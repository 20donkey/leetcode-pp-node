{"1":[],"2":[],"3":[],"4":[],"5":[],"6":[],"7":[],"8":[],"9":[],"10":[],"11":[],"12":[],"13":[],"14":[],"15":[],"16":[],"17":[],"18":[],"19":[],"20":[],"21":[],"22":[],"23":[],"24":[],"25":[],"26":[],"27":[],"28":[],"29":[],"30":[],"31":[],"32":[],"33":[],"34":[],"35":[],"36":[],"37":[],"38":[],"39":[],"40":[],"41":[],"42":[],"43":[],"44":[],"45":[],"46":[],"47":[],"48":[],"49":[],"50":[],"51":[],"52":[],"53":[],"54":[],"55":[],"56":[],"57":[],"58":[],"59":[],"60":[],"61":[],"62":[],"63":[],"64":[],"65":[],"66":[],"67":[],"68":[],"69":[],"70":[],"71":[],"72":[],"73":[],"74":[],"75":[],"76":[],"77":[],"78":[],"79":[],"80":[],"81":[],"82":[],"83":[],"84":[],"85":[],"86":[],"87":[],"88":[],"89":[],"90":[],"91":[],"839781960":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429561861","body":" 思路；返回数组转换为字符串相加的结果，转换回数组\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new ArrayList<>(); // 创建一个空的结果列表\r\n        int i = num.length - 1; // 从最高位开始处理\r\n        while (i >= 0 || k > 0) { // 如果num数组没有处理完或者k不为0\r\n            if (i >= 0) { // 如果num数组还有数\r\n                k += num[i]; // 将num[i]加到k中\r\n                i--; // 指向下一个num的下标\r\n            }\r\n            list.add(0, k % 10); // 将k的最低位添加到结果列表的最前面\r\n            k /= 10; // 去掉k的最低位\r\n        }\r\n        return list; // 返回结果列表\r\n    }\r\n}\r\n//时间空间复杂度O(N)\r\n\r\nclass Solution2 {\r\n    public static List<Integer> addToArrayForm(int[] num, int k) {\r\n        StringBuffer sb = new StringBuffer(); // 创建一个可变的字符串缓冲区\r\n        for (int i=0;i<num.length;i++) { // 遍历num数组\r\n            sb.append(num[i]); // 将num数组中的数添加到字符串缓冲区中\r\n        }\r\n        BigDecimal bg = new BigDecimal(sb.toString()).add(new BigDecimal(k)); // 将字符串缓冲区中的数和k相加\r\n        String countStr = bg.toString(); // 将相加的结果转换为字符串\r\n        List<Integer> list = new ArrayList<>(); // 创建一个空的结果列表\r\n        for (int i=0;i<countStr.length();i++) { // 遍历相加后的结果字符串\r\n            list.add(Integer.parseInt(String.valueOf(countStr.charAt(i)))); // 将结果字符串中的数添加到结果列表中\r\n        }\r\n        return list; // 返回结果列表\r\n    }\r\n}\r\n时间空间复杂度O(N)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431409004","body":"思路，但是错了\r\n//输出距离每个字母最近的e的下标->输入字串s,字符e。\r\n```java\r\nclass Solution{\r\n    public int[] shortestToChar(String s, char c) {\r\n        ArrayList<Integer> lst = new ArrayList<>();\r\n        int[] rt = new int[s.length()];\r\n        //得到arr\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) {\r\n                lst.add(i);\r\n            }\r\n        }\r\n        //遍历一遍\r\n        //遍历每个'e'字符3,5,611\r\n        for (int i = 0; i < lst.size(); i++) {\r\n            int e = lst.get(i); // 当前遍历到的'e'字符的下标\r\n            int j = e; // 初始化j为当前'e'字符的下标\r\n            while (j >= 0) {\r\n                int dist = e - j; // 计算当前字符到当前'e'字符的距离\r\n                // 如果rt[j]为0，说明当前位置之前没有出现过'e'字符，需要直接记录距离\r\n                // 或者当前位置到当前'e'字符的距离小于rt[j]，说明当前位置到当前'e'字符更近，需要更新rt[j]\r\n                if (rt[j] == 0 || dist < rt[j]) {\r\n                    rt[j] = dist; // 更新rt[j]为当前位置到当前'e'字符的距离\r\n                } else {\r\n                    break; // 如果当前位置到当前'e'字符的距离已经不再递减，说明已经找到最近的'e'字符，可以跳出循环\r\n                }\r\n                j--; // 继续向左遍历字符\r\n            }\r\n            j = e + 1; // 将j重置为当前'e'字符下标的下一个位置\r\n            while (j < s.length()) {\r\n                int dist = j - e; // 计算当前字符到当前'e'字符的距离\r\n                // 如果rt[j]为0，说明当前位置之前没有出现过'e'字符，需要直接记录距离\r\n                // 或者当前位置到当前'e'字符的距离小于rt[j]，说明当前位置到当前'e'字符更近，需要更新rt[j]\r\n                if (rt[j] == 0 || dist < rt[j]) {\r\n                    rt[j] = dist; // 更新rt[j]为当前位置到当前'e'字符的距离\r\n                } else if (dist == rt[j] && j < e) {\r\n                    // 当距离相等时，选择左边的字符\r\n                    rt[j] = dist;\r\n                    break;\r\n                } else {\r\n                    break; // 如果当前位置到当前'e'字符的距离已经不再递增，说明已经找到最近的'e'字符，可以跳出循环\r\n                }\r\n                j++; // 继续向右遍历字符\r\n            }\r\n        }\r\n        return rt;\r\n    }\r\n    \r\n} \r\n优化\r\n\r\n//给定一个字符串S和一个字符C，返回一个整数数组，其中每个元素表示字符C在字符串S中的距离。\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        // 创建int型数组rt，用于存放最终的距离结果\r\n        int[] rt = new int[s.length()];\r\n        // 遍历字符串S\r\n        for (int i = 0; i < s.length(); i++) {\r\n            // 如果字符S中当前字符等于目标字符C，距离为0\r\n            if (s.charAt(i) == c) {\r\n                rt[i] = 0;\r\n            }\r\n            // 否则以当前字符为中心，从左右向外扩散查找，直到找到目标字符C\r\n            else {\r\n                int j = i - 1; // 左边字符的位置\r\n                int k = i + 1; // 右边字符的位置\r\n                while (j >= 0 || k < s.length()) {\r\n                    // 如果左边字符的位置不越界且字符等于目标字符C，距离为当前字符和目标字符之间的距离\r\n                    if (j >= 0 && s.charAt(j) == c) {\r\n                        rt[i] = i - j;\r\n                        break;\r\n                    }\r\n                    // 如果右边字符的位置不越界且字符等于目标字符C，距离为当前字符和目标字符之间的距离\r\n                    else if (k < s.length() && s.charAt(k) == c) {\r\n                        rt[i] = k - i;\r\n                        break;\r\n                    }\r\n                    // 否则继续向外扩散查找\r\n                    j--;\r\n                    k++;\r\n                }\r\n            }\r\n        }\r\n        // 返回查找结果\r\n        return rt;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433295829","body":"//思路inc栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val\n```java\nclass Solution{\n    class CustomStack {\n        int maxSize;\n        int [] stk;\n        int top;\n\n        public CustomStack(int maxSize) {\n            this.maxSize = maxSize;\n            stk = new int[maxSize];\n            top = -1;\n        }\n        \n        public void push(int x) {\n            if(top<maxSize-1){\n                stk[++top]=x;\n            }\n        }\n        \n        public int pop() {\n            if(top<=0){\n                return -1;\n            }else{\n                int res = stack[top];\n                top--;\n                return res;\n            }\n        }\n        \n        public void increment(int k, int val) {\n            int l = Math.min(k,top+1);//1 <= maxSize, x, k <= 1000 \n            for(int i =0;i<l;i++){\n                stk[i] = stk[i]+val;\n            }\n        }\n    }\n} \n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434842640","body":"```java\n//思路 首先定义2个指针来解开括号\n//left找到左括号【\n//right找到对应的右】  需要用到栈,否则搞不开\n//找到前面的系数 numleft numright\n//递归\n\nimport java.util.Stack;\n\npublic class _394字符串解码 {\n    public String decodeString(String s) {\n        int left = 0 , right = 0;\n        char[] arr = s.toCharArray();\n        //left找到左括号【\n        for (int i = 0; i < s.length(); i++) {\n            if(arr[i]=='['){\n                left=i;\n            }\n        }\n        //right找1对应的】\n        Stack<Character> stk = new Stack<>();\n        for (int i = left+1; i < arr.length; i++) {\n            if(arr[i]=='['){//找到第2..个【 入栈\n                stk.push(arr[i]);\n            }else if(arr[i]==']'&&stk.isEmpty()){\n                right=i;//找到1对应的右】\n                break;\n            }\n            else if(arr[i]==']'&&!stk.isEmpty()){\n                stk.pop();\n            }\n        }\n        int numLeft = left -1,numRight = left -1;\n        while (numLeft>=0&&arr[numLeft]>='0'&&arr[numLeft]<='9'){//不越界且数字\n            numLeft--;//-1\n        }\n        //取出系数\n        int times = Integer.parseInt(s.substring(numLeft+1,numRight+1));//-1+1,右开\n        String sub = s.substring(left + 1, right);//被乘串\n        StringBuffer sb = new StringBuffer();//用来拼串\n        sb.append(s.substring(0,numLeft+1));\n        while (times>0){\n            sb.append(sub);\n            times--;\n        }\n        sb.append(s.substring(right+1));\n        return decodeString(sb.toString());\n    }\n\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435675661","body":"```java\n//思路2个栈 模拟队列\npublic class _232用栈实现队列 {\n        private Stack<Integer> inStack;\n        private Stack<Integer> outStack;\n        public _232用栈实现队列() {\n                inStack = new Stack<>();\n                outStack= new Stack<>();\n        }\n\n        public void push(int x) {\n                inStack.push(x);\n        }\n\n        public int pop() {\n                if(outStack.isEmpty()){\n                        while (!inStack.isEmpty()){\n                                outStack.push(inStack.pop());\n                        }\n                }\n                return  outStack.pop();\n        }\n\n        public int peek() {\n                int rt = this.pop();\n                outStack.push(rt);\n                return rt;\n        }\n\n        public boolean empty() {\n                return inStack.isEmpty()&& outStack.isEmpty();\n        }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436024133","body":"```java\n//思路子数组中的最大值小于后面未排序部分的最小值\npublic class _768最多能完成排序的块II {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        int last_pop = -1;\n        for (int i = 0; i < arr.length; i++) {\n            int num = arr[i];\n            if (stack.empty() || num >= stack.peek()) {\n                // 可以将栈中所有小于num的元素弹出\n                while (!stack.empty() && num < stack.peek()) {\n                    stack.pop();\n                }\n                last_pop = i;\n            }\n            stack.push(num);\n        }\n        // 如果栈中还有元素，它们组成的子数组也可以被单独排序\n        return arr.length - (last_pop + 1);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1438595335","body":"```java\r\n//思路：1.头部 head【0】和尾部head【head.length-1】相连拼成环形链表\r\n//     2.定义一个指针p1,p2指向head【head.length-1】，head[0]链表右移就是指针左移k个位置\r\n// if(k<head.length-1)  位置为head.length-1-k\r\n//if(k>head.length-1)   位置为head.length-1-k%(head.length-1)\r\npublic class _61旋转链表 {\r\n    public ListNode rotateRight(ListNode head,int k) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n\r\n        int n = 1;\r\n\r\n        ListNode tail = head;\r\n\r\n        while (tail.next != null) {\r\n            n++;\r\n            tail = tail.next;\r\n        }\r\n\r\n        tail.next = head;//首位相连\r\n        k=k%n;\r\n\r\n        ListNode new_tail = head;\r\n        for (int i = 0; i < n - 1 - k; i++) {//新尾点\r\n            new_tail = new_tail.next;\r\n        }\r\n        ListNode new_head = new_tail.next;//新头\r\n        new_tail.next=null;\r\n        return new_head;\r\n\r\n\r\n    }\r\n\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437259096","body":"明天看\npublic ListNode rotateRight(ListNode head, int k) {\n    if (head == null) {\n        return null;\n    }\n    int n = 1; // n表示链表的长度，初始值为1，因为head不为空\n    ListNode tail = head; // tail表示链表的尾节点，初始值为head\n    while (tail.next != null) { // 遍历链表，找到尾节点和链表长度\n        n++;\n        tail = tail.next;\n    }\n    tail.next = head; // 首尾相连，形成环形链表\n    k %= n; // 将k对n取余，简化处理k>=n的情况\n    if (k > 0) {\n        ListNode new_tail = head; // 找到新链表的尾节点\n        for (int i = 0; i < n-k-1; i++) { // 双指针寻找新链表的尾节点\n            new_tail = new_tail.next;\n        }\n        ListNode new_head = new_tail.next; // 找到新链表的头节点\n        new_tail.next = null; // 断开环形链表，使新链表成为单向链表\n        return new_head;\n    } else { // 如果k等于0，链表不需要旋转，直接返回原链表\n        return head;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440305218","body":"```java\npublic class _109有序链表转换二叉搜索树 {\n\n    public TreeNode sortedListToBST(ListNode head) {\n        //链表为空\n        if (head == null) {\n            return null;\n        }\n        //只有一个节点\n        if (head.next == null) {\n            return new TreeNode(head.val);\n        }\n        ListNode slow = head, fast = head, prev = null;\n\n        // 快慢指针找到链表的中间节点\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        // 以中间节点作为根节点构建二叉搜索树\n        TreeNode root = new TreeNode(slow.val);\n        prev.next = null; // 断开链表\n        root.left = sortedListToBST(head); // 递归构建左子树\n        root.right = sortedListToBST(slow.next); // 递归构建右子树\n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1442145791","body":"```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        //判空\n        if(headA==null||headB==null){\n            return null;\n        }\n        \n        ListNode pA=headA,pB=headB;\n        while(pA!=pB){\n            \n            if(pA==null){//a短\n                pA=headB;\n            }else{\n                pA=pA.next;\n            }\n            \n            if(pB==null){\n                pB=headA;\n            }else{\n                pB=pB.next;\n            }\n        }\n\n        return pA;\n    }\n}\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"954545647":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428935968","body":"### 思路\n\n逐位相加，从最后一位开始加起来，需要额外考虑剩余 1 的情况\n\n### 代码\n\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  let i = num.length - 1;\n  let res = [];\n  let carry = 0;\n  while (i >= 0 || k !== 0) {\n    const a = i >= 0 ? num[i] : 0;\n    const b = k !== 0 ? k % 10 : 0;\n    const sum = a + b + carry;\n    carry = sum >= 10 ? 1 : 0;\n    res.push(sum % 10);\n    // 更新边界条件\n    k = Math.floor(k / 10);\n    i--;\n  }\n  if (carry) res.push(carry);\n  return res.reverse();\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430709353","body":"### 思路\n\n先记录 S 中存在字符 C 的位置，然后二次 for 循环去遍历\n\n### 代码\n\n```javascript\nvar shortestToChar = function (S, C) {\n  // 记录 C 字符在 S 字符串中出现的所有下标\n  var hasCArr = [];\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) hasCArr.push(i);\n  }\n\n  // 结果数组 res\n  var res = Array(S.length).fill(Infinity);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) {\n      res[i] = 0;\n      continue;\n    }\n\n    // 非目标字符，到下标数组中找最近的下标\n    for (const cIndex of hasCArr) {\n      const dist = Math.abs(cIndex - i);\n      if (dist >= res[i]) break;\n      res[i] = dist;\n    }\n  }\n  return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432293551","body":"### 思路\r\n\r\n根据要求写代码\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.list = [];\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  const len = this.list.length;\r\n  if (len >= this.maxSize) return;\r\n  this.list.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  const len = this.list.length;\r\n  if (len === 0) return -1;\r\n  return this.list.pop();\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  const maxVal = Math.min(k, this.list.length);\r\n  for (let i = 0; i < maxVal; i++) {\r\n    this.list[i] += val;\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：push、pop：O(1) increment:O(N)。\r\n- 空间复杂度：O(maxSize)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1433935706","body":"### 思路\n\n利用辅助栈的思路，遇到【 入栈，遇到 】出栈\n\n### 代码\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\n\n// 输入：s = \"3[a]2[bc]\"\n// 输出：\"aaabcbc\"\n// 输入：s = \"3[a2[c]]\"\n// 输出：\"accaccacc\"\n// 输入：s = \"abc3[cd]xyz\"\n// 输出：\"abccdcdcdxyz\"\nvar decodeString = function (s) {\n  const temp = [];\n  let res = '';\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    const cur = s[i];\n    // 数字类型\n    if (Number.isInteger(Number(cur))) {\n      count = Number(count + cur);\n      continue;\n      // 分界线\n    } else if (cur === '[') {\n      temp.push([res, count]);\n      res = '';\n      count = 0;\n      continue;\n    } else if (cur === ']') {\n      const [str, count] = temp.pop();\n      const val = res.repeat(count);\n      res = str + val;\n      continue;\n    } else {\n      res += cur;\n    }\n  }\n  return res;\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435690072","body":"\n### 代码\n\n```js\nvar MyQueue = function() {\n  this.list = [];\n  this.help = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.list.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n   // 这里要多加一层判断的原因是辅助栈的元素需要先处理\n  if(!this.help.length)  { \n    while(this.list.length){\n      this.help.push(this.list.pop());\n    }\n  }\n  return this.help.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  if(!this.help.length)  {\n    while(this.list.length){\n      this.help.push(this.list.pop());\n    }\n  }\n  return this.help[this.help.length-1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return !this.list.length && !this.help.length;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435809463","body":"### 思路\n计数思维，排序后的数组和乱序的合是一样的\n\n### 代码\n\n```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n  const newArr = [...arr].sort((a, b) => a - b);\n  // 滑动窗口\n  let res = 0;\n  let sum1 = 0;\n  let sum2 = 0;\n  for (let i = 0; i < newArr.length; i++) {\n    let cur = arr[i];\n    let newCur = newArr[i];\n    sum1 += cur;\n    sum2 += newCur;\n    if (sum1 === sum2) {\n      res++;\n    }\n  }\n  return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(NlogN) 排序时间\n- 空间复杂度：O(N) 数组长度\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436157087","body":"### 思路\n\n暴力解法：先计算链表长度\n\n### 代码\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n  if (!head || !head.next) return head;\n  let length = 0;\n  let temp = head;\n  // 计算链表长度\n  while (temp) {\n    temp = temp.next;\n    ++length;\n  }\n  // 优化旋转个数\n  k = k % length;\n  if (k === 0) return head;\n  let slow = (fast = head);\n  // 快慢指针，找到倒数第K个元素\n  while (fast.next) {\n    if (k-- <= 0) {\n      slow = slow.next;\n    }\n    fast = fast.next;\n  }\n  fast.next = head;\n  // 第K+1个元素先暂存\n  let res = slow.next;\n  slow.next = null;\n  return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437707373","body":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function (head) {\n  if (!head || !head.next) return head;\n  let dummy = new ListNode(0);\n  dummy.next = head; // preHead\n  let help = head;\n  let res = head.next; // 返回的结果\n  while (help && help.next) {\n    let nextNode = help.next;\n    let nnNode = nextNode.next;\n    help.next = nnNode;\n    nextNode.next = help;\n    dummy.next = nextNode;\n    dummy = help;\n    help = nnNode;\n  }\n  return res;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439279835","body":"### 思路\n用快慢指针\n\n### 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function (head) {\n  if (!head) return head;\n  return dfs(head, null);\n};\n\nfunction dfs(head, tail) {\n  if (head == tail) return null;\n  let fast = head;\n  let slow = head;\n  while (fast !== tail && fast.next !== tail) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  let root = new TreeNode(slow.val);\n  root.left = dfs(head, slow);\n  root.right = dfs(slow.next, tail);\n  return root;\n}\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：nLogN\n- 空间复杂度：logN","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441077340","body":"### 思路\n\n哈希法：\n因为两个链表会有交点，所以可以先让第一个链表做一个标记，然后再去遍历第二个链表\n\n### 代码\n\n```javascript\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function (headA, headB) {\n  while (headA) {\n    headA.flag = true;\n    headA = headA.next;\n  }\n  while (headB) {\n    if (headB.flag) return headB;\n    headB = headB.next;\n  }\n  return null;\n};\n\n// 或者可以使用数组\nvar getIntersectionNode = function (headA, headB) {\n  let data = new Set();\n  while (headA) {\n    data.push(headA);\n    headA = headA.next;\n  }\n  while (headB) {\n    if (data.has(headB)) return headB;\n    headB = headB.next;\n  }\n  return null;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442637185","body":"### 思路\n\n哈希法：\n遍历链表，将每个值都保存到 hash 表中，如果存在重复则该节点是入口节点\n\n### 代码\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\n\nvar detectCycle = function (head) {\n  if (!head || !head.next) return null;\n  let arr = new Set();\n  while (head) {\n    if (arr.has(head)) return head;\n    arr.add(head);\n    head = head.next;\n  }\n  return null;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445139975","body":"### 思路\n\n双向链表+hashmap\n\n### 代码\n\n```js\nclass DoubleLinkedListNode {\n  constructor(key,value) {\n    this.key = key;\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\nclass LRUCache {\n  constructor(capacity){\n    this.capacity = capacity;\n    this.hashmap = {}\n    this.useSize = 0;\n    this.dummyHead= new DoubleLinkedListNode(null,null);\n    this.dummyTail= new DoubleLinkedListNode(null,null);\n    this.dummyHead.next = this.dummyTail;\n    this.dummyTail.prev = this.dummyHead;\n  }\n\n  _isFull(){\n    return this.useSize === this.capacity;\n  }\n\n  _removeNode(node){\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n    node.prev = null;\n    node.next = null;\n    return node;\n  }\n\n  _addToHead(node){\n    const head = this.dummyHead.next;\n    node.next = head;\n    node.prev = this.dummyHead;\n    this.dummyHead.next = node;\n    head.prev = node;\n  }\n\n  get(key){\n    if(this.hashmap[key]){\n      const node = this.hashmap[key];\n      const removeNode = this._removeNode(node);\n      this._addToHead(removeNode);\n      return node.value;\n    }else{\n      return -1;\n    }\n  }\n\n  put(key,val){\n    if(this.hashmap[key]){\n      const node = this.hashmap[key];\n      node.value = val;\n      this._addToHead(this._removeNode(node)) \n    }else{\n      if(this._isFull()){\n        // 先获取最后一个\n        const node = this.dummyTail.prev;\n        this._removeNode(node);\n        delete this.hashmap[node.key];\n        this.useSize--;\n      }\n\n      const node = new DoubleLinkedListNode(key,val);\n      this.hashmap[key] = node;\n      this._addToHead(node)\n      this.useSize++\n    }\n  }\n}\n\n\n```\n\n### 复杂度分析\n\n+ 空间复杂度 O(n)\n+ 时间复杂度 O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445237377","body":"### 思路\n\n递归\n\n### 代码\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function (root) {\n  if (!root) return 0;\n  return Math.max(maxDepth(root.left) + 1, maxDepth(root.right) + 1);\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445541947","body":"### 思路\n\n递归求解，注意边界条件\n\n### 代码\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function (p, q) {\n  if ((p === null && q !== null) || (p !== null && q === null)) return false;\n  if (p === q) return true;\n  if (p.val !== q.val) return false;\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};\n```\n\n**复杂度分析**\nN 都为树节点的个数\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447517218","body":"### 思路\n\n递归出口为叶子节点：当前节点的左右节点均为 null\n\n### 代码\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function (root) {\n  const helper = (root, cur) => {\n    if (root === null) return 0;\n    cur = 10 * cur + root.val;\n    if (root.left === null && root.right === null) return cur;\n    return helper(root.left, cur) + helper(root.right, cur);\n  };\n  return helper(root, 0);\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449143218","body":"### 思路\n\n两种思路：递归 和 BFS\n\n### 代码\n\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\n\nvar findBottomLeftValue = function (root) {\n  if (!root) return root;\n  let arr = [root];\n  let res = root;\n  while (arr.length) {\n    let cur = arr.shift();\n    if (cur.right) arr.push(cur.right);\n    if (cur.left) arr.push(cur.left);\n    if (cur.left) {\n      res = cur.left;\n    } else if (cur.right) {\n      res = cur.right;\n    }\n  }\n  return res.val;\n};\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451120096","body":"### 思路\n\n两种思路：递归 和 BFS\n\n### 代码\n\n```javascript\n// BFS\nconst serialize = (root) => {\n  const queue = [root];\n  let res = [];\n  while (queue.length) {\n    const node = queue.shift(); // 考察出列的节点\n    if (node) {\n      // 是真实节点，带出子节点入列\n      res.push(node.val); // 节点值推入res\n      queue.push(node.left); // 子节点入列，不管是不是null节点都入列\n      queue.push(node.right);\n    } else {\n      // 是null节点，没有子节点入列\n      res.push('X'); // X 推入res\n    }\n  }\n  return res.join(','); // 转成字符串\n};\n\nconst deserialize = (data) => {\n  if (data == 'X') return null;\n\n  const list = data.split(','); // 序列化字符串split成数组\n\n  const root = new TreeNode(list[0]); // 获取首项，构建根节点\n  const queue = [root]; // 根节点推入队列\n  let cursor = 1; // 初始指向list第二项\n\n  while (cursor < list.length) {\n    // 指针越界，即扫完了序列化字符串\n    const node = queue.shift(); // 考察出列的节点\n\n    const leftVal = list[cursor]; // 它的左儿子的值\n    const rightVal = list[cursor + 1]; // 它的右儿子的值\n\n    if (leftVal != 'X') {\n      // 是真实节点\n      const leftNode = new TreeNode(leftVal); // 创建左儿子节点\n      node.left = leftNode; // 认父亲\n      queue.push(leftNode); // 自己也是父亲，入列\n    }\n    if (rightVal != 'X') {\n      const rightNode = new TreeNode(rightVal);\n      node.right = rightNode;\n      queue.push(rightNode);\n    }\n    cursor += 2; // 一次考察一对儿子，指针加2\n  }\n  return root; // BFS结束，构建结束，返回根节点\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1452788009","body":"### 思路\n\n先用递归记录树的每一层数据，然后排序，最后最数据进行简单处理\n\n### 代码\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function (root) {\n  let row = (col = 0);\n  let res = [];\n  const dfs = (root, row, col, res) => {\n    if (!root) return;\n    res.push({\n      row,\n      col,\n      val: root.val\n    });\n    dfs(root.left, row + 1, col - 1, res);\n    dfs(root.right, row + 1, col + 1, res);\n  };\n  dfs(root, row, col, res);\n  res.sort((a, b) => {\n    const colA = a.col;\n    const colB = b.col;\n    if (colA === colB) {\n      if (a.row === b.row) return a.val - b.val;\n      return a.row - b.row;\n    }\n    return colA - colB;\n  });\n\n  console.log(res);\n  const resList = [];\n\n  for (let i = 0; i < res.length; i++) {\n    let temp = [];\n    const cur = res[i];\n    temp.push(cur.val);\n    while (res[i + 1] && res[i + 1].col === cur.col) {\n      temp.push(res[i + 1].val);\n      i++;\n    }\n    resList.push(temp);\n  }\n  return resList;\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454655885","body":"### 思路\n\n使用一个map来帮忙\n\n### 代码\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\n var twoSum = function(nums, target) {\n  const len = nums.length;\n  const map = new Map();\n  for(let i= 0; i <len; i++){\n    const cut = target-nums[i];\n    if(map.has(cut)){\n      return [map.get(cut),i]\n    }else{\n      map.set(nums[i],i)\n    }\n  }\n};\n```\n\n### 复杂度分析\n\n+ 时间复杂度 O(n)\n+ 空间复杂度 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455267792","body":"### 思路\n\n哈希法：用哈希表记录每一个值的出现次数，然后再对原数组去重，再根据出现次数排序\n\n### 代码\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function (nums, k) {\n  var map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    let cur = nums[i];\n    if (map.has(cur)) {\n      map.set(cur, map.get(cur) + 1);\n    } else {\n      map.set(cur, 1);\n    }\n  }\n  return [...new Set(nums)].sort((a, b) => map.get(b) - map.get(a)).slice(0, k);\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455277458","body":"### 代码\n\n```javascript\nvar numberOfBoomerangs = function (points) {\n  let res = 0;\n  for (const p of points) {\n    const map = new Map();\n    for (const q of points) {\n      const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n      map.set(dis, (map.get(dis) || 0) + 1);\n    }\n    console.log(map);\n    for (const [_, m] of map.entries()) {\n      res += m * (m - 1);\n    }\n  }\n  return res;\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457297021","body":"### 思路\n\n使用 map 来存储当前已经遍历过的字符，key 为字符，value 为下标\n\n使用 i 来标记无重复子串开始下标，j 为当前遍历字符下标\n\n遍历字符串，判断当前字符是否已经在 map 中存在，存在则更新无重复子串开始下标 i 为相同字符的下一位置，此时从 i 到 j 为最新的无重复子串，更新 max ，将当前字符与下标放入 map 中\n\n最后，返回 max 即可\n\n\n### 代码\n\n```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function (s) {\n  let map = new Map();\n  let max = 0;\n  for (let i = 0, j = 0; j < s.length; j++) {\n    if (map.has(s[j])) {\n      i = Math.max(map.get(s[j]) + 1, i);\n    }\n    max = Math.max(max, j - i + 1);\n    map.set(s[j], j);\n  }\n  return max;\n};\n```\n\n**复杂度分析**\nN 为数组长度\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459105695","body":"### 思路\n\nLucifer 的解法翻译\n\n### 代码\n\n```javascript\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\n// 1. 从 words 入手，words 所有单词排列生成字符串 X, 通过字符串匹配查看 X 在 s 中的出现位置\n// 2. 从 s 串入手，遍历 s 串中所有长度为 (words[0].length * words.length) 的子串 Y，查看 Y 是否可以由 words 数组构造生成\n\nvar findSubstring = function (s, words) {\n  const len = words[0]?.length || 0;\n  const map = {};\n  const res = [];\n  //   哈希表，记录单词出现次数\n  for (let word of words) {\n    map[word] = (map[word] || 0) + 1;\n  }\n  //   遍历所有字串\n  for (let i = 0; i < s.length; i++) {\n    const cache = { ...map };\n    for (let j = 0; j < words.length; j++) {\n      // 由于 words 的单词长度相同，因此 i+j*len 就是下一个 parts 的起点\n      //   由于每个 parts 的长度也是固定的 words[0]\n      const curSub = s.substr(i + j * len, len);\n      if (!cache[curSub]) {\n        //   对应不上，意味着此种方法分割不正确，尝试下一种\n        break;\n      } else {\n        //   找到一个做解法\n        cache[curSub]--;\n        // 如果到末尾都没有发现不正确，那么我们就得到了一种可行解\n        if (j === words.length - 1) {\n          res.push(i);\n        }\n      }\n    }\n  }\n  return res;\n};\n```\n\n**复杂度分析**\nN 为数组长度\n\n- 时间复杂度：O(n\\*m) n 为字符串长度，m 为 words 数组字符长度\n- 空间复杂度：O(m) m 为 words 数组长度\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461173672","body":"```js\n/**\n * @param {number[]} nums\n * @param {number} p\n * @return {number}\n */\nvar minSubarray = function (nums, p) {\n\n  const L = nums.length;\n  let count = 0;\n  for (let i = 0; i < L; i++) {\n    count += nums[i]\n  }\n\n  let canDivideP = count % p;\n  if (canDivideP == 0) {\n    return 0;\n  }\n\n  const map = new Map;\n  let curCount = 0;\n  let res = Infinity;\n  map.set(0, -1);\n  for (let i = 0; i < L; i++) {\n    curCount += nums[i];\n    const curPos = (curCount - canDivideP + p) % p;\n    if (map.has(curPos)) {\n      res = Math.min(res, i - map.get(curPos));\n      if (res == 1 && L > 1) {\n        return res;\n      }\n    }\n    map.set(curCount % p, i)\n  }\n  res >= L && (res = Infinity);\n  return res === Infinity ? -1 : res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463027832","body":"### 思路\n\n快慢指针，快指针一次走两步，当为空时，慢指针就是中间结点\n\n### 代码\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function (head) {\n  let slow = head;\n  let fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  return slow;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N) 链表长度\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464799248","body":"```js\nvar removeDuplicates = function(nums) {\n  const len = nums.length;\n  if(len === 0 || len === 1) return nums;\n  let left = 0;\n  let right = 0;\n  for(let i = 0; i < len; i++){\n    const leftVal = nums[left];\n    const rightVal = nums[right];\n    if(leftVal !== rightVal) {\n      left++;\n      nums[left] = rightVal;\n    }\n    right++\n  }\n  return left+1;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465060122","body":"```js\nvar searchInsert = function (nums, target) {\n  let len = nums.length;\n  let left = 0;\n  let right = len - 1;\n  while (left <= right) {\n    const middle = Math.floor((right + left) / 2)\n    const cur = nums[middle];\n    if (cur === target) {\n      return middle;\n    } else if (cur > target) {\n      right = middle - 1;\n    } else {\n      left = middle + 1;\n    }\n  }\n  return left;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465414460","body":"```js\n// 滑动窗口\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function (nums, k) {\n  let n = nums.length;\n  class slideWindow {\n    constructor() {\n      this.data = [];\n    }\n    push(val) {\n      let data = this.data;\n      // 保证数据从队头到队尾递减\n      while (data.length > 0 && data[data.length - 1] < val) {\n        data.pop();\n      }\n      data.push(val);\n    }\n    pop(val) {\n      let data = this.data;\n      if (data.length > 0 && data[0] === val) {\n        // 这里的js实现shift()理论上复杂度应该是O(k), 就不去真实实现一个O(1)出队的队列了，意思到位即可\n        data.shift();\n      }\n    }\n    max() {\n      return this.data[0];\n    }\n  }\n  let res = [];\n  let windows = new slideWindow();\n  debugger;\n  for (let i = 0; i < n; i++) {\n    if (i < k - 1) {\n      windows.push(nums[i]);\n    } else {\n      windows.push(nums[i]);\n      res.push(windows.max());\n      windows.pop(nums[i - k + 1]);\n    }\n  }\n  return res;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467180632","body":"```js\n// 最好还是分开两个数组更加直观一点\n// 可以直接统计入度和出度的差，因为我们要找的是入度和出度差为 n -1 的点。这样可以将两个数组降低为一个数组，不过复杂度是一样的。\nvar findJudge = function (n, trust) {\n  const count = new Array(n + 1).fill(0);\n  for (const edge of trust) {\n    const x = edge[0];\n    const y = edge[1];\n    count[y]++;\n    count[x]--;\n  }\n  console.log(count)\n  for (let i = 1; i <= n; ++i) {\n    if (count[i] === n - 1) {\n      return i;\n    }\n  }\n  return -1;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469087258","body":"```js\n\n/**\n * @param {number} n\n * @param {number[][]} dislikes\n * @return {boolean}\n */\nconst possibleBipartition = (N, dislikes) => {\n  let graph = [...Array(N + 1)].map(() => Array()), // 动态创建二维数组\n    colors = Array(N + 1).fill(-1);\n\n  console.log(graph, colors)\n\n  // build the undirected graph\n  for (const d of dislikes) {\n    graph[d[0]].push(d[1]);\n    graph[d[1]].push(d[0]);\n  }\n\n  console.log(graph)\n\n\n  const dfs = (cur, color = 0) => {\n    colors[cur] = color;\n    for (const nxt of graph[cur]) {\n      if (colors[nxt] !== -1 && colors[nxt] === color) return false; // conflict\n      if (colors[nxt] === -1 && !dfs(nxt, color ^ 1)) return false;\n    }\n    return true;\n  };\n\n  for (let i = 0; i < N; ++i) if (colors[i] === -1 && !dfs(i, 0)) return false;\n\n  return true;\n};\n\nconsole.log(possibleBipartition(4, [[1, 2], [1, 3], [2, 4]]))\n// console.log(possibleBipartition(10,\n//   [[6, 9], [1, 3], [4, 8], [5, 6], [2, 8], [4, 7], [8, 9], [2, 5], [5, 8], [1, 2], [6, 7], [3, 10], [8, 10], [1, 5], [3, 6], [1, 10], [7, 9], [4, 10], [7, 10], [1, 4], [9, 10], [4, 6], [2, 7], [6, 8], [5, 7], [3, 8], [1, 8], [1, 7], [7, 8], [2, 4]]))\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1472943983","body":"```js\n/**\n * @param {string} moves\n * @return {boolean}\n */\nvar judgeCircle = function (moves) {\n  const list = moves.split(\"\")\n  const map = {\n    \"L\": 0,\n    \"R\": 0,\n    \"U\": 0,\n    \"D\": 0\n  }\n  for (const dir of moves) {\n    map[dir] = map[dir] + 1;\n  }\n  const leftVal = map[\"L\"];\n  const rightVal = map[\"R\"];\n  const upVal = map[\"U\"];\n  const downVal = map[\"D\"];\n  return leftVal === rightVal && upVal === downVal\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475052079","body":"```js\nfunction numberOfRounds(startTime, finishTime) {\n  // 将开始时间和结束时间分割为小时和分钟\n  let [sh, sm] = startTime.split(\":\").map(Number);\n  let [eh, em] = finishTime.split(\":\").map(Number);\n\n  // 初始化一个变量以跟踪天数\n  let d = 0;\n\n  // 如果结束时间早于开始时间，则将结束时间增加一天\n  if (sh * 60 + sm > eh * 60 + em) d += 1;\n\n  // 将开始时间四舍五入到最接近的 15 分钟\n  if (0 < sm && sm <= 15) {\n    sm = 15;\n  } else if (15 < sm && sm <= 30) {\n    sm = 30;\n  } else if (30 < sm && sm <= 45) {\n    sm = 45;\n  } else if (45 < sm && sm <= 60) {\n    sm = 0;\n    sh += 1;\n  }\n\n  // 将结束时间四舍五入到最接近的 15 分钟\n  if (0 <= em && em < 15) {\n    em = 0;\n  } else if (15 <= em && em < 30) {\n    em = 15;\n  } else if (30 <= em && em < 45) {\n    em = 30;\n  } else if (45 <= em && em < 60) {\n    em = 45;\n  }\n\n  // 将开始时间和结束时间转换为分钟\n  const st = sh * 60 + sm;\n  let et = eh * 60 + em;\n\n  // 如果结束时间在下一天，则将其增加 24 小时\n  if (d === 1) et += 24 * 60;\n\n  // 计算开始时间和结束时间之间的 15 分钟间隔数\n  // 四舍五入到最接近的整数\n  return Math.max(0, et - st) / 15 | 0;\n}\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1541732340":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"michaelxi3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darknightwriter":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"findlayzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuwf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lbc546":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zch-bit":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frankelzeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhaodev":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joeymoso":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hackbl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiyishuoshuo":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429017592","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        //用LinkedList不断从头将位数和加入index 0\n        List<Integer> res = new LinkedList<>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; i--) {\n            //从末尾往前扫，加和取余的值\n            res.add(0, (num[i] + k) % 10);\n            //更新k存进位carry\n            k = (num[i] + k) / 10;\n        }\n\n        // post-possing: 处理k位数大于num的情况剩下的部分\n        // Time = O(log(k))\n        while (k > 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aouos":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wengzhouyunfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whisht":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzzkains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenmengyu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uancen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuomituxedo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongranherz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gr52":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hydelovegood":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nikojxie":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429253540","body":"### 思路：\r\n逐位相加 进位+1\r\n\r\n### 代码：\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n  const result = []\r\n  let index = num.length - 1, overTen = false, current = 0\r\n  while(index >=0 || k > 0 || overTen) {\r\n    current = (num[index] || 0) + (k % 10 || 0) + overTen\r\n    result.unshift(current % 10)\r\n    index--\r\n    k = Math.floor(k / 10)\r\n    overTen = current >= 10\r\n  }\r\n  return result\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430684438","body":"### 思路\n遍历每一个字符，再用两个指针同时遍历其左右的字符，找到就退出循环\n\n### 代码\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n  const answer = new Array(s.length)\n  for(let index = 0; index < s.length; index ++) {\n    const str = s[index]\n    let left = index, right = index + 1\n    while(left >= 0 || right < s.length) {\n      if(s[left] === c) {\n        answer[index] = index - left\n        break\n      }\n      if(s[right] === c) {\n        answer[index] = right - index\n        break\n      }\n      left --\n      right ++\n    }\n  }\n  return answer\n};\n```\n\n### 复杂度\n- 时间复杂度： O(n^2)\n- 空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432557533","body":"### 思路\n定义一个数组和一个maxSize，push和pop时判断边界，increament时遍历加value\n\n### 代码\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.stack = []\n  this.size = maxSize\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if(this.stack.length < this.size) {\n    this.stack.push(x)\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if(this.stack.length) {\n    return this.stack.pop()\n  }\n  return -1\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  k = Math.min(k, this.stack.length)\n  for(let i = 0; i < k; i++) {\n    this.stack[i] += val\n  }\n};\n\n```\n\n### 复杂度\n- 时间复杂度：O(min(k, size))\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441168830","body":"### 思路\r\na链表.length + b链表.length === b链表.length + a链表.length，如果有相交，在中间一定会相遇\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let a = headA, b = headB\r\n    while(a != b) {\r\n      a = a ? a.next : headB\r\n      b = b ? b.next : headA\r\n    }\r\n    return a\r\n};\r\n```\r\n\r\n### 复杂度\r\n- 时间复杂度 O(m+n) m,n分别为两个链表的长度\r\n- 空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fangxianshen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jokertzw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyang258":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kernelsue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erikahuang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuang-mou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iloveqier":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429027822","body":"# 思路\n\t原地计算 数组num倒序加上k的和的余数作为num的每一位 循环中k/10参与下一次计算 将num放到list中 对于k的长度大于num长度的 继续将k剩余的长度一次添加到list头的位置上  \n# 算法复杂度\n\t时间复杂度 O(max(n,log k)) 空间复杂度O(max(n,log k)) n为数组长度 k为参数k\n# 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new ArrayList<>();\n        int carry = k;\n        for (int i = num.length - 1; i >= 0&&carry != 0; i--) {\n            int sum = num[i] + carry;\n            carry = sum / 10;\n            num[i]=sum%10;\n        }\n        for(int i:num){\n            ans.add(i);\n        }\n        while (carry > 0) {\n            ans.add(0, carry % 10);\n            carry = carry / 10;\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430646933","body":"# 思路\n\t一次遍历 回头赋值\n# 复杂度\n\t时间复杂度 O(n) 空间复杂度 O(1)\n# 代码\n```java\nclass Solution {\n    public static int[] shortestToChar(String s, char c) {\n        int index = s.length(), i = -1;\n        int[] ans = new int[s.length()];\n        for (char a : s.toCharArray()) {\n            i++;\n            if (a == c) {\n                //当前下标的字母为标记字母\n                ans[i] = 0;\n                int k = i;\n                index = i;\n                //向前遍历 直到数组中某位的值＜当前位置和该值下标的差\n                while (k >= 1 && ans[--k] > i - k) {\n                    ans[k] = i - k;\n                }\n            }\n            ans[i] = Math.abs(i - index);\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432667078","body":"# 思路\n\t使用额外的数组存储increment需要增加的值和下标，在输出的时候增加这个值\n# 复杂度\n\t时间复杂度O(1) 空间复杂度O(maxSize)\n# 代码\n```java\nclass CustomStack {\n        int[] ans;\n        int index = 0;\n        int[] incres;\n\n        public CustomStack(int maxSize) {\n            ans = new int[maxSize];\n            incres = new int[maxSize];\n        }\n\n        public void push(int x) {\n            if (index < ans.length) {\n                ans[index++] = x;\n            }\n\n        }\n\n        public int pop() {\n            if (index <= 0) {\n                return -1;\n            }\n            int k = ans[--index] + incres[index];\n            if (index > 0) {\n                incres[index - 1] += incres[index];\n            }\n            incres[index] = 0;\n            return k;\n        }\n\n        public void increment(int k, int val) {\n            int temp = Math.min(k-1 , index - 1);\n            if(temp<0){\n                return;\n            }\n            incres[temp] += val;\n        }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434227801","body":"# 思路\n\t双栈 数字栈存储每一层的数字 字符串栈存储每一层外层的字符串 左括号储存 右括号取数并拼接\n# 复杂度\n\t时间复杂度 O(n) 空间复杂度O(n)\n# 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<Integer> numberDeque = new LinkedList<>();\n        Deque<String> stringDeque = new LinkedList<>();\n        StringBuilder stringBuilder = new StringBuilder();\n\n        int number = 0;\n        for (char c : s.toCharArray()) {\n            if (c == ']') {\n                StringBuilder temp = new StringBuilder();\n                temp.append(String.valueOf(stringBuilder).repeat(numberDeque.pop()));\n                stringBuilder = temp.insert(0, stringDeque.pop());\n            } else if (c == '[') {\n                numberDeque.push(number);\n                stringDeque.push(stringBuilder.toString());\n                number = 0;\n                stringBuilder = new StringBuilder();\n            } else if (c >= '0' && c <= '9') {\n                number = number * 10 + (c - '0');\n            } else {\n                stringBuilder.append(c);\n            }\n        }\n        return stringBuilder.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435645468","body":"\n# 思路\n\t双栈 head存栈 tail出栈 当tail为空的时候 将head依次出栈 tail入栈 \n\t每个元素最多只会执行两次入栈 两次出栈的操作 \n# 复杂度\n\t时间复杂度 平均O(1) 空间复杂度O(n)\n# 代码\n ```java\n class MyQueue {\n        Deque<Integer> head;\n        Deque<Integer> tail;\n        \n        public MyQueue() {\n            head = new LinkedList<>();\n            tail = new LinkedList<>();\n        }\n\n        public void push(int x) {\n            tail.push(x);\n        }\n\n        public int pop() {\n            if (tail.isEmpty()) {\n                switchStack();\n            }\n            return tail.pop();\n        }\n\n        public int peek() {\n            if (tail.isEmpty()) {\n                switchStack();\n            }\n            return tail.peek();\n        }\n\n        private void switchStack() {\n            while (!head.isEmpty()) {\n                tail.push(head.pop());\n            }\n        }\n\n        public boolean empty() {\n            return tail.isEmpty() && head.isEmpty();\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435866814","body":"# 思路\r\n\t单调栈 大于栈顶的值入栈 小于栈顶的值 出栈 直到栈顶的值大于当前值或栈空 \r\n# 复杂度\r\n\t时间复杂度O(n) 空间复杂度O(n)\r\n# 代码\r\n```java\r\npublic static int maxChunksToSorted(int[] arr) {\r\n        int[] stack = new int[arr.length];\r\n        int index = 0;\r\n        stack[index] = arr[0];\r\n        for (int i = 1; i < arr.length; i++) {\r\n            if (stack[index] > arr[i]) {\r\n                int k = stack[index];\r\n                while (index >= 0 && stack[index] > arr[i]) {\r\n                    k = Math.max(stack[index--], k);\r\n                }\r\n                stack[++index] = k;\r\n            } else {\r\n                stack[++index] = arr[i];\r\n            }\r\n        }\r\n        return index + 1;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436195573","body":"# 思路\n\t成环再拆环\n# 复杂度\n\t时间复杂度O(n) 空间复杂度O(1)\n# 代码\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null||k==0){\n            return head;\n        }\n        ListNode tail  = head,temp = head;\n        int length = 1;\n        while(tail.next!=null){\n            tail = tail.next;\n            length++;\n        }\n        tail.next = head;\n        tail = tail.next;\n        k = length - k % length;\n        for(int i=0;i<k;i++){\n            temp = tail;\n            tail = tail.next;\n        }\n        temp.next=null;\n        return tail;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437773221","body":"# 思路\n  迭代 每次向后遍历两位 交换他们的位置\n# 复杂度\n  时间复杂度 O(n) 空间复杂度O(1)\n\n\n# 代码\n```java\nclass Solution {\n    public static ListNode swapPairs(ListNode head) {\n        ListNode temp = new ListNode(0,head);\n        ListNode ans = temp;\n        while(head!=null&&head.next!=null){\n            temp.next = temp.next.next;\n            head.next = head.next.next;\n            temp.next.next = head;\n            head = head.next;\n            temp = temp.next.next;\n        }\n        return ans.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440218853","body":"# 思路\n\t查找中间节点作为树的根节点，再对左右两边的链表分别建树\n\n# 复杂度\n\t时间复杂度O(n) 空间复杂度O(n)\n# 代码\n```java\nclass Solution {\n      public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441284097","body":"# 思路\n\t先计算两个链表的长度 再将长链表长的头截去 再依次判断后续节点是否相同\n# 复杂度\n\t时间复杂度O(m+n) 空间复杂度 O(1)\n# 代码\n```java\n\tpublic class Solution {\n        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n            ListNode planA = headA, planB = headB;\n            int lengthA = 0, lengthB = 0;\n            while (planA != null) {\n                lengthA++;\n                planA = planA.next;\n            }\n            while (planB != null) {\n                lengthB++;\n                planB = planB.next;\n            }\n            planA = headA;\n            planB = headB;\n            if (lengthA > lengthB) {\n                for (int i = 0; i < lengthA - lengthB; i++) {\n                    planA = planA.next;\n                }\n            } else {\n                for (int i = 0; i < lengthB - lengthA; i++) {\n                    planB = planB.next;\n                }\n            }\n            while (planA != null) {\n                if (planA == planB) {\n                    return planA;\n                } else {\n                    planA = planA.next;\n                    planB = planB.next;\n                }\n            }\n            return null;\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1445032560","body":"# 思路\n\t快慢指针找到相交的位置 相交位置到接环处的距离为从头到接环处的距离\n# 复杂度\n\t时间复杂度O(n) 空间复杂度O(1)\n# 代码\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head==null||head.next==null){\n            return null;\n        }\n        ListNode fast= head,low = head;\n        while(fast.next!=null&&fast.next.next!=null){\n            fast = fast.next.next;\n            low = low.next;\n            if(fast==low){\n                low = head;\n                while(fast.next!=null&&low.next!=null){\n                    if(fast==low){\n                        return fast;\n                    }\n                    fast = fast.next;\n                    low = low.next;\n                }\n            }\n        }\n        return null;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445055153","body":"# 思路\n\t双端链表和hash结构记录\n# 复杂度\n\t时间复杂度O(1) 空间复杂度O(n)\n# 代码\n```java\n class LRUCache {\n        Map<Integer, DoubleListNode> cache;\n        //ArrayList<DoubleListNode> keyList;\n        int max;\n        int len;\n        DoubleListNode head;\n        DoubleListNode tail;\n\n        public LRUCache(int capacity) {\n            cache = new HashMap<>(capacity);\n            //keyList = new ArrayList<>();\n            max = capacity;\n            head = tail = null;\n            len = 0;\n        }\n\n        public int get(int key) {\n            DoubleListNode ans = cache.get(key);\n            if(ans == null){\n                return -1;\n            }\n            moveToLast(ans);\n            return ans.getValue();\n        }\n\n        public void put(int key, int value) {\n            DoubleListNode doubleListNode = cache.get(key);\n            if (doubleListNode == null) {\n                DoubleListNode temp = new DoubleListNode(key, value);\n                if (max == len) {\n                    DoubleListNode headTemp = head;\n                    if (head == tail) {\n                        head = tail = null;\n                    } else {\n                        head = head.getAfter();\n                        head.setBefore(null);\n                        headTemp.setAfter(null);\n                    }\n                    //keyList.remove(headTemp);\n                    cache.remove(headTemp.getKey());\n                    len--;\n                }\n                cache.put(key, temp);\n                moveToLast(temp);\n                len++;\n               // keyList.add(temp);\n            } else {\n                doubleListNode.setKeyValue(key, value);\n                moveToLast(doubleListNode);\n            }\n        }\n\n        private void moveToLast(DoubleListNode temp) {\n            //分四种情况\n            //新增的 前节点为尾节点 尾节点=这个节点\n            //头节点 下一个节点变为头节点 下一节点置空 前节点为尾节点 尾节点=这个节点\n            //尾节点 不动\n            //中间节点 记录前后节点 调转前后节点的指向 后节点置空 前节点为尾节点 尾节点=这个节点\n            if (temp.getBefore() == null) {\n                if (head == null) {\n                    head = tail = temp;\n                    return ;\n                }\n                if (temp.getAfter() != null) {\n                    //头节点\n                    head = head.getAfter();\n                    head.setBefore(null);\n                    temp.setAfter(null);\n                }\n                tail.setAfter(temp);\n                temp.setBefore(tail);\n                tail = temp;\n            }else {\n                if (temp.getAfter() != null) {\n                    //中间节点\n                    DoubleListNode after = temp.getAfter();\n                    DoubleListNode before = temp.getBefore();\n                    before.setAfter(after);\n                    after.setBefore(before);\n                    temp.setAfter(null);\n                    tail.setAfter(temp);\n                    temp.setBefore(tail);\n                    tail = temp;\n                }\n            }\n        }\n\n        class DoubleListNode {\n            private DoubleListNode before;\n            private Integer key;\n            private Integer value;\n            private DoubleListNode after;\n\n            public DoubleListNode(Integer key, Integer value) {\n                this.key = key;\n                this.value = value;\n                this.before = null;\n                this.after = null;\n            }\n\n            public DoubleListNode(DoubleListNode before, Integer key, Integer value, DoubleListNode after) {\n                this.key = key;\n                this.value = value;\n                this.before = before;\n                this.after = after;\n            }\n\n            public DoubleListNode getBefore() {\n                return before;\n            }\n\n            public DoubleListNode getAfter() {\n                return after;\n            }\n\n            public void setAfter(DoubleListNode after) {\n                this.after = after;\n            }\n\n            public void setBefore(DoubleListNode before) {\n                this.before = before;\n            }\n\n            public Integer getKey() {\n                return key;\n            }\n\n            public Integer getValue() {\n                return value;\n            }\n\n            public void setKeyValue(Integer key, Integer value) {\n                this.key = key;\n                this.value = value;\n            }\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445364941","body":"# 思路\n\t深度优先遍历\n# 复杂度\n\t时间复杂度O(n) 空间复杂度O(1)\n# 代码\n```java\nclass Solution {\n        public int maxDepth(TreeNode root) {\n            if (root == null) {\n                return 0;\n            }\n            return Math.max(getDeep(root.left, 1), getDeep(root.right, 1));\n        }\n\n        public int getDeep(TreeNode tree, int deep) {\n            if (tree == null) {\n                return deep;\n            }\n            return Math.max(getDeep(tree.left, deep + 1), getDeep(tree.right, deep + 1));\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446578264","body":"# 思路\n\t深度优先遍历\n# 复杂度\n\t时间复杂度 O(n) 空间复杂度O(1)\n# 代码\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null&&q==null){\n            return true;\n        }\n        if(p==null||q==null){\n            return false;\n        }\n        if(q.val!=p.val){\n            return false;\n        }\n        return isSameTree(p.left,q.left)&isSameTree(p.right,q.right);\n }\n}\n ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447471027","body":"# 思路\n    深度优先遍历 非叶子节点不处理\n# 复杂度\n    时间复杂度O(n) 空间复杂度O(1)\n# 代码\n```java\n    class Solution {\n        public int sumNumbers(TreeNode root) {\n            return getNum(root, 0);\n        }\n\n        public int getNum(TreeNode root, int val) {\n            if (root == null) {\n                return val;\n            }\n            if (root.left == null && root.right == null) {\n                return val * 10 + root.val;\n            }\n            if (root.left == null) {\n                return getNum(root.right, val * 10 + root.val);\n            }\n            if (root.right == null) {\n                return getNum(root.left, val * 10 + root.val);\n            }\n            return getNum(root.left, val * 10 + root.val) + getNum(root.right, val * 10 + root.val);\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450352226","body":"# 思路\n\t广度优先遍历\n# 复杂度\n\t时间复杂度O(n) 空间复杂度O(n)\n# 代码\n```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        List<TreeNode> treeNodeList = new LinkedList<>();\n        treeNodeList.add(root);\n        int ans =0;\n        while(treeNodeList.size()>0){\n            int len = treeNodeList.size();\n            for(int i=0;i<len;i++){\n                TreeNode temp = treeNodeList.remove(0);\n                if(i==0){\n                    ans = temp.val;\n                }\n                if(temp.left!=null){\n                    treeNodeList.add(temp.left);\n                }\n                if(temp.right!=null){\n                    treeNodeList.add(temp.right);\n                }\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451336281","body":"# 思路\r\n\t深度优先遍历 需存储所有的叶子节点及叶子结点的子节点(空节点) 反序列化的时候  以空节点为思路上的划分位置来构造生成\r\n# 复杂度\r\n\t时间复杂度O(n) 空间复杂度O(n)\r\n# 代码\r\n```java\r\npublic class Codec {\r\n    \r\n   public String serialize(TreeNode root) {\r\n        StringBuilder stringBuilder = new StringBuilder();\r\n        serialize(root, stringBuilder);\r\n        return stringBuilder.substring(1);\r\n    }\r\n\r\n    private void serialize(TreeNode root, StringBuilder stringBuilder) {\r\n        if (root == null) {\r\n            stringBuilder.append(\",\");\r\n            return;\r\n        }\r\n        stringBuilder.append(\",\").append(root.val);\r\n        serialize(root.left, stringBuilder);\r\n        serialize(root.right, stringBuilder);\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        String[] split = data.split(\",\");\r\n        List<String> treeNodeList = new LinkedList<>(Arrays.asList(split));\r\n        return deserialize(treeNodeList);\r\n    }\r\n\r\n\r\n    public TreeNode deserialize(List<String> treeNodeList) {\r\n        if (treeNodeList.size() == 0) {\r\n            return null;\r\n        }\r\n        if (\"\".equals(treeNodeList.get(0))) {\r\n            treeNodeList.remove(0);\r\n            return null;\r\n        }\r\n        String treeNode = treeNodeList.remove(0);\r\n        return new TreeNode(Integer.parseInt(treeNode), deserialize(treeNodeList), deserialize(treeNodeList));\r\n    }\r\n\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453378754","body":"# 思路\n\t自定义结构体存储树节点的坐标信息和值，将树节点转化成结构体放入list并排序，从排序后的结构体中遍历出答案\n# 复杂度\n\t时间复杂度O(n logn) 空间复杂度 O(n)\n# 代码\n```java\nclass Solution {\n    class Coordinate implements Comparable {\n        public int x;\n        public int y;\n        public int v;\n\n        public Coordinate(int x, int y, int v) {\n            this.x = x;\n            this.y = y;\n            this.v = v;\n        }\n\n        @Override\n        public int compareTo( Object o) {\n            Coordinate co2 = (Coordinate) o;\n            if (y > co2.y) {\n                return 1;\n            }\n            if (co2.y > y) {\n                return -1;\n            }\n            if (x > co2.x) {\n                return 1;\n            }\n            if (co2.x > x) {\n                return -1;\n            }\n\n            return Integer.compare(v, co2.v);\n        }\n    }\n\n\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<Coordinate> coordinateList = new ArrayList<>();\n        addToList(0, 0, coordinateList, root);\n        List<List<Integer>> temp = new ArrayList<>();\n        sort(coordinateList, 0, coordinateList.size() - 1);\n        int nowY = coordinateList.get(0).y;\n        List<Integer> tempList = new ArrayList<>();\n        for (Coordinate coordinate : coordinateList) {\n            if (coordinate.y != nowY) {\n                nowY = coordinate.y;\n                temp.add(tempList);\n                tempList = new ArrayList<>();\n            }\n            tempList.add(coordinate.v);\n        }\n        if (tempList.size() > 0) {\n            temp.add(tempList);\n        }\n        return temp;\n    }\n\n    private void addToList(int x, int y, List<Coordinate> coordinateList, TreeNode tree) {\n        if (tree == null) {\n            return;\n        }\n        coordinateList.add(new Coordinate(x, y, tree.val));\n        addToList(x + 1, y - 1, coordinateList, tree.left);\n        addToList(x + 1, y + 1, coordinateList, tree.right);\n    }\n\n    private void sort(List<Coordinate> coordinateList, int start, int end) {\n        Coordinate pivot;\n        int i, p_pos;\n        if (start < end) {\n            p_pos = start;\n            pivot = coordinateList.get(p_pos);\n            for (i = start + 1; i <= end; i++) {\n                if (coordinateList.get(i).compareTo(pivot) < 0) {\n                    p_pos++;\n                    switchElement(coordinateList, p_pos, i);\n                }\n            }\n            switchElement(coordinateList, start, p_pos);\n            sort(coordinateList, start, p_pos - 1);\n            sort(coordinateList, p_pos + 1, end);\n        }\n    }\n\n    public void switchElement(List<Coordinate> coordinateList, int a, int b) {\n        Coordinate coordinate = coordinateList.get(a);\n        coordinateList.set(a, coordinateList.get(b));\n        coordinateList.set(b, coordinate);\n    }\n\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454321890","body":"# 思路\n\t单循环 每次从map中查找当前下标的值和target的差值，存在则返回，不存在则将当前值当做key，下标当做value存到map中\n# 复杂度\n\t时间复杂度O(n) 空间复杂度O(n)\n# 代码\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            if(map.containsKey(target-nums[i])){\n                return new int[]{i,map.get(target-nums[i])};\n            }\n            map.put(nums[i],i);\n        }\n        return new int[]{0,0};\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455119376","body":"# 思路\n\thash表和优先队列\n# 复杂度\n\t时间复杂度O(n) 空间复杂度O(n)\n# 代码\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        //Comparator.comparingInt(o -> o[1]) 返回一个比较器 该比较器以int排序lambda表达式中是如何获取这个用于比较的int\n        //PriorityQueue 优先队列 以构造器中的比较器参数为排序规则排序\n        PriorityQueue<int[]> queue = new PriorityQueue<>((Comparator.comparingInt(o -> o[1])));\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            if (queue.size() == k) {\n                final int[] peek = queue.peek();\n                if (peek[1] < entry.getValue()) {\n                    queue.poll();\n                    queue.offer(new int[]{entry.getKey(), entry.getValue()});\n                }\n            } else {\n                queue.offer(new int[]{entry.getKey(), entry.getValue()});\n            }\n        }\n        int[] ans = new int[k];\n        for (int i = 0; i < k; ++i) {\n            ans[i] = queue.poll()[0];\n        }\n        return ans;\n    }\n\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455378780","body":"# 思路\n\tmap记录以每个点为折点的时候，各个长度的平方的数量 每遍历下一个折点清空map 遍历下一个边点的时候 从map中查询边点的数量并+1重新记录\n# 复杂度\n\t时间复杂度O(n*n) 空间复杂度O(n)\n# 代码\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        Map<Integer,Integer> map = new HashMap<>();\n        int ans = 0;\n        for(int i=0;i<points.length;i++){\n            for(int j=0;j<points.length;j++){\n                if(i==j){\n                    continue;\n                }\n                int len = (points[i][0]-points[j][0])*(points[i][0]-points[j][0])+(points[i][1]-points[j][1])*(points[i][1]-points[j][1]);\n                ans += map.merge(len, 1, Integer::sum) - 1;\n            }\n            map.clear();\n        }\n        return ans*2;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457371702","body":"# 思路\n\t双指针 快指针依次向后遍历  慢指针查询快指针指向的字符是否存在 存在则指向上一次出现的字符的下标 不存在则不动\n\t长度为遍历过程中快慢指针的差值的最大值\n# 复杂度\n\t时间复杂度O(n) 空间复杂度O(1)\n# 代码\n```java\npublic static int lengthOfLongestSubstring(String s) {\n        int[] m = new int[128];\n        int ans = 0;\n        for (int low = 0, fast = 0; fast < s.length(); fast++) {\n            low = Math.max(m[s.charAt(fast)], low);\n            ans = Math.max(ans, fast - low + 1);\n            m[s.charAt(fast++)] = fast;\n        }\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459775825","body":"# 思路\n\tmap保存单词 每次后移一位 依次截取数字长度个单词 判断是否在map中并且数量相对 都存在则符合答案 不存在则跳过 \n# 复杂度\n\t时间复杂度O(n*m*k) 空间复杂度O(m)\n# 代码\n```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList<>();\n        int wordLen = words[0].length();\n        //总长度小于则不符合\n        if (wordLen * words.length > s.length() || wordLen == 0 || s.length() == 0) {\n            return ans;\n        }\n        //所有的单词内置到map\n        Map<String, Integer> wordMap = new HashMap<>();\n        for (String w : words) {\n            wordMap.merge(w, 1, Integer::sum);\n        }\n        Map<String, Integer> wordMapTemp;\n        int allLen = words.length * wordLen;\n        String word;\n        boolean flag;\n        //滑动窗口\n        for (int i = 0; i < s.length() - allLen + 1; i++) {\n            flag = true;\n            wordMapTemp = new HashMap<>();\n            for (int j = 0; j < words.length; j++) {\n                word = s.substring(i + j * wordLen, i + j * wordLen + wordLen);\n                wordMapTemp.merge(word, 1, Integer::sum);\n                if (!wordMap.containsKey(word)||wordMapTemp.get(word) > wordMap.get(word)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                ans.add(i);\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461765453","body":"# 思路\n\t前缀和  map 计算数组总和并求和p的余数  利用同余定理找出start - end 这一段之和的余数为mode的 取最小值\n# 复杂度\n\t时间复杂度O(n) 空间复杂度O(n)\n# 代码\n```java\nclass Solution {\n    public int minSubarray(int[] nums, int p) {\n            int sum = 0, ans = nums.length, mode = 0;\n            for (int num : nums) {\n                mode = (num + mode) % p;\n            }\n            if (mode == 0) {\n                return 0;\n            }\n            Map<Integer, Integer> map = new HashMap<>();\n            for (int i = 0; i < nums.length; i++) {\n                map.put(sum, i);\n                sum = (nums[i] + sum) % p;\n                int k = (sum + p - mode) % p;\n                if (map.containsKey(k)) {\n                    ans = Math.min(ans, i - map.get(k)+1);\n                }\n            }\n            return ans == nums.length ? -1 : ans;\n        }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463052382","body":"# 思路\n\t双指针 快指针每次向后移动两位 慢指针移动一位 直到快指针无法移动停止 \n\t如果快指针后下一个节点不为空 则节点总数为负数 慢指针后移一位\n# 复杂度\n\t时间复杂度O(n) 空间复杂度O(1)\n# 代码\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode fast = head,low = head;\n        while(fast.next!=null&&fast.next.next!=null){\n            fast = fast.next.next;\n            low = low.next;\n        }\n        if(fast.next!=null){\n            low = low.next;\n        }\n        return low;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464940844","body":"# 思路\n\t双指针\n# 复杂度\n\t时间复杂度O(n) 空间复杂度O(1)\n# 代码\n```javaa\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int low = 1;\n        int temp  = nums[0];\n        for(int i=1;i<nums.length;i++){\n            if(temp==nums[i]){\n                continue;\n            }\n            nums[low] = nums[i];\n            temp = nums[i];\n            low++;\n        }\n        return low;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1464951157","body":"# 思路\n\t二分法\n# 复杂度\n\t时间复杂度O(logN) 空间复杂度O(1)\n# 代码\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int start = 0, end = nums.length-1, temp = 0;\n        while (start <= end) {\n            temp = (start + end) >> 1;\n            if (nums[temp] < target) {\n                start = temp + 1;\n            } else if (nums[temp] > target) {\n                end = temp - 1;\n            } else if (nums[temp] == target) {\n                return temp;\n            }\n        }\n        return start;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465592652","body":"# 思路\n\t优先队列的优化 值-下标的二元组加入到序列中 加入的过程中，从队尾删除值和下标均小于当前二元组的元素 \n\t向右滑动窗口 序列的第一个元素即为该下标的答案 当头二元组的下标和当前下标相同时 从序列中删除头\n# 复杂度\n\t每个二元组至多入队列一次出队列一次 时间复杂度O(n) 空间复杂度O(n)\n# 代码\n```java\nclass Solution {\n    public static int[] maxSlidingWindow(int[] nums, int k) {\n        //序列记录  值 - 下标\n        LinkedList<int[]> valueList = new LinkedList<>();\n        //将前n个加入到序列中\n        for (int i = 0; i < k; i++) {\n            addToList(new int[]{nums[i], i}, valueList);\n        }\n        int[] ans = new int[nums.length - k + 1];\n        for (int i = 0; i < nums.length - k; i++) {\n            ans[i] = valueList.getFirst()[0];\n            addToList(new int[]{nums[i + k], i + k}, valueList);\n            if (valueList.getFirst()[1] <= i) {\n                valueList.removeFirst();\n            }\n        }\n        ans[ans.length - 1] = valueList.getFirst()[0];\n        return ans;\n    }\n\n    private static void addToList(int[] value, LinkedList<int[]> valueList) {\n        while (valueList.size() > 0 && value[0] >= valueList.getLast()[0]) {\n            valueList.removeLast();\n        }\n        valueList.addLast(value);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467207474","body":"# 思路\n\t图 计算每个节点的入度 如果有指向其他节点的 则直接-n代表这个人不是法官\n# 复杂度\n\t时间复杂度O（n ）空间复杂度O（n）\n# 代码\n```java\n    public static int findJudge(int n, int[][] trust) {\n        int[] ans = new int[n];\n        for (int[] temp : trust) {\n            ans[temp[1] - 1] += 1;\n            ans[temp[0] - 1] -= n;\n        }\n        for (int i = 0; i < n; i++) {\n            if (ans[i] == n - 1) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469915746","body":"# 思路\n\t图 染色\n# 复杂度\n\t时间复杂度O(n+m) 空间复杂度O(n+m)\n# 代码\n```java\nclass Solution {\n    ArrayList<Integer>[] graph;\n    Map<Integer, Integer> color;\n\n    public boolean possibleBipartition(int N, int[][] dislikes) {\n        graph = new ArrayList[N+1];\n        for (int i = 1; i <= N; ++i)\n            graph[i] = new ArrayList();\n\n        for (int[] edge: dislikes) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n\n        color = new HashMap();\n        for (int node = 1; node <= N; ++node)\n            //如果当前顶点已被上色 则结束循环\n            //如果当前顶点未被上色 递归遍历顶点及相邻的订单\n            if (!color.containsKey(node) && !dfs(node, 0))\n                return false;\n        return true;\n    }\n\n    public boolean dfs(int node, int c) {\n        if (color.containsKey(node))\n            return color.get(node) == c;\n        //上色\n        color.put(node, c);\n        //递归检索相邻的定点  上相反的色\n        //深度优先遍历\n        for (int nei: graph[node])\n            if (!dfs(nei, c ^ 1))\n                return false;\n        return true;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1471360617","body":"# 思路\n\t拓扑排序\n# 复杂度\n\t时间复杂度O(m+n*n)  空间复杂度O(m+n*n) \n# 代码\n```java\npublic class Solution {\n\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n        // 第 1 步：数据预处理，给没有归属于一个组的项目编上组号\n        for (int i = 0; i < group.length; i++) {\n            if (group[i] == -1) {\n                group[i] = m;\n                m++;\n            }\n        }\n\n        // 第 2 步：实例化组和项目的邻接表\n        List<Integer>[] groupAdj = new ArrayList[m];\n        List<Integer>[] itemAdj = new ArrayList[n];\n        for (int i = 0; i < m; i++) {\n            groupAdj[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < n; i++) {\n            itemAdj[i] = new ArrayList<>();\n        }\n\n        // 第 3 步：建图和统计入度数组\n        int[] groupsIndegree = new int[m];\n        int[] itemsIndegree = new int[n];\n\n        int len = group.length;\n        for (int i = 0; i < len; i++) {\n            int currentGroup = group[i];\n            for (int beforeItem : beforeItems.get(i)) {\n                int beforeGroup = group[beforeItem];\n                if (beforeGroup != currentGroup) {\n                    groupAdj[beforeGroup].add(currentGroup);\n                    groupsIndegree[currentGroup]++;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (Integer item : beforeItems.get(i)) {\n                itemAdj[item].add(i);\n                itemsIndegree[i]++;\n            }\n        }\n\n        // 第 4 步：得到组和项目的拓扑排序结果\n        List<Integer> groupsList = topologicalSort(groupAdj, groupsIndegree, m);\n        if (groupsList.size() == 0) {\n            return new int[0];\n        }\n        List<Integer> itemsList = topologicalSort(itemAdj, itemsIndegree, n);\n        if (itemsList.size() == 0) {\n            return new int[0];\n        }\n\n        // 第 5 步：根据项目的拓扑排序结果，项目到组的多对一关系，建立组到项目的一对多关系\n        // key：组，value：在同一组的项目列表\n        Map<Integer, List<Integer>> groups2Items = new HashMap<>();\n        for (Integer item : itemsList) {\n            groups2Items.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\n        }\n\n        // 第 6 步：把组的拓扑排序结果替换成为项目的拓扑排序结果\n        List<Integer> res = new ArrayList<>();\n        for (Integer groupId : groupsList) {\n            List<Integer> items = groups2Items.getOrDefault(groupId, new ArrayList<>());\n            res.addAll(items);\n        }\n        return res.stream().mapToInt(Integer::valueOf).toArray();\n    }\n\n    private List<Integer> topologicalSort(List<Integer>[] adj, int[] inDegree, int n) {\n        List<Integer> res = new ArrayList<>();\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            Integer front = queue.poll();\n            res.add(front);\n            for (int successor : adj[front]) {\n                inDegree[successor]--;\n                if (inDegree[successor] == 0) {\n                    queue.offer(successor);\n                }\n            }\n        }\n\n        if (res.size() == n) {\n            return res;\n        }\n        return new ArrayList<>();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1472954866","body":"# 思路\n\t分别记录上下左右的移动距离 比较上下左右的移动距离是否相当\n# 复杂度\n\t时间复杂度O(n) 空间复杂度O(1)\n# 代码\n```java\npublic boolean judgeCircle(String moves) {\n        int[] ans = new int['U'+1];\n        for(char c:moves.toCharArray()){\n            ans[c]++;\n        }\n        return ans['L']==ans['R']&&ans['U']==ans['D'];\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474873340","body":"# 思路\n\t模拟 优先队列\n# 复杂度\n\t时间复杂度O(n logn) 空间复杂度O(n)\n# 代码\n```java\nclass Solution {\n    public int[] getOrder(int[][] ts) {\n        int n = ts.length;\n        // 将 ts 转存成 nts，保留任务编号\n        int[][] nts = new int[n][3];\n        for (int i = 0; i < n; i++) nts[i] = new int[]{ts[i][0], ts[i][1], i};\n        // 根据任务入队时间进行排序\n        Arrays.sort(nts, (a,b)->a[0]-b[0]);\n        // 根据题意，先按照「持续时间」排序，再根据「任务编号」排序\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->{\n            if (a[1] != b[1]) return a[1] - b[1];\n            return a[2] - b[2];\n        });\n        int[] ans = new int[n];\n        for (int time = 1, j = 0, idx = 0; idx < n; ) {\n        \t// 如果当前任务可以添加到「队列」中（满足入队时间）则进行入队\n            while (j < n && nts[j][0] <= time) q.add(nts[j++]);\n            if (q.isEmpty()) {\n\t            // 如果当前「队列」没有任务，直接跳到下个任务的入队时间\n                time = nts[j][0];\n            } else {\n            \t// 如果有可执行任务的话，根据优先级将任务出队（记录下标），并跳到该任务完成时间点\n                int[] cur = q.poll();\n                ans[idx++] = cur[2];\n                time += cur[1];\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475292783","body":"# 思路\n\t模拟\n# 算法复杂度\n\t时间复杂度O（1） 空间复杂度O(1)\n# 代码\n```java\nclass Solution {\n     public int numberOfRounds(String startTime, String finishTime) {\n        int startMM = Integer.parseInt(startTime.substring(0,2)) * 60 + Integer.parseInt(startTime.substring(3));\n        int finishMM = Integer.parseInt(finishTime.substring(0,2)) * 60 + Integer.parseInt(finishTime.substring(3));\n        if (startMM > finishMM) {\n            finishMM += 1440;\n        }\n        finishMM = finishMM/15*15;\n        return Math.max(0,finishMM-startMM)/15;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476071792","body":"# 思路\n\t枚举从每个字母变更的三种情况 选择其中的最小值\n# 复杂度\n\t时间复杂度O(n) 空间复杂度O(1)\n# 代码\n```java\npublic static int minCharacters(String a, String b) {\n\tint aLen = a.length(), bLen = b.length(), ans = Integer.MAX_VALUE;\n    int[] aList = new int[26], bList = new int[26];\n    for (char c : a.toCharArray()) {\n            aList[c - 'a']++;\n        }\n        for (char c : b.toCharArray()) {\n            bList[c - 'a']++;\n        }\n        int hadCount1a = 0, sumOfRemain1b = bLen, firstMethodModifyFrequency;\n        int sumOfRemain2a = aLen, hadCount2b = 0, secondMethodModifyFrequency;\n        for (int i = 0; i < 26 && ans != 0; i++) {\n            int ca = aLen - aList[i], ba = bLen - bList[i];\n            int countMethod3 = ca + ba;\n            ans = Math.min(countMethod3, ans);\n\n            //对于方法1 'a' 到当前字符串的和 + 'b'\n\n            hadCount1a += aList[i];\n            sumOfRemain1b -= bList[i];\n            firstMethodModifyFrequency = hadCount1a + sumOfRemain1b;\n\n            hadCount2b += bList[i];\n            sumOfRemain2a -= aList[i];\n            secondMethodModifyFrequency = sumOfRemain2a + hadCount2b;\n            if (i == 25) {\n                continue;\n            }\n            ans = Math.min(ans, Math.min(firstMethodModifyFrequency, secondMethodModifyFrequency));\n\n        }\n        return ans;\n\t\t    }\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1478011374","body":"# 思路\n\t堆排序\n# 复杂度\n\t时间复杂度O(n logn) 空间复杂度O（n）\n# 代码\n```java\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        heapSort(nums);\n        return nums;\n    }\n\n    public void heapSort(int[] nums) {\n        int len = nums.length - 1;\n        buildMaxHeap(nums, len);\n        for (int i = len; i >= 1; --i) {\n            swap(nums, i, 0);\n            len -= 1;\n            maxHeapify(nums, 0, len);\n        }\n    }\n\n    public void buildMaxHeap(int[] nums, int len) {\n        for (int i = len / 2; i >= 0; --i) {\n            maxHeapify(nums, i, len);\n        }\n    }\n\n    public void maxHeapify(int[] nums, int i, int len) {\n        for (; (i << 1) + 1 <= len;) {\n            int lson = (i << 1) + 1;\n            int rson = (i << 1) + 2;\n            int large;\n            if (lson <= len && nums[lson] > nums[i]) {\n                large = lson;\n            } else {\n                large = i;\n            }\n            if (rson <= len && nums[rson] > nums[large]) {\n                large = rson;\n            }\n            if (large != i) {\n                swap(nums, i, large);\n                i = large;\n            } else {\n                break;\n            }\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1478839334","body":"# 思路\n\t二分法\n# 复杂度\n\t时间复杂度O(log x) 空间复杂度O(1)\n# 代码\n```java\nclass Solution {\n    public static int mySqrt(int x) {\n        int start = 0, end = x;\n        while (start <= end) {\n            int temp = start + (end - start) / 2;\n            if ((long) temp * temp <= x) {\n                start = temp + 1;\n            } else {\n                end = temp - 1;\n            }\n        }\n        return start-1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480541474","body":"# 思路\n\t二分查找\n# 复杂度\n\t时间复杂度O(log n) 空间复杂度O(1)\n# 代码\n```java\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int start = 1,end = n;\n        int temp  = 1;\n        while (start < end) {\n            temp = start + (end - start) / 2;\n            if (isBadVersion(temp)) {\n                end = temp;\n            } else {\n                start = temp + 1;\n            }\n        }\n        return start;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482606242","body":"# 思路\n\t归并排序\n# 复杂度\n\t时间复杂度O(n log n) 空间复杂度O(n)\n# 代码\n```java\nclass Solution {\n    public int reversePairs(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        return reversePairsRecursive(nums, 0, nums.length - 1);\n    }\n\n    public int reversePairsRecursive(int[] nums, int left, int right) {\n        if (left == right) {\n            return 0;\n        } else {\n            int mid = (left + right) / 2;\n            int n1 = reversePairsRecursive(nums, left, mid);\n            int n2 = reversePairsRecursive(nums, mid + 1, right);\n            int ret = n1 + n2;\n\n            // 首先统计下标对的数量\n            int i = left;\n            int j = mid + 1;\n            while (i <= mid) {\n                while (j <= right && (long) nums[i] > 2 * (long) nums[j]) {\n                    j++;\n                }\n                ret += j - mid - 1;\n                i++;\n            }\n\n            // 随后合并两个排序数组\n            int[] sorted = new int[right - left + 1];\n            int p1 = left, p2 = mid + 1;\n            int p = 0;\n            while (p1 <= mid || p2 <= right) {\n                if (p1 > mid) {\n                    sorted[p++] = nums[p2++];\n                } else if (p2 > right) {\n                    sorted[p++] = nums[p1++];\n                } else {\n                    if (nums[p1] < nums[p2]) {\n                        sorted[p++] = nums[p1++];\n                    } else {\n                        sorted[p++] = nums[p2++];\n                    }\n                }\n            }\n            for (int k = 0; k < sorted.length; k++) {\n                nums[left + k] = sorted[k];\n            }\n            return ret;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483851980","body":"# 思路\n\t二分法 \n# 复杂度\n\t时间复杂度O((n+m)log n) 空间复杂度O(n)\n# 代码 \n```java\nass Solution {\n    public int findRadius(int[] houses, int[] heaters) {\n        int ans = 0;\n        Arrays.sort(heaters);\n        for (int house : houses) {\n            int i = binarySearch(heaters, house);\n            int j = i + 1;\n            int leftDistance = i < 0 ? Integer.MAX_VALUE : house - heaters[i];\n            int rightDistance = j >= heaters.length ? Integer.MAX_VALUE : heaters[j] - house;\n            int curDistance = Math.min(leftDistance, rightDistance);\n            ans = Math.max(ans, curDistance);\n        }\n        return ans;\n    }\n\n    public int binarySearch(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        if (nums[left] > target) {\n            return -1;\n        }\n        while (left < right) {\n            int mid = (right - left + 1) / 2 + left;\n            if (nums[mid] > target) {\n                right = mid - 1;\n            } else {\n                left = mid;\n            }\n        }\n        return left;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1484134706","body":"# 思路\n\t排序 + 二分查找\n# 复杂度\n\t时间复杂度O(n logn * longD ) 空间复杂度O(log n)\n# 代码\n```java\nclass Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n        int n = nums.length, left = 0, right = nums[n - 1] - nums[0];\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            int cnt = 0;\n            for (int j = 0; j < n; j++) {\n                int i = binarySearch(nums, j, nums[j] - mid);\n                cnt += j - i;\n            }\n            if (cnt >= k) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n\n    public int binarySearch(int[] nums, int end, int target) {\n        int left = 0, right = end;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484643367","body":"# 思路\n\t二分查找高度的数量 并且深度遍历直到尾点\n# 复杂度\n\t时间复杂度O(n*n*logn) 空间复杂度O(n*n)\n# 代码\n```java\nclass Solution {\n    private static int N;\n\n    private static final int[][] DIRECTIONS = new int[][]{{0, -1}, {0, 1}, {1, 0}, {-1, 0}};\n\n    public static int swimInWater(int[][] grid) {\n        int len = grid.length;\n        N = len;\n        int start = 0, end = len * len -1 , temp;\n        //二分查找\n        while (start < end) {\n            temp = (start + end) / 2;\n            //记录已经深度遍历过的点\n            boolean[][] visited = new boolean[len][len];\n            //第一个点小于当前判断的值 并且深度遍历其他的点\n            if (grid[0][0] <= temp && dfs(grid, visited, 0, 0, temp)) {\n                end = temp;\n            } else {\n                start = temp + 1;\n            }\n        }\n        return start;\n    }\n\n    //深度遍历所有的点\n    private static boolean dfs(int[][] grid, boolean[][] visited, int x, int y, int temp) {\n        visited[x][y] = true;\n        //四个方向\n        for (int[] direction : DIRECTIONS) {\n            int newX = x + direction[0];\n            int newY = y + direction[1];\n            //遍历到最后一个点的时候 并且最后一个点小于当前的高度  证明存在这个路径了\n            if (newX == N - 1 && newY == N - 1 && grid[newX][newY] <= temp) {\n                return true;\n            }\n            //点存在 未遍历 不高于当前高度 就继续深度遍历\n            if (isArea(newX, newY) && !visited[newX][newY] && grid[newX][newY] <= temp && dfs(grid, visited, newX, newY, temp)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static boolean isArea(int x, int y) {\n        return x >= 0 && y >= 0 && x < N && y < N;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486367167","body":"# 思路\n\t滑动窗口 循环s中的字符串 下一个为元音则+1 当遍历的长度大于k以后 k之前的每个元音长度-1 取最大值\n# 复杂度\n\t时间复杂度O(n) 空间复杂度O(n)\n# 代码\n```java\n public static int maxVowels(String s, int k) {\n        char[] sChar = s.toCharArray();\n        boolean[] vowels = new boolean[123];\n        vowels['a'] = vowels['e'] = vowels['i'] = vowels['o'] = vowels['u'] = true;\n        int vowelLen = 0;\n        int ans = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (vowels[sChar[i]]) {\n                vowelLen++;\n            }\n            if (i >= k && vowels[sChar[i - k]]) {\n                vowelLen--;\n            }\n            if (vowelLen == k) {\n                return k;\n            }\n            ans = Math.max(ans, vowelLen);\n        }\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1490508949","body":"# 思路\r\n\t动态规划\r\n# 代码\r\n```java\r\nclass Solution {\r\n    public double new21Game(int n, int k, int maxPts) {\r\n        if (k == 0) {\r\n            return 1.0;\r\n        }\r\n        double[] dp = new double[k + maxPts];\r\n        for (int i = k; i <= n && i < k + maxPts; i++) {\r\n            dp[i] = 1.0;\r\n        }\r\n        for (int i = k - 1; i >= 0; i--) {\r\n            for (int j = 1; j <= maxPts; j++) {\r\n                dp[i] += dp[i + j] / maxPts;\r\n            }\r\n        }\r\n        return dp[0];\r\n    }\r\n}\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1490515888","body":"# 思路\n\t滑动窗口\n# 代码\n```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        int sLen = s.length(), pLen = p.length();\n\n        if (sLen < pLen) {\n            return new ArrayList<Integer>();\n        }\n\n        List<Integer> ans = new ArrayList<Integer>();\n        int[] sCount = new int[26];\n        int[] pCount = new int[26];\n        for (int i = 0; i < pLen; ++i) {\n            ++sCount[s.charAt(i) - 'a'];\n            ++pCount[p.charAt(i) - 'a'];\n        }\n\n        if (Arrays.equals(sCount, pCount)) {\n            ans.add(0);\n        }\n\n        for (int i = 0; i < sLen - pLen; ++i) {\n            --sCount[s.charAt(i) - 'a'];\n            ++sCount[s.charAt(i + pLen) - 'a'];\n\n            if (Arrays.equals(sCount, pCount)) {\n                ans.add(i + 1);\n            }\n        }\n\n        return ans;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491398624","body":"# 思路\n\t滑动窗口\n# 复杂度\n\t时间复杂度 O(C*|s|+|t|) 空间复杂度O(C)\n# 代码\n```java\nclass Solution {\n    Map<Character, Integer> ori = new HashMap<Character, Integer>();\n    Map<Character, Integer> cnt = new HashMap<Character, Integer>();\n\n    public String minWindow(String s, String t) {\n        int tLen = t.length();\n        for (int i = 0; i < tLen; i++) {\n            char c = t.charAt(i);\n            ori.put(c, ori.getOrDefault(c, 0) + 1);\n        }\n        int l = 0, r = -1;\n        int len = Integer.MAX_VALUE, ansL = -1, ansR = -1;\n        int sLen = s.length();\n        while (r < sLen) {\n            ++r;\n            if (r < sLen && ori.containsKey(s.charAt(r))) {\n                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), 0) + 1);\n            }\n            while (check() && l <= r) {\n                if (r - l + 1 < len) {\n                    len = r - l + 1;\n                    ansL = l;\n                    ansR = l + len;\n                }\n                if (ori.containsKey(s.charAt(l))) {\n                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), 0) - 1);\n                }\n                ++l;\n            }\n        }\n        return ansL == -1 ? \"\" : s.substring(ansL, ansR);\n    }\n\n    public boolean check() {\n        Iterator iter = ori.entrySet().iterator(); \n        while (iter.hasNext()) { \n            Map.Entry entry = (Map.Entry) iter.next(); \n            Character key = (Character) entry.getKey(); \n            Integer val = (Integer) entry.getValue(); \n            if (cnt.getOrDefault(key, 0) < val) {\n                return false;\n            }\n        } \n        return true;\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495299743","body":"# 思路\n\tdfs 深度优先遍历 已遍历过的置0\n# 复杂度\n\t时间复杂度O(m*n) 空间复杂度O(m*n)\n# 代码\n```java\nclass Solution {\n   public int maxAreaOfIsland(int[][] grid) {\n        int size = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == 0) {\n                    continue;\n                }\n                size = Math.max(size, dfs(i, j, grid));\n\n            }\n        }\n        return size;\n    }\n\n    public int[][] position = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n\n    public int dfs(int x, int y, int[][] grid) {\n        if (x < 0 || y < 0 || x == grid.length || y == grid[0].length || grid[x][y] == 0) {\n            return 0;\n        }\n\n        grid[x][y] = 0;\n        int size = 1;\n        for (int i = 0; i < 4; i++) {\n            int newX = x + position[i][0];\n            int newY = y + position[i][1];\n            size += dfs(newX, newY, grid);\n        }\n        return size;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ashleyyma6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuki-yzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpc7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yujian920":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kiirii4":[null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1444974399","body":"## 思路\n为使两个函数达到O(1)复杂度，同时使用链表和哈希表\n## 代码\n```c++\nstruct ListNodes {\n    ListNodes* prev;\n    ListNodes* next;\n    int key, val;\n    ListNodes(): key(0), val(0), prev(nullptr), next(nullptr){}\n    ListNodes(int _key, int _value): key(_key), val(_value), prev(nullptr), next(nullptr){}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, ListNodes*> hashmap;\n    ListNodes* head;\n    ListNodes* tail;\n    int capacity, size;\n\npublic:\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\n        head = new ListNodes();\n        tail = new ListNodes();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if(!hashmap.count(key))\n            return -1;\n        ListNodes* node = hashmap[key];\n        moveTohead(node);\n        return node->val;\n    }\n    \n    void put(int key, int value) {\n        if(!hashmap.count(key)){\n            ListNodes* node = new ListNodes(key, value);\n            hashmap[key] = node;\n            addTohead(node);\n            ++size;\n            if(size > capacity){\n                ListNodes* removed = removeTail();\n                hashmap.erase(removed->key);\n                --size;\n                delete removed;\n            }\n        }\n        else {\n            ListNodes* node = hashmap[key];\n            node->val = value;\n            moveTohead(node);\n        }\n    }\n\n    void addTohead(ListNodes* node){\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    \n    void removeNode(ListNodes* node){\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void moveTohead(ListNodes* node){\n        removeNode(node);\n        addTohead(node);\n    }\n\n    ListNodes* removeTail(){\n        ListNodes* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};\n```\n## 复杂度\n时间:O(1)\n空间:O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ucashurui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heng518":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tlntin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richypang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fenchuiyun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry-lllman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nickyk319":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"herbertpan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsmmxmm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fan-svg":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzejia":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunnyyujf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"phoenixflyingsky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nehchsuy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzyxts":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elainekuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ll491119940":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"2learnsomething":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ataraxyadong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzasd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miluowzt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maylinglin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weijie-he":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brodxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y525":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429156559","body":"- Time: $O(N)$ N is the length of the input array\r\n- Space: $O(1)$ No extra space is used except the returned array.\r\n\r\n```typescript\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    const res = Array(num.length);\r\n\r\n    for (let read = num.length - 1, write = 0; read >= 0; read--, write++) {\r\n        res[write] = (num[read] + k) % 10;\r\n        k = ((num[read] + k) / 10) >> 0;\r\n    }\r\n\r\n    while (k > 0) {\r\n        res.push(k % 10);\r\n        k = (k / 10) >> 0;\r\n    }\r\n\r\n    res.reverse();\r\n    return res;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1432547572","body":"- Time: $O(N)$\r\n- Space: $O(N)$\r\n```tsx\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    const dist = Array(s.length).fill(0);\r\n\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) dist[i] = 0;\r\n        else dist[i] = (dist[i - 1] ?? Infinity) + 1;\r\n    }\r\n\r\n    for (let i = s.length - 2; i >= 0; i--) {\r\n        dist[i] = Math.min(dist[i], dist[i + 1] + 1);\r\n    }\r\n\r\n    return dist;\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432600245","body":"|operation|Time|Space|\r\n|-|-|-|\r\n|`push`|$O(1)$|$O(1)$|\r\n|`pop`|$O(1)$|$O(1)$|\r\n|`increment`|$O(1)$|$O(1)$|\r\n\r\n```tsx\r\nclass CustomStack {\r\n  private maxSize_: number;\r\n  private top_: number = -1;\r\n  private nums_: number[];\r\n  private inc_: number[];\r\n  constructor(maxSize: number) {\r\n    this.maxSize_ = maxSize;\r\n    this.nums_ = Array(maxSize);\r\n    this.inc_ = Array(maxSize).fill(0);\r\n  }\r\n\r\n  push(x: number): void {\r\n    if (this.top_ === this.maxSize_ - 1) return;\r\n    this.nums_[++this.top_] = x;\r\n  }\r\n\r\n  pop(): number {\r\n    if (this.top_ < 0) return -1;\r\n\r\n    const num = this.nums_[this.top_];\r\n    const inc = this.inc_[this.top_];\r\n    this.inc_[this.top_ - 1] += inc;\r\n    this.inc_[this.top_] = 0;\r\n    this.top_--;\r\n\r\n    return num + inc;\r\n  }\r\n\r\n  increment(k: number, val: number): void {\r\n    k = Math.min(k - 1, this.top_);\r\n    if (k < 0) return;\r\n    this.inc_[k] += val;\r\n  }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434252684","body":"- Time: $O(N)$, where N is the length of the input string.\r\n- Space: $O(S)$, where S is the length of the decoded string.\r\n\r\n```tsx\r\nfunction top<T>(stk: T[]): T {\r\n    return stk[stk.length - 1];\r\n}\r\n  \r\nfunction decodeString(s: string): string {\r\n    const stack: string[] = [];\r\n  \r\n    for (let i = 0; i < s.length; i++) {\r\n      if (s[i] !== ']') {\r\n        stack.push(s[i]);\r\n        continue;\r\n      }\r\n  \r\n      let pattern = '';\r\n      let times = '';\r\n      while (stack.length && top(stack) !== '[') {\r\n        pattern = stack.pop() + pattern;\r\n      }\r\n  \r\n      if (top(stack) === '[') {\r\n        stack.pop();\r\n  \r\n        while (stack.length && /[0-9]/.test(top(stack))) {\r\n          times = stack.pop() + times;\r\n        }\r\n      }\r\n  \r\n      stack.push(pattern.repeat(parseInt(times)));\r\n    }\r\n  \r\n    return stack.join('');\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1436318491","body":"- Time: push $O(1)$, pop, peek $O(1)$ on average\r\n- Space: $O(N)$\r\n\r\n```tsx\r\nclass MyQueue {\r\n    private _readStack: number[] = [];\r\n    private _writeStack: number[] = [];\r\n\r\n    constructor() {}\r\n\r\n    push(x: number): void {\r\n        this._writeStack.push(x);\r\n    }\r\n\r\n    pop(): number {\r\n        if (this.empty()) return -1;\r\n        if (!this._readStack.length) this._pour();\r\n        return this._readStack.pop()!;\r\n    }\r\n\r\n    peek(): number {\r\n        if (!this._readStack.length) this._pour();\r\n        return this._readStack[this._readStack.length - 1];\r\n    }\r\n\r\n    empty(): boolean {\r\n        return this._writeStack.length === 0 && this._readStack.length === 0;\r\n    }\r\n\r\n    _pour(): void {\r\n        while (this._writeStack.length)\r\n            this._readStack.push(this._writeStack.pop()!);\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436331511","body":"- Time: $O(N)$\r\n- Space: $O(N)$\r\n```tsx\r\nfunction peek<T>(arr: T[]): T {\r\n  return arr[arr.length - 1];\r\n}\r\n\r\nfunction maxChunksToSorted(arr: number[]): number {\r\n  const stk: number[] = [];\r\n\r\n  for (let num of arr) {\r\n    const maxInChunk = Math.max(peek(stk) ?? num, num);\r\n\r\n    while (stk.length > 0 && peek(stk) > num) {\r\n      stk.pop();\r\n    }\r\n\r\n    stk.push(maxInChunk);\r\n  }\r\n\r\n  return stk.length;\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436336096","body":"- Time: $O(N)$\r\n- Space: $O(1)$\r\n```tsx\r\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\r\n    if (!head) return null;\r\n\r\n    let len = 1;\r\n    let p = head;\r\n\r\n    while (p.next) {\r\n        p = p.next;\r\n        len++;\r\n    }\r\n\r\n    p.next = head;\r\n    k %= len;\r\n    k = len - k;\r\n\r\n    while (k--) {\r\n        p = p.next;\r\n    }\r\n\r\n    const rotatedHead = p.next;\r\n    p.next = null;\r\n    return rotatedHead;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437811498","body":"- Time: $O(N)$\r\n- Space: $O(N)$\r\n```tsx\r\nfunction swapPairs(head: ListNode | null): ListNode | null {\r\n    if (!head || !head.next) return head;\r\n    const rest = swapPairs(head.next.next);\r\n    const [first, second] = [head, head.next];\r\n    first.next = rest;\r\n    second.next = first;\r\n    return second;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439378192","body":"- Time: $O(N)$\r\n- Space: $O(h)$\r\n```tsx\r\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\r\n  if (!head) return null;\r\n\r\n  let p: ListNode | null = head;\r\n  let len = 0;\r\n  while (p !== null) {\r\n    p = p.next;\r\n    len++;\r\n  }\r\n\r\n  function inorder(start: number, end: number): TreeNode | null {\r\n    if (start > end || !head) return null;\r\n    const mid = (((end - start + 1) / 2) >> 0) + start;\r\n\r\n    const root = new TreeNode();\r\n    root.left = inorder(start, mid - 1);\r\n    root.val = head.val;\r\n    head = head.next;\r\n    root.right = inorder(mid + 1, end);\r\n    return root;\r\n  }\r\n\r\n  return inorder(0, len - 1);\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1451169430","body":"- Time: $O(N)$\r\n- Space: $O(1)$\r\n\r\n```tsx\r\nfunction getIntersectionNode(\r\n  headA: ListNode | null,\r\n  headB: ListNode | null,\r\n): ListNode | null {\r\n  if (!headA || !headB) return null;\r\n\r\n  let a = headA,\r\n    b = headB;\r\n\r\n  while (a !== b) {\r\n    a = a === null ? headB : a.next;\r\n    b = b === null ? headA : b.next;\r\n  }\r\n\r\n  return a;\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1451176338","body":"- Time: $O(N)$\r\n- Space: $O(1)$\r\n```tsx\r\nfunction detectCycle(head: ListNode | null): ListNode | null {\r\n    if (!head || !head.next) return null;\r\n\r\n    let fast = head, slow = head;\r\n\r\n    while (fast && fast.next) {\r\n        fast = fast.next.next;\r\n        slow = slow.next;\r\n        if (fast === slow) break;\r\n    }\r\n\r\n    if (fast !== slow) return null;\r\n\r\n    fast = head;\r\n    while (fast != slow) {\r\n        fast = fast.next;\r\n        slow = slow.next;\r\n    }\r\n    return fast;\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1451234551","body":"- Time: $O(1)$\r\n- Space: $O(N)$\r\n\r\n```tsx\r\nclass DLinkedListNode {\r\n  key: number;\r\n  value: number;\r\n  prev: DLinkedListNode | null;\r\n  next: DLinkedListNode | null;\r\n\r\n  constructor(\r\n    key: number,\r\n    value: number,\r\n    prev: DLinkedListNode | null = null,\r\n    next: DLinkedListNode | null = null,\r\n  ) {\r\n    this.key = key;\r\n    this.value = value;\r\n    this.prev = prev;\r\n    this.next = next;\r\n  }\r\n}\r\n\r\nclass DLinkedList {\r\n  dummy_head_ = new DLinkedListNode(-1, -1);\r\n  dummy_tail_ = new DLinkedListNode(-1, -1);\r\n\r\n  constructor() {\r\n    this.dummy_head_.next = this.dummy_tail_;\r\n    this.dummy_tail_.prev = this.dummy_head_;\r\n  }\r\n\r\n  // Adds the link to the head of the list.\r\n  stack(node: DLinkedListNode): void {\r\n    this.addAfter(node, this.dummy_head_);\r\n  }\r\n\r\n  // Adds the link to the tail of the list.\r\n  queue(node: DLinkedListNode): void {\r\n    this.addBefore(node, this.dummy_tail_);\r\n  }\r\n\r\n  // Adds the link to a list after another specified link.\r\n  addAfter(node: DLinkedListNode, target: DLinkedListNode): void {\r\n    const next = target.next;\r\n    target.next = node;\r\n    node.next = next;\r\n    if (next) next.prev = node;\r\n    node.prev = target;\r\n  }\r\n\r\n  // Adds the link to a list before another specified link.\r\n  addBefore(node: DLinkedListNode, target: DLinkedListNode): void {\r\n    const prev = target.prev;\r\n    if (prev) prev.next = node;\r\n    node.next = target;\r\n    target.prev = node;\r\n    node.prev = prev;\r\n  }\r\n\r\n  // Removes and returns the link at the head of the list.\r\n  pop(): DLinkedListNode | null {\r\n    if (!this.dummy_head_.next) return null;\r\n    return this.remove(this.dummy_head_.next);\r\n  }\r\n\r\n  // Removes and returns the link at the tail of the list.\r\n  popTail(): DLinkedListNode | null {\r\n    if (!this.dummy_tail_.prev) return null;\r\n    return this.remove(this.dummy_tail_.prev);\r\n  }\r\n\r\n  // Remove a specified link from the list.\r\n  remove(target: DLinkedListNode): DLinkedListNode | null {\r\n    const prev = target.prev;\r\n    const next = target.next;\r\n    if (prev) prev.next = next;\r\n    if (next) next.prev = prev;\r\n    target.prev = target.next = null;\r\n    return target;\r\n  }\r\n\r\n  // Returns the link at the head of the list without removing it.\r\n  peek(): DLinkedListNode | null {\r\n    return this.dummy_head_.next;\r\n  }\r\n\r\n  // Returns the link at the tail of the list without removing it.\r\n  peekTail(): DLinkedListNode | null {\r\n    return this.dummy_tail_.prev;\r\n  }\r\n\r\n  stringify(): string {\r\n    const list: Array<[number, number]> = [];\r\n\r\n    let p = this.dummy_head_.next;\r\n\r\n    while (p && p != this.dummy_tail_) {\r\n      list.push([p.key, p.value]);\r\n      p = p.next;\r\n    }\r\n    return JSON.stringify(list);\r\n  }\r\n}\r\n\r\nclass LRUCache {\r\n  dLinkedList = new DLinkedList();\r\n  key2ValueNodeMap_: { [index: number]: DLinkedListNode } = Object.create(null);\r\n  capacity_: number;\r\n  stored_: number = 0;\r\n\r\n  constructor(capacity: number) {\r\n    this.capacity_ = capacity;\r\n  }\r\n\r\n  get(key: number): number {\r\n    if (key in this.key2ValueNodeMap_) {\r\n      return this.refreshCache_(key);\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  put(key: number, value: number): void {\r\n    if (key in this.key2ValueNodeMap_) {\r\n      this.refreshCache_(key, value);\r\n      return;\r\n    }\r\n\r\n    if (this.stored_ === this.capacity_) {\r\n      const removedNode = this.dLinkedList.popTail();\r\n      if (removedNode) delete this.key2ValueNodeMap_[removedNode.key];\r\n      this.stored_--;\r\n    }\r\n\r\n    const valueNode = new DLinkedListNode(key, value);\r\n    this.dLinkedList.stack(valueNode);\r\n    this.key2ValueNodeMap_[key] = valueNode;\r\n\r\n    this.stored_++;\r\n  }\r\n\r\n  refreshCache_(key: number, value?: number): number {\r\n    const updateNode = this.key2ValueNodeMap_[key];\r\n    if (value !== undefined) updateNode.value = value;\r\n    this.dLinkedList.remove(updateNode);\r\n    this.dLinkedList.stack(updateNode);\r\n    return updateNode.value;\r\n  }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1451256156","body":"- Time: $O(N)$\r\n- Space: $O(h)$\r\n```tsx\r\nfunction maxDepth(root: TreeNode | null): number {\r\n    if (!root) return 0;\r\n    if (!root.left && !root.right) return 1;\r\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1451257045","body":"- Time: $O(N)$\r\n- Space: $O(1)$\r\n```tsx\r\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\r\n    if (!p && !q) return true;\r\n    if (!p || !q) return false;\r\n    if (p.val !== q.val) return false;\r\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1451261110","body":"- Time: $O(N)$\r\n- Space: $O(h)$\r\n```tsx\r\nfunction sumNumbers(root: TreeNode | null, value: number = 0): number {\r\n  if (!root) return 0;\r\n  value = value * 10 + root.val;\r\n  if (!root.left && !root.right) return value;\r\n  return sumNumbers(root.left, value) + sumNumbers(root.right, value);\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1451316924","body":"- Time: $O(N)$\r\n- Space: $O(h)$\r\n```tsx\r\nfunction findBottomLeftValue(root: TreeNode | null): number {\r\n    let maxDepth = -1;\r\n    let leftmost: number = -1;\r\n\r\n    function dfs(root: TreeNode | null, depth: number): void {\r\n        if (!root) return;\r\n\r\n        if (depth > maxDepth) {\r\n            maxDepth = depth;\r\n            leftmost = root.val;\r\n        }\r\n\r\n        dfs(root.left, depth + 1);\r\n        dfs(root.right, depth + 1);\r\n    }\r\n\r\n    dfs(root, 0);\r\n\r\n    return leftmost;\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451323997","body":"- Time: $O(N)$\r\n- Space: $O(N)$\r\n```tsx\r\nfunction serialize(root: TreeNode | null): string {\r\n  if (!root) return '';\r\n\r\n  const values: string[] = [];\r\n  const queue = [root];\r\n\r\n  while (queue.length) {\r\n    let size = queue.length;\r\n\r\n    while (size--) {\r\n      const node = queue.shift();\r\n      if (node) {\r\n        values.push(String(node.val));\r\n        queue.push(node.left);\r\n        queue.push(node.right);\r\n      } else {\r\n        values.push('#');\r\n      }\r\n    }\r\n  }\r\n\r\n  return values.join(',');\r\n}\r\n\r\n/*\r\n * Decodes your encoded data to tree.\r\n */\r\nfunction deserialize(data: string): TreeNode | null {\r\n  if (!data) return null;\r\n  const values: Array<number | null> = data\r\n    .split(',')\r\n    .map((x) => (x === '#' ? null : parseInt(x)));\r\n\r\n  const root = new TreeNode(values[0]);\r\n  const queue = [root];\r\n  let i = 1;\r\n\r\n  while (queue.length) {\r\n    let size = queue.length;\r\n\r\n    while (size--) {\r\n      const node = queue.shift();\r\n\r\n      if (values[i] !== null) {\r\n        node.left = new TreeNode(values[i]);\r\n        queue.push(node.left);\r\n      }\r\n      i++;\r\n\r\n      if (values[i] !== null) {\r\n        node.right = new TreeNode(values[i]);\r\n        queue.push(node.right);\r\n      }\r\n      i++;\r\n    }\r\n  }\r\n\r\n  return root;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1455723639","body":"- Time: $O(NlogN)$\r\n- Space: $O(N)$\r\n```tsx\r\nfunction verticalTraversal(root: TreeNode | null): number[][] {\r\n  const pointsOnY: { [index: number]: number[] } = {}; // y => [x, val]\r\n\r\n  function dfs(root: TreeNode | null, x: number, y: number): void {\r\n    if (!root) return;\r\n    if (!(y in pointsOnY)) pointsOnY[y] = [];\r\n    pointsOnY[y].push(x, root.val);\r\n    dfs(root.left, x + 1, y - 1);\r\n    dfs(root.right, x + 1, y + 1);\r\n  }\r\n\r\n  dfs(root, 0, 0);\r\n\r\n  return Object.keys(pointsOnY)\r\n    .sort((a, b) => +a - +b)\r\n    .map((y) =>\r\n      pointsOnY[y].sort((a, b) => (a[0] === b[0] ? a[1] - b[1] : a[0] - b[0])),\r\n    );\r\n}\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1455737917","body":"- Time: $O(N)$\r\n- Space: $O(N)$\r\n```tsx\r\nfunction twoSum(nums: number[], target: number): number[] {\r\n    const seen: {[key: number]: number} = {};\r\n\r\n    for (let i = 0; i < nums.length; i++) {\r\n        const diff = target - nums[i];\r\n\r\n        if (diff in seen) return [seen[diff], i];\r\n        seen[nums[i]] = i;\r\n    }\r\n};\r\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mirrors-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jakkiabc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyoneday":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429672378","body":"## 代码\r\n\r\n```js\r\nvar addToArrayForm = function (num, K) {\r\n    const len = num.length || 0;\r\n    let numK = K;\r\n    const result = [];\r\n\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        const a = num[i];\r\n        const b = numK % 10;\r\n       \r\n        let total = a + b;\r\n        numK = total >= 10 ? parseInt(numK / 10) + 1 : parseInt(numK / 10);\r\n        result[i] = total % 10;\r\n    }\r\n    while (numK > 0) {\r\n        result.unshift(numK % 10);\r\n        numK = parseInt(numK / 10);\r\n    }\r\n\r\n    return result;\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431427337","body":"## 代码\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n  const tempArr = [];\r\n  const len = s.length;\r\n  let idx = -1;\r\n  for (let i = 0; i < len; i++) {\r\n    if (s[i] === c) {\r\n      idx = i;\r\n      tempArr[i] = 0;\r\n    } else if (idx === -1) {\r\n      tempArr[i] = Infinity;\r\n    } else {\r\n      tempArr[i] = i - idx;\r\n    }\r\n  }\r\n\r\n  idx = Infinity;\r\n  for (let i = len - 1; i > -1; i--) {\r\n    const val = tempArr[i];\r\n\r\n    if (s[i] === c) {\r\n      idx = i;\r\n    } else if (val > idx - i) {\r\n      tempArr[i] = idx - i ;\r\n    }\r\n  }\r\n\r\n  return tempArr;\r\n};\r\n```\r\n\r\n## 时间复杂度\r\n\r\n- 空间复杂度O(n)\r\n- 时间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433027322","body":"## 代码\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function(maxSize) {\r\n  this.stack = [];\r\n  this.size = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.stack.length < this.size) {\r\n    this.stack.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  if (this.stack.length === 0) {\r\n    return -1;\r\n  } else {    \r\n    return this.stack.pop();\r\n  }\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  const len = k > this.stack.length ? this.stack.length : k;\r\n  for (let i = 0; i < len; i++) {\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434662917","body":"## 代码\r\n\r\n```js\r\nvar decodeString = function(s) {\r\n    const stack = [];\r\n\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] !== ']') {\r\n            stack.push(s[i]);\r\n        } else {\r\n            let result = \"\";\r\n            let tempStr = \"\";\r\n            let num = \"\";\r\n            while (stack[stack.length - 1] !== '[') {\r\n                const c = stack.pop();\r\n                tempStr = c + tempStr;\r\n            }\r\n            stack.pop();\r\n            while (/\\d/.test(stack[stack.length - 1]) && stack.length >= 0) {\r\n                const n = stack.pop();\r\n                num = n + num;\r\n            }\r\n            \r\n            for (let i = 0; i < +num; i++) {\r\n                result += tempStr;\r\n            }\r\n\r\n            for (let j = 0; j < result.length; j++) {\r\n                stack.push(result[j]);\r\n            }\r\n        }\r\n    }\r\n    \r\n    return stack.join(\"\");\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435657520","body":"## 代码\r\n\r\n```js\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    const temStack = [];\r\n    const len = this.stack.length;\r\n    for (let i = 0; i < len; i++) {\r\n        temStack.push(this.stack.pop());\r\n    }\r\n    const res = temStack.pop();\r\n    const len2 = temStack.length;\r\n    for (let j = 0; j < len2; j++) {\r\n        this.stack.push(temStack.pop());\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    const temStack = [];\r\n    const len = this.stack.length;\r\n    for (let i = 0; i < len; i++) {\r\n        temStack.push(this.stack.pop());\r\n    }\r\n    const res = temStack[len - 1];\r\n    for (let j = 0; j < len; j++) {\r\n        this.stack.push(temStack.pop());\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack.length === 0;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435977644","body":"## 代码\r\n\r\n```js\r\nvar maxChunksToSorted = function (arr) {\r\n  const stack = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const lastMax = stack[stack.length - 1];\r\n    if (i === 0) {\r\n      stack.push(arr[i]);\r\n    } else if (arr[i] >= stack[stack.length - 1]) {\r\n      stack.push(arr[i]);\r\n    } else {\r\n      while (arr[i] < stack[stack.length - 1] && stack.length) {\r\n        stack.pop()\r\n      }\r\n      stack.push(lastMax)\r\n    }\r\n  }\r\n  return stack.length;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437030058","body":"## 代码\r\n\r\n```js\r\nvar rotateRight = function (head, k) {\r\n  if (!(head && head.next)) return head;\r\n  if (k === 0) return head;\r\n  let node = head;\r\n  const node4 = head;\r\n  let len = 1;\r\n  while (node.next) {\r\n    len++;\r\n    node = node.next\r\n  }\r\n\r\n    let newLen = k % len === 0 ? 0 : Math.abs(len - k % len);\r\n  if (newLen === 0) return node4;\r\n  while (newLen > 1) {\r\n    newLen--;\r\n    head = head.next;\r\n  }\r\n\r\n  let node3 = head.next;\r\n  head.next = null;\r\n  const node5 = node3;\r\n\r\n  while (node3 && node3.next) {\r\n    node3 = node3.next;\r\n  }\r\n  if (node3) {\r\n    node3.next = node4;\r\n  }\r\n \r\n  return node5;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438554299","body":"## 代码\r\n\r\n```js\r\nvar swapPairs = function(head) {\r\n    if (!head || !head.next) {\r\n        return head\r\n    }\r\n    let pre = head.next\r\n    let next = head\r\n    let tmp = pre.next\r\n    head = head.next\r\n    while (next.next) {\r\n        pre.next = next\r\n        next.next = tmp ? (tmp.next || tmp) : null\r\n        if (tmp) {\r\n            pre = tmp.next\r\n            next = tmp\r\n            tmp = pre ? pre.next : null\r\n        }\r\n    }\r\n    return head\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439984188","body":"## 代码\r\n\r\n```js\r\nvar sortedListToBST = function (head) {\r\n  if (!head) return null;\r\n  if (head && !head.next) {\r\n    return new TreeNode(head.val);\r\n  }\r\n\r\n\r\n  function buildTree(head, tail) {\r\n    if (head === tail) return null;\r\n    const mid = findMid(head, tail);\r\n   \r\n    const topNode = new TreeNode(mid.val);\r\n    topNode.left = buildTree(head, mid);;\r\n    topNode.right = buildTree(mid.next, tail);;\r\n    return topNode;\r\n  }\r\n\r\n  function findMid(head, tail) {\r\n    let slow = head;\r\n    let fast = head;\r\n  \r\n    while (fast !== tail && fast.next !== tail) {\r\n      slow = slow.next;\r\n      fast = fast.next.next;\r\n    }\r\n\r\n    return slow;\r\n  }\r\n\r\n  return buildTree(head, null);\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441144408","body":"## 代码\r\n\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let node1 = headA, node2 = headB;\r\n    while (node1 != node2) {\r\n        node1 = node1 ? node1.next : headB;\r\n        node2 = node2 ? node2.next : headA;\r\n    }\r\n    return node1;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443877376","body":"## 代码\r\n\r\n```js\r\nvar detectCycle = function(head) {\r\n    let slow = fast = head\r\n    while(fast !== null && fast.next !== null) {\r\n        slow = slow.next\r\n        fast = fast.next.next\r\n        if (slow === fast) {\r\n            break\r\n        }\r\n    }\r\n    if (fast == null || fast.next == null) {\r\n        return null\r\n    }\r\n    slow = head\r\n    while(slow !== fast) {\r\n        slow = slow.next\r\n        fast = fast.next\r\n    }\r\n    return slow\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445139859","body":"## 代码\r\n\r\n```js\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n  this.map = new Map();\r\n  this.size = capacity;\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    let val = this.map.get(key)\r\n    if (val !== undefined) {\r\n        this.map.delete(key)\r\n        this.map.set(key, val);\r\n        return val\r\n    }\r\n    \r\n     return -1;\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n    if (this.map.has(key)) {\r\n        this.map.delete(key);\r\n    } else if (this.map.size >= this.size) {\r\n        const k = this.map.keys().next().value;\r\n        this.map.delete(k);\r\n    }\r\n  \r\n    this.map.set(key, value);\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445373942","body":"## 代码\r\n\r\n```js\r\nvar maxDepth = function(root) {\r\n    if (root) {\r\n         const lefttLen = maxDepth(root.left) || 0;\r\n         const rightLen = maxDepth(root.right) || 0;\r\n         return lefttLen > rightLen ? lefttLen + 1 : rightLen + 1;\r\n    } else return 0;\r\n   \r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446006902","body":"## 代码\r\n\r\n```js\r\nvar isSameTree = function(p, q) {\r\n   if (p === null && q === null) return true;\r\n   if (p && (q === null)) return false;\r\n   if (q && (p === null)) return false;\r\n   return  p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447940377","body":"## 代码\r\n\r\n```js\r\nvar sumNumbers = function(root) {\r\n  return dfs(root, '');\r\n\r\n  function dfs(root, prefix) {\r\n    if (!root) return 0;\r\n    const newP = prefix + root.val;\r\n    if (!root.left && !root.right) {\r\n      return newP;\r\n    }\r\n \r\n    const left = dfs(root.left, newP);\r\n    const right = dfs(root.right, newP); \r\n  \r\n    return +left + +right;\r\n  }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chouqin99":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaogeg111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ye2222":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uyplayer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guixian001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junzmer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hx-code":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"admu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxiaomm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pgquestions":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eldinzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangwenzhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnwu6688":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomtao626":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aiweng1981":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richard-lime":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acoada":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duanyaqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429633422","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& nums, int k)\r\n    {\r\n        stack<int> data;\r\n        int tmp;\r\n        int flag = 0;\r\n        for(int i = nums.size() - 1; i > -1; i--)\r\n        {\r\n            tmp = nums[i];\r\n            if(k > 0)\r\n            {\r\n                tmp += k % 10;\r\n                k = k / 10;\r\n            }\r\n            tmp += flag;\r\n            data.push(tmp % 10);\r\n            flag = tmp / 10;\r\n        }\r\n        while(k > 0)\r\n        {\r\n            tmp = flag + k % 10;\r\n            k = k / 10;\r\n            data.push(tmp % 10);\r\n            flag = tmp / 10;\r\n        }\r\n        if(flag)\r\n            data.push(flag);\r\n        vector<int> res;\r\n        while(data.size())\r\n        {\r\n            res.push_back(data.top());\r\n            data.pop();\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431591552","body":"```\r\n###思路\r\n\r\n看解题思路，左右个遍历一次，分别记录距离，然后对比大小\r\n\r\n###代码\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int count = s.length();\r\n        int[] ans = new int[n];\r\n        Arrays.fill(ans, count + 1);\r\n        for (int i = 0, j = -1; i < count; i++) {\r\n            if (s.charAt(i) == c) j = i;\r\n            if (j != -1) ans[i] = i - j;\r\n        }\r\n        for (int i = count - 1, j = -1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) j = i;\r\n            if (j != -1) ans[i] = Math.min(ans[i], j - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n###复杂度分析\r\n\r\n时间复杂度 ：O(n)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433285487","body":"```\r\nclass CustomStack {\r\n\r\n    int[] arr;\r\n    int tail = -1;\r\n\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(tail == arr.length - 1) {\r\n            return;\r\n        }\r\n        arr[++tail] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(tail == -1) {\r\n            return -1;\r\n        }\r\n        return arr[tail--];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i = 0; i < Math.min(k, arr.length); i++) {\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434397904","body":"```\r\nfunction decodeString(s: string): string {\r\n  let numStack = [];\r\n  let strStack: string[] = [];\r\n  let num = 0;\r\n  let result = \"\";\r\n\r\n  for (const str of s) {\r\n    // 是数字\r\n    if (!isNaN(+str)) {\r\n      num = +(num + str);\r\n    } else if (str === \"[\") {\r\n      // 是[，就是字符重复的开始，所以将之前的记录存档\r\n      numStack.push(num);\r\n      num = 0;\r\n      strStack.push(result);\r\n      result = \"\";\r\n    } else if (str === \"]\") {\r\n      // 是]，就准备收口，返回重复后的字符\r\n      let report = numStack.pop();\r\n      result = strStack.pop() + result.repeat(report as number);\r\n    } else {\r\n      // 是字符串，就要拼接起来\r\n      result += str;\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435676973","body":"```\r\nclass MyQueue {\r\npublic:\r\n    stack<int> s1,s2;\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n       s1.push(x); \r\n    }\r\n    \r\n    int pop() {\r\n       while(!s1.empty()){\r\n       s2.push(s1.top());\r\n       s1.pop();\r\n       }\r\n       return(s2.top());\r\n       s2.pop();\r\n    }\r\n    \r\n    int peek() {\r\n        int p=s2.top();\r\n        return p;\r\n    }\r\n    \r\n    bool empty() {\r\n        if(!s1.empty()||!s2.empty())\r\n        return false;\r\n        else return true;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437232291","body":"```\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(head==NULL)\r\n            return NULL;\r\n        ListNode* temp = head;\r\n        int len = 1;\r\n        while(temp->next!=NULL)\r\n        {    \r\n            temp = temp->next;\r\n            ++len;\r\n        }\r\n        temp->next = head;\r\n        int step = len - k%len;\r\n        while(--step)\r\n            head = head->next;\r\n        temp = head->next;\r\n        head->next = NULL;\r\n        return temp;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438704053","body":"```\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        if head is None or head.next is None: return head\r\n        start, end, len = head, None, 0\r\n        while head:\r\n            end = head\r\n            head = head.next\r\n            len += 1\r\n        end.next = start\r\n        pos = len - k % len\r\n        while pos > 1:\r\n            start = start.next\r\n            pos -= 1\r\n        ret = start.next\r\n        start.next = None\r\n        return ret\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440251594","body":"```\r\nclass Solution:\r\n    def divideConquer(self, segment: Optional[ListNode], length: int) -> Optional[TreeNode]:\r\n        if not segment: return\r\n        if not segment.next: return TreeNode(segment.val)\r\n        # find the middle node to divide and conquer\r\n        prev, middle = segment, segment.next\r\n        for _ in range(length//2-1):\r\n            prev, middle =  prev.next, middle.next \r\n        # divide and conquer\r\n        prev.next = None\r\n        leftTree = self.divideConquer(segment, length//2)\r\n        rightTree = self.divideConquer(middle.next, length-length//2-1)\r\n        middle.next = None\r\n        return TreeNode(middle.val, leftTree, rightTree) \r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head: return\r\n        if not head.next: return TreeNode(head.val)\r\n        # Get the length of the linked list\r\n        length = 0\r\n        cur = head\r\n        while cur:\r\n            length += 1\r\n            cur = cur.next\r\n        return self.divideConquer(head, length)\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445112872","body":"```\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.cache = OrderedDict()\r\n        self.length = 0\r\n        self.capacity = capacity\r\n        \r\n    def get(self, key: int) -> int:\r\n        if key in self.cache:\r\n            self.cache.move_to_end(key)\r\n            return self.cache[key]\r\n        return -1\r\n        \r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.cache:\r\n            self.cache[key] = value\r\n            self.cache.move_to_end(key)\r\n        else:\r\n            if self.length < self.capacity:\r\n                self.length += 1\r\n            else:\r\n                self.cache.popitem(False)\r\n            self.cache[key] = value\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1452831629","body":"```\r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        def dfs(nood):\r\n            if not nood:\r\n                return\r\n\r\n            col,row,val = hashmap[nood]\r\n            if nood.left:\r\n                hashmap[nood.left] = [col - 1, row + 1, nood.left.val]\r\n                dfs(nood.left)\r\n            if nood.right:\r\n                hashmap[nood.right] = [col + 1, row + 1, nood.right.val]\r\n                dfs(nood.right)\r\n\r\n        hashmap = dict()\r\n        hashmap[root] = [0,0,root.val]\r\n        dfs(root)\r\n        lt = sorted(hashmap.values())\r\n        n = len(lt)\r\n        ans = []\r\n        i = 0\r\n        while i < n:\r\n            j = i\r\n            tmp = []\r\n            while j < n and lt[j][0] == lt[i][0]:\r\n                tmp.append(lt[j][2])\r\n                j+=1\r\n            ans.append(tmp)\r\n            i = j\r\n        return ans\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457725263","body":"```\r\npublic static int lengthOfLongestSubstring(String s) {\r\n        int[] m = new int[128];\r\n        int ans = 0;\r\n        for (int low = 0, fast = 0; fast < s.length(); fast++) {\r\n            low = Math.max(m[s.charAt(fast)], low);\r\n            ans = Math.max(ans, fast - low + 1);\r\n            m[s.charAt(fast++)] = fast;\r\n        }\r\n        return ans;\r\n    }\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465397288","body":"```\r\nimport collections\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        # monotonic stack -- decreasing stack, so max value is at top of queue\r\n        mono = collections.deque()\r\n        ans = []\r\n\r\n        for i, num in enumerate(nums):\r\n            while mono and nums[mono[-1]] <= num:\r\n                mono.pop()\r\n            mono.append(i)\r\n            # when sliding window left, we pop the head of deque, that's why we stored the index\r\n            if mono[0] == i - k:\r\n                mono.popleft()\r\n            # when window size == k, we start to record and append max value to results\r\n            if i >= k - 1:\r\n                ans.append(nums[mono[0]])\r\n        return ans\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaiykk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cachezhou0617":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangtuo1999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cytrue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyryan-web":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429623057","body":"#### 解题思路\n  1. 低位到高位逐位将数字加在一起\n  2. 若加法的结果大于等于 1010，把进位的 11 加入到下一位的计算中\n\n\n#### 代码实现\n\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度: O(max(n,logk), 其中 nn 为数组的长度\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431493869","body":"#### 解题思路\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 C。\n- 如果只在一个方向找到，直接计算字符距离。\n- 如果两个方向都找到，取两个距离的最小值\n\n#### 代码实现\n\n```\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  const res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433182188","body":"### 思路\n  用数组模拟栈，用数组原生方法pop、push方法实现\n  \n### 代码\n\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length >= this.maxSize) {\n    return;\n  }\n  this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  return this.stack.length ? this.stack.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const length = Math.min(k, this.stack.length);\n  for (let i = 0; i < length; i++) {\n    this.stack[i] += val;\n  }\n};\n```\n### 复杂度\n- 时间复杂度 \n\n  push: O(1)\n\n  pop：O(1)\n  \n  increment：O(K) \n \n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434718608","body":"### 思路\n1. 将字符串从末尾开始遍历\n2. 遇到“]”入栈\n3. 拼接要出栈的字符串，遇到\"[\"出栈\n4. \"[\"后紧跟数据，累计最终的数字\n5. 将遍历后入栈的字符串出栈，进行反转拼接，得到最终结果\n\n### 代码\n\n```\n/**\n * @param {string} s\n * @return {string}\n */\n var decodeString = function(s) {\n    let stack = []; // 定义存储字符串的栈\n    let str = \"\"; // 定义最终返回的字符串\n    let num = \"\"; // 定义字符串重复的次数\n    const length = s.length;\n    for (let i = length - 1; i >= 0; i--) {\n      console.log(\"s[i]\", stack, i);\n      if (s[i] >= \"0\" && s[i] <= \"9\") {\n        // 解析出连续的数字\n        while (s[i] >= \"0\" && s[i] <= \"9\") {\n          num += s[i];\n          i--;\n          console.log(\"num\", num);\n        }\n        stack.push(\n          str.repeat(\n            Number(\n              num\n                .split(\"\")\n                .reverse()\n                .join(\"\")\n            )\n          )\n        ); // 拼接字符\n        str = \"\";\n        num = \"\"; //清空计数\n        i++;\n      } else if (s[i] === \"[\") {\n        // 遇到\"[\"时，将后续字符出栈\n        let curStr = stack.pop();\n        while (curStr !== \"]\") {\n          str += curStr;\n          curStr = stack.pop(); // 拼接出栈的字符串 \"[\"后跟着的一定是数字\n        }\n      } else {\n        // 将字符 或 \"]\"入栈\n        stack.push(s[i]);\n      }\n    }\n    return stack.reverse().join(\"\");\n  };\n```\n\n### 复杂度分析\n- 时间复杂度：O(n),循环遍历一遍\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435673074","body":"### 解题思路\n    定义两个栈，\n-   一个是pushStack, 执行push操作时，将元素入pushStack栈\n-   另一个是popStack,执行pop操作时，在popStack取元素；当popStack栈为空时，依次将pushStack元素pop取出，push进pushStack栈\n\n\n### 代码实现\n```\nvar MyQueue = function() {\n    this.pushStack = [];\n    this.popStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack[this.popStack.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.popStack.length === 0 && this.pushStack.length === 0;\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(1)$\n- 空间复杂度 $O(N)$, N为队列元素个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436018080","body":"#### 解题思路\n> 单调栈\n\n#### 代码实现\n\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    //定义最大数据栈\n    let res=[]\n    for(let i = 0; i < arr.length; i++) {\n        if(res.length==0){\n            res.push(arr[i])\n        }else{\n            if(arr[i]>=res[res.length-1]){\n                res.push(arr[i])\n            }else{\n                let max=res[res.length-1]\n                while(arr[i]<res[res.length-1]){\n                    res.pop()\n                }\n                res.push(max)\n            }\n        }\n    }\n    return res.length\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N)$，N为数组长度\n- 空间复杂度：$O(N)$，N为数组长度","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438685049","body":"\n### 解题思路\n1. 设置虚拟节点，定义pre指针，指向当前虚拟节点\n2. 当pre.next以及pre.next.next指针均不为空时，开始交换\n3. 令cur指针指向pre.next；next指针指向pre.next.next\n4. 交换过程如下：\n- pre.next = next\n- cur.next = next.next\n- next.next = cur\n- pre = cur\n\n### 代码实现\njavaScript\n\n```\nvar swapPairs = function(head) {\n    let dummyNode = new ListNode(0);\n    dummyNode.next = head;\n    let pre = dummyNode;\n    while(pre.next && pre.next.next) {\n        const cur = pre.next;\n        const next = pre.next.next;\n        pre.next = next;\n        cur.next = next.next;\n        next.next = cur;\n        pre = cur;\n    }\n    return dummyNode.next;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$, N为链表中节点数目\n- 空间复杂度 $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439928204","body":"### 解题思路\n    分治 \n### 代码实现\njavaScript\n\n```\nvar sortedListToBST = function(head) {\n  if(!head) return null;\n  let length = 0;\n  let current = head;\n  while(current){\n    current = current.next\n    length++\n  }\n\n  var buildBST = function(start, end){\n    if(start > end) return null;\n\n    const mid = start + ((end - start)>> 1)\n    const leftSide = buildBST(start, mid - 1);\n\n    const root = new TreeNode(head.val)\n    head = head.next;\n    root.left = leftSide\n\n    root.right = buildBST(mid+1, end)\n    return root;\n  }\n\n  return buildBST(0, length - 1)\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(logN)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441765166","body":"### 解题思路：\n1. 使用pA、pB两个指针分别指向A、B两个链表，两个指针以相同的速率向后移动\n2. 当pA指针移动到了A链接的末尾、令指针pA指向B链表的头部\n3. 当pB指针移动到了A链接的末尾、令指针pB指向A链表的头部\n4. 当pA、pB指针相遇时即为两个指针相遇的起点，否则两个指针不相交\n\n```\nvar getIntersectionNode = function(headA, headB) {\n    let pA = headA;\n    let pB = headB;\n    while (pA != pB) {\n        pA = pA === null ? headB : pA.next;\n        pB = pB === null ? headA : pB.next;\n    }\n    return pA;\n};\n```\n### 复杂度分析\n- 时间复杂度 O(N)\n- 空间复杂度 O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443711558","body":"### 解题思路\n\n从head开始快慢指针，快指针每次两步，慢指针每次一步，第一次相遇时将快指针回到head，改为每次前进一步，第二次相遇点为环起始点\n\n### 代码实现\n\n```\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if(head === null || head.next === null) return null;\n    // 定义快慢两个指针、只想链表头部\n    let fast = head;\n    let slow = head;\n    // 快指针走两步，满指针走一步\n    do {\n        if (fast !== null && fast.next !== null) {\n            fast = fast.next.next;\n        } else {\n            fast = null\n        }\n        slow = slow.next;\n    } while(fast !== slow)\n    if (fast === null) return null;\n    // 相遇后将快指针指向链表头部\n    fast = head;\n    while(fast !== slow) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return fast;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445134613","body":"### 解题思路\n    采用哈希表,保证get操作在O(1)时间复杂度内完成，\n    构建双向链表，保证put操作在O(1)时间复杂度内完成\n### 代码实现\n> javaScript\n\n```\nvar LinkedList = function(key, val) {\n    this.key = key;\n    this.val = val;\n    this.prev = null;\n    this.next = null;\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.size = 0;\n    this.cache = new Map();\n    // 构建虚拟节点\n    this.dummyHead = new LinkedList();\n    this.dummyTail = new LinkedList();\n    this.dummyHead.next = this.dummyTail;\n    this.dummyTail.prev = this.dummyHead;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (!this.cache.has(key)) {\n        return -1;\n    }\n    const node = this.cache.get(key);\n    // 将节点移动至链表头部\n    this.removeNode(node);\n    this.appendToHead(node);\n    return node.val;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    // 判断关键字key是否存在于缓存中\n    const node = this.cache.get(key);\n    if (node) {\n        // 更新关键字的值\n        node.val = value;\n        this.cache.set(key, node);\n        // 将关键字移动至链表头部\n        this.removeNode(node);\n        this.appendToHead(node);\n    } else {\n        // 当缓存容量达到上限时\n        if (this.size === this.capacity) {\n            // 删除最久未使用的\n            this.removeTailNode();\n        }\n        // 创建新节点\n        const newNode = new LinkedList(key, value);\n        this.cache.set(key, newNode)\n        this.appendToHead(newNode);\n        this.size ++;\n    }\n};\n\nLRUCache.prototype.removeNode = function(node) {\n    let preNode = node.prev;\n    let nextNode = node.next;\n    preNode.next = nextNode;\n    nextNode.prev = preNode;\n}\n\nLRUCache.prototype.appendToHead = function(node) {\n    let head = this.dummyHead.next;\n    this.dummyHead.next = node;\n    node.prev = this.dummyHead;\n    node.next = head;\n    head.prev = node;\n}\n\nLRUCache.prototype.removeTailNode = function() {\n    this.size --;\n    let tailNode = this.dummyTail.prev;\n    this.cache.delete(tailNode.key);\n    this.removeNode(tailNode);\n}\n```\n### 复杂度分析\n- 时间复杂度：$O(1)$ \n- 空间复杂度：$O(capacity)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445370562","body":"\n### 解题思路\n> DFS\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root, depth = 0) {\n  if(!root) return depth;\n  return Math.max(maxDepth(root.left, depth + 1),maxDepth(root.right, depth + 1))\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$ N为二叉树中节点的个数\n- 空间复杂度 $(K)$, k为二叉树的深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446531221","body":"### 解题思路\n> DFS\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n  if(!p && !q) return true\n  if(!p || !q) return false;\n  if(p.val != q.val) return false;\n\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448228558","body":"\n### 解题思路\n> DFS\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n  if(!p && !q) return true\n  if(!p || !q) return false;\n  if(p.val != q.val) return false;\n\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450155679","body":"\n### 解题思路\n> BFS\n\n### 代码实现\n> javaScript\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n  if(!root) return null;\n  const queue = [root]\n  let mostLeft = null;\n  while(queue.length > 0){\n    let curLevelSize = queue.length\n    mostLeft = queue[0]\n    for(let i = 0; i < curLevelSize; i++){\n      const curNode = queue.shift();\n      curNode.left && queue.push(curNode.left)\n      curNode.right&& queue.push(curNode.right)\n    }\n  }\n  return mostLeft.val\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$ N为二叉树的节点\n- 空间复杂度 $O(N)$ N为二叉树的节点","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451942310","body":"### 解题思路\n> DFS（递归）\n\n### 代码实现\n> javaScript\n\n```\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nconst serialize = (root) => {\n  if (root == null) {                  // 遍历到 null 节点\n    return 'X';\n  } \n  const left = serialize(root.left);   // 左子树的序列化结果\n  const right = serialize(root.right); // 右子树的序列化结果\n  return root.val + ',' + left + ','+ right; // 按  根,左,右  拼接字符串\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n  const list = data.split(',');   // split成数组\n\n  const buildTree = (list) => {   // 基于list构建当前子树\n    const rootVal = list.shift(); // 弹出首项，获取它的“数据”\n    if (rootVal == \"X\") {         // 是X，返回null节点\n      return null;\n    }\n    const root = new TreeNode(rootVal); // 不是X，则创建节点\n    root.left = buildTree(list);        // 递归构建左子树\n    root.right = buildTree(list);       // 递归构建右子树\n    return root;                        // 返回当前构建好的root\n  };\n\n  return buildTree(list);\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453451923","body":"### 解题思路\n> BFS\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n  if(!root) return root\n  const result = []\n  const obj = new Map();\n  // [node, rowVal, colVal]\n  const queue = [[root,0, 0]]\n\n  while(queue.length){\n    const [node, row, col] = queue.shift()\n    obj.set(col, (obj.get(col) || []).concat([[node.val, row]]))\n    node.left && queue.push([node.left, row + 1, col - 1 ])\n    node.right && queue.push([node.right, row + 1 , col + 1 ])\n  }\n\n  // sort\n  let sortedKeys = [...obj.keys()].sort((a,b) => a - b)\n\n  for(const key of sortedKeys){\n    let temp = obj.get(key)\n    temp = temp.sort((a,b) => {\n      if(a[1] != b[1]){\n        return a[1] - b[1]\n      }\n      return a[0] - b[0]\n    })\n    result.push(temp.map((item) => item[0]))\n  }\n  return result;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(NlogN)$\n- 空间复杂度 $O(N)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455122982","body":"### 解题思路\n> 桶排序\n\n### 代码实现\n> javaScript\n\n```\nlet topKFrequent = function(nums, k) {\n    let map = new Map(), arr = [...new Set(nums)]\n    nums.map((num) => {\n        if(map.has(num)) map.set(num, map.get(num)+1)\n        else map.set(num, 1)\n    })\n    \n    // 如果元素数量小于等于 k\n    if(map.size <= k) {\n        return [...map.keys()]\n    }\n    \n    return bucketSort(map, k)\n};\n\n// 桶排序\nlet bucketSort = (map, k) => {\n    let arr = [], res = []\n    map.forEach((value, key) => {\n        // 利用出现频率作为下标，将数据分配到各个桶中\n        if(!arr[value]) {\n            arr[value] = [key]\n        } else {\n            arr[value].push(key)\n        }\n    })\n    // 倒序遍历获取出现频率最大的前k个数\n    for(let i = arr.length - 1;i >= 0 && res.length < k;i--){\n        if(arr[i]) {\n            res.push(...arr[i])\n        }\n\t}\n\treturn res\n}\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456202431","body":"\n### 解题思路\n> 哈希表\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n    const maps = Array(points.length)\n        .fill(0)\n        .map(() => ({}));\n    let count = 0;\n\n    points.forEach((a, i) => {\n        const map = maps[i];\n        points.forEach((b, j) => {\n            if (a !== b) {\n                const dist = calcDistOf2Points(a, b);\n                map[dist] = (map[dist] || 0) + 1;\n            }\n        });\n        for (const dist in map) {\n            const num = map[dist];\n            if (num > 1) count += num * (num - 1);\n        }\n    });\n    return count;\n    function calcDistOf2Points([x1, y1], [x2, y2]) {\n        return (x1 - x2) ** 2 + (y1 - y2) ** 2;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(Nˆ2)$ N 是数组长度\n- 空间复杂度 $O(Nˆ2)$ 需要 N 个哈希表来记录 N 个点到其他 N-1 个点的距离，最坏的情况是每个点到其他点的距离都不一样，那每个哈希表的大小就是 N-1","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465217405","body":"### 解题思路\n> 二分法\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n  let left = 0;\n  let right = nums.length - 1;\n  while(left <= right) {\n    const mid = Math.floor(left + (right - left) / 2);\n    if(target === nums[mid]) {\n        right = mid - 1;\n    } else if(target > nums[mid]){\n        left = mid + 1\n    } else {\n        right = mid - 1\n    }\n  }\n  return left;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(logN)$\n- 空间复杂度 $O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475254974","body":"#### 代码实现\n\n```\nvar numberOfRounds = function(loginTime, logoutTime) {\n    let [startHour, startMinute] = getTime(loginTime);\n    let [endHour, endMinute] = getTime(logoutTime);\n    let day = 0;\n\n    if (startHour * 60 + startMinute > endHour * 60 + endMinute) {\n        day++;\n    }\n\n    if (startMinute > 0 && startMinute < 15) {\n        startMinute = 15;\n    } else if (startMinute > 15 && startMinute < 30) {\n        startMinute = 30;\n    } else if (startMinute > 30 && startMinute < 45) {\n        startMinute = 45;\n    } else if (startMinute > 45 && startMinute < 60) {\n        startMinute = 0;\n        startHour++;\n    }\n\n    if (endMinute > 0 && endMinute < 15) {\n        endMinute = 0;\n    } else if (endMinute > 15 && endMinute < 30) {\n        endMinute = 15;\n    } else if (endMinute > 30 && endMinute < 45) {\n        endMinute = 30;\n    } else if (endMinute > 45 && endMinute < 60) {\n        endMinute = 45;\n    }\n\n    const startTime = startHour * 60 + startMinute;\n    const endTime = endHour * 60 + endMinute + 24 * 60 * day;\n\n    return Math.max(0, endTime - startTime) / 15;\n\n    function getTime(time) {\n        const arr = time.split(':');\n        arr[0] = parseInt(arr[0]);\n        arr[1] = parseInt(arr[1]);\n        return arr;\n    }\n};\n```\n#### 复杂度分析\n- 时间复杂度 $O(1)$\n- 空间复杂度 $O(1)$","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1484122075","body":"##### 代码实现\n\n```\nvar smallestDistancePair = function(nums, k) {\n    nums.sort((a, b) => a - b);\n    let n = nums.length, left = 0, right = nums[n - 1] - nums[0];\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        let cnt = 0;\n        for (let j = 0; j < n; j++) {\n            const i = binarySearch(nums, j, nums[j] - mid);\n            cnt += j - i;\n        }\n        if (cnt >= k) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n};\n\nconst binarySearch = (nums, end, target) => {\n    let left = 0, right = end;\n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493352771","body":"[401. 二进制手表](https://leetcode.cn/problems/binary-watch/)\n\n##### 解题思路\n> 枚举时分\n\n##### 代码实现\n\n```\nvar readBinaryWatch = function(turnedOn) {\n    const ans = [];\n    for (let h = 0; h < 12; ++h) {\n        for (let m = 0; m < 60; ++m) {\n            if (h.toString(2).split('0').join('').length + m.toString(2).split('0').join('').length === turnedOn) {\n                ans.push(h + \":\" + (m < 10 ? \"0\" : \"\") + m);\n            }\n        }\n    }\n    return ans;\n};\n\n```\n##### 复杂度分析\n- 时间复杂度 $O(1)$\n- 空间复杂度 $O(1)$","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501141906","body":"\n##### 解题思路\n> 动态规划\n\n##### 代码实现\n\n```\nvar rob = function(nums) {\n    const len = nums.length;\n    if(len == 0)\n        return 0;\n    const dp = new Array(len + 1);\n    dp[0] = 0;\n    dp[1] = nums[0];\n    for(let i = 2; i <= len; i++) {\n        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]);\n    }\n    return dp[len];\n};\n\n```\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510398756","body":"\n##### 解题思路\n> 动态规划\n\n##### 代码实现\n\n```\nvar findTargetSumWays = function(nums, target) {\n    let sum = 0;\n    for (const num of nums) {\n        sum += num;\n    }\n    const diff = sum - target;\n    if (diff < 0 || diff % 2 !== 0) {\n        return 0;\n    }\n    const neg = Math.floor(diff / 2);\n    const dp = new Array(neg + 1).fill(0);\n    dp[0] = 1;\n    for (const num of nums) {\n        for (let j = neg; j >= num; j--) {\n            dp[j] += dp[j - num];\n        }\n    }\n    return dp[neg];\n};\n\n```\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519088243","body":"#### 代码实现\n\n```\nvar mergeKLists = function(lists) {\n  if (!lists.length) {\n    return null;\n  }\n  const merge = (head1, head2) => {\n    let dummy = new ListNode(0);\n    let cur = dummy;\n    while (head1 && head2) {\n      if (head1.val < head2.val) {\n        cur.next = head1;\n        head1 = head1.next;\n      } else {\n        cur.next = head2;\n        head2 = head2.next;\n      }\n      cur = cur.next;\n    }\n    cur.next = head1 == null ? head2 : head1;\n    return dummy.next;\n  };\n  const mergeLists = (lists, start, end) => {\n    if (start + 1 == end) {\n      return lists[start];\n    }\n    let mid = (start + end) >> 1;\n    let head1 = mergeLists(lists, start, mid);\n    let head2 = mergeLists(lists, mid, end);\n    return merge(head1, head2);\n  };\n  return mergeLists(lists, 0, lists.length);\n};\n```\n\n#### 复杂度分析\n- 空间复杂度： $O(logk)$\n- 时间复杂度:  $O(O(kn×logk))$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnxizhao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"incipe-win":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"revisegoal":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckysq999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dereklisdr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"perfqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mryao1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"likeyousmile":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhg1992":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liquanluo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aq666888":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samlu-ecnu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongxiangxiang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hatorimain":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429112268","body":"# 解法思路1:\r\n\r\n这题本质上就像做加法一样。我们先用linkedlist来存结果，因为往链表头加一个数的操作是O(1)\r\n\r\n`num = [1,2,0,0], k = 34`\r\n\r\n可以当作 num的最后一位加了34。然后我们保留它的最后一位，也就是往我们的结果数组里面add一个(nums[i] + k) % 10。\r\n\r\n然后num[i - 1]的前面一位要进位。这个要进的位就是 34/10的结果。这里是3。\r\n\r\n然后我们一直进行这个操作直到遍历完整个数组。这里有个问题就是k本身的长度可能比num的数组长度大。所以如果k>0（说明k没加完）。我们继续把k % 10，结果加到res数组里。然后再k/10进位。\r\n\r\n## 注意要点：\r\n注意k可能本身的长度比num长。\r\n\r\n这道题空间复杂度是O(1)因为只有返回的数组占了空间复杂度。算法本身没有用任何辅助的数据结构。\r\n\r\n## 复杂度：\r\n\r\n时间：$O(n)$\r\n\r\n（O(k)，K是k的位数))\r\n\r\n空间：$O(1)$\r\n\r\n## 第一次自己写的代码：\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> tmp = new LinkedList<>();\r\n        for(int i = num.length - 1; i >= 0; i--) {\r\n            num[i] += k;\r\n            tmp.addFirst(num[i] % 10);\r\n            k = num[i] / 10;\r\n        }\r\n        while(k > 0) {\r\n            tmp.addFirst(k % 10);\r\n            k = k / 10;\r\n        } \r\n        List<Integer> res = new ArrayList<>(tmp);\r\n        return res;\r\n    \r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430140762","body":"# 解法思路1:\n\n## 注意要点：\n\n这题先指针从左扫到右，再从右扫到左，把初始index设成一个很大的负值（这里设了20000是因为长度最大值是10000）。这里不能设Integer.MIN_VALUE因为之后会overflow。  \n\n计算从左往右时每个字符到字符c的距离。遇到第一个之前距离都是非常大。\n\n扫完以后再从右往左扫，比较这个新的距离跟原来的距离哪个更小，这里注意index要设成一个正的很大的数，因为这样遇到第一个c之前右边的结果产生的数都会非常大，通过和原来的res[i]比较能得到正确的值。\n\n## 复杂度：\n\n时间：$O(n)$\n\n空间：$O(1)$\n\n两个for循环所以是O(n),开的数组只用来返回结果所以是O(1)\n\n## 第一次自己写的代码：\n\n```jsx\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        int index = -20000;\n        for(int i = 0; i < s.length(); i++) {\n            if(s.charAt(i) == c) index = i;\n            res[i] = i - index;\n        }\n        index = 20000;\n        for(int i = s.length() - 1; i >= 0; i--) {\n            if(s.charAt(i) == c) index = i;\n            res[i] = Math.min(index - i, res[i]);\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1431936045","body":"# 题目名\r\n\r\n链接：[https://leetcode.com/problems/design-a-stack-with-increment-operation/description/](https://leetcode.com/problems/design-a-stack-with-increment-operation/description/)\r\n\r\n# 解法思路1:\r\n\r\n一开始global声明一个stack和一个increment数组。\r\n\r\n用stack的好处是不用多加一个变量来记录栈现在的size，不容易出错。\r\n\r\nincrement数组用来记录增加前几个index范围的值。\r\n\r\n比如increment[2]用来增加index [0, 2]范围的值\r\n\r\n实现push操作很简单。就是栈当前的size只要小于maxSize，就push。\r\n\r\nincrement数组用来增加数组[0, k - 1]范围的值。\r\n\r\n如果increment(k, val)了。那么我们就让i = Math.min(k, stack.size()) - 1。\r\n\r\nincrement[i] += val\r\n\r\n如果这时i < 0，说明没有区间的值让我们增加，不操作。\r\n\r\npop的时候同理。我们弹出栈顶的值，此时i = stack.size() - 1。\r\n\r\n此时增量操作过的栈顶实际的值应该是 increment[i] + stack.pop()\r\n\r\n因为我们已经加上了increment[i]的值。所以increment[i]清零。\r\n\r\nincrement[i - 1] += increment[i];\r\n\r\n然后返回increment[i] + stack.pop()\r\n\r\n优化的话可以把increment用一个linkedlist来维护，这样remove和add的操作都是1.空间复杂度最多是当前stack的size。\r\n\r\n## 注意要点：\r\n\r\n感觉这题的思路挺简单的就是前缀和实现O(1)操作，但是实际写的时候各种边界出了很多bug还de不出来。\r\n\r\n## 复杂度：\r\n\r\n时间：$O(1)$\r\n\r\n空间：$O(stackSize/N)$\r\n\r\npop, push, increment本身时间复杂度是1，但是因为我们额外要维护一个increment链表，所以平均下来空间复杂度是O(cnt/N)\r\n\r\n## 第一次自己写的代码：\r\n\r\n```java\r\nclass CustomStack {\r\n\r\n    Stack<Integer> stack;\r\n    LinkedList<Integer> increment;\r\n    int maxSize;\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        stack = new Stack<Integer>();\r\n        increment = new LinkedList<Integer>();\r\n        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(stack.size() < this.maxSize) {\r\n            increment.add(0);\r\n            stack.push(x);\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        int i = stack.size() - 1;\r\n        if(i < 0) return -1;\r\n        if(i > 0)\r\n            increment.set(i - 1, increment.get(i) + increment.get(i - 1));\r\n        int res = increment.get(i) + stack.pop();\r\n        increment.remove(i);\r\n        return res; \r\n        \r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int i = Math.min(stack.size(), k) - 1;\r\n        if(i >= 0)\r\n            increment.set(i, increment.get(i) + val);\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434777533","body":"```jsx\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n\n        StringBuilder sb = new StringBuilder();\n\n        for(char c : s.toCharArray()) {\n            if(c == ']') {\n                StringBuilder repeatStr = new StringBuilder();\n                while(!stack.isEmpty() && stack.peek() != '[') {\n                    repeatStr.append(stack.pop());\n                }\n                stack.pop();\n                repeatStr = repeatStr.reverse();\n                int repeatCnt = 0;\n                int k = 1;\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                \n                    int n = stack.pop() - '0';\n                    repeatCnt = k * n + repeatCnt;\n        \n                    k = k * 10;\n                }\n                \n                for(int i = 0; i < repeatCnt; i++){\n                    for(int j = 0; j < repeatStr.length(); j++) {\n                        stack.push(repeatStr.charAt(j));\n                    }\n                }\n            }\n            else {\n                stack.push(c);\n            }\n        }\n        while(!stack.isEmpty()) {\n            sb.append(stack.pop());\n        }\n        return sb.reverse().toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435712719","body":"class MyQueue {\n\n    Stack<Integer> s1, s2;\n    public MyQueue() {\n        s1 = new Stack<>();\n        s2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        s1.push(x);\n    }\n    \n    public int pop() {\n        peek();\n        return s2.pop();\n    }\n    \n    public int peek() {\n        if(s2.isEmpty()){\n            while(!s1.isEmpty()){\n                s2.push(s1.pop());\n            }\n        }\n        return s2.peek();\n    }\n    \n    public boolean empty() {\n        return s2.isEmpty() && s1.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435712652","body":"class MyQueue {\n\n    Stack<Integer> s1, s2;\n    public MyQueue() {\n        s1 = new Stack<>();\n        s2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        s1.push(x);\n    }\n    \n    public int pop() {\n        peek();\n        return s2.pop();\n    }\n    \n    public int peek() {\n        if(s2.isEmpty()){\n            while(!s1.isEmpty()){\n                s2.push(s1.pop());\n            }\n        }\n        return s2.peek();\n    }\n    \n    public boolean empty() {\n        return s2.isEmpty() && s1.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436291783","body":"# 题目名\n\n链接：[https://leetcode.com/problems/rotate-list/description/](https://leetcode.com/problems/rotate-list/description/)\n\n# 解法思路1:\n\n先遍历链表一遍，此时记录链表本身的长度。并且让链表成环。\n\n让k = k % len。此时让指针再走len - k 格。就可以走到旋转链表的链表的tail节点。记录这个节点的next节点。让他把tail的next节点变为null断尾。\n\n## 注意要点：\n\n## 复杂度：\n\n时间：$O(n)$\n\n空间：$O(1)$\n\n## 第一次自己写的代码：\n\n```jsx\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null) return null;\n        ListNode p = head;\n        int len = 1;\n        \n        while(p.next != null){\n            p = p.next;\n            len++;\n        }\n        p.next = head;\n        k = k % len;\n        k = len - k;\n        for(int i = 0; i < k; i++) {\n            p = p.next;\n        }\n        ListNode res = p.next;\n        p.next =null;\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437413335","body":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(5);\n        dummy.next = head;\n        ListNode preNode = dummy;\n        ListNode firstNode = head;\n        ListNode secondNode;\n        ListNode postNode;\n        while(firstNode != null && firstNode.next != null) {\n            secondNode = firstNode.next;\n            postNode = secondNode.next;\n         \n            preNode.next = secondNode;\n            \n            firstNode.next = postNode;\n            secondNode.next = firstNode;\n            preNode = firstNode;\n            firstNode = postNode;\n            \n        }\n        return dummy.next;\n\n        \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440304819","body":"class Solution {\n  public TreeNode sortedListToBST(ListNode head) {\n      if(head == null) return null;\n      return dfs(head,null);\n  }\n  private TreeNode dfs(ListNode head, ListNode tail){\n      if(head == tail) return null;\n      ListNode fast = head, slow = head;\n      while(fast != tail && fast.next != tail){\n          fast = fast.next.next;\n          slow = slow.next;\n      }\n      TreeNode root = new TreeNode(slow.val);\n      root.left = dfs(head, slow);\n      root.right = dfs(slow.next, tail);\n      return root;\n  }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1440388463","body":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n\n        while(p1 != p2) {\n            if(p1 == null) \n                p1 = headB;\n            else \n                p1 = p1.next;\n            \n\n            if(p2  == null)\n                p2 = headA;\n            else \n                p2 = p2.next;\n            \n        }\n        return p1;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"neado":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaojunjun1110":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wxleah":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunl1ght":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kerrhl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c1f2h3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dlm001128":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxy94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyqqq22":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elon-lau":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436019315","body":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for (int num : arr) {\n            if (!stack.isEmpty() && num < stack.getLast()) {\n                int cur = stack.removeLast();\n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(cur);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        return stack.size();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437016576","body":"public ListNode rotateRight(ListNode head, int k) {\nif (k == 0 || head == null || head.next == null) {\nreturn head;\n}\nint n = 1;\nListNode iter = head;\nwhile (iter.next != null) {\niter = iter.next;\nn++;\n}\nint add = n - k % n;\nif (add == n) {\nreturn head;\n}\niter.next = head;\nwhile (add-- > 0) {\niter = iter.next;\n}\nListNode ret = iter.next;\niter.next = null;\nreturn ret;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437733294","body":"TC: O(n)\nSC: O(n)\n\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        var next = head.next;\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n    }","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443683538","body":"    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head, slow = head;\n\n        while (true) {\n            if (fast == null || fast.next == null) return null;\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) break;\n        }\n\n        fast = head;\n        while (slow != fast) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n\n        return fast;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445131550","body":"class LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.dict = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.dict:\n            return -1\n        self.dict.move_to_end(key)\n        return self.dict[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.dict:\n            self.dict.move_to_end(key)\n        self.dict[key] = value\n        \n        if len(self.dict) > self.capacity:\n            self.dict.popitem(last=False)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nowkizzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsgtgyb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"irenia111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suiyi8760":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saltychess":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rabbit2010520":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yopming":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckytwj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzz607":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoulufeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxoojs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okkband":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wyz999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hacker90":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ricjli":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luhaoling":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gelxgx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lsunxh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lanceli424":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qycoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qilin88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengheng-yun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smz1995":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"size-of":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428989759","body":"var addToArrayForm = function(num, k) {\n  let i = num.length - 1, list = []\n\n  n = 0\n  while (i >= 0 || k > 0 || n) {\n    let a = num[i] || 0, b = k % 10\n\n    let res = a + b + n\n    n = res / 10 | 0\n    k = k / 10 | 0\n    i--\n\n    list.push(res % 10)\n  }\n\n  return list.reverse()\n};\n时间复杂度：O(n), 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430628438","body":"/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n  const res = new Array(s.length).fill(Infinity)\n  for (let i = 0; i < s.length; i++) {\n    res[i] = s.substr(i, 1) === c ? 0 : (res[i - 1] != undefined ? res[i - 1] : Infinity) + 1\n  }\n\n  for (let i = s.length - 1; i >= 0; i--) {\n    let prev = res[i + 1] !== undefined ? res[i + 1] : Infinity\n    res[i] = prev + 1 < res[i] ? prev + 1 : res[i]\n  }\n\n  return res\n};\n时间复杂度O(n),空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432299251","body":"/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.stack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length >= this.maxSize) return\n    this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (!this.stack.length) return -1\n    return this.stack.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let n = this.stack.length < k ? this.stack.length : k\n\n    for (let i = n - 1; i >= 0; i--) {\n        this.stack[i] += val\n    }\n};\n时间复杂度：push: O(1), pop: O(1), increment: O(n). 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1435472474","body":"/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let stack = []\r\n    let num = 0, char = '', cur = '', top \r\n\r\n    for (let i = 0; i < s.length; i++) {\r\n        cur = s.charAt(i)\r\n\r\n        if (typeof +cur === 'number' && !isNaN(+cur)) {\r\n            num = num * 10 + +cur\r\n        } else if (cur === '[') {\r\n            stack.push([num, char])\r\n            num = 0\r\n            char = ''\r\n        } else if (cur === ']') {\r\n            top = stack.pop()\r\n            char = top[1] + new Array(top[0]).fill(char).join('')\r\n        } else {\r\n            char += cur\r\n        }\r\n    }\r\n\r\n    return char\r\n};\r\n时间复杂度O(N),空间复杂度O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435474672","body":"var MyQueue = function() {\n    this.a = []\n    this.b = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.a.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (this.b.length) return this.b.pop()\n    while (this.a.length) {\n        this.b.push(this.a.pop())\n    }\n    return this.b.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (this.b.length) return this.b[this.b.length - 1]\n    while (this.a.length) {\n        this.b.push(this.a.pop())\n    }\n\n    return this.b[this.b.length - 1]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.a.length && !this.b.length\n};\n时间复杂度push，empty O(1),peek pop 均摊O(1), 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435942220","body":"/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n  const stack = []\n\n  for (let i = 0; i < arr.length; i++) {\n    if (!stack.length || stack[stack.length - 1] <= arr[i]) {\n      stack.push(arr[i])\n    } else {\n      const cur = stack.pop()\n      while(stack[stack.length - 1] > arr[i]) {\n        stack.pop()\n      }\n      stack.push(cur)\n    }\n  }\n  return stack.length\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438106808","body":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    const pre = new ListNode(-1)\n    pre.next = head\n    let now = pre\n\n    while (now.next !== null && now.next.next !== null) {\n        let start = now.next\n        let end = now.next.next\n\n        now.next = end\n        start.next = end.next\n        end.next = start\n        now = start\n    }\n\n    return pre.next\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441273699","body":"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let a = headA, b = headB\n\n    while (a !== b) {\n      a = a ? a.next : headB\n      b = b ? b.next : headA\n    }\n    return a\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442707466","body":"/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n  let quick = head, slow = head\n\n  while (quick && quick.next) {\n    quick = quick.next.next\n    slow = slow.next\n\n    if (quick === slow) {\n      quick = head\n      break\n    }\n  }\n\n  if (!quick || !quick.next) return null\n\n  while (quick !== slow) {\n    quick = quick.next\n    slow = slow.next\n  }\n\n  return quick\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451174355","body":"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n  if (!root) return ''\n  const list = []\n  const queue = [root]\n\n  while(queue.length) {\n    const node = queue.shift()\n\n    if (node) {\n      list.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    } else {\n      list.push(null)\n    }\n  }\n\n  return list.join(',')\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n  if (data === 'null' || !data) return null\n  data = data.split(',')\n\n  let root = new TreeNode(data[0])\n  let queue = [root]\n  let i = 0\n\n  while(queue.length && i < data.length - 1) {\n    const node = queue.shift()\n    let lc = data[i + 1]\n    let rc = data[i + 2]\n\n    if (lc) {\n      node.left = new TreeNode(lc)\n      queue.push(node.left)\n    }\n\n    if (rc) {\n      node.right = new TreeNode(rc)\n      queue.push(node.right)\n    }\n    i += 2\n  }\n\n  return root\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461605570","body":"/**\n * @param {number[]} nums\n * @param {number} p\n * @return {number}\n */\nvar minSubarray = function(nums, p) {\n  let mod = nums.reduce((total, cur) => total + cur, 0) % p\n    if (mod === 0) return 0\n    const map = new Map()\n    map.set(0, -1)\n    let res = nums.length, subMod = 0\n    for (let i = 0; i < nums.length; i++) {\n        subMod = (subMod + nums[i]) % p\n        let target = (subMod - mod + p) % p\n        if (map.has(target)) {\n            res = Math.min(res, i - map.get(target))\n        }\n        map.set(subMod, i)\n    }\n    return res != nums.length ? res : -1\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497228414","body":"/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar maxDistance = function(grid) {\nconst n = grid[0].length\n    const DIR = [[1,0], [0,1], [-1,0], [0,-1]]\n\n    const legal = (x,y) =>{\n        if(x < 0 || y < 0 || x >= n || y >= n) return false\n        return true \n    }\n\n    const dis = Array.from({length:n}).map(()=>  Array.from({length:n}).fill(Number.MAX_SAFE_INTEGER))\n    const queue = []\n\n    for(let i = 0; i < n;i++){\n        for(let j = 0; j < n; j++){\n            if(grid[i][j] == 1){\n                dis[i][j] = 0\n                queue.push([i,j])\n            }\n        }\n    }\n\n    while(queue.length){\n        const [x,y] = queue.shift()\n\n        for(const d of DIR){\n            let nx = d[0] + x\n            let ny = d[1] + y\n\n            if(legal(nx,ny) && dis[x][y] + 1 < dis[nx][ny]){\n                dis[nx][ny] = dis[x][y] + 1\n                queue.push([nx,ny])\n            }\n        }\n    }\n\n    let ans = -1\n    for(let i = 0; i < n;i++){\n        for(let j = 0; j < n; j++){\n            if(grid[i][j] == 0){\n                ans = Math.max(ans, dis[i][j])\n            }\n        }\n    }\n\n    return ans == Number.MAX_SAFE_INTEGER ? -1 : ans\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498805113","body":"var maxCandies = function(status, candies, keys, containedBoxes, initialBoxes) {\n    let sum = 0\n    const n = status.length\n    let has_box = new Array(n).fill(false)\n    let has_key = new Array(n).fill(false)\n    let open = new Array(n).fill(false)\n    function open(box){\n        if(open[box]) return     \n        if(!has_box[box]) return \n        if(status[box]===0 && !has_key[box]) return \n        open[box] = true \n        sum += candies[box]                      \n        for(let next of keys[box]){           \n            has_key[next] = true \n            open(next)\n        } \n        for(let next of containedBoxes[box]){ \n            has_box[next] = true \n            open(next)\n        } \n    }\n    for(let box of initialBoxes){\n        has_box[box] = true \n        open(box)\n    } \n    return sum \n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1500252823","body":"class Solution:\n    def solve(self, root):\n        q = collections.deque([(root, 0)])\n        d = {}\n        while q:\n            cur, pos = q.popleft()\n            if pos not in d:\n                d[pos] = cur.val\n            if cur.left:\n                q.append((cur.left, pos - 1))\n            if cur.right:\n                q.append((cur.right, pos + 1))\n        return list(map(lambda x:x[1], sorted(d.items(),key=lambda x: x[0])))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500807429","body":"/**\n * @param {number[]} cost\n * @return {number}\n */\nvar minCostClimbingStairs = function(cost) {\n    const n = cost.length;\n    const dp = new Array(n + 1);\n    dp[0] = dp[1] = 0;\n    for (let i = 2; i <= n; i++) {\n        dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501643915","body":"var findNumberOfLIS = function(nums) {\n    let n = nums.length, maxLen = 0, ans = 0;\n    const dp = new Array(n).fill(0);\n    const cnt = new Array(n).fill(0);\n    for (let i = 0; i < n; ++i) {\n        dp[i] = 1;\n        cnt[i] = 1;\n        for (let j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                if (dp[j] + 1 > dp[i]) {\n                    dp[i] = dp[j] + 1;\n                    cnt[i] = cnt[j]; \n                } else if (dp[j] + 1 === dp[i]) {\n                    cnt[i] += cnt[j];\n                }\n            }\n        }\n        if (dp[i] > maxLen) {\n            maxLen = dp[i];\n            ans = cnt[i]; \n        } else if (dp[i] === maxLen) {\n            ans += cnt[i];\n        }\n    }\n    return ans;\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506715206","body":"/**\n * @param {number} n\n * @param {number} k\n * @param {number} row\n * @param {number} column\n * @return {number}\n */\nvar knightProbability = function(n, k, row, column) {\n  const MOVE = [[2,1],[2,-1],[-2,1], [-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]\n\n  let dp = Array.from({length: n }).map(() =>  Array.from({length: n }).fill(0))\n  dp[row][column] = 1\n\n  for(let step = 1; step <= k; step++){\n      const tempDP =  Array.from({length: n }).map(() =>  Array.from({length: n }).fill(0))\n      for(let i = 0; i < n; i++){\n          for(let j = 0; j < n; j++){\n              for(const m of MOVE){\n                  const lastR = i - m[0]\n                  const lastC = j - m[1]\n                  if (lastR >= 0 && lastR < n && lastC >= 0 && lastC < n){\n                      tempDP[i][j] += dp[lastR][lastC] * 0.125\n                  }\n              }\n          }\n      }\n      dp = tempDP\n  }\n\n  let res = 0\n  for(let i = 0; i < n; i++){\n      for(let j = 0; j < n; j++){\n          res += dp[i][j]\n      }\n  }\n  return res\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1508255588","body":"var canIWin = function(maxChoosableInteger, desiredTotal) {\n    const memo = new Map();\n    const dfs = (maxChoosableInteger, usedNumbers, desiredTotal, currentTotal) => {\n        if (!memo.has(usedNumbers)) {\n            let res = false;\n            for (let i = 0; i < maxChoosableInteger; i++) {\n                if (((usedNumbers >> i) & 1) === 0) {\n                    if (i + 1 + currentTotal >= desiredTotal) {\n                        res = true;\n                        break;\n                    }\n                    if (!dfs(maxChoosableInteger, usedNumbers | (1 << i), desiredTotal, currentTotal + i + 1)) {\n                        res = true;\n                        break;\n                    }\n                }\n            }\n            memo.set(usedNumbers, res);\n        }\n        return memo.get(usedNumbers);\n    }\n    if ((1 + maxChoosableInteger) * (maxChoosableInteger) / 2 < desiredTotal) {\n        return false;\n    }\n    return dfs(maxChoosableInteger, 0, desiredTotal, 0);\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509714024","body":"/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canPartition = function(nums) {\n    const n = nums.length;\n    if (n < 2) {\n        return false;\n    }\n    let sum = 0, maxNum = 0;\n    for (const num of nums) {\n        sum += num;\n        maxNum = maxNum > num ? maxNum : num;\n    }\n    if (sum & 1) {\n        return false;\n    }\n    const target = Math.floor(sum / 2);\n    if (maxNum > target) {\n        return false;\n    }\n    const dp = new Array(n).fill(0).map(() => new Array(target + 1, false));\n    for (let i = 0; i < n; i++) {\n        dp[i][0] = true;\n    }\n    dp[0][nums[0]] = true;\n    for (let i = 1; i < n; i++) {\n        const num = nums[i];\n        for (let j = 1; j <= target; j++) {\n            if (j >= num) {\n                dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    return dp[n - 1][target];\n};\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1512780367","body":"/**\n * @param {number} amount\n * @param {number[]} coins\n * @return {number}\n */\nvar change = function(amount, coins) {\n    const dp = new Array(amount + 1).fill(0);\n    dp[0] = 1;\n    for (const coin of coins) {\n        for (let i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    return dp[amount];\n};\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516161336","body":"var eraseOverlapIntervals = function(intervals) {\n    if (!intervals.length) {\n        return 0;\n    }\n\n    intervals.sort((a, b) => a[1] - b[1]);\n\n    const n = intervals.length;\n    let right = intervals[0][1];\n    let ans = 1;\n    for (let i = 1; i < n; ++i) {\n        if (intervals[i][0] >= right) {\n            ++ans;\n            right = intervals[i][1];\n        }\n    }\n    return n - ans;\n};\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521140991","body":"```javascript\n\nvar singleNumber = function(nums) {\n    let xorsum = 0;\n    \n    for (const num of nums) {\n        xorsum ^= num;\n    }\n    let type1 = 0, type2 = 0;\n    const lsb = xorsum & (-xorsum);\n    for (const num of nums) {\n        if (num & lsb) {\n            type1 ^= num;\n        } else {\n            type2 ^= num;\n        }\n    }\n    return [type1, type2];\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1523214748","body":"```javascript\nvar subsets = function(nums) {\n  let n = nums.length, list = [[]]\n\n  function backtrack(max, res = [], start = 0) {\n    if (max === 0) return list.push([...res])\n\n    for (let i = start; i < n; ++i) {\n      res.push(nums[i])\n      backtrack(--max, res, i + 1)\n      max++\n      res.pop()\n    }\n  }\n\n  for (let i = 1; i <= n; ++i) {\n    backtrack(i)\n  }\n\n  return list\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1525424325","body":"```javscript\nvar Trie = function() {\n    this.children = {};\n};\n\n/** \n * @param {string} word\n * @return {void}\n */\nTrie.prototype.insert = function(word) {\n  let node = this.children;\n  for (const ch of word) {\n      if (!node[ch]) {\n          node[ch] = {};\n      }\n      node = node[ch];\n  }\n  node.isEnd = true;\n};\n\nTrie.prototype.searchPrefix = function(prefix) {\n    let node = this.children;\n    for (const ch of prefix) {\n        if (!node[ch]) {\n            return false;\n        }\n        node = node[ch];\n    }\n    return node;\n}\n\n/** \n * @param {string} word\n * @return {boolean}\n */\nTrie.prototype.search = function(word) {\n    const node = this.searchPrefix(word);\n    return node !== undefined && node.isEnd !== undefined;\n};\n\n/** \n * @param {string} prefix\n * @return {boolean}\n */\nTrie.prototype.startsWith = function(prefix) {\n    return this.searchPrefix(prefix);\n};\n\n```\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1529531052","body":"```javascript\n\n/**\n * @param {number[][]} graph\n * @param {number[]} initial\n * @return {number}\n */\n var minMalwareSpread = function(graph, initial) {\n    const n = graph.length;\n    const p = new Array(n).fill(-1);\n    const size = new Array(n).fill(1);\n    const st = Array.from(new Array(n),()=>new Array(n).fill(false));\n    let min = n;\n    let idx = -1;\n\n    var find = x =>{\n      if(p[x]!==x)p[x] = find(p[x]);\n      return p[x];\n    }\n\n    var merge = (x,y)=>{\n      if(find(x)===find(y))return;\n      size[find(y)] += size[find(x)];\n      p[find(x)] = find(y);\n      st[x][y] = st[y][x] =true;\n    }\n\n    for(let i=0;i<n;i++) p[i]=i;\n\n    for(let i=0;i<n;i++)\n      for(let j=0;j<n;j++)\n          if(graph[i][j]){\n              if(i===j || st[i][j])continue;\n              merge(i,j);\n          }\n\n    initial.sort((a,b)=> a-b);\n\n    for(let e of initial){\n        const set = new Set();\n        let res = 0;\n        for(let i of initial){\n            if(i===e)continue;\n            else{\n                let ri  = find(i);\n                if(!set.has(ri)){\n                    set.add(ri);\n                    res += size[ri];\n                }\n            }\n        }\n        if(res<min){\n            min = res;\n            idx = e;\n        }\n    }\n    return idx===-1 ? initial[0] : idx;\n};\n\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moyuanhua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"9vivian88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guxuehua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kirosola":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maoting":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youzhaing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hanwangxxx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dujt-x":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436196030","body":"# 题目\r\nhttps://leetcode-cn.com/problems/rotate-list/\r\n\r\n将链表旋转k次，其中k是非负整数，即将链表的最后k个节点移动到链表的头部。\r\n# 思路分析\r\n---\r\n需要找到链表中的倒数第k个节点，并将链表从这个节点处分成两个部分，然后将第二部分连接到链表的头部。\r\n\r\n1. 首先遍历一次链表，以确定链表的长度。\r\n\r\n2. 如果k大于链表的长度，将k对链表的长度取模，以确保它不大于链表的长度。\r\n\r\n3. 定义两个指针：快指针和慢指针，都指向链表的头部。快指针向前移动k步，然后慢指针和快指针同时向前移动，直到快指针到达链表的尾部。\r\n\r\n4. 将第二部分链表的尾部与第一部分链表的头部相连接。\r\n\r\n5. 将第二部分链表的头部作为新的头节点返回。\r\n# 代码实现\r\n---\r\nGolang\r\n```Go\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n    // 特殊情况：链表为空或只有一个节点\r\n    if head == nil || head.Next == nil {\r\n        return head\r\n    }\r\n    \r\n    // 计算链表的长度\r\n    n := 1\r\n    curr := head\r\n    for curr.Next != nil {\r\n        n++\r\n        curr = curr.Next\r\n    }\r\n    \r\n    // 如果k大于链表的长度，将k对链表的长度取模\r\n    k = k % n\r\n    \r\n    // 特殊情况：k等于0，即不需要旋转\r\n    if k == 0 {\r\n        return head\r\n    }\r\n    \r\n    // 定义快指针和慢指针\r\n    fast := head\r\n    slow := head\r\n    \r\n    // 快指针向前移动k步\r\n    for i := 0; i < k; i++ {\r\n        fast = fast.Next\r\n    }\r\n    \r\n    // 移动慢指针和快指针，直到快指针到达链表的尾部\r\n    for fast.Next != nil {\r\n        slow = slow.Next\r\n        fast = fast.Next\r\n    }\r\n    \r\n    // 将第二部分链表的尾部与第一部分链表的头部相连接\r\n    new_head := slow.Next\r\n    slow\r\n```\r\n# 复杂度分析\r\n- 时间复杂度：O(n)，其中n是链表的长度。需要遍历一次链表来计算链表的长度，遍历一次链表来找到倒数第k个节点，所以时间复杂度是O(n)。\r\n\r\n- 空间复杂度：O(1)，只使用了常数级别的额外空间。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"degndaixingqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gzgzgzgzgzgz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gentleman-goodman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyi-arch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zenwangzy":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429936974","body":"## 思路\n模拟计算加法的逻辑。从个位开始遍历num计算的时候，用k作为carry 的数字。最后如果还有剩余的carry数字，加到res前中。\n\n## 代码\n```python\nclass Solution: \n\tdef addToArrayForm(self, num: List[int], k: int) -> List[int]: \n\t\tn = len(num) \n\t\tcarry = total = 0 \n\t\tres = [] \n\t\ti = len(num)-1 # track digits in num \n\t\twhile i >= 0 or k != 0: \n\t\t\tx = num[i] if i >= 0 else 0 # last digit in num \n\t\t\ty = k % 10 if k != 0 else 0 # last digit in k \n\t\t\ttotal = x + y + carry \n\t\t\tcarry = total // 10 \n\t\t\tk = k // 10 # remove last digit from k \n\t\t\ti -= 1 \n\t\t\tres.append(total % 10) \n\t\t\t\n\t\tif carry != 0: \n\t\t\tres.append(carry) \n\t\treturn res[::-1]\n```\n## 复杂度分析\n\n时间: O(N), n is max (len(num), k )\n\n空间: O(N), n is number of digits we processed in the while loop and the space in the res array","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437079617","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head:\n            slow , fast = head ,head\n            tmp = head\n            leng = 0\n            while tmp:\n                tmp = tmp.next\n                leng +=1\n            k = k%leng\n            while k:\n                fast = fast.next\n                k -=1\n            while fast.next:\n                slow = slow.next\n                fast = fast.next\n            if slow.next:\n                tmp = slow.next\n            else:\n                return head\n            slow.next = None\n            fast.next = head\n            return tmp\n```\n## 复杂度分析\n\n n 为数组长度。\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461092224","body":"题目的意思是让我们移除一段最短连续子数组，使得剩下的数字和为 k 的整数倍。\n看到被 x 整除，求余数等问题都可以尝试考虑是否可以使用数学中的同余定理，看到连续子数组就可以考虑用前缀和进行优化。\n\n本题可以使用前缀和 + 同余定理进行优化：\n\n由前缀和我们知道子数组 A[i:j] 的和就是 pres[j] - pres[i-1]，其中 pres 为 A 的前缀和。\n\n由同余定理我们知道两个模 k 余数相同的数字相减，得到的值定可以被 k 整除。\n\n于是，我们可以将前缀和模 k 的余数 x 放到哈希表中，这个哈希表就充当了前缀和的角色，来记录最新的余数 x 对应的下标，记录最新的目的是为了找出符合要求的最短的连续子数组。\n\n算法上，我们可以先计算出总体的数组和 total 模 k 的余数，记为 target，那么我们的目标就是找到一段模 k 等于 target 的子数组\n```python\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        need = sum(nums) % p\n        store = {0: -1}\n        cur = 0\n        res = len(nums)\n        for i, num in enumerate(nums):\n            cur = (cur + num) % p\n            store[cur] = i\n            if (cur - need) % p in store:\n                res = min(res, i - store[(cur - need) % p])\n        return res if res < len(nums) else -1\n```\nTC:O(n)\nSC:O(n)  O(min(n,k))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyyxw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fourierhai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yangz001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mannnn6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"haoyangxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chjillout":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenjialu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mhcn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coconutice":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackgaoyuan":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428999601","body":"```\r\nfunc addToArrayForm(num []int, k int) []int {\r\n\tkstr := strconv.Itoa(k)\r\n\tvar kArr []int\r\n\tvar res []int\r\n\tvar sum, reminder, carry int\r\n\tfor i := 0; i < len(kstr); i++ {\r\n\t\tv, _ := strconv.Atoi(string(kstr[i]))\r\n\t\tkArr = append(kArr, v)\r\n\t}\r\n\treverseSlice(kArr)\r\n\treverseSlice(num)\r\n\tfor i, j := 0, 0; i < len(num) || j < len(kArr); {\r\n\t\tif i >= len(num) { // num out of index\r\n\t\t\tsum = carry + kArr[j]\r\n\t\t\tj++\r\n\t\t} else if j >= len(kArr) { // kArr out of index\r\n\t\t\tsum = carry + num[i]\r\n\t\t\ti++\r\n\t\t} else { // num and kArr are both in range\r\n\t\t\tsum = carry + num[i] + kArr[j]\r\n\t\t\ti++\r\n\t\t\tj++\r\n\t\t}\r\n\t\tcarry = sum / 10\r\n\t\treminder = sum % 10\r\n\t\tres = append(res, reminder)\r\n\t}\r\n\tif carry > 0 {\r\n\t\tres = append(res, carry)\r\n\t}\r\n\treverseSlice(res)\r\n\treturn res\r\n}\r\n\r\nfunc reverseSlice(num []int) {\r\n\tfor i, j := 0, len(num)-1; i < j; i, j = i+1, j-1 {\r\n\t\tnum[i], num[j] = num[j], num[i]\r\n\t}\r\n}\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436165664","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * type ListNode struct {\r\n *     Val int\r\n *     Next *ListNode\r\n * }\r\n */\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n\t// 边界守护\r\n\tif head == nil {\r\n\t\treturn head\r\n\t}\r\n\t// 存储节点头，节点头的Next都是nil，避免处理环\r\n\theadList := []*ListNode{}\r\n\t// 节点list的长度\r\n\tn := 0\r\n\t// 节点的指针\r\n\tp := head\r\n\t// 计数器，计算处理结束\r\n\tcount := 1\r\n\t// 应该处理的长度，因为当处理的次数与总长度相等时，会出现周期性的循环，所以应处理次数为 k%n，只求余数即可\r\n\ttotalCount := 0\r\n\r\n\t// 将节点放入list\r\n\tfor p != nil {\r\n\t\theadList = append(headList, p)\r\n\t\tpNext := p.Next\r\n\t\tp.Next = nil\r\n\t\tp = pNext\r\n\t\tn++\r\n\t}\r\n\r\n\ttotalCount = k % n\r\n\tp = head\r\n\r\n\t// 先将数组进行选装，不处理节点\r\n\tfor count <= totalCount {\r\n\t\theadList = append(headList[n-1:], headList[0:n-1]...)\r\n\t\tcount++\r\n\t}\r\n\r\n\t// 连接处理的节点\r\n\tfor i := 0; i < n; i++ {\r\n\t\tif i == n-1 {\r\n\t\t\theadList[i].Next = nil\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\theadList[i].Next = headList[i+1]\r\n\t}\r\n\r\n\thead = headList[0]\r\n\r\n\treturn head\r\n}\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445040196","body":"```\r\ntype Node struct {\r\n    Key int\r\n    Value int\r\n    Next *Node\r\n    Prev *Node\r\n}\r\n\r\ntype LRUCache struct {\r\n    Head *Node\r\n    Tail *Node\r\n    M map[int]*Node\r\n    Count int\r\n    Capacity int\r\n}\r\n\r\nfunc Constructor(capacity int) LRUCache {\r\n    head := &Node{}\r\n    tail := &Node{}\r\n    head.Next = tail\r\n    tail.Prev = head\r\n    return LRUCache{ Head: head, Tail: tail, M: make(map[int]*Node), Count: 0, Capacity: capacity }\r\n}\r\n\r\nfunc (this *LRUCache) removeNode(node *Node) {\r\n    node.Prev.Next, node.Next.Prev = node.Next, node.Prev\r\n    node.Prev, node.Next = nil, nil\r\n}\r\n\r\nfunc (this *LRUCache) insertToHead(node *Node) {\r\n    node.Next, node.Prev = this.Head.Next, this.Head\r\n    node.Prev.Next, node.Next.Prev = node, node\r\n}\r\n\r\nfunc (this *LRUCache) Get(key int) int {\r\n    node, ok := this.M[key]\r\n    if !ok {\r\n        return -1\r\n    }\r\n    value := node.Value\r\n    // move node to head\r\n    this.removeNode(node)\r\n    this.insertToHead(node)\r\n    return value\r\n}\r\n\r\nfunc (this *LRUCache) Put(key int, value int) {\r\n    node, ok := this.M[key]\r\n    if ok { // if key exist, update node and move to head\r\n        node.Value = value\r\n        this.removeNode(node)\r\n        this.insertToHead(node)\r\n    } else { // if key not exist, create a new node and insert to head\r\n        newNode := &Node{ Value: value, Key: key }\r\n        if this.Count >= this.Capacity {\r\n            lastNode := this.Tail.Prev\r\n            this.removeNode(lastNode)\r\n            delete(this.M, lastNode.Key)\r\n            this.Count -= 1\r\n        }\r\n        this.insertToHead(newNode)\r\n        this.M[key] = newNode\r\n        this.Count += 1\r\n    }\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449250077","body":"```\r\n/**\r\n * Definition for a binary tree node.\r\n * type TreeNode struct {\r\n *     Val int\r\n *     Left *TreeNode\r\n *     Right *TreeNode\r\n * }\r\n */\r\n\r\ntype BottomLeftInfo struct {\r\n    Level int\r\n    Node *TreeNode\r\n}\r\n\r\nfunc findBottomLeftValue(root *TreeNode) int {\r\n    bottomLeftInfo := BottomLeftInfo{}\r\n    dfs(root, 1, &bottomLeftInfo)\r\n    return bottomLeftInfo.Node.Val\r\n}\r\n\r\nfunc dfs(node *TreeNode, level int,bottomLeftInfo *BottomLeftInfo) {\r\n    if level > bottomLeftInfo.Level {\r\n        bottomLeftInfo.Node = node\r\n        bottomLeftInfo.Level = level\r\n    }\r\n    if node.Left != nil {\r\n        dfs(node.Left, level+1, bottomLeftInfo)\r\n    }\r\n    if node.Right != nil {\r\n        dfs(node.Right, level+1, bottomLeftInfo)\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457515480","body":"```\r\nfunc lengthOfLongestSubstring(s string) int {\r\n\tm := make(map[byte]bool)\r\n\ti := 0\r\n\tvar longestLength int \r\n\tfor j := 0; j < len(s); j++ {\r\n\t\tfor i < j {\r\n\t\t\t_, ok := m[s[j]]\r\n\t\t\tif !ok {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tdelete(m, s[i])\r\n\t\t\ti++\r\n\t\t}\r\n\t\tm[s[j]] = true\r\n\t\tif j - i + 1 > longestLength {\r\n\t\t\tlongestLength = j - i + 1\r\n\t\t}\r\n\t}\r\n\treturn longestLength\r\n}\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465508647","body":"```\r\ntype Node struct {\r\n    Value int\r\n    Next *Node\r\n    Prev *Node\r\n}\r\n\r\ntype Deque struct {\r\n    Head *Node\r\n    Tail *Node\r\n    Count int\r\n}\r\n\r\nfunc CreateDeque () Deque {\r\n    head := &Node{}\r\n    tail := &Node{}\r\n    head.Next = tail\r\n    tail.Prev = head\r\n    return Deque{ Head: head, Tail: tail, Count: 0 }\r\n}\r\n\r\nfunc (dq *Deque) InsertHead(value int) {\r\n    node := &Node{ Value: value }\r\n    node.Prev, node.Next = dq.Head, dq.Head.Next\r\n    node.Prev.Next, node.Next.Prev = node, node\r\n    dq.Count += 1\r\n}\r\n\r\nfunc (dq *Deque) DeleteHead() {\r\n    firstNode := dq.Head.Next\r\n    firstNode.Prev.Next, firstNode.Next.Prev = firstNode.Next, firstNode.Prev\r\n    firstNode.Next, firstNode.Prev = nil, nil\r\n    dq.Count -= 1\r\n}\r\n\r\nfunc (dq *Deque) InsertTail(value int) {\r\n    node := &Node{ Value: value }\r\n    node.Prev, node.Next = dq.Tail.Prev, dq.Tail\r\n    node.Prev.Next, node.Next.Prev = node, node\r\n    dq.Count += 1\r\n}\r\n\r\nfunc (dq *Deque) DeleteTail() {\r\n    lastNode := dq.Tail.Prev\r\n    lastNode.Prev.Next, lastNode.Next.Prev = lastNode.Next, lastNode.Prev\r\n    lastNode.Prev, lastNode.Next = nil, nil\r\n    dq.Count -= 1\r\n}\r\n\r\nfunc (dq *Deque) PeerHead() int {\r\n    return dq.Head.Next.Value\r\n}\r\n\r\nfunc (dq *Deque) PeerTail() int {\r\n    return dq.Tail.Prev.Value\r\n}\r\n\r\nfunc maxSlidingWindow(nums []int, k int) []int {\r\n    dq := CreateDeque()\r\n    res := []int{}\r\n    for idx, value := range nums {\r\n        for dq.Count > 0 && nums[dq.PeerTail()] < value {\r\n            dq.DeleteTail()\r\n        }\r\n        dq.InsertTail(idx)\r\n        if idx >= k - 1 {\r\n            for dq.Count > 0 && dq.PeerHead() < idx - k + 1 {\r\n                dq.DeleteHead()\r\n            }\r\n            res = append(res, nums[dq.PeerHead()])\r\n        }\r\n    }\r\n    return res\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473118005","body":"```\r\nfunc judgeCircle(moves string) bool {\r\n    up, left := 0, 0\r\n    for _, v := range moves {\r\n        if v == 85 {\r\n            up ++\r\n        } else if v == 68 {\r\n            up--\r\n        } else if v == 76 {\r\n            left++\r\n        } else {\r\n            left--\r\n        }\r\n    }\r\n    return up == 0 && left == 0\r\n}\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482052873","body":"```\r\nfunc reversePairs(nums []int) int {\r\n    var res int\r\n    mergeSort(nums, &res)\r\n    return res\r\n}\r\nfunc mergeSort(nums []int, res *int) []int {\r\n    if len(nums) <= 1 {\r\n        return nums\r\n    }\r\n    var mergedArray []int\r\n    array1 := nums[:(len(nums) - 1) / 2 + 1]\r\n    array2 := nums[(len(nums) - 1) / 2 + 1:]\r\n    sortArray1 := mergeSort(array1, res)\r\n    sortArray2 := mergeSort(array2, res)\r\n    for i := 0; i < len(sortArray1); i++ {\r\n        m, n := 0, len(sortArray2) - 1\r\n        for m < n {\r\n            mid := m + (n - m) / 2\r\n            if sortArray1[i] <= 2 * sortArray2[mid] {\r\n                n = mid\r\n            } else {\r\n                m = mid + 1\r\n            }\r\n        }\r\n        if sortArray1[i] > 2 * sortArray2[m] {\r\n            m += 1\r\n        }\r\n        *res += m\r\n    }\r\n    for i, j := 0, 0; i < len(sortArray1) || j < len(sortArray2); {\r\n        if i >= len(sortArray1) {\r\n            mergedArray = append(mergedArray, sortArray2[j])\r\n            j++\r\n        } else if j >= len(sortArray2) {\r\n            mergedArray = append(mergedArray, sortArray1[i])\r\n            i++\r\n        } else if sortArray1[i] <= sortArray2[j] {\r\n            mergedArray = append(mergedArray, sortArray1[i])\r\n            i++\r\n        } else {\r\n            mergedArray = append(mergedArray, sortArray2[j])\r\n            j++\r\n        }\r\n    }\r\n    return mergedArray\r\n}\r\n\r\n\r\n\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488295592","body":"```\r\nfunc new21Game(n int, k int, maxPts int) float64 {\r\n    dp := make([]float64, k + maxPts)\r\n    for i := k; i < k + maxPts; i++ {\r\n        if i <= n {\r\n            dp[i] = 1\r\n        } else {\r\n            dp[i] = 0\r\n        }\r\n    }\r\n    for i := k - 1; i >= 0; i-- {\r\n        var sum float64\r\n        for j := i + 1; j <= i + maxPts; j++ {\r\n            sum += dp[j]\r\n        }\r\n        dp[i] = sum / float64(maxPts)\r\n    }\r\n    return dp[0]\r\n}\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495224459","body":"```\r\n\r\nfunc maxAreaOfIsland(grid [][]int) int {\r\n\r\n m := len(grid)\r\n  n := len(grid[0])\r\n  ans := 0\r\n  //方向数组\r\n  dx := []int{-1,0,0,1}\r\n  dy := []int{0,-1,1,0}\r\n\r\n   //初始化并查集\r\n   fa := make([]int, m*n+1)\r\n   rank := make([]int, m*n+1)\r\n    for i:=0;i<=m*n;i++{\r\n        fa[i] = i\r\n    }\r\n    for i:=0;i<=m*n;i++{\r\n        rank[i] = 1\r\n    }\r\n\r\n   //循环网格\r\n\r\n    for i:=0;i<m;i++{\r\n        for j:=0;j<n;j++{\r\n           //如果碰到水则continue\r\n           if (grid[i][j] == 0){continue}\r\n\r\n           for k:=0;k<4;k++{\r\n\r\n               nx := i + dx[k]\r\n               ny := j + dy[k]\r\n\r\n               //到了边界continue\r\n               if (nx>=m || ny >=n||nx<0||ny<0){\r\n                   continue\r\n\r\n                //如果相邻是1，则加入并查集 uninonset   \r\n               }\r\n\r\n                if grid[nx][ny] == 1{\r\n                       unionSet(fa,rank, nums(n, i, j), nums(n,nx,ny))\r\n                   }\r\n               }\r\n           }\r\n  \r\n        }\r\n    \r\n    //最后查找并查集的最大秩即可，最大秩在根节点上\r\n    for i:=0;i<m;i++{\r\n      for j:=0;j<n;j++{\r\n\r\n          if (grid[i][j] ==1&&Find(fa, nums(n,i,j)) == nums(n,i,j)){\r\n  \r\n              ans = max(ans, rank[nums(n,i,j)])\r\n          }\r\n\r\n      }\r\n\r\n    }\r\n\r\n    return ans \r\n\r\n}\r\n\r\nfunc nums(n, i, j int) int {\r\n    return i*n+j\r\n}\r\n\r\nfunc max(a, b int) int{\r\n    if (a>b){\r\n        return a\r\n    }else{\r\n        return b \r\n    }\r\n}\r\n\r\n\r\nfunc Find(fa []int, x int ) int {\r\n    if (fa[x]==x){return  x}\r\n     fa[x] = Find(fa, fa[x])\r\n     return fa[x]\r\n}  \r\n//并查集按照秩合并，小的秩加到大的里面\r\n\r\nfunc unionSet(fa []int, rank []int , x, y int ) {\r\n    x, y = Find(fa, x), Find(fa, y) \r\n    if (x !=y){\r\n        if (rank[x]<=rank[y]){\r\n            fa[x] = y\r\n            rank[y] += rank[x]\r\n        }else {\r\n            fa[y] = x\r\n            rank[x] += rank[y]\r\n        }\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501283479","body":"```\r\nfunc findNumberOfLIS(nums []int) int {\r\n    type info struct {\r\n        maxLen int //最大递增子序列长度\r\n        cnt int    //最大递增子序列个数\r\n    }\r\n    var dp [2000]info\r\n    for i:=0; i<len(nums); i++ { //初始化，长度为1，个数为1\r\n        dp[i] = info{1, 1}\r\n    }\r\n    \r\n    for i:=0; i<len(nums); i++ {\r\n        for j:=i-1; j>=0; j-- {\r\n            if nums[i] > nums[j] { //当第i数大于第j数的值时\r\n                if 1+dp[j].maxLen > dp[i].maxLen { //当第j数的最大递增子序列长度+1 大于 当前第i数的最大长度\r\n                    dp[i].maxLen = 1+dp[j].maxLen //更新第i数的最大长度\r\n                    dp[i].cnt = dp[j].cnt //更新第i数的最大长度个数\r\n                } else if 1+dp[j].maxLen == dp[i].maxLen { //当第j数的最大递增子序列长度+1 等于 当前第i数的最大长度\r\n                     dp[i].cnt += dp[j].cnt //则累加个数\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    maxLen, cnt := 0, 0 //数组內最大递增子序列长度和个数\r\n    for i:=0; i<len(nums); i++ {\r\n        if dp[i].maxLen > maxLen { //大于\r\n            maxLen = dp[i].maxLen //更新长度\r\n            cnt = dp[i].cnt //更新个数\r\n        } else if dp[i].maxLen == maxLen { //等于\r\n            cnt += dp[i].cnt //累加个数\r\n        }\r\n    }\r\n    return cnt\r\n}\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1510773920","body":"```\r\nfunc coinChange(coins []int, amount int) int {\r\n    if amount == 0 {\r\n        return 0\r\n    }\r\n    if len(coins) == 0 && amount > 0 {\r\n        return -1\r\n    }\r\n    resCache := make(map[int]int)\r\n    return findFewestNum(coins, 0, resCache, amount)\r\n}\r\n\r\n/*\r\n当前curTotal情况下，满足条件的最少硬币数\r\n*params: curTotal就是当前的状态，因为每个面值的硬币无限多，因此硬币使用情况不影响当前的状态\r\n*params: resCache: { key: curTotal, value: minNum }\r\n*/\r\nfunc findFewestNum(coins []int, curTotal int, resCache map[int]int, amount int) (res int) {\r\n    if value, ok := resCache[curTotal]; ok {\r\n        return value\r\n    }\r\n    if curTotal == amount {\r\n        return 0\r\n    }\r\n    if curTotal > amount {\r\n        return -1\r\n    }\r\n    defer func(){\r\n        if _, ok := resCache[curTotal]; !ok {\r\n            resCache[curTotal] = res\r\n        }\r\n    }()\r\n    minNum := math.MaxInt\r\n    for _, value := range coins {\r\n        num := findFewestNum(coins, curTotal + value, resCache, amount)\r\n        if num != -1 && num < minNum {\r\n            minNum = num\r\n        }\r\n    }\r\n    if minNum == math.MaxInt {\r\n        return -1\r\n    }\r\n    return minNum + 1\r\n}\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1519340969","body":"```\r\nfunc beautifulArray(n int) []int {\r\n    var res = make([]int,n)\r\n    for i := 0;i<len(res);i++{\r\n        res[i]= 1\r\n    }\r\n    part(res,0,n-1)\r\n    return res\r\n}\r\n\r\nfunc part(arr []int,lo int,hi int){\r\n    if hi<=lo{\r\n        return\r\n    }\r\n    mid := (lo+hi)/2\r\n    part(arr,lo,mid)\r\n    part(arr,mid+1,hi)\r\n    for i := lo;i<=mid;i++{\r\n        arr[i] = 2 * arr[i] -1\r\n    }\r\n    for i := mid+1;i<=hi;i++{\r\n        arr[i] = 2 *arr[i]\r\n    }\r\n    return\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1522679001","body":"```\r\nfunc subsets(nums []int) [][]int {\r\n\tvar res [][]int\r\n\tvar curSet []int\r\n\trecursive(nums, &curSet, 0, &res)\r\n\treturn res\r\n}\r\n\r\nfunc recursive(nums []int, curSet *[]int, index int, res *[][]int) {\r\n\tif index > len(nums)-1 {\r\n        dst := make([]int, len(*curSet))\r\n\t\tcopy(dst, *curSet)\r\n\t\t*res = append(*res, dst)\r\n\t\treturn\r\n\t}\r\n\t// not add current element to curSet\r\n\trecursive(nums, curSet, index+1, res)\r\n\t// add current element to curSet\r\n\t*curSet = append(*curSet, nums[index])\r\n\trecursive(nums, curSet, index+1, res)\r\n\t*curSet = (*curSet)[0 : len(*curSet)-1]\r\n}\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1533166330","body":"```\r\nfunc pruneTree(root *TreeNode) *TreeNode {\r\n    if root == nil {\r\n        return nil\r\n    }\r\n    root.Left, root.Right = pruneTree(root.Left), pruneTree(root.Right)\r\n    if root.Left == nil && root.Right == nil && root.Val == 0 {\r\n        return nil\r\n    }\r\n    return root\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufeng727":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fontendart":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingchehu":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435837452","body":"# 思路\r\n將 sub array 與 sub sorted array 比對數字出現的次數\r\n次數都相同就代表 sub array 可以排序成 sub sorted array，也就代表可以分成一個 chunk\r\n\r\n# Code\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        arr_counter = collections.defaultdict(int)\r\n        sorted_arr_counter = collections.defaultdict(int)\r\n        ans = 0\r\n        \r\n        sorted_arr = sorted(arr)\r\n        \r\n        for i in range(len(arr)):\r\n            arr_counter[arr[i]] += 1\r\n            sorted_arr_counter[sorted_arr[i]] += 1\r\n            if arr_counter == sorted_arr_counter:\r\n                ans += 1\r\n        return ans\r\n```\r\n\r\n# 複雜度\r\nTime: O(N^2) 迴圈裡加上 dict 比對\r\nSpace: O(N) 開了兩個 dict ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436583561","body":"# 思路\r\n要 rotate linked list，就先找到對的位置，拆掉重新接起來\r\n用快慢指針相隔 k，接著快指針走到最後一個 node 的時候慢指針便為在新的 linked list 的最後一個 node\r\n最後就尾接到頭，新的 head 在慢指針的下個節點，再把慢指針指到的 node 斷開\r\n\r\n# Code\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        if k == 0:\r\n            return head\r\n\t\t\t\t\r\n        p = head\r\n        length = 1\r\n        while p.next:\r\n            length += 1\r\n            p = p.next\r\n            \r\n        k = k % length\r\n        fast = slow = head\r\n        while fast.next:\r\n            fast = fast.next\r\n            if k > 0:\r\n                k -= 1\r\n            else:\r\n                slow = slow.next\r\n\r\n        fast.next = head\r\n        head = slow.next\r\n        slow.next = None\r\n        return head\r\n```\r\n\r\n# 複雜度\r\nTime: O(N)\r\nSpace: 未使用額外空間 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438298437","body":"# Code\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        \n        ret = self.swapPairs(head.next.next)\n        tmp = head.next\n        head.next = ret\n        tmp.next = head\n        \n        return tmp\n```\n# 複雜度\nTime: O(N)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439745777","body":"# 思路\r\n使用遞迴，每次都用快慢指針找出 Linked List 中間的節點當作數的根節點，前半 Linked List 遞迴呼叫做出左子樹，後半 Linked List 遞迴呼叫做出右子樹\r\n\r\n# Code\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n        \r\n        slow = ListNode()\r\n        slow.next = head\r\n        fast = head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n\r\n        node = TreeNode()\r\n        node.val = slow.next.val\r\n        node.right = self.sortedListToBST(slow.next.next)\r\n        slow.next = None\r\n        node.left = self.sortedListToBST(head)\r\n        return node\r\n```\r\n# 複雜度\r\nTime:  O(NlogN) 數的高度 logN * 每層執行 N\r\nSpace: O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441937454","body":"# 思路\r\n雙指針，一個從 A 開始另一個從 B 開始同時移動，走完的指針從另一頭再開始走，如果途中有遇到一樣的節點，就代表兩個 Linked list 有相交，反之則沒有\r\n# Code\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        if not headA or not headB:\r\n            return None\r\n        restartedA = restartedB = False\r\n        curA = headA\r\n        curB = headB\r\n        while True:\r\n            if curA == curB:\r\n                return curA\r\n\r\n            if curA.next:\r\n                curA = curA.next\r\n            else:\r\n                if restartedA:\r\n                    return None\r\n                else:\r\n                    curA = headB\r\n                    restartedA = True\r\n            if curB.next:\r\n                curB = curB.next\r\n            else:\r\n                if restartedB:\r\n                    return None\r\n                else:\r\n                    curB = headA\r\n                    restarted = True\r\n```\r\n# 複雜度\r\nTime: O(len(Linked list A) + len(Linked list B)) \r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443379931","body":"# 思路\r\n快慢指針，快指針走兩步，慢指針走一步\r\n當兩個指針重疊的時候，代表快指針超越慢指針剛好一圈的距離\r\n快指針距離 = 2 * 慢指針距離\r\n快指針距離 - 慢指針距離 = 環圓周長\r\n=> 慢指針距離 = 環圓周長\r\n這時候一個指針原地，另一個指針從頭，等速移動，第一次碰到的就是環開始的節點\r\n\r\n# Code\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head:\r\n            return None\r\n        \r\n        slow = fast = head\r\n        while True:\r\n            if not fast or not fast.next:\r\n                return None\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if fast == slow:\r\n                break\r\n        slow = head\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        return slow\r\n```\r\n# 複雜度\r\nTime: O(N)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1444954131","body":"# 思路\r\n使用 hash map 讓 get 可以 O(1)\r\n使用雙向 linked list 讓刷新 key 最後使用順序，以及找出最不常用到的 key，都可以在 O(1) 完成\r\n# Code\r\n```python\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.size = capacity\r\n        self.map = {}\r\n        self.head = ListNode(-1, -1)\r\n        self.tail = ListNode(-1, -1)\r\n        self.head.right = self.tail\r\n        self.tail.left = self.head\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.map:\r\n            node = self.map[key]\r\n            # move to right side of the head \r\n            node.left.right = node.right\r\n            node.right.left = node.left\r\n            node.right = self.head.right\r\n            node.left = self.head\r\n            self.head.right.left = node\r\n            self.head.right = node\r\n            return node.val\r\n        else:\r\n            return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.map:\r\n            node = self.map[key]\r\n            # move to right side of the head \r\n            node.left.right = node.right\r\n            node.right.left = node.left\r\n            node.right = self.head.right\r\n            node.left = self.head\r\n            self.head.right.left = node\r\n            self.head.right = node\r\n            # update value\r\n            node.val = value\r\n        else:\r\n            if len(self.map) == self.size:\r\n                # evict the least recently used key\r\n                node = self.tail.left\r\n                del self.map[node.key]\r\n                self.tail.left = node.left\r\n                node.left.right = self.tail\r\n            # put new node\r\n            node = ListNode(key, value)\r\n            self.map[key] = node\r\n            node.left = self.head\r\n            node.right = self.head.right\r\n            self.head.right.left = node\r\n            self.head.right = node\r\n        return\r\n\r\nclass ListNode:\r\n    def __init__(self, key, val):\r\n        self.key = key\r\n        self.val = val\r\n        self.left = None\r\n        self.right = None\r\n```\r\n# 複雜度\r\nTime: O(1)\r\nSpace: O(N), N = capacity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445390099","body":"# 思路\r\n樹的最深深度等於左右子樹較深的深度的再加一\r\n# Code\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n```\r\n# 複雜度\r\nTime: O(N)，N 為節點數目\r\nSpace: O(h)，h = 樹的深度，logN ~ N","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445540805","body":"# 思路\r\n兩個樹同時 dfs 一一檢查每個 node 是否一樣\r\n# Code\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        elif (not p and q) or (p and not q):\r\n            return False\r\n        else:\r\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n# 複查度\r\nTime: O(N)\r\nSpace: O(h) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448269042","body":"# 思路\r\n使用 dfs，傳入樹的 node 還有此 node 之上串連下來的數字，若此傳入的節點為 leaf 則回傳從 root 到 leaf 的數字，若非 leaf 則回傳非 null 的左右子樹的累計數值\r\n# Code\r\n```python\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        def dfs(node, cur):\r\n            if not node.left and not node.right:\r\n                return cur * 10 + node.val\r\n            ans = 0\r\n            if node.left:\r\n                ans += dfs(node.left, cur * 10 + node.val)\r\n            if node.right:\r\n                ans += dfs(node.right, cur * 10 + node.val)\r\n            return ans\r\n        return dfs(root, 0)\r\n```\r\n# 複雜度\r\nTime: O(N)\r\nSpace: O(h)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450103492","body":"# 思路\r\n用 BFS，每一層都紀錄第一個節點的數字，走到最後一層就能得到答案\r\n# Code\r\n```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        q = collections.deque()\r\n        q.append(root)\r\n        ans = root.val\r\n        while q:\r\n            num = len(q)\r\n            ans = q[0].val\r\n            for _ in range(num):\r\n                node = q.popleft()\r\n                if node.left:\r\n                    q.append(node.left)\r\n                if node.right:\r\n                    q.append(node.right)\r\n        return ans\r\n```\r\n# 複雜度\r\nTime: O(N)\r\nSpace: O(Q) Q 為 queue 的大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451715322","body":"```python\r\nclass Codec:\r\n    # 照著 BFS 序列化，遇到空節點便填上 null 到字串裡\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        # 空的樹回傳空字串\r\n        if not root:\r\n            return ''\r\n        q = collections.deque([root])\r\n        ans = []\r\n        while q:\r\n            node = q.popleft()\r\n            if not node:\r\n                ans.append('null')\r\n            else:\r\n                ans.append(str(node.val))\r\n                q.append(node.left)\r\n                q.append(node.right)\r\n        # 末端的 null 都清掉\r\n        while ans[-1] == 'null':\r\n            ans.pop()\r\n        return ','.join(ans)\r\n\r\n    # 依序走過字串，照著 BFS 的順序組出樹，\r\n    # 如果遇到字串是 null，則代表無需新增節點\r\n    # 把新增的節點紀錄在 queue 裡面，等待下次出 queue 的時候往下連結子節點\r\n    # 從 queue 出來的節點要確定左右子節點都完成了才可以輪到下一個 queue 裡的節點\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if data == '':\r\n            return None\r\n        values = data.split(',')\r\n        # 先完成 root 節點\r\n        root = TreeNode(values[0])\r\n        q = collections.deque([root])      \r\n        # 暫存，左子節點完成，右子節點還沒完成\r\n        cur = None\r\n        for val in values[1:]:\r\n            if val == 'null':\r\n                new_node = None\r\n            else:\r\n                new_node = TreeNode(val)\r\n                q.append(new_node)\r\n                \r\n            if cur:\r\n                node = cur\r\n                node.right = new_node\r\n                cur = None\r\n            else:\r\n                node = q.popleft()\r\n                node.left = new_node\r\n                cur = node\r\n            \r\n        return root\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453643052","body":"# 思路\r\ndfs 走過，用兩層 dict 紀錄，x, y 座標當作 key，value 存那一個座標的所有節點的值，最後把 dict 排序後，組合成答案\r\n# Code\r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        seen = collections.defaultdict(lambda: collections.defaultdict(list))\r\n        \r\n        def dfs(node, x, y):\r\n            if not node:\r\n                return\r\n            seen[x][y].append(node.val)\r\n            dfs(node.left, x-1, y+1)\r\n            dfs(node.right, x+1, y+1)\r\n\r\n        dfs(root, 0, 0)\r\n        ans = []\r\n\r\n        for x in sorted(seen):\r\n            column = []\r\n            for y in sorted(seen[x]):\r\n                for item in sorted(seen[x][y]):\r\n                    column.append(item)\r\n            ans.append(column)\r\n\r\n        return ans\r\n```\r\n# 複雜度\r\nTime: O(NlogN)\r\nSpace: O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455116743","body":"```python\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        count = collections.defaultdict(int)\r\n        for n in nums:\r\n            count[n] += 1\r\n        sorted_item = sorted(count.items(), reverse=True, key=lambda item: item[1])\r\n        return [key for key, _ in sorted_item[:k]]\r\n```\r\n複雜度\r\nTime: O(NlogN)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456398753","body":"# 思路\r\n題目要求 i 到 j 跟 i 到 k 的距離要一樣，可以先把 i 到其他點的距離計算出來，並統計出同距離的點有幾個。再依同距離的點的數量計算可能的 j, k 的組合有幾個，並累加起來。\r\n# Code\r\n```python\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        ans = 0\r\n        for i in range(len(points)):\r\n            dist_count = collections.defaultdict(int)\r\n            for j in range(len(points)):\r\n                dist_count[(points[j][0] - points[i][0]) ** 2 + (points[j][1] - points[i][1]) ** 2] += 1\r\n            for d in dist_count.values():\r\n                ans += d * (d-1)\r\n        return ans\r\n```\r\n# 複雜度\r\nTime: O(N^2)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1458390309","body":"# 思路\r\nsliding window 維護不重複的子字串，hash map 紀錄出現過的字元的位置\r\n# Code\r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        l = r = 0\r\n        ans = 0\r\n        seen = {}\r\n        while r < len(s):\r\n            if s[r] in seen:\r\n                ans = max(ans, r-l)\r\n                l = seen[s[r]] + 1                \r\n            seen[s[r]] = r\r\n            r += 1\r\n        return max(ans, r-l)\r\n```\r\n# 複雜度\r\nTime: O(N)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460289942","body":"# Code\r\n```python\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        window_length = len(\"\".join(words))\r\n        \r\n        # 將題目給的 words 先化成 counters，之後用來對答案\r\n        words_dict = collections.defaultdict(int)\r\n        for word in words:\r\n            words_dict[word] += 1\r\n        \r\n        # 單字的長度\r\n        word_length = len(words[0])\r\n        \r\n        # words 裡給的單字有多長，就開多少個 counter 來紀錄\r\n        seen_dicts = [collections.defaultdict(int) for _ in range(word_length)]\r\n        \r\n        ans = []\r\n        for r in range(len(s) - word_length + 1):\r\n            window_head = r + word_length - window_length\r\n            \r\n            # 當前對應的 counter\r\n            cur_counter = seen_dicts[r%word_length]\r\n            \r\n            # 將 r 指到的單字納入對應的 counter 裡\r\n            r_word = s[r:r+word_length]\r\n            cur_counter[r_word] += 1\r\n            \r\n            # 一旦當前 counter 存的單字數超過題目給的單字數，就要踢除最早納入的單字\r\n            if sum(cur_counter.values()) > len(words):\r\n                word_to_remove = s[window_head-word_length:window_head]\r\n                cur_counter[word_to_remove] -= 1\r\n                if cur_counter[word_to_remove] == 0:\r\n                    del cur_counter[word_to_remove]\r\n\r\n            # 比對當下對應的 counter 跟答案是不是一致\r\n            if cur_counter == words_dict:\r\n                window_head = r + word_length - window_length\r\n                ans.append(window_head)\r\n        \r\n        return ans\r\n```\r\n# 複雜度\r\nTime: O(len(s))，遍歷 s 一次\r\nSpace: O(word_length * len(words))，seen_dicts 的大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462117429","body":"```python\r\nclass Solution:\r\n    def minSubarray(self, nums: List[int], p: int) -> int:\r\n        mod = sum(nums) % p\r\n        if mod == 0:\r\n            return 0\r\n\r\n        mod_dict = {0: -1}\r\n        ans = len(nums)\r\n        total = 0\r\n        for i in range(len(nums)):\r\n            total += nums[i]\r\n            cur_mod = total % p\r\n            target = (cur_mod - mod + p) % p\r\n            if target in mod_dict:\r\n                ans = min(ans, i - mod_dict[target])\r\n            mod_dict[cur_mod] = i\r\n        \r\n        if ans == len(nums):\r\n            return -1\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463511789","body":"# 思路\r\n使用快慢指針\r\n# Code\r\n```python\r\nclass Solution:\r\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        return slow\r\n```\r\n# 複雜度\r\nTime: O(N)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464931867","body":"# 思路\r\n快指針遍歷 array 時，發現數值與慢指針不一樣時，快慢指針的數值互換，並且移動慢指針，直到快指針走完 array\r\n# Code\r\n```python\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        l = r = 0\r\n        while r < len(nums):\r\n            if nums[r] != nums[l]:\r\n                l += 1\r\n                nums[l], nums[r] = nums[r], nums[l]\r\n            r += 1\r\n        return l+1\r\n```\r\n# 複雜度\r\nTIme: O(N)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465081583","body":"# 思路\r\nBinary seach\r\n# Code\r\n```python\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        l, r = 0, len(nums)-1\r\n        while l <= r:\r\n            mid = (r + l)//2\r\n            if nums[mid] == target:\r\n                return mid\r\n            elif nums[mid] > target:\r\n                r = mid - 1\r\n            else:\r\n                l = mid + 1\r\n        return l\r\n```\r\n# 複雜度\r\nTime: O(lngN)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466366911","body":"# 思路\r\n不用把所有 window 裡面的值都紀錄起來比較，而是每當新元素進來的時候，替剔除掉小於新元素的舊元素。使用單調 queue 紀錄 window，queue 由大到小，每當新的元素進來，從先前元素中剔除掉小於新元素的元素\r\nqueue 紀錄 index，既可找回原本的數值，也能計算 window 長度是否超過 k\r\n# Code\r\n```python\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        # queue 紀錄 index，既可找回原本的數值，也能計算 window 長度是否超過 k\r\n        q = collections.deque()\r\n        ans = []\r\n        for i in range(len(nums)):\r\n            # 維持單調遞減：加入新元素前，先去除小於新元素的舊元素\r\n            while q and nums[q[-1]] < nums[i]: q.pop()\r\n            q.append(i)\r\n            # 剔除超過 window 的元素\r\n            while q and q[0] <= i - k: q.popleft()\r\n            if i >= k - 1:\r\n                ans.append(nums[q[0]])\r\n        return ans\r\n```\r\n# 複雜度\r\nTime: O(N)\r\nSpace: O(K)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468023472","body":"# 思路\r\n找出 in degree = N-1， out degree = 0 的點\r\n# Code\r\n```python\r\nclass Solution:\r\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\r\n        in_degree = collections.defaultdict(int)\r\n        out_degree = collections.defaultdict(int)\r\n        for edge in trust:\r\n            out_degree[edge[0]] += 1\r\n            in_degree[edge[1]] += 1\r\n        for i in range(1, n+1):\r\n            if in_degree[i] == n - 1 and out_degree[i] == 0:\r\n                return i\r\n        return -1\r\n```\r\n# 複雜度\r\nTime: O(N)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1470174856","body":"```python\r\nclass Solution:\r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n        graph = [[0] * n for i in range(n)]\r\n        for edge in dislikes:\r\n            print(edge)\r\n            graph[edge[0]-1][edge[1]-1] = 1\r\n            graph[edge[1]-1][edge[0]-1] = 1\r\n            \r\n        colors = [0] * n\r\n        \r\n        # 確保所有的節點都上色了，從還沒上色的節點開始 dfs 下去塗色\r\n        for i in range(n):\r\n            if colors[i] == 0:\r\n                if not self.dfs(graph, colors, n, i, 1):\r\n                    # 一旦塗色失敗就回錯\r\n                    return False\r\n        return True\r\n        \r\n        \r\n    def dfs(self, graph, colors, n, i, color):\r\n        colors[i] = color\r\n        for j in range(n):\r\n            # 如果 i 與 j 相連\r\n            if graph[i][j] == 1:\r\n                # 如果 j 已經上過色，而且還跟 i 同樣顏色，就塗色失敗\r\n                if colors[j] == color:\r\n                    return False\r\n                # 如果 j 還沒上過色，就繼續 dfs 塗色\r\n                if colors[j] == 0:\r\n                    # 一旦有塗色失敗，就直接回傳失敗\r\n                    if not self.dfs(graph, colors, n, j, -1 * color):\r\n                        return False\r\n        return True\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1472080409","body":"嘗試讀懂\r\n```python\r\nclass Solution:\r\n    # bfs topological sort\r\n    def tp_sort(self, items, indegree, neighbors):\r\n        q = collections.deque([])\r\n        ans = []\r\n\t# 從 indegree 0 的節點開始\r\n        for item in items:\r\n            if not indegree[item]:\r\n                q.append(item)\r\n        while q:\r\n            cur = q.popleft()\r\n            ans.append(cur)\r\n\r\n            for neighbor in neighbors[cur]:\r\n\t\t# 走過相連節點將 indegree 減一\r\n                indegree[neighbor] -= 1\r\n\t\t# 直到 indegree 為 0 時加入 queue\r\n                if not indegree[neighbor]:\r\n                    q.append(neighbor)\r\n\r\n        return ans\r\n\r\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\r\n        max_group_id = m\r\n\t# 沒有小組負責的專案，逕自逐一分配給新的小組\r\n        for project in range(n):\r\n            if group[project] == -1:\r\n                group[project] = max_group_id\r\n                max_group_id += 1\r\n\r\n        project_indegree = collections.defaultdict(int)\r\n        group_indegree = collections.defaultdict(int)\r\n        project_neighbors = collections.defaultdict(list)\r\n        group_neighbors = collections.defaultdict(list)\r\n        group_projects = collections.defaultdict(list)\r\n\r\n        for project in range(n):\r\n            group_projects[group[project]].append(project)\r\n\r\n            for pre in pres[project]:\r\n\t\t# 如果是不同小組完成的，那這兩個小組就有相依關係\r\n                if group[pre] != group[project]:\r\n                    # 小组關係圖\r\n                    group_indegree[group[project]] += 1\r\n                    group_neighbors[group[pre]].append(group[project])\r\n                else:\r\n                    # 專案關係圖\r\n                    project_indegree[project] += 1\r\n                    project_neighbors[pre].append(project)\r\n\r\n        ans = []\r\n        # 先對小組做拓墣排序\r\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\r\n\r\n        if len(group_queue) != max_group_id:\r\n            return []\r\n\r\n        for group_id in group_queue:\r\n            # 對小組中的專案做拓墣排序\r\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\r\n\r\n            if len(project_queue) != len(group_projects[group_id]):\r\n                return []\r\n            ans += project_queue\r\n\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473364576","body":"# Code\r\n```python\r\nclass Solution:\r\n    def judgeCircle(self, moves: str) -> bool:\r\n        x, y = 0, 0\r\n        for step in moves:\r\n            if step == 'R':\r\n                x += 1\r\n            elif step == 'L':\r\n                x -= 1\r\n            elif step == 'U':\r\n                y += 1\r\n            else:\r\n                y -= 1\r\n        return x == 0 and y == 0\r\n```\r\n# 複雜度\r\nTime: O(N)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474680072","body":"```python\r\nclass Solution:\r\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\r\n        tasks = [(task[0], task[1], i) for i, task in enumerate(tasks)]\r\n        tasks.sort()\r\n        i = 0\r\n        queue = []\r\n        t = 0\r\n        ans = []\r\n        while i < len(tasks) or queue:\r\n            if not queue:\r\n                t = max(t, tasks[i][0])\r\n            while i < len(tasks) and tasks[i][0] <= t:\r\n                heapq.heappush(queue, (tasks[i][1], tasks[i][2]))\r\n                i += 1\r\n            processingTime, index = heapq.heappop(queue)\r\n            ans.append(index)\r\n            t += processingTime\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475063310","body":"```python\r\nclass Solution:\r\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\r\n        loginTime = loginTime.split(':')\r\n        logoutTime = logoutTime.split(':')\r\n        inHr, inMin = int(loginTime[0]), int(loginTime[1])\r\n        outHr, outMin = int(logoutTime[0]), int(logoutTime[1])\r\n\r\n\t# 跨日把結束時間加24小時\r\n        inTime = inHr * 60 + inMin\r\n        outTime = outHr * 60 + outMin\r\n        if outTime < inTime:\r\n            outHr += 24\r\n\r\n        # 從登入時間找出最近一場的開始時間\r\n        if 0 < inMin <= 15:\r\n            inMin = 15\r\n        elif 15 < inMin <= 30:\r\n            inMin = 30\r\n        elif 30 < inMin <= 45:\r\n            inMin = 45\r\n        elif 45 < inMin <= 59:\r\n            inMin = 0\r\n            inHr += 1\r\n        elif inMin == 0:\r\n            inMin = 0\r\n\r\n        inTime = inHr * 60 + inMin\r\n        outTime = outHr * 60 + outMin\r\n        return (outTime - inTime) // 15 if (outTime - inTime) >= 0 else 0\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475817216","body":"```python\r\nclass Solution:\r\n    def minCharacters(self, a: str, b: str) -> int:\r\n        count_a = collections.defaultdict(int)\r\n        count_b = collections.defaultdict(int)\r\n        for s in a:\r\n            count_a[ord(s)] += 1\r\n        for s in b:\r\n            count_b[ord(s)] += 1\r\n\r\n        return min(self.rule_1_2_helper(count_a, count_b), self.rule_1_2_helper(count_b, count_a), self.rule_3_helper(count_a, count_b))\r\n        \r\n    def rule_1_2_helper(self, count_a, count_b):\r\n        ans = math.inf\r\n        for i in range(1, 26):\r\n            cur = 0\r\n            for k, v in count_a.items():\r\n                if k - ord('a') < i:\r\n                    cur += v\r\n            for k, v in count_b.items():\r\n                if k - ord('a') >= i:\r\n                    cur += v\r\n            ans = min(ans, cur)\r\n        return ans\r\n\r\n    def rule_3_helper(self, count_a, count_b):\r\n        ans = math.inf\r\n        for i in range(26):\r\n            cur = 0\r\n            for k, v in count_a.items():\r\n                if k - ord('a') != i:\r\n                    cur += v\r\n            for k, v in count_b.items():\r\n                if k - ord('a') != i:\r\n                    cur += v\r\n            ans = min(ans, cur)\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477622662","body":"```python\r\nclass Solution:\r\n    def sortArray(self, nums: List[int]) -> List[int]:\r\n        self.sort(nums, 0, len(nums)-1)\r\n        return nums\r\n\r\n    def sort(self, nums, left, right):\r\n        if right <= left:\r\n            return\r\n\r\n        i, j = left, right\r\n        pivot = nums[left]\r\n        while i != j:\r\n            while nums[j] > pivot and i < j:\r\n                j -= 1\r\n            while nums[i] <= pivot and i < j:\r\n                i += 1\r\n            if i < j:\r\n                nums[i], nums[j] = nums[j], nums[i]\r\n        nums[left], nums[i] = nums[i], nums[left]\r\n\r\n        self.sort(nums, left, i-1)\r\n        self.sort(nums, i+1, right)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479679654","body":"```python\r\nclass Solution:\r\n    def mySqrt(self, x: int) -> int:\r\n        left, right = 0, x\r\n        ans = 0\r\n        while left <= right:\r\n            mid = (right + left) // 2\r\n            if mid ** 2 > x:\r\n                right = mid - 1\r\n            elif mid ** 2 < x:\r\n                left = mid + 1\r\n                # 遇到可能的答案先暫存起來\r\n                ans = mid\r\n            else:\r\n                return mid\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480923203","body":"```python\r\nclass Solution:\r\n    def firstBadVersion(self, n: int) -> int:\r\n        l, r = 1, n\r\n        while l <= r:\r\n            mid = (l + r) // 2\r\n            if isBadVersion(mid):\r\n                r = mid - 1\r\n            else:\r\n                l = mid + 1\r\n        return l\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482988892","body":"```python\r\nfrom sortedcontainers import SortedList\r\n\r\nclass Solution:\r\n    def reversePairs(self, nums: List[int]) -> int:\r\n        s = SortedList()\r\n        ans = 0\r\n\r\n        for n in nums:\r\n            x = s.bisect_right(n * 2)\r\n            ans += (len(s) - x)\r\n            # 用 sorted list 可以讓加入元素的複雜度從 bisect.insort 的 O(N) 降低為 O(logN)\r\n            s.add(n)\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483855497","body":"```python\r\nclass Solution:\r\n    def solve(self, nums):\r\n        nums.sort()\r\n        N = len(nums)\r\n        if N <= 3:\r\n            return 0\r\n        LIGHTS = 3\r\n\r\n        def possible(diameter):\r\n            start = nums[0]\r\n            end = start + diameter\r\n            for i in range(LIGHTS):\r\n                idx = bisect_right(nums, end)\r\n                if idx >= N:\r\n                    return True\r\n                start = nums[idx]\r\n                end = start + diameter\r\n            return False\r\n\r\n        l, r = 0, nums[-1] - nums[0]\r\n        while l <= r:\r\n            mid = (l + r) // 2\r\n            if possible(mid):\r\n                r = mid - 1\r\n            else:\r\n                l = mid + 1\r\n        return l / 2\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1483970667","body":"```python\r\nclass Solution:\r\n    def solve(self, A, k):\r\n        A.sort()\r\n        def count_not_greater(diff):\r\n            i = ans = 0\r\n            for j in range(1, len(A)):\r\n                while A[j] - A[i] > diff:\r\n                    i += 1\r\n                ans += j - i\r\n            return ans\r\n        l, r = 0, A[-1] - A[0]\r\n        k += 1 \r\n        while l <= r:\r\n            mid = (l + r) // 2\r\n            if count_not_greater(mid) >= k:\r\n                r = mid - 1\r\n            else:\r\n                l = mid + 1\r\n        return l\r\n```\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1485172406","body":"```python\r\nclass Solution:\r\n    def swimInWater(self, grid: List[List[int]]) -> int:\r\n        l, r = 0, max([max(v) for v in grid])\r\n        n = len(grid)\r\n        seen = set()\r\n        \r\n        def test(t, x, y):\r\n            if x < 0 or y < 0 or x >= n or y >= n:\r\n                return False\r\n            if (x, y) in seen:\r\n                return False\r\n            if grid[x][y] > t:\r\n                return False\r\n            if x == n-1 and y == n-1:\r\n                return True\r\n            seen.add((x,y))\r\n            return test(t, x+1, y) or test(t, x-1, y) or test(t, x, y-1) or test(t, x, y+1)\r\n\r\n        while l <= r:\r\n            mid = (l+r) // 2\r\n            if test(mid, 0, 0):\r\n                r = mid - 1\r\n            else:\r\n                l = mid + 1\r\n            seen = set()\r\n        return l\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486847300","body":"# 思路\r\n固定長度滑動窗口\r\n# Code\r\n```python\r\nclass Solution:\r\n    def maxVowels(self, s: str, k: int) -> int:\r\n        r = l = 0\r\n        ans = cnt = 0\r\n        \r\n        while r < len(s):\r\n            if s[r] in ['a', 'e', 'i', 'o', 'u']:\r\n                cnt += 1\r\n\r\n            while l <= r:\r\n                if r - l + 1 > k:\r\n                    if s[l] in ['a', 'e', 'i', 'o', 'u']:\r\n                        cnt -= 1\r\n                    l += 1\r\n                else:\r\n                    break\r\n            \r\n            ans = max(ans, cnt)\r\n            r += 1\r\n        \r\n        return ans\r\n```\r\n# 複雜度\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488659402","body":"```python\r\nclass Solution:\r\n    def new21Game(self, N: int, K: int, W: int) -> float:\r\n        dp = [0] * (K + W)\r\n        win_sum = 0\r\n        for i in range(K, K + W):\r\n            if i <= N:\r\n                dp[i] = 1\r\n            win_sum += dp[i]\r\n\r\n        for i in range(K - 1, -1, -1):\r\n            dp[i] = win_sum / W\r\n            win_sum += dp[i] - dp[i + W]\r\n        return dp[0]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1490231935","body":"```python\r\nclass Solution:\r\n    def findAnagrams(self, s: str, p: str) -> List[int]:\r\n        l = r = 0\r\n        p_cnt = collections.Counter(p) \r\n        seen = collections.defaultdict(int)\r\n        ans = []\r\n\r\n        while r <= len(s)-1:\r\n            seen[s[r]] += 1\r\n\r\n            while r-l+1 > len(p):\r\n                seen[s[l]] -= 1\r\n                if seen[s[l]] == 0:\r\n                    del seen[s[l]]\r\n                l += 1\r\n\r\n            if r-l+1 == len(p) and p_cnt == seen:\r\n                ans.append(l)\r\n            r += 1\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1492194317","body":"```python\r\nclass Solution:\r\n    def minWindow(self, s: str, t: str) -> str:\r\n        def fullfill(seen, target):\r\n            if len(seen) != len(target):\r\n                return False\r\n            for k in target:\r\n                if seen[k] < target[k]:\r\n                    return False\r\n            return True\r\n\r\n        l = 0\r\n        ans = \"\"\r\n        seen = collections.defaultdict(int)\r\n        target = collections.Counter(t)\r\n\r\n        for r in range(len(s)):\r\n            if s[r] in target:\r\n                seen[s[r]] += 1\r\n\r\n            while l <= r and fullfill(seen, target):\r\n                candidate = s[l:r+1]\r\n                if len(candidate) < len(ans) or len(ans) == 0:\r\n                    ans = candidate                \r\n                if s[l] in seen:\r\n                    seen[s[l]] -= 1\r\n                    if seen[s[l]] == 0:\r\n                        del seen[s[l]]\r\n                l += 1\r\n\r\n        return ans\r\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493199556","body":"```python\r\nclass Solution:\r\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\r\n        hour = collections.defaultdict(list)\r\n        mins = collections.defaultdict(list)\r\n            \r\n        for i in range(12):\r\n            h, sum =i, 0\r\n            for n in range(3, -1, -1):\r\n                if h >= 2 ** n:\r\n                    h -= 2 ** n\r\n                    sum += 1\r\n            hour[sum].append(\"%d\" % i)\r\n        \r\n        for i in range(60):\r\n            m, sum =i, 0\r\n            for n in range(5, -1, -1):\r\n                if m >= 2 ** n:\r\n                    m -= 2 ** n\r\n                    sum += 1\r\n            mins[sum].append(\"%02d\" % i)\r\n\r\n        ans = []\r\n        for n in range(turnedOn+1):\r\n            for h in hour[n]:\r\n                for m in mins[turnedOn - n]:\r\n                    ans.append(h + \":\" + m)\r\n        return ans\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494343384","body":"```python\r\nclass Solution:\r\n    def __init__(self):\r\n        self.ans = 0\r\n\r\n    def totalNQueens(self, n: int) -> int:\r\n        def dfs(n, row, col, pie, na):\r\n            if row >= n:\r\n                self.ans += 1\r\n                return\r\n            bits = ~(col | pie | na) & ((1 << n) - 1)\r\n            while bits:\r\n                p = bits & -bits\r\n                bits = bits & (bits - 1)\r\n                dfs(n, row + 1, col | p, (pie | p) << 1, (na | p) >> 1)\r\n        \r\n        dfs(n, 0, 0, 0, 0)\r\n        return self.ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495187478","body":"```python\r\nclass Solution:\r\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\r\n        def dfs(x, y):\r\n            if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]):\r\n                return 0\r\n            if grid[x][y] == 0:\r\n                return 0\r\n            grid[x][y] = 0\r\n            return 1 + dfs(x+1, y) + dfs(x-1, y) + dfs(x, y+1) + dfs(x, y-1)\r\n        ans = 0\r\n        for i in range(len(grid)):\r\n            for j in range(len(grid[0])):\r\n                ans = max(ans, dfs(i, j))\r\n        return ans\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497509249","body":"```python\r\nclass Solution:\r\n    def maxDistance(self, grid: List[List[int]]) -> int:\r\n        n = len(grid[0])\r\n        q = collections.deque([(x, y) for y in range(n) for x in range(n) if grid[x][y] == 1])\r\n        if len(q) == 0 or len(q) == n ** 2: return -1\r\n\r\n        step = -1\r\n        while q:\r\n            step += 1\r\n            for _ in range(len(q)):\r\n                point = q.popleft()\r\n                for (x, y) in [(point[0]+1, point[1]), (point[0]-1, point[1]), (point[0], point[1]+1), (point[0], point[1]-1)]:\r\n                    if x >= 0 and x < n and y >= 0 and y < n and grid[x][y] == 0:\r\n                        q.append((x, y))\r\n                        grid[x][y] = -1\r\n\r\n        return step\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1499142985","body":"```python\r\nclass Solution:\r\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\r\n        ownOpenedBox = []\r\n        ownBox = dict()\r\n        for i in initialBoxes:\r\n            if status[i] == 1:\r\n                ownOpenedBox.append(i)\r\n            else:\r\n                ownBox[i] = None\r\n        \r\n        amt = 0\r\n        for b in ownOpenedBox:\r\n            amt += candies[b]\r\n            for n in containedBoxes[b]:\r\n                if status[n] == 1:\r\n                    ownOpenedBox.append(n)\r\n                else:\r\n                    ownBox[n] = None\r\n            for k in keys[b]:\r\n                if k in ownBox:\r\n                    ownOpenedBox.append(k)\r\n                    del ownBox[k] # 要刪掉開過的\r\n                status[k] = 1\r\n\r\n        return amt\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1500391063","body":"leetcode 987\r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        seen = collections.defaultdict(lambda: collections.defaultdict(list))\r\n        \r\n        def dfs(node, x, y):\r\n            if not node:\r\n                return\r\n            seen[x][y].append(node.val)\r\n            dfs(node.left, x-1, y+1)\r\n            dfs(node.right, x+1, y+1)\r\n\r\n        dfs(root, 0, 0)\r\n        ans = []\r\n\r\n        for x in sorted(seen):\r\n            column = []\r\n            for y in sorted(seen[x]):\r\n                for item in sorted(seen[x][y]):\r\n                    column.append(item)\r\n            ans.append(column)\r\n\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500897149","body":"```python\r\nclass Solution:\r\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\r\n        stair = [] \r\n        for i in range(len(cost)+1):\r\n            if i == 0 or i == 1:\r\n                stair.append(0)\r\n            else:\r\n                stair.append(min(stair[i-1]+cost[i-1], stair[i-2]+cost[i-2]))\r\n\r\n        return stair[-1]\r\n```\r\n# 複雜度\r\nTime: O(N)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501149368","body":"```python\r\nclass Solution:\r\n    def rob(self, nums: List[int]) -> int:\r\n        accu = []\r\n        for i in range(len(nums)):\r\n            if i == 0:\r\n                accu.append(nums[0])\r\n            elif i == 1:\r\n                accu.append(max(nums[0], nums[1]))\r\n            else:\r\n                accu.append(max(accu[i-2]+nums[i], accu[i-1]))\r\n        return accu[-1]\r\n```\r\n# 複雜度\r\nTime: O(N)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501938504","body":"```python\r\nclass Solution:\r\n    def findNumberOfLIS(self, nums: List[int]) -> int:\r\n        n = len(nums)\r\n        dp =  [[1, 1] for i in range(n)] # [最長長度, 最長長度的個數]\r\n\r\n        for i in range(n):\r\n            for j in range(i):\r\n                if nums[i] > nums[j]:\r\n                    if dp[j][0] + 1 > dp[i][0]: # 若長度更長，更新最長長度與個數\r\n                        dp[i][0] = dp[j][0] + 1\r\n                        dp[i][1] = dp[j][1]\r\n                    elif dp[j][0] + 1 == dp[i][0]: # 若長度一樣，累加個數\r\n                        dp[i][1] += dp[j][1]\r\n        longest = max([dp[i][0] for i in range(n)])\r\n        return sum([dp[i][1] for i in range(n) if dp[i][0] == longest])\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1503322063","body":"```python\r\nclass Solution:\r\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\r\n        m, n = len(text1), len(text2)\r\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\r\n        ans = 0\r\n        for i in range(1, m+1):\r\n            for j in range(1, n+1):\r\n                if text1[i-1] == text2[j-1]:\r\n                    dp[i][j] = dp[i-1][j-1] + 1\r\n                    ans = max(ans, dp[i][j])\r\n                else:\r\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\r\n        return ans\r\n```\r\n複雜度\r\nTime: O(m * n)\r\nSpace: O(m * n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1505529789","body":"```python\r\nclass Solution:\r\n    def uniquePaths(self, m: int, n: int) -> int:\r\n        d = [[1] * n for _ in range(m)]\r\n\r\n        for col in range(1, m):\r\n            for row in range(1, n):\r\n                d[col][row] = d[col - 1][row] + d[col][row - 1]\r\n\r\n        return d[m - 1][n - 1]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1507086913","body":"```python\r\nclass Solution:\r\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\r\n        dp = [[0 for _ in range(n)] for _ in range(n)]\r\n        dp[row][column] = 1\r\n        directions = [[1, 2], [1, -2], [-1, 2], [-1, -2], [2, 1], [2, -1], [-2, 1], [-2, -1]]\r\n\r\n        for _ in range(k):\r\n            temp_dp = [[0 for _ in range(n)] for _ in range(n)]\r\n            for i in range(n):\r\n                for j in range(n):\r\n                    for d in directions:\r\n                        x, y = i - d[0], j - d[1]\r\n                        if 0 <= x < n and 0 <= y < n:\r\n                            temp_dp[i][j] += dp[x][y] * 0.125\r\n            dp = temp_dp\r\n\r\n        p = 0\r\n        for i in range(n):\r\n            for j in range(n):\r\n                p += dp[i][j]\r\n        return p\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509875209","body":"```python\r\nclass Solution:\r\n    def canPartition(self, nums: List[int]) -> bool:\r\n        target = sum(nums) // 2\r\n        if target + target != sum(nums):\r\n            return False\r\n        dp = [False] * (target + 1)\r\n        dp[0] = True\r\n\r\n        for i in range(1, len(nums) + 1):\r\n            for j in range(target, 0, -1):\r\n                if dp[j] or (j - nums[i - 1] > -1 and dp[j - nums[i - 1]]):\r\n                    dp[j] = True\r\n        return dp[-1]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510403580","body":"```python\r\nclass Solution:\r\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\r\n        if (sum(nums) + target) % 2 == 1: return 0\r\n        t = (sum(nums) + target) // 2\r\n        dp = [[0] * (len(nums) + 1) for _ in range(t + 1)]\r\n        dp[0][0] = 1\r\n        for i in range(t + 1):\r\n            for j in range(1, len(nums) + 1):\r\n                dp[i][j] = dp[i][j-1]\r\n                if i - nums[j-1] >= 0: dp[i][j] += dp[i - nums[j-1]][j-1]\r\n        return dp[-1][-1]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511603724","body":"```python\r\nclass Solution:\r\n    def coinChange(self, coins, amount):\r\n        dp = [amount + 1] * (amount+1)\r\n        dp[0] = 0\r\n        for coin in coins:\r\n            for i in range(coin, amount+1):            \r\n                dp[i] = min(dp[i], dp[i-coin]+1)\r\n        return -1 if dp[amount] == amount + 1 else dp[amount]\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514929079","body":"```python\r\nclass Solution:\r\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\r\n        g.sort()\r\n        s.sort()\r\n        kid = 0\r\n        for cookie in s:\r\n            if cookie >= g[kid]:\r\n                kid += 1\r\n            if kid == len(g):\r\n                break\r\n\r\n        return kid\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516556412","body":"```python\r\nclass Solution:\r\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\r\n        n = len(intervals)\r\n        if n == 0: return 0\r\n        dp = [1] * n\r\n        ans = 1\r\n        intervals.sort(key=lambda a: a[0])\r\n\r\n        for i in range(len(intervals)):\r\n            for j in range(i - 1, -1, -1):\r\n                if intervals[i][0] >= intervals[j][1]:\r\n                    dp[i] = max(dp[i], dp[j] + 1)\r\n                    break\r\n        return n - max(dp)\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518687607","body":"```python\r\nclass Solution:\r\n    visited = dict()\r\n\r\n    def numTrees(self, n: int) -> int:\r\n        if n in self.visited:\r\n            return self.visited.get(n)\r\n        if n <= 1:\r\n            return 1\r\n        res = 0\r\n        for i in range(1, n + 1):\r\n            res += self.numTrees(i - 1) * self.numTrees(n - i)\r\n        self.visited[n] = res\r\n        return res\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1523634177","body":"```python\nclass Solution:\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res, end = [], 1 << len(nums)\n        for sign in range(end):\n            subset = []\n            for i in range(len(nums)):\n                if ((1 << i) & sign) != 0:\n                    subset.append(nums[i])\n            res.append(subset)\n        return res\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1529037018","body":"```python\nclass Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        \n        def dfs(i):\n            visited.add(i)\n            for j in range(len(isConnected[i])):\n                if j not in visited and isConnected[i][j]==1:\n                    dfs(j)\n                    \n        visited = set()\n        provinces = 0\n        for i in range(len(isConnected)):\n            if i not in visited:\n                dfs(i)\n                provinces +=1\n            \n        return provinces\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1534715133","body":"```python\r\nclass Solution:\r\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\r\n        def backtrack(ans,tempList, candidates, remain, start):\r\n            if remain < 0: return\r\n            elif remain == 0: return ans.append(tempList.copy()) \r\n            for i in range(start, len(candidates)):\r\n                tempList.append(candidates[i])\r\n                backtrack(ans, tempList, candidates, remain - candidates[i], i)\r\n                tempList.pop()\r\n        ans = [];\r\n        backtrack(ans, [], candidates, target, 0);\r\n        return ans;\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null],"cobayaz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomato-tomato":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xfliudx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"djd28176":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xilutian":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"itsjacob":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shunanch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yppah-eb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raychenlei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"woshichuanqilz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"willuuu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christina-soda":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jia98shanliang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user-vannnn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tobepellucid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnvsd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yueza":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawyuan97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"victorhuang99":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cusanity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jay-xzj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiradaone":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyue-ma":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joyce94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"steven72574":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tian-pengfei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asuka1h":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaowangcoding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james0608":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaneyang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"azl397985856":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whgsh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chengfengfengwang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bulingbulingbuling":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c2tr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448160584","body":"dfs\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        def dfs(root, cur):\n            if not root:\n                return 0\n\n            cur = cur * 10 + root.val\n\n            if not root.left and not root.right:\n                return cur\n            \n            return dfs(root.left, cur) + dfs(root.right, cur)\n\n        return dfs(root, 0)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eden-ye":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingtrains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"starorbiting":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo-xiaoxiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"passengersa":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shellylcooper":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"testplm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tom-zhouch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skylarxu214":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taihui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huaxueguakele":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yang-chenyu104":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mlking15":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"-3":[],"cyonline":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rzhao010":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jetery":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429910267","body":"### [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n### 思路\n模拟竖式的加法, 得到每个数组的最低位, 从最低位开始加\\\n注意 _循环结束后_ 对进位 `t` 的判断\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> a, b;\n        for (int i = num.size() - 1; i >= 0; i--) a.push_back(num[i]);\n        while (k != 0) {\n            b.push_back(k % 10);\n            k /= 10;\n        }\n        vector<int> temp;\n        int t = 0;\n        for (int i = 0; i < a.size() || i < b.size(); i++) {\n            if (i < a.size()) t += a[i];\n            if (i < b.size()) t += b[i];\n            temp.push_back(t % 10);\n            t /= 10;\n        }\n        if (t) temp.push_back(1);\n        vector<int> ans;\n        for (int i = temp.size() - 1; i >= 0; i--) ans.push_back(temp[i]);\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431533429","body":"```\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> ans(s.size(), INT_MAX);\n        int l = s.size(), r = -1, n = s.size();\n        for (int i = 0; i < s.size(); i++) {\n            int j = n - 1 - i;\n            if (s[i] == c) l = i;\n            if (s[j] == c) r = j;\n            if (i >= l) ans[i] = min(ans[i], i - l);\n            if (j <= r) ans[j] = min(ans[j], r - j);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433192790","body":"```cpp\nclass CustomStack {\n\npublic:\n    int size = 0, max = 0;\n    vector<int> stack;\n\n    CustomStack(int maxSize) {\n        max = maxSize;\n    }\n    \n    void push(int x) {\n        if (size < max) {\n            stack.push_back(x);\n            size++;\n        }\n    }\n    \n    int pop() {\n        if (size == 0) return -1;\n        size = size - 1;\n        int ret = stack[size];\n        stack.pop_back();\n        return ret;\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i < size && i < k; i++) {\n            stack[i] += val;\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434832063","body":"```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<int> num;\n        int n = 0;\n        stack<string> str;\n        string ans = \"\";\n        for (char c : s) {\n            if (c >= '0' && c <= '9') {\n                n = n * 10 + c - '0';\n            } else if (c == '[') {\n                num.push(n);\n                n = 0;\n                str.push(ans);\n                ans = \"\";\n            } else if (c == ']') {\n                int t = num.top();\n                num.pop();\n                for (int i = 0; i < t; i++) {\n                    str.top() += ans;\n                }\n                ans = str.top();\n                str.pop();\n            } else {\n                ans += c;\n            }\n        }\n        return ans;\n    }\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435650699","body":"```cpp\nclass MyQueue {\npublic:\n    stack<int> input;\n    stack<int> output;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        input.push(x);\n    }\n    \n    int pop() {\n        int ret = 0;\n        if (output.size() > 0) {\n            ret = output.top();\n            output.pop();\n        } else {\n            while (!input.empty()) {\n                output.push(input.top());\n                input.pop();\n            }\n            ret = output.top();\n            output.pop();\n        }\n        return ret;\n    }\n    \n    int peek() {\n        int ret = 0;\n        if (output.size() > 0) {\n            ret = output.top();\n        } else {\n            while (!input.empty()) {\n                output.push(input.top());\n                input.pop();\n            }\n            ret = output.top();\n        }\n        return ret;\n    }\n    \n    bool empty() {\n        return input.empty() && output.empty();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436017435","body":"```cpp\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        // å·²ç»æåºçæ°ç»\n        vector<int> clone = arr;\n        sort(clone.begin(), clone.end());\n        \n        int ans = 0, window = 0;\n        // ä½¿ç¨åå¸è¡¨è¿è¡è®¡æ°\n        unordered_map<int, int> map;\n\n        for (int i = 0; i < arr.size(); i++) {\n            map[arr[i]]++;\n            if (map[arr[i]] == 0) window--;\n            else if (map[arr[i]] == 1) window++;\n\n            map[clone[i]]--;\n            if (map[clone[i]] == 0) window--;\n            else if (map[clone[i]] == -1) window++;\n\n            if (window == 0) ans++;\n        }\n\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437184094","body":"```cpp\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (k == 0 || head == NULL || head->next == NULL) {\n            return head;\n        }\n        \n        int size = 1;\n        ListNode* cur = head;\n        while (cur->next != NULL) {\n            cur = cur->next;\n            size++;\n        }\n        cur->next = head;\n\n        k %= size;\n        for (int i = size - k - 1; i > 0; i--) {\n            head = head->next;\n        }\n\n        cur = head->next;\n        head->next = NULL;\n\n        return cur;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438684634","body":"```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* dummy = new ListNode(-1);\n        dummy->next = head;\n        ListNode *a = dummy, *b = head;\n        while (b != nullptr && b->next != nullptr) {\n            ListNode* c = b->next;\n            ListNode* d = c->next;\n            a->next = c;\n            c->next = b;\n            b->next = d;\n            a = b;\n            b = a->next;\n        }\n\n        return dummy->next;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440285037","body":"```cpp\n\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        TreeNode *root;\n        if (head == nullptr) return nullptr;\n        else if (head->next == nullptr) {\n            root = new TreeNode(head->val);\n            return root;\n        }\n\n        ListNode *fast = head, *slow = head, *pre = head;\n        // è®© slow æåä¸­é´èç¹\n        while (fast != nullptr && fast->next != nullptr) {\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        while (pre->next != slow) pre = pre->next;\n        root = new TreeNode(slow->val);\n        pre->next = nullptr; // ä»ä¸­é´æ­å¼é¾è¡¨, é²æ­¢éå½æ¶é¾è¡¨é¿åº¦ä¸å\n        // éå½å¤ç\n        root->left = sortedListToBST(head);\n        root->right = sortedListToBST(slow->next);\n\n        return root;\n\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441830126","body":"```cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (!headA || !headB) return nullptr;\n        ListNode *a = headA, *b = headB;\n        while (a != b) {\n            a = a == nullptr ? headB : a->next;\n            b = b == nullptr ? headA : b->next;\n        }\n        return a;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443807764","body":"```cpp\n\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head, *fast = head;\n        while (fast != nullptr && fast->next != nullptr) {\n            fast = fast->next->next;\n            slow = slow->next;\n            if (fast == slow) break;\n        }\n\n        if (fast == nullptr || fast->next == nullptr) return nullptr;\n        slow = head;\n        while (slow != fast) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return slow;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445071115","body":"### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/description/)\n### 思路\n用`list`来维护关键字的新旧, `map`来记录关键字的键值对  \n#### 小技巧: 由于put时也会对元素新旧产生影响, 可以在put时调用get\n### 代码 (Java)  \n```java\nclass LRUCache {\n\n    private HashMap<Integer, Integer> map;\n    private ArrayList<Integer> list;\n    private int max;\n\n    public LRUCache(int capacity) {\n        max = capacity;\n        map = new HashMap<>();\n        list = new ArrayList<>();\n    }\n    \n    public int get(int key) {\n        if (map.containsKey(key)) {\n            for (int i = 0; i < list.size(); i++) {\n                if (list.get(i) == key) {\n                    list.remove(i);\n                    list.add(key);\n                    break;\n                }\n            }\n            return map.get(key);\n        }\n        else return -1;\n    }\n    \n    public void put(int key, int value) {\n        if (this.get(key) == -1) {\n            if (list.size() == max) {\n                int rm = list.get(0);\n                list.remove(0);\n                map.remove(rm);\n            }\n            list.add(key);\n        }\n        \n        map.put(key, value);\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445278525","body":"### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\n### 思路\nDFS\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr) return 0;\n        return 1 + max(maxDepth(root->left), maxDepth(root->right));\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(height)\n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446329116","body":"### [100. 相同的树](https://leetcode.cn/problems/same-tree/)\n### 思路\nDFS\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr) return true;\n        else if (p == nullptr || q == nullptr) return false;\n        else if (p->val != q->val) return false;\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(min(m,n)) (m, n为树的节点数)\n- 空间复杂度：O(min(m,n))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448240526","body":"### [129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)\n### 思路 DFS\n* 递归三部曲:\n    1. 终止条件 : 已经到达叶子节点 (左右子树为空)\n    2. 返回值 : 本题不用返回, 全局变量`ans`加上当前`cur`即可\n    3. 本层处理问题 : 更新`cur`(cur * 10 + 左/右子树的值)\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int ans;\n    void help(TreeNode *root, int cur) {\n        if (root->left == nullptr && root->right == nullptr) {\n            ans += cur;\n        } else {\n            if (root->left != nullptr)\n                help(root->left, cur * 10 + root->left->val);\n            if (root->right != nullptr)\n                help(root->right, cur * 10 + root->right->val);\n        }\n\n    }\n    int sumNumbers(TreeNode* root) {\n        if (root == nullptr) return 0;\n\n        help(root, root->val);\n\n        return ans;\n    }\n        \n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(height)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450228953","body":"层序遍历即可\n```cpp\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> q;\n        int ans;\n        q.push(root);\n        while (!q.empty()) {\n            ans = q.front()->val;\n            int s = q.size();\n            for (int i = 0; i < s; i++) {\n                TreeNode* cur = q.front();\n                q.pop();\n                if (cur->left) q.push(cur->left);\n                if (cur->right) q.push(cur->right);\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451680931","body":"```cpp\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        if (!root) return \"#_\";\n        string ans = to_string(root->val) + \"_\";\n        ans += serialize(root->left);\n        ans += serialize(root->right);\n        return ans;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        stringstream ss(data);\n        string cur;\n        queue<string> queue;\n        while (getline(ss, cur, '_')) \n            queue.push(cur);\n        \n        return preOrd(queue);\n    }\n\n    TreeNode* preOrd(queue<string> &q) {\n        string val = q.front();\n        q.pop();\n        if (val == \"#\") return NULL;\n        auto root = new TreeNode(stoi(val));\n        root->left = preOrd(q);\n        root->right = preOrd(q);\n        return root;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453700830","body":"```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n\n    typedef map<int, multiset<pair<int, int>>> MAP;\n\n    void dfs(int x, int y, TreeNode* root, MAP &mp) {\n        if (!root) return ;\n        mp[y].insert({x, root->val});\n        dfs(x + 1, y - 1, root->left, mp);\n        dfs(x + 1, y + 1, root->right, mp);\n    }\n\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        MAP mp;\n        dfs(0, 0, root, mp);\n        vector<vector<int>> ans;\n        for (auto &[a, b] : mp) {\n            vector<int> temp;\n            for (auto &e : b) {\n                temp.push_back(e.second);\n            }\n            ans.push_back(temp);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454751804","body":"### [1. 两数之和](https://leetcode.cn/problems/two-sum/)\n### 思路\nhash表, 键值对中键为`nums[i]`, 值为`i`, 如果`target - nums[i]`存在就返回 \n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> mp;\n        for (int i = 0; i < nums.size(); i++) {\n            auto iter = mp.find(target - nums[i]);\n            if (iter != mp.end()) {\n                return {iter->second, i};\n            }\n            mp[nums[i]] = i;\n        }\n        return {};\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455001309","body":"```cpp\nclass Solution {\npublic:\n    typedef pair<int, int> PII;\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> mp;\n        for (int elem : nums) mp[elem]++;\n\n        priority_queue<PII, vector<PII>, greater<PII>> q;\n        for (auto &[a, b] : mp) {\n            if (q.size() < k) {\n                q.push(make_pair(b, a));\n            } else {\n                if (b > q.top().first) {\n                    q.pop();\n                    q.push(make_pair(b, a));\n                }\n            }\n        }\n\n        vector<int> ans;\n        while (q.size()) {\n            ans.push_back(q.top().second);\n            q.pop();\n        }\n\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456237157","body":"```cpp\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int ans = 0;\n        for (int i = 0; i < points.size(); i++) {\n            unordered_map<int, int> mp;\n            for (int j = 0; j < points.size(); j++) {\n                if (j == i) continue;\n                int x = points[i][0] - points[j][0];\n                int y = points[i][1] - points[j][1];\n                int dist = x * x + y * y;\n                mp[dist]++;\n            }\n            for (auto [dist, cnt] : mp) {\n                ans += cnt * (cnt - 1);\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1464955796","body":"```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int ans = 0;\n        unordered_map<char, int> mp;\n        for (int l = 0, r = 0; r < s.size(); r++) {\n            char right = s[r], left = s[l];\n            mp[right]++;\n            while (mp[right] > 1) {\n                mp[left]--;\n                left = s[++l];\n            }\n            ans = max(ans, r - l + 1);\n        }\n        return ans;\n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460316212","body":"```cpp\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        unordered_map<string, int> mp;\n        for (string s : words) mp[s]++;\n        int n = s.size(), m = words.size(), wLen = words[0].size();\n        vector<int> ans;\n        for (int i = 0; i < n - m * wLen + 1; i++) {\n            unordered_map<string, int> temp;\n            int j = 0;\n            while (j < m) {\n                string sub = s.substr(i + j * wLen, wLen);\n                temp[sub]++;\n                if (mp.count(sub) == 0) break;\n                if (temp[sub] > mp[sub]) break;\n                j++;\n            }\n            if (j == m) ans.push_back(i);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461530707","body":"同余定理\n```cpp\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int sum = 0, ans = 0;\n        unordered_map<int, int> mp;\n        for (int num : nums) {\n            sum += num;\n            mp[(sum % k + k) % k] ++;\n        }\n\n        for (auto &[k, v] : mp) {\n            if (k == 0) ans += v;\n            ans += v * (v - 1) / 2;\n        }\n\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463780568","body":"```cpp\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* a = head, *b = a;\n        while (b != nullptr && b->next != nullptr) {\n            b = b->next->next;\n            a = a->next;\n        }\n        return a;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464919709","body":"```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if (nums.size() == 1) return 1;\n        int i = 0, j = 1;\n        while (j < nums.size()) {\n            if (nums[i] != nums[j]) nums[++i] = nums[j++];\n            else {\n                while (j < nums.size() && nums[j] == nums[i]) j++;\n            }\n        }\n        return i + 1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465233311","body":"```cpp\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l = 0, r = nums.size() - 1;\n        while (l < r) {\n            int mid = (l + r + 1) >> 1;\n            if (nums[mid] <= target) l = mid;\n            else r = mid - 1;\n        }\n        return nums[l] >= target ? l : l + 1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466345603","body":"```cpp\nclass Solution {\n\nprivate:\n    class MyQueue {\n        public:\n        deque<int> q;\n        void push(int val) {\n            while (!q.empty() && q.back() < val) \n                q.pop_back();\n            q.push_back(val);\n        }\n        void pop(int val) {\n            if (!q.empty() && q.front() == val) \n                q.pop_front();\n        }\n        int front() {\n            return q.front();\n        }\n    };\n\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        MyQueue q;\n        vector<int> ans;\n        for (int i = 0; i < k; i++) {\n            q.push(nums[i]);\n        }\n        ans.push_back(q.front());\n        for (int i = k; i < nums.size(); i++) {\n            q.pop(nums[i - k]);\n            q.push(nums[i]);\n            ans.push_back(q.front());\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468249127","body":"```cpp\nclass Solution {\npublic:\n    int a[1001];\n    int findJudge(int n, vector<vector<int>>& trust) {\n        for (vector<int> t : trust) {\n            a[t[0]]--;\n            a[t[1]]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            if (a[i] == n - 1) return i;\n        }\n        return -1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1470239555","body":"```cpp\nclass Solution {\npublic:\n    int p[4010];\n    int find(int x) {\n        if (p[x] != x) p[x] = find(p[x]);\n        return p[x];\n    }\n\n    void union_(int i, int j) {\n        p[find(i)] = p[find(j)];\n    }\n\n    bool connected(int i, int j) {\n        return find(i) == find(j);\n    }\n    \n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        for (int i = 1; i <= 2 * n; i++) p[i] = i;\n        for (vector<int> dis : dislikes) {\n            int a = dis[0], b = dis[1];\n            if (connected(a, b)) return false;\n            union_(a, b + n);\n            union_(b, a + n);\n        }\n        return true;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1472142490","body":"```cpp\nclass Solution {\npublic:\n    vector<int> topSort(vector<int> &deg, vector<vector<int>> &graph, vector<int> &items) {\n        queue<int> q;\n        for (auto item : items) {\n            if (deg[item] == 0) q.push(item);\n        }\n        vector<int> ret;\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            ret.push_back(u);\n            for (auto &v : graph[u]) {\n                if (--deg[v] == 0) q.push(v);\n            }\n        }\n        return ret.size() == items.size() ? ret : vector<int> {};\n    }\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        vector<vector<int>> groupItem(n + m);\n\n        vector<vector<int>> groupGraph(n + m);\n        vector<vector<int>> itemGraph(n);\n\n        vector<int> groupDegree(n + m, 0);\n        vector<int> itemDegree(n, 0);\n\n        vector<int> id;\n        for (int i = 0; i < n + m; i++) {\n            id.push_back(i);\n        }\n\n        int leftId = m;\n        for (int i = 0; i < n; i++) {\n            if (group[i] == -1) {\n                group[i] = leftId;\n                leftId += 1;\n            }\n            groupItem[group[i]].push_back(i);\n        }\n\n        for (int i = 0; i < n; ++i) {\n            int curGroupId = group[i];\n            for (auto& item: beforeItems[i]) {\n\n                int beforeGroupId = group[item];\n                if (beforeGroupId == curGroupId) {\n                    itemDegree[i] += 1;\n                    itemGraph[item].push_back(i);   \n                } else {\n                    groupDegree[curGroupId] += 1;\n                    groupGraph[beforeGroupId].push_back(curGroupId);\n                }\n            }\n        }\n\n        // 组间拓扑关系排序\n        vector<int> groupTopSort = topSort(groupDegree, groupGraph, id); \n        if (groupTopSort.size() == 0) {\n            return vector<int>{};\n        } \n        vector<int> ans;\n\n        // 组内拓扑关系排序\n        for (auto& curGroupId: groupTopSort) {\n            int size = groupItem[curGroupId].size();\n            if (size == 0) {\n                continue;\n            }\n            //按组的topo序逐个进行内部排序\n            vector<int> res = topSort(itemDegree, itemGraph, groupItem[curGroupId]);\n            if (res.size() == 0) {\n                return vector<int>{};\n            }\n            for (auto& item: res) {\n                ans.push_back(item);\n            }\n        }\n        return ans;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473243853","body":"```cpp\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int x = 0, y = 0;\n        for (char c : moves) {\n            if (c == 'U') y += 1;\n            else if (c == 'D') y -= 1;\n            else if (c == 'L') x -= 1;\n            else if (c == 'R') x += 1;\n        }\n        return x == 0 && y == 0;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474874153","body":"```cpp\nclass Solution {\npublic:\n    typedef pair<int, int> PII;\n\n    static bool cmp(vector<int> a, vector<int> b) {\n        if (a[0] == b[0]) return a[1] < b[1];\n        return a[0] < b[0];\n    }\n\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        map<PII, int> mp;\n        vector<int> ans;\n        for (int i = 0; i < tasks.size(); i++) \n            mp[make_pair(tasks[i][1], tasks[i][0])] = i;\n        sort(tasks.begin(), tasks.end(), cmp);\n\n        priority_queue<PII, vector<PII>, greater<PII>> q;\n        \n        q.push(make_pair(tasks[0][1], tasks[0][0]));\n        int idx = 1;\n        long long cur = tasks[0][0];\n        \n        while (!q.empty()) {\n            ans.push_back(mp[q.top()]);\n            cur += q.top().first;\n            q.pop();\n            while (idx < tasks.size() && tasks[idx][0] <= cur) {\n                q.push(make_pair(tasks[idx][1], tasks[idx][0]));\n                idx++;\n            }\n        }\n\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475260664","body":"```cpp\nclass Solution {\npublic:\n    int numberOfRounds(string loginTime, string logoutTime) {\n        int t1 = stoi(loginTime.substr(0, 2)) * 60 + stoi(loginTime.substr(3, 5));\n        int t2 = stoi(logoutTime.substr(0, 2)) * 60 + stoi(logoutTime.substr(3, 5));\n        if (t1 > t2) t2 += 24 * 60;\n        t2 = t2 / 15 * 15;\n        return (t2 - t1) / 15;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475778664","body":"枚举\n```cpp\nclass Solution {\npublic:\n    int minCharacters(string a, string b) {\n        vector<int> va(26, 0);\n        vector<int> vb(26, 0);\n        for (char c : a) va[c - 'a']++;\n        for (char c : b) vb[c - 'a']++;\n        int n = a.size(), m = b.size(), ans = m + n;\n        // 3\n        for (int i = 0; i < 26; i++) \n            ans = min(ans, n + m - va[i] - vb[i]);\n        for (int i = 1; i < 26; i++) {\n            va[i] += va[i - 1];\n            vb[i] += vb[i - 1];\n        }\n        for (int i = 0; i < 25; i++) {\n            // 1\n            ans = min(ans, va[i] + m - vb[i]);\n            // 2\n            ans = min(ans, n + vb[i] - va[i]);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1478024929","body":"```cpp\nclass Solution {\npublic:\n\n    void merge(vector<int> &nums, vector<int> &temp, int l, int r) {\n        if (l >= r) return;\n        int mid = (l + r) >> 1;\n        merge(nums, temp, l, mid); merge(nums, temp, mid + 1, r);\n        int i = l, j = mid + 1, k = 0;\n        while (i <= mid && j <= r) {\n            if (nums[i] <= nums[j]) temp[k++] = nums[i++];\n            else temp[k++] = nums[j++];\n        }\n        while (i <= mid) temp[k++] = nums[i++];\n        while (j <= r) temp[k++] = nums[j++];\n        for (i = l, k = 0; i <= r; i++, k++) nums[i] = temp[k];\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        vector<int> temp(nums.size());\n        merge(nums, temp, 0, nums.size() - 1);\n        return nums;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1478890205","body":"```cpp\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x <= 1) return x;\n        int l = 0, r = x;\n        while (l < r) {\n            int mid = (l + r) >> 1;\n            if (mid >= x / mid) r = mid;\n            else l = mid + 1;\n        }\n        return l > x / l ? l - 1 : l;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480423958","body":"```cpp\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        long l = 1, r = n;\n        while (l < r ) {\n            long mid = (l + r) >> 1;\n            if (isBadVersion(mid)) r = mid;\n            else l = mid + 1;\n        }\n        return l;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1484148159","body":"···cpp\ntypedef long long LL;\nclass Solution {\npublic:\n\n    LL add(vector<int> &nums, int l, int r, int mid) {\n        int i = l, j = mid + 1;\n        LL ret = 0;\n        while (i <= mid && j <= r) {\n            if (nums[i] > (LL)nums[j] * 2) {\n                ret += mid - i + 1;\n                j++;\n            } else {\n                i++;\n            }\n        }\n        return ret;\n    }\n\n    LL merge(vector<int> &nums, vector<int> &temp, int l, int r) {\n        if (l >= r) return 0;\n        int mid = (l + r) >> 1;\n        LL ret = merge(nums, temp, l, mid) + merge(nums, temp, mid + 1, r) + add(nums, l, r, mid);\n        int i = l, j = mid + 1, k = 0;\n        while (i <= mid && j <= r) {\n            if (nums[i] <= nums[j]) temp[k++] = nums[i++];\n            else temp[k++] = nums[j++];\n        }\n        while(i <= mid) temp[k++] = nums[i++];\n        while(j <= r) temp[k++] = nums[j++];\n        for (i = l, k = 0; i <= r; i++, k++) nums[i] = temp[k];\n        return ret;\n    }\n\n    int reversePairs(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> temp(n);\n        return merge(nums, temp, 0, n - 1);\n    }\n};\n···","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483849148","body":"```cpp\nclass Solution {\npublic:\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\n        int a = 0, b = 0, ans = 0, n = houses.size(), m = heaters.size();\n        sort(begin(houses), end(houses));\n        sort(begin(heaters), end(heaters));\n        while(a < n){\n            while(b + 1 < m && (houses[a] << 1) >= heaters[b] + heaters[b+1]) ++b;\n            ans = max(ans, abs(houses[a++] - heaters[b]));\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1485376416","body":"```cpp\nclass Solution {\npublic:\n\n    int check(vector<int> &nums, int x) {\n        int count = 0;\n        for (int i = 0, j = 1; i < nums.size(); i++) {\n            while (j < nums.size() && nums[j] - nums[i] <= x) j++;\n            count += j - i - 1;\n        }\n        return count;\n    }\n\n    int smallestDistancePair(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        int l = 0, r = 1e6 + 10;\n        while (l < r) {\n            int mid = (l + r) >> 1;\n            if (check(nums, mid) >= k) r = mid; \n            else l = mid + 1;\n        }\n        return l;\n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484148629","body":"### [778. 水位上升的泳池中游泳](https://leetcode.cn/problems/swim-in-rising-water/description/)\r\n#### 思路\r\n二分 + dfs\r\n#### 代码 (cpp)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    typedef pair<int, int> PII;\r\n    int dirs[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\r\n    int swimInWater(vector<vector<int>>& grid) {\r\n        int n = grid.size();\r\n        int l = 0, r = n * n;\r\n        while (l < r) {\r\n            int mid = (l + r) >> 1;\r\n            if (dfs(grid, mid)) r = mid;\r\n            else l = mid + 1;\r\n        }\r\n        return l;\r\n    }\r\n\r\n    bool dfs(vector<vector<int>> &grid, int time) {\r\n        if (time < grid[0][0]) return false;\r\n        int n = grid.size();\r\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\r\n        queue<PII> que;\r\n        que.push({0, 0});\r\n        vis[0][0] = true;\r\n        while (!que.empty()) {\r\n            auto [i, j] = que.front();\r\n            que.pop();\r\n            for (auto dir : dirs) {\r\n                int x = i + dir[0];\r\n                int y = j + dir[1];\r\n                if (x < 0 || y < 0 || x >= n || y >= n) continue;\r\n                if (grid[x][y] > time || vis[x][y] == true) continue;\r\n                vis[x][y] = true;\r\n                que.push({x, y});\r\n            }\r\n        }\r\n        return vis[n - 1][n - 1];\r\n    }\r\n};\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(n^2 * logn)\r\n- 空间复杂度：O(n^2)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486268504","body":"```cpp\nclass Solution {\npublic:\n\n    bool check(char c) {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    }\n\n    int maxVowels(string s, int k) {\n        int cur = 0, ans = 0;\n        queue<char> q;\n        for (char c : s) {\n            q.push(c);\n            if (q.size() > k) {\n                char del = q.front();\n                q.pop();\n                if (check(del)) cur--;\n            }\n            if (check(c)) cur++;\n            ans = max(ans, cur);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488867130","body":"```cpp\nclass Solution {\npublic:\n    double new21Game(int N, int K, int W) {\n        if (K == 0) return 1.0;\n\n        vector<double> f(N + 1, 0), s(N + 1, 0);\n        f[0] = s[0] = 1;\n\n        for (int i = 1; i <= N; i++) {\n            int l = max(0, i - W), r = min(K - 1, i - 1);\n\n            if (l <= r) {\n                if (l == 0) f[i] = s[r] / W;\n                else f[i] = (s[r] - s[l - 1]) / W;\n            }\n\n            s[i] = s[i - 1] + f[i];\n        }\n\n        return s[N] - s[K - 1];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1490354744","body":"```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> findAnagrams(string s, string p) {\r\n        int m = s.size(), n = p.size();\r\n        vector<int> ans;\r\n        if (n > m) return ans;\r\n        vector<int> ss(26, 0);\r\n        vector<int> pp(26, 0);\r\n        for (int i = 0; i < n; i++) {\r\n            ss[s[i] - 'a']++;\r\n            pp[p[i] - 'a']++;\r\n        }\r\n        if(ss == pp) ans.push_back(0);\r\n        for (int i = n; i < m; i++) {\r\n            ss[s[i - n] - 'a']--;\r\n            ss[s[i] - 'a']++;\r\n            if (ss == pp) ans.push_back(i - n + 1);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1492120372","body":"```cpp\nclass Solution {\npublic:\n    string minWindow(string s, string t) {\n        unordered_map<char, int> ms, mt;\n        for (char x : t) {\n            mt[x]++;\n        }\n        string ans;\n        for (int i = 0, j = 0, c = 0; i < s.size(); i++) {\n            ms[s[i]]++;\n            if (ms[s[i]] <= mt[s[i]]) c++;\n            while (j < i && ms[s[j]] > mt[s[j]]) ms[s[j++]]--;\n            if (c == t.size() && (ans.empty() || i - j + 1 < ans.size())) {\n                ans = s.substr(j, i - j + 1);\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1493011477","body":"```cpp\nclass Solution {\npublic:\n    int minOperations(vector<int>& nums, int x) {\n        int target = 0;\n        for (int num : nums) target += num;\n        target -= x;\n\n        int sum = 0, len = -1;\n        for (int l = 0, r = 0; r < nums.size(); r++) {\n            sum += nums[r];\n            while (l <= r && sum > target) sum -= nums[l++];\n            if (sum == target) len = max(len, r - l + 1);\n        }\n\n        return len == -1 ? -1 : nums.size() - len;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493367062","body":"```cpp\nclass Solution {\npublic:\n\n    int count(int n) {\n        int ret = 0;\n        while (n) {\n            n = n & (n - 1);\n            ret++;\n        }\n        return ret;\n    }\n\n    vector<string> readBinaryWatch(int turnedOn) {\n        vector<string> ans;\n        for (int i = 0; i < 12; i++) \n            for (int j = 0; j < 60; j++) {\n                if (count(i) + count(j) == turnedOn) {\n                    string h = to_string(i);\n                    string min = to_string(j);\n                    string temp = h + \":\" + (j < 10 ? \"0\" + min : min);\n                    ans.push_back(temp);\n                }\n            }\n\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494514469","body":"```cpp\nconst int N = 20;\nclass Solution {\npublic:\n    bool row[N], col[N], dg[N], udg[N];\n    int n, ans;\n\n    void dfs(int x, int y, int k) {\n        if (k > n) return ;\n        if (y == n) y = 0, x ++;\n        if (x == n) {\n            if (k == n) ans++;\n            return ;\n        }\n        dfs(x, y + 1, k);\n        if (!row[x] && !col[y] && !dg[x + y] && !udg[x - y + n]) {\n            row[x] = col[y] = dg[x + y] = udg[x - y + n] = true;\n            dfs(x, y + 1, k + 1);\n            row[x] = col[y] = dg[x + y] = udg[x - y + n] = false;\n        }\n    }\n\n    int totalNQueens(int n) {\n        this->n = n;\n        dfs(0, 0, 0);\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495582240","body":"```cpp\nclass Solution {\npublic:\n    int dirs[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n    int row, col, ans;\n\n    int dfs(int i, int j, vector<vector<int>>& grid, vector<vector<bool>>& vis) {\n        if (i < 0 || j < 0 || i == row || j == col || vis[i][j]) return 0;\n        int cur = 0;\n        if (grid[i][j] == 1) {\n            vis[i][j] = true;\n            cur ++;\n            for (auto dir : dirs) {\n                int x = i + dir[0];\n                int y = j + dir[1];\n                cur += dfs(x, y, grid, vis);\n            }\n        }\n        return cur;\n    }\n\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        row = grid.size(), col = grid[0].size();\n        vector<vector<bool>> vis(row, vector<bool>(col, false));\n        for (int i = 0; i < row; i++) {\n            for (int j = 0; j < col; j++) {\n                if (grid[i][j] == 1 && !vis[i][j]) {\n                    ans = max(ans, dfs(i, j, grid, vis));\n                }\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497537038","body":"```cpp\nclass Solution {\npublic:\n    int maxDistance(vector<vector<int>>& grid) {\n        const int dx[4] = {0, 1, 0, -1};\n        const int dy[4] = {1, 0, -1, 0};\n\n        int n = grid.size(), m = grid[0].size();\n        queue<pair<int, int>> q;\n        vector<vector<int>> dis(n, vector(m, INT_MAX));\n\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                if (grid[i][j] == 1) {\n                    q.push(make_pair(i, j));\n                    dis[i][j] = 0;\n                }\n\n        while (!q.empty()) {\n            auto u = q.front();\n            q.pop();\n\n            for (int i = 0; i < 4; i++) {\n                int x = u.first + dx[i], y = u.second + dy[i];\n                if (x < 0 || x >= n || y < 0 || y >= m)\n                    continue;\n\n                if (dis[x][y] > dis[u.first][u.second] + 1) {\n                    dis[x][y] = dis[u.first][u.second] + 1;\n                    q.push(make_pair(x, y));\n                }\n            }\n        }\n\n        int ans = -1;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                if (grid[i][j] == 0 && dis[i][j] < INT_MAX)\n                    ans = max(ans, dis[i][j]);\n\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1499268206","body":"```cpp\nclass Solution {\npublic:\n    int maxCandies(vector<int>& status, vector<int>& candies, vector<vector<int>>& keys, vector<vector<int>>& containedBoxes, vector<int>& initialBoxes) {\n        int res = 0;\n        unordered_set<int> boxes(initialBoxes.begin(), initialBoxes.end());\n\n        while (1) {\n            unordered_set<int> new_boxes;\n            unordered_set<int> opened_boxes;\n            for (int x : boxes)\n                if (status[x]) {\n                    opened_boxes.insert(x);\n                    res += candies[x];\n                    for (int k : keys[x])\n                        status[k] = true;\n\n                    for (int b : containedBoxes[x])\n                        new_boxes.insert(b);\n                }\n\n            if (opened_boxes.empty())\n                break;\n\n            for (int b : opened_boxes)\n                boxes.erase(b);\n\n            for (int b : new_boxes)\n                boxes.insert(b);\n        }\n\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1500409797","body":"### [987. 二叉树的垂序遍历](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/description/)\n#### 思路\n本题可以理解为以根节点为(0, 0), 向左为(x + 1, y - 1), 向右为(x + 1, y + 1)  \ny值越小(列越靠前), x越小(层考前)的先入列  \n使用 map + multiset, y权重大于x, 以y值映射键值对(x, val)  \n通过前序遍历整颗树\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n\n    typedef map<int, multiset<pair<int, int>>> MAP;\n\n    void trav(int x, int y, TreeNode* root, MAP &mp) {\n        if (!root) return ;\n        mp[y].insert({x, root->val});\n        trav(x + 1, y - 1, root->left, mp);\n        trav(x + 1, y + 1, root->right, mp);\n    }\n\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        MAP mp;\n        trav(0, 0, root, mp);\n        vector<vector<int>> ans;\n        for (auto &[a, b] : mp) {\n            vector<int> temp;\n            for (auto &e : b) {\n                temp.push_back(e.second);\n            }\n            ans.push_back(temp);\n        }\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500918797","body":"```cpp\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n = cost.size();\n        vector<int> dp(n);\n        dp[0] = cost[0], dp[1] = cost[1];\n        for (int i = 2; i < n; i++) {\n            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];\n        }\n        return min(dp[n - 1], dp[n - 2]);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501151684","body":"```cpp\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 1) return nums[0];\n        vector<int> dp(n + 1);\n        dp[1] = nums[0], dp[2] = nums[1];\n        for (int i = 2; i <= n; i++) {\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1]);\n        }\n        return max(dp[n], dp[n - 1]);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501969668","body":"```java\nclass Solution {\n    public int findNumberOfLIS(int[] nums) {\n        int n = nums.length;\n        int[] f = new int[n], g = new int[n];\n        int max = 1;\n        for (int i = 0; i < n; i++) {\n            f[i] = g[i] = 1;\n            for (int j = 0; j < i; j++) {\n                if (nums[j] < nums[i]) {\n                    if (f[i] < f[j] + 1) {\n                        f[i] = f[j] + 1;\n                        g[i] = g[j];\n                    } else if (f[i] == f[j] + 1) {\n                        g[i] += g[j];\n                    }\n                }\n            }\n            max = Math.max(max, f[i]);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (f[i] == max) ans += g[i];\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1503583315","body":"```cpp\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m = text1.size(), n = text2.size();\n        vector<vector<int>> dp(m + 1, vector(n + 1, 0));\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (text1[i - 1] == text2[j - 1]) \n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                else \n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n        return dp[m][n];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1505113833","body":"```cpp\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m, vector(n, 0));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || j == 0) {\n                    dp[i][j] = 1;\n                } else {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1507179106","body":"```cpp\nconst int dirs[8][2] = {{-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}, {1, -2}, {2, -1}, {1, 2}, {2, 1}};\nclass Solution {\npublic:\n    int n;\n    double knightProbability(int n, int k, int row, int col) {\n        this->n = n;\n        vector<vector<vector<double>>> vis(n, vector<vector<double>>(n, vector<double>(k + 1)));\n        return dfs(row, col, k, vis);\n    }\n\n    double dfs(int x, int y, int k, vector<vector<vector<double>>> &vis) {\n        if (x < 0 || y < 0 || x >= n || y >= n) return 0;\n        if (k == 0) return 1;\n        if (vis[x][y][k]) return vis[x][y][k];  // 剪枝\n        double ret = 0;\n        for (auto dir : dirs) {\n            int i = x + dir[0];\n            int j = y + dir[1];\n            ret += dfs(i, j, k - 1, vis) / 8.0;\n        }\n        vis[x][y][k] = ret;\n        return ret;\n    }\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1508828190","body":"```cpp\nclass Solution {\npublic:\n    bool canIWin(int M, int T) {\n        const int sum = M * (M + 1) / 2;\n        if (sum < T) return false;\n        if (T == 0) return true;\n        m_ = vector<char>(1 << M, 0);\n        return dfs(M, T, 0);\n    }\n    \nprivate:\n    vector<char> m_; // 0: unknown, 1: won, -1: lost\n    bool dfs(int M, int T, int state) {\n        if (T <= 0) return false;\n        if (m_[state]) return m_[state] == 1;\n        for (int i = 0; i < M; ++i) {\n            if (state & (1 << i)) continue; // number i used      \n            // The next player can not win, current player wins\n            if (!dfs(M, T - (i + 1), state | (1 << i))) \n                //return m_[state] = 1;\n                return true;\n        }\n        // Current player loses.\n        m_[state] = -1;\n        return false;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509754971","body":"```cpp\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int len = nums.size();\n        int sum = 0;\n        for (int e : nums) sum += e;\n        if (sum & 1 == 1) return false;\n        int target = sum >> 1;\n        vector<vector<bool>> dp(len, vector<bool>(target + 1, false));\n        if (nums[0] <= target) dp[0][nums[0]] = true;\n        for (int i = 1; i < len; i++) {\n            for (int j = 0; j < target + 1; j++) {\n                dp[i][j] = dp[i - 1][j];\n                if (nums[i] == j) {\n                    dp[i][j] = true;\n                    continue;\n                } else if (nums[i] < j) {\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];\n                }\n            }\n        }\n        return dp[len - 1][target];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510408875","body":"```cpp\nclass Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int S) {\n        int n = nums.size();\n        int sum = accumulate(nums.begin(), nums.end(), 0);\n\n        if (!(-sum <= S && S <= sum))\n            return 0;\n\n        vector<vector<int>> f(n + 1, vector<int>(2 * sum + 1, 0));\n        f[0][0 + sum] = 1;\n\n        for (int i = 1; i <= n; i++)\n            for (int j = -sum; j <= sum; j++) {\n                if (-sum <= j - nums[i - 1])\n                    f[i][j + sum] += f[i - 1][j - nums[i - 1] + sum];\n                if (j + nums[i - 1] <= sum)\n                    f[i][j + sum] += f[i - 1][j + nums[i - 1] + sum];\n            }\n\n        return f[n][S + sum];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511514431","body":"```cpp\nclass Solution {\npublic:\n    int INF = 0x3f3f3f3f;\n    int coinChange(vector<int>& coins, int amount) {\n        int n = coins.size();\n        vector<int> f(amount + 1);\n        for (int i = 1; i <= amount; i++) f[i] = INF;\n        for (int i = 1; i <= n; i++) {\n            int val = coins[i - 1];\n            for (int j = val; j <= amount; j++) {\n                f[j] = min(f[j], f[j - val] + 1);\n            }\n        }\n        return f[amount] == INF ? -1 : f[amount];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1513367639","body":"```cpp\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        vector<int> vc(amount + 1);\n        vc[0] = 1;\n        for (int coin : coins) {\n            for (int i = coin; i <= amount; i++){\n                vc[i] += vc[i - coin];\n            }\n        }\n        return vc[amount];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514912493","body":"```cpp\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        int ans = 0;\n        for (int i = 0; i < s.size(); i++) {\n            if (ans < g.size() && g[ans] <= s[i]) ans++;\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516320286","body":"```cpp\nclass Solution {\npublic:\n    static bool cmp (const vector<int>& a, const vector<int>& b) {\n        return a[1] < b[1];\n    }\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        if (intervals.size() == 0) return 0;\n        sort(intervals.begin(), intervals.end(), cmp);\n        int count = 1;\n        int end = intervals[0][1];\n        for (int i = 1; i < intervals.size(); i++) {\n            if (end <= intervals[i][0]) {\n                end = intervals[i][1];\n                count++;\n            }\n        }\n        return intervals.size() - count;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517974844","body":"```cpp\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 1) return true;\n        int mx = nums[0]; // 当前可到达最远距离\n        for (int i = 0; i < n - 1; i++) {\n            if (mx <= i && nums[i] == 0) return false;\n            mx = max(mx, i + nums[i]);\n        }\n        return true;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518682221","body":"\nclass Solution {\npublic:\n    int numTrees(int n) {\n         vector<int> dp(n + 1);\n         dp[0] = 1;\n         for(int i = 1; i <= n; i ++)\n            for(int j = i; j >= 1; j --) dp[i] += (dp[j - 1] * dp[i - j]);\n        return dp[n];\n    }\n};\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519094236","body":"```cpp\nclass Solution {\npublic:\n    struct cmp { //结构体 cmp 重载 ()函数\n        bool operator()(ListNode *a, ListNode *b) {\n            return a->val > b->val; // 小根堆\n        }\n    };\n\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        priority_queue<ListNode*, vector<ListNode*>, cmp> q;\n\n        for (ListNode *list : lists) \n            if (list != nullptr)\n                q.push(list);\n\n        ListNode *dummy = new ListNode(0), *tail = dummy;\n        while (!q.empty()) {\n            ListNode *cur = q.top(); q.pop();\n            tail->next = cur;\n            tail = tail->next;\n            if (cur->next != nullptr) //if (cur->next)\n                q.push(cur->next);\n        }\n        \n        return dummy->next;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1520292231","body":"```cpp\nclass Solution {\npublic:\n    unordered_map<int,vector<int>> mp;\n    vector<int> beautifulArray(int n) {\n        vector<int> ans;\n        if(n == 1){\n            ans.push_back(1);\n            return ans;\n        }\n        if(mp.count(n)) return mp[n];\n        \n        int odd = (n + 1) / 2;\n        int even = n / 2;\n        vector<int> left = beautifulArray(odd);\n        vector<int> right = beautifulArray(even);\n    \n        for(auto &val : left){\n            ans.push_back(val * 2 - 1);\n        }\n\n        for(auto &val : right){\n            ans.push_back(val * 2);\n        }\n        mp[n] = ans;\n        return ans;\n    }\n   \n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1522001379","body":"```cpp\nclass Solution {\npublic:\n    vector<int> singleNumber(vector<int>& nums) {\n        vector<int> ans(2, 0);\n        int x_or = 0;\n        for (int num : nums) x_or ^= num;\n        \n        int f = 1;\n        while ((f & x_or) == 0) f <<= 1;\n\n        for (int num : nums) {\n            if (num & f) ans[0] ^= num;\n            else ans[1] ^= num;\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1523568555","body":"```cpp\nclass Solution {\npublic:\n    vector<vector<int>> ans;\n    vector<vector<int>> subsets(vector<int>& nums) {\n        int n  = nums.size();\n        vector<int> t;\n        for (int i = 0; i < (1 << n); i++) {\n            t.clear();\n            for (int j = 0; j < n; j++) {\n                if (i & (1 << j)) t.push_back(nums[j]);\n            }\n            ans.push_back(t);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1525886318","body":"```cpp\nclass Trie {\npublic:\n    /** Initialize your data structure here. */\n    struct Node\n    {\n        bool is_end;\n        Node *next[26];\n        Node()\n        {\n            is_end = false;\n            for (int i = 0; i < 26; i ++ )\n                next[i] = 0;\n        }\n    };\n\n    Node *root;\n    Trie() {\n        root = new Node();\n    }\n\n    /** Inserts a word into the trie. */\n    void insert(string word) {\n        Node *p = root;\n        for (char c : word)\n        {\n            int son = c - 'a';\n            if (!p->next[son]) p->next[son] = new Node();\n            p = p->next[son];\n        }\n        p->is_end = true;\n    }\n\n    /** Returns if the word is in the trie. */\n    bool search(string word) {\n        Node *p = root;\n        for (char c : word)\n        {\n            if (p->next[c - 'a']) p = p->next[c - 'a'];\n            else\n                return false;\n        }\n        return p->is_end;\n    }\n\n    /** Returns if there is any word in the trie that starts with the given prefix. */\n    bool startsWith(string prefix) {\n        Node *p = root;\n        for (char c : prefix)\n        {\n            if (p->next[c - 'a']) p = p->next[c - 'a'];\n            else\n                return false;\n        }\n        return true;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1527741721","body":"```cpp\nclass MapSum {\npublic:\n    static const int N = 3010;\n    int son[N][26];\n    int idx;\n    int cnt[N];\n    unordered_map<string, int> M;\n    MapSum() {\n        idx = 0;\n        memset(cnt, 0, sizeof cnt);\n        memset(son, 0, sizeof son);\n    }\n    \n    void insert(string key, int val) {\n        int p = 0;\n        for(int i = 0; i < key.size(); i++){\n            int u = key[i] - 'a';\n            if (!son[p][u]) son[p][u] = ++idx;\n            p = son[p][u];\n            if (M.count(key)) cnt[p] += (val - M[key]);\n            else cnt[p] += val;            \n        }\n        M[key] = val;\n    }\n    \n    int sum(string prefix) {\n        int p = 0;\n        for(int i = 0; i < prefix.size(); i++){\n            int u = prefix[i] - 'a';\n            if (!son[p][u]) return 0;\n            p = son[p][u];\n        }\n        return cnt[p];\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528812783","body":"```cpp\nclass Solution {\npublic:\n    struct Trie{\n         int smallIndex;\n         Trie* next[26];\n         Trie(){ \n             smallIndex=-1;\n             memset(next,0,sizeof(next));\n         }\n    };\n    vector<vector<int>> res;\n    Trie* root=new Trie();\n    void insert(string s,int s_index){\n        Trie*  node=root;\n        for(auto ch:s){\n            if(node->next[ch-'a']==NULL){\n                node->next[ch-'a']=new Trie();\n            }\n            node=node->next[ch-'a'];\n        }\n        node->smallIndex=s_index; \n    }\n\n    void search(string subBig,int index){ \n        Trie* node=root;\n        for(auto ch:subBig){\n            if(node->next[ch-'a']==NULL) return;\n            node=node->next[ch-'a'];\n            if(node->smallIndex!=-1){ \n                res[node->smallIndex].push_back(index);\n            }           \n        }\n    }\n\n\n    vector<vector<int>> multiSearch(string big, vector<string>& smalls) {\n        res.resize(smalls.size());\n        for(int i=0;i<smalls.size();i++){ \n            insert(smalls[i],i);\n        }\n        for(int i=0;i<big.size();i++){ \n            string subBig=big.substr(i);\n            search(subBig,i);\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1529035380","body":"```cpp\nclass Solution {\npublic:\n    int ans, a[210];\n\n    void init(int n) {\n        for (int i = 0; i < n; i++) a[i] = i;\n    }\n\n    int find(int x) {\n        if (x != a[x]) a[x] = a[find(a[x])];\n        return a[x];\n    }\n\n    void connect(int i, int j) {\n        int x = find(i), y = find(j);\n        if (x == y) return;\n        a[x] = y;\n        ans--;\n    }\n\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        int row = isConnected.size();\n        int col = isConnected[0].size();\n        init(row);\n        ans = row;\n        for (int i = 0; i < row; i++) {\n            for (int j = 0; j < col; j++) {\n                if (isConnected[i][j]) connect(i, j);\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1529674074","body":"```cpp\nclass Solution {\npublic:\n    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {\n        int n = graph.size(), m = initial.size();\n        int res = INT_MAX, ans = -1;\n\n        for (int j = 0; j < m; j++) {\n            queue<int> q;\n            vector<bool> vis(n, false);\n            int tot = 0;\n\n            for (int i = 0; i < m; i++)\n                if (initial[i] != initial[j]) {\n                    q.push(initial[i]);\n                    vis[initial[i]] = true;\n                    tot++;\n                }\n\n            while (!q.empty()) {\n                int cur = q.front();\n                q.pop();\n                for (int i = 0; i < n; i++)\n                    if (graph[cur][i] == 1 && !vis[i]) {\n                        vis[i] = true;\n                        q.push(i);\n                        tot++;\n                    }\n            }\n\n            if (res > tot) {\n                res = tot;\n                ans = initial[j];\n            } else if (res == tot && ans > initial[j]) {\n                ans = initial[j];\n            }\n        }\n\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1531704331","body":"```cpp\nconst int N = 1e5 + 10;\nclass Solution {\npublic:\n    int count, a[N];\n\n    void init(int n) {\n        count = n;\n        for (int i = 0; i < n; i++) a[i] = i;\n    }\n\n    int find(int x) {\n        if (a[x] != x) a[x] = a[find(a[x])];\n        return a[x];\n    }\n\n    bool unio(int i, int j) {\n        int x = find(i), y = find(j);\n        if (x == y) return false;\n        a[x] = y;\n        count--;\n        return true;\n    }\n\n    int makeConnected(int n, vector<vector<int>>& connections) {\n        init(n);\n        int cable = 0;\n        for (vector<int> temp : connections) {\n            int i = temp[0], j = temp[1];\n            if (!unio(i, j)) cable++;\n        }\n        count--; // 需要用于连接的线为总个数 - 1\n        return cable < count ? -1 : count;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1533220650","body":"```cpp\nclass Solution {\npublic:\n    TreeNode* pruneTree(TreeNode* root) {\n        if (root == nullptr) return root;\n        root->left = pruneTree(root->left);\n        root->right = pruneTree(root->right);\n        if (root->left == nullptr && root->right == nullptr && root->val == 0) return nullptr;\n        return root;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1534985666","body":"```cpp\nclass Solution {\npublic:\n    void solve(int i, vector<int>& candidates, int sum,\n             vector<int> &ch, int target, vector<vector<int>>& ans) {\n        if (sum == target) {\n            ans.push_back(ch);\n            return;\n        }\n        if (i == candidates.size() || sum > target)\n            return;\n\n        solve(i + 1, candidates, sum, ch, target, ans);\n\n        ch.push_back(candidates[i]);\n        solve(i, candidates, sum + candidates[i], ch, target, ans);\n        ch.pop_back();\n    }\n\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        vector<vector<int>> ans;\n        sort(candidates.begin(), candidates.end());\n        vector<int> ch;\n        solve(0, candidates, 0, ch, target, ans);\n\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1536451947","body":"```cpp\nclass Solution {\npublic:\n    void solve(int i, vector<int>& candidates, int sum,\n             vector<int>& ch, int target, vector<vector<int>>& ans) {\n        if (sum == target) {\n            ans.push_back(ch);\n            return;\n        }\n        if (i == candidates.size() || sum > target)\n            return;\n\n        for (int j = i + 1; j < candidates.size(); j++)\n            if (candidates[j] != candidates[i]) {\n                solve(j, candidates, sum, ch, target, ans);\n                break;\n            }\n\n        ch.push_back(candidates[i]);\n        solve(i + 1, candidates, sum + candidates[i], ch, target, ans);\n        ch.pop_back();\n    }\n\n\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<vector<int>> ans;\n        sort(candidates.begin(), candidates.end());\n        vector<int> ch;\n        solve(0, candidates, 0, ch, target, ans);\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1537163613","body":"```cpp\nclass Solution {\npublic:\n    vector<bool> st;\n    vector<int> path;\n    vector<vector<int>> ans;\n\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        st = vector<bool>(nums.size(), false);\n        path = vector<int>(nums.size());\n        dfs(nums, 0, 0);\n        return ans;\n    }\n\n    void dfs(vector<int>& nums, int u, int start)\n    {\n        if (u == nums.size())\n        {\n            ans.push_back(path);\n            return;\n        }\n\n        for (int i = start; i < nums.size(); i ++ )\n            if (!st[i])\n            {\n                st[i] = true;\n                path[i] = nums[u];\n                if (u + 1 < nums.size() && nums[u + 1] != nums[u])\n                    dfs(nums, u + 1, 0);\n                else\n                    dfs(nums, u + 1, i + 1);\n                st[i] = false;\n            }\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null],"klspta":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bookyue":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429838033","body":"现写的还没以前写的简洁，泪目\n\nOC: O(max(n, logk))  \nSC: O(1)\n\n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new LinkedList<>();\n        int i = num.length - 1;\n        int d = 0;\n        while (i >= 0 || k > 0 || d > 0) {\n            d += (i >= 0 ? num[i] : 0) + k % 10;\n            ans.add(0, d % 10);\n            d /= 10;\n            k /= 10;\n            i--;\n        }\n\n        return ans;\n    }\n```\n\n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new LinkedList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0) {\n            if (i >= 0) k += num[i];\n\n            ans.add(0, k % 10);\n            k /= 10;\n            i--;\n        }\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430652958","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        Arrays.fill(ans, n);\n        for (int i = 0, j = -1; i < n; i++) {\n            if (s.charAt(i) == c) j = i;\n            if (j != -1) ans[i] = i - j;\n        }\n\n        for (int i = n - 1, j = -1; i >= 0; i--) {\n            if (s.charAt(i) == c) j = i;\n            if (j != -1) ans[i] = Math.min(ans[i], j - i);\n        }\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432451072","body":"TC: O(1) for all operations  \nOC: O(n)\n\n```java\nclass CustomStack {\n    private final int[] stack;\n    private final int[] add;\n    private int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        add = new int[maxSize];\n        top = -1;\n    }\n\n    public void push(int x) {\n        if (top == stack.length - 1) return;\n\n        stack[++top] = x;\n    }\n\n    public int pop() {\n        if (top == -1) return -1;\n\n        int ans = stack[top] + add[top];\n        if (top > 0) add[top - 1] += add[top];\n        add[top] = 0;\n        top--;\n\n        return ans;\n    }\n\n    public void increment(int k, int val) {\n        int limit = Math.min(k - 1, top);\n        if (limit >= 0)\n            add[limit] += val;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1433955807","body":"TC: O(n)  \nSC: O(n)\n\n```java\n    public String decodeString(String s) {\n        Queue<Character> queue = new ArrayDeque<>();\n        for (char c : s.toCharArray())\n            queue.offer(c);\n\n        return helper(queue);\n    }\n\n    private String helper(Queue<Character> queue) {\n        StringBuilder sb = new StringBuilder();\n        int num = 0;\n        while (!queue.isEmpty()) {\n            char c = queue.poll();\n            if (Character.isDigit(c)) {\n                num = 10 * num + c - '0';\n            } else if (c == '[') {\n                String sub = helper(queue);\n                sb.append(sub.repeat(num));\n                num = 0;\n            } else if (c == ']') {\n                break;\n            } else {\n                sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435471668","body":"TC: push O(1), pop O(n), peek O(n)  \nOC: O(n)\n\n```java\nclass MyQueue {\n    private final Deque<Integer> in;\n    private final Deque<Integer> out;\n\n    public MyQueue() {\n        in = new ArrayDeque<>();\n        out = new ArrayDeque<>();\n    }\n\n    public void push(int x) {\n        in.push(x);\n    }\n\n    public int pop() {\n        transfer();\n        return out.pop();\n    }\n\n    public int peek() {\n        transfer();\n        return out.peek();\n    }\n\n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n    }\n    \n    private void transfer() {\n        if (!out.isEmpty()) return;\n        \n        while (!in.isEmpty())\n            out.push(in.pop());\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435945243","body":"https://leetcode.com/problems/max-chunks-to-make-sorted-ii/solutions/595713/monotonic-stack-solution-with-detailed-explanation/\n\nTC: O(n)  \nSC: O(n)\n\n```java\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int num : arr) {\n            while (!stack.isEmpty() && stack.peek() > num)\n                stack.pop();\n\n            stack.push(num);\n        }\n\n        return stack.size();\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436175369","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || k == 0) return head;\n\n        int n = 1;\n        var cur = head;\n        while (cur.next != null) {\n            cur = cur.next;\n            n++;\n        }\n\n        k %= n;\n        if (k == 0) return head;\n\n        cur.next = head;\n        k = n - k - 1;\n\n        while (k > 0) {\n            head = head.next;\n            k--;\n        }\n\n        var newHead = head.next;\n        head.next = null;\n        return newHead;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437716929","body":"TC: O(n)  \nSC: O(n)\n\n```java\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        var next = head.next;\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439314255","body":"TC: O(n)  \nSC: O(lgn)\n\n```java\n    private ListNode cur;\n\n    public TreeNode sortedListToBST(ListNode head) {\n        int len = 0;\n        for (var p = head; p != null; p = p.next) len++;\n\n        cur = head;\n        return buildTree(0, len - 1);\n    }\n\n    private TreeNode buildTree(int left, int right) {\n        if (left > right) return null;\n\n        int mid = (left + right) >>> 1;\n\n        TreeNode leftTree = buildTree(left, mid - 1);\n\n        TreeNode root = new TreeNode(cur.val);\n        cur = cur.next;\n\n        TreeNode rightTree = buildTree(mid + 1, right);\n        root.left = leftTree;\n        root.right = rightTree;\n\n        return root;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1440331400","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode nodeA = headA;\n        ListNode nodeB = headB;\n        while (nodeA != nodeB) {\n            nodeA = nodeA == null ? headB : nodeA.next;\n            nodeB = nodeB == null ? headA : nodeB.next;\n        }\n\n        return nodeA;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442063599","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head, slow = head;\n\n        while (true) {\n            if (fast == null || fast.next == null) return null;\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) break;\n        }\n\n        fast = head;\n        while (slow != fast) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n\n        return fast;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1444996220","body":"TC: get: O(1) put: O(1)  \nSC: O(n)\n\n```java\nclass LRUCache {\n    private final DLinkedList list;\n    private final Map<Integer, DLinkedList.DLinkedNode> map;\n    private final int capacity;\n\n    public LRUCache(int capacity) {\n        list = new DLinkedList();\n        map = new HashMap<>();\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        if (!map.containsKey(key)) return -1;\n\n        var node = map.get(key);\n        list.moveToHead(node);\n        return node.getVal();\n    }\n\n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            var node = map.get(key);\n            node.setVal(value);\n            list.moveToHead(node);\n            return;\n        }\n\n        if (capacity == map.size())\n            map.remove(list.deleteTail().getKey());\n\n        var node = new DLinkedList.DLinkedNode(key, value);\n        map.put(key, node);\n        list.addHead(node);\n    }\n}\n\nclass DLinkedList {\n    private final DLinkedNode dummyHead;\n    private final DLinkedNode dummyTail;\n\n    public DLinkedList() {\n        dummyHead = new DLinkedNode();\n        dummyTail = new DLinkedNode();\n        dummyHead.next = dummyTail;\n        dummyTail.prev = dummyHead;\n    }\n\n    public void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addHead(node);\n    }\n\n    public DLinkedNode deleteTail() {\n        var tail = dummyTail.prev;\n        removeNode(tail);\n        return tail;\n    }\n    \n    public void addHead(DLinkedNode node) {\n        node.prev = dummyHead;\n        node.next = dummyHead.next;\n        dummyHead.next.prev = node;\n        dummyHead.next = node;\n    }\n\n    private void removeNode(DLinkedNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    public static class DLinkedNode {\n        private int key;\n        private int val;\n        private DLinkedNode prev;\n        private DLinkedNode next;\n\n        DLinkedNode() {\n        }\n\n        DLinkedNode(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public int getKey() {\n            return key;\n        }\n\n        public int getVal() {\n            return val;\n        }\n\n        public void setVal(int val) {\n            this.val = val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445271678","body":"TC: O(n)  \nSC: O(n)  \n\n```java\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445545788","body":"TC: O(n)  \nSC: O(n)\n\n```java\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null || q == null) return p == q;\n\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1446627268","body":"TC: O(n)  \nSC: O(n)\n\n```java\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    private int dfs(TreeNode root, int path) {\n        if (root == null) return 0;\n\n        path = path * 10 + root.val;\n        if (root.left == null && root.right == null) return path;\n\n        return dfs(root.left, path) + dfs(root.right, path);\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449175337","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    private int ans;\n    private int max;\n\n    public int findBottomLeftValue(TreeNode root) {\n        ans = 0;\n        max = 0;\n        dfs(root, 1);\n        return ans;\n    }\n    \n    private void dfs(TreeNode root, int depth) {\n        if (root == null) return;\n        \n        if (depth > max) {\n            max = depth;\n            ans = root.val;\n        }\n        dfs(root.left, depth + 1);\n        dfs(root.right, depth + 1);\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451172884","body":"TC: O(n)  \nSC: O(n)\n\n```java\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        return buildString(root, new StringBuilder()).toString();\n    }\n\n    private StringBuilder buildString(TreeNode root, StringBuilder sb) {\n        if (root == null) {\n            sb.append('X').append(',');\n            return sb;\n        }\n\n        sb.append(root.val).append(',');\n        buildString(root.left, sb);\n        buildString(root.right, sb);\n\n        return sb;\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        return buildTree(data.split(\",\"), new int[]{0});\n    }\n\n    private TreeNode buildTree(String[] nodes, int[] idx) {\n        String s = nodes[idx[0]++];\n        if (s.equals(\"X\")) return null;\n\n        TreeNode node = new TreeNode(Integer.parseInt(s));\n        node.left = buildTree(nodes, idx);\n        node.right = buildTree(nodes, idx);\n\n        return node;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453163361","body":"TC: O(nlogn)  \nSC: O(n)\n\n```java\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        Map<Integer, List<int[]>> map = new TreeMap<>();\n        Queue<TreeNode> queue = new ArrayDeque<>();\n        Queue<Integer> queueOfCol = new ArrayDeque<>();\n        queue.offer(root);\n        queueOfCol.offer(0);\n\n        int row = 0;\n        while (!queue.isEmpty()) {\n            for (int i = queue.size(); i > 0; i--) {\n                var cur = queue.poll();\n                int col = queueOfCol.poll();\n\n                map.computeIfAbsent(col, o -> new ArrayList<>()).add(new int[]{row, cur.val});\n\n                if (cur.left != null) {\n                    queue.offer(cur.left);\n                    queueOfCol.offer(col - 1);\n                }\n\n                if (cur.right != null) {\n                    queue.offer(cur.right);\n                    queueOfCol.offer(col + 1);\n                }\n            }\n\n            row++;\n        }\n\n        List<List<Integer>> ans = new ArrayList<>();\n        for (List<int[]> list : map.values()) {\n            list.sort((a, b) -> a[0] != b[0] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1]));\n            List<Integer> cur = new ArrayList<>(list.size());\n            list.forEach(v -> cur.add(v[1]));\n\n            ans.add(cur);\n        }\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454392305","body":"TC: O(n)  \nSC: O(n)\n\n```java\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(target - nums[i]))\n                return new int[] {map.get(target - nums[i]), i};\n\n            map.put(nums[i], i);\n        }\n        \n        return new int[0];\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455085634","body":"TC: O(nlogk)  \nSC: O(k)\n\n```java\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        for (var num : nums)\n            count.merge(num, 1, Integer::sum);\n\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n\n        for (var e : count.entrySet()) {\n            int[] p = {e.getKey(), e.getValue()};\n            if (k > minHeap.size())\n                minHeap.add(p);\n            else if (p[1] > minHeap.element()[1]) {\n                minHeap.remove();\n                minHeap.add(p);\n            }\n        }\n\n        return minHeap.stream().mapToInt(e -> e[0]).toArray();\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455509160","body":"TC: O(n^2)  \nSC: O(n)\n\n```java\n    public int numberOfBoomerangs(int[][] points) {\n        if (points == null || points.length < 3) return 0;\n\n        int n = points.length;\n        int res = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n\n                int x = points[i][0] - points[j][0];\n                int y = points[i][1] - points[j][1];\n                int dist = x * x + y * y;\n                map.merge(dist, 1, Integer::sum);\n            }\n\n            for (int cnt : map.values())\n                res += cnt * (cnt - 1);\n\n            map.clear();\n        }\n\n        return res;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457350760","body":"TC: O(n)  \r\nSC: O(1)\r\n写复杂了，dup变量可以去掉\r\n\r\n```java\r\n    public int lengthOfLongestSubstring(String s) {\r\n        int[] cnt = new int[256];\r\n        int right = 0;\r\n        int left = 0;\r\n        int dup = 0;\r\n        int ans = 0;\r\n        while (right < s.length()) {\r\n            char c = s.charAt(right);\r\n            right++;\r\n            if (cnt[c]++ >= 1) dup++;\r\n            while (dup != 0) {\r\n                char c1 = s.charAt(left);\r\n                left++;\r\n                if (cnt[c1]-- > 1) dup--;\r\n            }\r\n\r\n            ans = Math.max(ans, right - left);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460117388","body":"TC: O(n*m) n = s.length, m = words.length  \nSC: O(m)\n\n```java\n    public List<Integer> findSubstring(String s, String[] words) {\n        int sLen = s.length();\n        int n = words.length;\n        int wLen = words[0].length();\n        \n        if (sLen < n * wLen) return List.of();\n        \n        Map<String, Integer> counts = new HashMap<>();\n        for (String word : words)\n            counts.merge(word, 1, Integer::sum);\n\n        List<Integer> ans = new ArrayList<>();\n\n        Map<String, Integer> seen = new HashMap<>();\n        for (int i = 0; i <= sLen - n * wLen; i++) {\n            String sub = s.substring(i, i + n * wLen);\n\n            int j;\n            for (j = 0; j < sub.length(); j += wLen) {\n                String sWord = sub.substring(j, j + wLen);\n                if (!counts.containsKey(sWord)) break;\n\n                int cnt = seen.merge(sWord, 1, Integer::sum);\n\n                if (cnt > counts.get(sWord)) break;\n            }\n\n            seen.clear();\n            if (j == sub.length()) ans.add(i);\n        }\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462228144","body":"```java\nclass Solution {\n    public int minSubarray(int[] nums, int p) {\n        long sum = 0L;\n        for (var num : nums) sum += num;\n        int mod = (int) ((sum % p + p) % p);\n        \n        if (mod == 0) return 0;\n        \n        int n = nums.length;\n        int ans = n;\n        sum = 0L;\n        \n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0 , -1);\n\n        for (int i = 0; i < n; i++) {\n            sum += nums[i];\n            int curM = (int) ((sum % p + p) % p);\n            map.put(curM, i);\n            \n            int targetM = curM - mod + (curM >= mod ? 0 : p);\n            if (map.containsKey(targetM))\n                ans = Math.min(ans, i - map.get(targetM));\n        }\n        \n        return ans == n ? -1 : ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463680245","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    public ListNode middleNode(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        return slow;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464899103","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    public int removeDuplicates(int[] nums) {\n        int slow = 0;\n        int fast = 1;\n        while (fast < nums.length) {\n            if (nums[slow] != nums[fast]) {\n                slow++;\n                nums[slow] = nums[fast];\n            }\n            fast++;\n        }\n\n        return slow + 1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1464994030","body":"TC: O(logn)  \nSC: O(1)\n\n```java\n    public int searchInsert(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length;\n        \n        while (left < right) {\n            int mid = (left + right) >>> 1;\n            \n            if (nums[mid] >= target)\n                right = mid;\n            else \n                left = mid + 1;\n        }\n        \n        return left;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466161919","body":"TC: O(n)  \nSC: O(k)\n\n```java\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        int[] res = new int[n - k + 1];\n        Deque<Integer> deque = new ArrayDeque<>(k);\n\n        for (int i = 0; i < n; i++) {\n            if (!deque.isEmpty() && deque.getFirst() <= i - k)\n                deque.removeFirst();\n\n            while (!deque.isEmpty() && nums[deque.getLast()] < nums[i])\n                deque.removeLast();\n\n            deque.addLast(i);\n\n            if (i + 1 >= k) res[i - k + 1] = nums[deque.getFirst()];\n        }\n\n        return res;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467638471","body":"TC: O(n)  \nSC: O(n)\n\n```java\n    public int findJudge(int n, int[][] trust) {\n        int[] degrees = new int[n + 1];\n\n        for (int[] t : trust) {\n            degrees[t[0]]--;\n            degrees[t[1]]++;\n        }\n\n        for (int i = 1; i <= n; i++)\n            if (degrees[i] == n - 1) return i;\n\n        return -1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469198664","body":"TC: O(n)  \nSC: O(1)\n\n```java\nclass Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        int[] colors = new int[n]; // 0: hasn't been visited yet\n        var graph = buildGraph(dislikes, n);\n\n        for (int i = 0; i < n; i++) {\n            if (colors[i] == 0 && !setColor(graph, colors, i, 1))\n                return false;\n        }\n\n        return true;\n    }\n\n    private List<List<Integer>> buildGraph(int[][] dislikes, int n) {\n        List<List<Integer>> graph = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());\n\n        for (int[] edge : dislikes) {\n            int v = edge[0] - 1;\n            int w = edge[1] - 1;\n            graph.get(v).add(w);\n            graph.get(w).add(v);\n        }\n\n        return graph;\n    }\n\n    private boolean setColor(List<List<Integer>> graph, int[] colors, int node, int color) {\n        if (colors[node] != 0)\n            return colors[node] == color;\n\n        colors[node] = color;\n        for (var neighbor : graph.get(node)) {\n            if (!setColor(graph, colors, neighbor, -color))\n                return false;\n        }\n\n        return true;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1471203239","body":"TC: O(n + m)  \nSC: O(n + m)\n\n```java\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n        for (int i = 0; i < group.length; i++) {\n            if (group[i] == -1) group[i] = m++;\n        }\n\n        List<List<Integer>> groupAdj = new ArrayList<>(m);\n        for (int i = 0; i < m; i++) groupAdj.add(new ArrayList<>());\n\n        List<List<Integer>> itemAdj = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) itemAdj.add(new ArrayList<>());\n\n        int[] groupsIndegree = new int[m];\n        int[] itemsIndegree = new int[n];\n\n        for (int i = 0; i < group.length; i++) {\n            int currentGroup = group[i];\n            for (var beforeItem : beforeItems.get(i)) {\n                int beforeGroup = group[beforeItem];\n                if (beforeGroup == currentGroup) continue;\n                groupAdj.get(beforeGroup).add(currentGroup);\n                groupsIndegree[currentGroup]++;\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (var beforeItem : beforeItems.get(i)) {\n                itemAdj.get(beforeItem).add(i);\n                itemsIndegree[i]++;\n            }\n        }\n\n        List<Integer> groupList = topologicalSort(groupAdj, groupsIndegree, m);\n        if (groupList.isEmpty()) return new int[0];\n\n        List<Integer> itemList = topologicalSort(itemAdj, itemsIndegree, n);\n        if (itemList.isEmpty()) return new int[0];\n\n        Map<Integer, List<Integer>> groups2Items = new HashMap<>();\n        for (int item : itemList)\n            groups2Items.computeIfAbsent(group[item], i -> new ArrayList<>()).add(item);\n\n        int idx = 0;\n        int[] res = new int[n];\n        for (int groupId : groupList) {\n            if (!groups2Items.containsKey(groupId)) continue;\n            for (int item : groups2Items.get(groupId))\n                res[idx++] = item;\n        }\n\n        return res;\n    }\n\n    private List<Integer> topologicalSort(List<List<Integer>> graph, int[] indegree, int n) {\n        List<Integer> res = new ArrayList<>();\n        Queue<Integer> queue = new ArrayDeque<>();\n        for (int i = 0; i < n; i++)\n            if (indegree[i] == 0) queue.offer(i);\n\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            res.add(cur);\n            for (int successor : graph.get(cur)) {\n                indegree[successor]--;\n                if (indegree[successor] == 0)\n                    queue.offer(successor);\n            }\n        }\n\n        return res.size() == n ? res : List.of();\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473180258","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    public boolean judgeCircle(String moves) {\n        int vertical = 0;\n        int horizontal = 0;\n        for (char move : moves.toCharArray()) {\n            switch (move) {\n                case 'U' -> vertical++;\n                case 'D' -> vertical--;\n                case 'L' -> horizontal++;\n                case 'R' -> horizontal--;\n            }\n        }\n\n        return vertical == 0 && horizontal == 0;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474743058","body":"TC: O(nlogn)  \nSC: O(n)\n\n```java\n    public int[] getOrder(int[][] tasks) {\n        int n = tasks.length;\n        // {idx, enqueue time, processing time}\n        int[][] taskArr = new int[n][3];\n        for (int i = 0; i < tasks.length; i++)\n            taskArr[i] = new int[]{i, tasks[i][0], tasks[i][1]};\n\n        // order by enqueue time\n        Arrays.sort(taskArr, Comparator.comparingInt(t -> t[1]));\n\n        var minHeap = new PriorityQueue<int[]>((a, b) -> a[2] != b[2] ? a[2] - b[2] : a[0] - b[0]);\n        int[] ans = new int[n];\n        int curTime = 0;\n        int taskIdx = 0;\n        int ansIdx = 0;\n        while (taskIdx < n || !minHeap.isEmpty()) {\n            if (minHeap.isEmpty() && curTime < taskArr[taskIdx][1])\n                curTime = taskArr[taskIdx][1];\n\n            while (taskIdx < n && taskArr[taskIdx][1] <= curTime)\n                minHeap.offer(taskArr[taskIdx++]);\n\n            int[] task = minHeap.poll();\n            curTime += task[2];\n            ans[ansIdx++] = task[0];\n        }\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475089100","body":"TC: O(1)  \nSC: O(1)\n\n```java\n    public int numberOfRounds(String loginTime, String logoutTime) {\n        int loginMinutes = Integer.parseInt(loginTime.substring(0, 2)) * 60\n                + Integer.parseInt(loginTime.substring(3, 5));\n        int logoutMinutes = Integer.parseInt(logoutTime.substring(0, 2)) * 60\n                + Integer.parseInt(logoutTime.substring(3, 5));\n\n        if (logoutMinutes < loginMinutes) logoutMinutes += 24 * 60;\n\n        logoutMinutes = logoutMinutes / 15 * 15;\n        return (logoutMinutes - loginMinutes) / 15;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475511852","body":"TC: O(max(n, m))  \nSC: O(1)\n\n```java\n    public int minCharacters(String a, String b) {\n        int an = a.length();\n        int[] aCnt = new int[26];\n        for (int i = 0; i < an; i++)\n            aCnt[a.charAt(i) - 'a']++;\n\n        int bn = b.length();\n        int[] bCnt = new int[26];\n        for (int i = 0; i < bn; i++)\n            bCnt[b.charAt(i) - 'a']++;\n\n        int ans = Integer.MAX_VALUE;\n        int aSum = 0;\n        int bSum = 0;\n        for (int i = 0; i < 25; i++) { // exclude 'z'\n            aSum += aCnt[i];\n            bSum += bCnt[i];\n\n            ans = Math.min(\n                    // a > b or b > a\n                    Math.min(aSum + bn - bSum, bSum + an - aSum),\n                    // a == b\n                    Math.min(ans, an - aCnt[i] + bn - bCnt[i])\n            );\n        }\n\n        ans = Math.min(ans, an - aCnt[25] + bn - bCnt[25]);\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477226691","body":"TC: O(nlogn)  \nSC: O(logn)\n\n```java\n    public int[] sortArray(int[] nums) {\n        quicksort(nums);\n        return nums;\n    }\n\n    // median of 3\n    private void quicksort(int[] nums) {\n        quicksort(nums, 0, nums.length - 1);\n    }\n\n    private void quicksort(int[] nums, int left, int right) {\n        if (left + 7 >= right) {\n            insertionSort(nums, left, right);\n            return;\n        }\n\n        int pivot = partition(nums, left, right);\n        quicksort(nums, left, pivot - 1);\n        quicksort(nums, pivot + 1, right);\n    }\n\n    private void insertionSort(int[] nums, int left, int right) {\n        for (int i = left; i <= right; i++) {\n            int tmp = nums[i];\n            int j;\n            for (j = i; j > left && nums[j - 1] > tmp; j--) \n                nums[j] = nums[j - 1];\n            \n            nums[j] = tmp;\n        }\n    }\n\n    private int partition(int[] nums, int left, int right) {\n        int mid = (left + right) >>> 1;\n        if (nums[left] > nums[mid]) swap(nums, left, mid);\n        if (nums[left] > nums[right]) swap(nums, left, right);\n        if (nums[mid] > nums[right]) swap(nums, mid, right);\n        swap(nums, left, mid);\n\n        int pivot = nums[left];\n        int lo = left + 1;\n        int hi = right;\n        while (true) {\n            while (nums[lo] < pivot) lo++;\n            while (nums[hi] > pivot) hi--;\n\n            if (lo >= hi) break;\n            swap(nums, lo, hi);\n            lo++;\n            hi--;\n        }\n\n        swap(nums, left, hi);\n        return hi;\n    }\n\n    private void swap(int[] nums, int a, int b) {\n        if (a == b) return;\n\n        int tmp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = tmp;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1478799750","body":"TC: O(lgn)  \nSC: O(1)\n\n```java\n    public int mySqrt(int x) {\n        long s = x;\n        while (s * s > x)\n            s = (s + x / s) / 2;\n        return (int) s;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480441498","body":"TC: O(lgn)  \nSC: O(1)\n\n```java\n    public int firstBadVersion(int n) {\n        int left = 1;\n        int right = n;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n\n            if (isBadVersion(mid))\n                right = mid;\n            else\n                left = mid + 1;\n        }\n\n        return left;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482172833","body":"TC: O(nlgn)  \nSC: O(n)\n\nbinary indexed tree - loose discrete\n```java\n    public int reversePairs(int[] nums) {\n        int n = nums.length;\n        var map = discrete(nums);\n        int[] tree = new int[2 * n + 1];\n\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            int index = map.get(nums[i] * 2L);\n            ans += i - preSum(tree, index);\n            index = map.get((long) nums[i]);\n            add(tree, index);\n        }\n\n        return ans;\n    }\n\n    private void add(int[] tree, int index) {\n        for (int i = index + 1; i < tree.length; i += i & -i)\n            tree[i]++;\n    }\n\n    private int preSum(int[] tree, int index) {\n        int sum = 0;\n        for (int i = index + 1; i > 0; i -= i & -i)\n            sum += tree[i];\n\n        return sum;\n    }\n    \n    private Map<Long, Integer> discrete(int[] nums) {\n        Set<Long> set = new TreeSet<>();\n        for (int num : nums) {\n            set.add((long) num);\n            set.add(num * 2L);\n        }\n\n        Map<Long, Integer> map = new HashMap<>();\n        int idx = 0;\n        for (Long x : set) \n            map.put(x, idx++);\n        \n        return map;\n    }\n```\n\n\nTC: O(nlgn)  \nSC: O(n)\n\nbinary indexed tree - tight discrete\n```java\n    public int reversePairs(int[] nums) {\n        int n = nums.length;\n        int[] sorted = Arrays.copyOf(nums, n);\n        Arrays.sort(sorted);\n        int[] tree = new int[n + 1];\n\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            int index = getLastSmallerEqualPos(sorted, 2L * nums[i]);\n            ans += i - preSum(tree, index);\n            index = getLastSmallerEqualPos(sorted, nums[i]);\n            add(tree, index);\n        }\n\n        return ans;\n    }\n\n    private void add(int[] tree, int index) {\n        for (int i = index + 1; i < tree.length; i += i & -i)\n            tree[i]++;\n    }\n\n    private int preSum(int[] tree, int index) {\n        int sum = 0;\n        for (int i = index + 1; i > 0; i -= i & -i)\n            sum += tree[i];\n\n        return sum;\n    }\n\n    /**\n     * arr = {1, 3, 7, 7, 7, 8}\n     * getLastSmallerEqualPos(arr, 7) = 4\n     */\n    private int getLastSmallerEqualPos(int[] sorted, long searched) {\n        int left = 0;\n        int right = sorted.length;\n        searched++;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (searched <= sorted[mid])\n                right = mid;\n            else\n                left = mid + 1;\n        }\n\n        return left - 1;\n    }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483849713","body":"TC: O(nlgn)  \nSC: O(n)\n\n```java\n    public int findRadius(int[] houses, int[] heaters) {\n        Arrays.sort(houses);\n        Arrays.sort(heaters);\n\n        int left = 0;\n        int right = Math.max(houses[houses.length - 1] - houses[0], heaters[heaters.length - 1]);\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n\n            if (enough(houses, heaters, mid))\n                right = mid;\n            else\n                left = mid + 1;\n        }\n\n        return left;\n    }\n\n    private boolean enough(int[] houses, int[] heaters, int radius) {\n        for (int i = 0, j = 0; i < houses.length; i++) {\n            while (j < heaters.length && houses[i] > heaters[j] + radius) j++;\n\n            if (j == heaters.length \n                    || houses[i] < heaters[j] - radius \n                    || houses[i] > heaters[j] + radius)\n                return false;\n        }\n\n        return true;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1484011235","body":"TC: O(nlogn)  \nSC: O(n)\n\n```java\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n        int left = 0;\n        int right = nums[nums.length - 1] - nums[0];\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n\n            if (feasible(nums, mid, k))\n                right = mid;\n            else\n                left = mid + 1;\n        }\n\n        return left;\n    }\n\n    private boolean feasible(int[] nums, int dist, int k) {\n        int left = 0;\n        int right = 1;\n        int count = 0;\n        while (left < nums.length || right < nums.length) {\n            while (right < nums.length && nums[right] - nums[left] <= dist)\n                right++;\n\n            count += right - left - 1;\n            if (count >= k) return true;\n            left++;\n        }\n\n        return false;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484384539","body":"TC: O(n^2lgn)  \nSC; O(n^2)\n\nbinary-search\n```java\n    private static final int[][] DIRS = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    public int swimInWater(int[][] grid) {\n        int n = grid.length;\n        int left = grid[0][0];\n        int right = n * n - 1;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n\n            if (feasible(grid, 0, 0, mid, new boolean[n][n]))\n                right = mid;\n            else\n                left = mid + 1;\n        }\n\n        return left;\n    }\n\n    private boolean feasible(int[][] grid, int x, int y, int depth, boolean[][] visited) {\n        visited[x][y] = true;\n\n        for (int[] dir : DIRS) {\n            int nx = x + dir[0];\n            int ny = y + dir[1];\n\n            if (nx < 0 || nx >= grid.length || ny < 0 || ny >= grid.length\n                    || visited[nx][ny] || depth < grid[nx][ny]) continue;\n\n            if (nx == grid.length - 1 && ny == nx) return true;\n            if (feasible(grid, nx, ny, depth, visited)) return true;\n        }\n\n        return false;\n    }\n```\n\nunion-find\n```java\n    private static final int[][] DIRS = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    private int n;\n\n    public int swimInWater(int[][] grid) {\n        this.n = grid.length;\n        int len = n * n;\n\n        int[] index = new int[len];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                index[grid[i][j]] = getIndex(i, j);\n\n        UF uf = new UF(len);\n        for (int i = 0; i < len; i++) {\n            int x = index[i] / n;\n            int y = index[i] % n;\n\n            int idx = getIndex(x, y);\n            for (int[] dir : DIRS) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n\n                if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] <= i)\n                    uf.union(idx, getIndex(nx, ny));\n\n                if (uf.find(0) == uf.find(len - 1))\n                    return i;\n            }\n        }\n\n        return -1;\n    }\n\n    private int getIndex(int x, int y) {\n        return x * n + y;\n    }\n\n    private static class UF {\n        private final int[] parent;\n        private final int[] rank;\n\n        UF(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++)\n                parent[i] = i;\n        }\n\n        int find(int p) {\n           while (p != parent[p]) {\n               parent[p] = parent[parent[p]];\n               p = parent[p];\n           }\n\n           return p;\n        }\n\n        void union(int p, int q) {\n            int pRoot = find(p);\n            int qRoot = find(q);\n\n            if (pRoot == qRoot) return;\n\n            if (rank[pRoot] >= rank[qRoot])\n                parent[qRoot] = pRoot;\n            else\n                parent[pRoot] = qRoot;\n\n            if (rank[pRoot] == rank[qRoot])\n                rank[pRoot]++;\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486082392","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    public int maxVowels(String s, int k) {\n        int cnt = 0;\n        for (int i = 0; i < k; i++) {\n            if (isVowel(s.charAt(i)))\n                cnt++;\n        }\n\n        int ans = cnt;\n        for (int i = k; i < s.length(); i++) {\n            if (isVowel(s.charAt(i - k)))\n                cnt--;\n\n            if (isVowel(s.charAt(i)))\n                cnt++;\n\n            ans = Math.max(ans, cnt);\n            if (ans == k) return k;\n        }\n\n        return ans;\n    }\n\n    private boolean isVowel(char c) {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488499902","body":"TC: O(n+maxPts)  \nSC: O(n+maxPts)\n\n```java\n    public double new21Game(int n, int k, int maxPts) {\n        if (k == 0) return 1;\n        \n        double[] dp = new double[k + maxPts];\n        double sum = 0;\n        for (int i = k; i < k + maxPts; i++) {\n            if (i <= n) dp[i] = 1;\n            sum += dp[i];\n        }\n\n        for (int i = k - 1; i >= 0; i--) {\n            dp[i] = sum / maxPts;\n            sum = sum - dp[i + maxPts] + dp[i];\n        }\n        \n        return dp[0];\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489929024","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    public List<Integer> findAnagrams(String s, String p) {\n        if (p.length() > s.length()) return List.of();\n\n        int n = s.length();\n        int m = p.length();\n\n        int need = 0;\n        int[] cnt = new int[26];\n        for (int i = 0; i < m; i++) {\n            if (cnt[p.charAt(i) - 'a']++ == 0) need++;\n            if (cnt[s.charAt(i) - 'a']-- == 1) need--;\n        }\n\n        List<Integer> ans = new ArrayList<>();\n        if (need == 0) ans.add(0);\n\n        for (int i = m; i < n; i++) {\n            if (cnt[s.charAt(i - m) - 'a']++ == 0) need++;\n            if (cnt[s.charAt(i) - 'a']-- == 1) need--;\n\n            if (need == 0) ans.add(i - m + 1);\n        }\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491189408","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    public String minWindow(String s, String t) {\n        if (t.length() > s.length()) return \"\";\n\n        int[] cnt = new int[128];\n        int diff = 0;\n        for (int i = 0; i < t.length(); i++)\n            if (cnt[t.charAt(i)]++ == 0) diff++;\n\n        int right = 0;\n        int left = 0;\n        int start = 0;\n        int len = s.length() + 1;\n        while (right < s.length()) {\n            if (cnt[s.charAt(right)]-- == 1) diff--;\n            right++;\n\n            while (diff == 0) {\n                if (right - left < len) {\n                    len = right - left;\n                    start = left;\n                }\n\n                if (cnt[s.charAt(left)]++ == 0) diff++;\n                left++;\n            }\n        }\n\n        return len != s.length() + 1 ? s.substring(start, start + len) : \"\";\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1492823046","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    public int maxScore(int[] cardPoints, int k) {\n        int w = cardPoints.length - k;\n        \n        int sumW = 0;\n        for (int i = 0; i < w; i++) \n            sumW += cardPoints[i];\n        \n        int ans = sumW;\n        int sum = sumW;\n        for (int i = w; i < cardPoints.length; i++) {\n            sumW -= cardPoints[i - w];\n            sumW += cardPoints[i];\n            sum += cardPoints[i];\n            \n            ans = Math.min(ans, sumW);\n        }\n        \n        return sum - ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493314786","body":"TC: O(24*60)  \nOC: O(1)\n\n```java\n    public List<String> readBinaryWatch(int turnedOn) {\n        List<String> res = new ArrayList<>();\n        for (int i = 0; i < 12; i++) {\n            for (int j = 0; j < 60; j++)\n                if (bitCount(i) + bitCount(j) == turnedOn)\n                    res.add(i + \":\" + (j <= 9 ? \"0\" + j : j));\n        }\n\n        return res;\n    }\n\n    private int bitCount(int num) {\n        int cnt = 0;\n        while (num != 0) {\n            num = num & (num - 1);\n            cnt++;\n        }\n\n        return cnt;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494053040","body":"TC: O(n!)  \nSC: O(n^2)\n\n```java\nclass Solution {\n    public int totalNQueens(int n) {\n        char[][] board = new char[n][n];\n        for (char[] row : board) Arrays.fill(row, '.');\n\n        return nQueensBacktrack(n, 0, board);\n    }\n\n    private int nQueensBacktrack(int n, int row, char[][] board) {\n        if (n == row) return 1;\n\n        int count = 0;\n        for (int col = 0; col < n && row < n; col++) {\n            if (!feasible(n, board, row, col)) continue;\n\n            board[row][col] = 'Q';\n            count += nQueensBacktrack(n, row + 1, board);\n            board[row][col] = '.';\n        }\n\n        return count;\n    }\n\n    private boolean feasible(int n, char[][] board, int row, int col) {\n        for (int i = row - 1; i >= 0; i--)\n            if (board[i][col] == 'Q') return false;\n\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)\n            if (board[i][j] == 'Q') return false;\n\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++)\n            if (board[i][j] == 'Q') return false;\n\n        return true;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495386383","body":"SC: O(n)  \nTC: O(1)\n\ndfs\n```java\n    private static final int[][] DIRS = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    public int maxAreaOfIsland(int[][] grid) {\n        int ans = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] != 1) continue;\n\n                ans = Math.max(ans, dfs(grid, i, j));\n            }\n        }\n\n        return ans;\n    }\n\n    private int dfs(int[][] grid, int x, int y) {\n        grid[x][y] = 0;\n        int area = 1;\n        for (int[] dir : DIRS) {\n            int nx = x + dir[0];\n            int ny = y + dir[1];\n\n            if (nx >= 0 && nx < grid.length && ny >= 0 && ny < grid[0].length\n                    && grid[nx][ny] == 1)\n                area += dfs(grid, nx, ny);\n        }\n\n        return area;\n    }\n```\n\nunion-find\n```java\n    private static final int[][] DIRS = {{1, 0}, {0, 1}};\n\n    private int[] parent;\n    private int[] size;\n\n    public int maxAreaOfIsland(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n\n        if (m == 1 && n == 1) return grid[0][0];\n\n        parent = new int[m * n];\n        size = new int[m * n];\n        for (int i = 0; i < m * n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n\n        int ans = 0;\n        for (int x = 0; x < m; x++) {\n            for (int y = 0; y < n; y++) {\n                if (grid[x][y] == 0) continue;\n\n                ans = Math.max(ans, grid[x][y]);\n                for (int[] dir : DIRS) {\n                    int nx = x + dir[0];\n                    int ny = y + dir[1];\n\n                    if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 1)\n                        ans = Math.max(ans, union(x * n + y, nx * n + ny));\n                }\n            }\n        }\n\n        return ans;\n    }\n\n    private int find(int p) {\n        while (p != parent[p]) {\n            parent[p] = parent[parent[p]];\n            p = parent[p];\n        }\n\n        return p;\n    }\n\n    private int union(int p, int q) {\n        int pRoot = find(p);\n        int qRoot = find(q);\n\n        if (pRoot == qRoot) return size[pRoot];\n\n        if (size[pRoot] >= size[qRoot]) {\n            parent[qRoot] = pRoot;\n            size[pRoot] += size[qRoot];\n        } else {\n            parent[pRoot] = qRoot;\n            size[qRoot] += size[pRoot];\n        }\n\n        return Math.max(size[pRoot], size[qRoot]);\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497196756","body":"TC: O(n^2)  \nSC: O(n^2)\n\n```java\n    private static final int[][] DIRS = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    public int maxDistance(int[][] grid) {\n        int n = grid.length;\n        boolean[][] seen = new boolean[n][n];\n        Queue<int[]> queue = new ArrayDeque<>(n * n);\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++)\n                if (grid[i][j] == 1) {\n                    queue.offer(new int[]{i, j});\n                    seen[i][j] = true;\n                }\n        }\n\n        if (queue.isEmpty() || queue.size() == n * n) return -1;\n\n        int dist = 0;\n        while (!queue.isEmpty()) {\n            dist++;\n            for (int size = queue.size(); size > 0; size--) {\n                int[] coordinate = queue.poll();\n\n                for (int[] dir : DIRS) {\n                    int x = coordinate[0] + dir[0];\n                    int y = coordinate[1] + dir[1];\n\n                    if (x >= 0 && x < n && y >= 0 && y < n && !seen[x][y] && grid[x][y] == 0) {\n                        queue.offer(new int[]{x, y});\n                        seen[x][y] = true;\n                    }\n                }\n            }\n        }\n\n        return dist - 1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1499025172","body":"TC: O(n)  \nSC: O(n)\n\n```java\n    public int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {\n        Set<Integer> keySet = new HashSet<>();\n        Set<Integer> closed = new HashSet<>();\n        Queue<Integer> queue = new ArrayDeque<>();\n        int maxCandies = 0;\n\n        for (int initialBox : initialBoxes) {\n            if (status[initialBox] == 1 || keySet.contains(initialBox)) {\n                maxCandies += candies[initialBox];\n                for (int key : keys[initialBox]) keySet.add(key);\n                queue.offer(initialBox);\n            } else {\n                closed.add(initialBox);\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            int box = queue.poll();\n\n            for (int containedBox : containedBoxes[box]) {\n                if (status[containedBox] == 1 || keySet.contains(containedBox)) {\n                    maxCandies += candies[containedBox];\n                    for (int key : keys[containedBox]) keySet.add(key);\n                    queue.offer(containedBox);\n                } else {\n                    closed.add(containedBox);\n                }\n            }\n\n            for (int cBox : closed) {\n                if (keySet.contains(cBox)) {\n                    maxCandies += candies[cBox];\n                    for (int key : keys[cBox]) keySet.add(key);\n                    queue.offer(cBox);\n                }\n            }\n\n            closed.removeAll(keySet);\n        }\n\n        return maxCandies;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1499827199","body":"TC: O(n)  \nSC: O(n)\n\n```java\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        Map<Integer, List<int[]>> map = new TreeMap<>();\n        Queue<TreeNode> queue = new ArrayDeque<>();\n        Queue<Integer> queueOfCol = new ArrayDeque<>();\n        queue.offer(root);\n        queueOfCol.offer(0);\n\n        int row = 0;\n        while (!queue.isEmpty()) {\n            for (int i = queue.size(); i > 0; i--) {\n                var cur = queue.poll();\n                int col = queueOfCol.poll();\n\n                map.computeIfAbsent(col, o -> new ArrayList<>()).add(new int[]{row, cur.val});\n\n                if (cur.left != null) {\n                    queue.offer(cur.left);\n                    queueOfCol.offer(col - 1);\n                }\n\n                if (cur.right != null) {\n                    queue.offer(cur.right);\n                    queueOfCol.offer(col + 1);\n                }\n            }\n\n            row++;\n        }\n\n        List<List<Integer>> ans = new ArrayList<>();\n        for (List<int[]> list : map.values()) {\n            list.sort((a, b) -> a[0] != b[0] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1]));\n            List<Integer> cur = new ArrayList<>(list.size());\n            list.forEach(v -> cur.add(v[1]));\n\n            ans.add(cur);\n        }\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500920779","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    public int minCostClimbingStairs(int[] cost) {\n        int n = cost.length;\n\n        int secPrev = cost[0];\n        int prev = cost[1];\n\n        int ans;\n        for (int i = 2; i < n; i++) {\n            ans = Math.min(secPrev, prev) + cost[i];\n            secPrev = prev;\n            prev = ans;\n        }\n\n        return Math.min(prev, secPrev);\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501071796","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    public int rob(int[] nums) {\n        int prev = 0;\n        int secPrev = 0;\n        int ans = 0;\n        for (int num : nums) {\n            ans = Math.max(secPrev + num, prev);\n            secPrev = prev;\n            prev = ans;\n        }\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501819684","body":"TC: O(n^2)  \nSC: O(n)\n\n```java\n    public int findNumberOfLIS(int[] nums) {\n        int n = nums.length;\n        int[] f = new int[n];\n        int[] g = new int[n];\n        int max = 1;\n        for (int i = 0; i < n; i++) {\n            f[i] = g[i] = 1;\n            for (int j = 0; j < i; j++) {\n                if (nums[j] < nums[i]) {\n                    if (f[i] < f[j] + 1) {\n                        f[i] = f[j] + 1;\n                        g[i] = g[j];\n                    } else if (f[i] == f[j] + 1) {\n                        g[i] += g[j];\n                    }\n                }\n            }\n\n            max = Math.max(max, f[i]);\n        }\n\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (f[i] == max) ans += g[i];\n        }\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1502790050","body":"TC: O(n*m)  \nSC: O(m)\n\n```java\n    public int longestCommonSubsequence(String text1, String text2) {\n        int n = text1.length();\n        int m = text2.length();\n        int[] f = new int[m + 1];\n        for (int i = 0; i < n; i++) {\n            int prev = f[0];\n            for (int j = 0; j < m; j++) {\n                int tmp = f[j + 1];\n                if (text1.charAt(i) == text2.charAt(j))\n                    f[j + 1] = prev + 1;\n                else\n                    f[j + 1] = Math.max(f[j + 1], f[j]);\n\n                prev = tmp;\n            }\n        }\n\n        return f[m];\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1504381639","body":"TC: O(m*n)  \nSC: O(n)\n\n```java\n    public int uniquePaths(int m, int n) {\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n\n        for (int i = 1; i < m; i++)\n            for (int j = 1; j < n; j++)\n                dp[j] = dp[j] + dp[j - 1];\n\n        return dp[n - 1];\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506910577","body":"TC: O(n^2*k)  \nSC: O(n^2*k)\n\n```java\n    private static final int[][] DIRS = new int[][]{{-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {-2, 1}, {-2, -1}, {2, 1}, {2, -1}};\n\n    public double knightProbability(int n, int k, int row, int column) {\n        return dfs(n, row, column, k, new double[n][n][k + 1]);\n    }\n\n    private double dfs(int n, int x, int y, int k, double[][][] memo) {\n        if (x < 0 || x >= n || y < 0 || y >= n) return 0D;\n\n        if (k == 0) return 1D;\n\n        if (memo[x][y][k] != 0) return memo[x][y][k];\n\n        double ans = 0D;\n\n        for (int[] dir : DIRS) {\n            ans += dfs(n, x + dir[0], y + dir[1], k - 1, memo) / 8D;\n        }\n        \n        memo[x][y][k] = ans;\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1508566527","body":"TC: O(2^n)  \nSC: O(2^n)\n\n```java\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (maxChoosableInteger >= desiredTotal) return true;\n\n        if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal)\n            return false;\n\n        return dfs(0, 0, maxChoosableInteger, desiredTotal, new byte[1 << 21]);\n    }\n\n    private boolean dfs(int state, int sum, int maxChoosableInteger, int desiredTotal, byte[] visited) {\n        if (visited[state] == 1) return true;\n        if (visited[state] == 2) return false;\n\n        for (int num = 1; num <= maxChoosableInteger; num++) {\n            if (((state >> num) & 1) == 1) continue;\n\n            if (sum + num >= desiredTotal) {\n                visited[state] = 1;\n                return true;\n            }\n\n            if (!dfs((state | 1 << num), sum + num, maxChoosableInteger, desiredTotal, visited)) {\n                visited[state] = 1;\n                return true;\n            }\n\n            visited[state] = 2;\n        }\n\n        visited[state] = 2;\n        return false;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509849785","body":"TC: O(n^2)  \nSC: O(n^2)\n\n```java\n    public boolean canPartition(int[] nums) {\n        int sum = 0;\n        for (int num : nums) sum += num;\n\n        if ((sum & 1) == 1) return false;\n\n        return dfs(nums, sum / 2, 0, new Boolean[nums.length][sum / 2 + 1]);\n    }\n\n    private boolean dfs(int[] nums, int sum, int idx, Boolean[][] dp) {\n        if (idx == nums.length || sum < 0) return false;\n\n        if (dp[idx][sum] != null) return dp[idx][sum];\n\n        if (sum == 0) return dp[idx][sum] = true;\n\n        for (int i = idx; i < nums.length; i++) {\n            if (dfs(nums, sum - nums[i], i + 1, dp))\n                return dp[i][sum] = true;\n\n            dp[i][sum] = false;\n        }\n\n        return dp[idx][sum] = false;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510396802","body":"TC: O(n^2)  \nSC: O(n^2)\n\n```java\n    public int findTargetSumWays(int[] nums, int target) {\n        return dfs(nums, 0, 0, target, new HashMap<>());\n    }\n\n    private int dfs(int[] nums, int idx, int sum, int target, Map<String, Integer> map) {\n        String key = idx + \"_\" + sum;\n        if (nums.length == idx) {\n            map.put(key, sum == target ? 1 : 0);\n            return map.get(key);\n        }\n\n        if (map.containsKey(key)) return map.get(key);\n\n        int ans = dfs(nums, idx + 1, sum + nums[idx], target, map)\n                + dfs(nums, idx + 1, sum - nums[idx], target, map);\n\n        map.put(key, ans);\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511060023","body":"TC: O(n*amount)  \nSC: O(amount)\n\n```java\n    public int coinChange(int[] coins, int amount) {\n        int[] dp = new int[amount + 1];\n        Arrays.fill(dp, amount + 1);\n        dp[0] = 0;\n        for (int i = 1; i <= amount; i++) {\n            for (int coin : coins) {\n                if (i - coin < 0) continue;\n\n                dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n            }\n        }\n\n        return dp[amount] == amount + 1 ? -1 : dp[amount];\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1512995705","body":"TC: O(nm)  \nSC: O(m)\n\n```java\n    public int change(int amount, int[] coins) {\n        int[] dp = new int[amount + 1];\n        dp[0] = 1;\n\n        for (int coin : coins) {\n            for (int i = coin; i <= amount; i++) {\n                dp[i] += dp[i - coin];\n            }\n        }\n        \n        return dp[amount];\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514684093","body":"TC: O(nlogn + mlogm)  \nSC: O(1)\n\n```java\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int i = 0;\n        int j = 0;\n        while (i < g.length && j < s.length) {\n            if (g[i] <= s[j]) i++;\n            j++;\n        }\n\n        return i;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516378160","body":"TC: O(nlogn)  \nSC: O(n)\n\n```java\n    public int eraseOverlapIntervals(int[][] intervals) {\n        Arrays.sort(intervals, Comparator.comparing(i -> i[1]));\n\n        int res = 0;\n        int i = 0;\n        while (i < intervals.length) {\n            int j = i + 1;\n            int cur = intervals[i][1];\n\n            while (j < intervals.length && cur > intervals[j][0]) {\n                res++;\n                j++;\n            }\n\n            i = j;\n        }\n\n        return res;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1518474137","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    public boolean canJump(int[] nums) {\n        int max = 0;\n        int n = nums.length;\n\n        for (int i = 0; i < n; i++) {\n            if (i > max) return false;\n            max = Math.max(max, nums[i] + i);\n        }\n\n        return true;\n    }\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518653370","body":"TC: O(n^2)  \nSC: O(n^2)\n\n```java\n    private int[][] memo;\n\n    public int numTrees(int n) {\n        memo = new int[n + 1][n + 1];\n        return dfs(1, n);\n    }\n    \n    private int dfs(int lo, int hi) {\n        if (lo > hi) return 1;\n\n        if (memo[lo][hi] != 0) return memo[lo][hi];\n\n        int res = 0;\n        for (int mid = lo; mid <= hi; mid++) \n            res += dfs(lo, mid - 1) * dfs(mid + 1, hi);\n\n        memo[lo][hi] = res;\n        return res;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519061178","body":"TC: O(nlogn)  \nSC: O(n)\n\n```java\n    public ListNode mergeKLists(ListNode[] lists) {\n        var minHeap = new PriorityQueue<ListNode>(Comparator.comparingInt(a -> a.val));\n\n        for (var head : lists)\n            if (head != null) minHeap.offer(head);\n\n        ListNode dummy = new ListNode(-1);\n        var cur = dummy;\n        while (!minHeap.isEmpty()) {\n            cur.next = minHeap.poll();\n\n            cur = cur.next;\n            if (cur.next != null) minHeap.offer(cur.next);\n        }\n\n        return dummy.next;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1519259981","body":"TC: O(nlogn)  \nSC: O(logn)\n\n```java\n    public int[] beautifulArray(int n) {\n        int[] arr = new int[n];\n        Arrays.fill(arr, 1);\n        part(arr, 0, n - 1);\n        return arr;\n    }\n\n    private void part(int[] arr, int lo, int hi) {\n        if (lo >= hi) return;\n\n        int mid = (lo + hi) >>> 1;\n        part(arr, lo, mid);\n        part(arr, mid + 1, hi);\n\n        for (int i = lo; i <= mid; i++)\n            arr[i] = arr[i] * 2 - 1;\n\n        for (int i = mid + 1; i <= hi; i++)\n            arr[i] = arr[i] * 2;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521034309","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    public int[] singleNumber(int[] nums) {\n        int xor = 0;\n        for (int num : nums) xor ^= num;\n\n        int num1 = 0;\n        int lowbit = xor & (-xor);\n        for (int num : nums) {\n            if ((num & lowbit) == 0) num1 ^= num;\n        }\n\n        return new int[]{xor ^ num1, num1};\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1522642519","body":"TC: O(2^n)  \nSC: O(n)  \n\n```java\n    public List<List<Integer>> subsets(int[] nums) {\n        return dfs(nums, 0, new ArrayDeque<>(), new ArrayList<>());\n    }\n\n    private List<List<Integer>> dfs(int[] nums, int idx, Deque<Integer> subset, List<List<Integer>> res) {\n        res.add(new ArrayList<>(subset));\n\n        for (int i = idx; i < nums.length; i++) {\n            subset.addLast(nums[i]);\n            dfs(nums, i + 1, subset, res);\n            subset.removeLast();\n        }\n\n        return res;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1525890859","body":"```java\nclass Trie {\n    private final Trie[] children;\n    private boolean isEnd;\n\n    public Trie() {\n        children = new Trie[26];\n        isEnd = false;\n    }\n\n    public void insert(String word) {\n        Trie node = this;\n        for (char c : word.toCharArray()) {\n            int idx = c - 'a';\n            if (node.children[idx] == null)\n                node.children[idx] = new Trie();\n\n            node = node.children[idx];\n        }\n\n        node.isEnd = true;\n    }\n\n    public boolean search(String word) {\n        Trie node = searchPrefix(word);\n        return node != null && node.isEnd;\n    }\n\n    public boolean startsWith(String prefix) {\n        return searchPrefix(prefix) != null;\n    }\n\n    private Trie searchPrefix(String prefix) {\n        Trie node = this;\n        for (char c : prefix.toCharArray()) {\n            int idx = c - 'a';\n            if (node.children[idx] == null)\n                return null;\n\n            node = node.children[idx];\n        }\n\n        return node;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1527115012","body":"TC: O(n)  \nSC: O(n)\n\n```java\nclass MapSum {\n    private final MapSum[] children;\n    private final Map<String, Integer> map;\n    private int val;\n\n    public MapSum() {\n        children = new MapSum[26];\n        map = new HashMap<>();\n        val = 0;\n    }\n\n    public void insert(String key, int val) {\n        int delta = val - map.getOrDefault(key, 0);\n        map.put(key, val);\n        MapSum node = this;\n        for (char c : key.toCharArray()) {\n            int idx = c - 'a';\n\n            if (node.children[idx] == null)\n                node.children[idx] = new MapSum();\n\n            node = node.children[idx];\n            node.val += delta;\n        }\n    }\n\n    public int sum(String prefix) {\n        MapSum node = this;\n        for (char c : prefix.toCharArray()) {\n            int idx = c - 'a';\n\n            if (node.children[idx] == null) return 0;\n\n            node = node.children[idx];\n        }\n\n        return node.val;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528718418","body":"```java\nclass Solution {\n    public int[][] multiSearch(String big, String[] smalls) {\n        Trie trie = new Trie();\n\n        for (int i = 0; i < smalls.length; i++)\n            trie.insert(smalls[i], i);\n\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = 0; i < smalls.length; i++)\n            ans.add(new ArrayList<>());\n\n        for (int i = 0; i < big.length(); i++)\n            for (var id : trie.hasPrefix(big.substring(i)))\n                ans.get(id).add(i);\n\n        return ans.stream()\n                .map(arr -> arr.stream().mapToInt(i -> i).toArray())\n                .toArray(int[][]::new);\n    }\n\n    private static class Trie {\n        private final Trie[] children;\n        private boolean isEnd;\n        private int id;\n\n        private Trie() {\n            children = new Trie[26];\n            isEnd = false;\n            id = -1;\n        }\n\n        private void insert(String word, int id) {\n            if (word.isBlank()) return;\n            \n            Trie node = this;\n            for (char c : word.toCharArray()) {\n                int idx = c - 'a';\n                if (node.children[idx] == null)\n                    node.children[idx] = new Trie();\n\n                node = node.children[idx];\n            }\n\n            node.isEnd = true;\n            node.id = id;\n        }\n\n        private List<Integer> hasPrefix(String search) {\n            Trie node = this;\n            List<Integer> ids = new ArrayList<>();\n            for (char c : search.toCharArray()) {\n                int idx = c - 'a';\n\n                if (node.isEnd) ids.add(node.id);\n\n                if (node.children[idx] == null) return ids;\n\n                node = node.children[idx];\n            }\n\n            if (node.isEnd) ids.add(node.id);\n            return ids;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1529056182","body":"```java\n    public int findCircleNum(int[][] isConnected) {\n        int n = isConnected.length;\n        boolean[] visited = new boolean[n];\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (visited[i]) continue;\n            \n            dfs(isConnected, i, visited);\n            count++;\n        }\n        \n        return count;\n    }\n    \n    private void dfs(int[][] isConnected, int i, boolean[] visited) {\n        for (int j = 0; j < isConnected.length; j++) {\n            if (isConnected[i][j] == 1 && !visited[j]) {\n                visited[j] = true;\n                dfs(isConnected, j, visited);\n            }\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1529766777","body":"TC: O(n)  \nSC: O(n)\n\n```java\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int n = graph.length;\n        int[] colors = new int[n];\n        Arrays.fill(colors, -1);\n        int color = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (colors[i] != -1) continue;\n\n            dfs(graph, colors, i, color);\n            color++;\n        }\n\n        int[] size = new int[color];\n        for (int c : colors) size[c]++;\n\n        int[] cnt = new int[color];\n        for (int i : initial) cnt[colors[i]]++;\n\n        Arrays.sort(initial);\n        int ans = initial[0];\n        int max = Integer.MIN_VALUE;\n        for (int i : initial) {\n            int c = colors[i];\n            if (cnt[c] != 1) continue;\n\n            if (size[c] > max) {\n                max = size[c];\n                ans = i;\n            }\n        }\n\n        return ans;\n    }\n\n    private void dfs(int[][] graph, int[] colors, int cur, int color) {\n        colors[cur] = color;\n        for (int nei = 0; nei < graph.length; nei++) {\n            if (graph[cur][nei] == 1 && colors[nei] == -1)\n                dfs(graph, colors, nei, color);\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1530817960","body":"TC: O(m)\nSC: O(m)\n\n```java\n    private int[] parent;\n    private int[] rank;\n    private int count;\n\n    public int makeConnected(int n, int[][] connections) {\n        if (connections.length < n - 1) return -1;\n\n        parent = new int[n];\n        rank = new int[n];\n        count = n;\n        for (int i = 0; i < n; i++)\n            parent[i] = i;\n\n        for (int[] connection : connections)\n            union(connection[0], connection[1]);\n\n        return count - 1;\n    }\n\n    private int find(int p) {\n        while (p != parent[p]) {\n            parent[p] = parent[parent[p]];\n            p = parent[p];\n        }\n\n        return p;\n    }\n\n    private void union(int p, int q) {\n        int pRoot = find(p);\n        int qRoot = find(q);\n\n        if (pRoot == qRoot) return;\n\n        if (rank[pRoot] >= rank[qRoot])\n            parent[qRoot] = pRoot;\n        else\n            parent[pRoot] = qRoot;\n\n        if (rank[pRoot] == rank[qRoot])\n            rank[pRoot]++;\n\n        count--;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1532470597","body":"TC: O(n)  \nSC: O(n)\n\n```java\n    public TreeNode pruneTree(TreeNode root) {\n        if (root == null) return null;\n        \n        root.left = pruneTree(root.left);\n        root.right = pruneTree(root.right);\n        \n        return (root.val == 0 && root.left == null && root.right == null) ? null : root;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1533994973","body":"```java\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        return dfs(candidates, 0, target, new ArrayDeque<>(), new ArrayList<>());\n    }\n\n    private List<List<Integer>> dfs(int[] candidates, int idx, int target, Deque<Integer> path, List<List<Integer>> ans) {\n        if (target == 0) {\n            ans.add(new ArrayList<>(path));\n            return ans;\n        }\n\n        for (int i = idx; i < candidates.length; i++) {\n            if (target < candidates[i]) break;\n\n            path.addFirst(candidates[i]);\n            dfs(candidates, i, target - candidates[i], path, ans);\n            path.removeFirst();\n        }\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1535589137","body":"```java\nclass Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        List<List<Integer>> ans = new ArrayList<>();\n        dfs(candidates, 0, target, new ArrayDeque<>(), ans);\n        return ans;\n    }\n\n    private void dfs(int[] candidates, int idx, int target, Deque<Integer> path, List<List<Integer>> ans) {\n        if (target == 0) {\n            ans.add(new ArrayList<>(path));\n            return;\n        }\n\n        for (int i = idx; i < candidates.length; i++) {\n            if (target < candidates[i]) return;\n\n            if (i > idx && candidates[i] == candidates[i - 1]) continue;\n\n            path.addLast(candidates[i]);\n            dfs(candidates, i + 1, target - candidates[i], path, ans);\n            path.removeLast();\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1537031668","body":"```java\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        return dfs(nums, new boolean[n], new ArrayDeque<>(n), new ArrayList<>(n * n));\n    }\n\n    private List<List<Integer>> dfs(int[] nums, boolean[] used, Deque<Integer> path, List<List<Integer>> ans) {\n        if (path.size() == nums.length) {\n            ans.add(new ArrayList<>(path));\n            return ans;\n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]))\n                continue;\n\n            used[i] = true;\n            path.addLast(nums[i]);\n            dfs(nums, used, path, ans);\n            path.removeLast();\n            used[i] = false;\n        }\n\n        return ans;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null],"jancerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"buer1121":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ceramickitten":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gg925407590":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alyenor":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenming-cao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggohem":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dark-volute":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ronething":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jmastella":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429296672","body":"思路\r\n用一个addson记录需要进位的数字, 从个位开始加，每一次把 %10 存进list里面，直到addson为零\r\n\r\n代码\r\n`\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> li = new ArrayList();\r\n\r\n        int addson = k;\r\n        int index = num.length-1;\r\n\r\n        while(index>=0 || addson >0){\r\n            if(index>=0){\r\n                addson += num[index];\r\n                index--;\r\n            }\r\n            li.add(0, addson%10);\r\n            addson/=10;\r\n            \r\n        }\r\n\r\n        return li;\r\n    }\r\n}\r\n`\r\n复杂度分析\r\n\r\n时间: O(max(N, log k)), N is the length of num\r\n空间: O(max(N, log k)), N is the length of num\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430971036","body":"思路\r\n从左到右loop一遍，记录左边离他最近的character。再从右到左loop一遍记录右边离他最近的character，两者取min。\r\n\r\n代码\r\n```\r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] answer = new int[s.length()];\r\n        int index = -1;\r\n        for(int i=0; i<s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                index = i;\r\n            }\r\n            if(index == -1){\r\n                answer[i] = s.length();\r\n            }else{\r\n                answer[i] = i - index;\r\n            }\r\n            //System.out.println(s.charAt(i) + \" \" + answer[i]);\r\n        }\r\n        //System.out.println(\"==================\");\r\n        for(int i=s.length()-1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                index = i;\r\n            }\r\n            if(index >= i){\r\n                answer[i] = Math.min(answer[i], index - i);\r\n            }\r\n            //System.out.println(s.charAt(i) + \" \" + answer[i]);\r\n        }\r\n        return answer;\r\n}\r\n```\r\n复杂度\r\n时间：O(N) N=s.length()\r\n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432576668","body":"思路\r\n用int array来代表stack，new variable index来mark top of list\r\npush的时候，check有没有超过array.length\r\npop的时候，check index>=0\r\nincrement的时候，取Math.min(k, arr.length)\r\n\r\n代码\r\n```\r\nclass CustomStack {\r\n    int[] arr;\r\n    int index;\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        index = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(index < arr.length-1){\r\n            index++;\r\n            arr[index] = x;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    public int pop() {\r\n        if(index >=0){\r\n            return arr[index--];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        System.out.println(k + \" \" + index);\r\n        for(int i=0; i< Math.min(k, arr.length); i++){\r\n            arr[i]+=val;\r\n        }\r\n    }\r\n}\r\n```\r\n复杂度分析\r\n\r\n时间复杂度：push、pop：O(1) increment:O(N)。\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434224506","body":"思路\r\n利用stack\r\n1.遇到数字变成int 数字\r\n2.遇到'[' 把数字push to stack\r\n3.遇到’]‘ 把所有的character pop出来组成一个string，在用数字去repeat\r\n4.遇到字母push to stack\r\n\r\n代码\r\n```\r\n    public String decodeString(String s) {\r\n        \r\n        Stack<String> stack = new Stack<>();\r\n        int i=0;\r\n        int repeat =0;\r\n        while(i<s.length()){\r\n            char curr = s.charAt(i);\r\n            if(Character.isDigit(curr)){\r\n                repeat = repeat*10 + Character.getNumericValue(curr);\r\n            }else if(curr == '['){\r\n                stack.push(Integer.toString(repeat));\r\n                stack.push(\"*\");\r\n                repeat = 0;\r\n            }else if(curr == ']'){\r\n                String str = \"\";\r\n                while(!stack.peek().equals(\"*\")){\r\n                    str = stack.pop() + str;\r\n                }\r\n                stack.pop();\r\n                int count = Integer.parseInt(stack.pop());\r\n                stack.push(str.repeat(count));\r\n            }else{\r\n                stack.push(Character.toString(curr));\r\n            }\r\n            i++;\r\n        }\r\n        String result = \"\";\r\n        while(!stack.isEmpty()){\r\n            result = stack.pop() + result;\r\n        }\r\n        return result;\r\n    }\r\n```\r\n复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435638176","body":"思路\r\n两个stack，一个是部分reverse queue的顺序，一个是正序\r\npush：直接push到reverse_stack\r\npop: 如果正序stack不为空，pop from 正序stack。otherwise，先把reverse stack所有element放进正序stack里，再pop from 正序stack。\r\npeek：和pop思路一样\r\nempty：两个stack都为空\r\n代码\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> s1;\r\n    Stack<Integer> s2;\r\n    public MyQueue() {\r\n        s1 = new Stack<>(); // reverse\r\n        s2 = new Stack<>(); /// front\r\n    }\r\n    \r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(!s2.isEmpty()){\r\n            return s2.pop();\r\n        }\r\n        while(!s1.isEmpty()){\r\n            s2.push(s1.pop());\r\n        }\r\n        return s2.pop();\r\n    }\r\n\r\n    \r\n    public int peek() {\r\n        if(!s2.isEmpty()){\r\n            return s2.peek();\r\n        }\r\n        while(!s1.isEmpty()){\r\n            s2.push(s1.pop());\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```\r\n复杂度分析\r\n\r\n时间复杂度：push()和empty()：O(1)，pop()，peek()：O(N)。\r\n空间复杂度：O(N)，其中 N number of element push in stack。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435925844","body":"### 思路\r\n用stack来存每一个chunck里面最大的数字，monotonic stack\r\n如果stack.peek() > arr[i], 找到所有比arr[i]大的数字，pop()出来，然后再把本chunk最大的数字再加回去\r\n### 代码\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int count =1;\r\n        Stack<Integer> stack = new Stack<>();\r\n        for(int i=0; i<arr.length; i++){\r\n            if(stack.size() == 0 || stack.peek()<= arr[i]){\r\n                stack.push(arr[i]);\r\n                continue;\r\n            }\r\n            int temp = stack.peek();\r\n            while(!stack.empty() && stack.peek() > arr[i] ){\r\n                stack.pop();\r\n            }\r\n            stack.push(temp);\r\n\r\n            \r\n        }\r\n        return stack.size();\r\n    }\r\n```\r\n### 复杂度\r\n时间：O(N)\r\n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436517682","body":"### 思路\r\nfast 和slow两个pointer。先找到整个list长度N。fast走 k%N步，找到新的head，修改\r\nedge case：empty list，k=0 or k%N=0\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null){\r\n            return null;\r\n        }\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n\r\n        int len = 0;\r\n        while(fast != null){\r\n            fast = fast.next;\r\n            len++;\r\n        }\r\n        fast = head;\r\n        if(k==0 || k%len == 0){\r\n            return head;\r\n        }\r\n        for(int i=0; i<k%len; i++){\r\n            fast = fast.next;\r\n        }\r\n        while(fast.next != null){\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n\r\n        ListNode temp = slow.next;\r\n        slow.next = null;\r\n        fast.next = head;\r\n\r\n        return temp; \r\n\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n时间：O(N)\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437990918","body":"### 思路\r\n1. 借助了一些hint，提示用recursion。\r\n2. new listNode fakehead 帮助返回new head。\r\n3. Base Case： curr==null || curr.next ==null\r\n4. Recursion: \r\nparent -> swap1 -> swap2 -> temp\r\n变为\r\nparent -> swap2 -> swap1 -> temp\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n\r\n        ListNode fakeHead = new ListNode();\r\n        fakeHead.next = head;\r\n        helper(fakeHead, head);\r\n        return fakeHead.next;\r\n    }\r\n    public void helper(ListNode parent, ListNode swap1){\r\n        \r\n        if(swap1 == null || swap1.next == null){\r\n            return;\r\n        }\r\n        ListNode swap2 = swap1.next;\r\n        ListNode temp = swap2.next;\r\n        swap2.next = swap1;\r\n        swap1.next = temp;\r\n        parent.next = swap2;\r\n\r\n        helper(swap1, swap1.next);\r\n    }\r\n\r\n}\r\n```\r\n### 复杂度\r\n时间：O(N)\r\n空间： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439654691","body":"## 思路\r\nroot, left, right  preorder traversal\r\n\r\n## 代码\r\n```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return helper(head, null);\r\n    }\r\n    public TreeNode helper(ListNode head, ListNode tail){\r\n        if(head == tail){\r\n            return null;\r\n        }\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while(fast !=tail && fast.next!=tail){\r\n            slow = slow.next;\r\n            if(fast.next==tail){\r\n                break;\r\n            }\r\n            fast =fast.next.next;\r\n        }\r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = helper(head, slow);\r\n        root.right = helper(slow.next, tail);\r\n\r\n        return root;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n时间：O(N)\r\n空间：O(log(N))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441094599","body":"### 思路\r\nAAAAAAAACCCCC\r\nBBCCCCC\r\n\r\nA+C+B = B + C + A\r\n\r\n当Aloop完继续loopB， 同理B loop完继续loop A，当他俩交汇时就是intersection\r\n\r\n### 代码\r\n```\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode lA = headA;\r\n        ListNode lB = headB;\r\n\r\n        while(lA != null || lB !=null){\r\n            if(lA == lB){\r\n                return lA;\r\n            }\r\n            \r\n            if(lA == null){\r\n                lA = headB;\r\n            }else{\r\n                lA = lA.next;\r\n            }\r\n            if(lB == null){\r\n                lB = headA;\r\n            }else{\r\n                lB = lB.next;\r\n            }\r\n            \r\n            \r\n            \r\n        }\r\n        return null;\r\n    }\r\n```\r\n### 复杂度\r\n时间 O(m+n)\r\n空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442861379","body":"### 思路\r\n快慢指针+数学\r\n\r\n### 代码\r\n```\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n\r\n\r\n        while(fast != null){\r\n            slow = slow.next;\r\n            if(fast ==null || fast.next ==null){\r\n                return null;\r\n            }\r\n            fast = fast.next.next;\r\n        }\r\n        slow = head;\r\n        while(slow != fast){\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        return slow;\r\n    }\r\n```\r\n### 复杂度\r\n时间 O(N)\r\n空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445048062","body":"### 思路\r\ndoubly linked list+hashMap\r\n\r\n### 代码\r\n```\r\nclass LRUCache {\r\n  \r\n  Node head = new Node(0, 0), tail = new Node(0, 0);\r\n  Map<Integer, Node> map = new HashMap();\r\n  int capacity;\r\n  \r\n  public LRUCache(int _capacity) {\r\n    capacity = _capacity;\r\n    head.next = tail;\r\n    tail.prev = head;\r\n  }\r\n\r\n  public int get(int key) {\r\n    if(map.containsKey(key)) {\r\n      Node node = map.get(key);\r\n      remove(node);\r\n      insert(node);\r\n      return node.value;\r\n    } else {\r\n      return -1;\r\n    }\r\n  }\r\n\r\n  public void put(int key, int value) {\r\n    if(map.containsKey(key)) {\r\n      remove(map.get(key));\r\n    }\r\n    if(map.size() == capacity) {\r\n      remove(tail.prev);\r\n    }\r\n    insert(new Node(key, value));\r\n  }\r\n  \r\n  private void remove(Node node) {\r\n    map.remove(node.key);\r\n    node.prev.next = node.next;\r\n    node.next.prev = node.prev;\r\n  }\r\n  \r\n  private void insert(Node node){\r\n    map.put(node.key, node);\r\n    Node headNext = head.next;\r\n    head.next = node;\r\n    node.prev = head;\r\n    headNext.prev = node;\r\n    node.next = headNext;\r\n  }\r\n  \r\n  class Node{\r\n    Node prev, next;\r\n    int key, value;\r\n    Node(int _key, int _value) {\r\n      key = _key;\r\n      value = _value;\r\n    }\r\n  }\r\n```\r\n复杂度\r\n时间：O(1)\r\n空间：O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445906025","body":"### 思路\r\nrecursion\r\nbase case：root = null，depth=0\r\nrecursive case：math.max(left.depth, right.depth)+1\r\n\r\n### 代码\r\n```\r\npublic int maxDepth(TreeNode root) {\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n        int left = maxDepth(root.left);\r\n        int right = maxDepth(root.right);\r\n\r\n        return Math.max(left, right)+1;\r\n    }\r\n```\r\n### 复杂度\r\n时间：O（N）\r\n空间：O（N）","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445900316","body":"## 思路\r\nbase case：q和p都为null， true。 q和p中只有一个为null，false。q值和p值不想等，false。\r\nrecursive：q.left p.left && q.right p.right\r\n\r\n## 代码\r\n```\r\npublic boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p ==null && q==null){\r\n            return true;\r\n        }else if(p == null || q ==null){\r\n            return false;\r\n        }else if(q.val != p.val){\r\n            return false;\r\n        }else{\r\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n        }\r\n    }\r\n```\r\n## 复杂度\r\n时间：O(N) 每一个node都要到\r\n空间：O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447706330","body":"## 思路\r\nDFS\r\nbase case: 只有一个node，value = root.val\r\nrecursive case: preorder\r\n一直把前面算好的数字传下去，到leafnode 算好穿回来\r\n\r\n## 代码\r\n```\r\npublic int sumNumbers(TreeNode root) {\r\n        if(root == null){\r\n            return 0 ;\r\n        }\r\n        return helper(root,0); \r\n\r\n    }\r\n    public int helper(TreeNode root, int pVal){\r\n        \r\n        if(root.left == null && root.right == null){\r\n            return pVal*10 +root.val;\r\n        }\r\n        int left = 0;\r\n        int right =0;\r\n        if(root.left != null){\r\n            left = helper(root.left, pVal*10+root.val);\r\n        }\r\n        if(root.right != null){\r\n            right = helper(root.right, pVal*10+root.val);\r\n        }\r\n        \r\n        \r\n\r\n        return left +right;\r\n\r\n    }\r\n```\r\n## 复杂度\r\n时间：O(N)\r\n空间：O(h) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449484142","body":"### 思路\r\n把depth当作parameter传下去，比较左边和右边的depth，depth最大的第一个数字就是result\r\n\r\n### 代码\r\n```\r\npublic int findBottomLeftValue(TreeNode root) {\r\n        int[] result = helper(root, 0);\r\n        return result[1];\r\n\r\n    }\r\n    public int[] helper(TreeNode root, int depth){\r\n        if(root.left == null && root.right == null){\r\n            //System.out.println(depth+1 + \" \"+ root.val);\r\n            return new int[]{depth+1 , root.val};\r\n        }\r\n        int[] left = new int[]{-1, 0};\r\n        int[] right = new int[]{-1, 0};\r\n\r\n        if(root.left != null){\r\n            left = helper(root.left, depth+1);\r\n        }\r\n        if(root.right != null){\r\n            right = helper(root.right, depth+1);\r\n        }\r\n\r\n        if(left[0] >= right[0]){\r\n            return left;\r\n        }else{\r\n            return right;\r\n        }\r\n    }\r\n```\r\n\r\n### 复杂度\r\n时间：O(N)\r\n空间：O(h) height","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451388840","body":"### 思路\r\nserialize的时候，用preorder（root，left，right）来记录treenode value。null时记为“n“。\r\ndeserialize的时候，同样用preorder来复现，用index来记录现在的node的index\r\n\r\n### 代码\r\n```\r\npublic class Codec {\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        if(root == null){\r\n            return \"\";\r\n        }\r\n        String str = shelper(root);\r\n        //System.out.println(str);\r\n        return str;\r\n    }\r\n    public String shelper(TreeNode root){\r\n        if(root == null){\r\n            return \"n\";\r\n        }\r\n\r\n        return root.val + \",\" +shelper(root.left) +\",\" + shelper(root.right);\r\n    }\r\n\r\n    int index;\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        if(data.length() == 0){\r\n            return null;\r\n        }\r\n        String[] arr = data.split(\",\");\r\n        index =0;\r\n        return dehelper(arr);\r\n    }\r\n    public TreeNode dehelper(String[] arr){\r\n        if(index>=arr.length || arr[index].equals(\"n\")){\r\n            index++;\r\n            return null;\r\n        }\r\n\r\n        TreeNode root = new TreeNode(Integer.parseInt(arr[index]));\r\n        index++;\r\n        root.left = dehelper(arr);\r\n        root.right = dehelper(arr);\r\n\r\n        return root;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n时间O(N)\r\n空间O(h)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453103481","body":"### 思路\r\n不确定是不是最优解，非常之麻烦。\r\nmap: key = int column, value = HashMap<int row, List<Inetger>>\r\n\r\n### 代码\r\n\r\n```\r\nclass Solution {\r\n    int min_col;\r\n    int max_col;\r\n    int max_row;\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        Map<Integer,Map<Integer, List<Integer>>> map = new HashMap<>();\r\n        min_col =0;\r\n        max_col =0;\r\n        max_row = 0;\r\n        helper(root, map, 0,0);\r\n        List<List<Integer>> result = new ArrayList<>();\r\n        for(int i=min_col; i<=max_col; i++){\r\n            Map<Integer, List<Integer>> rmap = map.get(i);\r\n            if(rmap == null){\r\n                continue;\r\n            }\r\n            List<Integer> subList = new ArrayList<>();\r\n            for(int j=0; j<=max_row; j++){\r\n                if(rmap.get(j) == null){\r\n                    continue;\r\n                }\r\n                List<Integer> li = rmap.get(j);\r\n                Collections.sort(li);\r\n                subList.addAll(li);\r\n                 \r\n            }\r\n            result.add(subList);            \r\n        }\r\n        return result;\r\n\r\n    }\r\n    public void helper(TreeNode root, Map<Integer,Map<Integer, List<Integer>>> map, int r, int c){\r\n        if(root == null){\r\n            return;\r\n        }\r\n        min_col = Math.min(min_col, c);\r\n        max_col = Math.max(max_col, c);\r\n        max_row = Math.max(max_row, r);\r\n        Map<Integer, List<Integer>> rmap;\r\n        if(map.get(c) == null){\r\n            rmap = new HashMap<>();\r\n        }else{\r\n            rmap = map.get(c);\r\n        }\r\n        List<Integer> li;\r\n        if(rmap.get(r) == null){\r\n            li = new ArrayList<>();\r\n        }else{\r\n            li = rmap.get(r);\r\n        }\r\n        li.add(root.val);\r\n        rmap.put(r, li);\r\n        map.put(c, rmap);\r\n        helper(root.left, map,r+1, c-1);\r\n        helper(root.right, map, r+1, c+1);\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n时间：O(Nlogn), 再dfs里O(N), 在外面的时候每一个node都只被sort了一遍，O(NLOGN)\r\n空间：O(h), height","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454323100","body":"### 思路\r\n用map存已经loop过的value\r\n如果target-nums[i]在map里，找到\r\n\r\n### 代码\r\n```java\r\npublic int[] twoSum(int[] nums, int target) {\r\n\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        for(int i=0; i<nums.length; i++){\r\n\r\n            if(map.get(target - nums[i]) != null){\r\n                return new int[]{map.get(target - nums[i]), i};\r\n            }\r\n\r\n            map.put(nums[i], i);\r\n        }\r\n\r\n        return new int[]{};\r\n\r\n    }\r\n```\r\n\r\n###复杂度\r\n时间O(N)\r\n空间O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455016420","body":"### 思路\r\n1. hashMap + priority queue, 时间O(nlogn）空间O(N)\r\n2. bucket sort写了好几遍了，还是忘记\r\n\r\n### 代码\r\n```java\r\npublic int[] topKFrequent(int[] nums, int k) {\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        for(int i=0; i<nums.length; i++){\r\n            int count = map.getOrDefault(nums[i], 0)+1;\r\n            map.put(nums[i], count);\r\n        }\r\n        List<Integer>[] bucket = new List[nums.length+1];\r\n\r\n        for(int key : map.keySet()){\r\n            int index = map.get(key);\r\n            if(bucket[index] == null){\r\n                bucket[index] = new ArrayList<>();\r\n            }\r\n            bucket[index].add(key);\r\n        }\r\n\r\n        int[] result = new int[k];\r\n        int index = 0;\r\n        for(int i=bucket.length-1; i>=0; i--){\r\n            if(bucket[i] == null) continue;\r\n            for(int ele : bucket[i]){\r\n                if(index == k){\r\n                    break;\r\n                }\r\n                result[index] = ele;\r\n                index++;\r\n            }\r\n        }\r\n        return result;\r\n\r\n    }\r\n```\r\n\r\n###复杂度\r\n时间O(N)\r\n空间O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1457696047","body":"### 思路\r\n1. brute force失败， O(N^3)超时\r\n2. 用两个loop，outer loop 代表i，\r\n                               inner loop 代表j和k，每一个i都寻找 i j k，i k j 的combination\r\n                              如果有2个距离一样的，说明有2中combination，如果有3个一样的， ABC ACB BAC BCA CAB CBA,一共六种，所以是 N permutation 2， 简化一下就是n*(n-1)，算完clear map\r\n### 代码\r\n```java\r\npublic int numberOfBoomerangs(int[][] points) {\r\n\r\n        int result =0;\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        for(int i=0; i<points.length; i++){\r\n            for(int j=0; j<points.length; j++){\r\n                    if(i == j) continue;\r\n                    int x = points[j][0] -  points[i][0];\r\n                    int y = points[j][1] - points[i][1];\r\n                    int ij = x*x +y*y;\r\n                    \r\n                    int count = map.getOrDefault(ij, 0) +1;\r\n                    map.put(ij, count);\r\n                    //System.out.println(i +\" \" +j + \" \" + \" \" + ij);\r\n            }\r\n            for(int val : map.values()){\r\n                if(val >1){\r\n                    result+= val * (val-1);\r\n                }\r\n            }\r\n            map.clear();\r\n        }\r\n        //System.out.println(map.values());\r\n        \r\n \r\n        return result;\r\n    }\r\n\r\n```\r\n###复杂度\r\n时间 O(N^2)\r\n空间 O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457614969","body":"### 思路\r\n双指针，map用来存occurance of character\r\n双指针left， right，先挪right，如果条件不满足挪left只到条件满足\r\n\r\n### 代码\r\n```java\r\npublic int lengthOfLongestSubstring(String s) {\r\n        Map<Character, Integer> map = new HashMap<>();\r\n        int left = 0;\r\n        int right = 0;\r\n        int result = 0;\r\n        while(right < s.length()){\r\n\r\n            int count = map.getOrDefault(s.charAt(right), 0);\r\n            map.put(s.charAt(right), count+1);\r\n            \r\n\r\n            while(map.get(s.charAt(right)) > 1){\r\n                map.put(s.charAt(left), map.get(s.charAt(left))-1);\r\n                left++;\r\n            }\r\n            \r\n            result = Math.max(result, right - left +1);\r\n            right++;\r\n\r\n        }\r\n        return result;\r\n    }\r\n```\r\n\r\n### 复杂度\r\n时间 O(N)\r\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459140085","body":"### 思路\r\n想不出来，看的答案\r\n用一个mapA来存occurance of word in array\r\n在String S里，截取等长的substring，每一个substring一个mapB，比较mapA和mapB的occurance\r\n\r\n### 代码\r\n```java\r\npublic List<Integer> findSubstring(String s, String[] words) {\r\n        Map<String, Integer> map = new HashMap<>();\r\n        List<Integer> result = new ArrayList<>();\r\n        for(int i=0; i<words.length; i++){\r\n            map.put(words[i], map.getOrDefault(words[i], 0)+1);\r\n        }\r\n\r\n        int wordLen = words[0].length();\r\n        int count = words.length;\r\n        int subLen = wordLen * count;\r\n\r\n        for(int i=0; i< s.length()-subLen+1; i++){\r\n            String str = s.substring(i, i+subLen);\r\n            //System.out.println(str);\r\n            Map<String, Integer> strMap = new HashMap<>();\r\n\r\n            for(int j=0; j<str.length(); j+=wordLen){\r\n                String word = str.substring(j,j+wordLen);\r\n                //System.out.println(word);\r\n                if(map.get(word) == null){\r\n                    break;\r\n                }\r\n                strMap.put(word, strMap.getOrDefault(word, 0)+1);\r\n                System.out.println(j);\r\n                if(strMap.get(word) > map.get(word)){\r\n                    break;\r\n                }\r\n                \r\n                if(j == subLen - wordLen){\r\n                    result.add(i);\r\n                }\r\n            }\r\n            \r\n\r\n        }\r\n        return result;\r\n        \r\n    }\r\n```\r\n\r\n###复杂度\r\n时间 O(M*N) m is length of string, n is length of array words\r\n空间 O(M)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461321161","body":"### 思路\r\nHashMap + prefix sum\r\n有很多edge case / bug\r\n\r\n### 代码\r\n```java\r\npublic int minSubarray(int[] nums, int p) {\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        int target = 0;\r\n        int result = nums.length;\r\n        for(int i : nums) target = (target +i) % p;\r\n\r\n        // x x [x x x] x x\r\n        //   i     j\r\n        //map[j] - map[i] = target\r\n        int prefix = 0;\r\n        map.put(0, -1);\r\n        for(int i=0; i<nums.length; i++){\r\n            prefix = (prefix + nums[i]) % p;\r\n            map.put(prefix, i);\r\n            int diff = (prefix - target +p) % p;\r\n            if(map.containsKey(diff)){\r\n                result = Math.min(result, i - map.get(diff));\r\n            }\r\n            \r\n\r\n        }\r\n\r\n        return result == nums.length? -1: result;\r\n        \r\n    }\r\n```\r\n### 复杂度\r\n时间 O(N)\r\n空间 O(p) p = 有多少个不同的余数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463328683","body":"### 思路\r\n快慢指针\r\n\r\n### 代码\r\n```java\r\npublic ListNode middleNode(ListNode head) {\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n\r\n        while(fast != null && fast.next != null){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n \r\n        }\r\n        return slow;\r\n    }\r\n```\r\n###复杂度\r\n时间O(N)\r\n空间O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464952400","body":"### 思路\r\n快慢指针，slow代表 不重复的数字的index，所以return要的是不重复数字的number，所以return slow+1\r\n如果slow指的数字不等于fast指的数字，把fast的数字挪到slow的下一个\r\n\r\n### 代码\r\n```java\r\npublic int removeDuplicates(int[] nums) {\r\n        int slow = 0;\r\n        int fast = 0;\r\n        \r\n        while(fast < nums.length){\r\n            if(nums[slow] != nums[fast]){\r\n                slow++;\r\n                nums[slow] = nums[fast];\r\n            }\r\n            fast++;\r\n        }\r\n        return slow+1;\r\n    }\r\n```\r\n### 复杂度\r\n时间 O(N)\r\n空间 O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1464946458","body":"### 思路\r\nbinary search，use lower bound of mid, (start+end) /2\r\nif not exist, return the start index of number\r\n\r\n### 代码\r\n```java\r\npublic int searchInsert(int[] nums, int target) {\r\n\r\n        int start = 0;\r\n        int end = nums.length - 1;\r\n        //System.out.println(start +\" \" + end);\r\n        while(start <= end){\r\n            //take the lower mid for even elements\r\n            int mid = (start + end) /2;\r\n            if(nums[mid] == target){\r\n                return mid;\r\n            }else if(nums[mid] > target){\r\n                end = mid-1;\r\n            }else if(nums[mid] < target){\r\n                start = mid +1;\r\n            }\r\n            //System.out.println(start +\" \"+mid +\" \" + end);\r\n        }\r\n        return start; \r\n    }\r\n```\r\n\r\n### 复杂度\r\n时间 O(logN)\r\n空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465661003","body":"### 思路\r\nmonotonic decreasing deque\r\n存的是index of num\r\n如果 deque头 的index 不再窗口里面,  pollFIrst\r\n如果 deque尾 的index 的值 < nums[i], pollLast\r\n把deque头的值放进result里面\r\n\r\n### 代码\r\n```java\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        Deque<Integer> deque = new LinkedList<>();\r\n        int[] result = new int[nums.length-k+1];        \r\n\r\n        for(int i=0; i<nums.length; i++){\r\n            while(!deque.isEmpty() && (i - deque.peekFirst()+1) >k){\r\n                deque.pollFirst();\r\n            }\r\n            while(!deque.isEmpty() && nums[deque.peekLast()] < nums[i]){\r\n                deque.pollLast();\r\n            } \r\n            deque.addLast(i);\r\n\r\n            if(i+1 -k >=0){\r\n                result[i+1-k]  = nums[deque.peekFirst()];\r\n            }\r\n        }\r\n        return result;\r\n            \r\n    }\r\n```\r\n### 复杂度\r\n时间O(N)\r\n空间O(N)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467083385","body":"### 思路\r\ntrust : edges from vertex a to vertex b\r\nBuild a graph based on trust. Count the number of in-edge and out-edge\r\nif in-edge = n-1 and out-edge =0, it is the judge\r\n\r\n### 代码\r\n```java\r\npublic int findJudge(int n, int[][] trust) {\r\n        int[][] count = new int[n+1][n+1];\r\n\r\n        for(int i=0; i<trust.length; i++){\r\n            int a = trust[i][0];\r\n            int b = trust[i][1];\r\n\r\n            count[b][1]++;\r\n            count[a][0]++;\r\n\r\n\r\n        }\r\n\r\n        for(int i=1; i<count.length; i++){\r\n            if(count[i][0] == 0 && count[i][1] == n-1){\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n```\r\n###复杂度\r\n时间O(E) E is the length of trust\r\n空间O(N) N is the number of vertex(people)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473999563","body":"###思路\r\nup的次数和down的次数相等，left 次数和right的次数相等，回到原点，如果不是泽没有\r\n\r\n### 代码\r\n```java\r\n   public boolean judgeCircle(String moves) {\r\n        int x = 0;\r\n        int y = 0;\r\n\r\n        for(int i=0; i<moves.length(); i++){\r\n            char m = moves.charAt(i);\r\n            if(m == 'U'){\r\n                y +=1;\r\n            }else if(m == 'D'){\r\n                y-= 1;\r\n            }else if(m == 'L'){\r\n                x -= 1;\r\n            }else{\r\n                x +=1;\r\n            }\r\n        }\r\n\r\n        return x==0 && y==0;\r\n    }\r\n```\r\n### 复杂度\r\nO(N)\r\nO(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476822434","body":"### 思路\r\nuse  array size 26 to count the occurrence of character\r\ncondition 1 and 2, brute force with the prefix\r\n   edge case: A cannot change to 'z'\r\ncondition 3 count\r\n### 代码\r\n```java\r\n    public int minCharacters(String a, String b) {\r\n        int[] countA= new int[26];\r\n        int[] countB= new int[26];\r\n\r\n        for(int i=0; i<a.length(); i++){\r\n            char c = a.charAt(i);\r\n            countA[c-'a'] ++;\r\n        }\r\n        for(int i=0; i<b.length(); i++){\r\n            char c = b.charAt(i);\r\n            countB[c-'a'] ++;\r\n        }\r\n        int c1 = condition12(a, b, countA, countB);\r\n        int c2 = condition12(b, a, countB, countA);\r\n        int c3 = condition3(a, b, countA, countB);\r\n        System.out.println(c1 + \" \" + c2 + \" \" +c3);\r\n        int result = Math.min(c1,c2);\r\n\r\n        return Math.min(result, c3);\r\n    }\r\n    public int condition12(String a, String b,int[] countA,int[] countB){\r\n        int operation = Math.max(a.length(), b.length());\r\n        int prefixA = a.length();\r\n        int prefixB = 0;\r\n        \r\n        for(int i=0; i<26; i++){\r\n            int count =0;\r\n\r\n            if(i < 25){\r\n                prefixA -= countA[i];\r\n            }\r\n            count+= prefixA;\r\n\r\n            prefixB+=countB[i];\r\n            count+=prefixB;\r\n\r\n\r\n            operation = Math.min(count, operation);\r\n        }\r\n\r\n        return operation;\r\n\r\n\r\n    }\r\n    public int condition3(String a, String b,int[] countA,int[] countB){\r\n        int max = 0;\r\n        for(int i=0; i<26; i++){\r\n            max = Math.max(max, countA[i] +countB[i]);\r\n        }\r\n        return a.length()+b.length() - max;\r\n    }\r\n```\r\n###复杂度\r\n时间 O(max(m,n))\r\n空间 O(1)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1476723889","body":"### 思路\r\nquickSort\r\n\r\n###代码\r\n```java\r\n    public int[] sortArray(int[] nums) {\r\n        // quick sort\r\n        quickSort(nums,0, nums.length-1);\r\n        return nums;\r\n    }\r\n    public void quickSort(int[] nums, int start, int end){\r\n        if(start >= end){\r\n            return;\r\n        }\r\n        int pivot = partition(nums, start, end);\r\n        quickSort(nums, start, pivot-1);\r\n        quickSort(nums, pivot+1, end);\r\n    }\r\n    public int partition(int[] nums, int start, int end){\r\n        //number greater than or equal to 0.0 and less than 1.0.\r\n        int index = (int) (Math.random() *(end - start+1)) + start;\r\n        swap(nums, index, end);\r\n        int count = start;\r\n        for(int i=start; i < end; i++){\r\n            if(nums[i] < nums[end]){\r\n                swap(nums, i, count);\r\n                count++;\r\n            }\r\n        }\r\n        swap(nums, count, end);\r\n        return count;\r\n\r\n    }\r\n    public void swap(int[] nums, int x, int y){\r\n        int temp = nums[x];\r\n        nums[x] = nums[y];\r\n        nums[y] = temp;\r\n    }\r\n```\r\n###复杂度\r\n时间 O(nlogn)\r\n空间 O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480573040","body":"### 思路\r\nbinary search\r\n为什么要做 start+ (end-start) / 2， 而不是 (start+end)/2呢，因为如果最后一个element是 2^31 - 1, (start +end)就会overflow\r\n### 代码\r\n```java\r\npublic int firstBadVersion(int n) {\r\n        int start = 1;\r\n        int end = n;\r\n\r\n        while(start <=end){\r\n            int mid = start+ (end-start) / 2;\r\n\r\n\r\n            if(isBadVersion(mid) && !isBadVersion(mid-1)){\r\n                return mid;\r\n            }\r\n            if(isBadVersion(mid)){\r\n                end = mid;\r\n            }else{\r\n                start = mid+1;\r\n            }\r\n        }\r\n        return n;\r\n    }\r\n```\r\n### 复杂度\r\n时间 O(nlogn)\r\n空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482295493","body":"### 思路\r\n不会，看了答案\r\nmergeSort\r\n如果左边>右边*2， 那么左边剩下后面的（before mid）全都会大于右边*2\r\nedge case：如果是很大的int，乘以二会超过边界，所以需要用 2*（long）NUMBER\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    int count;\r\n    public int reversePairs(int[] nums) {\r\n        count =0;\r\n        mergeSort(nums, 0, nums.length-1);\r\n        \r\n        return count;\r\n    }\r\n    public void mergeSort(int[] nums, int start, int end){\r\n        if(start >= end){\r\n            return;\r\n        }\r\n        int mid = start+ (end - start)/2;\r\n\r\n        mergeSort(nums, start, mid);\r\n        mergeSort(nums, mid+1, end);\r\n        merge(nums, start, mid, end);\r\n    }\r\n\r\n    public void merge(int[] nums, int start, int mid, int end){\r\n        int[] temp = new int[end -start +1];\r\n        int left = start;\r\n        int right = mid+1;\r\n        int index = 0;\r\n        while(left<=mid && right <=end){\r\n            if(nums[left] < nums[right]){\r\n                temp[index] = nums[left];\r\n                left++;\r\n            }else{\r\n                temp[index] = nums[right];\r\n                right++;\r\n            }\r\n            index++;\r\n        }\r\n\r\n        while(left <=mid){\r\n            temp[index] = nums[left];\r\n            left++;\r\n            index++;\r\n        }\r\n        while(right <= end){\r\n            temp[index] = nums[right];\r\n            right++;\r\n            index++;\r\n        }\r\n        int tleft = start;\r\n        int tright = mid+1;\r\n        while(tleft<=mid && tright <=end){\r\n            //double cmp = double(nums[tleft]) - double(nums[tright]) - double(nums[tright]);\r\n            //if(cmp >0){\r\n            if(nums[tleft] > 2*(long)nums[tright]){\r\n                count+= (mid - tleft)+1;\r\n                tright++;\r\n            }else{\r\n                tleft++;\r\n            }\r\n        }\r\n\r\n        for(int i = start; i<=end; i++){\r\n            nums[i] = temp[i-start];\r\n        }\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n时间 O(nlogn)\r\n空间O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1486260200","body":"### 思路\r\ndijkstra\r\n\r\n### 代码\r\n```java\r\npublic int swimInWater(int[][] grid) {\r\n        //Dijkstra\r\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> grid[a[0]][a[1]] - grid[b[0]][b[1]]);\r\n        int[][] visited = new int[grid.length][grid.length];\r\n        int[][] dir = new int[][]{{0,1}, {1,0},{-1,0},{0,-1}};\r\n        int time = 0;\r\n        pq.add(new int[]{0,0});\r\n\r\n        while(!pq.isEmpty()){\r\n            int[] curr = pq.poll();\r\n            \r\n            time = Math.max(time, grid[curr[0]][curr[1]]);\r\n\r\n            if(curr[0] == grid.length-1 && curr[1] == grid.length-1){\r\n                return time;\r\n            }\r\n            visited[curr[0]][curr[1]] = 1;\r\n            for(int[] d: dir){\r\n\r\n                if(curr[0]+d[0]<0 || curr[0]+d[0]>=grid.length ||curr[1]+d[1]<0 || curr[1]+d[1]>=grid.length || visited[curr[0]+d[0]][curr[1]+d[1]] == 1){\r\n                continue;\r\n            }\r\n                pq.add(new int[]{curr[0]+d[0], curr[1]+d[1]});\r\n            }\r\n        }\r\n        return time;\r\n    }\r\n```\r\n\r\n### 复杂度\r\n时间 O(N^2)\r\n空间 O(N^2)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486272352","body":"### 思路\r\n滑动窗口\r\nend每一个loop开始向右滑动一次，记录currCount\r\nstart滑动条件： end-start>k，超过窗口大小start向右滑动，updatecurrCount\r\n\r\n### 代码\r\n```java\r\npublic int maxVowels(String s, int k) {\r\n        int start =0;\r\n        int end = 0;\r\n        Set<Character> vowel = new HashSet<>(Arrays.asList('a','e','i','o','u'));\r\n        int result =0;\r\n        int currCount = 0;\r\n\r\n        while(end < s.length()){\r\n            if(vowel.contains(s.charAt(end))){\r\n                currCount++;\r\n            }\r\n            end++;\r\n\r\n            while(end - start >k){\r\n                if(vowel.contains(s.charAt(start))){\r\n                    currCount--;\r\n                }\r\n                start++;\r\n            }\r\n            result = Math.max(result, currCount);\r\n        }\r\n        return result;\r\n    }\r\n```\r\n### 复杂度\r\n时间 O(N)\r\n空间 O(`)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488838453","body":"```Java\r\n\r\nclass Solution {\r\n    public double new21Game(int n, int k, int maxPts) {\r\n        if (n-k + 1 >= maxPts) {\r\n            return 1.0;\r\n        }\r\n\t\tdouble[] dp = new double[k+maxPts];\r\n        double sum = n-k+1;\r\n        for(int i=k; i<=n; i++){\r\n            dp[i] =1;\r\n        }\r\n        \r\n\t\tfor(int i=k-1; i>=0; i--){\r\n            dp[i] = sum / (maxPts);\r\n            sum = sum - dp[i+maxPts]+ dp[i];\r\n        }\r\n        return dp[0];\r\n    }\r\n}\r\n\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493377772","body":"### 思路\r\n枚举，共2……0 = 1024种可能\r\nhour前4位，minute后6位\r\ncheck condition：\r\n1.  hour <12 && min<60\r\n2. 时间代表的binary number的1的个数 = turnon\r\n\r\n### 代码\r\n```java\r\npublic List<String> readBinaryWatch(int turnedOn) {\r\n        List<String> result = new ArrayList<>();\r\n        // 2^10 = 1024 种灯的开闭组合\r\n        for(int i=0; i< 1024; i++){\r\n            int hour = i>>6;\r\n            int min = i&63;\r\n            \r\n            if(hour <12 && min <60 && Integer.bitCount(i) == turnedOn){\r\n                if(min < 10){\r\n                    result.add(hour+\":0\"+min);\r\n                }else{\r\n                    result.add(hour+\":\"+min);\r\n                }\r\n                \r\n            }\r\n        }\r\n        return result;\r\n    }\r\n```\r\n### 复杂度\r\n时间 O(1)\r\n空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494584802","body":"### 思路\r\nbackTracking\r\n用index 来代表queen\r\nCheckisValid只需要check column 上面，左上，右上\r\n### 代码\r\n```java\r\npublic int totalNQueens(int n) {\r\n        List<Set> result = new ArrayList<>();\r\n        backTrack(n, result, new HashSet<Integer>(), 0);\r\n        //System.out.print(result);\r\n        return result.size();\r\n    }\r\n    public void backTrack(int n, List<Set> result, HashSet<Integer> set,int row){\r\n        if(row == n){\r\n            result.add(new HashSet<>(set));\r\n            return;\r\n        }\r\n        //column\r\n        for(int i=0; i<n; i++){\r\n            if(!isValid(row, i, n, set)){\r\n                continue;\r\n            }\r\n            //HashSet<Integer> dupSet= new HashSet<Integer>(set);\r\n            //dupSet.add(row*n+i);\r\n            set.add(row*n+i);\r\n            //System.out.print(set);\r\n            backTrack(n, result, set, row+1);\r\n            set.remove(row*n+i);\r\n\r\n        }\r\n    }\r\n    public boolean isValid(int row, int col, int n, HashSet<Integer> set){\r\n        //check column\r\n        for(int i=0; i<=row; i++){\r\n            if(set.contains(n*i+col)){\r\n                return false;\r\n            }\r\n        }\r\n        int cRow = row;\r\n        int cCol = col;\r\n\r\n        while(cRow>=0 && cCol>=0){\r\n            if(set.contains(cRow*n+cCol)){\r\n                return false;\r\n            }\r\n            cRow--;\r\n            cCol--;\r\n        }\r\n        cRow = row;\r\n        cCol = col;\r\n\r\n        while(cRow>=0 && cCol<n){\r\n            if(set.contains(cRow*n+cCol)){\r\n                return false;\r\n            }\r\n            cRow--;\r\n            cCol++;\r\n        }\r\n        return true;\r\n\r\n    }\r\n```\r\n### 复杂度\r\n时间 O(N!*N)\r\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1496148950","body":"### 思路\r\ndfs，\r\n不用visited来track，直接修改grid\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    int maxArea;\r\n    public int maxAreaOfIsland(int[][] grid) {\r\n        maxArea =0;\r\n        for(int i=0; i<grid.length; i++){\r\n            for(int j=0; j< grid[0].length; j++){\r\n                if(grid[i][j] == 0){\r\n                    continue;\r\n                }\r\n                maxArea = Math.max(maxArea, dfs(grid, i, j));\r\n            }\r\n        }\r\n        return maxArea;\r\n    }\r\n    \r\n    public int dfs(int[][] grid, int i, int j){\r\n        if(grid[i][j] == 0){\r\n            return 0;\r\n        }\r\n        int result = 1;\r\n        grid[i][j] = 0;\r\n        if(i-1 >=0){\r\n            result+= dfs(grid, i-1, j);\r\n        }\r\n        if(i+1 <grid.length){\r\n            result+= dfs(grid,i+1, j);\r\n        }\r\n        if(j-1 >=0){\r\n            result+= dfs(grid,i, j-1);\r\n        }\r\n        if(j+1 <grid[0].length){\r\n            result+= dfs(grid,i, j+1);\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n时间 O(N) N=number of element in grid\r\n空间 O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498359316","body":"### 思路\r\nBFS\r\n需要注意的是，你需要既能access到box又有钥匙，所以新加一个openable array to keep track of openable boxes\r\n### 代码\r\n```java\r\n    public int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {\r\n        int maxCandies = 0;\r\n        Queue<Integer> queue = new LinkedList<>();\r\n        int[] openable = new int[status.length];\r\n        for(int box : initialBoxes){\r\n            if(status[box] == 1){\r\n                //System.out.println(box);\r\n                queue.offer(box);\r\n            }else{\r\n                openable[box] =1;\r\n            }\r\n        }\r\n        int result = 0;\r\n        while(!queue.isEmpty()){\r\n            int size = queue.size();\r\n            for(int i=0; i<size; i++){\r\n                int box = queue.poll();\r\n                result+= candies[box];\r\n                status[box] = -1;\r\n                \r\n                for(int child : keys[box]){\r\n                    if(status[child] == 0){\r\n                        //System.out.println(box);\r\n                        status[child] = 1;\r\n                    }\r\n                }\r\n                for(int child : containedBoxes[box]){\r\n                        openable[child] =1;\r\n                }\r\n                for(int j = 0; j<openable.length; j++){\r\n                    if(openable[j] == 1 && status[j] ==1){\r\n                        queue.offer(j);\r\n                        openable[j] = 0;\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n```\r\n### 复杂度\r\n O(N) N = number of boxes \r\n O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1500411202","body":"### 思路\r\n用自己的map的思路太复杂了，implement不好写\r\n看了题解，都是逐级比较，override comparator更好写些。\r\n    new Comparator<int[]>(){\r\n        public int compare(int[] a, int[] b){\r\n            // do some comparsion\r\n            return ;\r\n        }\r\n    };\r\n\r\n### 代码\r\n```java\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        List<int[]> nodes = new ArrayList<>();\r\n        traverse(root, nodes, 0, 0);\r\n        Collections.sort(nodes, new Comparator<int[]>(){\r\n            public int compare(int[] a, int[] b){\r\n                if(a[0]!= b[0]){\r\n                    return a[0] - b[0];\r\n                }else if(a[1] != b[1]){\r\n                    return a[1] - b[1];\r\n                }else{\r\n                    return a[2] - b[2];\r\n                }\r\n            }\r\n        });\r\n        List<List<Integer>> result = new ArrayList<>();\r\n        int col = Integer.MIN_VALUE;\r\n        for(int[] node : nodes){\r\n            if(col != node[0]){\r\n                col = node[0];\r\n                result.add(new ArrayList<>());\r\n            }\r\n            result.get(result.size() -1).add(node[2]);\r\n        }\r\n        return result;\r\n    }\r\n    public void traverse(TreeNode root, List<int[]> nodes, int row, int col){\r\n        if(root == null){\r\n            return;\r\n        }\r\n        nodes.add(new int[]{col, row, root.val});\r\n        traverse(root.left, nodes, row+1, col-1);\r\n        traverse(root.right, nodes, row+1, col+1);\r\n    }\r\n```\r\n### 复杂度\r\n时间 O(nlogn)\r\n空间 O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500916612","body":"### 思路\r\ndp\r\n### 代码\r\n```java\r\npublic int minCostClimbingStairs(int[] cost) {\r\n        int[] dp = new int[cost.length+1];\r\n\r\n        for(int i=0; i<dp.length; i++){\r\n            if(i<=1){\r\n                dp[i] = 0;\r\n                continue;\r\n            }\r\n            dp[i] = Math.min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]);\r\n        }\r\n        return dp[dp.length-1];\r\n    }\r\n```\r\n### 复杂度\r\n时间 O(N)\r\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501044646","body":"### 思路\r\ndp\r\ndp[i] 分两种情况 :\r\n1. 偷房子i => nums[i] + dp[i-2]\r\n2.  不偷房子i => dp[i-1]\r\n两者取max\r\n                           \r\n\r\n\r\n### 代码\r\n```java\r\npublic int rob(int[] nums) {\r\n        if(nums.length == 1){\r\n            return nums[0];\r\n        }\r\n        int[] dp = new int[nums.length];\r\n        dp[0] = nums[0];\r\n        dp[1] = Math.max(dp[0], nums[1]);\r\n        \r\n        for(int i=2; i<nums.length; i++){\r\n            dp[i] = Math.max(dp[i-2]+nums[i], dp[i-1]);\r\n        }\r\n        return dp[nums.length-1];\r\n    }\r\n```\r\n### 复杂度\r\n时间 O(N)\r\n空间 O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501589909","body":"    public int findNumberOfLIS(int[] nums) {\r\n        int maxLen = 0;\r\n        // length of longest LIS\r\n        int[] len = new int[nums.length];\r\n        // count\r\n        int[] count = new int[nums.length];\r\n        int result =0;\r\n        for(int i=0; i<nums.length; i++){\r\n            len[i] = 1;\r\n            count[i] = 1;\r\n            for(int j=0; j<i; j++){\r\n                if(nums[i] > nums[j]){\r\n                    if(len[i] == len[j]+1){\r\n                        System.out.println(i +\" \"+ j);\r\n                        count[i] += count[j];\r\n                    }\r\n                    if(len[i] < len[j]+1){\r\n                        len[i] = len[j]+1;\r\n                        count[i] = count[j];\r\n                    }\r\n                    \r\n                }\r\n            }\r\n            if(maxLen == len[i]){\r\n                result+=count[i];\r\n            }\r\n            if(maxLen < len[i]){\r\n                maxLen = len[i];\r\n                result = count[i];\r\n            }\r\n        }\r\n        System.out.println(Arrays.toString(len));\r\n        System.out.println(Arrays.toString(count));\r\n        return result;\r\n\r\n\r\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1502651721","body":"```java \r\nint[][] m = new int[s.length() +1][t.length() +1];\r\n        for (int i=s.length()-1; i>=0; i--) {\r\n            for (int j=t.length()-1; j>=0; j--) {\r\n                if (s.charAt(i) == t.charAt(j)) {\r\n                    m[i][j] = m[i+1][j+1] + 1;\r\n                } else {\r\n                    m[i][j] = Math.max(m[i+1][j], m[i][j+1]);\r\n                }\r\n            }\r\n        }\r\n        return m[0][0];\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1505507745","body":"### 思路\r\n二维爬了楼梯\r\ndp\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int uniquePaths(int m, int n) {\r\n        int[][] dp = new int[m][n];\r\n        for(int i=0; i<m;i++){\r\n            dp[i][0] = 1;\r\n        }\r\n        for(int j=0; j<n; j++){\r\n            dp[0][j] = 1;\r\n        }\r\n        for(int i=1; i<m;i++){\r\n            for(int j=1; j<n; j++){\r\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\r\n            }\r\n        }\r\n        return dp[m-1][n-1];\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n时间 O(M*N)\r\n空间 O(M*N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1507174542","body":"### 思路\r\ndp\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public double knightProbability(int n, int k, int row, int column) {\r\n        int[][] dir = new int[][]{{1, -2}, {2, -1}, {2, 1}, {1,2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1,-2}};\r\n        double[][] dp = new double[n][n];\r\n        dp[row][column] = 1;\r\n\r\n        for(int step =0; step<k; step++){\r\n            double[][] tempDp = new double[n][n];\r\n            for(int i=0; i<n; i++){\r\n                for(int j=0; j<n; j++){\r\n                    for(int[] d: dir){\r\n                        int x = i - d[0];\r\n                        int y = j - d[1];\r\n                        if(x>=0 && x<n && y>=0 && y<n){\r\n                            tempDp[i][j] += dp[x][y]*0.125;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            dp = tempDp;\r\n        }\r\n\r\n        double result = 0;\r\n        for(int i=0; i<n; i++){\r\n            for(int j=0; j<n; j++){\r\n                result+=dp[i][j];\r\n            }\r\n        }\r\n        return result;\r\n                \r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n时间 O(k*N^2)\r\n空间  O(k*N^2)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"paopaohua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dd2001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mayloveless":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuexi001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nineis7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"abby-xu":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429186782","body":"合并list -> 加上k -> 拆分为list\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        return [int(a) for a in str(int(''.join(map(str,num)))+k)]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430833276","body":"```\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size(), pos = -n;\n        vector<int> res(n,n);\n        for (int i = 0; i < n; i++) {\n            if (s[i] == c) pos = i;\n            res[i] = i - pos;\n        }\n        for (int i = pos - 1; i >= 0; i--) {\n            if (s[i] == c) pos = i;\n            res[i] = min(res[i], pos - i);\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432418838","body":"```\nclass CustomStack {\n    vector<int> stack;\n    int n;\npublic:\n    CustomStack(int maxSize) {\n        n = maxSize;\n    }\n    \n    void push(int x) {\n        if (stack.size() == n) return;\n        if (stack.size() < n) stack.push_back(x);\n    }\n    \n    int pop() {\n        if(stack.size()==0)\n            return -1;\n        int x=stack.back();\n        stack.pop_back();\n        return x;\n    }\n    \n    void increment(int k, int val) {\n        int x=k;\n        if(stack.size()<k)\n            x=stack.size();\n        for(int i=0;i<x;i++) {\n            stack[i]+=val;\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434174727","body":"```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        current_string = \"\"\n        k = 0\n\n        for char in s:\n            if char == \"[\":\n                # Just finished parsing this k, save current string and k for when we pop\n                stack.append((current_string, k))\n                # Reset current_string and k for this new frame\n                current_string = \"\"\n                k = 0\n            elif char == \"]\":\n                # We have completed this frame, get the last current_string and k from when the frame \n                # opened, which is the k we need to duplicate the current current_string by\n                last_string, last_k = stack.pop(-1)\n                current_string = last_string + last_k * current_string\n            elif char.isdigit():\n                k = k * 10 + int(char)\n            else:\n                current_string += char\n\n        return current_string\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435491976","body":"```\nclass MyQueue:\n\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n\n    def push(self, x):\n        self.s1.append(x)\n\n    def pop(self):\n        self.peek()\n        return self.s2.pop()\n\n    def peek(self):\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n        return self.s2[-1]        \n\n    def empty(self):\n        return not self.s1 and not self.s2 \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435903870","body":"```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        s = []\n        for i,a in enumerate(arr):\n            maxi = a\n            while s and s[-1] > a:\n                maxi = max(maxi,s.pop())\n            s.append(maxi)\n        return len(s)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436365541","body":"```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return None\n      \n      #check the length\n        lastNode, length = head, 1\n        while lastNode.next:\n            lastNode = lastNode.next\n            length += 1\n\n        # check the number of rotation\n        k = k % length\n\n      # setlast node point to the first node\n        lastNode.next = head\n\n      #traverse until (length - k) node\n        temp = head\n        for i in range(length - k - 1): temp = temp.next\n\n      #disconnect the first and last node\n        out = temp.next\n        temp.next = None\n\n        return out\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439434999","body":"```\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head: return None\n        if not head.next: return TreeNode(head.val)\n\n        pre, slow, fast = None, head, head\n\n        # find the middle node of the linked list\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        if pre: pre.next = None\n\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n\n        return root\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441182993","body":"```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        p, q = headA, headB\n        while p != q:\n            p = p.next if p else headB\n            q = q.next if q else headA\n        return p\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445018954","body":"```\nclass LRUCache:\n\n    def __init__(self, capacity):\n        self.dic = collections.OrderedDict()\n        self.remain = capacity\n\n    def get(self, key):\n        if key not in self.dic:\n            return -1\n        v = self.dic.pop(key) \n        self.dic[key] = v   # set key as the newest one\n        return v\n\n\n    def put(self, key, value):\n        if key in self.dic:    \n            self.dic.pop(key)\n        else:\n            if self.remain > 0:\n                self.remain -= 1  \n            else:  # self.dic is full\n                self.dic.popitem(last=False) \n        self.dic[key] = value\n```   ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445266396","body":"class Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445699421","body":"```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        # BFS\n        # queue = [(p, q)]\n        # while queue:\n        #     node1, node2 = queue.pop(0)\n        #     if not node1 and not node2: # no child\n        #         continue\n        #     elif None in [node1, node2]:\n        #         return False\n        #     else:\n        #         if node1.val != node2.val:\n        #             return False\n        #         queue.append((node1.left, node2.left))\n        #         queue.append((node1.right, node2.right))\n        # return True\n\n        #DFS\n        if not p and not q: return True\n        if not p or not q: return False\n        return p.val == q.val and self.isSameTree(q.left, p.left) and self.isSameTree(q.right, p.right)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447537901","body":"```\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        p = {root: root.val}\n        c = dict()\n        res = 0\n        while p:\n            for node, number in p.items():\n                if node.left:\n                    c[node.left] = number*10 + node.left.val\n                if node.right:\n                    c[node.right] = number*10 + node.right.val\n                if not node.left and not node.right:\n                    res += number\n            p = c\n            c = dict()\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449095016","body":"```\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        res = []\n        self.dfs(root, res, 0)\n        return res[-1][0]\n    \n    def dfs(self, root, res, level):\n        if not root: return\n        if level == len(res): res.append([])\n        res[level].append(root.val)\n        self.dfs(root.left, res, level + 1)\n        self.dfs(root.right, res, level + 1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451292288","body":"```\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        def rserialize(root, string):\n            \"\"\" a recursive helper function for the serialize() function.\"\"\"\n            # check base case\n            if root is None:\n                string += 'None,'\n            else:\n                string += str(root.val) + ','\n                string = rserialize(root.left, string)\n                string = rserialize(root.right, string)\n            return string\n        \n        return rserialize(root, '')\n        \n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def rdeserialize(l):\n            \"\"\" a recursive helper function for deserialization.\"\"\"\n            if l[0] == 'None':\n                l.pop(0)\n                return None\n                \n            root = TreeNode(l[0])\n            l.pop(0)\n            root.left = rdeserialize(l)\n            root.right = rdeserialize(l)\n            return root\n\n        data_list = data.split(',')\n        root = rdeserialize(data_list)\n        return root\n```  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1455004195","body":"class Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        g = collections.defaultdict(list) \n        queue = [(root,0)]\n        while queue:\n            new = []\n            d = collections.defaultdict(list)\n            for node, s in queue:\n                d[s].append(node.val) \n                if node.left:  new += (node.left, s-1), \n                if node.right: new += (node.right,s+1),  \n            for i in d: g[i].extend(sorted(d[i]))\n            queue = new\n        return [g[i] for i in sorted(g)]","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455004457","body":"```\n        import heapq\n        from collections import Counter, defaultdict\n        heap = [(-1*v1, k1) for k1,v1 in Counter(nums).items()] # O(N) to build the heap\n        heapq.heapify(heap) # O((n-k) log n). Worst case O(n log n).\n        result = []\n        for i in range(k):\n            result.append(heapq.heappop(heap)[1]) # O(logN) / O((n-k) log n) for the pops\n        return result\n``` ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455410384","body":"```\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans=0\n        for i in points:\n            a={}\n            for j in points:\n                c=(i[0]-j[0])**2+(i[1]-j[1])**2\n                if c not in a:\n                    a[c]=1\n                else:\n                    ans+=a[c]\n                    a[c]+=1\n        return ans*2\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457602803","body":"class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        # dic = {}\n        # res, last_match = 0, -1\n        # for i, c in enumerate(s):\n        #     if c in dic and last_match < dic[c]:\n        #         last_match = dic[c]\n        #     res = max(res, i - last_match)\n        #     dic[c] = i\n        # return res\n        seen = {}\n        l = 0\n        output = 0\n        for r in range(len(s)): #sliding window\n            if s[r] not in seen: # keep increasing the window size\n                output = max(output,r-l+1)\n            else:\n                if seen[s[r]] < l: # s[r] is inside the current window\n                    output = max(output,r-l+1) \n                else: # s[r] is not inside the current window\n                    l = seen[s[r]] + 1\n            seen[s[r]] = r\n        return output","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459303642","body":"```python\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        word_len = len(words[0])\r\n        ori_word_dict = defaultdict(int)\r\n\t\t\r\n        for word in words:\r\n            ori_word_dict[word] += 1\r\n        \r\n        all_word_len = len(words) * word_len\r\n        result = []\r\n        for i in range(word_len):\r\n            queue = deque()\r\n            word_dict = ori_word_dict.copy()\r\n            for j in range(i, len(s) - word_len + 1, word_len):\r\n                word = s[j:j + word_len]\r\n                if word_dict.get(word, 0) != 0:\r\n                    word_dict[word] -= 1\r\n                    queue.append(word)\r\n                    if sum(word_dict.values()) == 0:\r\n                        result.append(j - all_word_len + word_len)\r\n                        last_element = queue.popleft()\r\n                        word_dict[last_element] = word_dict.get(last_element, 0) + 1\r\n                else:\r\n                    while len(queue):\r\n                        last_element = queue.popleft()\r\n                        if last_element == word:\r\n                            queue.append(word)\r\n                            break\r\n                        else:\r\n                            word_dict[last_element] = word_dict.get(last_element, 0) + 1\r\n                            if word_dict[last_element] > ori_word_dict[last_element]:\r\n                                word_dict = ori_word_dict.copy()\r\n\r\n        return result\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461342464","body":"```\nclass Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        preSum = 0\n        count = 0\n        d = {0:1}\n        for i in range(len(nums)):\n            preSum = (preSum + nums[i]) % k\n            count += d.get(preSum, 0)\n            d[preSum] = d.get(preSum, 0) +1\n        return count\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463228867","body":"```python\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464846307","body":"```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        # need to check length if no mentioned\n        # if len(nums) == 0: return 0\n        x = 1\n        for i in range(len(nums)-1):\n            if nums[i] != nums[i+1]:\n                nums[x] = nums[i+1]\n                x+=1\n        return x\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465102234","body":"```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums)-1\n        while l <= r:\n            mid = int(l+(r-l)/2)\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return r + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465531976","body":"class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        class MaxStack:\n            def __init__(self):\n                self._stack = []\n                self._max_stack = []\n\n            def push(self, item):\n                self._stack.append(item)\n                self._max_stack.append(\n                    max(item, self._max_stack[-1]) if self._max_stack else item\n                )\n\n            def pop(self):\n                self._max_stack.pop()\n                return self._stack.pop()\n\n            def get_max(self):\n                return self._max_stack[-1] if self._max_stack else int(-1e6)\n\n            def empty(self):\n                return not self._stack\n\n        left = MaxStack()\n        right = MaxStack()\n        answer = []\n\n        for ind in range(k):\n            left.push(nums[ind])\n\n        for ind in range(k, len(nums)):\n            if right.empty():\n                while not left.empty():\n                    right.push(left.pop())\n\n            answer.append(max(left.get_max(), right.get_max()))\n            left.push(nums[ind])\n            right.pop()\n        answer.append(max(left.get_max(), right.get_max()))\n        return answer","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467330420","body":"```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        trusts = [0] * (n+1)\n        for (a, b) in trust:\n            trusts[a] -= 1\n            trusts[b] += 1\n            \n        for i in range(1, len(trusts)):\n            if trusts[i] == n-1: return i\n        return -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469205561","body":"```python\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        dislike = [[] for _ in range(n)]\n        for a, b in dislikes:\n            dislike[a-1].append(b-1)\n            dislike[b-1].append(a-1)\n\n        groups = [0] * n\n        for p in range(n):\n            if groups[p] == 0:\n                groups[p] = 1\n                q = deque([p])\n                while q: # bfs\n                    a = q.pop()\n                    for b in dislike[a]:\n                        if groups[b] == 0:\n                            groups[b] = 1 if groups[a] == 2 else 2\n                            q.appendleft(b)\n                        elif groups[a] == groups[b]:\n                            return False\n        return True\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473028788","body":"class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        return moves.count('U')==moves.count('D') and moves.count('R')==moves.count('L') if len(moves)%2 == 0 else False","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474660887","body":"```python\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        res = []\n        tasks = sorted([(t[0], t[1], i) for i, t in enumerate(tasks)])\n        i = 0\n        h = []\n        time = tasks[0][0]\n        while len(res) < len(tasks):\n            while (i < len(tasks)) and (tasks[i][0] <= time):\n                heapq.heappush(h, (tasks[i][1], tasks[i][2])) # (processing_time, original_index)\n                i += 1\n            if h:\n                t_diff, original_index = heapq.heappop(h)\n                time += t_diff\n                res.append(original_index)\n            elif i < len(tasks):\n                time = tasks[i][0]\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475111956","body":"```python\nclass Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        start_hour, start_min = int(loginTime[:2]), int(loginTime[3:])\n        end_hour, end_min = int(logoutTime[:2]), int(logoutTime[3:])\n        if (start_hour > end_hour) or (start_hour == end_hour and start_min > end_min):\n            end_hour += 24\n        answer = 0\n        minutes = [0, 15, 30, 45]\n        if not (start_hour == end_hour and start_min <= end_min):\n            answer += 4 * (end_hour - start_hour - 1) + 4 - bisect_left(minutes, start_min) + bisect_right(minutes, end_min) - 1\n        else:\n            for i in range(3):\n                if start_min <= minutes[i] and minutes[i + 1] <= end_min:\n                    answer += 1\n        return answer\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475498865","body":"```python\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        def count(s):\n            arr = [0 for i in range(26)]\n            for c in s:\n                arr[ord(c) - ord('a')] += 1\n            return arr\n        \n        c1 = count(a)\n        c2 = count(b)\n        \n        def helper(c1, c2):\n            res = float('inf')\n            moveC1 = sum(c1) # move all in c1 to be less or equal\n            moveC2 = 0 # move all in c2 to be greater\n            for i in range(25):\n                moveC1 -= c1[i]\n                moveC2 += c2[i]\n                res = min(res, moveC1 + moveC2)\n            return res\n        \n        def helper3(c1, c2):\n            res = float('inf')\n            sum1 = sum(c1)\n            sum2 = sum(c2)\n            for i in range(26):\n                res = min(res, sum1 - c1[i] + sum2 - c2[i])\n            return res\n        \n        res1 = helper(c1, c2)\n        res2 = helper(c2, c1)\n        res3 = helper3(c1, c2)\n        return min([res1, res2, res3])\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477275798","body":"```python\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        # Runtime: O(nlogn) expected, O(n^2) worst case\n        # Space: O(n) expected, O(n^2) worst case\n        if len(nums) <= 1: return nums\n\n        pivot = random.choice(nums)\n        lt = [v for v in nums if v < pivot]\n        eq = [v for v in nums if v == pivot]\n        gt = [v for v in nums if v > pivot]\n\n        return self.sortArray(lt) + eq + self.sortArray(gt)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1478939331","body":"```python\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 1: return 1\n        l, r = 0, x\n        while l <= r:\n            mid_v = l+(r-l) // 2\n            if mid_v*mid_v <= x < (mid_v+1)*(mid_v+1):\n                return mid_v\n            elif mid_v*mid_v > x:\n                r = mid_v - 1\n            else:\n                l = mid_v + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480636290","body":"```python\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        if n == 1 and isBadVersion(n): return n\n        l, r = 1, n\n        while l <= r:\n            mid = int((l+r)/2)\n            if isBadVersion(mid):\n                if not isBadVersion(mid - 1):\n                    return int(mid)\n                r = mid - 1\n            else:\n                l = mid + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482233650","body":"```python\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        def h(nums):\n            if len(nums) <= 1: return nums, 0\n            mid = len(nums) // 2\n            lArr, lRes, rArr, rRes = *h(nums[:mid]), *h(nums[mid:])\n            res, rIndex = lRes + rRes, 0\n            for n in lArr:\n                while rIndex < len(rArr) and rArr[rIndex] * 2 < n: rIndex += 1\n                res += rIndex\n            return sorted(nums), res \n        return h(nums)[1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483738093","body":"```python\nclass Solution:\n    def solve(self, nums):\n        nums.sort()\n        N = len(nums)\n        if N <= 3:\n            return 0\n        LIGHTS = 3\n        def possible(diameter):\n            start = nums[0]\n            end = start + diameter\n            for i in range(LIGHTS):\n                idx = bisect_right(nums, end)\n                if idx >= N:\n                    return True\n                start = nums[idx]\n                end = start + diameter\n            return False\n\n        l, r = 0, nums[-1] - nums[0]\n        while l <= r:\n            mid = (l + r) // 2\n            if possible(mid):\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l / 2\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1483968712","body":"```python\nclass Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n        def feasible(val):\n            i,j,cnt = 0,1,0\n            while j<n:\n                while i<j and abs(nums[j]-nums[i]) > val:\n                    i+=1\n                cnt+=j-i\n                j+=1\n            return cnt>=k\n        low = 0\n        high = nums[-1] - nums[0]\n        while low<high:\n            mid = low+high>>1\n            if feasible(mid):\n                high = mid\n            else:\n                low=mid+1\n        return low\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484485917","body":"```python\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        nums_rows = num_cols = len(grid)\n        \n        def get_neighbors(row, col):\n            delta_rows = [-1, 0, 1, 0]\n            delta_cols = [0, 1, 0, -1]\n            neighbors = []\n            for i in range(len(delta_rows)):\n                new_row = row + delta_rows[i]\n                new_col = col + delta_cols[i]\n                if new_row < 0 or new_row >= nums_rows or new_col < 0 or new_col >= num_cols:\n                    continue\n                neighbors.append((new_row, new_col))\n            \n            return neighbors\n        \n        min_heap = [(grid[0][0], (0, 0))]\n        heapq.heapify(min_heap)\n        curr_max = float('-inf')\n        visited = set()\n        while min_heap:\n            val, (row, col) = heapq.heappop(min_heap)\n            if (row, col) in visited:\n                continue\n            visited.add((row, col))\n            \n            if (row, col) == (nums_rows - 1, num_cols - 1):\n                return max(curr_max, grid[nums_rows - 1][num_cols - 1])\n            \n            curr_max = max(curr_max, val)\n            for neighbor in get_neighbors(row, col):\n                nr, nc = neighbor\n                heapq.heappush(min_heap, (grid[nr][nc], (nr, nc)))\n        \n        return -1 \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486252678","body":"```python\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        i,c,m,n=0,0,0,len(s)\n        for j in range(n):\n            if s[j] in 'aeiou':\n                c+=1\n            if j-i+1==k:\n                m=max(m,c)\n                if s[i] in 'aeiou':\n                    c-=1\n                i+=1\n        return m\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1487903468","body":"```python\nclass Solution:\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\n        dp = [0 for i in range(k)] + [1 for i in range(k, 1 + n)] + [0 for i in range(maxPts)] \n        Win = float(sum(dp[k : k + maxPts])) \n        for i in range(k-1,-1,-1):\n            dp[i] = Win / maxPts\n            Win += dp[i] - dp[i + maxPts]\n        return dp[0]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489643413","body":"```python\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        count1 = collections.Counter(p)\n        count2 = collections.Counter(s[:len(p)])\n        i, j = 0, len(p)\n        size = len(s)\n        ans = []\n        while j <= size:\n            if count2 == count1:\n                ans += i,\n            if j < size:\n                count2[s[j]] += 1\n            count2[s[i]] -= 1\n            if count2[s[i]]==0:\n                del count2[s[i]]\n            i += 1\n            j += 1\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491328726","body":"class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        from collections import Counter\n    \n        temp = Counter(t)\n        count = len(temp)\n\n        i, j = 0, 0\n        string = \"\"\n        mini = 10 ** 6\n\n        while j < len(s):           \n            if s[j] in temp:\n                temp[s[j]] -= 1\n                if temp[s[j]] == 0:\n                    count -= 1\n\n            while count == 0 and i <= j:\n\n                if (j - i + 1) < mini:\n                    mini = (j - i + 1)\n                    string = s[i: j + 1]\n\n                if s[i] in temp:\n                    temp[s[i]] += 1\n                    if temp[s[i]] == 1:\n                        count += 1\n\n                i += 1        \n            j += 1               \n        return string","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1492848477","body":"```python\nclass Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n\n        leftMap = dict()\n        leftMap[0] = -1\n        left = 0\n        for i in range(n):\n            left += nums[i]\n            if left not in leftMap:\n                leftMap[left] = i\n\n        right = 0\n        ans = n + 1\n        for i in range(n, -1, -1):\n            if i < n:  right += nums[i]\n            left = x - right\n            if left in leftMap:  # left + right = x -> left = x - right\n                ans = min(ans, leftMap[left] + 1 + n - i)\n        if ans == n + 1: return -1\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493245811","body":"class Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        if turnedOn > 8:\n            return []\n        ans = []\n        for h in range(12):\n            for m in range(60):\n                if(bin(h).count(\"1\") + bin(m).count(\"1\") == turnedOn):\n                    ans.append(f\"{str(h)}:{str(m).rjust(2, '0')}\")\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1493549276","body":"```python\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        self.res = 0\n        self.dfs([-1]*n, 0)\n        return self.res\n\n    def dfs(self, nums, index):\n        if index == len(nums):\n            self.res += 1\n            return #backtracking\n        for i in range(len(nums)):\n            nums[index] = i\n            if self.valid(nums, index):\n                self.dfs(nums, index+1)\n\n    def valid(self, nums, n):\n        for i in range(n):\n            if nums[i] == nums[n] or abs(nums[n]-nums[i]) == n-i:\n                return False\n        return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495173943","body":"```python\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        def dfs(x,y):\n            if grid[x][y] == 1:\n                grid[x][y] = -1\n                res = 1\n            else:\n                return 0\n            if x + 1 < len(grid):\n                res += dfs(x+1,y) \n            if x - 1 >= 0:\n                res += dfs(x-1,y) \n            if y + 1 < len(grid[0]):\n                res += dfs(x,y+1)\n            if y - 1 >= 0:\n                res += dfs(x,y-1)\n            return res\n            \n        seen = set()\n        max_area = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    max_area = max(max_area, dfs(i,j))\n        \n        return max_area\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1496651295","body":"```python\nclass Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        dist = [[float('inf') for _ in grid[0]] for _ in grid]\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    dist[i][j] = 0\n                    continue\n                if i-1 >= 0:\n                    dist[i][j] = min(dist[i-1][j]+1, dist[i][j])\n                if j-1 >= 0:\n                    dist[i][j] = min(dist[i][j-1]+1, dist[i][j])\n        maxer = -1\n        for i in range(len(grid)-1, -1, -1):\n            for j in range(len(grid[0])-1, -1, -1):\n                if grid[i][j] == 1:\n                    dist[i][j] = 0\n                    continue\n                if i+1 < len(grid):\n                    dist[i][j] = min(dist[i+1][j]+1, dist[i][j])\n                if j+1 < len(grid[0]):\n                    dist[i][j] = min(dist[i][j+1]+1, dist[i][j])\n                maxer = max(maxer, dist[i][j])\n        if maxer == float('inf'):\n            return -1\n        return maxer\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498546717","body":"```python\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        from collections import defaultdict, deque\n        queue = deque()\n        closedboxes = set()\n        availkeys = set()\n        candycount = 0\n        for ib in initialBoxes:\n            if status[ib] == 1:\n                queue.append(ib)\n            else:\n                closedboxes.add(ib)\n        while queue:\n            currentbox = queue.popleft()\n            candycount += candies[currentbox]\n            for cb in containedBoxes[currentbox]:\n                if status[cb] == 1:\n                    queue.append(cb)\n                else:\n                    closedboxes.add(cb)\n            for k in keys[currentbox]:\n                availkeys.add(k)\n            for c in closedboxes.intersection(availkeys):\n                queue.append(c)\n                closedboxes.remove(c)\n                availkeys.remove(c)\n        \n        return candycount\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500798588","body":"```python\nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        if len(cost) < 2: return cost[0]\n\n        dp = [0 for _ in range(len(cost) + 1)]\n        dp[0], dp[1] = cost[0], cost[1]\n        cost = cost + [0]\n\n        for i in range(2, len(dp)): dp[i] = cost[i] + min(dp[i - 1], dp[i - 2])\n\n        return dp[-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501038103","body":"```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        # Base Case: nums[0] = nums[0]\n        # nums[1] = max(nums[0], nums[1])\n        # nums[k] = max(k + nums[k-2], nums[k-1])\n        '''\n        # Approach 1:- Construct dp table - O(n) space\n        if not nums: return 0\n        if len(nums) == 1: return nums[0]\n\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        for i in range(2, len(nums)):\n          dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n        return dp[-1] # return the last element\n        '''\n        # Approach 2:- O(1) space\n        prev = curr = 0\n        for num in nums:\n            temp = prev # This represents the nums[i-2]th value\n            prev = curr # This represents the nums[i-1]th value\n            curr = max(num + temp, prev) # Here we just plug into the formula\n        return curr\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501256866","body":"```python\nclass Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp, cnt, max_val = [1]*n, [1]*n, 1\n        for i in range(1,n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    if dp[j] + 1 > dp[i]:\n                        dp[i], cnt[i] = 1 + dp[j], cnt[j]\n                    elif dp[j] + 1 == dp[i]:\n                        cnt[i] += cnt[j]\n            max_val = max(max_val,dp[i])\n\n        return sum([j for i,j in zip(dp,cnt) if i == max_val])\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1502530216","body":"```python\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        m, n = len(text1), len(text2)\n        dp, dpPrev = [0] * (n+1), [0] * (n+1)\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if text1[i-1] == text2[j-1]:\n                    dp[j] = dpPrev[j-1] + 1\n                else:\n                    dp[j] = max(dp[j-1], dpPrev[j])\n            dp, dpPrev = dpPrev, dp\n        return dpPrev[n]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1504528879","body":"```python\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        @cache\n        def dfs(i, j):\n            if i >= m or j >= n:      return 0\n            if i == m-1 and j == n-1: return 1\n            return dfs(i+1, j) + dfs(i, j+1)\n        return dfs(0, 0)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506260230","body":"```python\nclass Solution:\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n        dirs = [(-2,-1),(-1,-2),(1,-2),(2,-1),(2,1),(1,2),(-1,2),(-2,1)]\n\n        @lru_cache(None)\n        def sol(i, j, k):\n            if k == 0:\n                return 1\n            curr = 0\n            for di, dj in dirs:\n                i2, j2 = i + di, j + dj\n                if 0 <= i2 < n and 0 <= j2 < n:\n                    curr += 0.125 * sol(i2, j2, k - 1)\n            return curr\n        \n        return sol(row, column, k)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1507885164","body":"```python\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        @cache\n        def dfs(usedNumbers, currentTotal):\n            for i in range(1, maxChoosableInteger + 1):\n                if (usedNumbers >> i) & 1 == 0:\n                    if currentTotal + i >= desiredTotal or not dfs(usedNumbers | (1 << i), currentTotal + i):\n                        return True\n            return False\n        \n        return ((1 + maxChoosableInteger) * maxChoosableInteger) >> 1 >= desiredTotal and dfs(0, 0)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1509993659","body":"class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        @lru_cache(None)\n        def rec(index, cur):\n            if index == len(nums):\n                if cur == target:\n                    return 1\n                return 0\n            return rec(index + 1, cur + nums[index]) + rec(index + 1, cur - nums[index])\n        \n        return rec(0, 0)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1512386927","body":"```python\nclass Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [0] * (amount+1)\n        dp[0] =1\n\n        for i in range(len(coins)-1,-1,-1):\n            for j in range(1,amount+1):\n                if j - coins[i] >=0:\n                    dp[j] += dp[j-coins[i]]\n                \n        return dp[amount]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514147549","body":"```python\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        gs,ss = sorted(g),sorted(s)\n        c = 0\n        while ss and gs:\n            if ss[-1] >= gs[-1]:\n                ss.pop()\n                c += 1\n            gs.pop()\n        return c\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1515821014","body":"```python\nclass Solution: #time: O(NlogN) :: sort space:O(1)\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        real_end, cnt = float('-inf'), 0\n        for srt, end in sorted(intervals, key=lambda x: x[1]):\n            if srt >= real_end: \n                real_end = end\n            else: \n                cnt += 1\n        return cnt\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517281496","body":"```python\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        n = len(nums)\n        max_pos = 0\n        i = 0\n        while i <= max_pos:\n            max_pos = max(max_pos, i + nums[i])\n            if max_pos >= n-1: return True\n            i += 1\n        return False\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518510359","body":"```python\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [1, 1]\n        for i in range(2, n + 1):\n            count = 0\n            for j in range(i):\n                count += dp[j] * dp[i - j - 1]\n            dp.append(count)\n        return dp.pop()\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1519299951","body":"```python\nclass Solution:\n    def beautifulArray(self, n: int) -> List[int]:\n        res = [1]\n        while len(res) < n:\n            res = [i * 2 - 1 for i in res] + [i * 2 for i in res]\n        return [i for i in res if i <= n]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521194128","body":"```python\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        freq = {}\n        for num in nums:\n            if num not in freq:\n                freq[num] = 0\n            else:\n                del freq[num]\n        return freq.keys()\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1522800792","body":"```python\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        ret = []\n        self.dfs(nums, [], ret)\n        return ret\n    \n    def dfs(self, nums, path, ret):\n        ret.append(path)\n        for i in range(len(nums)):\n            self.dfs(nums[i+1:], path+[nums[i]], ret)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1527038037","body":"```python\nclass MapSum:\n\n    def __init__(self):\n        self.dic = {}\n\n    def insert(self, key: str, val: int) -> None:\n        self.dic[key] = val\n\n    def sum(self, prefix: str) -> int:\n        out, n = 0, len(prefix)\n        for item in self.dic:\n            if item[:n] == prefix:\n                out += self.dic[item]\n        return out\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1529261777","body":"#抄答案\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        n, fa = len(grid), list(range(len(grid)))\n        def find(x):\n            if fa[x]!=x:\n                fa[x] = find(fa[x])\n            return fa[x]\n        for i in range(n):\n            for j in range(i+1, n):\n                if grid[i][j]:\n                    fa[find(j)] = find(i)\n        cnter = Counter(find(i) for i in range(n))\n        cnter_m = Counter(find(i) for i in mal)        \n        return min([(-cnter[find(i)], i) for i in mal if cnter_m[find(i)]==1] or [(0, min(mal))])[1]","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1532082838","body":"```python\nclass Solution:\n    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        def dfs(node):\n            if not node: return True\n            left, right = dfs(node.left), dfs(node.right)\n            if left: node.left = None\n            if right: node.right = None\n            return left and right and node.val == 0\n        \n        return root if not dfs(root) else None\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1533978278","body":"```python\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        ret = []\n        self.dfs(candidates, target, [], ret)\n        return ret\n    \n    def dfs(self, nums, target, path, ret):\n        if target < 0:\n            return \n        if target == 0:\n            ret.append(path)\n            return \n        for i in range(len(nums)):\n            self.dfs(nums[i:], target-nums[i], path+[nums[i]], ret)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1535764015","body":"```python\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        ret = []\n        self.dfs(sorted(candidates), target, 0, [], ret)\n        return ret\n    \n    def dfs(self, nums, target, idx, path, ret):\n        if target <= 0:\n            if target == 0: ret.append(path)\n            return \n        for i in range(idx, len(nums)):\n            if i > idx and nums[i] == nums[i-1]: continue\n            if nums[i]>target: return\n            self.dfs(nums, target-nums[i], i+1, path+[nums[i]], ret)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1536952550","body":"```python\nclass Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        ans = [[]]\n        for n in nums:\n            new_ans = []\n            for l in ans:\n                for i in range(len(l)+1):\n                    new_ans.append(l[:i]+[n]+l[i:])\n                    if i<len(l) and l[i]==n: break              #handles duplication\n            ans = new_ans\n        return ans\n```","onTime":true},null,null,null,null,null,null,null,null,null],"gsw9818":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaomingshixiaotang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"snmyj":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429688195","body":"```c\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> kvet,res;\n        while(k>=1){\n            kvet.push_back(k%10);\n            k/=10;\n        }\n        reverse(kvet.begin(),kvet.end());\n        int n=num.size(),m=kvet.size(),cnt;\n        if(n>=m){\n            cnt=0;\n            for(int i=m-1,j=n-1;i>=0;i--,j--){\n                int a=num[j]+kvet[i]+cnt;\n                if(a>=10) {\n                    res.push_back(a-10);\n                    cnt=1;\n                }\n                else {\n                    res.push_back(a);\n                    cnt=0;\n                }\n            }\n            for(int i=n-m-1;i>=0;i--){\n                int a=num[i]+cnt;\n                if(a>=10) {\n                    res.push_back(a-10);\n                    cnt=1;\n                }\n                else {\n                    res.push_back(a);\n                    cnt=0;\n                }\n            }\n        }\n        else if(n<m){\n            cnt=0;\n            for(int i=n-1,j=m-1;i>=0;i--,j--){\n                int a=num[i]+kvet[j]+cnt;\n                if(a>=10) {\n                    res.push_back(a-10);\n                    cnt=1;\n                }\n                else {\n                    res.push_back(a);\n                    cnt=0;\n                }\n            }\n            for(int i=m-n-1;i>=0;i--){\n                int a=kvet[i]+cnt;\n                if(a>=10) {\n                    res.push_back(a-10);\n                    cnt=1;\n                }\n                else {\n                    res.push_back(a);\n                    cnt=0;\n                }\n            }\n        }\n        if(cnt!=0) res.push_back(cnt);\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```\nT:max(m,n)+n\nS:o(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431233047","body":"```c\n class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n=s.length();\n        \n        vector<int> res;\n        for(int i=0;i<n;i++){\n           \n            if(s[i]==c) res.push_back(0);\n            else{\n                 for(int p=1;;p++){\n                     if(i+p<n){\n                     if((s[i+p]==c)&&(i+p)<n) {\n                         res.push_back(p);\n                         break;\n                     }\n                     }\n                     if(i-p>=0){\n                    if((s[i-p]==c)&&(i-p)>=0){\n                        res.push_back(p);\n                        break;\n                    }\n                     }\n                 }\n                \n                \n            }\n            \n        }\n        return res;\n    }\n};\n```\nT:O(NlogN);\nS:O(N);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433244386","body":"```c\r\nclass CustomStack {\r\npublic:\r\n    vector<int> s;\r\n    int len=0,maxlen;\r\n    CustomStack(int maxSize) {\r\n            maxlen=maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(len<maxlen){\r\n        s.push_back(x);\r\n        len++;\r\n        }\r\n       \r\n    }\r\n    \r\n    int pop() {\r\n        if(len>0) {\r\n          int temp=s[len-1];\r\n          s.pop_back();\r\n        \r\n        len--;\r\n        return temp;\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n            if(k<=len) {\r\n                for(int i=0;i<k;i++) s[i]+=val;\r\n            }\r\n            else {\r\n                for(int i=0;i<s.size();i++) s[i]+=val;\r\n            }\r\n    }\r\n};\r\n```\r\nT：push() pop() == O(1) ; increment: O(k);\r\nS: O(N);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434512405","body":"```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<char> ss;\r\n        string ans=\"\",re=\"\",rereverse=\"\";\r\n        int sign=0,cnt=0;\r\n        for(int i=0;i<s.size();i++){\r\n            ss.push(s[i]);\r\n        }\r\n        for(int t=s.size()-1;t>=0;t--){\r\n            if(sign==0&&ss.top()>='a'&&ss.top()<='z') {\r\n                ans+=ss.top();\r\n                ss.pop(); \r\n                continue;         \r\n              }\r\n            if(ss.top()==']'){\r\n                sign++;\r\n                ss.pop(); \r\n                continue;    \r\n            }\r\n            if(ss.top()=='[') {\r\n                sign--;\r\n                ss.pop();\r\n                continue;\r\n            }\r\n            if(sign!=0&&ss.top()>='a'&&ss.top()<='z') {\r\n                    re+=ss.top();\r\n                    ss.pop();\r\n                    continue;\r\n            }\r\n            if(ss.top()>='0'&&ss.top()<='9') {\r\n                cnt=ss.top()-'0';\r\n                ss.pop();\r\n                continue;\r\n            }\r\n            if(cnt!=0) {\r\n                for(int i=re.size()-1;i>=0;i--) rereverse+=re[i];\r\n                     if(sign==0){\r\n                            for(int j=cnt;j>0;cnt--){\r\n                                ans+=rereverse;\r\n                            }\r\n                     }      \r\n                     if(sign!=0){\r\n                            for(int j=cnt;j>0;cnt--){\r\n                                re+=rereverse;\r\n                            }\r\n                     }    \r\n                 \r\n            }\r\n            re=\"\";\r\n            rereverse=\"\";\r\n            cnt=0;\r\n            \r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\n```\r\nT:O(N);\r\nS:O(N);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435126511","body":"```c\nclass MyQueue {\npublic:\n    stack<int> s1,s2;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n       s1.push(x); \n    }\n    \n    int pop() {\n       while(!s1.empty()){\n       s2.push(s1.top());\n       s1.pop();\n       }\n       return(s2.top());\n       s2.pop();\n    }\n    \n    int peek() {\n        int p=s2.top();\n        return p;\n    }\n    \n    bool empty() {\n        if(!s1.empty()||!s2.empty())\n        return false;\n        else return true;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435772317","body":"```c\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int n=arr.size(),max=0;;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>=i;j--){\n                if(arr[j]<=arr[i]) {\n                    max++;\n                    for(int k=j-1;k>=i;k--){\n                        if(arr[k]==arr[j])\n                        max++;\n                        else if(arr[i]==arr[j]) {\n                            \n                            if(arr[k]==arr[j]){\n                                max++;\n                                j=k;\n                            }\n                            \n                        }\n                    }\n                    if(j!=n-1){\n                    i=j;\n                    break;\n                    }\n                    \n                    return max;\n                   \n                }\n            }\n        }\n        return max;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436057624","body":"```c\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        ListNode* p=head,newhead;\n        int length=0,cnt=0;\n        while(p!=nullptr){\n            length++;\n            p=p->next;\n        }\n        p=head;\n        while(p!=nullptr){\n            cnt++;\n            p=p->next;\n            if(cnt==length-k){\n                newhead=p->next;\n                p->next=nullptr;\n               \n            }\n            if(cnt==length) {\n                p->next=head;\n                break;\n            }\n        }\n        return newhead;\n    }\n};\n```\nT:O(n);\nS:O(1);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438651683","body":"```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy=new ListNode(-1,head);\n        ListNode cur=dummy;\n        ListNode temp=null;\n        ListNode temp1=null;\n        while(cur.next!=null&&cur.next.next!=null){\n            temp=cur.next;\n            temp1=cur.next.next.next;\n            cur.next=cur.next.next;\n            cur.next.next=temp;\n            cur.next.next.next=temp1;\n            cur=cur.next.next;\n        }\n        return dummy.next;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440094184","body":"```c++\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head==nullptr) return nullptr;\n        if(head->next==nullptr) return new TreeNode(head->val);\n        ListNode* p=head,*q=head,*dummy=nullptr;\n        while(q!=nullptr&&q->next!=nullptr){\n            dummy=p;\n            p=p->next;\n            q=q->next->next;\n        }\n        dummy->next=nullptr;\n        TreeNode *root=new TreeNode(p->val);\n        root->left=sortedListToBST(head);\n        root->right=sortedListToBST(p->next);\n        return root;\n\n    }\n};\n```\nTC:O(n);\nSC:O(n);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441849235","body":"```c\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> visited = new HashSet<>();\n        ListNode temp = headA;\n        while(temp != null){\n            visited.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while(temp != null){\n            if(visited.contains(temp)){\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443877734","body":"```c\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *f=head,*s=head;\n        if(f==nullptr||f->next==nullptr) return nullptr;\n        while(f!=nullptr){\n            if(f->next==nullptr) return nullptr;\n            if(f->next->next==nullptr) return nullptr;\n            f=f->next->next;\n            s=s->next;\n            if(s==f) {\n                f=head;\n                while(f!=s){\n                    f=f->next;\n                    s=s->next;\n                }\n                return s;\n            }\n            \n        } \n        return nullptr;       \n    }\n};\n```\ntc:o(n);\nsc:O(n);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445148023","body":"```java\nclass LRUCache {\n    private int cap;\n    private Map<Integer,Integer> map=new LinkedHashMap<>();\n\n    public LRUCache(int capacity) {\n    this.cap=capacity;\n    }\n    \n    public int get(int key) {\n        if(map.keySet().contains(key)){\n            int value=map.get(key);\n            map.remove(key);\n            map.put(key,value);\n            return value;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        if(map.keySet().contains(key)){\n            map.remove(key);\n        }else if(map.size()==cap){\n            Iterator<Map.Entry<Integer,Integer>> iterator=map.entrySet().iterator();\n            iterator.next();\n            iterator.remove();\n        }\n        map.put(key,value);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445383393","body":"```c\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (!root) return 0;\n        return 1 + max(maxDepth(root->left), maxDepth(root->right));\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446364033","body":"```c\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n       if(p==nullptr&&q==nullptr) return true;\n       if(p==nullptr||q==nullptr) return false;\n       \n       return (p->val==q->val)&&isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448407139","body":"```\nclass Solution {\npublic:\n    int sum=0;\n    int dfs(TreeNode* root,int num){\n        if(!root) return sum;\n        num=10*num+root->val;\n        if(root->left==nullptr) sum+=10*num+root->val;\n        if(root->right==nullptr) sum+=10*num+root->val;\n        dfs(root->left,num);\n        dfs(root->right,num);\n        return sum;\n    }\n    int sumNumbers(TreeNode* root) {\n        return dfs(root,0);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450382301","body":"```\nclass Solution {\n    int val;\n    int deep = -1;\n    public void dfs(TreeNode root,int depth){\n        if(root == null)return;\n\n        dfs(root.left,depth+1);\n        dfs(root.right,depth+1);\n\n        if(depth > deep){\n            deep = depth;\n            val = root.val;\n        }\n    }\n\n    public int findBottomLeftValue(TreeNode root) {\n        dfs(root,0);\n        return val;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1452063348","body":"```\n\nclass Codec {\npublic:\n\n    string serialize(TreeNode* root) {\n        string str=\"\";\n        if(!root)return str;\n        search_pre(root,str);\n        return str;\n    }\n \n \n    TreeNode* deserialize(string data) {\n        if(data.compare(\"\")==0)return nullptr;\n        TreeNode* head;\n        create_tree(head,data);\n        return head;\n    }\nprivate:\n \n    void search_pre(TreeNode* root,string& str)\n    {\n        str+=to_string((long long)root->val);\n        str+=\",\";\n        if(root->left)search_pre(root->left,str);\n        else str+=\"null,\";\n        if(root->right)search_pre(root->right,str);\n        else str+=\"null,\";\n    }\n \n    void create_tree(TreeNode*& root,string& str)\n    {\n      \n        int num=find_next_num(str);\n        if(num==INT_MIN)return;\n        root=new TreeNode(num);\n        create_tree(root->left,str);\n        create_tree(root->right,str);\n    }\n \n    int find_next_num(string& str)\n    {\n        int num=str.find(\",\");\n        string temp=str.substr(0,num);\n        str.erase(0,num+1);\n        if(temp.compare(\"null\")==0)return INT_MIN;//null return INT_MIN\n        else return stoi(temp);\n    }\n \n  \n\tint stoi(string str)\n\t{\n        bool negative=false;\n        if(str[0]=='-')\n        {\n            negative=true;\n            str.erase(0,1);\n        }\n\t\tint n=str.length(),ans=0;\n\t\tfor(int i=0;i<n;++i)\n\t\t{\n\t\t\tans+=(str[i]-'0')*(int)pow(10.0,n-i-1);\n\t\t}\n\t\treturn negative?-ans:ans;\n\t}\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453744695","body":"```\r\nclass Solution:\r\n  def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n    ans = []\r\n    xToNodes = collections.defaultdict(list)\r\n\r\n    def dfs(node: Optional[TreeNode], x: int, y: int) -> None:\r\n      if not node:\r\n        return\r\n\r\n      xToNodes[x].append((-y, node.val))\r\n      dfs(node.left, x - 1, y - 1)\r\n      dfs(node.right, x + 1, y - 1)\r\n\r\n    dfs(root, 0, 0)\r\n\r\n    \r\n    return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454786813","body":"```c\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int> &nums, int target) {\n        int length = nums.size();\n        for (int i = 0; i < length - 1; ++i) {\n            for (int j = i + 1; j < length; ++j) {\n                if (nums[i] + nums[j] == target) {\n                    return {i, j};\n                }\n            }\n        }\n        return {};\n    }\n};\n\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1454938493","body":"```\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int,int> hash;\n        vector<vector<int>> res;\n        vector<int>ans;\n        for(auto &x:nums) hash[x]++;\n        for(auto &x:hash) res.push_back({x.first,x.second});\n        sort(res.begin(),res.end(),[](vector<int> &a,vector<int> &b){return a[1]>b[1];});\n        for(int i=0;i<=k-1;i++) ans.push_back(res[i][0]);\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455228153","body":"```\r\nclass Solution {\r\npublic:\r\n    int numberOfBoomerangs(vector<vector<int>>& points) {\r\n        int res=0;\r\n        for(int i=0;i<points.size();i++) {\r\n            unordered_map<int,int> m;\r\n            for(int j=0;j<points.size();j++) {\r\n                int dx=points[i][0]-points[j][0];\r\n                int dy=points[i][1]-points[j][1];\r\n                m[dx*dx+dy*dy]++;\r\n            }\r\n            for(auto i:m) {\r\n                res+=i.second*(i.second-1);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457040059","body":"```c\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int max=0,l=0,r=0;\n        if(s==\"\") return max;\n        if(s.size()==1) return 1;\n        unordered_map<int,int> hash;\n        while(l<s.length()-1){\n            int cnt=1;\n            hash[s[l]]++;\n\n            r=l+1;\n\n            while(r<s.length()){\n                if(hash.count(s[r])) {\n                    if(cnt>max) max=cnt;\n                    break;\n                }\n                else{\n                    hash[s[r]]++;\n                    cnt++;\n                    if(cnt>max) max=cnt;\n                }\n                r++;\n            }\n            hash.clear();\n            l++;\n        }\n        return max;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1458998657","body":"```\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> res;\n        int l=words.size()*words[0].size();\n        unordered_map<string,int> hashs,hashscur;\n        for(string x:words) hashs[x]++;\n        for(int i=0;i<s.length()-l+1;i++){\n            string curtarget=s.substr(i,l);\n            hashscur.clear();\n            for(int j=0;j<words.size();j++){\n                string subcurtarget=curtarget.substr(j*words[0].size(),words[0].size());\n                if(hashs.count(subcurtarget)){\n                    hashscur[subcurtarget]++;\n                    if(hashscur[subcurtarget]>hashs[subcurtarget]) break;\n                }\n                else break;\n               \n                if(j==words.size()-1) res.emplace_back(i);\n            }\n\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461087854","body":"```\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int n=nums.size(),ans=0;\n        vector<int> presums(n,0);\n        unordered_map<int,int> hashs;\n        hashs[0]=1;\n        for(int i=0;i<n;i++){\n            if(i==0) presums[0]=nums[0];\n            else presums[i]=presums[i-1]+nums[i];\n            hashs[(presums[i]%k+k)%k]++;\n            int t=(presums[i]%k+k)%k;\n            if(hashs.count(t)) ans+=hashs[t]-1;\n          \n            \n        }\n        \n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1462872993","body":"```c\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode *p=head;\n        int length=0;\n        int n=0;\n        while(p!=nullptr){\n            length++;\n            p=p->next;\n        }\n        p=head;\n        while(n<=length/2-1){\n            \n            p=p->next;\n            n++;\n        }\n        return p;\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464845533","body":"```c\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int w=0,n=nums.size();\n        if(n==0) return 1;\n        for(int i=1;i<n;i++){\n            if(nums[w]!=nums[i]) {\n                nums[w+1]=nums[i];\n                w++;\n                \n            }\n        }\n        return w+1;\n\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465000535","body":"```\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l=0,r=nums.size()-1,mid;\n        if(target<nums[0]) return 0;\n        if(target>nums[r]) return r+1;\n        while(l<=r){\n            mid=(l+r)/2;\n            if(target==nums[mid]) return mid;\n            if(target<nums[mid]) {\n                r=mid-1;\n            }\n            else l=mid+1;\n        }\n        return l;\n    }\n};\n```\nt:O(logn);\ns:1;","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465481974","body":"```c\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        vector<int> ans={};\n        deque<int> q;\n        for(int i=0;i<k;i++){\n            while(!q.empty()&&nums[i]>=nums[q.back()]) q.pop_back();\n            q.push_back(i);\n        }\n        ans.push_back(nums[q.front()]);\n        for(int i=k;i<nums.size();i++){\n           while(!q.empty()&&nums[i]>nums[q.back()]) q.pop_back();\n           q.push_back(i);\n           while(i-q.front()>=k) q.pop_front();\n           ans.push_back(nums[q.front()]);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1466944550","body":"```c\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n            unordered_map<int,int> hashs,hashs_judge;\n            vector<int> res;\n            if(trust.size()==0){ \n                if(n==1){ \n                    return 1;\n                }\n                return -1;\n            }\n            for(int i=0;i<trust.size();i++){\n                hashs[trust[i][0]]++;\n                hashs_judge[trust[i][1]]++;\n            }\n            for(auto x:hashs){\n               \n                    res.push_back(x.first);\n                \n            }\n            sort(res.begin(),res.end());\n            for(int i=0;i<res.size();i++){\n                \n                if(res[i]!=i+1) {\n                    if(hashs_judge[i+1]==n-1)\n                    return i+1;\n                    else return -1;\n                }\n                if(i==res.size()-1&&!hashs.count(n)) {\n                      if(hashs_judge[n]==n-1) return n;\n                      else return -1;\n                    }\n            }\n            return -1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469425531","body":"```c\nclass Solution {\npublic:\n    bool dfs(int pos, vector<int>& color, vector<vector<int>>& e) {\n        for(int i = 0; i < e[pos].size(); i++) {\n            if(color[e[pos][i]] == color[pos]) {\n                return false;\n            } else if(color[e[pos][i]] == -1) \n                color[e[pos][i]] = 1 - color[pos];\n                bool res = dfs(e[pos][i], color, e);\n                if(!res) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\n        vector<vector<int>> e(N + 1, vector<int>(0));\n        vector<int> color(N + 1, -1);\n        for(int i = 0; i < dislikes.size(); i++) {\n            e[dislikes[i][0]].push_back(dislikes[i][1]);\n            e[dislikes[i][1]].push_back(dislikes[i][0]);\n        }\n        for(int i = 1; i <= N; i++) {\n            if(color[i] == -1) {\n                color[i] = 0;\n                bool res = dfs(i, color, e);\n                if(!res) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1471544560","body":"```\nclass Solution {\npublic:\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        for(int i = 0; i < n; i++)\n        {\n            if(group[i] == -1)\n                group[i] = m++;\n        }\n        vector<vector<int>> itemgraph(n);\n        vector<vector<int>> groupgraph(m);\n        vector<int> itemIndegree(n, 0);\n        vector<int> groupIndegree(m, 0);\n        for(int i = 0; i < n; i++)\n        {\n            for(auto j : beforeItems[i])\n            {\n                itemgraph[j].push_back(i);\n                itemIndegree[i]++;\n                if(group[i] != group[j]) \n                {\t\n                    groupgraph[group[j]].push_back(group[i]);\n                    groupIndegree[group[i]]++;\n                }\n            }\n        }\n        vector<vector<int>> g_items(m);\n   \n        queue<int> q;\n        for(int i = 0; i < n; i++)\n            if(itemIndegree[i] == 0)\n                q.push(i);\n        int countItem = 0;\n        while(!q.empty())\n        {\n            int i = q.front();\n            q.pop();\n            countItem++;\n            g_items[group[i]].push_back(i);\n         \n            for(auto j : itemgraph[i])\n            {\n                if(--itemIndegree[j]==0)\n                    q.push(j);\n            }\n        }\n        if(countItem != n)\n            return {};\n      \n        vector<int> g_order;\n        for(int i = 0; i < m; i++)\n            if(groupIndegree[i] == 0)\n                q.push(i);\n        int countgroup = 0;\n        while(!q.empty())\n        {\n            int g = q.front();\n            q.pop();\n            countgroup++;\n            g_order.push_back(g);\n            for(auto j : groupgraph[g])\n            {\n                if(--groupIndegree[j]==0)\n                    q.push(j);\n            }\n        }\n        if(countgroup != m)\n            return {};\n      \n        vector<int> ans(n);\n        int idx = 0;\n        for(auto g : g_order)\n        {\n            for(auto i : g_items[g])\n                ans[idx++] = i;\n        }\n        return ans;\n    }\n};\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473197862","body":"```\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int dx = 0,dy = 0;\n        for (int i = 0; i < moves.size(); i++){\n            if (moves[i] == 'R') dx += 1;\n            if (moves[i] == 'L') dx -= 1;\n            if (moves[i] == 'U') dy += 1;\n            if (moves[i] == 'D') dy -= 1;\n        }\n        if (dx == 0 && dy == 0) return true;\n        else return false;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474741861","body":"```\ntypedef pair<int,int> pii;\nstruct cmp{\n    bool operator()(pii& a, pii& b) const\n    {                          \n        if(a.first == b.first) \n            return a.second > b.second;\n        return a.first > b.first;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        int n = tasks.size(), k = 0;\n        vector<int> ans(n);\n        vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(),[&](auto a, auto b){\n            return tasks[a][0] < tasks[b][0];\n        });\n        priority_queue<pii,vector<pii>,cmp> q;\n        int t = 0;\n        for(int i = 0; i < n; )\n        {\n            while(i < n && tasks[idx[i]][0] <= t)\n            {  \n                q.push({tasks[idx[i]][1], idx[i]});\n                i++;\n            }\n            if(!q.empty())\n            {  \n                int delta = q.top().first, id = q.top().second;\n                int start = tasks[id][0]; \n                q.pop();\n                ans[k++] = id;\n                t = max(t, start);\n                t += delta;\n            }\n            else \n            {\n                t = tasks[idx[i]][0];\n            }\n        }\n        while(!q.empty())\n        {\n            int id = q.top().second;\n            q.pop();\n            ans[k++] = id;\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475045928","body":"```\nclass Solution {\npublic:\n    int numberOfRounds(string startTime, string finishTime) {\n        int t0 = 60 * stoi(startTime.substr(0, 2)) + stoi(startTime.substr(3, 5));\n        int t1 = 60 * stoi(finishTime.substr(0, 2)) + stoi(finishTime.substr(3, 5));\n        if (t1 < t0){\n           \n            t1 += 1440;\n        }\n        t0+=(60-stoi(startTime.substr(3, 5)))%15;\n        t1-=stoi(finishTime.substr(3, 5))%15;\n        return max(0,(t1 - t0) / 15);\n    }\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475758894","body":"```\nclass Solution {\n    public int minCharacters(String a, String b) {\n        char [] ac = a.toCharArray(), bc = b.toCharArray();\n        int alen = a.length(), blen = b.length(), ans = alen + blen;\n        int [] c1 = new int[26], c2 = new int[26];\n        for (int i = 0; i < 26; i++) {\n            c1[i] = 0;\n            c2[i] = 0;\n        }\n        for (int i = 0; i < alen; i++)\n            c1[ac[i] - 'a']++;\n        for (int i = 0; i < blen; i++)\n            c2[bc[i] - 'a']++;\n        \n        int ans1 = alen - c1[0] + c2[0], ans2 = blen - c2[0] + c1[0];\n        for (int i = 1; i < 26; i++) {\n            ans = Math.min(ans, ans1);\n            ans = Math.min(ans, ans2);\n            ans1 = ans1 - c1[i] + c2[i];\n            ans2 = ans2 + c1[i] - c2[i];\n        }     \n        for (int i = 0; i < 26; i++)\n            ans = Math.min(ans, alen + blen - c1[i] - c2[i]);\n\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477387176","body":"```\nclass Solution {\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        quicksort(nums,0,nums.size()-1);\n        return nums;\n    }\n    void quicksort(vector<int>& nums,int l,int r){\n        if(l>=r) return;\n        int i=l-1,j=r+1;\n        int partval=nums[(i+j)>>1];\n        while(i<j){\n            do i++;while(nums[i]<partval);\n            do j--;while(nums[j]>partval);\n            if(i<j) swap(nums[i],nums[j]);\n        }\n\n        quicksort(nums,l,j);\n        quicksort(nums,j+1,r);\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479068802","body":"```\r\nclass Solution {\r\npublic:\r\n    int mySqrt(int x) {\r\n        for(int i=1; i <= x / i;i++){\r\n           long t=i*i;\r\n            if(t>x)\r\n            return i-1;\r\n        }\r\n\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480729516","body":"```\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int l=1,r=n;\n        while(l<=r){\n        int mid=l+(r-l)/2;\n        if(isBadVersion(mid)) r = mid-1;\n        else l=mid+1;\n        }\n        return l;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482951293","body":"```\r\nclass Solution {\r\npublic:\r\n    int reversePairsRecursive(vector<int>& nums, int left, int right) {\r\n        if (left == right) {\r\n            return 0;\r\n        } else {\r\n            int mid = (left + right) / 2;\r\n            int n1 = reversePairsRecursive(nums, left, mid);\r\n            int n2 = reversePairsRecursive(nums, mid + 1, right);\r\n            int ret = n1 + n2;\r\n            int i = left;\r\n            int j = mid + 1;\r\n            while (i <= mid) {\r\n                while (j <= right && (long long)nums[i] > 2 * (long long)nums[j]) j++;\r\n                ret += (j - mid - 1);\r\n                i++;\r\n            }\r\n            vector<int> sorted(right - left + 1);\r\n            int p1 = left, p2 = mid + 1;\r\n            int p = 0;\r\n            while (p1 <= mid || p2 <= right) {\r\n                if (p1 > mid) {\r\n                    sorted[p++] = nums[p2++];\r\n                } else if (p2 > right) {\r\n                    sorted[p++] = nums[p1++];\r\n                } else {\r\n                    if (nums[p1] < nums[p2]) {\r\n                        sorted[p++] = nums[p1++];\r\n                    } else {\r\n                        sorted[p++] = nums[p2++];\r\n                    }\r\n                }\r\n            }\r\n            for (int i = 0; i < sorted.size(); i++) {\r\n                nums[left + i] = sorted[i];\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    int reversePairs(vector<int>& nums) {\r\n        if (nums.size() == 0) return 0;\r\n        return reversePairsRecursive(nums, 0, nums.size() - 1);\r\n    }\r\n};\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483822811","body":"```\nclass Solution:\n    def rotateString(self, A: str, B: str) -> bool:\n     \n        n = len(A)\n        \n        if A ==\"\" and B ==\"\":\n            return True\n        \n        for i in range(n):\n           \n            if B == A[i:] +A[0:i]:\n                return True             \n        return False\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1484046437","body":"```\nclass Solution {\npublic:\n    int smallestDistancePair(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        int n=nums.size(), l=0, r=nums[n-1]-nums[0];\n        while(l <= r){\n            int m=(l+r)/2, cnt=0;\n            for(int i=0,j=0;j<n;j++){\n                while(nums[j]-nums[i] > m)\n                    i++;\n                cnt += j-i;\n            }\n            if(cnt >= k)\n                r = m-1;\n            else\n                l = m+1;\n        }\n        return l;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484682756","body":"```\npublic static int swimInWater(int[][] grid) {\n        int n = grid.length;\n        int lo = Math.max(grid[0][0], grid[n - 1][n - 1]);\n \n        int hi = findMax(grid);\n \n        if(grid[n - 1][n - 1] == hi){\n            return hi;\n        }\n \n        BitSet bs = new BitSet(hi);\n \n        while (lo < hi) {\n            int mi = (lo + hi) >> 1;\n            if (dfs(grid, 0, 0, mi, bs)) {\n                hi = mi;\n            } else {\n                lo = mi + 1;\n            }\n            bs.clear();\n        }\n \n        return lo;\n    }\n \n\n    public static int findMax(int[][] grid){\n        int max = -1;\n        for (int[] ints : grid) {\n            for (int anInt : ints) {\n                max = Math.max(max, anInt);\n            }\n        }\n        return max;\n    }\n \n    public static boolean dfs(int[][] grid, int i, int j, int limit, BitSet bs) {\n        if (bs.get(i * grid.length + j) || grid[i][j] > limit) {\n            return false;\n        }\n        if (i == grid.length - 1 && j == grid.length - 1) {\n            return true;\n        }\n        bs.set(i * grid.length + j);\n        if (i < grid.length - 1 && dfs(grid, i + 1, j, limit, bs)) {\n            return true;\n        }\n        if (j < grid.length - 1 && dfs(grid, i, j + 1, limit, bs)) {\n            return true;\n        }\n        if (i > 0 && dfs(grid, i - 1, j, limit, bs)) {\n            return true;\n        }\n        if (j > 0 && dfs(grid, i, j - 1, limit, bs)) {\n            return true;\n        }\n        return false;\n    }\n \n \n    public static void main(String[] args) {\n\n        int[][] grid = {{0, 1, 2, 3, 4}, {24, 23, 22, 21, 5}, {12, 13, 14, 15, 16}, {11, 17, 18, 19, 49}, {10, 9, 8, 47, 50}};\n        int res = swimInWater(grid);\n        System.out.println(res);\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486627236","body":"```\nclass Solution {\npublic:\n    int maxVowels(string s, int k) {\n        int n=s.size();\n        int max=0;\n        for(int i=0;i<n-k+1;i++){\n            int cnt=0;\n            for(int j=i;j<i+k;j++){\n                if(s[j]=='a'||s[j]=='e'||s[j]=='i'||s[j]=='o'||s[j]=='u') cnt++;\n                if(cnt==k) return k;\n            }\n            if(cnt>max) max=cnt;\n\n        }\n        return max;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488822747","body":"class Solution(object):\r\n    def new21Game(self, N, K, W):\r\n      \r\n        if K == 0: return 1\r\n        dp = [1.0] + [0] * N\r\n        tSum = 1.0\r\n        for i in range(1, N + 1):\r\n            dp[i] = tSum / W\r\n            if i < K:\r\n                tSum += dp[i]\r\n            if 0 <= i - W < K:\r\n                tSum -= dp[i - W]\r\n        return sum(dp[K:])\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489914274","body":"```c\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        if(p.size()>s.size()) return {};\n         vector<int> ret={};\n         unordered_map<char,int> m,temp;\n         for(auto x:p) m[x]++;\n         temp=m;\n         int cnt=0;\n         for(int i=0;i<=s.size()-p.size();i++){\n           if(temp.count(s[i])){\n               cnt++;\n               temp[s[i]]--;\n               for(int j=i+1;j<i+p.size()+1;j++){\n                   if(!temp.count(s[j])) break;\n                   if(temp.count(s[j])&&temp[s[j]]!=0){\n                       temp[s[j]]--;\n                       cnt++;\n                       continue;\n                   }\n                   if(temp[s[j]]==0) break;\n               }\n           }  \n           if(cnt==p.size()) ret.push_back(i);\n           temp=m;\n           cnt=0;\n         }\n         return ret;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1492184695","body":"```\nclass Solution:\n    def minWindow(self, s: 'str', t: 'str') -> 'str':\n        from collections import Counter\n        t = Counter(t)\n        lookup = Counter()\n        start = 0\n        end = 0\n        min_len = float(\"inf\")\n        res = \"\"\n        while end < len(s):\n            lookup[s[end]] += 1\n            end += 1\n            #print(start, end)\n            while all(map(lambda x: lookup[x] >= t[x], t.keys())):\n                if end - start < min_len:\n                    res = s[start:end]\n                    min_len = end - start\n                lookup[s[start]] -= 1\n                start += 1\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1493005968","body":"```\nclass Solution {\npublic:\n    int minOperations(vector<int>& nums, int x) {\n        int target = 0;\n        for (int num : nums) target += num;\n        target -= x;\n\n        int sum = 0, len = -1;\n        for (int l = 0, r = 0; r < nums.size(); r++) {\n            sum += nums[r];\n            while (l <= r && sum > target) sum -= nums[l++];\n            if (sum == target) len = max(len, r - l + 1);\n        }\n\n        return len == -1 ? -1 : nums.size() - len;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493288679","body":"``` c\nclass Solution {\npublic:\n    vector<string> readBinaryWatch(int turnedOn) {\n         vector<string> res;\n        for(int i=0;i<12;i++){\n            for(int j=0;j<60;j++){\n                if(__builtin_popcount(i)+__builtin_popcount(j)==turnedOn){\n                    string s={};\n                    s+=to_string(i)+\":\"+(j<10?\"0\":\"\")+to_string(j);\n                     res.push_back(s);\n                }\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494568095","body":"```\npublic int totalNQueens(int n) {\n    List<Integer> ans = new ArrayList<>();\n    backtrack(new ArrayList<Integer>(), ans, n);\n    return ans.size();\n}\n\nprivate void backtrack(List<Integer> currentQueen, List<Integer> ans, int n) {\n    if (currentQueen.size() == n) {\n        ans.add(1);\n        return;\n    }\n    for (int col = 0; col < n; col  ) {\n        if (!currentQueen.contains(col)) {\n            if (isDiagonalAttack(currentQueen, col)) {\n                continue;\n            }\n            currentQueen.add(col);\n            backtrack(currentQueen, ans, n);\n            currentQueen.remove(currentQueen.size() - 1);\n        }\n\n    }\n\n}\n\nprivate boolean isDiagonalAttack(List<Integer> currentQueen, int i) {\n    int current_row = currentQueen.size();\n    int current_col = i;\n    for (int row = 0; row < currentQueen.size(); row  ) {\n        if (Math.abs(current_row - row) == Math.abs(current_col - currentQueen.get(row))) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1496219843","body":"```\r\nclass Solution {\r\npublic:\r\n    int dfs(vector<vector<int>>& grid,int i,int j){\r\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size())\r\n            return 0;\r\n        if (grid[i][j] != 1)\r\n            return 0;\r\n        grid[i][j] = 2;\r\n        int temp = 1;\r\n        int dx[4] = {-1,0,1,0};\r\n        int dy[4] = {0,1,0,-1};\r\n        for (int k = 0;k < 4;k++){\r\n            temp += dfs(grid,i + dx[k], j + dy[k]);\r\n        }\r\n        return temp;\r\n       \r\n    }\r\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\r\n       \r\n        int res = 0;\r\n        for (int i = 0; i < grid.size();i ++)\r\n            for (int j = 0;j < grid[0].size();j++)\r\n                if (grid[i][j] == 1)\r\n                    res = max(res,dfs(grid,i,j));\r\n        return res;\r\n    }\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497727831","body":"class Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        r, c = len(grid), len(grid[0])\n        data = list()\n        for i in range(r):\n            for j in range(c):\n                if grid[i][j] == 1:\n                    data.append((i, j, 0))\n        \n        d = [(0,1), (0,-1), (1,0), (-1,0)]\n        res = 0\n        while data:\n            i, j, res = data.pop(0)\n            for xd, yd in d:\n                x, y = i + xd, j + yd\n                if 0 <= x < r and 0 <= y < c and grid[x][y] == 0:\n                    grid[x][y] = 1\n                    data.append((x, y, res+1))\n                    \n        return res if res != 0 else -1\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1499261955","body":"```\nclass Solution {\npublic:\n    int maxCandies(vector<int>& status, vector<int>& candies, vector<vector<int>>& keys, vector<vector<int>>& containedBoxes, vector<int>& initialBoxes) {\n        queue<int> q;\n        int sum = 0, id;\n        unordered_set<int> nokeybox;\n        for(int box : initialBoxes)\n        {\n            q.push(box);\n        }\n        while(!q.empty())\n        {\n            id = q.front();\n            q.pop();\n            sum += candies[id];\n            for(int k : keys[id])\n            {\n                status[k] = 1;\n                if(nokeybox.count(k))\n                {   \n                    q.push(k);//入队\n                    nokeybox.erase(k);\n                }\n            }\n            for(int box : containedBoxes[id])\n            {\n                if(status[box]==1)\n                    q.push(box);\n                else\n                    nokeybox.insert(box);\n            }\n        }\n        return sum;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1500238510","body":"```\npublic void preOrderTraverse2(TreeNode root) {\n\t\tLinkedList<TreeNode> stack = new LinkedList<>();\n\t\tTreeNode pNode = root;\n\t\twhile (pNode != null || !stack.isEmpty()) {\n\t\t\tif (pNode != null) {\n\t\t\t\tSystem.out.print(pNode.val+\"  \");\n\t\t\t\tstack.push(pNode);\n\t\t\t\tpNode = pNode.left;\n\t\t\t} else { \n\t\t\t\tTreeNode node = stack.pop();\n\t\t\t\tpNode = node.right;\n\t\t\t}\n\t\t}\n\t}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500915001","body":"```\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n       vector<int> dp(cost.size()+1,0);\n       dp[0]=0;\n       dp[1]=0;\n       for(int i=2;i<=cost.size();i++){\n           dp[i]=min(dp[i-2]+cost[i-2],dp[i-1]+cost[i-1]);\n           \n       }\n        return dp[cost.size()];\n    }\n      \n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501157619","body":"```\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        vector<int> dp(nums.size());\n        if(nums.size()==1) return nums[0];\n        dp[0]=nums[0];\n        dp[1]=max(nums[0],nums[1]);\n\n         for(int i=2;i<nums.size();i++){\n             dp[i]=max(dp[i-2]+nums[i],dp[i-1]);\n            \n         }\n         return dp[nums.size()-1];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501983718","body":"```\nclass Solution {\npublic:\n    int findNumberOfLIS(vector<int>& nums) {\n       int n=nums.size(),maxlen=0;\n       vector<int> dp(n,0);\n\n       for(int i=0;i<n;i++){\n           dp[i]=1;\n           for(int j=0;j<i;j++){\n               if(nums[i]>nums[j]){\n                   dp[i]=max(dp[i],dp[j]+1);\n               }\n           }\n    \n           maxlen=max(dp[i],maxlen);\n       }\n       return maxlen;\n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1503658345","body":"```\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));\n        for (int i = 1; i <= text1.size(); i++) {\n            for (int j = 1; j <= text2.size(); j++) {\n                if (text1[i - 1] == text2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[text1.size()][text2.size()];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1505529282","body":"```\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n       vector<vector<int>> dp(m,vector<int>(n));\n       for(int i=0;i<n;i++) dp[0][i]=1;\n       for(int j=0;j<m;j++) dp[j][0]=1;\n       for(int i=1;i<m;i++){\n           for(int j=1;j<n;j++){\n               dp[i][j]=dp[i][j-1]+dp[i-1][j];\n           }\n       }\n       return dp[m-1][n-1];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1507210318","body":"```\nclass Solution(object):\n    def knightProbability(self, N, K, r, c):\n        \"\"\"\n        :type N: int\n        :type K: int\n        :type r: int\n        :type c: int\n        :rtype: float\n        \"\"\"\n        dp = [[0 for i in range(N)] for j in range(N)]\n        dp[r][c] = 1\n        directions = [(1, 2), (1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1), (-1, 2), (-1, -2)]\n        for k in range(K):\n            new_dp = [[0 for i in range(N)] for j in range(N)]\n            for i in range(N):\n                for j in range(N):\n                    for d in directions:\n                        x, y = i + d[0], j + d[1]\n                        if x < 0 or x >= N or y < 0 or y >= N:\n                            continue\n                        new_dp[i][j] += dp[x][y]\n            dp = new_dp\n        return sum(map(sum, dp)) / float(8 ** K)\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1508824677","body":"```\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        if (maxChoosableInteger + 1) * maxChoosableInteger // 2 < desiredTotal:\n            return False\n        if desiredTotal <= 0:\n            return True\n        memo = {}\n        def dfs(used, cur_total):\n            if cur_total <= 0:\n                return False\n            if used in memo:\n                return memo[used]\n            for i in range(maxChoosableInteger):\n                if not used & (1 << i):\n                    if not dfs(used | (1 << i), cur_total - i - 1):\n                        memo[used]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509869880","body":"```\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums)\n    {\n        int SUM = accumulate(nums.begin(), nums.end(), 0);\n        int Size = SUM / 2;\n        vector<vector<int>> dp(nums.size(), vector<int>(Size + 1, 0));\n        if (SUM % 2 == 1) return false;\n        sort(nums.begin(),nums.end());\n        //初始化 \n        for (int j = 0; j <= Size; j++)\n        {\n            if (j >= nums[0])  dp[0][j] = nums[0];\n        }\n\n        for (int i = 1; i < nums.size(); i++)\n        {\n            for (int j = Size; j >0; j--)\n            {\n                if (j < nums[i])  dp[i][j] = dp[i - 1][j];\n                else  dp[i][j] = max(dp[i - 1][j], dp[i-1][j - nums[i]] + nums[i]);\n            }\n        }\n        if(dp[nums.size()-1][Size]!=Size)\n            return false;\n        return true;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510414785","body":"```\nclass Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n        }\n        if ((target + sum ) % 2 == 1)\n            return 0;\n        if (Math.abs(target) > sum)\n            return 0;\n        int bagWeight = (target + sum) / 2;\n        int[][] dp = new int[nums.length][bagWeight + 1];\n        dp[0][0] = 1; \n        for (int j = 0; j <= bagWeight; j++) {\n            if (j == nums[0])\n                dp[0][j] = 1; \n            if (j == nums[0] && nums[0] == 0)\n                dp[0][j] = 2; \n            \n        }\n        for (int i = 1; i < nums.length; i++) {\n            for (int j = 0; j <= bagWeight; j++) {\n                dp[i][j] = dp[i - 1][j]; \n                if (j >= nums[i]) \n                    dp[i][j] += dp[i - 1][j - nums[i]];\n            }\n        }\n        return dp[nums.length - 1][bagWeight];\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511641497","body":"```\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> dp(amount+1,amount*2);\n        dp[0]=0;\n        if(amount==0) return 0;\n        for(int i=1;i<=amount;i++){\n            for(auto x:coins){\n                if(i<x) continue;\n                dp[i]=min(dp[i],dp[i-x]+1);\n            }\n        }\n       \n       return dp[amount]==amount*2?-1:dp[amount];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1513255892","body":"```\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n         vector<int> dp(6000,0);\n         dp[0]=0;\n         sort(coins.begin(),coins.end());\n         for(int i=1;i<=amount;i++){\n         for(auto x:coins){\n               if((i-x)==0) \n                   dp[i]++;\n                \n               if(((i-x)>0)&&dp[i-x]!=0){\n                   dp[i]+=dp[i-x];\n               }\n         }\n         }\n         return dp[amount];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514980018","body":"```\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        sort(g.begin(),g.end());\n        sort(s.begin(),s.end());\n        int cnt=0,index=0,amount=s.size();\n        for(int i=0;i<g.size();i++){\n            \n            for(int j=index;j<s.size();j++){\n                if(s[j]>=g[i]&&amount>0){ \n                    cnt++;\n                    amount--;\n                    break;\n                    index=j;\n                    }\n            }\n\t\t\t if(amount==0) break;\n\n        }\n        return cnt;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516326239","body":"```\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        int n=intervals.size();\n       \n        vector<int> dp(n,1);\n        sort(intervals.begin(),intervals.end());\n        for(int i=1;i<n;i++){\n          \n            for(int j=i-1;j>=0;j--){\n                if(intervals[j][1]<=intervals[i][0]){\n                    //dp[i]=dp[j]++;\n                    dp[i]=dp[j]+1;\n                   break;\n                }\n               \n            }\n            \n        }\n        sort(dp.begin(),dp.end());\n        return(n-dp[n-1]);\n \n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517313410","body":"```\npublic:\n    bool canJump(vector<int>& nums) {\n        if(nums.size()==1) return true;\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]==0){\n                int cnt=0;\n                for(int j=0;j<i;j++){\n                   if((nums[j]<=i-j)&&i!=nums.size()-1) cnt++;\n                }\n                if(cnt==i) return false;\n            }\n        }\n        return true;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518688186","body":"```\nclass Solution {\npublic:\n    int numTrees(int n) {\n        int c=1;\n        for(int i=0;i<n;i++)\n         c = c * 2*(2*i+1)/(i+2);\n         return c;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519061008","body":"```\nclass Solution {\npublic:\n    ListNode* mergetwo(ListNode*a,ListNode*b){\n          if ((!a)||(!b)) return a?a:b;\n          ListNode head(-1),*rear=&head,*pa=a,*pb=b;\n          while(pa&&pb){\n              if(pa->val<pb->val){\n                  rear->next=pa;\n                  pa=pa->next;\n              }\n              else{\n                   rear->next=pb;\n                  pb=pb->next;\n              }\n              rear=rear->next;\n          }\n          rear->next=(pa?pa:pb);\n          return head.next;\n    }\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n            ListNode *ans=nullptr;\n            for(int i=0;i<lists.size();i++){\n                ans=mergetwo(lists[i],ans);\n            }\n            return ans;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1519368009","body":"```\nclass Solution(object):\n    def beautifulArray(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: List[int]\n        \"\"\"\n\n        l = 1\n        now = [1]\n        while l < N:\n            now = [x + x - 1 for x in now] + [x + x for x in now]\n            l += l\n        \n        res = []\n        for num in now:\n            if num <= N:\n                res.append(num)\n        \n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1520640640","body":"```\nclass Solution {\npublic:\n    vector<int> singleNumber(vector<int>& nums) {\n       unordered_map<int,int> maps;\n       vector<int> ret;\n       for(auto x:nums) maps[x]++;\n       for(auto x:maps) if(x.second==1) ret.push_back(x.first);\n       return ret;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1522898781","body":"```\nclass Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        vector<int> temp;\n        int n=nums.size();\n        for(int i=0;i<(1<<n);i++){\n            int mask=i;\n            for(int j=0;j<n;j++){\n                if(mask&(1<<j)) temp.push_back(nums[j]);\n            }\n            ans.push_back(temp);\n            temp.clear();\n        }\n        return ans;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1525207634","body":"\nclass Trie {\npublic:\n    vector<string> trie;   \n    Trie() {\n       \n    }\n    \n    void insert(string word) {\n     trie.push_back(word); \n    \n    }\n    \n    bool search(string word) {\n      for(int i=0;i<trie.size();i++){\n          if(trie[i]==word) return true;\n      }  \n      return false;\n    }\n    \n    bool startsWith(string prefix) {\n         if(trie.size()==0) return false;\n         for(int i=0;i<trie.size();i++){\n                 int cnt=0;\n             for(int k=0;k<prefix.length();k++){\n                 if(prefix[k]==trie[i][k]) {\n                     cnt++;\n                     continue;\n                }\n                 else break;\n             }\n             if(cnt==prefix.length()) return true;\n         }   \n         return false;\n    }\n};\n\n```\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1527107181","body":"```\nclass MapSum {\npublic:\n    map<string,int> mapsum;\n    MapSum() {\n        \n    }\n    \n    void insert(string key, int val) {\n        mapsum[key]=val;\n    }\n    \n    int sum(string prefix) {\n        int sum=0;\n     for(auto [x,val]:mapsum){\n         if(x.substr(0,prefix.length())==prefix){\n            sum+=val;\n         }\n     }    \n        return sum; \n     }   \n\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528662276","body":"```\nclass Solution:\n    def multiSearch(self, big: str, smalls: List[str]) -> List[List[int]]:\n        postion = []\n        for i in range(len(smalls)):\n            small = smalls[i]\n            length = max(len(small), 1)\n            k = 0\n            p = []\n            while k + length <= len(big):\n                if big[k:k+length] == small:\n                    p.append(k)\n                k += 1\n            postion.append(p)\n        return postion\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1528951403","body":"```\nclass Solution {\npublic:\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        int n = isConnected.size();\n        vector<bool> visited(n, false);\n        queue<int> que;\n\n        int ans = 0;\n        for(int candi = 0; candi < n; candi++) {\n            if(visited[candi] == false) {\n                ans++;\n                que.push(candi);\n                visited[candi] = true;\n                while(!que.empty()) {\n                    int city = que.front();\n                    que.pop();\n                    for(int neighbor = 0; neighbor < n; neighbor++) {\n                        if(visited[neighbor] == false and isConnected[city][neighbor] == 1) {\n                            que.push(neighbor);\n                            visited[neighbor] = true;\n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1529119988","body":"```\nclass Solution {\npublic:\n  int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial) {\n\n    int n = graph.size();\n    int p[n], size[n];\n    function<int(int)> find = [&](int x) {\n        if (p[x] != x)p[x] = find(p[x]);\n        return p[x];\n    };\n    function<void(int, int)> unite = [&](int a, int b) {\n        a = find(a), b = find(b);\n        if (a == b)return;\n        if (size[a] < size[b])swap(a, b);\n        p[b] = a, size[a] += size[b];\n    };\n    for (int i = 0; i < n; i++) {\n        p[i] = i, size[i] = 1;\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (graph[i][j])unite(i, j);\n        }\n    }\n    int cnt[n];\n    memset(cnt, 0, sizeof cnt);\n    for (int e: initial)cnt[e]++;   \n    int curSize = 0, idx = -1;\n    for (int e: initial) {\n        int rt = find(e);\n        if (cnt[rt] == 1) {         \n            if (curSize < size[rt])curSize = size[rt], idx = e;\n            else if (curSize == size[rt] && e < idx)idx = e;\n        }\n    }\n    if (idx == -1) {\n        idx = INT_MAX;\n        for (int e: initial)\n            if (e < idx)idx = e;\n    }\n\n    return idx;\n}\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1531155436","body":"```\nclass Solution {\npublic:\n    vector<int> p;\n    int find(int x){\n        if(x!=p[x]) p[x]=find(p[x]);\n        return p[x];\n    }\n    void connect(int a,int b){\n        int pa=find(a),pb=find(b);\n        p[pa]=pb;\n    }\n    int makeConnected(int n, vector<vector<int>>& connections) {\n     int m=connections.size();\n     if(n-1>m) return -1;\n     p.resize(n);\n     for(int i=0;i<n;i++) p[i]=i;\n     for(auto e:connections){\n         int a=e[0],b=e[1];\n         if(find(a)!=find(b)) {\n             connect(a,b);\n             --n;\n         }\n     }\n     return n-1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1532428439","body":"```\nclass Solution {\npublic:\n    TreeNode* pruneTree(TreeNode* root) {\n        if(root==nullptr) return nullptr;\n        root->left=pruneTree(root->left);\n        root->right=pruneTree(root->right);\n        if( root->left==nullptr&&root->right==nullptr&&root->val==0) return nullptr;\n       \n        return root;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1534063873","body":"```\nclass Solution {\npublic:\n    vector<vector<int>> ans;\n    vector<int> temp;\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n              dfs(candidates,target,0);\n              return ans;   \n    }\n    void dfs(vector<int>& candidates, int target,int idx){\n        if(target==0) {\n            ans.push_back(temp);\n            return;\n        }\n         if(idx==candidates.size()) {\n           \n            return;\n        }\n         dfs(candidates, target,idx+1);\n         if(target-candidates[idx]>=0){\n             temp.push_back(candidates[idx]);\n             dfs(candidates,target-candidates[idx],idx);\n             temp.pop_back();\n         }\n        \n\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1535899682","body":"```\nclass Solution {\npublic:\n    vector<int> temp;\n    vector<vector<int>> ans;\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n       sort(candidates.begin(),candidates.end());\n       dfs(candidates,target,0,0);\n       return ans; \n    }\n    void dfs(vector<int>& candidates, int target,int sum,int index){\n        if(sum>target) return;\n        if(sum==target) ans.push_back(temp);\n        for(int i=index;i<candidates.size()-1;i++){\n            if(i!=candidates.size()-1&&candidates[i+1]==candidates[i]) continue;\n            temp.push_back(candidates[i]);\n            sum+=candidates[i];\n            dfs(candidates,target,sum,i+1);\n            sum-=candidates[i];\n            temp.pop_back();\n\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1537084758","body":"```\nclass Solution {\npublic:\n            vector<vector<int>> res;\n             vector<int> path;\n             vector<bool> sign;\n      \n     \n    vector<vector<int>> permute(vector<int>& nums) {\n             int size=nums.size();\n             sign=vector<bool>(nums.size());\n             dfs(nums,0);\n             return res;\n\n             }\n    \n    \n    void  dfs(vector<int>& n,int m)\n    {\n        if(m==n.size()) {\n            res.push_back(path);\n            return;\n        }\n        for(int i=0;i<n.size();i++){\n            if(!sign[i])\n            {\n            path.push_back(n[i]);\n            sign[i]=true;\n            dfs(n,m+1);\n            sign[i]=false;\n            path.pop_back();\n            \n\n        }\n        }\n    }\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null],"flipn9":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429974446","body":"```java\n/**\n    TC: O(max(N,logk)), N为数组的长度\n    SC: O(max(N,logk))\n*/\n\n// Method 2: 将 加数 k 整个 加入数组表示的数的最低位\n//           3 + 912 = 915, 5 留在当前这一位，将 910 / 10 = 91 以进位的形式加入下一位\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int N = num.length;\n        for (int i = N - 1; i >= 0; i--){\n            int sum = num[i] + k;\n            res.add(0, sum % 10);\n            k = sum / 10;   // 更新 k 存进位 carry\n        }\n        while (k > 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n        return res;\n    }\n}\n\n// Method 1: 两个数拆解后 同时 从后往前逐位相加\nclass Solution1 {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int N = num.length;\n        \n        int i = N - 1;\n        int sum = 0, carry = 0;\n        while (i >= 0 || k > 0) {\n            int x = i >= 0 ? num[i] : 0;\n            int y = k > 0 ? k % 10 : 0;\n            sum = x + y + carry;\n            carry = sum / 10;\n            k /= 10;\n            i--;\n            res.add(0, sum % 10);\n        }\n        \n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430842233","body":"```java\n/**\n    思路:     对每一个 i 从中心扩散找最近的 C     O(n^2)\n        ==>  空间换时间, 存储所有 c 的位置       O(nk), 出现 k 次\n        ==>  Greedy, 只关心最近的 C ==> 正向遍历+反向遍历\n    ------------------------------------------------------------------\n    实现:\n        两个数组 left 和 right 分别记录每个字符左/右侧出现的最后一个 C 字符的下标\n        同时比遍历这两个数组, 计算距离最小值\n\n    优化:    \n        1. 只需要最近的 C, 所以看情况可以覆盖掉第一个数组的值\n            case 1. 字符的左侧没有出现过 C 字符\n            case 2. i - left > right - i\n        2. 直接记录 C 与当前字符的距离, 而不是 C 的下标, 还可以省去最后遍历计算距离的过程\n                \n    TC: O(N), SC: O(1)      1ms\n*/\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int N = s.length();\n        int[] dist = new int[N];\n        dist[0] = s.charAt(0) == c ? 0 : N;\n        for (int i = 1; i < N; i++) {\n            dist[i] = s.charAt(i) == c ? 0 : dist[i - 1] + 1;\n        }\n        for (int i = N - 2; i >= 0; i--) {\n            dist[i] = Math.min(dist[i], dist[i + 1] + 1);  // 左侧距离 > 右侧距离, 未遇到 C 默认距离为 N\n        }\n        return dist;\n    }\n}\n\n/**\n    sliding window: 把 c 看成 s 的分割线\n    XXXX | XXXX | XXXXXX\n    \n    TC: O(N), SC: O(1)\n*/\nclass Solution1 {\n    public int[] shortestToChar(String s, char c) {\n        int N = s.length();\n        int[] dist = new int[N];\n        \n        int l = s.charAt(0) == c ? 0 : N;\n        int r = s.indexOf(c);\n        for (int i = 0; i < N; i++) {\n            dist[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\n            if (i == r) {\n                l = r;\n                r = s.indexOf(c, l + 1);\n            }\n        }\n        return dist;\n    }\n}\n```\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434131488","body":"```java\n/**\n    Method 2: recursive\n         先解析数字 x, 解析到了左括号 [，递归向下解析后面的内容，遇到对应的右括号就返回 ]\n         [] 解析结束后, 再继续 解析] 右边的内容\n*/\nclass Solution1 {\n    int i = 0;\n    public String decodeString(String s) {\n        int count = 0;\n        StringBuilder sb = new StringBuilder();\n        while (i < s.length()) {\n            char c = s.charAt(i);\n            i++;\n            if (Character.isLetter(c)) {\n                sb.append(c);\n            } else if (Character.isDigit(c)) {\n                count = count * 10 + (c - '0');\n            } else if (c == ']') {      \n                break;\n            } else if (c == '[') {\n                String repeat = decodeString(s);\n                while (count > 0) {\n                    sb.append(repeat);\n                    count--;\n                }\n            }\n        }\n        return sb.toString();\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435745090","body":"```java\n/**\n    思路: 和 769 类似\n    块的最大值呈升序排列, 维护一个单调递增栈 保存每个块的最大值\n        如果当前栈为空 || 栈顶 比当前小, 将当前元素 push 进去\n        如果当前栈非空 && 栈顶比当前大, 栈顶应该是目前块的最大值, pop 出来, \n                                    把所有比当前大的元素也 pop 出来\n                                    再把真正的最大值 pop 回去\n    TC: O(N), SC: O(N)\n*/\nclass Solution1 {\n    public int maxChunksToSorted(int[] arr) {\n        int[] stack = new int[arr.length];\n        int top = -1;\n        for (int i : arr) {\n            if (top != -1 && stack[top] > i) {\n                int max = stack[top--];\n                while (top != -1 && stack[top] > i)\n                    top--;\n                stack[++top] =  max;\n            } else {\n                stack[++top] = i;\n            }\n        }\n        return top + 1;\n    }\n}\n\n// method 2: TC: O(nlogn), O(M)\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] copy = arr.clone();\n        Arrays.sort(copy);\n        int count = 0;\n        int sum1 = 0, sum2 = 0;\n        for(int i = 0; i < arr.length; i++) {\n            sum1 += arr[i];\n            sum2 += copy[i];\n            if(sum1 == sum2) {\n                count++;\n                sum1 = 0;\n                sum2 = 0;\n            }\n        }\n        return count;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437235654","body":"```java\n/**\n    思路: 走 k 步, 由于 k 可能很大, 希望 k = k % N\n        1. 遍历, 找到N, 和尾结点 tail\n        2. 断开两种方式\n            - 找到新的头结点, 连接旧头尾, 断开得到新的 head, 新的 tail 指向 null\n            - 先连成环, 再找到新的头尾, 断开\n*/\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode fast = dummy, slow = dummy;\n\n        int N = 0;\n        for (; fast.next != null; N++)\n            fast = fast.next;\n        for (int i = N - k % N; i > 0; i--) \n            slow = slow.next;\n\n        fast.next = dummy.next; \n        dummy.next = slow.next;\n        slow.next = null;\n    \n        return dummy.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438694383","body":"```java\n\n// 思路: 两两翻转 TC: O(n) SC: O(1)\n// 像这种多次对链表进行相同操作, iterative 的写法用 dummy 节点会很方便\n\n// recursive\nclass Solution1 {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) \n            return head;\n        \n        ListNode first = head;\n        ListNode second = head.next;\n        ListNode others = head.next.next;\n        \n        second.next = first;\n        first.next = swapPairs(others);\n        return second;\n    }\n}\n\n// iterative\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode tmp = dummy;\n        while (tmp.next != null && tmp.next.next != null) {\n            ListNode first = tmp.next;\n            ListNode second = tmp.next.next;\n            tmp.next = second;\n            first.next = second.next;\n            second.next = first;\n            tmp = first;\n        }\n        return dummy.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440299863","body":"\n```java\n// Approach 2: 中序遍历结果是链表本身:     TC: O(n), SC: O(logn)\n//             不直接找到中点的值, 而是构造完左子树, 指针自然指向中间结点, 再构造右子树\nclass Solution {\n    ListNode cur;\n    \n    public TreeNode sortedListToBST(ListNode head) {\n        cur = head;\n        int len = 0;\n        for (ListNode p = head; p != null; p = p.next)\n            len++;\n        return inOrderBuildTree(0, len - 1);\n    }\n    \n    private TreeNode inOrderBuildTree(int left, int right) {\n        if (left > right) return null;\n        int mid = left + (right - left) / 2;\n        \n        TreeNode leftTree = inOrderBuildTree(left, mid - 1);    // 构造左子树\n        TreeNode root = new TreeNode(cur.val);                  // 构造根节点\n        cur = cur.next;\n        TreeNode rightTree = inOrderBuildTree(mid + 1, right);  // 构造右子树\n        \n        root.left = leftTree;\n        root.right = rightTree;\n        return root;\n    }\n}\n\n// Approach 1: 快慢指针找链表中点    TC: O(nlogn), SC: O(logn)\nclass Solution1 {\n    public TreeNode sortedListToBST(ListNode head) {\n        return build(head, null);\n    }\n    \n    // 把链表左闭右开区间 [begin, end) 的节点构造成 BST\n    private TreeNode build(ListNode begin, ListNode end) {\n        if (begin == end) \n            return null; // 左闭右开 -> 空集\n        ListNode mid = getMid(begin, end);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = build(begin, mid);\n        root.right = build(mid.next, end);\n        return root;\n    }\n    \n    private ListNode getMid(ListNode begin, ListNode end) {\n        ListNode slow = begin, fast = begin;\n        while (fast != end && fast.next != end) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442727715","body":"```java\n/**\n    找到 LL 环的入口, 如果无环, 返回 null\n    \n    思路: 快慢指针, 快指针有环会追上慢指针 相遇\n    \n    \n    TC: O(n), SC: O(1)\n*/\nclass Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null)\n            return null;\n        \n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) break;\n        }\n        // 无环\n        if (fast == null || fast.next == null)\n            return null;\n        // 有环\n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445156074","body":"\n```java\n// TC: O(n), SC: O(height)\n\n// postorder\nclass Solution1 {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n    }\n}\n\n// backtrack\nclass Solution {\n    int curDepth = 0;\n    int maxDepth = 0;\n    \n    public int maxDepth(TreeNode root) {\n        traverse(root);\n        return maxDepth;\n    }\n    \n    private void traverse(TreeNode root) {\n        if (root == null) return;\n        curDepth++;\n        maxDepth = Math.max(maxDepth, curDepth);\n        traverse(root.left);\n        traverse(root.right);\n        curDepth--;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445523099","body":"```java\n/**\n *  Preorder  TC:O(n), SC:O(h)\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null || q == null)\n            return p == q;\n        if (p.val != q.val)\n            return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447740503","body":"```java\n// TC: O(n), SC: O(h)\nclass Solution {\n    int total = 0;\n    \n    public int sumNumbers(TreeNode root) {\n        traverse(root, 0);\n        return total;\n    }\n    \n    private void traverse(TreeNode root, int curSum) {\n        if (root == null) return;\n        curSum = curSum * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            total += curSum;\n            return;\n        }\n        traverse(root.left, curSum);\n        traverse(root.right, curSum);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449279564","body":"```java\n/**\n    Approach 1:\n    DFS: 先左后右\n        记录遍历到的节点的 height 和 这个 height 最左边节点的值\n        如果 height 大于 curHeight, curVal = 当前节点的值, curHeight = height\n    TC: O(n), SC: O(h)\n*/\nclass Solution1 {\n    int curVal, curHeight;\n    \n    public int findBottomLeftValue(TreeNode root) {\n        curVal = 0;\n        curHeight = 0;\n        dfs(root, 0);\n        return curVal;\n    }\n    \n    public void dfs(TreeNode root, int height) {\n        if (root == null) return;\n        height++;\n        if (height > curHeight) {\n            curHeight = height;\n            curVal = root.val;\n        }\n        dfs(root.left, height);\n        dfs(root.right, height);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451325403","body":"```java\nimport java.util.StringTokenizer;\n/**\n    BT <==> string, 构建满二叉树, null 节点以\"#\"的形式存在于 string 中\n            \n    BFS --> 如果要建的节点是 null, 建 null; 不是 null, 建 new TreeNode(cur.val), 把节点加入 q\n            1,2,3,#,#,4,5,#,#,#,#,\n    DFS -->  注意, preorder 列表最左侧是根节点, postorder 列表最右侧是割接点, deserialize先右后左\n            1,2,#,#,3,4,#,#,5,#,#,\n    \n    TC: O(n)    SC: O(n)\n*/\n// ---------------------- DFS ----------------------\npublic class Codec {\n    String SEP = \",\";\n    String NULL = \"#\";\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        serialize(root, sb);\n        // System.out.println(sb.toString());\n        return sb.toString();\n    }\n    \n    private void serialize(TreeNode root, StringBuilder sb) {\n        if (root == null) {\n            sb.append(NULL).append(SEP);\n            return;\n        }\n        sb.append(root.val).append(SEP);\n        serialize(root.left, sb);\n        serialize(root.right, sb);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        StringTokenizer st = new StringTokenizer(data, SEP);\n        return deserialize(st);\n    }\n    \n    private TreeNode deserialize(StringTokenizer st) {\n        // if (!st.hasMoreTokens()) return null; // 这一句其实写了也不会 call 到的\n        String cur = st.nextToken();\n        if (cur.equals(NULL)) return null;\n        TreeNode root = new TreeNode(Integer.parseInt(cur));\n        root.left = deserialize(st);\n        root.right = deserialize(st);\n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1452945966","body":"```java\n/**\n    1. 遍历二叉树,对所有节点生成坐标\n    2. 对所有节点排序\n        - col: 从左到右\n        - row: 从上到下\n        - val: 从小到大\n    3. 将排序好的节点组装成题目要求的格式\n    \n    TC: O(nlogn)    SC: O(n)\n\n*/\n// PQ\nclass Solution2 {\n    record Info(TreeNode node, int col, int row) {}\n    \n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        PriorityQueue<Info> pq = new PriorityQueue<>((a, b) \n                                                     -> a.col != b.col? \n                                                        a.col - b.col : a.row != b.row? \n                                                        a.row - b.row : a.node.val - b.node.val);\n        traverse(root, pq, 0, 0);\n        while (!pq.isEmpty()) {\n            List<Integer> tmp = new ArrayList<>();\n            Info cur = pq.poll();\n            tmp.add(cur.node.val);\n            int curCol = cur.col;\n            while (!pq.isEmpty() && pq.peek().col == curCol) {\n                tmp.add(pq.poll().node.val);\n            }\n            res.add(tmp);\n        }\n        return res;\n    }\n    \n    private void traverse(TreeNode cur, PriorityQueue<Info> pq, int col, int row) {\n        if (cur == null) return;\n        pq.offer(new Info(cur, col, row));\n        traverse(cur.left, pq, col - 1, row + 1);\n        traverse(cur.right, pq, col + 1, row + 1);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454387775","body":"```java\n/**\n    Approach 1: loop all combination\n    两数差i从 1...N - 1, 两数中大数从 i...N - 1遍历所有数\n    TC: (N - 1) * (N - 2) = O(N^2)  SC: O(1)\n*/\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int N = nums.length;\n        for (int i = 1; i < N; i++) {\n            for (int j = i; j < N; j++) {\n                if (nums[j] + nums[j - i] == target) {\n                    return new int[] {j, j - i};\n                }\n            }\n        }\n        return null;\n    }\n}\n\n/**\n    Approach 2: HashMap<num, index>\n    查看对于当前 num, map 中是有 complement 恰好组成 target\n        有则返回, 没有将当前<num, index>存进去\n    TC: O(N), SC: O(N)\n*/\nclass Solution1 {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] {i, map.get(complement)};\n            }\n            map.put(nums[i], i);\n        }\n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1454967716","body":"```java\n/** \n    Approach 3: 计数排序   TC: O(n)    SC: O(n)    22ms\n*/\nclass Solution3 {\n    public int[] topKFrequent(int[] nums, int k) {\n        int N = nums.length;\n        // Map valToFreq\n        Map<Integer, Integer> valToFreq = new HashMap<>();\n        for (int v : nums) {\n            valToFreq.put(v, valToFreq.getOrDefault(v, 0) + 1);\n        }\n        // List freqToVals\n        List<Integer>[] freqToVals = new ArrayList[N + 1];\n        for (Map.Entry<Integer, Integer> entry : valToFreq.entrySet()) {\n            int val = entry.getKey(), freq = entry.getValue();\n            if (freqToVals[freq] == null)\n                freqToVals[freq] = new ArrayList<>();\n            freqToVals[freq].add(val);\n        }\n        // find the top k\n        int[] res = new int[k];\n        int p = 0;\n        for (int i = N; i > 0; i--) {\n            List<Integer> cur = freqToVals[i];\n            if (cur == null) continue;\n            for (int j = 0; j < cur.size(); j++) {\n                res[p++] = cur.get(j);\n                if (p == k) return res;\n            }\n        }\n        return null;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457585206","body":"```java\n/**\n    思路一: 滑动窗口\n    1. 要有 memo 记录是否有重复\n    2. 从左到右遍历, 一旦遇到重复, 窗口收缩\n    3. 记录最长长度\n    \n    TC: O(N),   SC: O(1)\n*/\nclass Solution1 {\n    public int lengthOfLongestSubstring(String s) {\n        int N = s.length();\n        if (N <= 1) return N;\n        int[] memo = new int[128];\n        int maxLen = 0;\n        int l = 0, r = 0;\n        for (; r < N; r++) {\n            char in = s.charAt(r);\n            memo[in]++;\n            while (memo[in] != 1) {\n                memo[s.charAt(l++)]--;\n            }\n            maxLen = Math.max(maxLen, r - l + 1);\n        }\n        return maxLen;\n    }\n}\n/**\n    思路二: 不用 memo 记录是否有重复, 记录 char 出现的位置 之后一位的位置\n            从而直接缩短窗口\n*/\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int N = s.length();\n        if (N <= 1) return N;\n        int[] memo = new int[128];\n        int maxLen = 0;\n        int l = 0, r = 0;\n        for (; r < N; r++) {\n            char in = s.charAt(r);\n            l = Math.max(l, memo[in]);\n            maxLen = Math.max(maxLen, r - l + 1);\n            memo[in] = r + 1;\n        }\n        return maxLen;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459624469","body":"```java\n// 对于每一个窗口从后向前\nclass Solution {\n   public List<Integer> findSubstring(String s, String[] words) {\n       List<Integer> res = new ArrayList<>();\n       \n       Map<String, Integer> wordToFreq = new HashMap<>();\n       for (String w : words) {\n           wordToFreq.put(w, wordToFreq.getOrDefault(w, 0) + 1);\n       }\n       \n       int wN = words.length;\n       int wL = words[0].length();\n       int tL = wL * wN;\n       int sL = s.length();\n       \n       if (tL > sL) return res;\n       \n       for (int k = 0; k < wL; k++) {                       // 起始点 从单词长度不同点开始\n           for (int i = k; i + tL <= sL; i+= wL) {          // 从起始点开始遍历整个 s\n               Map<String, Integer> tmp = new HashMap<>();\n               for (int j = i + tL - wL; j >= i; j -= wL) {\n                   String word = s.substring(j, j + wL);\n                   // System.out.println(word);\n                   int curFreq = tmp.getOrDefault(word, 0) + 1;\n                   int needFreq = wordToFreq.getOrDefault(word, 0);\n                   if (needFreq < curFreq) {\n                       i = j;\n                       break;\n                   } else if (j == i) {\n                       res.add(i);\n                   } else {\n                       tmp.put(word, curFreq);\n                   }\n               }\n               // System.out.println();\n           }\n       }\n       return res;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463196161","body":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\n```java\n/**\n    TC: O(n)    SC: O(1)\n    \n    注意写法:                        even 节点个数 (不包括 null)       奇数节点 永远落在正中间\n    fast && fast.next               ==> slow 落在靠右的中间节点\n    fast.next && fast.next.next     ==> slow 落在靠左的中间结点\n    \n*/\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464825154","body":"```java\n/** 双指针: 把不同的元素 copy 到前面来 */\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int N = nums.length;\n        int i = 0, j = 1;\n        for (; j < N; j++) {\n            if (nums[j] != nums[i]) {\n                nums[++i] = nums[j];    // [0..slow] no duplicates\n            }\n        }\n        return i + 1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465059512","body":"```java\n/**\n    找左边界: 找得到 left 就是结果, 找不到 left 就是大一位的 position\n    TC: O(nlogn)    SC: O(1)\n*/\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int N = nums.length;\n        int left = 0, right = N;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        } \n        return left;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465406763","body":"```java\n/**\n    维护一个 单调递减 的 Monotonic Queue, 尾进头出\n    TC: O(n)    SC: O(k)\n    36ms\n*/\nclass Solution1 {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int N  = nums.length;\n        int[] res = new int[N - k + 1];\n        Deque<Integer> queue = new ArrayDeque<>();\n        for (int i = 0; i < N; i++) {\n            // 保证窗口内 从大到小, 如果前面的数小则需要一次弹出, 直到满足要求\n            while (!queue.isEmpty() && nums[i] >= nums[queue.peekLast()]) {\n                queue.pollLast();\n            }\n            queue.addLast(i);\n            // 判断队首的值是否在 k 的滑动窗口内\n            if (queue.peekFirst() <= i - k) {\n                queue.poll();\n            }\n            // 当增长到窗口长度为k时 保存当前窗口中最大值\n            if (i + 1 - k >= 0) {\n                res[i + 1 - k] = nums[queue.peekFirst()];\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467260192","body":"```java\nclass Solution {\n    public int findJudge(int N, int[][] trust) {\n        if (trust.length < N - 1) \n            return -1;\n        \n        int[] trustScores = new int[N + 1]; // 初始信用分都为 0, 包括法官对自己\n        \n        for (int[] t : trust) {\n            trustScores[t[1]]++;\n            trustScores[t[0]]--;\n        }\n        \n        for (int i = 1; i <= N; i++) {\n            if (trustScores[i] == N - 1)\n                return i;\n        }\n        return -1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469245077","body":"```java\n/**\n    DFS: 遍历边 dfs, 看 source vetex 能不能给 child color 呈不同的颜色\n    \n    1. colors:  0: unseen\n                1 和 -1 互为 opposite color \n    2. 给未 color 的出发点 默认 color 成 1\n    \n    n 个人, m 个 dislike的关系\n    TC: O(n + m)    SC: O(n + m)    18ms\n*/\nclass Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int[] e : dislikes) {\n            graph.get(e[0]).add(e[1]);\n            graph.get(e[1]).add(e[0]);\n        }\n        int[] colors = new int[n + 1];\n        for (int s = 1; s <= n; s++) {\n            if (colors[s] == 0 && !dfs(graph, s, colors, 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private boolean dfs(List<List<Integer>> graph, int s, int[] colors, int color) {\n        colors[s] = color;\n        for (int next : graph.get(s)) {\n            if (colors[next] == -color) continue;\n            if (colors[next] == color) return false;\n            if (!dfs(graph, next, colors, -color)) return false;\n        }\n        return true;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1471333448","body":"```java\n/**\n    topological sort: \n        \n    [6(0), 3(0), 4(0), 1(-1), 5(1), 2(1), 0(-1), 7(-1)]\n    -----------------  -----  ----------  ------------\n    思路一: (这个比较巧妙)\n    将 group 和 item 的关系存在一张 graph 中\n        graph[N + groupId] 是 group\n        graph[0 ... N + 1] 是 item\n        * 对于不属于任何一组的 item, 其实没必要给它一个新组, 因为它可能会穿插在别的组之间\n    \n    对于 graph 的关系\n        item 存在先后顺序, group 也存在先后顺序\n        item --> group      indegree[group]++       根据 group 生成\n        groupA --> groupB   indegree[groupB]++;     根据 beforeItems 生成\n        \n    思路二:\n    先确定 group 的先后, 再确认 item 的先后\n    \n    TC: O(N + M)    SC: O(N + M)\n*/\nclass Solution {\n    int[] res;\n    int idx;\n    \n    public int[] sortItems(int N, int M, int[] group, List<List<Integer>> beforeItems) {\n        int[] indegree = new int[N + M];\n        List<Integer>[] graph = new ArrayList[N + M];\n        for (int i = 0; i < N + M; i++) graph[i] = new ArrayList<>();\n        // 建立 group 的 关系\n        for (int i = 0; i < N; i++) {\n            if (group[i] == -1) continue;\n            graph[N + group[i]].add(i);\n            indegree[i]++;\n        }\n        // 在 group 的基础上, 把 item 放入 group 的列表中\n        for (int i = 0; i < N; i++) {\n            for (int before : beforeItems.get(i)) { // before --> item\n                // find the groupID of i and beforeItem\n                int a = group[before] == -1? before: N + group[before];\n                int b = group[i] == -1? i : N + group[i];\n                if (a == b) { // same group\n                    graph[before].add(i);\n                    indegree[i]++;\n                } else {\n                    graph[a].add(b);\n                    indegree[b]++;\n                }\n            }\n        }\n        // topological sort\n        res = new int[N]; idx = 0;\n        for (int i = 0; i < N + M; i++) {\n            if (indegree[i] == 0)\n                dfs(N, graph, indegree, i);\n        }\n        return (idx == N) ? res : new int[]{};\n    }\n    \n    private void dfs(int N, List<Integer>[] graph, int[] indegree, int cur) {\n        if (cur < N) \n            res[idx++] = cur;\n        indegree[cur]--; // 为了使每个 cur 只触动是否加入 res 一次, 到零之后减成-1\n        for (int next : graph[cur]) {\n            if (--indegree[next] == 0)\n                dfs(N, graph, indegree, next);\n        }\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474562836","body":"```java\n/**\n    task 按照 入队时间 & 任务编号 \n    \n    idxedTasks: 待执行任务, i: 下一个执行到哪一个\n    PriorityQueue: 入队后, 等待完成的任务\n    \n    TC: O(NlogN)    SC: O(N)\n*/\nclass Solution {\n    public int[] getOrder(int[][] tasks) {\n        int N = tasks.length;\n        \n        // 1. 保留任务index\n        int[][] idxedTasks = new int[N][3];\n        for (int i = 0; i < N; i++) \n            idxedTasks[i] = new int[] {tasks[i][0], tasks[i][1], i};\n        \n        // 2. 按照任务入队时间 排序\n        Arrays.sort(idxedTasks, (a, b) -> a[0] - b[0]);\n        \n        // 3. 根据题意，先按照「持续时间」排序，再根据「任务编号」排序\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\n            (a, b) -> a[1] == b[1] ? a[2] - b[2] : a[1] - b[1]);\n        \n        // 4. 按照入队时间, 加到待完成的 pq 中, 完成 pq 中的任务后, 再处理后续\n        int[] res = new int[N];\n        int time = 1, i = 0, resIdx = 0;\n        while (resIdx < N) {\n            // 如果当前任务 满足入队时间 则入队\n            while (i < N && idxedTasks[i][0] <= time)\n                pq.add(idxedTasks[i++]);\n            if (pq.isEmpty()) { // 空队列, 跳转到下一个任务时间\n                time = idxedTasks[i][0];\n            } else {            // pq 非空, 出队, 并跳到该任务时间点\n                int[] cur = pq.poll();\n                res[resIdx++] = cur[2];\n                time += cur[1];\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482165364","body":"```java\n/**\n    Approach 1: MergeSort       TC: O(NlogN)    SC: O(N)\n*/\nclass Solution {\n    public int reversePairs(int[] nums) {\n        if (nums.length == 1) return 0;\n        int N = nums.length;\n        int[] helper = new int[N];\n        return mergeSort(nums, helper, 0, N - 1);\n    }\n    \n    private int mergeSort(int[] nums, int[] helper, int left, int right) {\n        if (left >= right) return 0;\n        int count = 0;\n        int mid = left + (right - left) / 2;\n        count += mergeSort(nums, helper, left, mid);\n        count += mergeSort(nums, helper, mid + 1, right);\n        count += merge(nums, helper, left, mid, right);\n        return count;\n    }\n    \n    private int merge(int[] nums, int[] helper, int left, int mid, int right) {\n        for (int i = left; i <= right; i++) \n            helper[i] = nums[i];\n        int count = 0;\n        int i = left, j = mid + 1;\n        // count the reverse pairs, 不能一边 count 一边 merge, 因为负数  \n        \n        // while (i <= mid && j <= right) {\n        //     if ((long)array[i] > (long)array[j] * 2) {\n        //         // count += mid + 1 - i;\n        //         j++;\n        //     } else {\n        //         i++;\n        //     }\n        // }\n        while (i <= mid) {\n            while (j <= right && (long) nums[i] > (long) nums[j] * 2) {\n                j++;\n            }\n            count += j - (mid + 1);\n            i++;\n        }\n        // sort\n        \n        i = left;\n        j = mid + 1;\n        while (i <= mid) {\n            if (j > right || helper[i] <= helper[j]) {\n                nums[left++] = helper[i++];\n                // count += j - (mid + 1);\n            } else {\n                nums[left++] = helper[j++];\n                // count += mid + 1 - i;\n            }\n        }\n        return count;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484425724","body":"```java\n/**\n    Approach 1: 二分查找 最短的等待时间, 看能不能找到一条路径\n    TC: O(N ^ 2 logN)   SC: O(N^2)\n            4ms\n*/\nclass Solution {\n    public static final int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    \n    int N;\n    int[][] grid;\n    \n    public int swimInWater(int[][] grid) {\n        this.N = grid.length;\n        this.grid = grid;\n        \n        int left = 0, right = N * N;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            boolean[][] visited = new boolean[N][N];\n            if (grid[0][0] <= mid && dfs(0, 0, visited, mid)) \n                right = mid;\n            else \n                left = mid + 1;\n        }\n        return left;\n    }\n    \n    private boolean dfs(int x, int y, boolean[][] visited, int threshold) {\n        if (x == N - 1 && y == N - 1) \n            return true;\n        visited[x][y] = true;\n        for (int[] dir : dirs) {\n            int i = x + dir[0], j = y + dir[1];\n            if (isValid(i, j) && !visited[i][j] && grid[i][j] <= threshold) \n                if (dfs(i, j, visited, threshold))\n                    return true;\n        }\n        return false;\n    }\n    \n    private boolean isValid(int x, int y) {\n        return x >= 0 && x < N && y >= 0 && y < N;\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493206749","body":"```java\n/**\n    Approach 1: 枚举所有的 h 和 m, 计算他们的 bitCount, 看位数和是否等于 turnedOn\n                12 * 60 = 720 种组合\n    TC: O(1)    SC: O(1)\n*/\nclass Solution {\n    public List<String> readBinaryWatch(int turnedOn) {\n        List<String> res = new ArrayList<>();\n        for (int h = 0; h < 12; h++) {\n            for (int m = 0; m < 60; m++) {\n                if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) {\n                    StringBuilder sb = new StringBuilder();\n                    sb.append(h).append(\":\");\n                    sb.append(m < 10 ? \"0\" : \"\").append(m);\n                    res.add(new String(sb));\n                }\n            }\n        }\n        return res;\n    }\n}\n\n/**\n    Approach 2: 枚举 2^10 = 1024 种灯的开闭组合\n                高 4 位: 小时     低 6 位: 分钟, \n                若小时和分钟的值 均在合规范围内, 并且 二进制中 1 的个数为 turnedOn, 加入 res\n    TC: O(1)    SC: O(1)            \n*/\nclass Solution1 {\n    public List<String> readBinaryWatch(int turnedOn) {\n        List<String> res = new ArrayList<>();\n        for (int i = 0; i < 1024; i++) {\n            int h = i >> 6, m = i & 63;\n            if (h < 12 && m < 60 && Integer.bitCount(i) == turnedOn) {\n                StringBuilder sb = new StringBuilder();\n                sb.append(h).append(\":\");\n                sb.append(m < 10 ? \"0\" : \"\").append(m);\n                res.add(new String(sb));\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wabw1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqmmy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-pricity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sclihuiming":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"amazeding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"astrking":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429161664","body":"### 思路\n\n~~~bash\n1、题目可以简略理解为是2个数的相加，主要就是考虑生成结果的方式\n2、我们遍历num数组，考虑倒叙遍历，依次和k相加，结果对10取模，余数留下，模继续和下一位相加\n3、利用linkedlist的特性，每次加入的时候都是往头部加，这样我们得到的值就是正序的\n4、同时考虑到K值特别大的情况，最后对K值再进行判断一下，这样就是完整的流程\n~~~\n\n### 代码\n\n~~~java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> res = new LinkedList<>();\n    int n = num.length;\n    \n    for (int i = n - 1; i >= 0; i--) {\n        res.add(0, (num[i] + k) % 10);\n        k = (num[i] + k) / 10;\n    }\n    \n    while (k > 0) {\n        res.add(0, k % 10);\n        k /= 10;\n    }\n    \n    return res;\n}\n~~~\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430897544","body":"### 思路\n\n~~~bash\n1.无脑两次遍历，正着一次，反着一次，然后再比较两次遍历后相同下标处的最小值即可\n2.遍历的时候只考虑当前顺序，考虑不到的情况由下次反序遍历时来弥补\n~~~\n\n### 代码\n\n~~~java\npublic int[] shortestToChar(String s, char c) {\n    int n = s.length();\n    int[] ans = new int[n];\n\n    for (int i = 0, idx = -n; i < n; ++i) {\n        if (s.charAt(i) == c) {\n            idx = i;\n        }\n        ans[i] = i - idx;\n    }\n\n    for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n        if (s.charAt(i) == c) {\n            idx = i;\n        }\n        ans[i] = Math.min(ans[i], idx - i);\n    }\n    return ans;\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432869219","body":"### 思路\n\n~~~bash\n1、看题目描述+栈的本身特性，做到后进先出\n2、同时考虑题目中的increment函数，循环加那肯定是数组来的最快，无脑for循环加即可\n3、我们把数组想象成横向的一组数字，左边是开头，右边是结尾，每次新增数据都是在结尾处添加当前数据，符合题目中的push要求，同时可以对前n个元素进行for循环遍历相加，也符合题目中的increment要求，只是我们不符合题目中的pop要求\n4、我们把步骤3中的数组进行逆时针旋转，同时记录最后一位值的下标，每次pop的时候，就移出数组中的最后一位元素，这样就满足了我们题目的要求\n\n整体而言就是数组+一个辅助标志位\n~~~\n\n### 代码\n\n~~~java\npublic class CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top =-1;\n    }\n    public void Push(int x) {\n        if(top!=stack.Length-1)\n        {\n            top++;\n            stack[top]=x;\n        }\n    }\n    public int Pop() {\n        if(top==-1)\n        {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    public void Increment(int k, int val) {\n        int limit = Math.Min(k, top + 1);\n        for (int i = 0; i < limit; ++i)\n        {\n            stack[i] += val;\n        }\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：push和pop为O(1)，increment为O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434284105","body":"### 思路\n\n~~~bash\n默认题解是与辅助栈相结合，我们遍历字符串，一次压入栈，等遇到']'再出栈，一致出栈至'['，根据重复次数进行相关操作，再依次入栈，依次类推，得到最终结果即可\n\n本次我们换另一种思路：递归\n1、依次取出每个字符，再对剩下的字符串进行递归，在方法中对不同类型的情况进行分类处理\n2、利用队列的特性(先进先出)，可以简化遍历以及对方法的调用\n~~~\n\n### 代码\n\n~~~java\nstatic class Solution {\n    public String decodeString(String s) {\n        Queue<Character> q = new LinkedList<>();\n        // 借助队列(先进者先出)，简化递归函数，看起来更加清晰明了\n        for (char c : s.toCharArray()) {\n            q.offer(c);\n        }\n        return decodeString(q);\n    }\n\n    public String decodeString(Queue<Character> q) {\n        StringBuilder res = new StringBuilder();\n        int num = 0;\n        // 什么时候q为空则结束\n        while (!q.isEmpty()) {\n            // 我们就针对一个一个字符进行判断\n            char c = q.poll();\n            // 当字符是阿拉伯数字时，计算重复次数\n            if (c >= '0' && c <= '9') {\n                num = 10 * num + (c - '0');\n            } else if (c == '[') {  // 字符是左括号，可以理解为一条新开始的字符串，我们直接对剩余的q操作即可\n                String tmp = decodeString(q);\n                // 操作完成且获取到返回的字符串后，判断字符串是否需要重复\n                while (num > 0) {\n                    res.append(tmp);\n                    num--;\n                }\n            } else if (c == ']') { // 判断是否要结束返回\n                return res.toString();\n            } else { // 这种情况就是遇到了字符，无脑接在res后面即可\n                res.append(c);\n            }\n\n        }\n        // 最后返回我们的res即可\n        return res.toString();\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435665008","body":"### 思路\n\n~~~bash\n1、栈的特性是先进后出，队列的特性是先进先出，我们根据这些特性来做此道题目\n2、知道两者特性之后，我们需要用两个栈来模拟队列的特性，一个栈为入队栈，一个栈为出对栈。当出队栈存在内容时，出队栈的栈顶，即为第一个出队的元素。若出队栈无元素，我们的需求又是出队的话，我们就需要将入队栈的内容反序导入出队栈，然后弹出栈顶即可。\n~~~\n\n### 代码\n\n~~~java\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new LinkedList<Integer>();\n        outStack = new LinkedList<Integer>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}\n~~~\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435946779","body":"### 思路\n\n~~~bash\n采用单调栈的思想，将一个减序列压缩合并成最该序列的最大的值，保证其它栈里面是单调递增即可\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for (int num : arr) {\n            // 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\n            // 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\n            if (!stack.isEmpty() && num < stack.getLast()) {\n                // 我们需要将融合后的区块的最大值重新放回栈\n                // 而 stack 是递增的，因此 stack[-1] 是最大的\n                int cur = stack.removeLast();\n                // 维持栈的单调递增\n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(cur);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        // 栈存的是块信息，因此栈的大小就是块的数量\n        return stack.size();\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436532795","body":"### 思路\n\n~~~bash\n1、首先我们先确认一个概念，当整体向右边移动1个位置，相当于把链表的最后1位移动到head前面，移动2个位置，就是把链表的最后两位移动到head前面\n2、如果说链表的整体长度为k，你移动k，相当于没有移动(把链表当成一个环来处理)\n3、所以我们的移动，只需要考虑K对链表长度的求余即可\n4、那么后续问题，就可以转化为查询链表上面倒数第几个元素了，这样就十分方便了\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        int count = 0;\n        ListNode now = head;\n        while(now != null){\n            now = now.next;\n            count++;\n        }\n        k = k % count;\n        ListNode slow = head, fast = head;\n        while(fast.next != null){\n            if(k-- <= 0){\n                slow = slow.next;\n            }\n            fast = fast.next;\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438140941","body":"### 思路\n\n~~~bash\n采用递归的思想，两个两个一组，先对前面两个进行翻转，再把剩下的依次进行翻转\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    // 定义：输入以 head 开头的单链表，将这个单链表中的每两个元素翻转，\n    // 返回翻转后的链表头结点\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode first = head;\n        ListNode second = head.next;\n        ListNode others = head.next.next;\n        // 先把前两个元素翻转\n        second.next = first;\n        // 利用递归定义，将剩下的链表节点两两翻转，接到后面\n        first.next = swapPairs(others);\n        // 现在整个链表都成功翻转了，返回新的头结点\n        return second;\n\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439827715","body":"### 思路\n\n~~~bash\ndfs+双指针：\n1、获取当前链表的中点\n2、以链表中点为根\n3、中点左边的值都小于它,可以构造左子树\n4、同理构造右子树\n5、循环第一步\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n  public TreeNode sortedListToBST(ListNode head) {\n      if(head == null) return null;\n      return dfs(head,null);\n  }\n  private TreeNode dfs(ListNode head, ListNode tail){\n      if(head == tail) return null;\n      ListNode fast = head, slow = head;\n      while(fast != tail && fast.next != tail){\n          fast = fast.next.next;\n          slow = slow.next;\n      }\n      TreeNode root = new TreeNode(slow.val);\n      root.left = dfs(head, slow);\n      root.right = dfs(slow.next, tail);\n      return root;\n  }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(nlogn)\n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441663474","body":"### 思路\n\n~~~bash\n1、使用两个指针如指针 a, b 分别指向 A, B 这两条链表的头节点, 两个指针以相同的速度向后移动。\n2、若在此过程中 a, b 指针相遇，则相遇节点为两链表相交的起始节点，否则说明两个链表不存在相交点。\n~~~\n\n### 代码\n\n~~~java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        // p1 指向 A 链表头结点，p2 指向 B 链表头结点\n        ListNode p1 = headA, p2 = headB;\n        while (p1 != p2) {\n            // p1 走一步，如果走到 A 链表末尾，转到 B 链表\n            if (p1 == null) p1 = headB;\n            else            p1 = p1.next;\n            // p2 走一步，如果走到 B 链表末尾，转到 A 链表\n            if (p2 == null) p2 = headA;\n            else            p2 = p2.next;\n        }\n        return p1;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443817075","body":"### 思路\n\n~~~bash\n1、遍历整个链表,同时将每个节点都插入哈希表。由于题目没有限定每个节点的值均不同，因此我们必须将节点的引用作为哈希表的键\n2、如果当前节点在哈希表中不存在,继续遍历；如果存在,那么当前节点就是环的入口节点。\n~~~\n\n### 代码\n\n~~~java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode pos = head;\n        Set<ListNode> visited = new HashSet<ListNode>();\n        while (pos != null) {\n            if (visited.contains(pos)) {\n                return pos;\n            } else {\n                visited.add(pos);\n            }\n            pos = pos.next;\n        }\n        return null;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445010282","body":"### 思路\n\n~~~bash\n1、先了解lru是什么，Least Recently Used，题中意思可以简单理解为最新使用的数据放在最前面，老的数据往后排，或者我们直接淘汰掉\n2、根据这个思想，那么我们可以做相关的设计，哈希+链表，首先判断数据是否在我们的lrucache里面，如果在，我们就把它放在第一位，剩下的还是按照原顺序组合，如果不在，我们就淘汰最末位，将新数据放在第一位，如此即可\n~~~\n\n### 代码\n\n~~~java\nclass LRUCache {\n    class DLinkedNode {\n        int key, value;\n        DLinkedNode prev, next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {\n            key = _key;\n            value = _value;\n        }\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size, cap;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n        //add dummy head and dummyTail\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) return -1;\n        //if key exist, move it to head by using its location store in Hashmap\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            //made a newNode if it does not exist\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > cap) {\n                DLinkedNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445282536","body":"### 思路\n\n~~~bash\n动态规划，输入一个节点，返回以该节点为根的二叉树的最大深度，根据左右子树的最大深度推出原二叉树的最大深度\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftMax = maxDepth(root.left);\n        int rightMax = maxDepth(root.right);\n        return 1 + Math.max(leftMax, rightMax);\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446013772","body":"### 思路\n\n~~~bash\n依次比较两颗树的子节点\n~~~\n\n### 代码\n\n```\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null || q == null) return false;\n        if(p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n\n**复杂度分析**\n\n时间复杂度：O(min(m,n）)，其中 m和n为两棵树的节点数\n\n空间复杂度：O(min(m,n）)，其中 m和n为两棵树的节点数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447989900","body":"### 思路\n\n~~~bash\n求从根到叶子的路径之和，那我们只需要把每条根到叶子的路径找出来，并求和即可，这里用 DFS 去解，DFS 也是最容易想到的。\n~~~\n\n### 代码\n\n~~~java\n    public int sumNumbers(TreeNode root) {\n        return helper(root, 0);\n    }\n\n    public int helper(TreeNode root, int i){\n        if (root == null) return 0;\n        int temp = i * 10 + root.val;\n        if (root.left == null && root.right == null)\n            return temp;\n        return helper(root.left, temp) + helper(root.right, temp);\n    }\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450123343","body":"### 思路\n\n~~~bash\n广度优先遍历，先加右，再加左，保证最后遍历的节点为最底层最左边节点的值。\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> bfs = new LinkedList<>();\n        bfs.offer(root);\n        int res = -1;\n        while(!bfs.isEmpty()){\n            TreeNode cur = bfs.poll();\n            res = cur.val;\n            if(cur.right != null){\n                bfs.offer(cur.right);\n            }\n            if(cur.left != null){\n                bfs.offer(cur.left);\n            }\n        }\n        return res;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451653967","body":"### 思路\n\n~~~bash\nDFS，自己没想出来，先提交作业了\n~~~\n\n### 代码\n\n~~~java\npublic class Codec {\n\n        // Encodes a tree to a single string.\n        public String serialize(TreeNode root) {\n            if (root == null) return \"X,\";\n            String leftSerialize = serialize(root.left); //左子树的序列化字符串\n            String rightSerialize = serialize(root.right); //右子树的序列化字符串\n            return root.val + \",\" + leftSerialize + rightSerialize;\n        }\n\n        // Decodes your encoded data to tree.\n        /**\n         * 构建树的函数 buildTree 接收的 “状态” 是 list 数组，由序列化字符串转成\n         * 按照前序遍历的顺序：先构建根节点，再构建左子树、右子树\n         * 将 list 数组的首项弹出，它是当前子树的 root 节点\n         * 如果它为 'X' ，返回 null\n         * 如果它不为 'X'，则为它创建节点，并递归调用 buildTree 构建左右子树，当前子树构建完毕，向上返回\n         */\n        public TreeNode deserialize(String data) {\n            String[] temp = data.split(\",\");\n            Deque<String> dp = new LinkedList<>(Arrays.asList(temp));\n            return buildTree(dp);\n        }\n        private TreeNode buildTree(Deque<String> dq){\n            String s = dq.poll(); //返回当前结点\n            if (s.equals(\"X\")) return null;\n            TreeNode node = new TreeNode(Integer.parseInt(s));\n            node.left = buildTree(dq); //构建左子树\n            node.right = buildTree(dq); //构建右子树\n            return node;\n        }\n    }\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453141837","body":"### 思路\n\n~~~bash\n1、遍历二叉树,对所有节点生成坐标\n2、将坐标信息（x,y）和 节点值 val 保存值 Map<Integer, Map<Integer, List>> 的数据结构中\n3、在遍历完树后对结果进行遍历并整理出最终的结果值\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root)  {\n        List<List<Integer>> result = new ArrayList<>();\n        Map<Integer, Map<Integer, List<Integer>>> memo = new HashMap<>();\n        record(root, memo, 0, 0);\n        \n        Set<Integer> columnSet = memo.keySet();\n        Integer[] columns = columnSet.toArray(new Integer[columnSet.size()]);\n        Arrays.sort(columns);\n        for (int i = 0; i < columns.length; i++){\n            int column = columns[i];\n            Map<Integer, List<Integer>> lineData = memo.get(column);\n            Set<Integer> lineSet = lineData.keySet();\n            Integer[] lines = lineSet.toArray(new Integer[lineSet.size()]);\n            Arrays.sort(lines);\n            List<Integer> lineResult = new ArrayList<>();\n            for (int j = 0; j < lines.length; j++) {\n                int line = lines[j];\n                List<Integer> data = lineData.get(line);\n                if (data.size() == 1){\n                    lineResult.addAll(data);\n                }\n                else {\n                    Integer[] colRowArray = data.toArray(new Integer[data.size()]);\n                    Arrays.sort(colRowArray);\n                    for (Integer nodeVal : colRowArray) {\n                        lineResult.add(nodeVal);\n                    }\n                }\n            }\n            result.add(lineResult);\n        }\n        return result;\n    }\n\n    private void record(TreeNode root,Map<Integer, Map<Integer, List<Integer>>> memo, int x, int y){\n\n        Map<Integer, List<Integer>> column = memo.getOrDefault(x, new HashMap<>());\n        List<Integer> line = column.getOrDefault(y, new ArrayList<>());\n        line.add(root.val);\n        column.put(y,line);\n        memo.put(x, column);\n        if(root.left != null) {\n            record(root.left, memo, x-1, y+1);\n        }\n        if(root.right != null) {\n            record(root.right, memo, x+1, y+1);\n        }\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(NlogN)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454748069","body":"### 代码\n\n~~~java\npublic class Solution {\n\n    public int[] twoSum(int[] nums, int target) {\n       \n       for(int i = 0; i < nums.length; i++)\n           for(int j = i + 1; j < nums.length; j++)\n               if(nums[i] + nums[j] == target)\n                   return new int[]{i, j};\n\n       return new int[]{-1, -1};\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455088117","body":"### 思路\n\n~~~bash\n用哈希表记录元素和对应的频率，对频率进行排序，取出前K个\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> occurrences = new HashMap<Integer, Integer>();\n        for (int num : nums) {\n            occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);\n        }\n\n        // int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] m, int[] n) {\n                return m[1] - n[1];\n            }\n        });\n        for (Map.Entry<Integer, Integer> entry : occurrences.entrySet()) {\n            int num = entry.getKey(), count = entry.getValue();\n            if (queue.size() == k) {\n                if (queue.peek()[1] < count) {\n                    queue.poll();\n                    queue.offer(new int[]{num, count});\n                }\n            } else {\n                queue.offer(new int[]{num, count});\n            }\n        }\n        int[] ret = new int[k];\n        for (int i = 0; i < k; ++i) {\n            ret[i] = queue.poll()[0];\n        }\n        return ret;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(N)\t\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456171280","body":"### 思路\n\n~~~bash\n在points里的每一个点都可以作为一个枢纽i，连接两个点j和k。\n双重循环出每一个i与j k之间的距离，如果距离相同的数组个数大于1肯定是回旋镖数组\n~~~\n\n### 代码\n\n~~~java\npublic int numberOfBoomerangs(int[][] points) {\n\n    if (points == null || points.length <= 2)\n        return 0;\n\n    int res = 0;\n    Map<Integer, Integer> equalCount = new HashMap<>();\n\n    for (int i = 0; i < points.length; ++i) {\n\n        for (int j = 0; j < points.length; ++j) {\n\n            int dinstance = getDistance(points[i], points[j]);\n            equalCount.put(dinstance, equalCount.getOrDefault(dinstance, 0) + 1);\n        }\n\n        for (int count : equalCount.values())\n            res += count * (count - 1);\n        equalCount.clear();\n    }\n\n    return res;\n}\n\nprivate int getDistance(int[] x, int[] y) {\n\n    int x1 = y[0] - x[0];\n    int y1 = y[1] - x[1];\n\n    return x1 * x1 + y1 * y1;\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(N2)\t\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1458343007","body":"### 思路\n\n~~~bash\n滑动窗口\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n\tunordered_map<char, int> window;\n\n    int left = 0, right = 0;\n    int res = 0; // 记录结果\n    while (right < s.size()) {\n        char c = s[right];\n        right++;\n        // 进行窗口内数据的一系列更新\n        window[c]++;\n        // 判断左侧窗口是否要收缩\n        while (window[c] > 1) {\n            char d = s[left];\n            left++;\n            // 进行窗口内数据的一系列更新\n            window[d]--;\n        }\n        // 在这里更新答案\n        res = max(res, right - left);\n    }\n    return res;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(N)\t\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460298019","body":"代码\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList<>();\n        int wordLen = words[0].length();\n        //总长度小于则不符合\n        if (wordLen * words.length > s.length() || wordLen == 0 || s.length() == 0) {\n            return ans;\n        }\n        //所有的单词内置到map\n        Map<String, Integer> wordMap = new HashMap<>();\n        for (String w : words) {\n            wordMap.merge(w, 1, Integer::sum);\n        }\n        Map<String, Integer> wordMapTemp;\n        int allLen = words.length * wordLen;\n        String word;\n        boolean flag;\n        //滑动窗口\n        for (int i = 0; i < s.length() - allLen + 1; i++) {\n            flag = true;\n            wordMapTemp = new HashMap<>();\n            for (int j = 0; j < words.length; j++) {\n                word = s.substring(i + j * wordLen, i + j * wordLen + wordLen);\n                wordMapTemp.merge(word, 1, Integer::sum);\n                if (!wordMap.containsKey(word)||wordMapTemp.get(word) > wordMap.get(word)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                ans.add(i);\n            }\n        }\n        return ans;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461934610","body":"### 思路\n\n~~~bash\n前缀和+哈希\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int minSubarray(int[] nums, int p) {\n            int sum = 0, ans = nums.length, mode = 0;\n            for (int num : nums) {\n                mode = (num + mode) % p;\n            }\n            if (mode == 0) {\n                return 0;\n            }\n            Map<Integer, Integer> map = new HashMap<>();\n            for (int i = 0; i < nums.length; i++) {\n                map.put(sum, i);\n                sum = (nums[i] + sum) % p;\n                int k = (sum + p - mode) % p;\n                if (map.containsKey(k)) {\n                    ans = Math.min(ans, i - map.get(k)+1);\n                }\n            }\n            return ans == nums.length ? -1 : ans;\n        }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(N)\t\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463958835","body":"### 思路\n\n~~~bash\n快慢指针，一个是1倍速，一个2倍数，注意先走2，再走1，等2走完了即可\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        if (head.next == null) {\n            return head;\n        }\n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(N)\t\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464929492","body":"### 思路\n\n~~~bash\n快慢指针，经典题了\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int i = 0,j = 1;\n        for(; j < nums.length;){\n            if(nums[i] == nums[j]){\n                j++;\n            } else {\n                nums[++i] = nums[j++];\n            }\n        }\n        return i+1;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(N)\t\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465202900","body":"### 思路\n\n~~~bash\n二分法，经典题目了\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        return left_bound(nums, target);\n    }\n\n    // 搜索左侧边界的二分算法\n    int left_bound(int[] nums, int target) {\n        if (nums.length == 0) return -1;\n        int left = 0;\n        int right = nums.length; // 注意\n\n        while (left < right) { // 注意\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                right = mid;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else if (nums[mid] > target) {\n                right = mid; // 注意\n            }\n        }\n        return left;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(logN)\t\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466109971","body":"### 思路\n\n~~~bash\n单调队列，自己没想到用到堆的方法，这个后面再消化一下\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int[] ans = new int[nums.length - k + 1];\n        Deque<Integer> deque = new ArrayDeque<>();\n\n        for (int i = 0; i < nums.length; i++){\n            if (!deque.isEmpty() && deque.peekFirst() + k <= i) deque.pollFirst();\n            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]){\n                deque.pollLast();\n            }\n            deque.offerLast(i);\n            if (i - k + 1 >= 0) ans[i - k + 1] = nums[deque.peekFirst()];\n        }\n        return ans;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\t\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468251558","body":"### 思路\n\n~~~bash\n图，也是经典题了，考虑到法官的出入度即可\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] count = new int[n + 1];\n        for (int[] edge : trust) {\n            int x = edge[0];\n            int y = edge[1];\n            ++count[y];\n            --count[x];\n        }\n        for (int i = 1; i < n + 1; i++) {\n            if (count[i] == n - 1) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\t\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1470112606","body":"### 思路\n\n~~~bash\n也是图的经典题了，染色问题，dfs遍历，没染色的话，就染相反的颜色，如果染色的话就判断一下，相同颜色直接return false\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    ArrayList<Integer>[] graph;\n    Map<Integer, Integer> color;\n\n    public boolean possibleBipartition(int N, int[][] dislikes) {\n        graph = new ArrayList[N+1];\n        for (int i = 1; i <= N; ++i)\n            graph[i] = new ArrayList();\n\n        for (int[] edge: dislikes) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n\n        color = new HashMap();\n        for (int node = 1; node <= N; ++node)\n            if (!color.containsKey(node) && !dfs(node, 0))\n                return false;\n        return true;\n    }\n\n    public boolean dfs(int node, int c) {\n        if (color.containsKey(node))\n            return color.get(node) == c;\n        color.put(node, c);\n\n        for (int nei: graph[node])\n            if (!dfs(nei, c ^ 1))\n                return false;\n        return true;\n    }\n}\n~~~\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1471895271","body":"### 思路\n\n~~~bash\n图，讲道理，自己没想出来，先提交作业了，后面自己再好好看下\n~~~\n\n### 代码\n\n~~~java\npublic class Solution {\n\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n        // 第 1 步：数据预处理，给没有归属于一个组的项目编上组号\n        for (int i = 0; i < group.length; i++) {\n            if (group[i] == -1) {\n                group[i] = m;\n                m++;\n            }\n        }\n\n        // 第 2 步：实例化组和项目的邻接表\n        List<Integer>[] groupAdj = new ArrayList[m];\n        List<Integer>[] itemAdj = new ArrayList[n];\n        for (int i = 0; i < m; i++) {\n            groupAdj[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < n; i++) {\n            itemAdj[i] = new ArrayList<>();\n        }\n\n        // 第 3 步：建图和统计入度数组\n        int[] groupsIndegree = new int[m];\n        int[] itemsIndegree = new int[n];\n\n        int len = group.length;\n        for (int i = 0; i < len; i++) {\n            int currentGroup = group[i];\n            for (int beforeItem : beforeItems.get(i)) {\n                int beforeGroup = group[beforeItem];\n                if (beforeGroup != currentGroup) {\n                    groupAdj[beforeGroup].add(currentGroup);\n                    groupsIndegree[currentGroup]++;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (Integer item : beforeItems.get(i)) {\n                itemAdj[item].add(i);\n                itemsIndegree[i]++;\n            }\n        }\n\n        // 第 4 步：得到组和项目的拓扑排序结果\n        List<Integer> groupsList = topologicalSort(groupAdj, groupsIndegree, m);\n        if (groupsList.size() == 0) {\n            return new int[0];\n        }\n        List<Integer> itemsList = topologicalSort(itemAdj, itemsIndegree, n);\n        if (itemsList.size() == 0) {\n            return new int[0];\n        }\n\n        // 第 5 步：根据项目的拓扑排序结果，项目到组的多对一关系，建立组到项目的一对多关系\n        // key：组，value：在同一组的项目列表\n        Map<Integer, List<Integer>> groups2Items = new HashMap<>();\n        for (Integer item : itemsList) {\n            groups2Items.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\n        }\n\n        // 第 6 步：把组的拓扑排序结果替换成为项目的拓扑排序结果\n        List<Integer> res = new ArrayList<>();\n        for (Integer groupId : groupsList) {\n            List<Integer> items = groups2Items.getOrDefault(groupId, new ArrayList<>());\n            res.addAll(items);\n        }\n        return res.stream().mapToInt(Integer::valueOf).toArray();\n    }\n\n    private List<Integer> topologicalSort(List<Integer>[] adj, int[] inDegree, int n) {\n        List<Integer> res = new ArrayList<>();\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            Integer front = queue.poll();\n            res.add(front);\n            for (int successor : adj[front]) {\n                inDegree[successor]--;\n                if (inDegree[successor] == 0) {\n                    queue.offer(successor);\n                }\n            }\n        }\n\n        if (res.size() == n) {\n            return res;\n        }\n        return new ArrayList<>();\n    }\n}\n~~~\n\n**复杂度分析**\n\n时间复杂度：O(m+n)\n\n空间复杂度：O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473266268","body":"### 思路\n\n~~~bash\n简而言之，左右和上下的次数要一样才能回到原点，我们就根据这个思路走下去即可\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        for(char move: moves.toCharArray()) {\n            if(move == 'R') {\n                x++;\n            } else if(move == 'L') {\n                x--;\n            } else if(move == 'U') {\n                y++;\n            } else if(move == 'D') {\n                y--;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474857992","body":"### 思路\n\n~~~bash\n没看太懂，先提交作业了\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int[] getOrder(int[][] tasks) {\n        int n = tasks.length;\n        int[] ans = new int[n];\n        int[][] extTasks = new int[n][3];\n        for(int i = 0; i < n; i++) {\n            extTasks[i][0] = i;\n            extTasks[i][1] = tasks[i][0];\n            extTasks[i][2] = tasks[i][1];\n        }\n        Arrays.sort(extTasks, (a,b)->a[1] - b[1]);\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[2] == b[2] ? a[0] - b[0] : a[2] - b[2]);\n        int time = 0;\n        int ai = 0;\n        int ti = 0;\n        while(ai < n) {\n            while(ti < n && extTasks[ti][1] <= time) {\n                pq.offer(extTasks[ti++]);\n\n            }\n            if(pq.isEmpty()) {\n                time = extTasks[ti][1];\n                continue;\n            }\n            int[] bestFit = pq.poll();\n            ans[ai++] = bestFit[0];\n            time += bestFit[2];\n        }\n        return ans;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(nlogn)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475289820","body":"### 思路\n\n~~~bash\n转换为分钟\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int numberOfRounds(String loginTime, String logoutTime) {\n        int res = 0;\n        int h = Integer.parseInt(loginTime.substring(0, 2));\n        int m = Integer.parseInt(loginTime.substring(3, 5));\n        int hh = Integer.parseInt(logoutTime.substring(0, 2));\n        int mm = Integer.parseInt(logoutTime.substring(3, 5));\n        if (h > hh || (h == hh && m > mm)) {\n            res += (23 - h + hh) * 4;\n        } else {\n            res += (hh - h - 1) * 4;\n        }\n        res += (60 - m) / 15;\n        res += mm / 15;\n        return res >= 0 ? res : 0;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(1)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476438600","body":"### 思路\n\n~~~bash\n枚举，也是经典题目了，使用 c1 和 c2 对字符串 a 和 b 分别进行词频统计，记字符串 a 和 b 的长度为 nnn 和 mmm。\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int minCharacters(String a, String b) {\n        int n = a.length(), m = b.length(), ans = 0x3f3f3f3f;\n        int[] c1 = new int[26], c2 = new int[26];\n        for (char c : a.toCharArray()) c1[c - 'a']++;\n        for (char c : b.toCharArray()) c2[c - 'a']++;\n        for (int i = 0; i < 26 && ans != 0; i++) {\n            // 3\n            int ca = n - c1[i], cb = m - c2[i];\n            ans = Math.min(ans, ca + cb);\n            if (i == 0) continue;\n            int r1 = 0, r2 = 0;\n            // 1\n            for (int j = i; j < 26; j++) r1 += c1[j];\n            for (int j = 0; j < i; j++) r1 += c2[j];\n            // 2\n            for (int j = i; j < 26; j++) r2 += c2[j];\n            for (int j = 0; j < i; j++) r2 += c1[j];\n            ans = Math.min(ans, Math.min(r1, r2));\n        }\n        return ans;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477746061","body":"### 思路\n\n~~~bash\n直接上快速排序\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n\n    private static final Random random = new Random();\n\n    public int[] sortArray(int[] nums) {\n        quickSort(nums, 0, nums.length - 1);\n        return nums;\n    }\n\n    private void quickSort(int[] nums, int left, int right) {\n        //递归退出条件\n        if (left >= right) {\n            return;\n        }\n        //随机选取法\n        int RandomIndex = left + random.nextInt(right - left + 1);\n        swap(nums, left, RandomIndex);\n\n        int pivot = nums[left];\n        int less = left;\n        int more = right + 1;\n        // 循环不变量：这里是左闭右闭区间\n        // 小于nums[pivot]区间：[left + 1, less]\n        // 等于nums[pivot]区间：[less + 1, i]\n        // 大于nums[pivot]区间：[more, right]\n        int i = left + 1;\n        while (i < more) {\n            if (nums[i] < pivot) {\n                less++;\n                swap(nums, i, less);\n                i++;\n            } else if (nums[i] == pivot) {\n                i++;\n            } else {\n                //这里不i++很重要！因为我们无法确定从尾部换来的元素是否小于nums[pivot]\n                more--;\n                swap(nums, i, more);\n            }\n        }\n        //less最后指向的一定是小于nums[pivot]的元素\n        swap(nums, left, less);\n        //同理more指向大于nums[pivot]的元素\n        quickSort(nums, left, less - 1);\n        quickSort(nums, more, right);\n    }\n\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(nlogn)\n\n空间复杂度：O(logn)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479488992","body":"### 思路\n\n~~~bash\n二分法，经典题了\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int mySqrt(int x) {\n        if(x==1)\n            return 1;\n        int left=0;\n        int right=46340;\n        while(left<=right){\n            int mid=left+(right-left)/2;\n            if(mid*mid>x){\n                right=mid-1;\n            }else if(mid*mid<x){\n                left=mid+1;\n            }else{\n                return mid;\n            }\n        }\n        return right;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(logn)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1481404377","body":"思路\n二分查找，今天加班，先交下作业\n\n代码\n        public int FirstBadVersion(int n)\n        {\n            int left = 1, right = n;\n            while (left < right)\n            { \n                int mid = left + (right - left) / 2; \n                if (IsBadVersion(mid))\n                {\n                    right = mid; \n                }\n                else\n                {\n                    left = mid + 1; \n                }\n            }\n            return left;\n        }\n复杂度分析\n\n时间复杂度：O(logn)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482990182","body":"class Solution {\n    public int reversePairs(int[] nums) {\n        if(nums.length == 0) return 0;\n        return reversePairsRecursive(nums, 0, nums.length - 1);\n    }\n    public int reversePairsRecursive(int[] nums, int l, int r){\n        if(l == r){\n            return 0;\n        } else {\n            int mid = (l + r) /2;\n            int n1 = reversePairsRecursive(nums, l, mid);\n            int n2 = reversePairsRecursive(nums, mid+1, r);\n            int res = n1 + n2;\n            // 统计下标对数量\n            int i = l;\n            int j = mid + 1;\n            while(i <= mid){\n                while(j <= r && (long) nums[i] > 2 *(long)nums[j]){\n                    j ++;\n                }\n                res += j - mid - 1;\n                i++;\n            }\n\n\n            // 合并两个排序数组\n            int[] sort = new int[r - l + 1];\n            int p1 = l, p2 = mid + 1;\n            int p = 0;\n            while(p1 <= mid || p2 <= r){\n                if(p1 > mid){\n                    sort[p++] = nums[p2++];\n                } else if(p2 > r) {\n                    sort[p++] = nums[p1++];\n                } else{\n                    if(nums[p1] < nums[p2]){\n                        sort[p++] = nums[p1++];\n                    } else{\n                        sort[p++] = nums[p2++];\n                    }\n                }\n            }\n            for(int k = 0; k < sort.length; k++){\n                nums[l + k] = sort[k];\n            }\n            return res;\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483850800","body":"class Solution {\n    public double solve(int[] nums) {\n        Arrays.sort(nums);\n        int streetLength = nums[nums.length - 1] - nums[0];\n        int low = 0, high = streetLength / 3 + 1;\n        while (low + 1 < high) {\n            int mid = low + (high - low) / 2;\n            if (isPossible(nums, mid, 3)) {\n                high = mid;\n            } else {\n                low = mid;\n            }\n        }\n        if (isPossible(nums, low, 3)) {\n            return low / 2D;\n        }\n        return high / 2D;\n    }\n\n    private boolean isPossible(int[] nums, int diameter, int lightNumber) {\n        int lightDiameter = -1;\n        int currentLightNum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > lightDiameter) {\n                currentLightNum++;\n                lightDiameter = nums[i] + diameter;\n            }\n            if (currentLightNum > lightNumber) {\n                return false;\n            }\n        }\n        return true;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1484135012","body":"class Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n        int n = nums.length, left = 0, right = nums[n - 1] - nums[0];\n        while(left <= right){\n            int mid = (left + right) / 2;\n            int cnt = 0;\n            for(int j = 0; j< n; j ++){\n                int i = binarySearch(nums, j, nums[j] - mid);\n                cnt += j - i;\n            }\n            if(cnt >= k){\n                right = mid -1;\n            } else {\n                left = mid +1;\n            }\n        }\n        return left;\n    }\n    public int binarySearch(int[] nums, int end, int target){\n        int left = 0, right = end;\n        while(left < right){\n            int mid = (left + right) / 2;\n            if(nums[mid] < target){\n                left = mid + 1;\n            } else{\n                right = mid;\n            }\n        }\n        return left;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1485050889","body":"public class Solution {\n\n    private int N;\n\n    public static final int[][] DIRECTIONS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    public int swimInWater(int[][] grid) {\n        this.N = grid.length;\n\n        int len = N * N;\n        // 下标：方格的高度，值：对应在方格中的坐标\n        int[] index = new int[len];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                index[grid[i][j]] = getIndex(i, j);\n            }\n        }\n\n        UnionFind unionFind = new UnionFind(len);\n        for (int i = 0; i < len; i++) {\n            int x = index[i] / N;\n            int y = index[i] % N;\n\n            for (int[] direction : DIRECTIONS) {\n                int newX = x + direction[0];\n                int newY = y + direction[1];\n                if (inArea(newX, newY) && grid[newX][newY] <= i) {\n                    unionFind.union(index[i], getIndex(newX, newY));\n                }\n\n                if (unionFind.isConnected(0, len - 1)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    private int getIndex(int x, int y) {\n        return x * N + y;\n    }\n\n    private boolean inArea(int x, int y) {\n        return x >= 0 && x < N && y >= 0 && y < N;\n    }\n\n    private class UnionFind {\n\n        private int[] parent;\n\n        public UnionFind(int n) {\n            this.parent = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n\n        public int root(int x) {\n            while (x != parent[x]) {\n                parent[x] = parent[parent[x]];\n                x = parent[x];\n            }\n            return x;\n        }\n\n        public boolean isConnected(int x, int y) {\n            return root(x) == root(y);\n        }\n\n        public void union(int p, int q) {\n            if (isConnected(p, q)) {\n                return;\n            }\n            parent[root(p)] = root(q);\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486965840","body":"public int maxVowels(String s, int k) {\n\n    if (s == null || s.length() < k)\n        return 0;\n\n    int res = 0;\n    Set<Character> set = new HashSet<>(){{\n        add('a');add('e');add('i');add('o');add('u');\n    }};\n\n    // init\n    for (int i = 0; i < k; i++)\n        if (set.contains(s.charAt(i)))\n            res++;\n\n    int cur = res;\n    for (int i = 1; i < s.length() - k + 1; i++) {\n\n        if (set.contains(s.charAt(i - 1)))\n            cur--;\n        if (set.contains(s.charAt(i + k - 1)))\n            cur++;\n\n        res = Math.max(res, cur);\n    }\n\n    return res;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488798487","body":"class Solution {\n     public double new21Game(int N, int K, int W) {\n        if (K == 0 || N >= K + W) return 1;\n        double dp[] = new double[N + 1],  Wsum = 1, res = 0;\n        dp[0] = 1;\n        for (int i = 1; i <= N; ++i) {\n            dp[i] = Wsum / W;\n            if (i < K) Wsum += dp[i]; else res += dp[i];\n            if (i - W >= 0) Wsum -= dp[i - W];\n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1490429116","body":"public List<Integer> findAnagrams(String s, String p) {\n\n    List<Integer> res = new LinkedList<>();\n    if (s == null || p == null || s.length() < p.length())\n        return res;\n\n    int[] ch = new int[26];\n    //统计p串字符个数\n    for (char c : p.toCharArray())\n        ch[c - 'a']++;\n    //把窗口扩成p串的长度\n    int start = 0, end = 0, rest = p.length();\n    for (; end < p.length(); end++) {\n        char temp = s.charAt(end);\n        ch[temp - 'a']--;\n        if (ch[temp - 'a'] >= 0)\n            rest--;\n    }\n\n    if (rest == 0)\n        res.add(0);\n    //开始一步一步向右移动窗口。\n    while (end < s.length()) {\n        //左边的拿出来一个并更新状态\n        char temp = s.charAt(start);\n        if (ch[temp - 'a'] >= 0)\n            rest++;\n        ch[temp - 'a']++;\n        start++;\n        //右边的拿进来一个并更新状态\n        temp = s.charAt(end);\n        ch[temp - 'a']--;\n        if (ch[temp - 'a'] >= 0)\n            rest--;\n        end++;\n        // 状态合法就存到结果集合\n        if (rest == 0)\n            res.add(start);\n    }\n\n    return res;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1492127475","body":"### 代码\n\n~~~java\nclass Solution {\n    public String minWindow(String s, String t) {\n        String res = \"\";\n        if (t.length() > s.length()) {\n            return res;\n        }\n        // need 是需要凑齐的字符\n        HashMap<Character, Integer> need = new HashMap<>();\n        // window 当前是当前窗口有几个字符\n        HashMap<Character, Integer> window = new HashMap<>();\n        // 遍历我们的需要覆盖的字符串，将结果加入至need 哈希表中\n        for (int i = 0; i < t.length(); i++) {\n            char ch = t.charAt(i);\n            need.put(ch, need.getOrDefault(ch, 0) + 1);\n        }\n        // left 起点\n        int l = 0;\n        // right 终点\n        int r = 0;\n        // 已经满足的字符个数，那么当valid的值 == t.size()时，那么就说明已经满足该窗口了\n        int valid = 0;\n        // 最大值\n        int len = Integer.MAX_VALUE;\n        // 其实位置，我们从0开始\n        int start = 0;\n        // 只要right没有超过s的边界，就无脑遍历\n        while (r < s.length()) {\n            // 这个是加进来的字符值\n            char ch = s.charAt(r);\n            // 加进来一个字符，那么right往右边移动一个位置\n            r++;\n            // 只有当该值在need里面时，我们才往里面加东西\n            if (need.containsKey(ch)) {\n                // 那么窗口里面先累加，这个时候只考虑我们需要的值，其它值不用考虑，反正有start起始位置，最后直接字符串截取即可\n                window.put(ch, window.getOrDefault(ch, 0) + 1);\n                // 如果窗口里面某个值的个数 == 需要的值的个数，那么说明我们其中一个满足了\n                if (window.get(ch).equals(need.get(ch))) {\n                    // valid就++\n                    valid++;\n                }\n            }\n            // 判断左侧窗口是否要收缩\n            // 当valid的值 == need的size，size就是key，就是distint字符的种类，都满足了，那说明就是有效了，该窗口肯定就符合了\n            // 那么我们开始收缩左窗口\n            while (valid == need.size()) {\n                // 在这里更新最小覆盖子串\n                // 趁着满足条件了，我们先更新再说，更新就更新一下其实位置和长度即可\n                if (r - l < len) {\n                    start = l;\n                    len = r - l;\n                }\n                // d 是将移出窗口的字符\n                // 取来，下面是要用的\n                char d = s.charAt(l);\n                // 左移窗口，无脑左移，我管你成功不成功，那不是我操心的事儿，你后面自己判断去吧\n                l++;\n                // 进行窗口内数据的一系列更新\n                // 判断在不在里面，不在，皆大欢喜，我继续左移，在的话就进去判断\n                // 进去了，不一定出来，可能中间加了多个，减去一个也没事儿\n                if (need.containsKey(d)) {\n                    // 我们进行判断，如果说，== 了，那么就说明再移除这个值就打破平衡了，那么我们就跳出来\n                    if (window.get(d).equals(need.get(d))) {\n                        // valid -- ,直接跳出来，反正上面的while 是valid == need.size()\n                        valid--;\n                    }\n                    // 这个是不管你是否对valid进行操作，我就把窗口里面的这个值的个数减一，我个人感觉这个\n                    // 放在判断valid是否--上面比较好，先搞那些无脑的操作，再进行比对，多顺畅\n                    window.put(d, window.get(d) - 1);\n                }\n            }\n        }\n        //  最后就是跳出来了，我们看下lec的长度是否还是我们的初始最大值，如果是，那么就说明一次都没进去过\n        //  如果不是，那么就截取我们定的最小长度的start和长度，进行相关的截取操作即可\n        return len == Integer.MAX_VALUE ? \"\" : s.substring(start, start + len);\n    }\n}\n~~~\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1493000518","body":"### 代码\n\n~~~java\npublic int MinOperations(int[] nums, int x){\n    int total = 0;\n    int length = nums.Length;\n    for (int i = 0; i < length; i++)\n    {\n        total += nums[i];\n    }\n    int remain = total - x;\n    if (remain == 0)\n    {\n        return length;\n    }\n    else if (remain < 0)\n    {\n        return -1;\n    }\n    int maxLength = -1;\n    int sum = 0;\n    int start = 0, end = 0;\n    while (end < length)\n    {\n        sum += nums[end];\n        while (sum > remain)\n        {\n            sum -= nums[start];\n            start++;\n        }\n        if (sum == remain)\n        {\n            maxLength = Math.Max(maxLength, end - start + 1);\n        }\n        end++;\n    }\n    return maxLength < 0 ? -1 : length - maxLength;\n}\n~~~\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493375439","body":"### 代码\n\n~~~java\nclass Solution {\n    public List<String> readBinaryWatch(int turnedOn) {\n        List<String> ans = new ArrayList<String>();\n        for (int h = 0; h < 12; ++h) {\n            for (int m = 0; m < 60; ++m) {\n                if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) {\n                    ans.add(h + \":\" + (m < 10 ? \"0\" : \"\") + m);\n                }\n            }\n        }\n        return ans;\n    }\n}\n~~~\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494466693","body":"### 代码\n\n~~~java\nclass Solution {\n    public int totalNQueens(int n) {\n        return solveNQueens(n).size();\n    }\n\n    public List<List<String>> solveNQueens(int n) {\n        List<List<String>> ans = new ArrayList<> ();\n        int[] cols = new int[n];\n        solveNQueens(n, 0, ans, cols);\n        return ans;\n    }\n\n    private void solveNQueens(int n, int row, List<List<String>> ans, int[] cols) {\n        if (row == n) {\n            List<String> oneAns = new ArrayList<> ();\n            for (int i = 0; i < n; i++) {\n                String tmp = \"\";\n                for (int j = 0; j < n; j++) {\n                    tmp += cols[i] == j ? \"Q\" : \".\";\n                }\n                oneAns.add(tmp);\n            }\n            ans.add(oneAns);\n            return;\n        }\n\n        for (int j = 0; j < n; j++) {\n            if (canVisit(n, cols, row, j)) {\n                cols[row] = j;\n                solveNQueens(n, row + 1, ans, cols);\n            }\n        }\n    }\n\n    private boolean canVisit(int n, int[] cols, int row, int col) {\n        int leftUp = col - 1, rightUp = col + 1;\n        for (int i = row - 1; i >= 0; i--) {\n            if (cols[i] == col) return false;\n            if (leftUp >= 0 && cols[i] == leftUp) return false;\n            if (rightUp < n && cols[i] == rightUp) return false;\n            leftUp--;rightUp++;\n        }\n        return true;\n    }\n}\n~~~\n\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501923410","body":"### 代码\n\n~~~java\nclass Solution {\n    public int findNumberOfLIS(int[] nums) {\n        int n = nums.length, maxLen = 0, ans = 0;\n        int[] dp = new int[n];\n        int[] cnt = new int[n];\n        for(int i = 0; i<n; i++){\n            dp[i] = 1;\n            cnt[i] = 1;\n            for(int j = 0; j<i; j++){\n                if(nums[i] > nums[j]){\n                    if(dp[j] + 1 > dp[i]){\n                        dp[i] = dp[j] + 1;\n                        cnt[i] = cnt[j]; // 重置计数\n                    } else if(dp[j] + 1 == dp[i]){\n                        cnt[i] += cnt[j];\n                    }\n                }\n            }\n            if(dp[i] > maxLen){\n                maxLen = dp[i];\n                ans = cnt[i];\n            } else if(dp[i] == maxLen){\n                ans += cnt[i];\n            }\n        }\n        return ans;\n    }\n}\n~~~\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tzuikuo":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429891420","body":"### 思路\n待补充\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        map<int,int> nummap;\n        vector<int> revec;\n        int n=num.size(),flag=0;\n        reverse(num.begin(),num.end());\n        for(int i=0;i<n;i++){\n            nummap[i]=num[i];\n        }\n        int i=0;\n        while(k!=0){\n            nummap[i]+=k%10;\n            k=k/10;\n            i++;\n        }\n        for(auto it=nummap.begin();it!=nummap.end();it++){\n            if(it->second>=10&&it->first<nummap.size()-1){\n                it->second-=10;\n                it++;\n                it->second+=1;\n                it--;\n            }\n            if(it->second>=10&&it->first==nummap.size()-1){\n                it->second-=10;\n                flag++;\n            }\n            revec.push_back(it->second);\n        }\n        if(flag) revec.push_back(1);\n        reverse(revec.begin(),revec.end());\n        return revec;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431487447","body":"### 思路\n待补充\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n=s.size();\n        vector<int> re;\n        for(int i=0;i<n;i++){\n            int left=i,right=i;\n            if(s[i]==c){\n                re.push_back(0);\n                continue;\n            }\n            left--;\n            right++;\n            while(true){\n                if(left<0&&right>n-1) break;\n                if(left>=0){\n                    if(s[left]==c){\n                        re.push_back(i-left);\n                        break;\n                    }\n                    left--;\n                } \n                if(right<=n-1){\n                    if(s[right]==c){\n                        re.push_back(right-i);\n                        break;\n                    }\n                    right++;\n                }\n            }\n        }\n        return re;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433245555","body":"### 思路\n用数组\n\n### 代码\n\n\n```C++\nclass CustomStack {\npublic:\n    int max_=0;\n    vector<int> vec;\n    CustomStack(int maxSize) {\n        max_=maxSize;\n    }\n    \n    void push(int x) {\n        if(vec.size()<max_) vec.push_back(x);\n    }\n    \n    int pop() {\n        int re=-1;\n        if(!vec.empty()){\n            re=vec[vec.size()-1];\n            vec.pop_back();\n        }\n        return re;\n    }\n    \n    void increment(int k, int val) {\n        if(vec.size()>0){\n            if(vec.size()<k){\n                for(int i=0;i<vec.size();i++) vec[i]+=val;\n            }\n            else{\n                for(int i=0;i<k;i++){\n                    vec[i]+=val;\n                }\n            }\n        }\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434724515","body":"### 思路\r\n栈\r\n\r\n### 代码\r\n\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        int n=s.size();\r\n        stack<string> stackstr;\r\n        stack<int> stacknum;\r\n        string curstr=\"\";\r\n        int curnum=0;\r\n        for(int i=0;i<n;i++){\r\n            if(s[i]>='0'&&s[i]<='9') curnum=curnum*10+(s[i]-'0');\r\n            if(s[i]>='a'&&s[i]<='z') curstr+=s[i];\r\n            if(s[i]=='['){\r\n                stackstr.push(curstr);\r\n                stacknum.push(curnum);\r\n                curstr=\"\";\r\n                curnum=0;\r\n            }\r\n            if(s[i]==']'){\r\n                string temp=curstr;\r\n                for(int i=0;i<stacknum.top()-1;i++) curstr+=temp;\r\n                curstr=stackstr.top()+curstr;\r\n                stackstr.pop();\r\n                stacknum.pop();\r\n            }\r\n        }\r\n        return curstr;\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435703493","body":"### 思路\n两个栈\n\n### 代码\n\n\n```C++\nclass MyQueue {\npublic:\n    stack<int> mainstack,tempstack;\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        mainstack.push(x);\n    }\n    \n    int pop(){\n        int temp;\n        if(!tempstack.empty()){\n            temp=tempstack.top();\n            tempstack.pop();\n        }\n        else{\n            while(!mainstack.empty()){\n                temp=mainstack.top();\n                mainstack.pop();\n                tempstack.push(temp);\n            }\n            temp=tempstack.top();\n            tempstack.pop(); \n        }  \n        return temp;\n    }\n    \n    int peek() {\n        if(!tempstack.empty()) return tempstack.top();\n        else{\n            while(!mainstack.empty()){\n                int temp=mainstack.top();\n                mainstack.pop();\n                tempstack.push(temp);\n            }   \n            return tempstack.top();\n        }\n    }\n    \n    bool empty() {\n        if(mainstack.empty()&&tempstack.empty()) return true;\n        return false;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436005055","body":"### 思路\r\n分块排序前后和一样，妙啊\r\n\r\n### 代码\r\n\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        long long sum1 = 0, sum2 = 0, ans = 0;\r\n        vector<int> t = arr;\r\n        sort(t.begin(), t.end());\r\n        for(int i = 0; i < arr.size(); i++) {\r\n            sum1 += t[i];\r\n            sum2 += arr[i];\r\n            if(sum1 == sum2) ans++;\r\n        }\r\n\treturn ans;\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437156067","body":"### 思路\n快慢指针\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        ListNode* slow=head,*fast=head,*newhead;\n        ListNode* cur=head;\n        int c=0;\n        if(!head||!head->next) return head;\n        while(cur){\n            cur=cur->next;\n            c++;\n        }\n        if(k>=c) k%=c;\n        while(k){\n            fast=fast->next;\n            k--;\n        }\n        while(fast->next){\n            fast=fast->next;\n            slow=slow->next;\n        }\n        fast->next=head;\n        newhead=slow->next;\n        slow->next=NULL;\n        return newhead;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438590472","body":"### 思路\n两个指针，虚拟头节点；\n讨论里有用递归的\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* pre,*left,*right,*last;\n        pre=new ListNode(0);\n        pre->next=head;\n        left=head;\n        if(head) right=head->next;\n        last=pre;\n        while(left&&left->next){\n            last->next=right;\n            left->next=right->next;\n            right->next=left;\n            last=left;\n            if(left&&left->next){\n               left=left->next;\n               right=left->next; \n            }\n        }\n        return pre->next;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440291205","body":"### 思路\n递归\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    TreeNode* buildBST(ListNode* head) {\n        if(!head) return nullptr;\n\n        ListNode *slow = head, *fast = head, *prev = nullptr;\n \n        while(fast && fast->next) {\n            prev = slow;\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        if(prev) prev -> next = nullptr;\n        if(slow == head) head = nullptr;\n\n        TreeNode* node = new TreeNode(slow->val);\n\n        node -> left = buildBST(head);\n        node -> right = buildBST(slow->next);\n\n        return node;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        return buildBST(head);\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441081771","body":"### 思路\n从剩下相同的长度处往后比较\n\n### 代码\n```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        int nA=0,nB=0;\n        ListNode* curA,*curB;\n        curA=headA;\n        curB=headB;\n        while(curA){\n            nA++;\n            curA=curA->next;\n        }\n        while(curB){\n            nB++;\n            curB=curB->next;\n        }\n        int diff=abs(nA-nB);\n        if(nA>nB){\n            while(diff)\n            {\n                headA=headA->next;\n                diff--;\n            }\n        }\n        else if(nB>nA){\n            while(diff)\n            {\n                headB=headB->next;\n                diff--;\n            }\n        }\n        while(headA&&headB){\n            if(headA==headB) return headA;\n            headA=headA->next;\n            headB=headB->next;\n        }\n\n        return nullptr;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(m+n)。m,n分别为两个链表的长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443881220","body":"### 思路\n快慢指针\n\n### 代码\n```C++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* slow=head,*fast=head;\n        if(!fast) return NULL;\n        while(fast && fast->next){\n            slow=slow->next;\n            fast=fast->next->next;\n            if(fast==slow){\n                break;\n            }\n        }\n        if(!(fast && fast->next)) return NULL;\n        else{\n            while(head!=slow){\n                head=head->next;\n                slow=slow->next;\n            }\n            return head;\n        }\n        return nullptr;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445120815","body":"### 思路\n待定\n\n### 代码\n```C++\nclass LRUCache\n{\n    public:\n        list<pair<int,int>> l;\n        unordered_map<int,list<pair<int, int>>::iterator> m;\n        int size;\n        LRUCache(int capacity)\n        {\n            size=capacity;\n        }\n        int get(int key)\n        {\n            if(m.find(key)==m.end())\n                return -1;\n            l.splice(l.begin(),l,m[key]);\n            return m[key]->second;\n        }\n        void put(int key, int value)\n        {\n            if(m.find(key)!=m.end())\n            {\n                l.splice(l.begin(),l,m[key]);\n                m[key]->second=value;\n                return;\n            }\n            if(l.size()==size)\n            {\n                auto d_key=l.back().first;\n                l.pop_back();\n                m.erase(d_key);\n            }\n            l.push_front({key,value});\n            m[key]=l.begin();\n        }\n};\n```\n\n**复杂度分析**\n待定","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445353146","body":"### 思路\r\n递归\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if(!root) return 0;\r\n        if(root->left&&root->right) return max(maxDepth(root->left)+1,maxDepth(root->right)+1);\r\n        else{\r\n            if(root->left) return maxDepth(root->left)+1;\r\n            else if(root->right) return maxDepth(root->right)+1;\r\n            else return 1;\r\n        } \r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间 O(N)\r\n- 空间 O(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446566986","body":"### 思路\n递归\n\n### 代码\n```C++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p&&!q) return true;\n        if(!p&&q||!q&&p) return false;\n        if(p->val!=q->val) return false;\n        return isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);\n    }\n};\n```\n\n**复杂度分析**\n- 时间 O(N)\n- 空间 O(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447483682","body":"### 思路\n递归，遍历\n\n### 代码\n```C++\nclass Solution {\npublic:\n    int curnum=0,sum=0;\n    int sumNumbers(TreeNode* root) {\n        traversal(root);\n        \n        return sum;\n    }\n    void traversal(TreeNode* cur){\n        curnum=curnum*10+cur->val;\n        if(cur->left) traversal(cur->left);\n        if(cur->right) traversal(cur->right);\n        if(!cur->left&&!cur->right){\n            sum+=curnum;\n        }\n        curnum=(curnum-cur->val)/10;\n        return;\n    }\n};\n```\n\n**复杂度分析**\n- 时间 O(N)\n- 空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449192905","body":"### 思路\n递归\n\n### 代码\n```C++\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> curq,lastq;\n        if(!root) return 0;\n        curq.push(root);\n        while(!curq.empty()){\n            TreeNode* left=curq.front();\n            while(!curq.empty()){\n                TreeNode* temp=curq.front();\n                if(temp->left) lastq.push(temp->left);\n                if(temp->right) lastq.push(temp->right);\n                curq.pop();\n            }\n            if(lastq.empty()) return left->val;\n            while(!lastq.empty()){\n                TreeNode* temp2=lastq.front();\n                curq.push(temp2);\n                lastq.pop();\n            }\n        }\n        return 0;\n    }\n};\n```\n\n**复杂度分析**\n待定","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454718621","body":"### 思路\nhashmap\n\n### 代码\n```C++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        map<int,int> mymap;\n        vector<int> re;\n        for(int i=0;i<nums.size();i++){\n            if(mymap.find(target-nums[i])!=mymap.end()){\n                re.push_back(mymap[target-nums[i]]);\n                re.push_back(i);\n                break;\n            }\n            if(mymap.find(nums[i])==mymap.end()) mymap[nums[i]]=i;\n        }\n\n        return re;\n    }\n};\n```\n\n**复杂度分析**\n- 时间 O(N)\n- 空间 O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456398458","body":"### 思路\nhashmap\n\n### 代码\n```C++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int n=points.size();\n        int d,cnt=0;\n        for(int i=0;i<n;i++){\n            map<int,int> mymap;\n            for(int j=0;j<n;j++){\n                if(i!=j){\n                    d=pow(points[i][0]-points[j][0],2)+pow(points[i][1]-points[j][1],2);\n                    mymap[d]++;\n                }\n            }\n            for(auto &p:mymap){\n                int temp=p.second;\n                if(temp) cnt+=temp*(temp-1);\n            }\n        }\n        return cnt;\n    }\n};\n```\n\n**复杂度分析**\n待定","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457271655","body":"### 思路\n待定\n\n### 代码\n```C++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        map<int,int> mymap;\n        int n=s.size(),maxx=0,left=0,len=0;\n        while(left<n){\n            if(mymap.find(s[left])==mymap.end()){\n                mymap[s[left]]=left;\n                len++;\n                left++;\n            }\n            else{\n                left=mymap[s[left]];\n                if(len>maxx) maxx=len;\n                len=0;\n                left++;\n                mymap.clear();\n            }\n        }\n        if(len>maxx) maxx=len;\n        return maxx;\n    }\n};\n```\n\n**复杂度分析**\n待定","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462252611","body":"### 思路\n待定\n\n### 代码\n```C++\nclass Solution {\npublic:\n    int minSubarray(vector<int>& nums, int p) {\n        int tmp = 0, res = nums.size(), need_to_remove = 0;\n        for (auto num : nums) need_to_remove = (need_to_remove + num) % p;\n        if (need_to_remove == 0) return 0;\n        \n        unordered_map<int, int> pre_sum;\n        pre_sum[0] = -1;\n        \n        for (int i = 0; i < nums.size(); i++) {\n            tmp = (tmp + nums[i]) % p;\n            pre_sum[tmp] = i;\n            int rest = (tmp - need_to_remove + p) % p;\n            \n            if (pre_sum.find(rest) != pre_sum.end()) res = min(res, i - pre_sum[rest]);\n        }\n        return res >= nums.size() ? -1 : res;\n    }\n};\n\n```\n\n**复杂度分析**\n待定","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465108248","body":"### 思路\n待定\n\n### 代码\n```C++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int n=nums.size(),left=0,right=n-1,med;\n        while(left<=right){\n            med=(left+right)/2;\n            if(target==nums[med]) return med;\n            else{\n                if(target>nums[med]){\n                    left=med+1;\n                }\n                else{\n                    right=med-1;\n                }\n            }\n        }\n        return left;\n    }\n};\n\n```\n\n**复杂度分析**\n待定","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465395921","body":"### 思路\n待定\n\n### 代码\n```C++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> maxqueue;\n        int n=nums.size();\n        vector<int> results;\n        for(int i=0;i<k;i++){\n            if(maxqueue.empty()) maxqueue.push_back(nums[i]);\n            else{\n                while(!maxqueue.empty()&&maxqueue.back()<nums[i]) maxqueue.pop_back();\n                maxqueue.push_back(nums[i]);\n            }\n        }\n        \n        for(int i=0;i<n-k;i++){\n            results.push_back(maxqueue.front());\n            //cout<<\"i=\"<<i<<\" \"<<maxqueue.front()<<\" \";\n            if(nums[i]==maxqueue.front()){\n                maxqueue.pop_front();\n            }\n            if(maxqueue.empty()) maxqueue.push_back(nums[i+k]);\n            else{\n                while(!maxqueue.empty()&&maxqueue.back()<nums[i+k]) maxqueue.pop_back();\n                maxqueue.push_back(nums[i+k]);\n                //cout<<\"i=\"<<i<<\" \"<<nums[i+k]<<\" \"<<endl;\n            }\n            //results.push_back(maxqueue.front());\n        }\n        results.push_back(maxqueue.front());\n        return results;\n    }\n};\n\n```\n\n**复杂度分析**\n待定","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467194264","body":"### 思路\n法官就是被n-1个人信任，信任0个人\n用两个map，记录每个人信任几个人和被几个人信任\n\n### 代码\n```C++\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        map<int,int> trustcnt,trustedcnt;\n        int m=trust.size();\n        for(int i=0;i<m;i++){\n            trustcnt[trust[i][0]-1]++;\n            trustedcnt[trust[i][1]-1]++;\n        }\n        for(int i=0;i<n;i++){\n            if(trustedcnt[i]==n-1&&trustcnt[i]==0) return i+1;\n        }\n\n        return -1;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间：O(N)\n- 空间：O(N)\nN=n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473702899","body":"### 思路\n上=下 左=右，就能返回\n\n### 代码\n```C++\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int n=moves.size();\n        int r=0,l=0,u=0,d=0;\n        for(int i=0;i<n;i++){\n            if(moves[i]=='R') r++;\n            if(moves[i]=='L') l++;\n            if(moves[i]=='U') u++;\n            if(moves[i]=='D') d++;\n        }\n        if(r==l&&u==d) return true;\n        else return false;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间：O(N)\n- 空间：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475283897","body":"### 思路\n登录时间，除以15向上取整；登出时间，除以15向下取整。相减。再处理一下边界。\n\n### 代码\n```C++\nclass Solution {\npublic:\n    int numberOfRounds(string loginTime, string logoutTime) {\n        int hin,min,hout,mout,timein,timeout,re;\n        hin=(loginTime[0]-'0')*10+(loginTime[1]-'0');\n        min=(loginTime[3]-'0')*10+(loginTime[4]-'0');\n        hout=(logoutTime[0]-'0')*10+(logoutTime[1]-'0');\n        mout=(logoutTime[3]-'0')*10+(logoutTime[4]-'0');\n        timein=hin*60+min;\n        timeout=hout*60+mout;\n        if(timein<timeout){\n            re=floor(timeout/15.0)-ceil(timein/15.0);\n        }\n        else{\n            re=24*60/15-ceil(timein/15.0)+floor(timeout/15.0);\n        }\n        if(re<0) re=0;\n        return re;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间：O(1)\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476342695","body":"### 思路\n待定\n\n### 代码\n```C++\nclass Solution {\npublic:\n    int minCharacters(string a, string b) {\n        int m = a.size(), n = b.size(), res = m + n;\n        vector<int> c1(26), c2(26);\n        for (char& c: a) c1[c - 'a']++;\n        for (char& c: b) c2[c - 'a']++;\n\n        for (int i = 0; i < 26; ++i) {\n            res = min(res, m + n - c1[i] - c2[i]); \n            if (i > 0) {\n                c1[i] += c1[i - 1];\n                c2[i] += c2[i - 1];\n            }\n            if (i < 25) {\n                res = min(res, m - c1[i] + c2[i]);\n                res = min(res, n - c2[i] + c1[i]); \n            }\n        }\n        return res;\n    }\n};\n\n```\n\n**复杂度分析**\n待定","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477406932","body":"### 思路\n写了一个好像很复杂的归并\n\n### 代码\n```C++\nclass Solution {\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> re;\n        re=merge(nums,0,n-1);\n\n        return re;\n    }\n    vector<int> merge(vector<int>& nums,int left,int right){\n        int mid,ii,jj;\n        vector<int> temp;\n        if(left==right){\n            temp.push_back(nums[left]);\n            return temp;\n        }\n        if(right==left+1){\n            if(nums[left]>nums[right]){\n                temp.push_back(nums[right]);\n                temp.push_back(nums[left]);\n            }\n            else{\n                temp.push_back(nums[left]);\n                temp.push_back(nums[right]);\n            }\n        }\n        else{\n            mid=(left+right)/2+1;\n            vector<int> vecleft,vecright;\n            vecleft=merge(nums,left,mid-1);\n            vecright=merge(nums,mid,right);\n            ii=0;\n            jj=0;\n            while(ii<vecleft.size()||jj<vecright.size()){\n                if(ii<vecleft.size()&&jj<vecright.size()){\n                    if(vecleft[ii]<vecright[jj]){\n                        temp.push_back(vecleft[ii]);\n                        ii++;\n                    }\n                    else{\n                        temp.push_back(vecright[jj]);\n                        jj++;\n                    }\n                }\n                else if(ii>=vecleft.size()){\n                    temp.push_back(vecright[jj]);\n                    jj++;\n                }\n                else{\n                    temp.push_back(vecleft[ii]);\n                    ii++;\n                }\n            }\n        }\n        return temp;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间O(nlogn)\n- 空间O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482676573","body":"### 思路\n归并的过程中记录逆序对数目\n\n### 代码\n```C++\nclass Solution {\npublic:\n    int cnt=0;\n    int reversePairs(vector<int>& nums) {\n        int n=nums.size();\n        mergesort(nums,0,n-1);\n        return cnt;\n    }\n    void mergesort(vector<int>& nums,int left,int right){\n      vector<int> temp;\n      int n=nums.size();\n      if(left==right){\n        temp.push_back(nums[left]);\n      }\n      else if(left==right-1){\n        if(nums[left]>(long long) 2*nums[right]) cnt++;\n        if(nums[left]>nums[right]){\n          temp.push_back(nums[right]);\n          temp.push_back(nums[left]);\n        }\n        else{\n          temp.push_back(nums[left]);\n          temp.push_back(nums[right]);\n        }\n      }\n      else{\n        int med=(right+left)/2;\n        mergesort(nums,left,med);\n        mergesort(nums,med+1,right);\n        int ii=left,jj=med+1;\n        int j=med+1;\n        for(int i=left;i<=med;i++){\n            while(j<=right&&nums[i]>(long long)2*nums[j]){\n                cnt+=(med-i+1);\n                j++;\n            }\n        }          \n        while(ii<=med||jj<=right){\n          if(ii<=med&&jj>right){\n            temp.push_back(nums[ii]);\n            ii++;\n          }\n          else if(ii>med&&jj<=right){\n            temp.push_back(nums[jj]);\n            jj++;\n          }\n          else{\n            if(nums[ii]>nums[jj]){\n              temp.push_back(nums[jj]);\n              jj++;\n            }\n            else{\n              temp.push_back(nums[ii]);\n              ii++;\n            }\n          }\n        }\n      }\n      for(int i=left;i<=right;i++){\n          nums[i]=temp[i-left];\n      }\n      return;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间O(nlogn)\n- 空间O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484523070","body":"### 思路\r\n优先级队列\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int swimInWater(vector<vector<int>>& grid) {\r\n        int m=grid.size(),n=grid[0].size();\r\n        int re=0;\r\n        vector<vector<int>> direc={{1,0},{-1,0},{0,-1},{0,1}};\r\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\r\n\r\n        pq.push({grid[0][0],{0,0}});\r\n        grid[0][0]=-1;\r\n        while(!pq.empty()){\r\n            int sz=pq.size();\r\n            while(sz--){\r\n                pair<int,pair<int,int>> cur;\r\n                cur=pq.top();\r\n                pq.pop();\r\n                re=max(re,cur.first);\r\n                if(cur.second.first==m-1&&cur.second.second==n-1) return re;\r\n                for(int i=0;i<=3;i++){\r\n                    int x=direc[i][0]+cur.second.first;\r\n                    int y=direc[i][1]+cur.second.second;\r\n                    if(x>=0&&x<m&&y>=0&&y<n&&grid[x][y]!=-1){\r\n                        pq.push({grid[x][y],{x,y}});\r\n                        grid[x][y]=-1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return re;\r\n    }\r\n    \r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间待定\r\n- 空间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1487018032","body":"### 思路\n待定\n\n### 代码\n```C++\nclass Solution {\npublic:\n    bool isvowel(char c){\n        return c=='a' or c=='e' or c=='i' or c=='o' or c=='u';\n    }\n    int maxVowels(string s, int k) {\n        int i=0;\n        int j=0;\n        int n=s.size();\n        int len=0;\n        int ctv=0;\n        int res=0;\n\t\t//Code starts\n        while(j<n){\n            if(isvowel(s[j])){\n                ctv++;\n            }\n            len++;\n            if(len>k){\n                if(isvowel(s[i])){\n                    ctv--;\n                }\n                i++;\n            }\n            res=max(res,ctv);\n            j++;\n        }\n        return res;\n    }\n};\n\n```\n\n**复杂度分析**\n待定","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488632059","body":"### 思路\n待定\n\n### 代码\n```C++\nclass Solution {\npublic:\n    double new21Game(int n, int k, int maxPts) {\n        if (k == 0 || n >= k + maxPts - 1) return 1.0;\n        vector<double> dp(n + 1);\n        dp[0] = 1.0;\n        double W = 1.0, res = 0.0;\n        for (int i = 1; i <= n; ++i) {\n            dp[i] = W / maxPts;\n            if (i < k) W += dp[i];\n            else res += dp[i];\n            if (i - maxPts >= 0) W -= dp[i - maxPts];\n        }\n        return res;\n    }\n};\n\n```\n\n**复杂度分析**\n待定","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1492039554","body":"### 思路\n滑动窗口\n\n### 代码\n```C++\nclass Solution {\npublic:\n    string minWindow(string s, string t) {\n        int n=s.size(),nt,i=0,mini=n+1,ii,jj;\n        map<char,int> mt;\n        string result;\n        \n        for(auto it:t) mt[it]++;\n        nt=mt.size();\n        for(int j=0;j<n;j++){\n            mt[s[j]]--;\n            if(mt[s[j]]==0) nt--;\n            //cout<<\"j=\"<<j<<\" \";\n            while(nt==0){\n                mt[s[i]]++;\n                if(mt[s[i]]>0) nt++;            \n                if(j-i+1<mini){\n                    mini=j-i+1;\n                    ii=i;\n                    jj=j;\n                }\n                i++;\n            }\n        }\n        for(int k=ii;k<=jj;k++){\n            result.push_back(s[k]);\n        }\n        return result;\n    }\n};\n\n```\n\n**复杂度分析**\n待定","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493195901","body":"### 思路\n回溯\n\n### 代码\n```C++\nclass Solution {\npublic:\n    int hour=0,min=0;\n    vector<string> re;\n    vector<int> rehour,remin;\n    vector<string> readBinaryWatch(int turnedOn) {\n        for(int i=0;i<=3;i++) rehour.push_back(0);\n        for(int i=0;i<=5;i++) remin.push_back(0);\n        recur(turnedOn);\n\n        return re;\n    }\n    void recur(int turnedOn){\n        //cout<<\"led=\"<<turnedOn<<endl;\n        if(turnedOn==0){\n           string newstr=\"\";\n           int hh=hour;\n           int mm=min;\n           char temp;\n           if(hh>=10){\n               temp='0'+hh/10;\n               newstr.push_back(temp);\n               temp='0'+hh%10;\n               newstr.push_back(temp);\n           }\n           else{\n               temp='0'+hh%10;\n               newstr.push_back(temp);\n           }\n           newstr.push_back(':');\n           if(mm>=10){\n               temp='0'+mm/10;\n               newstr.push_back(temp);\n               temp='0'+mm%10;\n               newstr.push_back(temp);\n           }\n           else{\n               newstr.push_back('0');\n               temp='0'+mm%10;\n               newstr.push_back(temp);\n           }\n           if(find(re.begin(),re.end(),newstr)==re.end()) re.push_back(newstr);\n           //cout<<newstr<<endl;\n           return; \n        }\n        else{\n            for(int i=0;i<=3;i++){\n                if(rehour[i]==1) continue;\n                hour+=pow(2,i);\n                if(hour>=12){\n                    hour-=pow(2,i);\n                    break;\n                }\n                else{\n                    rehour[i]=1;\n                    recur(turnedOn-1);\n                    hour-=pow(2,i);\n                    rehour[i]=0;\n                }\n            }\n            for(int i=0;i<=5;i++){\n                if(remin[i]==1) continue;\n                min+=pow(2,i);\n                if(min>=60){\n                    min-=pow(2,i);\n                    break;\n                }\n                else{\n                    remin[i]=1;\n                    recur(turnedOn-1);\n                    min-=pow(2,i);\n                    remin[i]=0;\n                }\n                \n            }\n        }\n        return;\n\n    }\n};\n\n```\n\n**复杂度分析**\n-时间 O(N!) N<=10\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1493648484","body":"### 思路\n回溯\n\n### 代码\n```C++\nclass Solution {\npublic:\n    vector<vector<int>> board;\n    vector<vector<int>> record;\n    vector<int> step;\n    int totalNQueens(int n) {\n        \n        for(int i=0;i<n;i++){\n            vector<int> temp;\n            for(int j=0;j<n;j++) temp.push_back(0);\n            board.push_back(temp);\n        }\n        recur(0,n);\n\n        return record.size();\n    }\n    void recur(int layer,int n){\n        if(layer>=n&&step.size()==n){\n            if(find(record.begin(),record.end(),step)==record.end())record.push_back(step);\n            for(int i=0;i<n;i++){\n                cout<<step[i]<<\" \";\n            }\n            cout<<endl;\n            return;\n        }\n        for(int i=0;i<n;i++){\n            if(board[layer][i]==0){\n                board[layer][i]=1;\n                step.push_back(i);\n                vector<vector<int>> flag(n,vector<int>(n));\n                for(int j=1;j<n;j++){\n                    if(layer+j<n&&board[layer+j][i]==0){\n                       board[layer+j][i]=-1; \n                       flag[layer+j][i]=1;\n                    }\n                    if(i+j<n&&layer+j<n&&board[layer+j][i+j]==0){\n                        board[layer+j][i+j]=-1;\n                        flag[layer+j][i+j]=1;\n                    }\n                    if(i-j>=0&&layer+j<n&&board[layer+j][i-j]==0){\n                        board[layer+j][i-j]=-1;\n                        flag[layer+j][i-j]=1;\n                    }\n                }\n                recur(layer+1,n);\n                board[layer][i]=0;\n                for(int j=1;j<n;j++){\n                    if(layer+j<n&&flag[layer+j][i]==1){\n                       board[layer+j][i]=0; \n                    }\n                    if(i+j<n&&layer+j<n&&flag[layer+j][i+j]==1){\n                        board[layer+j][i+j]=0;\n                    }\n                    if(i-j>=0&&layer+j<n&&flag[layer+j][i-j]==1){\n                        board[layer+j][i-j]=0;\n                    }\n                }\n                step.pop_back();\n            }\n        }\n    }\n};\n\n```\n\n**复杂度分析**\n-时间 O(N!)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495399450","body":"### 思路\n广度优先\n### 代码\n```C++\nclass Solution {\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int m=grid.size(),n=grid[0].size();\n        vector<vector<int>> record(m,vector<int>(n,0));\n        vector<vector<int>> direct={{0,1},{0,-1},{1,0},{-1,0}};\n        int cnt=0,remax=INT_MIN;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(grid[i][j]==1&&record[i][j]==0){\n                    int ii,jj;\n                    queue<vector<int>> myque;\n                    cnt=0;\n                    myque.push({i,j});\n                    record[i][j]=1;\n                    while(!myque.empty()){\n                        cnt++;\n                        vector<int> curvec;\n                        curvec=myque.front();\n                        myque.pop();\n                        ii=curvec[0];\n                        jj=curvec[1];\n                        for(int k=0;k<=3;k++){\n                            if(ii+direct[k][0]<m&&ii+direct[k][0]>=0&&jj+direct[k][1]<n&&jj+direct[k][1]>=0&&grid[ii+direct[k][0]][jj+direct[k][1]]==1&&record[ii+direct[k][0]][jj+direct[k][1]]==0){\n                                myque.push({ii+direct[k][0],jj+direct[k][1]});\n                                record[ii+direct[k][0]][jj+direct[k][1]]=1;\n                            }\n                        }\n                    }\n                    if(cnt>remax) remax=cnt;\n                }\n                else continue;\n            }\n        }\n        if(remax==INT_MIN) return 0; \n        return remax;\n    }\n};\n```\n\n**复杂度分析**\n-时间 O(n^2)\n-空间 O(n^2)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1499293167","body":"### 思路\n\n（此处撰写思路）\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    int maxCandies(vector<int>& status, vector<int>& candies, vector<vector<int>>& keys, vector<vector<int>>& containedBoxes, vector<int>& initialBoxes) \n    {\n        queue<int> q;\n        int result=0;\n        vector<bool> reachableClosedBoxes(status.size(),false);  //Only used to store boxes that are reached but closed.\n        for(int &i:initialBoxes)            //Push initial boxes that we can open in the queue.\n            if(status[i])\n                q.push(i);\n            else\n                reachableClosedBoxes[i]=true;\n        while(!q.empty())                   //Continue until no more boxes are left that can be opened.\n        {\n            result+=candies[q.front()];\t\t\t//Add candies we got.\n            for(int &i:keys[q.front()])\t\t\t\t//Open the box whose keys are found.\n            {\n                if(!status[i]&&reachableClosedBoxes[i])//If the box was previously closed and we already reached it,use it as an open box\n                    q.push(i);\n                status[i]=1;\n            }\n            for(int &i:containedBoxes[q.front()])\t\t//Push all the boxes within this box for then next cycle in the queue.\n                if(status[i])\n                    q.push(i);\n                else\n                    reachableClosedBoxes[i]=true;      //The box is closed, wait until we get the keys for this box.\n            q.pop();\n        }\n        return result;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500920817","body":"### 思路\n动态规划\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n=cost.size();\n        vector<int> dp(n+1);\n        if(n==1) return cost[0];\n        if(n==2) return min(cost[0],cost[1]);\n        for(int i=2;i<=n;i++){\n            dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);\n        }\n        return dp[n];\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1500923792","body":"### 思路\n动态规划，不能相邻。dp[i]的含义是前i间房子偷最多。两种情况，是否偷第i间。\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> dp(n);\n        if(n==1) return nums[0];\n        dp[0]=nums[0];\n        dp[1]=max(nums[0],nums[1]);\n        for(int i=2;i<n;i++){\n            dp[i]=max(dp[i-2]+nums[i],dp[i-1]);\n        }\n\n        return dp[n-1];\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501986610","body":"### 思路\n动态规划\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    int findNumberOfLIS(vector<int>& nums) {\n        int n=nums.size(),maxcount=1,re=0;\n        vector<vector<int>> dp(n,vector<int>(2,0));\n        cout<<1<<\" \";\n        dp[0][0]=1;\n        dp[0][1]=1;\n        for(int i=1;i<n;i++){\n            dp[i][0]=1;\n            for(int j=0;j<i;j++){\n                if(nums[i]>nums[j]) dp[i][0]=max(dp[i][0],dp[j][0]+1);\n            }\n            if(dp[i][0]>maxcount) maxcount=dp[i][0];\n            cout<<dp[i][0]<<\" \";\n        }\n        cout<<endl;\n        cout<<1<<\" \";\n        for(int i=1;i<n;i++){\n            for(int j=0;j<i;j++){\n                if(dp[j][0]==dp[i][0]-1&&nums[j]<nums[i]) dp[i][1]+=dp[j][1];\n                if(dp[i][0]==1) dp[i][1]=1;\n            }\n            cout<<dp[i][1]<<\" \";\n        }\n        for(int i=0;i<n;i++){\n            if(dp[i][0]==maxcount) re+=dp[i][1];\n        }\n        return re;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1502052200","body":"### 思路\n动态规划\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m=text1.size(),n=text2.size();\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\n\n        for(int i=1;i<=m;i++){\n            for(int j=1;j<=n;j++){\n                if(text1[i-1]==text2[j-1]){\n                    dp[i][j]=dp[i-1][j-1]+1;\n                }\n                else{\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(m*n)\n- 空间复杂度：O(m*n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1507659288","body":"### 思路\r\n动态规划\r\n\r\n### 代码\r\n\r\n\r\n```C++\r\nbool canIWin(int M, int T) \r\n  {\r\n    int sum = M*(M+1)/2; // sum of entire choosable pool\r\n\r\n    // I just pick 1 to win\r\n    if (T < 2) return true;\r\n    \r\n    // Total is too large, nobody can win\r\n    else if (sum < T) return false;\r\n    \r\n    // Total happens to match sum, whoever picks at odd times wins\r\n    else if (sum == T) return M%2;\r\n    \r\n    // Non-trivial case: do DFS\r\n    // Initial total: T\r\n    // Initial game state: k = 0 (all numbers are not picked)\r\n    else return dfs(M, T, 0);\r\n  }\r\n\r\n  // DFS to check if I can win\r\n  // k: current game state\r\n  // T: remaining total to reach\r\n  bool dfs(int M, int T, int k) \r\n  {\r\n    // memorized\r\n    if (mem[k] != 0) return mem[k] > 0;\r\n    \r\n    // total is already reached by opponent, so I lose\r\n    if (T <= 0) return false;\r\n\r\n    // try all currently available numbers\r\n    for (int i = 0; i < M; ++i)\r\n      // if (i+1) is available to pick and my opponent can't win after I picked, I win!\r\n      if (!(k&(1<<i)) && !dfs(M, T-i-1, k|(1<<i))) {\r\n        mem[k] = 1;\r\n        return true;\r\n      } \r\n    \r\n    // Otherwise, I will lose\r\n    mem[k] = -1;\r\n    return false;      \r\n  }\r\n\r\n  // m[key]: memorized game result when pool state = key\r\n  // 0: un-computed; 1: I win; -1: I lose\r\n  int mem[1<<20] = {};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(m*n)\r\n- 空间复杂度：O(m*n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1513167319","body":"### 思路\n动态规划\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        vector<int> dp(amount+1);\n        int n=coins.size();\n        for(int j=0;j<=amount;j++){\n            if(j%coins[0]==0) dp[j]=1;\n        }\n        for(int i=1;i<n;i++){\n            for(int j=coins[i];j<=amount;j++){\n                dp[j]=dp[j]+dp[j-coins[i]];\n            }\n        }\n\n        return dp[amount];\n    }\n};\n\n\n```\n\n**复杂度分析**\n待定","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517219672","body":"### 思路\n贪心，循环数组，记录跳最远的距离，不超过最远距离\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int maxright=0,n=nums.size();\n        for(int i=0;i<n;i++){\n            if(i>maxright) break;\n            maxright=max(maxright,i+nums[i]);\n        }\n        if(maxright>=n-1) return true;\n        return false;\n    }\n};\n\n\n```\n\n**复杂度分析**\n-时间O(n)\n-空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518689880","body":"### 思路\n分治\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n+1,0);\n        if(n==1) return 1;\n        if(n==2) return 2;\n        dp[0]=1;\n        dp[1]=1;\n        dp[2]=2;\n        for(int i=3;i<=n;i++){\n            for(int j=1;j<=i;j++){\n                dp[i]+=dp[j-1]*dp[i-j];\n                //cout<<\"i=\"<<i<<\" \"<<dp[j-1]*dp[n-j]<<endl;\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n```\n\n**复杂度分析**\n-待定","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519098610","body":"### 思路\n分治\n\n### 代码\n\n\n```C++\nclass cmp {\n     public:\n     bool operator()(ListNode* a, ListNode* b)\n     {\n         if(a->val > b->val)return true;\n         else return false;\n     }\n };\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists)\n     {\n        priority_queue<ListNode* , vector<ListNode*>,cmp> q;\n        ListNode* dummy = new ListNode(-1);\n        ListNode* tail = dummy;\n        for(int i = 0 ; i<lists.size() ; i++)\n        {\n            if(lists[i] != NULL)\n            {\n                q.push(lists[i]);\n            }\n        }\n        while(q.size() > 0)\n        {\n            ListNode* temp = q.top();\n            tail->next = temp;\n            tail = temp;\n            q.pop();\n            if(temp->next != NULL)q.push(temp->next);\n        }return dummy->next;\n    }\n};\n\n\n```\n\n**复杂度分析**\n-待定","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1520264385","body":"### 思路\n分治\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    vector<int> beautifulArray(int n) {\n        return solve(n);\n    }\n    \n    vector<int> solve(int n){\n        //base case\n        if(n==1) {\n            vector<int> k = {1};\n            return k;\n        }\n        \n        vector<int> ans = solve(n-1);\n        vector<int> temp;\n        for(int i = 0; i < ans.size(); i++){\n            if(2*ans[i]-1 <= n) temp.push_back(2*ans[i]-1);\n        }\n        for(int i = 0; i < ans.size(); i++){\n            if(2*ans[i] <= n) temp.push_back(2*ans[i]);\n        }\n        return temp;\n    }\n};\n\n\n```\n\n**复杂度分析**\n-待定","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528796232","body":"### 思路\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    vector<vector<int>> multiSearch(string big, vector<string>& smalls) {\n        vector<vector<int>> ans;\n        for(auto P : smalls){\n            ans.push_back({});\n            if(P.empty()){\n                continue;\n            }\n\n            //计算失配函数\n            vector<int> f(P.size()+1);\n            getFail(P,f);\n\n            \n            //在big中查找字符串P的所有出现位置\n            int j = 0;\n            for(int i=0;i<big.size();++i){\n                while(j && P[j] != big[i]){\n                    j = f[j];\n                }\n                if(P[j] == big[i]){\n                    j++;\n                }\n                if(j == P.size()){//找到了P\n                    ans.back().push_back(i-(j-1));\n                }\n            }\n            \n        }\n        return ans;\n    }\n\n    void getFail(const string& P,vector<int>& f){\n        f[0] = 0;\n        f[1] = 0;\n        for(int j=1;j<P.size();++j){\n            int k = f[j];\n            while(k && P[k] != P[j]){\n                k = f[k];\n            }\n\n            if(P[k] == P[j]){\n                f[j+1] = k + 1;\n            }else{\n                f[j+1] = 0;\n            }\n        }\n    }\n};\n\n```\n\n**复杂度分析**\n-待定","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1529040825","body":"### 思路\n\n并查集\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    vector<int> g[205];\n    int n, m, vis[205];\n\n    void dfs(int u) {\n        vis[u] = 1;\n        for(auto v: g[u]) {\n            if(!vis[v]) dfs(v);\n        }\n    }\n\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        memset(vis, 0, sizeof(vis));\n        n = isConnected.size(), m = isConnected[0].size();\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<m; j++) {\n                if(isConnected[i][j]) {\n                    g[i].push_back(j);\n                }\n            }\n        }\n\n        int ans = 0;\n        for(int u=0; u<n; u++) {\n            if(!vis[u]) {\n                ans++;\n                dfs(u);\n            }\n        }\n        return ans;\n    }\n};\n\n```\n\n**复杂度分析**\n-待定","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1531722965","body":"### 思路\n\n### 代码\n\n\n```C++\nclass Solution {\n    void dfs(vector<int> adj[], vector<bool> &visited, int src)\n    {\n        visited[src] = true;\n        for(int i : adj[src]){\n            if(!visited[i]){\n                dfs(adj, visited, i);\n            }\n        }\n    }\npublic:\n    int makeConnected(int n, vector<vector<int>>& arr) {\n        int len = arr.size();\n        if(len<n-1) return -1;\n         vector<int> adj[n];\n        for(auto v : arr)\n        {\n            adj[v[0]].push_back(v[1]);\n            adj[v[1]].push_back(v[0]);\n        }\n        vector<bool> visited(n, false);\n        int ans = 0;\n        for(int i=0; i<n; i++)\n        if(!visited[i])\n        {\n            dfs(adj, visited, i);\n            ans++;\n        }\n        return ans - 1;\n    }\n};\n\n```\n\n**复杂度分析**\n-待定","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1533166194","body":"### 思路\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    TreeNode* pruneTree(TreeNode* root) {\n        if(!ifhasone(root)) return NULL;\n        else{\n            traversal(root);\n        }\n        return root;\n    }\n    void traversal(TreeNode* root){\n        if(!root) return;\n        else{\n            if(!ifhasone(root->left)) root->left=NULL;\n            if(!ifhasone(root->right)) root->right=NULL;\n        }\n        traversal(root->left);\n        traversal(root->right);\n    }\n    bool ifhasone(TreeNode* tempnode){\n        if(!tempnode) return false;\n        if(tempnode->val==1) return true;\n        else{\n            return ifhasone(tempnode->left)||ifhasone(tempnode->right);\n        }\n    }\n};\n\n```\n\n**复杂度分析**\n-待定","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1537154459","body":"### 思路\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    vector<int> re;\n    vector<vector<int>> results;\n    set<vector<int>> results_s;\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        vector<int> used(nums.size());\n        backtracing(nums,used);\n        for(auto it=results_s.begin();it!=results_s.end();it++) results.push_back(*it);\n        return results;\n    }\n    void backtracing(vector<int>& nums,vector<int>& used){\n        if(ifallused(used)){\n            //vector<int> re_s;\n            //for(int ii=0;ii<re.size();ii++) re_s.push_back(re[ii]);\n            //sort(re_s.begin(),re_s.end());\n            results_s.insert(re);\n            return;\n        }\n        for(int i=0;i<nums.size();i++){\n            if(used[i]==0){\n                re.push_back(nums[i]);\n                used[i]=1;\n                backtracing(nums,used);\n                re.pop_back();\n                used[i]=0;\n            }\n            else continue;\n        }\n    }\n    bool ifallused(vector<int> &used){\n        int flag=0;\n        for(int i=0;i<used.size();i++){\n            if(used[i]==0) flag=1;\n        }\n        return !flag;\n    }\n};\n\n```\n\n**复杂度分析**\n-待定","onTime":true},null,null,null,null,null,null,null,null,null],"ringo1597":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brucezhang-utf-8":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luanxing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moin-jer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lihua1997":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cuizezhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuanaxuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tiandao043":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"restlessbreeze":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429917860","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int n = num.size();\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10) {\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            res.push_back(sum);\r\n        }\r\n        for (; k > 0; k /= 10) {\r\n            res.push_back(k % 10);\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431476973","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> ans(n);\r\n\r\n        for (int i = 0, idx = -n; i < n; ++i) {\r\n            if (s[i] == c) {\r\n                idx = i;\r\n            }\r\n            ans[i] = i - idx;\r\n        }\r\n\r\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\r\n            if (s[i] == c) {\r\n                idx = i;\r\n            }\r\n            ans[i] = min(ans[i], idx - i);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433162602","body":"### code\r\n```\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stk;\r\n    int top;\r\n\r\n    CustomStack(int maxSize) {\r\n        stk.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top != stk.size() - 1) {\r\n            ++top;\r\n            stk[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stk[top + 1];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int lim = min(k, top + 1);\r\n        for (int i = 0; i < lim; ++i) {\r\n            stk[i] += val;\r\n        }\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434687773","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    string getDigits(string &s, size_t &ptr) {\r\n        string ret = \"\";\r\n        while (isdigit(s[ptr])) {\r\n            ret.push_back(s[ptr++]);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string getString(vector <string> &v) {\r\n        string ret;\r\n        for (const auto &s: v) {\r\n            ret += s;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string decodeString(string s) {\r\n        vector <string> stk;\r\n        size_t ptr = 0;\r\n\r\n        while (ptr < s.size()) {\r\n            char cur = s[ptr];\r\n            if (isdigit(cur)) {\r\n                string digits = getDigits(s, ptr);\r\n                stk.push_back(digits);\r\n            } else if (isalpha(cur) || cur == '[') {\r\n                stk.push_back(string(1, s[ptr++])); \r\n            } else {\r\n                ++ptr;\r\n                vector <string> sub;\r\n                while (stk.back() != \"[\") {\r\n                    sub.push_back(stk.back());\r\n                    stk.pop_back();\r\n                }\r\n                reverse(sub.begin(), sub.end());\r\n                stk.pop_back();\r\n                int repTime = stoi(stk.back()); \r\n                stk.pop_back();\r\n                string t, o = getString(sub);\r\n                while (repTime--) t += o; \r\n                stk.push_back(t);\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435665075","body":"### code\r\n```\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n\r\n    void in2out() {\r\n        while (!inStack.empty()) {\r\n            outStack.push(inStack.top());\r\n            inStack.pop();\r\n        }\r\n    }\r\n\r\npublic:\r\n    MyQueue() {}\r\n\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    int pop() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n\r\n    int peek() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n\r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435990423","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        unordered_map<int, int> cnt;\r\n        int res = 0;\r\n        vector<int> sortedArr = arr;\r\n        sort(sortedArr.begin(), sortedArr.end());\r\n        for (int i = 0; i < sortedArr.size(); i++) {\r\n            int x = arr[i], y = sortedArr[i];\r\n            cnt[x]++;\r\n            if (cnt[x] == 0) {\r\n                cnt.erase(x);\r\n            }\r\n            cnt[y]--;\r\n            if (cnt[y] == 0) {\r\n                cnt.erase(y);\r\n            }\r\n            if (cnt.size() == 0) {\r\n                res++;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437043032","body":"### code\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (!head) return nullptr;\r\n        int length = 1;\r\n        ListNode* H = head;\r\n        while (H -> next)\r\n        {\r\n            H = H -> next;\r\n            length++;\r\n        }  \r\n        H -> next = head;\r\n        k = length - k % length;\r\n        while (k > 1)\r\n        {\r\n            head = head -> next;\r\n            k--;\r\n        }\r\n        H = head;\r\n        head = H -> next;\r\n        H -> next = nullptr;\r\n        return head;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437769132","body":"### code\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (!head || !head -> next)\r\n            return head;\r\n        ListNode* newHead = swapPairs(head -> next -> next);\r\n        ListNode* p = head -> next;\r\n        head -> next = newHead;\r\n        p -> next = head;\r\n        return p;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439377466","body":"### code\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* getMedium(ListNode* left, ListNode* right)\r\n    {\r\n        ListNode* S = left;\r\n        ListNode* F = left;\r\n        while (F != right && F -> next != right)\r\n        {\r\n            S = S -> next;\r\n            F = F -> next -> next;\r\n        }\r\n        return S;\r\n    }\r\n\r\n    TreeNode* BST(ListNode* l, ListNode* r)\r\n    {\r\n        if (l == r) return nullptr;\r\n        ListNode* me = getMedium(l, r);\r\n        TreeNode* med = new TreeNode(me -> val);\r\n        med -> left = BST(l, me);\r\n        med -> right = BST(me -> next, r);\r\n        return med;\r\n    }\r\n\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        return BST(head, nullptr);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441274715","body":"### code\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if (!headA || !headB) return nullptr;\r\n        ListNode *pa = headA;\r\n        ListNode *pb = headB;\r\n        while (pa != pb)\r\n        {\r\n            pa = pa == nullptr ? headB : pa -> next;\r\n            pb = pb == nullptr ? headA : pb -> next;\r\n        }\r\n        return pa;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442784316","body":"### code\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode *s = head;\r\n        ListNode *f = head;\r\n        while (f && f -> next)\r\n        {\r\n            s = s -> next;\r\n            f = f -> next -> next;\r\n            if (s == f) break;\r\n        }\r\n        if (!f || !f -> next) return nullptr;\r\n        f = head;\r\n        while (f != s)\r\n        {\r\n            s = s -> next;\r\n            f = f -> next;\r\n        }\r\n        return s;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1444862693","body":"### code\r\n```\r\nclass LRUCache {\r\npublic:\r\n    struct LRUNode\r\n    {\r\n        int key;\r\n        int val;\r\n        LRUNode* prev;\r\n        LRUNode* next;\r\n        LRUNode() : key(0), val(0), prev(nullptr), next(nullptr) {}\r\n        LRUNode(int _key, int _val) : key(_key), val(_val), prev(nullptr), next(nullptr) {}\r\n    };\r\n\r\n    LRUNode* front;\r\n    LRUNode* end;\r\n    int cap;\r\n    int nc;\r\n    unordered_map<int, LRUNode*> hash;\r\n    \r\n    LRUCache(int capacity) {\r\n        front = new LRUNode();\r\n        end = new LRUNode();\r\n        front -> next = end;\r\n        end -> prev = front;\r\n        cap = capacity;\r\n        nc = 0;\r\n    }\r\n    \r\n    int get(int key) {\r\n        int res = -1;\r\n        if (hash.count(key))\r\n        {\r\n            res = hash[key] -> val;\r\n            deleteFromlist(hash[key]);\r\n            addTofront(hash[key]);\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (hash.count(key))\r\n        {\r\n            hash[key] -> val = value;\r\n            deleteFromlist(hash[key]);\r\n            addTofront(hash[key]);    \r\n        }\r\n        else\r\n        {\r\n            if (nc == cap)\r\n            {\r\n                nc--;\r\n                hash.erase(end -> prev -> key);\r\n                deleteFromend();\r\n            }\r\n            nc++;\r\n            LRUNode* temp = new LRUNode(key, value);\r\n            addTofront(temp);  \r\n            hash[key] = temp; \r\n        }\r\n    }\r\n\r\n    void addTofront(LRUNode* temp)\r\n    {\r\n        temp -> next = front -> next;\r\n        front -> next -> prev = temp;\r\n        front -> next = temp;\r\n        temp -> prev = front;\r\n    }\r\n\r\n    void deleteFromend()\r\n    {\r\n        LRUNode* temp = end -> prev;\r\n        temp -> prev -> next = end;\r\n        end -> prev = temp -> prev;\r\n    }\r\n\r\n    void deleteFromlist(LRUNode* p)\r\n    {\r\n        LRUNode* q = p -> prev;\r\n        q -> next = p -> next;\r\n        p -> next -> prev = q;\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache* obj = new LRUCache(capacity);\r\n * int param_1 = obj->get(key);\r\n * obj->put(key,value);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445234940","body":"### code\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (!root) return 0;\r\n        int left = maxDepth(root->left);\r\n        int right = maxDepth(root->right);\r\n        return left > right ? left + 1 : right + 1;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446162673","body":"### code\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if (!p && !q) return true;\r\n        else if ((!p && q) || (!q && p)) return false;\r\n        else\r\n        {\r\n            if (q->val != p->val) return false;\r\n            else\r\n                return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n        }\r\n\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448229623","body":"### code\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n\r\n    int sum1(int a, TreeNode* root)\r\n    {\r\n        int b = 10 * a + root->val;\r\n        if (!root->left && !root->right) return b;\r\n        else if (!root->left && root->right) return sum1(b, root->right);\r\n        else if (root->left && !root->right) return sum1(b, root->left);\r\n        else return sum1(b, root->left) + sum1(b, root->right);\r\n    }\r\n\r\n    int sumNumbers(TreeNode* root) {\r\n        return sum1(0, root);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449505363","body":"### code\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    queue<TreeNode*>q;\r\n    int findBottomLeftValue(TreeNode* root) {\r\n        TreeNode* ans;\r\n        q.push(root);\r\n        while(!q.empty())\r\n        {\r\n            ans = q.front();\r\n            q.pop();\r\n            if (ans->right) q.push(ans->right);\r\n            if (ans->left) q.push(ans->left);\r\n        }\r\n        return ans->val;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451953806","body":"### code\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Codec {\r\npublic:\r\n\r\n    // Encodes a tree to a single string.\r\n    queue<TreeNode*> q;\r\n    vector<int> v;\r\n    string serialize(TreeNode* root) {\r\n        string s;\r\n        if (!root) return {};\r\n        q.push(root);\r\n        s += to_string(root->val);\r\n        s += ',';\r\n        while (!q.empty())\r\n        {\r\n            TreeNode* temp = q.front();\r\n            q.pop();\r\n            if (temp->left) \r\n            {\r\n                q.push(temp->left);\r\n                s += to_string(temp->left->val);\r\n                s += ',';\r\n            }\r\n            else\r\n                s += \"null,\";\r\n            if (temp->right) \r\n            {\r\n                q.push(temp->right);\r\n                s += to_string(temp->right->val);\r\n                s += ',';\r\n            }\r\n            else\r\n                s += \"null,\";\r\n        }\r\n        int length = s.size();\r\n        int flag = 0;\r\n        for (int i = length - 5; i >= 0; i -= 5)\r\n        {\r\n            if (s[i] != 'n')\r\n                break;\r\n            flag++;\r\n        }\r\n        s.resize(length - 1 - 5 * flag);\r\n        cout << s << endl;\r\n        return s;\r\n    }\r\n\r\n    int zifuzhuanshuzi(string temp)\r\n    {\r\n        int flag = 0;\r\n        if (temp[0] == '-')\r\n            flag = 1;\r\n        int sum = 0;\r\n        for (int c = flag; c < temp.size(); c++)\r\n        {\r\n            sum = sum * 10 + (temp[c] - '0');\r\n        }\r\n        cout << \"temp = \" << temp << \"sum = \" << sum << endl;\r\n        return flag == 0 ? sum : -sum;\r\n    }\r\n\r\n    void stringTovector(string data)\r\n    {\r\n        int length = data.size();\r\n        string temp = \"\";\r\n        for (int i = 0; i < length; i++)\r\n        {\r\n            if ((data[i] >= '0' && data[i] <= '9') || (data[i] == '-')) //数字\r\n                temp += data[i];\r\n            else if (data[i] == 'n')\r\n            {\r\n                i += 4;\r\n                v.push_back(1001);\r\n            }\r\n            else\r\n            {\r\n                v.push_back(zifuzhuanshuzi(temp));\r\n                temp = \"\";\r\n            }\r\n        }\r\n        v.push_back(zifuzhuanshuzi(temp));\r\n    }\r\n\r\n    int i = 0;\r\n\r\n    // Decodes your encoded data to tree.\r\n    queue<TreeNode*> q2;\r\n    TreeNode* deserialize(string data) \r\n    {\r\n        if (!data.size()) return nullptr;\r\n        stringTovector(data);\r\n        for (int i = 0; i < v.size(); i++)\r\n            cout << v[i] << endl;\r\n         \r\n        int flag = 0;\r\n        int length = v.size();\r\n        TreeNode* root = new TreeNode(v[flag]);\r\n        flag++;\r\n        cout << \"flag \" << flag << endl;\r\n        q2.push(root);\r\n        \r\n        while (!q2.empty() && (flag < length))\r\n        {\r\n            TreeNode* temp = q2.front();\r\n            cout << temp->val << endl;\r\n            q2.pop();\r\n            if ((flag < length) && (v[flag] < 1001)) \r\n            {\r\n                temp->left = new TreeNode(v[flag]);\r\n                q2.push(temp->left);\r\n            }\r\n            flag++;\r\n            cout << \"flag \" << flag << endl;\r\n            if ((flag < length) && (v[flag] < 1001)) \r\n            {\r\n                temp->right = new TreeNode(v[flag]);\r\n                q2.push(temp->right);\r\n            }\r\n            flag++;\r\n            cout << \"flag \" << flag << endl;\r\n        }\r\n        return root;\r\n    }\r\n};\r\n\r\n// Your Codec object will be instantiated and called as such:\r\n// Codec ser, deser;\r\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453543878","body":"### code\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    struct Node\r\n    {\r\n        int column;\r\n        int row;\r\n        int val;\r\n        Node(int _val, int _row, int _column) : val(_val), row(_row), column(_column) {}\r\n    };\r\n\r\n    vector<Node*> v;\r\n    void dfs(TreeNode* root, int row, int column)\r\n    {\r\n        if (!root) return;\r\n        Node *n = new Node(root->val, row, column);\r\n        v.push_back(n);\r\n        dfs(root->left, row + 1, column - 1);\r\n        dfs(root->right, row + 1, column + 1);\r\n    }\r\n\r\n    static bool cmp(Node* a, Node* b)\r\n    {\r\n        if (a->column != b->column) return a->column < b->column;\r\n        if (a->row != b->row) return a->row < b->row;\r\n        return a->val < b->val;\r\n    }\r\n\r\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        dfs(root, 0, 0);\r\n        sort(v.begin(), v.end(), cmp);\r\n        vector<vector<int>> res;\r\n\r\n        int MAX = -1001;\r\n        for (auto c : v)\r\n        {\r\n            if (c->column != MAX)\r\n            {\r\n                MAX = c->column;\r\n                res.emplace_back();\r\n            }\r\n            res.back().push_back(c->val);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454317935","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    unordered_map<int, int> p;\r\n    vector<int> twoSum(vector<int>& nums, int target) {\r\n        vector<int> res;\r\n        for (int i = 0; i < nums.size(); i++)\r\n        {\r\n            if (p.count(target - nums[i]))\r\n            {\r\n                res.push_back(i);\r\n                res.push_back(p[target - nums[i]]);\r\n                break;\r\n            }\r\n            p[nums[i]] = i;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455104515","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    static bool cmp(pair<int, int>& m, pair<int, int>& n) {\r\n        return m.second > n.second;\r\n    }\r\n\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int, int> occurrences;\r\n        for (auto& v : nums) {\r\n            occurrences[v]++;\r\n        }\r\n\r\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);\r\n        for (auto& [num, count] : occurrences) {\r\n            if (q.size() == k) {\r\n                if (q.top().second < count) {\r\n                    q.pop();\r\n                    q.emplace(num, count);\r\n                }\r\n            } else {\r\n                q.emplace(num, count);\r\n            }\r\n        }\r\n        vector<int> ret;\r\n        while (!q.empty()) {\r\n            ret.emplace_back(q.top().first);\r\n            q.pop();\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455715224","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int numberOfBoomerangs(vector<vector<int>>& points) {\r\n        int size = points.size(); \r\n        int ans = 0;\r\n        for (int i = 0; i < size; i++)\r\n        {\r\n            unordered_map<int, int> m;\r\n            for (int j = 0; j < size; j++)\r\n            {\r\n                if (i == j) continue;\r\n                int length = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\r\n                m[length]++;\r\n            }\r\n            for (auto& [k, v]: m)\r\n                ans += v * (v - 1);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1458165977","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n            int res = 0;\r\n            int length = 0;\r\n            unordered_map<char, int> mp;\r\n            int n = s.size();\r\n            int start = 0;\r\n            for (int i = 0; i < n; i++)\r\n            {\r\n                    if (!mp.count(s[i]) || mp[s[i]] < start)\r\n                    {\r\n                            length += 1;\r\n                            res= max(ans, length);\r\n                    }\r\n                    else\r\n                    {\r\n                            start = mp[s[i]] + 1;\r\n                            length = i - start + 1;\r\n                    }\r\n                    mp[s[i]] = i;\r\n            }\r\n            return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460045728","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n\r\n    unordered_map<string, int>m1;\r\n    int compare(string temp, int n, int length, unordered_map<string, int>m1)\r\n    {\r\n        unordered_map<string, int>m2;\r\n        for (int i = 0; i < n * length; i += length)\r\n        {\r\n            string temp1 = temp.substr(i, length);\r\n            m2[temp1]++;\r\n        }\r\n        for (unordered_map<string, int>::iterator it = m1.begin(); it != m1.end(); it++)\r\n        {\r\n            if (!m2.count(it->first) || m2[it->first] != it->second)\r\n                return -1 ;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    vector<int> findSubstring(string s, vector<string>& words) {\r\n        vector<int> res;\r\n        \r\n        int n = words.size(); //有n个单词\r\n        int length = words[0].length(); //每个单词的长度为length\r\n        int totallength = n * length;\r\n        for (int i = 0; i < n; i++)\r\n            m1[words[i]]++;\r\n        if (s.length() < totallength) return res;\r\n        for (int i = 0; i <= s.length() - totallength; i++)\r\n        {\r\n            string temp = s.substr(i, totallength);\r\n            int ans = compare(temp, n, length, m1);\r\n            if (ans != -1) res.push_back(i);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461324922","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int minSubarray(vector<int>& nums, int p) {\r\n        long long target = 0;\r\n        for (int i = 0; i < nums.size(); i++)\r\n            target += nums[i];\r\n        target = target % p;\r\n        if (target == 0) return 0;1` \r\n        int ans = nums.size();\r\n        unordered_map<int, int> m = {{0, -1}};\r\n        long long sum = 0;\r\n        for (int i = 0; i < nums.size(); i++)\r\n        {\r\n            sum += nums[i];\r\n            int mod = sum % p;\r\n            if (m.count((mod - target + p) % p))\r\n            {\r\n                if (i - m[(mod - target + p) % p] < ans)\r\n                    ans = i - m[(mod - target + p) % p];\r\n            }\r\n            m[mod] = i;\r\n        }\r\n        return ans == nums.size() ? -1 : ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463408405","body":"### code\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* middleNode(ListNode* head) {\r\n        ListNode* f = head;\r\n        ListNode* s = head;\r\n        while (f && f->next)\r\n        {\r\n            s = s->next;\r\n            f = f->next->next;\r\n        }\r\n        return s;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464745763","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int removeDuplicates(vector<int>& nums) {\r\n        if (nums.size() == 1) return 1;\r\n        int slow = 0;\r\n        int fast = 1;\r\n        while (fast < nums.size())\r\n        {\r\n            if (nums[fast] > nums[slow])\r\n            {\r\n                nums[++slow] = nums[fast++];\r\n            }    \r\n            else\r\n                fast++;\r\n        }\r\n        return slow + 1;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465064445","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int searchInsert(vector<int>& nums, int target) {\r\n        int left = 0;\r\n        int right = nums.size() - 1;\r\n        while (left <= right)\r\n        {\r\n            int middle = left + (right - left) / 2;\r\n            if (nums[middle] <target) \r\n                left = middle + 1;\r\n            else\r\n                right = middle - 1;\r\n        }\r\n        return left;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466148880","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n\r\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) \r\n    {\r\n        deque<int> q;\r\n        for (int i = 0; i < k; i++)\r\n        {\r\n            while (!q.empty() && nums[i] > nums[q.back()])\r\n                q.pop_back();\r\n            q.push_back(i);\r\n        }\r\n\r\n        vector<int> res = {nums[q.front()]};\r\n        int L = 1;\r\n        for (int i = k; i < nums.size(); i++, L++)\r\n        {\r\n            while (!q.empty() && nums[i] > nums[q.back()])\r\n                q.pop_back();         \r\n            q.push_back(i);\r\n            while (!q.empty() && q.front() < L)\r\n                q.pop_front();\r\n            res.push_back(nums[q.front()]);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467898866","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int findJudge(int n, vector<vector<int>>& trust) {\r\n        vector<int> indegree(n + 1);\r\n        vector<int> outdegree(n + 1);\r\n\r\n        for (int i = 0; i < trust.size(); i++)\r\n        {\r\n            outdegree[trust[i][0]]++;\r\n            indegree[trust[i][1]]++;\r\n        }\r\n\r\n        int ans = 0;\r\n        int flag = -1;\r\n        for (int i = 1; i <= n; i++)\r\n        {\r\n            if (indegree[i] == n - 1 && outdegree[i] == 0)\r\n            {\r\n                ans++;\r\n                flag = i;\r\n            }\r\n                \r\n        }\r\n\r\n        return ans == 1 ? flag : -1;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1470036646","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n\r\n    bool dfs(int node, int curcolor, vector<int>& color, vector<vector<int>>& g)\r\n    {\r\n        color[node] = curcolor;\r\n        for (int i = 0; i < g[node].size(); i++)\r\n        {\r\n            if (color[g[node][i]] == curcolor)\r\n                return false;\r\n            else if (color[g[node][i]] == 0 && !dfs(g[node][i], -curcolor, color, g))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\r\n\r\n        vector<int> color(n + 1);\r\n        vector<vector<int>> g(n + 1);\r\n        for (int i = 0; i < dislikes.size(); i++)\r\n        {\r\n            g[dislikes[i][0]].push_back(dislikes[i][1]);\r\n            g[dislikes[i][1]].push_back(dislikes[i][0]);\r\n        }\r\n        for (int i = 1; i <= n; i++)\r\n        {\r\n            if (color[i] == 0 && !dfs(i, 1, color, g))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1471130167","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> topSort(vector<int>& deg, vector<vector<int>>& graph, vector<int>& items) {\r\n        queue<int> Q;\r\n        for (auto& item: items) {\r\n            if (deg[item] == 0) {\r\n                Q.push(item);\r\n            }\r\n        }\r\n        vector<int> res;\r\n        while (!Q.empty()) {\r\n            int u = Q.front(); \r\n            Q.pop();\r\n            res.emplace_back(u);\r\n            for (auto& v: graph[u]) {\r\n                if (--deg[v] == 0) {\r\n                    Q.push(v);\r\n                }\r\n            }\r\n        }\r\n        return res.size() == items.size() ? res : vector<int>{};\r\n    }\r\n\r\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\r\n        vector<vector<int>> groupItem(n + m);\r\n        vector<vector<int>> groupGraph(n + m);\r\n        vector<vector<int>> itemGraph(n);\r\n\r\n        vector<int> groupDegree(n + m, 0);\r\n        vector<int> itemDegree(n, 0);\r\n        \r\n        vector<int> id;\r\n        for (int i = 0; i < n + m; ++i) {\r\n            id.emplace_back(i);\r\n        }\r\n\r\n        int leftId = m;\r\n        \r\n        for (int i = 0; i < n; ++i) {\r\n            if (group[i] == -1) {\r\n                group[i] = leftId;\r\n                leftId += 1;\r\n            }\r\n            groupItem[group[i]].emplace_back(i);\r\n        }\r\n        \r\n        for (int i = 0; i < n; ++i) {\r\n            int curGroupId = group[i];\r\n            for (auto& item: beforeItems[i]) {\r\n                int beforeGroupId = group[item];\r\n                if (beforeGroupId == curGroupId) {\r\n                    itemDegree[i] += 1;\r\n                    itemGraph[item].emplace_back(i);   \r\n                } else {\r\n                    groupDegree[curGroupId] += 1;\r\n                    groupGraph[beforeGroupId].emplace_back(curGroupId);\r\n                }\r\n            }\r\n        }\r\n\r\n        \r\n        vector<int> groupTopSort = topSort(groupDegree, groupGraph, id); \r\n        if (groupTopSort.size() == 0) {\r\n            return vector<int>{};\r\n        } \r\n        vector<int> ans;\r\n        \r\n        for (auto& curGroupId: groupTopSort) {\r\n            int size = groupItem[curGroupId].size();\r\n            if (size == 0) {\r\n                continue;\r\n            }\r\n            vector<int> res = topSort(itemDegree, itemGraph, groupItem[curGroupId]);\r\n            if (res.size() == 0) {\r\n                return vector<int>{};\r\n            }\r\n            for (auto& item: res) {\r\n                ans.emplace_back(item);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473773368","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    bool judgeCircle(string moves) {\r\n        int a = 0;\r\n        int b = 0;\r\n        for (auto& c : moves)\r\n        {\r\n            switch (c)\r\n            {\r\n                case 'L':\r\n                    a--;\r\n                    break;\r\n                case 'R':\r\n                    a++;\r\n                    break;\r\n                case 'U':\r\n                    b++;\r\n                    break;\r\n                case 'D':\r\n                    b--;\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n        return a == 0 && b == 0;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474664238","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    struct Node\r\n    {\r\n        int id;\r\n        long long enqueueTime;\r\n        long long processingTime;\r\n        Node(int _id, int _enqueueTime, int _processingTime) : id(_id) , enqueueTime(_enqueueTime), processingTime(_processingTime) {}\r\n    };\r\n    struct cmp1\r\n    {\r\n        bool operator()(Node* n1, Node* n2)\r\n        {\r\n                return n1->enqueueTime > n2->enqueueTime;\r\n        }\r\n    };\r\n    struct cmp2\r\n    {\r\n        bool operator()(Node* n1, Node* n2)\r\n        {\r\n            if (n1->processingTime == n2->processingTime)\r\n                return n1->id > n2->id;\r\n            else\r\n                return n1->processingTime > n2->processingTime;\r\n        }\r\n    };\r\n    vector<int> getOrder(vector<vector<int>>& tasks) {\r\n        priority_queue<Node*, vector<Node*>, cmp1> p1;\r\n        priority_queue<Node*, vector<Node*>, cmp2> p2;\r\n        for (int i = 0; i < tasks.size(); i++)\r\n            p1.push(new Node(i, tasks[i][0], tasks[i][1]));\r\n            \r\n        int execute = 0;\r\n        long long timestamp = 0;\r\n        vector<int> res;\r\n        while (execute < tasks.size())\r\n        {\r\n            if (p2.empty())\r\n            {\r\n                timestamp = max(timestamp, p1.top()->enqueueTime);\r\n                while (!p1.empty() && p1.top()->enqueueTime == timestamp)\r\n                {\r\n                    p2.push(p1.top());\r\n                    p1.pop();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                timestamp += p2.top()->processingTime;\r\n                res.push_back(p2.top()->id);\r\n                p2.pop();\r\n                execute++;\r\n                while (!p1.empty() && p1.top()->enqueueTime <= timestamp)\r\n                {\r\n                    p2.push(p1.top());\r\n                    p1.pop();\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475112511","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int numberOfRounds(string loginTime, string logoutTime) {\r\n\r\n        int sh = stoi(loginTime.substr(0, 2));\r\n        int sm = stoi(loginTime.substr(3, 2));\r\n        int lh = stoi(logoutTime.substr(0, 2));\r\n        int lm = stoi(logoutTime.substr(3, 2));\r\n        int result;\r\n\r\n        if (sh * 60 + sm < lh * 60 + lm)\r\n        {\r\n            int a1 = sm % 15;\r\n            if (a1 != 0) sm += (15 - a1);\r\n            result =  (lh * 60 + lm - sh * 60 - sm) / 15;\r\n        }\r\n        else\r\n            result = (lh * 60 + lm) / 15 + (1440 - sh * 60 - sm) / 15;\r\n        \r\n        return result;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476215088","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int minCharacters(string a, string b) {\r\n        vector<int> counterA(26);\r\n        vector<int> counterB(26);\r\n\r\n        for (auto& c : a)\r\n            counterA[c - 'a']++;\r\n            \r\n        for (auto& c : b)\r\n            counterB[c - 'a']++;\r\n\r\n        int min1 = 0;\r\n        for (int i = 0; i < 26; i++)\r\n        {\r\n            min1 = max(min1, counterA[i] + counterB[i]);\r\n        }\r\n        min1 = a.size() + b.size() - min1;\r\n\r\n        for (int i = 1; i < 26; i++)\r\n        {\r\n            counterA[i] += counterA[i - 1]; \r\n            counterB[i] += counterB[i - 1]; \r\n        }\r\n\r\n        int cur;\r\n        for (int i = 0; i < 25; i++)\r\n        {\r\n            cur = min((a.size() - counterA[i] + counterB[i]), (b.size() - counterB[i] + counterA[i]));\r\n            min1 = min(min1, cur);\r\n        }\r\n\r\n        return min1;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477868837","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n\r\n    void Merge(vector<int>&nums, vector<int>& temp, int lefts, int rights, int righte)\r\n    {\r\n        int lefte = rights - 1;\r\n        int len = righte - lefts + 1;\r\n        int flag = lefts;\r\n        while (lefts <= lefte && rights <= righte)\r\n        {\r\n            if (nums[lefts] <= nums[rights])\r\n                temp[flag++] = nums[lefts++];\r\n            else\r\n                temp[flag++] = nums[rights++];\r\n        }\r\n        while (lefts <= lefte)\r\n        {\r\n                temp[flag++] = nums[lefts++];\r\n        }\r\n        while (rights <= righte)\r\n        {\r\n                temp[flag++] = nums[rights++];\r\n        }\r\n        for (int i = 0; i < len; i++, righte--)\r\n            nums[righte] = temp[righte];\r\n    }\r\n\r\n    void Merge_sort(vector<int>& nums, vector<int>& temp, int left, int right)\r\n    {\r\n        if (left < right)\r\n        {\r\n            int mid = left + (right - left) / 2;\r\n            Merge_sort(nums, temp, left, mid);\r\n            Merge_sort(nums, temp, mid + 1, right);\r\n            Merge(nums, temp, left, mid + 1, right);\r\n        }\r\n    }\r\n\r\n    vector<int> sortArray(vector<int>& nums) \r\n    {\r\n        int size = nums.size();\r\n        vector<int> temp(size);\r\n        Merge_sort(nums, temp, 0, size - 1);\r\n        return nums;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1478760447","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int mySqrt(int x) {\r\n        if (x == 0) return 0;\r\n        int left = 1;\r\n        int right = x;\r\n        long long mid;\r\n        while (left <= right)\r\n        {\r\n            mid = left + (right - left) / 2;\r\n            if (mid * mid > x)\r\n                right = mid - 1;\r\n            else if ((mid * mid < x) && ((mid + 1) * (mid + 1) <= x))\r\n                left = mid + 1;\r\n            else\r\n                break;\r\n        }\r\n        return mid;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480676191","body":"### code\r\n```\r\n// The API isBadVersion is defined for you.\r\n// bool isBadVersion(int version);\r\n\r\nclass Solution {\r\npublic:\r\n    int firstBadVersion(int n) {\r\n        int left = 1;\r\n        int right = n;\r\n        while (left <= right)\r\n        {\r\n            int mid = left + (right - left) / 2;\r\n            if (isBadVersion(mid))\r\n                right = mid - 1;\r\n            else\r\n                left = mid + 1;\r\n        }\r\n        return left;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482933112","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int reversePairsRecursive(vector<int>& nums, int left, int right) {\r\n        if (left == right) {\r\n            return 0;\r\n        } else {\r\n            int mid = (left + right) / 2;\r\n            int n1 = reversePairsRecursive(nums, left, mid);\r\n            int n2 = reversePairsRecursive(nums, mid + 1, right);\r\n            int ret = n1 + n2;\r\n\r\n            int i = left;\r\n            int j = mid + 1;\r\n            while (i <= mid) {\r\n                while (j <= right && (long long)nums[i] > 2 * (long long)nums[j]) j++;\r\n                ret += (j - mid - 1);\r\n                i++;\r\n            }\r\n\r\n            vector<int> sorted(right - left + 1);\r\n            int p1 = left, p2 = mid + 1;\r\n            int p = 0;\r\n            while (p1 <= mid || p2 <= right) {\r\n                if (p1 > mid) {\r\n                    sorted[p++] = nums[p2++];\r\n                } else if (p2 > right) {\r\n                    sorted[p++] = nums[p1++];\r\n                } else {\r\n                    if (nums[p1] < nums[p2]) {\r\n                        sorted[p++] = nums[p1++];\r\n                    } else {\r\n                        sorted[p++] = nums[p2++];\r\n                    }\r\n                }\r\n            }\r\n            for (int i = 0; i < sorted.size(); i++) {\r\n                nums[left + i] = sorted[i];\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    int reversePairs(vector<int>& nums) {\r\n        if (nums.size() == 0) return 0;\r\n        return reversePairsRecursive(nums, 0, nums.size() - 1);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483818154","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int findRadius(vector<int> &houses, vector<int> &heaters) {\r\n        int ans = 0;\r\n        sort(heaters.begin(), heaters.end());\r\n        for (int house: houses) {\r\n            int j = upper_bound(heaters.begin(), heaters.end(), house) - heaters.begin();\r\n            int i = j - 1;\r\n            int rightDistance = j >= heaters.size() ? INT_MAX : heaters[j] - house;\r\n            int leftDistance = i < 0 ? INT_MAX : house - heaters[i];\r\n            int curDistance = min(leftDistance, rightDistance);\r\n            ans = max(ans, curDistance);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1484102636","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int smallestDistancePair(vector<int>& nums, int k) {\r\n        sort(nums.begin(), nums.end());\r\n        int n = nums.size(), left = 0, right = nums.back() - nums.front();\r\n        while (left <= right) {\r\n            int mid = (left + right) / 2;\r\n            int cnt = 0;\r\n            for (int j = 0; j < n; j++) {\r\n                int i = lower_bound(nums.begin(), nums.begin() + j, nums[j] - mid) - nums.begin();\r\n                cnt += j - i;\r\n            }\r\n            if (cnt >= k) {\r\n                right = mid - 1;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1485074591","body":"### code\r\n```\r\nstruct Entry {\r\n    int i;\r\n    int j;\r\n    int val;\r\n    bool operator<(const Entry& other) const {\r\n        return this->val > other.val;\r\n    }\r\n    Entry(int ii, int jj, int val): i(ii), j(jj), val(val) {}\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    int swimInWater(vector<vector<int>>& grid) {\r\n        int n = grid.size();\r\n        priority_queue<Entry, vector<Entry>, function<bool(const Entry& x, const Entry& other)>> pq(&Entry::operator<);\r\n        vector<vector<int>> visited(n, vector<int>(n, 0));\r\n        pq.push(Entry(0, 0, grid[0][0]));\r\n        int ret = 0;\r\n        vector<pair<int, int>> directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\r\n        while (!pq.empty()) {\r\n            Entry x = pq.top();\r\n            pq.pop();\r\n            if (visited[x.i][x.j] == 1) {\r\n                continue;\r\n            }\r\n            visited[x.i][x.j] = 1;\r\n            ret = max(ret, grid[x.i][x.j]);\r\n            if (x.i == n - 1 && x.j == n - 1) {\r\n                break;\r\n            }\r\n\r\n            for (const auto [di, dj]: directions) {\r\n                int ni = x.i + di, nj = x.j + dj;\r\n                if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\r\n                    if (visited[ni][nj] == 0) {\r\n                        pq.push(Entry(ni, nj, grid[ni][nj]));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486988272","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxVowels(string s, int k) {\r\n        int res = 0;\r\n        for (int i = 0; i < k; i++)\r\n        {\r\n            if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u')\r\n                res++;\r\n        }\r\n        int endIndex = k;\r\n        int startIndex = 1;\r\n        int curres = res;\r\n        for (; endIndex < s.length(); endIndex++, startIndex++)\r\n        {\r\n            if (s[startIndex - 1] == 'a' || s[startIndex - 1] == 'e' || s[startIndex - 1] == 'i' || s[startIndex - 1] == 'o' || s[startIndex - 1] == 'u')\r\n                curres--;\r\n            if (s[endIndex] == 'a' || s[endIndex] == 'e' || s[endIndex] == 'i' || s[endIndex] == 'o' || s[endIndex] == 'u')\r\n                curres++;\r\n            if (curres > res)\r\n                res = curres;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488818487","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    double new21Game(int n, int k, int maxPts) {\r\n        if (k == 0) {\r\n            return 1.0;\r\n        }\r\n        vector<double> dp(k + maxPts);\r\n        for (int i = k; i <= n && i < k + maxPts; i++) {\r\n            dp[i] = 1.0;\r\n        }\r\n        dp[k - 1] = 1.0 * min(n - k + 1, maxPts) / maxPts;\r\n        for (int i = k - 2; i >= 0; i--) {\r\n            dp[i] = dp[i + 1] - (dp[i + maxPts + 1] - dp[i + 1]) / maxPts;\r\n        }\r\n        return dp[0];\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1490406313","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> findAnagrams(string s, string p) {\r\n        int sLen = s.size(), pLen = p.size();\r\n\r\n        if (sLen < pLen) {\r\n            return vector<int>();\r\n        }\r\n\r\n        vector<int> ans;\r\n        vector<int> sCount(26);\r\n        vector<int> pCount(26);\r\n        for (int i = 0; i < pLen; ++i) {\r\n            ++sCount[s[i] - 'a'];\r\n            ++pCount[p[i] - 'a'];\r\n        }\r\n\r\n        if (sCount == pCount) {\r\n            ans.emplace_back(0);\r\n        }\r\n\r\n        for (int i = 0; i < sLen - pLen; ++i) {\r\n            --sCount[s[i] - 'a'];\r\n            ++sCount[s[i + pLen] - 'a'];\r\n\r\n            if (sCount == pCount) {\r\n                ans.emplace_back(i + 1);\r\n            }\r\n        }\r\n\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491988509","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    unordered_map <char, int> ori, cnt;\r\n\r\n    bool check() {\r\n        for (const auto &p: ori) {\r\n            if (cnt[p.first] < p.second) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    string minWindow(string s, string t) {\r\n        for (const auto &c: t) {\r\n            ++ori[c];\r\n        }\r\n\r\n        int l = 0, r = -1;\r\n        int len = INT_MAX, ansL = -1, ansR = -1;\r\n\r\n        while (r < int(s.size())) {\r\n            if (ori.find(s[++r]) != ori.end()) {\r\n                ++cnt[s[r]];\r\n            }\r\n            while (check() && l <= r) {\r\n                if (r - l + 1 < len) {\r\n                    len = r - l + 1;\r\n                    ansL = l;\r\n                }\r\n                if (ori.find(s[l]) != ori.end()) {\r\n                    --cnt[s[l]];\r\n                }\r\n                ++l;\r\n            }\r\n        }\r\n\r\n        return ansL == -1 ? string() : s.substr(ansL, len);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1492979899","body":"### code\r\n```\r\nclass Solution:\r\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\r\n        n = len(cardPoints)\r\n        totalSum = sum(cardPoints)\r\n        Sum = sum(cardPoints[:n - k])\r\n        maxPoints = totalSum - Sum\r\n\r\n        for i in range(k):\r\n            Sum += cardPoints[n - k + i] - cardPoints[i]\r\n            maxPoints = max(maxPoints, totalSum - Sum)\r\n        \r\n        return maxPoints\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493351073","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n\r\n    int cnt(int num)\r\n    {\r\n        int res = 0;\r\n        while (num != 0)\r\n        {\r\n            num = num & (num - 1);\r\n            res++;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    vector<string> readBinaryWatch(int turnedOn) {\r\n        vector<string> res;\r\n        for (int i = 0; i < 12; i++)\r\n        {\r\n            for (int j = 0; j < 60; j++)\r\n            {\r\n                if (cnt(i) + cnt(j) == turnedOn)\r\n                {\r\n                    res.push_back(to_string(i) + \":\" + (j < 10 ? \"0\" + to_string(j) : to_string(j)));\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494216109","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n\r\n    bool ok(int i, int j, vector<vector<int>>& path)\r\n    {\r\n        int m = 0;\r\n        int n = 0;\r\n        while (m < i)\r\n        {\r\n            if (path[m][j] == 1)\r\n                return false;\r\n            m++;\r\n        }\r\n        while (n < j)\r\n        {\r\n            if (path[i][n] == 1)\r\n                return false;\r\n            n++;\r\n        }\r\n        m = i - 1;\r\n        n = j - 1;\r\n        while (m >= 0 && n >= 0)\r\n        {\r\n            if (path[m][n] == 1)\r\n                return false;\r\n            m--;\r\n            n--;\r\n        }\r\n        m = i - 1;\r\n        n = j + 1;\r\n        while (m >= 0 && n < path[0].size())\r\n        {\r\n            if(path[m][n] == 1)\r\n                return false;\r\n            m--;\r\n            n++;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    void backtracking(int i, vector<vector<int>>& path, int& res)\r\n    {\r\n        if (i == path[0].size())\r\n        {\r\n            res++;\r\n            return;\r\n        }\r\n        for (int j = 0; j < path[0].size(); j++)\r\n        {\r\n            if (!ok(i, j, path))\r\n                continue;\r\n            path[i][j] = 1;\r\n            backtracking(i + 1, path, res);\r\n            path[i][j] = 0;\r\n        }\r\n    }\r\n\r\n    int totalNQueens(int n) {\r\n        vector<int> temp(n);\r\n        vector<vector<int>> path(n, temp);\r\n        int res = 0;\r\n        backtracking(0, path, res);\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1496096597","body":"### code\r\n```\r\nclass Solution:\r\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\r\n        row = len(grid)\r\n        col = len(grid[0])\r\n\r\n        def dfs(m,n):\r\n            if m<0 or m>=row or n<0 or n>=col or grid[m][n]!=1:\r\n                return 0\r\n            cnt = 1\r\n            grid[m][n]=0\r\n            cnt +=dfs(m-1,n)+dfs(m+1,n)+dfs(m,n-1)+dfs(m,n+1)\r\n            return cnt\r\n        res = 0\r\n        for i in range(row):\r\n            for j in range(col):\r\n                if grid[i][j]==1:\r\n                    res = max(res,dfs(i,j))\r\n        return res;\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497331132","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    static constexpr int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\r\n    static constexpr int MAX_N = 100 + 5;\r\n\r\n    struct Coordinate {\r\n        int x, y, step;\r\n    };\r\n\r\n    int n, m;\r\n    vector<vector<int>> a;\r\n\r\n    bool vis[MAX_N][MAX_N];\r\n\r\n    int findNearestLand(int x, int y) {\r\n        memset(vis, 0, sizeof vis);\r\n        queue <Coordinate> q;\r\n        q.push({x, y, 0});\r\n        vis[x][y] = 1;\r\n        while (!q.empty()) {\r\n            auto f = q.front(); q.pop();\r\n            for (int i = 0; i < 4; ++i) {\r\n                int nx = f.x + dx[i], ny = f.y + dy[i];\r\n                if (!(nx >= 0 && nx <= n - 1 && ny >= 0 && ny <= m - 1)) {\r\n                    continue;\r\n                }\r\n                if (!vis[nx][ny]) {\r\n                    q.push({nx, ny, f.step + 1});\r\n                    vis[nx][ny] = 1;\r\n                    if (a[nx][ny]) {\r\n                        return f.step + 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    int maxDistance(vector<vector<int>>& grid) {\r\n        this->n = grid.size();\r\n        this->m = grid.at(0).size();\r\n        a = grid;\r\n        int ans = -1;\r\n        for (int i = 0; i < n; ++i) {\r\n            for (int j = 0; j < m; ++j) {\r\n                if (!a[i][j]) {\r\n                    ans = max(ans, findNearestLand(i, j));\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498925602","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxCandies(vector<int>& status, vector<int>& candies, vector<vector<int>>& keys, vector<vector<int>>& containedBoxes, vector<int>& initialBoxes) {\r\n        int n = status.size();\r\n        vector<bool> can_open(n), has_box(n), used(n);\r\n        for (int i = 0; i < n; ++i) {\r\n            can_open[i] = (status[i] == 1);\r\n        }\r\n\r\n        queue<int> q;\r\n        int ans = 0;\r\n        for (int box: initialBoxes) {\r\n            has_box[box] = true;\r\n            if (can_open[box]) {\r\n                q.push(box);\r\n                used[box] = true;\r\n                ans += candies[box];\r\n            }\r\n        }\r\n        \r\n        while (!q.empty()) {\r\n            int big_box = q.front();\r\n            q.pop();\r\n            for (int key: keys[big_box]) {\r\n                can_open[key] = true;\r\n                if (!used[key] && has_box[key]) {\r\n                    q.push(key);\r\n                    used[key] = true;\r\n                    ans += candies[key];\r\n                }\r\n            }\r\n            for (int box: containedBoxes[big_box]) {\r\n                has_box[box] = true;\r\n                if (!used[box] && can_open[box]) {\r\n                    q.push(box);\r\n                    used[box] = true;\r\n                    ans += candies[box];\r\n                }\r\n            }\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1500330122","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    struct Node\r\n    {\r\n        int column;\r\n        int row;\r\n        int val;\r\n        Node(int _val, int _row, int _column) : val(_val), row(_row), column(_column) {}\r\n    };\r\n\r\n    vector<Node*> v;\r\n    void dfs(TreeNode* root, int row, int column)\r\n    {\r\n        if (!root) return;\r\n        Node *n = new Node(root->val, row, column);\r\n        v.push_back(n);\r\n        dfs(root->left, row + 1, column - 1);\r\n        dfs(root->right, row + 1, column + 1);\r\n    }\r\n\r\n    static bool cmp(Node* a, Node* b)\r\n    {\r\n        if (a->column != b->column) return a->column < b->column;\r\n        if (a->row != b->row) return a->row < b->row;\r\n        return a->val < b->val;\r\n    }\r\n\r\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        dfs(root, 0, 0);\r\n        sort(v.begin(), v.end(), cmp);\r\n        vector<vector<int>> res;\r\n\r\n        int MAX = -1001;\r\n        for (auto c : v)\r\n        {\r\n            if (c->column != MAX)\r\n            {\r\n                MAX = c->column;\r\n                res.emplace_back();\r\n            }\r\n            res.back().push_back(c->val);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500885381","body":"#### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int minCostClimbingStairs(vector<int>& cost) {\r\n        vector<int> dp(cost.size() + 1);\r\n        dp[0] = 0;\r\n        dp[1] = 0;\r\n        for (int i = 2; i < dp.size(); i++)\r\n            dp[i] = min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1]);\r\n        return dp[cost.size()];\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501130185","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int rob(vector<int>& nums) {\r\n        if (nums.size() == 1) return nums[0];\r\n        if (nums.size() == 2) return max(nums[0], nums[1]);\r\n        vector<int> temp(2);\r\n        vector<vector<int>> dp(nums.size(), temp);\r\n        dp[0][0] = nums[0];\r\n        dp[0][1] = 0;\r\n        for (int i = 1; i < nums.size(); i++)\r\n        {\r\n            dp[i][0] = dp[i - 1][1] + nums[i];\r\n            dp[i][1] = max(dp[i - 1][0], dp[i - 1][1]);\r\n        }\r\n        return max(dp[nums.size() - 1][0], dp[nums.size() - 1][1]);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501380723","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int findNumberOfLIS(vector<int>& nums) {\r\n        vector<int> dp(nums.size(), 1);\r\n        vector<int> count(nums.size(), 1);\r\n        int res = 0;\r\n        int maxlen = 0;\r\n        for (int i = 0; i < nums.size(); i++)\r\n        {\r\n            for (int j = 0; j < i; j++)\r\n            {\r\n                if (nums[i] > nums[j])\r\n                {\r\n                    if (dp[j] + 1 > dp[i])\r\n                    {\r\n                        dp[i] = dp[j] + 1;\r\n                        count[i] = count[j];\r\n                    }\r\n                    else if (dp[j] + 1 == dp[i])\r\n                    {\r\n                        count[i] += count[j];\r\n                    }\r\n                }\r\n            }\r\n            if (dp[i] > maxlen)\r\n            {\r\n                maxlen = dp[i];\r\n                res = count[i];\r\n            }\r\n            else if (dp[i] == maxlen)\r\n            {\r\n                res += count[i];\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1505278524","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int longestCommonSubsequence(string text1, string text2) {\r\n        vector<int> temp(text1.length() + 1);\r\n        vector<vector<int>> dp(text2.length() + 1, temp);\r\n\r\n        for (int i = 1; i <= text2.length(); i++)\r\n        {\r\n            for (int j = 1; j <= text1.length(); j++)\r\n            {\r\n                if (text2[i - 1] == text1[j - 1])\r\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\r\n                else\r\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\r\n            }\r\n        }\r\n        return dp[text2.length()][text1.length()];\r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1505282917","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int uniquePaths(int m, int n) {\r\n        vector<int> temp(n, 1);\r\n        vector<vector<int>> dp(m, temp);\r\n\r\n        for (int i = 1; i < m; i++)\r\n        {\r\n            for (int j = 1; j < n; j++)\r\n            {\r\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\r\n            }\r\n        }\r\n        return dp[m - 1][n - 1];\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506362515","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    double knightProbability(int n, int k, int row, int column) {\r\n\r\n        vector<vector<int>> dic = {{1, 2}, {2, 1}, {1, -2}, {2, -1}, {-1, 2}, {-2, 1}, {-1, -2}, {-2, -1}};\r\n\r\n        vector<vector<vector<double>>> dp(k + 1, vector<vector<double>>(n, vector<double>(n)));\r\n        dp[0][column][row] = 1;\r\n        for (int step = 1; step < k + 1; step++)\r\n        {\r\n            for (int i = 0; i < n; i++)\r\n            {\r\n                for (int j = 0; j < n; j++)\r\n                {\r\n                    for (int m = 0; m < 8; m++)\r\n                    {\r\n                        int lasti = i - dic[m][0];\r\n                        int lastj = j - dic[m][1];\r\n                        if (lasti >= 0 && lasti < n && lastj >= 0 && lastj < n)\r\n                            dp[step][i][j] += dp[step - 1][lasti][lastj] * 1 / 8;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        double res = 0;\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            for (int j = 0; j < n; j++)\r\n            {\r\n                res += dp[k][i][j];\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1507917568","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int res[1 << 21];\r\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\r\n        if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal)\r\n            return false;\r\n        if (maxChoosableInteger >= desiredTotal)\r\n            return true;\r\n        \r\n        return dfs(0, 0, maxChoosableInteger, desiredTotal);\r\n    }\r\n\r\n    bool dfs(int used, int cursum, int maxChoosableInteger, int desiredTotal)\r\n    {\r\n        if (res[used] == 1)\r\n            return true;\r\n        if (res[used] == 2)\r\n            return false;\r\n        for (int i = 1; i < maxChoosableInteger + 1; i++)\r\n        {\r\n            if (1 << i & used)\r\n                continue;\r\n            if (cursum + i >= desiredTotal)\r\n            {\r\n                res[used] = 1;\r\n                return true;\r\n            }  \r\n            if (!dfs(1 << i | used, cursum + i, maxChoosableInteger, desiredTotal))\r\n            {\r\n                res[used] = 1;\r\n                return true;\r\n            }  \r\n        }\r\n        res[used] = 2;\r\n        return false;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509442735","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    bool canPartition(vector<int>& nums) {\r\n\r\n        int sum = 0;\r\n        for (int i = 0; i < nums.size(); i++)\r\n            sum += nums[i];\r\n        if (sum % 2 != 0)\r\n            return false;\r\n        int target = sum / 2;\r\n        vector<int> dp(target + 1);\r\n        for (int i = 0; i < nums.size(); i++)\r\n        {\r\n            for (int j = target; j >= nums[i]; j--)\r\n            {\r\n                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);\r\n            }\r\n        }\r\n        return dp[target] == target ? true : false; \r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510022364","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int findTargetSumWays(vector<int>& nums, int target) {\r\n        int sum = 0;\r\n        for (int i = 0; i < nums.size(); i++)\r\n        {\r\n            sum += nums[i];\r\n        }\r\n        if (abs(target) > sum) \r\n            return 0;\r\n        if ((sum + target) % 2 != 0)\r\n            return 0;\r\n        target = (sum + target) / 2;\r\n        vector<int> dp(target + 1);\r\n        dp[0] = 1;\r\n        for (int i = 0; i < nums.size(); i++)\r\n        {\r\n            for (int j = target; j >= nums[i]; j--)\r\n            {\r\n                dp[j] = dp[j] + dp[j - nums[i]];\r\n            }\r\n        }\r\n        return dp[target];\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1510553017","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int coinChange(vector<int>& coins, int amount) {\r\n        vector<int> dp(amount + 1, INT_MAX);\r\n        dp[0] = 0;\r\n        for (int i = 0; i < coins.size(); i++)\r\n        {\r\n            for (int j = coins[i]; j <= amount; j++)\r\n            {\r\n                if (dp[j - coins[i]] < INT_MAX)\r\n                    dp[j] = min(dp[j], dp[j - coins[i]] + 1);\r\n            }\r\n        }\r\n        return dp[amount] == INT_MAX ? -1 : dp[amount];\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1518981165","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int change(int amount, vector<int>& coins) {\r\n        vector<int> dp(amount + 1);\r\n        dp[0] = 1;\r\n        for (int i = 0; i < coins.size(); i++)\r\n        {\r\n            for (int j = coins[i]; j < amount + 1; j++)\r\n            {\r\n                dp[j] = dp[j] + dp[j - coins[i]];\r\n            }\r\n        }\r\n        return dp[amount] == 0 ? 0 : dp[amount];\r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514208842","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int findContentChildren(vector<int>& g, vector<int>& s) {\r\n        int glength = g.size() - 1;\r\n        int slength = s.size() - 1;\r\n        sort(g.begin(), g.end());\r\n        sort(s.begin(), s.end());\r\n        int res = 0;\r\n        while (slength >= 0 && glength >= 0)\r\n        {\r\n            while (glength >= 0 && s[slength] < g[glength])\r\n                glength--;\r\n            if (glength < 0)\r\n                break;\r\n            slength--;\r\n            glength--;\r\n            res++;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516208343","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    static bool cmp(const vector<int>& a, const vector<int>& b)\r\n    {\r\n        return a[1] < b[1];\r\n    }\r\n\r\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\r\n        vector<int> dp(intervals.size(), 1);\r\n        sort(intervals.begin(), intervals.end(), cmp);\r\n        int res = 1;\r\n        int flag = intervals[0][1];\r\n        for (int i = 1; i < intervals.size(); i++)\r\n        {\r\n            if (intervals[i][0] >= flag)\r\n            {\r\n                res++;\r\n                flag = intervals[i][1];\r\n            }\r\n        }\r\n        \r\n        return intervals.size() - res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517104889","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    bool canJump(vector<int>& nums) {\r\n        int k = 0;\r\n        for (int i = 0; i < nums.size(); i++)\r\n        {\r\n            if (i > k)\r\n                return false;\r\n            k = max(k, i + nums[i]);\r\n        }\r\n        return true;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518456001","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int numTrees(int n) {\r\n        vector<int> dp(n + 1);\r\n        dp[0] = 1;\r\n        dp[1] = 1;\r\n        for (int i = 2; i <= n; i++)\r\n        {\r\n            for (int j = 0; j < i; j++)\r\n            {\r\n                dp[i] += dp[j] * dp[i - 1 - j];\r\n            }\r\n        }\r\n        return dp[n];\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1518912621","body":"### code\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* merge(ListNode* A, ListNode* B)\r\n    {\r\n        ListNode* temp = new ListNode(0);\r\n        ListNode* newHead = temp;\r\n        while (A && B)\r\n        {\r\n            if (A->val < B->val)\r\n            {\r\n                temp->next = A;\r\n                A = A->next;\r\n                temp = temp->next;\r\n            }\r\n            else\r\n            {\r\n                temp->next = B;\r\n                B = B->next;\r\n                temp = temp->next;\r\n            }\r\n        }\r\n        while (A)\r\n        {\r\n            temp->next = A;\r\n            A = A->next;\r\n            temp = temp->next;\r\n        }\r\n        while (B)\r\n        {\r\n            temp->next = B;\r\n            B = B->next;\r\n            temp = temp->next;\r\n        }\r\n        return newHead->next;\r\n    }\r\n\r\n    ListNode* Merge(vector<ListNode*>& lists, int left, int right)\r\n    {\r\n        if (left == right)\r\n            return lists[left];\r\n        int mid = left + (right - left) / 2;\r\n        return merge(Merge(lists, left, mid), Merge(lists, mid + 1, right));\r\n    }\r\n\r\n\r\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\r\n        int n = lists.size();\r\n        if (n == 0)\r\n            return nullptr;\r\n        if (n == 1)\r\n            return lists[0];\r\n        ListNode* head = Merge(lists, 0, n - 1);\r\n        return head;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1519330503","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> bea(int n)\r\n    {\r\n        vector<int> ans(n, 0);\r\n        if (n != 1)\r\n        {\r\n            int t = 0;\r\n            for (auto x : bea((n + 1) / 2))\r\n                ans[t++] = 2 * x - 1;\r\n            for (auto x : bea(n / 2))\r\n                ans[t++] = 2 * x;\r\n        }\r\n        else\r\n            ans[0] = 1;\r\n        return ans;\r\n    }\r\n\r\n    vector<int> beautifulArray(int n) {\r\n        return bea(n);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521051311","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> singleNumber(vector<int>& nums) {\r\n        vector<int> ans(2, 0);\r\n        long long res = 0;\r\n        for (int i = 0; i < nums.size(); i++)\r\n        {\r\n            res ^= nums[i];\r\n        }\r\n        res = res & (-res);\r\n        for (int i = 0; i < nums.size(); i++)\r\n        {\r\n            if ((nums[i] & res) == 0)\r\n            {\r\n                ans[0] ^= nums[i];\r\n            }\r\n            else\r\n            {\r\n                ans[1] ^= nums[i];\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1522570432","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> path;\r\n    vector<vector<int>> res;\r\n\r\n    void backtrack(vector<int>& nums, int startindex)\r\n    {\r\n        res.push_back(path);\r\n        if (startindex >= nums.size())\r\n        { \r\n            return;\r\n        }\r\n        for (int i = startindex; i < nums.size(); i++)\r\n        {\r\n            path.push_back(nums[i]);\r\n            backtrack(nums, i + 1);\r\n            path.pop_back();\r\n        }\r\n    }\r\n\r\n    vector<vector<int>> subsets(vector<int>& nums) {\r\n        backtrack(nums, 0);\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1525597638","body":"### code\r\n```\r\nclass Trie {\r\n    Trie *child[26];\r\n    bool isWord;\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    Trie() {\r\n        isWord = false;\r\n        for(int i=0;i<26;i++){\r\n            child[i] = nullptr;\r\n        }\r\n    }\r\n    \r\n    /** Inserts a word into the trie. */\r\n    void insert(string word) {\r\n        Trie *t = this;\r\n        for(char c: word){\r\n            if(!t -> child[c-'a']){\r\n                t->child[c-'a'] = new Trie();\r\n            }\r\n            t = t->child[c-'a'];\r\n        }\r\n        t->isWord = true;\r\n    }\r\n    \r\n    /** Returns if the word is in the trie. */\r\n    bool search(string word) {\r\n        Trie *t = this;\r\n        for(char c:word){\r\n            if(!t -> child[c - 'a']){\r\n                return false;\r\n            }\r\n            t = t->child[c - 'a'];\r\n        }\r\n        return t->isWord;\r\n    }\r\n    \r\n    /** Returns if there is any word in the trie that starts with the given prefix. */\r\n    bool startsWith(string prefix) {\r\n        Trie *t = this;\r\n        for(char c:prefix){\r\n            if(!t->child[c-'a']){\r\n                return false;\r\n            }\r\n            t = t->child[c - 'a'];\r\n        }\r\n        return true;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1527438244","body":"### code\r\n```\r\nstruct TrieNode {\r\n    int val;\r\n    TrieNode * next[26];\r\n    TrieNode() {\r\n        this->val = 0;\r\n        for (int i = 0; i < 26; ++i) {\r\n            this->next[i] = nullptr;\r\n        }\r\n    }\r\n};\r\n\r\nclass MapSum {\r\npublic:\r\n    MapSum() {\r\n        this->root = new TrieNode();\r\n    }\r\n    \r\n    void insert(string key, int val) {\r\n        int delta = val;\r\n        if (cnt.count(key)) {\r\n            delta -= cnt[key];\r\n        }\r\n        cnt[key] = val;\r\n        TrieNode * node = root;\r\n        for (auto c : key) {\r\n            if (node->next[c - 'a'] == nullptr) {\r\n                node->next[c - 'a'] = new TrieNode();\r\n            }\r\n            node = node->next[c - 'a'];\r\n            node->val += delta;\r\n        }\r\n    }\r\n    \r\n    int sum(string prefix) {\r\n        TrieNode * node = root;\r\n        for (auto c : prefix) {\r\n            if (node->next[c - 'a'] == nullptr) {\r\n                return 0;\r\n            } else {\r\n                node = node->next[c - 'a'];\r\n            }\r\n        }\r\n        return node->val;\r\n    }\r\nprivate:\r\n    TrieNode * root;\r\n    unordered_map<string, int> cnt;\r\n};\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528457267","body":"### code\r\n```\r\nstruct TrieNode\r\n{\r\n    int id;\r\n    TrieNode* child[26];\r\n    TrieNode()\r\n    {\r\n        id = -1;\r\n        for (int i = 0; i < 26; i++)\r\n            child[i] = nullptr;\r\n    }\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    TrieNode* root = new TrieNode();\r\npublic:\r\n    void Insert(string& s, int id)\r\n    {\r\n        TrieNode* temp = root;\r\n        for (char c : s)\r\n        {\r\n            if (!temp->child[c - 'a'])\r\n                temp->child[c - 'a'] = new TrieNode();\r\n            temp = temp->child[c - 'a'];\r\n        }\r\n        temp->id = id;\r\n    }\r\n\r\n    void search(string& s, vector<vector<int>>& res, int i)\r\n    {\r\n        TrieNode* temp = root;\r\n        for (char c : s)\r\n        {\r\n            if (!temp->child[c - 'a'])\r\n                break;\r\n            else\r\n            {\r\n                temp = temp->child[c - 'a'];\r\n                if (temp->id != -1)\r\n                {\r\n                    res[temp->id].push_back(i);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    vector<vector<int>> multiSearch(string big, vector<string>& smalls) \r\n    {\r\n        int n = smalls.size();\r\n        int m = big.length();\r\n        vector<vector<int>> res(n, vector<int>{});\r\n\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            if (smalls[i].length() == 0)\r\n                continue;\r\n            Insert(smalls[i], i);\r\n        }\r\n\r\n        for (int i = 0; i < m; i++)\r\n        {\r\n            string temp = big.substr(i, m - i);\r\n            search(temp, res, i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1528916693","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    void bfs(const vector<vector<int>>& isConnected, vector<int>& visited, int i)\r\n    {\r\n        stack<int> stk;\r\n        stk.push(i);\r\n        visited[i] = 1;\r\n        while (!stk.empty())\r\n        {\r\n            int temp = stk.top();\r\n            stk.pop();\r\n            for (int p = 0; p < isConnected.size(); p++)\r\n            {\r\n                if (visited[p] == 0 && isConnected[temp][p] == 1)\r\n                {\r\n                    stk.push(p);\r\n                    visited[p] = 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    int findCircleNum(vector<vector<int>>& isConnected) {\r\n        int m = isConnected.size();\r\n        vector<int> visited(m, 0);\r\n        int res = 0;\r\n        for (int i = 0; i < m; i++)\r\n        {\r\n            if (visited[i] == 0)\r\n            {\r\n                res++;\r\n                bfs(isConnected, visited, i);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1529244199","body":"### code\r\n```\r\nclass UF\r\n{\r\npublic:\r\n    vector<int> parent;\r\n    vector<int> weight;\r\n    int count;\r\n\r\n    UF(int N)\r\n    {\r\n        for (int i = 0; i < N; i++)\r\n        {\r\n            parent.push_back(i);\r\n            weight.push_back(1);\r\n        }\r\n        count = N;\r\n    }\r\n\r\n    int find(int i)\r\n    {\r\n        if (parent[i] == i)\r\n            return i;\r\n        return parent[i] = find(parent[i]); \r\n    }\r\n\r\n    void Union(int i, int j)\r\n    {\r\n        int parentI = find(i);\r\n        int parentJ = find(j);\r\n        if (parentI != parentJ)\r\n        {\r\n            if (weight[parentI] <= weight[parentJ])\r\n            {\r\n                parent[parentI] = parentJ;\r\n                weight[parentJ] += weight[parentI];\r\n                weight[parentI] = 0;\r\n            }\r\n            else\r\n            {\r\n                parent[parentJ] = parentI;\r\n                weight[parentI] += weight[parentJ];\r\n                weight[parentJ] = 0;\r\n            }\r\n            count--;\r\n        }\r\n    }\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {\r\n        int n = graph.size();\r\n        UF uf(n);\r\n        for (int i = 0; i < graph.size(); i++)\r\n        {\r\n            for (int j = i + 1; j < graph[0].size(); j++)\r\n            {\r\n                if (graph[i][j] == 1)\r\n                    uf.Union(i, j);\r\n            }\r\n        }\r\n\r\n        vector<int> record(n, 0);\r\n        for (int i = 0; i < initial.size(); i++)\r\n        {\r\n            record[uf.find(initial[i])]++;\r\n        }\r\n\r\n        sort(initial.begin(), initial.end());\r\n        int maxnum = -1;\r\n        int res = -1;\r\n        for (int i = 0; i < initial.size(); i++)\r\n        {\r\n            if (record[uf.find(initial[i])] == 1)\r\n            {\r\n                if (uf.weight[uf.find(initial[i])] > maxnum)\r\n                {\r\n                    maxnum = uf.weight[uf.find(initial[i])];\r\n                    res = initial[i];\r\n                }\r\n                else if (uf.weight[uf.find(initial[i])] > maxnum && initial[i] < res)\r\n                {\r\n                    res = initial[i];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (res == -1)\r\n            res = initial[0];\r\n        return res;\r\n    \r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1530747082","body":"### code\r\n```\r\nclass UF\r\n{\r\npublic:\r\n    int count;\r\n    vector<int> parent;\r\n    vector<int> weight;\r\n    UF(int N)\r\n    {\r\n        count = N;\r\n        for (int i = 0; i < N; i++)\r\n        {\r\n            parent.push_back(i);\r\n            weight.push_back(1);\r\n        }\r\n    }\r\n\r\n    int find(int index)\r\n    {\r\n        if (parent[index] == index)\r\n            return index;\r\n        return parent[index] = find(parent[index]);\r\n    }\r\n\r\n    void Union(int index1, int index2)\r\n    {\r\n        int parent1 = find(index1);\r\n        int parent2 = find(index2);\r\n\r\n        if (parent1 == parent2)\r\n            return;\r\n        else\r\n        {\r\n            if (weight[parent1] <= weight[parent2])\r\n            {\r\n                parent[parent1] = parent2;\r\n                weight[parent2] += weight[parent1];\r\n                weight[parent1] = 0;\r\n                count--;\r\n            }\r\n            else\r\n            {\r\n                parent[parent2] = parent1;\r\n                weight[parent1] += weight[parent2];\r\n                weight[parent2] = 0;\r\n                count--;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    int makeConnected(int n, vector<vector<int>>& connections) {\r\n        UF uf(n);\r\n        for (int i = 0; i < connections.size(); i++)\r\n        {\r\n            int tempx = connections[i][0];\r\n            int tempy = connections[i][1];\r\n            uf.Union(tempx, tempy);\r\n        }\r\n        \r\n        if (connections.size() < n - 1)\r\n            return -1;\r\n        return uf.count - 1;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1532372264","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    TreeNode* pruneTree(TreeNode* root) {\r\n        if (!root)\r\n            return root;\r\n        root->left = pruneTree(root->left);\r\n        root->right = pruneTree(root->right);\r\n        if (root->val == 0 && root->left == nullptr && root->right == nullptr)\r\n            return nullptr;\r\n        return root;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1533949353","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<vector<int>> res;\r\n    vector<int> path;\r\n\r\n    void backtrack(vector<int>& candidates, int target, int cur, int startindex)\r\n    {\r\n        if (cur >= target)\r\n        {\r\n            if (cur == target)\r\n                res.push_back(path);\r\n            else\r\n                return;\r\n        }\r\n        for (int i = startindex; i < candidates.size(); i++)\r\n        {\r\n            path.push_back(candidates[i]);\r\n            backtrack(candidates, target, cur + candidates[i], i);\r\n            path.pop_back();\r\n        }\r\n    }\r\n\r\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\r\n        backtrack(candidates, target, 0, 0);\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1535573319","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<vector<int>> res;\r\n    vector<int> path;\r\n\r\n    void backtrack(vector<int>& candidates, int startindex, int cursum, int target, vector<int>& used)\r\n    {\r\n        if (startindex >= candidates.size() ||cursum >= target)\r\n        {\r\n            if (cursum == target)\r\n                res.push_back(path);\r\n            return;\r\n        }\r\n        for (int i = startindex; i < candidates.size(); i++)\r\n        {\r\n            if (i > 0 && used[i - 1] == 0 && candidates[i] == candidates[i - 1])\r\n                continue;\r\n            used[i] = 1;\r\n            path.push_back(candidates[i]);\r\n            backtrack(candidates,i + 1, cursum + candidates[i], target, used);\r\n            path.pop_back();\r\n            used[i] = 0;\r\n        }\r\n    }\r\n\r\n\r\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\r\n        sort(candidates.begin(), candidates.end());\r\n        vector<int> used(candidates.size(), 0);\r\n        backtrack(candidates, 0, 0, target, used);\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1536951307","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<vector<int>> res;\r\n    vector<int> path;\r\n\r\n    void backtrack(vector<int>& nums, vector<int>& used)\r\n    {\r\n        if (path.size() == nums.size())\r\n        {\r\n            res.push_back(path);\r\n            return;\r\n        }\r\n        for (int i = 0; i < nums.size(); i++)\r\n        {\r\n            if (i > 0 && used[i - 1] == 0 && nums[i] == nums[i - 1])\r\n                continue;\r\n            if (used[i] == 1)\r\n                continue;\r\n            used[i] = 1;\r\n            path.push_back(nums[i]);\r\n            backtrack(nums, used);\r\n            path.pop_back();\r\n            used[i] = 0;\r\n        }\r\n    }\r\n\r\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\r\n        vector<int> used(nums.size(), 0);\r\n        sort(nums.begin(), nums.end());\r\n        backtrack(nums, used);\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null],"ruikiwi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huiminren":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saitochen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wtdcai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"albert556":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wuxiaoshawn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zrtch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuzhu096":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whoam-challenge":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weisday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"syh-coder":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436022622","body":"func maxChunksToSorted(arr []int) (ans int) {\r\n    cnt := map[int]int{}\r\n    b := append([]int{}, arr...)\r\n    sort.Ints(b)\r\n    for i, x := range arr {\r\n        cnt[x]++\r\n        if cnt[x] == 0 {\r\n            delete(cnt, x)\r\n        }\r\n        y := b[i]\r\n        cnt[y]--\r\n        if cnt[y] == 0 {\r\n            delete(cnt, y)\r\n        }\r\n        if len(cnt) == 0 {\r\n            ans++\r\n        }\r\n    }\r\n    return\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaaller":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kyrie96521":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cavecrypto":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cxgbro":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erjian96":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-polarbear":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alexno1no2":[null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431598470","body":"```\n暴力破解\nclass Solution:\n     def shortestToChar(self, s: str, c: str) -> List[int]:\n         c_idx = [ i for i in range(len(s)) if s[i] == c ]\n         return [ min(abs( i - j )  for j in c_idx) for i in range(len(s)) ]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433313429","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yetfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhiyuanpeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bwspsu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"arinzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mdge":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng666":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yin02":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elsa-zhang":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429069573","body":"```bash\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        sum = 0\n        for i in range(n):\n            sum=10*sum+num[i]\n        sum = sum+k\n\n        ans = []\n        while sum:\n            sum, remian = sum//10, sum%10\n            ans.append(remian)\n        \n        return ans[::-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430692126","body":"```bash\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pos = []\n        for i, w in enumerate(s):\n            if w==c:\n                pos.append(int(i))\n        \n        ans = []\n        for i, w in enumerate(s):\n            dis = [abs(p-i) for p in pos]\n            ans.append(min(dis))\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432520891","body":"```bash\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxsize = maxSize\n        self.list = []\n\n    def push(self, x: int) -> None:\n        if len(self.list) < self.maxsize:\n            self.list.append(x)\n\n    def pop(self) -> int:\n        if len(self.list) == 0:\n            return -1\n        return self.list.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        length = min(k, len(self.list))\n        for i in range(length):\n            self.list[i] = self.list[i]+val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434068281","body":"```bash\nclass Solution:\n    def decodeString(self, str: str) -> str:\n        stack, num, res = [], 0, ''\n        for s in str:\n            if '0'<=s<='9':\n                num = int(num)*10 + int(s)\n            elif s == '[':\n                stack.append([num, res])\n                num, res = 0, ''\n            elif s == ']':\n                last_num, last_res = stack.pop()\n                res = last_res + last_num*res\n            else:\n                res += s\n        \n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435500329","body":"```bash\nclass MyQueue:\n\n    def __init__(self):\n        self.quene = []\n\n    def push(self, x: int) -> None:\n        self.quene.append(x)\n\n    def pop(self) -> int:\n        return self.quene.pop(0)\n\n    def peek(self) -> int:\n        return self.quene[0]\n\n    def empty(self) -> bool:\n        return False if self.quene else True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435981637","body":"```bash\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        n = len(arr)\n        temp = []\n        ans = []\n        for i in range(n):\n            temp.append(arr[i])\n            if i<n-1 and max(temp)<=min(arr[i+1:]):\n                ans.append(temp)\n                temp = []\n            elif i==n-1:\n                ans.append(temp)\n        return len(ans) if ans else 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436283928","body":"```bash\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n\n        if not head:\n            return \n            \n        cur = head\n        length = 0\n        while cur:\n            cur = cur.next\n            length+=1\n        rotate_length = k%length\n        l = length - rotate_length\n\n        if l==length:\n            return head\n\n        node1 = head\n        temp1 = node1\n        while l-1:\n            node1 = node1.next\n            l-=1\n        node2 = node1.next\n        node1.next = None\n\n        temp2 = node2\n        while node2.next:\n            node2=node2.next\n        node2.next = temp1\n\n        return temp2\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437833179","body":"```bash\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return head\n        dummyhead = ListNode()\n        dummyhead.next = head\n        temp = dummyhead\n\n        while temp.next and temp.next.next:\n            node1 = temp.next\n            node2 = temp.next.next\n\n            temp.next = node2\n            node1.next = node2.next\n            node2.next = node1\n\n            temp = node1\n        \n        return dummyhead.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439368408","body":"```bash\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return head\n\n        def getMedian(l:ListNode, r:ListNode)-> ListNode:\n            fast = slow = l \n            while fast!=r and fast.next!=r:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n\n        def buildTree(l:ListNode, r:ListNode)-> TreeNode:\n            if l == r:\n                return None\n            mid = getMedian(l, r)\n            root = TreeNode(mid.val)\n            root.left = buildTree(l, mid)\n            root.right = buildTree(mid.next, r)\n            return root\n        \n        return buildTree(head, None)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441162055","body":"```bash\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        node1,node2 = headA, headB\n        while node1!=node2:\n            if node1:\n                node1 = node1.next\n            else:\n                node1 = headB\n            \n            if node2:\n                node2 = node2.next\n            else:\n                node2 = headA\n\n        return node2\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442762738","body":"```bash\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        flag = False\n        node1, node2 = head, head\n        while node2 and node2.next:\n            node2 = node2.next.next\n            node1 = node1.next\n            if node1 == node2:\n                flag = True\n                break\n        \n        if not flag:\n            return None\n        \n        node2 = head\n        while node2!=node1:\n            node2 = node2.next\n            node1 = node1.next\n        return node2\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445130610","body":"```bash\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.dict = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.dict:\n            return -1\n        self.dict.move_to_end(key)\n        return self.dict[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.dict:\n            self.dict.move_to_end(key)\n        self.dict[key] = value\n        \n        if len(self.dict) > self.capacity:\n            self.dict.popitem(last=False)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445344252","body":"```bash\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right))+1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445637064","body":"```bash\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        \n        if p.val == q.val:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) \n        else:\n            return False\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448025973","body":"```bash\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(root, cur):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return cur*10+root.val\n            return dfs(root.left, cur*10+root.val) + dfs(root.right, cur*10+root.val)\n        \n        return dfs(root, 0)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1448561963","body":"```bash\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return None\n        \n        sequene = []\n        sequene.append(root)\n        \n        while sequene:\n            lenghth = len(sequene)\n            num = sequene[0].val\n            \n            for i in range(lenghth):\n                node = sequene.pop(0)\n                left, right = node.left, node.right\n                \n                if left:\n                    sequene.append(left)\n                if right:\n                    sequene.append(right)\n        return num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451259075","body":"```bash\n# Definition for a binary tree node.\n\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        quene = []\n        quene.append(root)\n        \n        ans = ''\n        while quene:\n            length = len(quene)\n            for _ in range(length):\n                node = quene.pop(0)\n                if node:\n                    ans += str(node.val)+','\n                    left, right = node.left, node.right\n                    quene.append(left)\n                    quene.append(right)\n                else:\n                    ans += '#,'\n        return ans[:-1]        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        nodes = data.split(',')\n        if nodes==['#']: \n            return []\n        root = TreeNode(nodes[0])\n        quene = [root]\n        \n        i = 0\n        while i<len(nodes)-1:\n            node = quene.pop(0)\n            left, right = nodes[i+1], nodes[i+2]\n            i += 2\n            if left!='#':\n                l = TreeNode(left)\n                node.left = l\n                quene.append(l)\n            if right!='#':\n                r = TreeNode(right)\n                node.right = r\n                quene.append(r)\n        return root\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1452879133","body":"```bash\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def verticalTraversal(self, root):\n        seen = collections.defaultdict(lambda:collections.defaultdict(list))\n\n        def dfs(root, x, y):\n            if not root:\n                return \n            seen[y][x].append(root.val)\n            dfs(root.left, x+1, y-1)\n            dfs(root.right, x+1, y+1)\n\n        dfs(root,0,0)\n\n        ans = []\n        for y in sorted(seen):\n            level = []\n            for x in sorted(seen[y]):\n                level += sorted(v for v in seen[y][x])\n            ans.append(level)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1455010640","body":"```bash\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        n = len(nums)\n        record = dict()\n        for i in range(n):\n            record[nums[i]]=i\n        for j in range(n):\n            if target-nums[j] in record and record[target - nums[j]]!=j:\n                return [record[target - nums[j]], j]\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455008802","body":"```bash\nfrom collections import Counter\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        counter = dict(Counter(nums))\n        counter = sorted(counter.items(), key=lambda x:-x[1])\n        ans = []\n        for key, val in counter:\n            if k>0:\n                ans.append(key)\n                k-=1\n            else:\n                break\n        return ans\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455723023","body":"```bash\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        n = len(points)\n        for i in range(n):\n            dict_i = collections.defaultdict(int)\n            for j in range(n):\n                if j == i:\n                    continue\n                dist = abs(points[i][0] - points[j][0]) ** 2 + abs(points[i][1] - points[j][1]) ** 2\n                dict_i[dist] += 1\n            for k,v in dict_i.items():\n                ans+=v*(v-1)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457624949","body":"```bash\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        max_length = 1\n        if not s:\n            return 0\n        n = len(s)\n        stack = []\n        for i in range(n):\n            if s[i] not in stack:\n                stack.append(s[i])\n                max_length = max(max_length, len(stack))\n            else:\n                stack.append(s[i])\n                while stack[0]!=s[i]:\n                    stack.pop(0)\n                stack.pop(0)\n        return max_length\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459269172","body":"```bash\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        n = len(s)\n        m = len(words[0]) * len(words)\n        k = len(words[0])\n\n        dict_word = collections.defaultdict(int)\n        for w in words:\n            dict_word[hash(w)]+=1\n        \n        ans = []\n        for i in range(n-m+1):\n            window = s[i:i+m]\n            split_word = []\n            for j in range(len(words)):\n                split_word.append(window[j*k:j*k+k])\n            dict_w = collections.defaultdict(int)\n            for w in split_word:\n                if w in words:\n                    dict_w[hash(w)]+=1\n            flag = True\n            for key, value in dict_word.items():\n                if key in dict_w and dict_word[key]==dict_w[key]:\n                    continue\n                else:\n                    flag=False\n            if flag:\n                ans.append(i)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461483603","body":"```bash\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        sum_num = sum(nums)\n        if sum_num<p:\n            return -1\n\n        target = sum_num % p\n        if target == 0:\n            return 0\n\n        n = len(nums)\n        dp = [0]*n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = dp[i-1]+nums[i]\n        \n        dic = {0: -1}\n        ans = n\n        for j in range(n):\n            if (dp[j]-target)%p in dic:\n                ans = min(ans, j-dic[(dp[j]-target)%p])\n            cur = dp[j]%p\n            dic[cur] = j\n        return ans if ans < len(nums) else -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463167617","body":"```bash\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        head1 = head\n        head2 = head\n        while head1 and head1.next:\n            head1 = head1.next.next\n            head2 = head2.next\n        return head2\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464939303","body":"```bash\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        n = len(nums)\n        for i in range(n-1,0,-1): \n            if nums[i] == nums[i-1]: \n                nums.pop(i)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465403223","body":"```bash\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n\n        l = 0\n        r = len(nums) - 1\n\n        while(l<=r):\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465407794","body":"```bash\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        if not nums or not k:\n            return None\n\n        # 堆\n        n = len(nums)\n        q = [(-nums[i], i) for i in range(k)]\n        heapq.heapify(q)\n        \n        ans = [-q[0][0]]\n        for i in range(k, n):\n            heapq.heappush(q, (-nums[i], i))\n            while q[0][1] <= i-k:\n                heapq.heappop(q)\n            ans.append(-q[0][0])    \n        \n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1471304129","body":"```bash\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        count = [0] * (n + 1)\n        for i, j in trust:\n            count[i] -= 1\n            count[j] += 1\n        for i in range(1, n + 1):\n            if count[i] == n - 1:\n                return i\n        return -1\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1471317493","body":"```bash\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        edges_dict = collections.defaultdict(list)\n        for (a, b) in dislikes:\n            edges_dict[a-1].append(b-1)\n            edges_dict[b-1].append(a-1)\n\n        def dfs(i, edges_dict, colors, n, color=None):\n            colors[i]=color\n            if edges_dict[i]:\n                for c in edges_dict[i]:\n                    if colors[c]==color:\n                        return False\n                    if colors[c]==0:\n                        if not dfs(c, edges_dict, colors, n, color*(-1)):\n                            return False\n            return True\n        \n        colors = [0]*n\n        for i in range(n):\n            if colors[i]!=0:\n                continue\n            if not dfs(i, edges_dict, colors, n, color=1):\n                return False\n        \n        return True\n```","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475093746","body":"```bash\nclass Solution:\n    def numberOfRounds(self, startTime: str, finishTime: str) -> int:\n        start_hour, start_min = map(int, startTime.split(':'))\n        finish_hour, finish_min = map(int, finishTime.split(':'))\n        \n        start_time, finish_time = 0,0\n        if start_hour*60+start_min > finish_hour*60+finish_min:\n            finish_time += 24*60\n        \n        if 0 < start_min <= 15:\n            start_min = 15\n        elif 15 < start_min <= 30:\n            start_min = 30\n        elif 30 < start_min <= 45:\n            start_min = 45\n        elif 45 < start_min <= 60:\n            start_min = 0\n            start_hour += 1\n            \n        if 0 <= finish_min < 15:\n            finish_min = 0\n        elif 15 <= finish_min < 30:\n            finish_min = 15\n        elif 30 <= finish_min < 45:\n            finish_min = 30\n        elif 45 <= finish_min < 60:\n            finish_min = 45\n        \n        start_time += start_hour*60 + start_min\n        finish_time += finish_hour*60 + finish_min\n        \n        # if start_hour*60+start_min > finish_hour*60+finish_min:\n        #     finish_time += 24*60\n        \n        game_time = (finish_time - start_time)//15\n        \n        return max(0, game_time)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476386806","body":"```bash\nclass Solution:\n    def minCharacters(self, A: str, B: str) -> int:\n        counter_A = [0] * 26\n        counter_B = [0] * 26\n        for a in A:\n            counter_A[ord(a) - ord('a')] += 1\n        for b in B:\n            counter_B[ord(b) - ord('a')] += 1\n        \n        ans = len(A)+len(B)\n        \n        ## AB为一样的同一个字母组成的字符串\n        for i in range(26):\n            ans = min(ans, len(A)+len(B)-counter_A[i]-counter_B[i])\n        \n        ## A 的最大字母保证严格小于 B 的最大字母\n        # 枚举 A 的最大字母\n        for i in range(1, 26):\n            t = 0\n            # A 中大于等于 i 的所有字符都需要进行一次操作\n            for j in range(i, 26):\n                t += counter_A[j]\n            # B 中小于 i 的所有字符都需要进行一次操作\n            for j in range(i):\n                t += counter_B[j]\n            ans = min(ans, t)\n\n        ## B 的最大字母保证严格小于 A 的最大字母\n        for i in range(1, 26):\n            t = 0\n            for j in range(i, 26):\n                t += counter_B[j]\n            for j in range(i):\n                t += counter_A[j]\n            ans = min(ans, t)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477533628","body":"```bash\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n\n        def merge(nums, l, mid, r):\n            i, j, temp = l, mid+1, []\n            while i<=mid and j<=r:\n                if nums[i]<nums[j]:\n                    temp.append(nums[i])\n                    i+=1\n                else:\n                    temp.append(nums[j])\n                    j+=1\n            while i<=mid:\n                temp.append(nums[i])\n                i+=1\n            while j<=r:\n                temp.append(nums[j])\n                j+=1\n            for i in range(len(temp)):\n                nums[l+i] = temp[i]\n\n        def sort(nums, l, r):\n            if l>=r:\n                return \n            mid = (l+r)//2\n            sort(nums, l, mid)\n            sort(nums, mid+1, r)\n            merge(nums, l, mid, r)\n        \n        sort(nums, 0, len(nums)-1)\n        return nums\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asur4s":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlesugarman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhihaowan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"apockira":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guowei0223":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuqianyang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sj941127":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yongxi-zhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darwintk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"h-steven":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mischaqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wurongronga":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miduoliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyshenzhengkang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y4h2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yoco323":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forschers":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shanshuiqiankun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"annabellhyx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hwfrankfung":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435826710","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        rec = [None] * (len(arr)+1)\n        rec[0] = 0\n        cur, p = arr[0], 0\n        for i in arr:\n            while i < rec[p]:\n                p -= 1\n            p += 1\n            if i > cur:\n                cur = i;\n            rec[p] = cur\n        return p\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438638398","body":"```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445312866","body":"```python\nclass Solution:\n    def maxDepth(self, root):\n        if root is None: \n            return 0 \n        else: \n            left_height = self.maxDepth(root.left) \n            right_height = self.maxDepth(root.right) \n            return max(left_height, right_height) + 1 \n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1452047101","body":"```python\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        res = \"\"\n\n        def dfs_NLR(x: TreeNode) -> None:\n            nonlocal res\n            if x == None:\n                res += 'None,'\n                return \n            else:\n                res += str(x.val) + ','\n                dfs_NLR(x.left)\n                dfs_NLR(x.right)\n\n        dfs_NLR(root)\n        return res\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if data == \"\":\n            return None\n        s = data.split(',')\n        idx = 0\n\n        def dfs_LRN() -> TreeNode:\n            nonlocal idx\n            if s[idx] == \"None\":\n                idx += 1\n                return None\n            else:\n                root = TreeNode(int(s[idx]))\n                idx += 1\n                root.left = dfs_LRN()\n                root.right = dfs_LRN()\n                return root\n\n        return dfs_LRN()\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frederickfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huibinny":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggmybro":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"myleetcodejourney":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"want2333":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"staringwhere":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng8":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ryanbaiyansong":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428966385","body":"```\nclass Solution:\n    def addToArrayForm(self, nums: List[int], k: int) -> List[int]:\n        nums.reverse()\n        i = t = 0\n        n = len(nums)\n        res = []\n        while i < n or t or k:\n            if k:\n                t += k % 10\n                k //= 10\n            \n            if i < n:\n                t += nums[i]\n                i += 1\n            \n            digit = t % 10\n            res.append(digit)\n            t //= 10\n        \n        res.reverse()\n        return res\n```\n高精度板子题","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430158405","body":"# 双指针 + 前后缀分解\n···\nclass Solution:\n    def shortestToChar(self, s: str, t: str) -> List[int]:\n        n = len(s)\n        ans = [0] * n\n        idx = -n \n        for i, c in enumerate(s):\n            if c == t:\n                idx = i \n            ans[i] = i - idx \n        \n        idx = 2 * n\n        for i in range(n - 1, -1, -1):\n            c = s[i]\n            if c == t:\n                idx = i \n            ans[i] = min(ans[i], idx - i)\n        \n        return ans\n        \n        l = 0 if s[0] == t else n \n        r = s.find(t, start=1)\n        for i in range(n):\n            ans[i] = min(i - l, r - i)\n            if i == r:\n                l = r \n                r = s.find(t, start = l + 1)\n        \n        return ans\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1431886534","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = []\n        self.maxSize = maxSize\n\n\n    def push(self, x: int) -> None:\n        if len(self.stk) < self.maxSize:\n            self.stk.append(x)\n\n\n    def pop(self) -> int:\n        if not self.stk: return -1\n        return self.stk.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i < len(self.stk):\n                self.stk[i] += val\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n# maxSize\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436006067","body":"···\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        # split arr into number of chunks\n        n = len(arr)\n        #动态比较两个集合是否相同 两个哈希表\n        tmp = sorted(arr)\n        count = Counter()\n        res = 0\n        for x, y in zip(arr, sorted(arr)):\n            count[x] += 1\n            count[y] -= 1\n            if all(x == 0 for x in count.values()):\n                res += 1\n        \n        return res\n            \n\n\n\n\n        #单调栈 O(N) 维护所有集合的最大值\n        # 存储每一个区间的最大值\n        stk = []\n        for x in arr:\n            # 新的最大值\n            t = x\n            while stk and stk[-1] > x:\n                t = max(t, stk[-1])\n                stk.pop()\n            stk.append(t)\n        return len(stk)\n···","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437367599","body":"···\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head \n        dummy = ListNode(-1)\n        dummy.next = head \n        pre = dummy \n        cur = head \n        \n        while cur and cur.next:\n            sec = cur.next\n            tmp = cur.next.next\n            cur.next.next = cur \n            cur.next = tmp \n            pre.next = sec \n            pre = cur \n            cur = cur.next \n        \n        return dummy.next\n···\nO(N) O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439216912","body":"···\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return \n        \n        len = 0\n        p = head \n        while p:\n            p = p.next \n            len += 1\n        def build(L: int, R: int) -> Optional[TreeNode]:\n            if L > R:\n                return \n            \n            mid = (L + R + 1) // 2\n            root = TreeNode()\n            root.left = build(L, mid - 1)\n            nonlocal head\n            root.val = head.val\n            head = head.next\n            root.right = build(mid + 1, R)\n            return root\n\n        \n        return build(0, len - 1\n\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1440656556","body":"···\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        a, b = headA, headB\n        while a != b:\n            if a:\n                a = a.next \n            else:\n                a = headB\n            \n            if b:\n                b = b.next\n            else:\n                b = headA\n        \n        return a\n···","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445178724","body":"···\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        def dfs(node: Optional[TreeNode]):\n            if not node:\n                return 0\n            \n            left = dfs(node.left)\n            right = dfs(node.right)\n            \n            return max(left, right) + 1\n        \n        return dfs(root)\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445642650","body":"```\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p is None and q is None:\n            return True\n        if p is not None and q is None or q is not None and p is None:\n            return False \n        if p.val != q.val:\n            return False \n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1446919990","body":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        s = 0\n        ans = 0\n        def dfs(root, cur):\n            nonlocal ans\n            if not root:\n                return \n            if not root.left and not root.right:\n                ans += cur * 10 + root.val\n                return \n            \n            dfs(root.left, cur * 10 + root.val)\n            dfs(root.right, cur * 10 + root.val)\n    \n        dfs(root, 0)\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449324271","body":"```\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n            \n        # last row, left most\n        q = deque([root])\n        ans = 0\n        while q:\n            sz = len(q)\n            level = []\n            for _ in range(sz):\n                node = q.popleft()\n                level.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                \n                if node.right:\n                    q.append(node.right)\n            ans = level[0]\n            level = []\n        \n        return ans      \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1450956012","body":"···\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return \"\"\n        res = []\n        q = deque([root])\n        while q:\n            curr = q.popleft()\n            if curr == None:\n                res.append(\"#\")\n                continue\n            else:\n                res.append(curr.val)\n            q.append(curr.left)\n            q.append(curr.right)\n        \n        return \",\".join(map(str, res))\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data:\n            return None\n        data = data.split(\",\")\n        rootVal = int(data[0])\n        root = TreeNode(rootVal)\n        index = 1\n        q = deque([root])\n        while q:\n            curr = q.popleft()\n            leftVal = data[index]\n            if leftVal != \"#\":\n                curr.left = TreeNode(int(leftVal))\n                q.append(curr.left)\n            else:\n                curr.left = None\n            index += 1\n            rightVal = data[index]\n            if rightVal != \"#\":\n                curr.right = TreeNode(int(rightVal))\n                q.append(curr.right)\n            else:\n                curr.right = None\n            index += 1\n        \n        return root\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1452601061","body":"```\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root: return []\n\n        def dfs(node: Optional[TreeNode], r: int, c: int):\n            if not node:\n                return \n            col2val[c].append((r, node.val))\n            dfs(node.left, r + 1, c - 1)\n            dfs(node.right, r + 1, c + 1)\n        \n        col2val = defaultdict(list)\n        dfs(root, 0, 0)\n\n        ans = []\n\n        for col, vals in sorted(col2val.items()):\n            vals.sort()\n            ans.append([v for _, v in vals])\n        \n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1453868686","body":"```\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]: \n        d = {}\n        for i, x in enumerate(nums):\n            y = target - x \n            if y in d:\n                return [d[y], i]\n            \n            d[x] = i \n        \n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1454823665","body":"···\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        minHeap = []\n        cnt = Counter(nums)\n\n        for i, c in cnt.items():\n            heappush(minHeap, (c, i))\n\n            if len(minHeap) > k:\n                heappop(minHeap)\n        \n        return [x for _, x in minHeap]\n\n···","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459096322","body":"```\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        n = len(s)\n        word_length = len(words[0])\n        word_num = len(words)\n        substring_size = word_length * word_num\n        all_words = Counter(words)\n        def check(ss):\n            cur_words = defaultdict(int)\n            for i in range(0, substring_size, word_length):\n                cur = ss[i: i + word_length]\n                if cur not in all_words:\n                    return False\n                cur_words[cur] += 1\n            return cur_words == all_words\n        res = []\n        for i in range(n - substring_size + 1):\n            cur_string = s[i: i + substring_size]\n            if check(cur_string):\n                res.append(i)\n        \n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1460520885","body":"```\nclass Solution:\n    def minSubarray(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        # (tot - subarray) % p == 0\n        # (tot % p) == subarray % p\n        # sum_ = sum(nums)\n        # mod  = sum_ % p\n        # ans = n \n        # d = defaultdict(int)\n        # d[0] = -1\n        # S = 0\n        # for i, x in enumerate(nums):\n        #     S += x\n        #     cur = S % p\n        #     target = (cur - mod + p) % p\n        #     if target in d:\n        #         print(i, d[target])\n        #         ans = min(ans, i - d[target])\n        #     d[cur] = i\n        \n        # return ans if ans != n else -1\n\n\n        total = sum(nums)\n        mod = total % k\n        if total % k == 0:return 0\n        ans = len(nums)\n        total = 0\n        dic = {0: -1}\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % k\n            target = (cur - mod + k) % k\n            if target in dic:\n                ans = min(ans, j - dic[target])\n            dic[cur] = j\n\n        if ans == len(nums):\n            return -1\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1462366283","body":"···\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow = fast = head \n        while fast and fast.next:\n            slow = slow.next \n            fast = fast.next.next\n        \n        return slow\n···","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dou-yu-xuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyxupup":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cs12300":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chiehw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aesir-idun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaldsk12":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hxj2001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"for123s":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428245121","body":"```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res = {num.rbegin(), num.rend()};\n        int len = 0;\n        while (k!=0) {\n            int temp = k % 10;\n            k /= 10;\n            if (len < res.size()) {\n                if (temp + res[len] >= 10) {\n                    k += 1;\n                }\n                res[len] = (res[len] + temp) % 10;\n            }\n            else {\n                res.emplace_back(temp);\n            }\n            ++len;\n        }\n        return {res.rbegin(), res.rend()};\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430050786","body":"```\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> res(s.size(), -1);\n        int idx = -1;\n        for (int i=0;i<s.size();i++) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            if (idx != -1) {\n                res[i] = i - idx;\n            }\n        }\n        idx = -1;\n        for (int i=s.size()-1;i>=0;i--) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            if (res[i] == -1) {\n                res[i] = idx - i;\n            }\n            else if (idx != -1) {\n                res[i] = min(res[i], idx - i);\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1431673255","body":"```\nclass CustomStack {\npublic:\n    vector<int> nums;\n    int top = -1;\n    CustomStack(int maxSize) {\n        nums.resize(maxSize);\n    }\n    \n    void push(int x) {\n        if (top == nums.size()-1) {\n            return;\n        }\n        nums[++top] = x;\n    }\n    \n    int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        return nums[top--];\n    }\n    \n    void increment(int k, int val) {\n        for (int i=0;i<=top&&i<k;i++) {\n            nums[i] += val;\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434813115","body":"```\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<char> st_c;\n        stack<int> st_num;\n        for(int i=0;i<s.size();++i)\n        {\n            if(s[i]>='0'&&s[i]<='9')\n            {\n                int temp = s[i]-'0';\n                while(s[i+1]>='0'&&s[i+1]<='9')\n                {\n                    ++i;\n                    temp = temp * 10 + s[i]-'0';\n                }\n                st_num.push(temp);\n            }\n            else if(s[i]==']')\n            {\n                string temp = \"\";\n                while(st_c.top()!='[')\n                {\n                    temp = st_c.top() + temp;\n                    st_c.pop(); \n                }\n                st_c.pop();\n                for(int j=0;j<st_num.top();++j)\n                {\n                    for(int k=0;k<temp.size();++k)\n                    {\n                        st_c.push(temp[k]);\n                    }\n                }\n                st_num.pop();\n            }\n            else\n            {\n                st_c.push(s[i]);\n            }\n        }\n        string res=\"\";\n        while(!st_c.empty())\n        {    \n            res = st_c.top() + res;\n            st_c.pop();\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435702529","body":"```\nclass MyQueue {\n    stack<int> in;\n    stack<int> out;\npublic:\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        in.push(x);\n    }\n    \n    int pop() {\n        int temp;\n        if(out.empty())\n        {\n            while(!in.empty())\n            {\n                temp = in.top();\n                in.pop();\n                out.push(temp);\n            }\n        }\n        temp = out.top();\n        out.pop();\n        return temp;\n    }\n    \n    int peek() {\n        int temp;\n        if(out.empty())\n        {\n            while(!in.empty())\n            {\n                temp = in.top();\n                in.pop();\n                out.push(temp);\n            }\n        }\n        temp = out.top();\n        return temp;\n    }\n    \n    bool empty() {\n        return in.empty()&&out.empty();\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436034279","body":"```\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head==NULL)\n            return NULL;\n        ListNode* temp = head;\n        int len = 1;\n        while(temp->next!=NULL)\n        {    \n            temp = temp->next;\n            ++len;\n        }\n        temp->next = head;\n        int step = len - k%len;\n        while(--step)\n            head = head->next;\n        temp = head->next;\n        head->next = NULL;\n        return temp;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438592570","body":"```\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* pre = new ListNode(0,head);\n        ListNode* first = pre;\n        ListNode* second = pre->next;\n        while(second&&second->next)\n        {\n            ListNode* temp = second->next->next; \n            first->next = second->next;\n            first->next->next = second;\n            second->next = temp;\n            first = second;\n            second = temp;\n        }\n        return pre->next;\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443894105","body":"```\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(!head)\n            return NULL;\n        ListNode *slow = head;\n        ListNode *fast = head;\n        while(fast->next&&fast->next->next)\n        {\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow==fast)\n                break;\n        }\n        if(!fast->next||!fast->next->next)\n            return NULL;\n        while(head!=slow)\n        {\n            head = head->next;\n            slow = slow->next;\n        }\n        return head;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445135750","body":"```\nstruct DLinkeNode{\n    int key, value;\n    DLinkeNode* prev;\n    DLinkeNode* next;\n    DLinkeNode(): key(0), value(0), prev(nullptr), next(nullptr){}\n    DLinkeNode(int key1, int value1): key(key1), value(value1), prev(nullptr), next(nullptr){}\n};\n\n\n\nclass LRUCache {\nprivate:\n    unordered_map<int,DLinkeNode*> mp;\n    DLinkeNode* head;\n    DLinkeNode* tail;\n    int max_capacity;\n    int size;\n\npublic:\n    void removeNode(DLinkeNode* node)\n    {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void addToHead(DLinkeNode* node)\n    {\n        node->next = head->next;\n        head->next = node;\n        node->prev = head;\n        node->next->prev = node;\n    }\n\n    void moveToHead(DLinkeNode* node)\n    {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    LRUCache(int capacity) {\n        mp.clear();\n        max_capacity = capacity;\n        size = 0;\n        head = new DLinkeNode();\n        tail = new DLinkeNode();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if(mp.count(key)==0)\n            return -1;\n        DLinkeNode* node = mp[key];\n        moveToHead(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        if(mp.count(key)==0)\n        {\n            DLinkeNode* node = new DLinkeNode(key,value);\n            mp[key] = node;\n            addToHead(node);\n            ++size;\n            if(size>max_capacity)\n            {\n                DLinkeNode* temp = tail->prev;\n                tail->prev = temp->prev;\n                temp->prev->next = tail;\n                mp.erase(temp->key);\n                delete temp;\n                --size;\n            }\n        }\n        else\n        {\n            DLinkeNode* node = mp[key];\n            node->value = value;\n            moveToHead(node);\n        }\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446497998","body":"```\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!q&&!p)\n            return true;\n        else if(!q&&p)\n            return false;\n        else if(q&&!p)\n            return false;\n\n        if(q->val==p->val)\n            return isSameTree(q->left,p->left)&&isSameTree(q->right,p->right);\n        else\n            return false;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448419192","body":"```\nclass Solution {\nprivate:\n    int sum = 0;\npublic:\n    void dfs(TreeNode* root, int temp)\n    {\n        temp = temp * 10 + root->val;\n        if((!root->left)&&(!root->right))\n        {\n            sum += temp;\n            return;\n        }\n        if(root->left)\n            dfs(root->left, temp);\n        if(root->right)\n            dfs(root->right, temp);\n    }\n    int sumNumbers(TreeNode* root) {\n        if(!root)\n            return 0;\n        dfs(root, 0);\n        return sum;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450381214","body":"```\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int res=root->val, flag = 1;\n        while(!q.empty())\n        {\n            flag = 0;\n            int len = q.size();\n            for(int i=0;i<len;i++)\n            {\n                if(q.front()->left)\n                {\n                    if(flag==0)\n                    {\n                       res = q.front()->left->val;\n                       flag = 1;\n                    }\n                    q.push(q.front()->left);\n                }\n                if(q.front()->right)\n                {\n                    if(flag==0)\n                    {\n                       res = q.front()->right->val;\n                       flag = 1;\n                    }\n                    q.push(q.front()->right);\n                }\n                q.pop();\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1452083441","body":"```\nclass Codec {\npublic:\n    string serialize(TreeNode* root) {\n        if (!root) return \"X\";\n        auto l = \"(\" + serialize(root->left) + \")\";\n        auto r = \"(\" + serialize(root->right) + \")\";\n        return  l + to_string(root->val) + r;\n    }\n\n    inline TreeNode* parseSubtree(const string &data, int &ptr) {\n        ++ptr;\n        auto subtree = parse(data, ptr);\n        ++ptr;\n        return subtree;\n    }\n\n    inline int parseInt(const string &data, int &ptr) {\n        int x = 0, sgn = 1;\n        if (!isdigit(data[ptr])) {\n            sgn = -1;\n            ++ptr;\n        }\n        while (isdigit(data[ptr])) {\n            x = x * 10 + data[ptr++] - '0';\n        }\n        return x * sgn;\n    }\n\n    TreeNode* parse(const string &data, int &ptr) {\n        if (data[ptr] == 'X') {\n            ++ptr;\n            return nullptr;\n        }\n        auto cur = new TreeNode(0);\n        cur->left = parseSubtree(data, ptr);\n        cur->val = parseInt(data, ptr);\n        cur->right = parseSubtree(data, ptr);\n        return cur;\n    }\n\n    TreeNode* deserialize(string data) {\n        int ptr = 0;\n        return parse(data, ptr);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453690969","body":"```\nclass Solution {\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<tuple<int, int, int>> nodes;\n\n        function<void(TreeNode*, int, int)> dfs = [&](TreeNode* node, int row, int col) {\n            if (!node) {\n                return;\n            }\n            nodes.emplace_back(col, row, node->val);\n            dfs(node->left, row + 1, col - 1);\n            dfs(node->right, row + 1, col + 1);\n        };\n\n        dfs(root, 0, 0);\n        sort(nodes.begin(), nodes.end());\n        vector<vector<int>> ans;\n        int lastcol = INT_MIN;\n        for (const auto& [col, row, value]: nodes) {\n            if (col != lastcol) {\n                lastcol = col;\n                ans.emplace_back();\n            }\n            ans.back().push_back(value);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454776539","body":"```\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int,int> mp;\n        for(int i=0;i<nums.size();i++)\n        {\n            if(mp.count(target-nums[i])==1)\n                return {mp[target-nums[i]],i};\n            mp[nums[i]] = i;\n        }\n        return {};\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455129655","body":"```\nclass Solution {\npublic:\n    class mycomparison {\n    public:\n        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n            return lhs.second > rhs.second;\n        }\n    };\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> map;\n        for (int i = 0; i < nums.size(); i++) {\n            map[nums[i]]++;\n        }\n        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;\n        for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++) {\n            pri_que.push(*it);\n            if (pri_que.size() > k) {\n                pri_que.pop();\n            }\n        }\n        vector<int> result(k);\n        for (int i = k - 1; i >= 0; i--) {\n            result[i] = pri_que.top().first;\n            pri_que.pop();\n        }\n        return result;\n\n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456394415","body":"```\r\nclass Solution {\r\npublic:\r\n    int dis(vector<int> i, vector<int> j)\r\n    {\r\n        int x = i[0] - j[0];\r\n        int y = i[1] - j[1];\r\n        return x*x+y*y;\r\n    }\r\n    int numberOfBoomerangs(vector<vector<int>>& points) {\r\n        int ret = 0;\r\n        vector<vector<int>> dis_(points.size(),vector<int>(points.size(),-1));\r\n        for(int i=0;i<points.size();++i)\r\n        {\r\n            unordered_map<int,int> mp;\r\n            for(int j=0;j<points.size();++j)\r\n            {\r\n                if(i!=j)\r\n                {\r\n                    if(dis_[i][j]==-1)\r\n                    {\r\n                        dis_[i][j] = dis(points[i],points[j]);\r\n                        dis_[j][i] = dis_[i][j];\r\n                    }\r\n                    if(mp.count(dis_[i][j])==1)\r\n                    {\r\n                        mp[dis_[i][j]]++;\r\n                        ret +=  2 * (mp[dis_[i][j]] - 1);\r\n                    }\r\n                    else\r\n                        mp[dis_[i][j]]=1;     \r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1458403372","body":"```\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if(s.size()==0)\n            return 0;\n        unordered_map<char,int> mp;\n        int l = 0, r = 1;\n        int ret = 1;\n        mp[s[0]] = 0;\n        while(r<s.size())\n        {\n            if(mp.count(s[r])==0||mp[s[r]]==-1)\n            {\n                mp[s[r]] = r;\n                ret = max(ret, r+1-l);\n            }\n            else\n            {\n                while(s[l]!=s[r])\n                    mp[s[l++]] = -1;\n                l++;\n                mp[s[r]] = r;\n            }\n            ++r;\n        }\n        return ret;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460380701","body":"```\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        unordered_map<string, int> allWordsMap;\n        for (auto& v : words) {\n            ++allWordsMap[v];\n        }\n        \n        int num = words.size();\n        int onelen = words[0].length();\n        vector<int> res;\n        if (s.length() < num * onelen) {\n            return res;\n        }\n        \n        for (int left = 0; left < s.length() - num * onelen + 1; ++left) {\n            unordered_map<string, int> nowWordsMap;\n            int right = left;\n            while (right < left + num * onelen) {\n                auto cur = s.substr(right, onelen);\n                if (allWordsMap.find(cur) == allWordsMap.end() \n                    || nowWordsMap[cur] == allWordsMap[cur]) {\n                    break;\n                }\n                \n                ++nowWordsMap[cur];\n                right += onelen;\n            }\n            \n            if (right == left + num * onelen) {\n                res.emplace_back(left);\n            }\n        }\n        \n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462304985","body":"```\nclass Solution {\npublic:\n    int minSubarray(vector<int>& nums, int p) {\n        int sum = 0;\n        for(int i=0;i<nums.size();i++)\n            sum = (sum + nums[i])%p;\n        int mod = sum;\n        if(mod==0)\n            return 0;\n        unordered_map<int,int> mp;\n        mp[0] = -1;\n        int min_val = nums.size();\n        sum = 0;\n        for(int i=0;i<nums.size();i++)\n        {\n            sum = (sum + nums[i])%p;\n            int temp2 = (sum-mod+p)%p;\n            if(mp.count(temp2)==1)\n                min_val = min(min_val,i-mp[temp2]);\n            mp[sum] = i;\n        }\n        if(min_val==nums.size())\n            return -1;\n        return min_val;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463989915","body":"```\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        if(!head->next)\n            return head;\n        ListNode* temp = head->next;\n        while(temp->next&&temp->next->next)\n        {\n            temp = temp->next->next;\n            head = head->next;\n        }\n        return head->next;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464939763","body":"```\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if(nums.size()==0)\n            return 0;\n        int pre = 1, next = 1;\n        while(next<nums.size())\n        {\n            if(nums[next]==nums[next-1])\n                ++next;\n            else\n                nums[pre++] = nums[next++];\n        }\n        return pre;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466360162","body":"```\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size(), top;\n        vector<int> left(n), right(n), res;\n        for(int i=0;i<n;++i)\n        {\n            if(i%k==0)\n            {    \n                left[i] = nums[i];\n                top = i+k-1>=n-1?n-1:i+k-1;\n                right[top] = nums[top];\n            }\n            else\n            {    \n                left[i] = max(left[i-1],nums[i]);\n                right[top-1] = max(nums[top-1],right[top]);\n                --top;\n            }\n        }\n        for(int i=0;i<n-k+1;++i)    \n            res.emplace_back(max(left[i + k - 1], right[i]));\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468375072","body":"```\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        vector<vector<int>> parents(n+1,vector<int>(2,0));\n        for(int i=0;i<trust.size();i++)\n        {\n            parents[trust[i][0]][0]++;\n            parents[trust[i][1]][1]++;\n        }\n        int m = n - 1;\n        for(int i=1;i<=n;i++)\n            if(parents[i][0]==0&&parents[i][1]==m)\n                return i;\n        return -1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1470276492","body":"```\nclass Solution {\npublic:\n    bool dfs(int curnode, int nowcolor, vector<int>& color, const vector<vector<int>>& g) {\n        color[curnode] = nowcolor;\n        for (auto& nextnode : g[curnode]) {\n            if (color[nextnode] && color[nextnode] == color[curnode]) {\n                return false;\n            }\n            if (!color[nextnode] && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<int> color(n + 1, 0);\n        vector<vector<int>> g(n + 1);\n        for (auto& p : dislikes) {\n            g[p[0]].push_back(p[1]);\n            g[p[1]].push_back(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1472223711","body":"```\nclass Solution {\npublic:\n    vector<int> topologicalSort(vector<vector<int>> &Adj, vector<int> &Indegree, int n){\n        vector<int> res;\n        queue<int> q;\n        for(int i = 0;i<n;i++){\n            if(Indegree[i]==0){\n                q.push(i);\n            }\n        }\n        while(!q.empty()){\n            int front = q.front();\n            q.pop();\n            res.push_back(front);\n            for(int successor: Adj[front]){\n                Indegree[successor]--;\n                if(Indegree[successor]==0){\n                    q.push(successor);\n                }\n            }\n        }\n        if(res.size()==n){return res;}\n        return vector<int>();\n    }\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        // 第 1 步：数据预处理，给没有归属于一个组的项目编上组号\n        for(int i=0;i<group.size();i++){\n            if(group[i] == -1){\n                group[i] = m;\n                m++;\n            }\n        }\n        // 第 2 步：实例化组和项目的邻接表\n        vector<vector<int>> groupAdj(m, vector<int>());\n        vector<vector<int>> itemAdj(n, vector<int>());\n\n        // 第 3 步：建图和统计入度数组\n        vector<int> groupsIndegree(m, 0);\n        vector<int> itemIndegree(n, 0);\n\n        int len = group.size();\n        for(int i=0;i<len;i++){\n            int currentGroup = group[i];\n            for(int beforeItem: beforeItems[i]){\n                int beforeGroup = group[beforeItem];\n                if(beforeGroup!=currentGroup){\n                    groupAdj[beforeGroup].push_back(currentGroup);\n                    groupsIndegree[currentGroup]++;\n                }\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int item: beforeItems[i]){\n                itemAdj[item].push_back(i);\n                itemIndegree[i]++;\n            }\n        }\n        // 第 4 步：得到组和项目的拓扑排序结果\n        vector<int> groupList = topologicalSort(groupAdj, groupsIndegree, m);\n        if(groupList.size()==0){\n            return vector<int> ();\n        }\n        vector<int> itemList = topologicalSort(itemAdj, itemIndegree, n);\n        if(itemList.size()==0){\n            return vector<int> ();\n        }\n        // 第 5 步：根据项目的拓扑排序结果，项目到组的多对一关系，建立组到项目的一对多关系\n        // key：组，value：在同一组的项目列表\n        map<int, vector<int>> group2Items;\n        for(int item: itemList){\n            group2Items[group[item]].push_back(item);\n        }\n        // 第 6 步：把组的拓扑排序结果替换成为项目的拓扑排序结果\n        vector<int> res;\n        for(int groupId: groupList){\n            vector<int> items = group2Items[groupId];\n            for(int item: items){\n                res.push_back(item);\n            }\n        }\n        return res;\n    } \n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzhilin":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428529645","body":"### 思路\r\n类似计算加法的逻辑。从个位开始遍历num计算的时候，用k作为carry over的数字。最后如果还有剩余的carry数字，加到res中。\r\n\r\n### 代码\r\n```python\r\nclass Solution: \r\n\tdef addToArrayForm(self, num: List[int], k: int) -> List[int]: \r\n\t\tn = len(num) \r\n\t\tcarry = total = 0 \r\n\t\tres = [] \r\n\t\ti = len(num)-1 # track digits in num \r\n\t\twhile i >= 0 or k != 0: \r\n\t\t\tx = num[i] if i >= 0 else 0 # last digit in num \r\n\t\t\ty = k % 10 if k != 0 else 0 # last digit in k \r\n\t\t\ttotal = x + y + carry \r\n\t\t\tcarry = total // 10 \r\n\t\t\tk = k // 10 # remove last digit from k \r\n\t\t\ti -= 1 \r\n\t\t\tres.append(total % 10) \r\n\t\t\t\r\n\t\tif carry != 0: \r\n\t\t\tres.append(carry) \r\n\t\treturn res[::-1]\r\n```\r\n\r\n**复杂度分析**\r\n- 时间: O(N), n is max number of digits in num or k\r\n- 空间: O(N), n is number of digits we processed in the while loop and the space in the res array","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430710786","body":"### 思路\nfirst pass left to right to calculate distance between last index of c (prev) and current index of element i, save answer to arr.\nsecond pass right to left to calculate distance between current i and last index of c.\ncompare with saved answers to find minimum\n\n### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n        prev = float('-inf')\n        ans = []\n        for i, ele in enumerate(s):\n            if ele == c:\n                prev = i\n            ans.append(i - prev)\n\n        prev = float('inf')\n        for i in range(len(s)-1, -1, -1):\n            if s[i] == c:\n                prev = i\n            ans[i] = min(prev - i, ans[i])\n\n        return ans\n```\n\n**复杂度分析**\n时间: O(n) all elements in s\n空间: O(n) ans array","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1434027418","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxsize = maxSize\n        \n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxsize:\n            self.stack.append(x)\n\n        \n\n    def pop(self) -> int:\n        if self.stack:\n            pop = self.stack.pop()\n            return pop\n        else:\n            return -1\n        \n\n    def increment(self, k: int, val: int) -> None:\n        if k < len(self.stack):\n            for i in range(k):\n                print(self.stack)\n                self.stack[i] = self.stack[i]+val\n        else:\n            for i in range(len(self.stack)):\n                self.stack[i] = self.stack[i]+val\n        \n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1433571424","body":"### 思路\r\n类似basic calculator系列，创建空stack st和空string cur_str，从左到右遍历s。如果当前遍历的是数字，用一个temporary variable num存下来。如果是左括号，把当前repeat num和cur str加进stack，reset num和cur str。遇到右括号pop stack，根据存下来的数字复制cur str并存进cur str里。如果是普通character，直接存进cur str。\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        st = []\r\n        cur_str = \"\"\r\n        num = 0\r\n        for c in s:\r\n            if c.isdigit():\r\n                num = 10*num\r\n                num += int(c)\r\n            elif c == '[':\r\n                st.append((cur_str, num))\r\n                cur_str = ''\r\n                num = 0\r\n            elif c ==']':\r\n                s, val = st.pop()\r\n                cur_str = s + val * cur_str\r\n            else:\r\n                cur_str += c\r\n        return cur_str\r\n```\r\n\r\n**复杂度分析**\r\n时间：O(n),itereated over s\r\n空间：O(max depth) aka O(n), stack","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437535008","body":"### 思路\r\nFirst we need to get the length of linkedlist to calculate actual amount to rotate.\r\nThen if list length is less than k, we modulate k by length to have the actual rotation amount.\r\nwe will make the list in cycle to make rotation easier.\r\nThen we need to find new head, which means we need to get the node at length-k-1's position (new tail) through iteration and get new head (length - k). Afterwards we set tail.next to None.\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return None\r\n        length = 1\r\n        last = head\r\n        \r\n        while (last.next):\r\n            last = last.next\r\n            length += 1\r\n\r\n        last.next = head\r\n        k = k % length\r\n        first = head\r\n        for i in range(length-k-1):\r\n            first = first.next\r\n        newhead = first.next\r\n        first.next = None\r\n\r\n        return newhead\r\n```\r\n\r\n**复杂度分析**\r\ntime: O(n) iterate through list\r\nspace: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437500021","body":"### 思路\nuse a dummy head and prev to save the node before swapping, then swap the two nodes on the go iteratively.\n\n1. setup dummy head\n2. swap first node and second node\n3. move the pointers by updating head node and prev\n\n### 代码\n\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dh = ListNode(-1)\n        dh.next = head\n        prev = dh\n\n        while head != None and head.next != None:\n            first = head\n            second = head.next\n\n            prev.next = second\n            first.next = second.next\n            second.next = first\n\n            prev = first\n            head = first.next\n\n        return dh.next\n```\n\n**复杂度分析**\ntime: O(n), iterate over the linkedlist with n nodes\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439008937","body":"### 思路\nWe first need to find the middle node in the linkedlist (root node). Initiate slow and fast pointers to find the mid point. Because it's a sorted linkedlist, we want the mid point as well as the two halves. So also initiate a prev ptr that points to one node before slow in order to help us break the linkedlist into half later. After we have the mid node, construct root tree node and check if the mid node is the same as head, which means that mid is the only node in the linkedlist thus we can return the tree node. If mid is not the only node, we recursively construct the left and right subtrees by passing them into the function.\n\n### 代码\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        # use 2 pointers to get middle node in ll\n        fast = slow = head\n        # save a reference to break list later\n        prev = None\n        \n        # find middle element in ll (rootnode)\n        while fast and fast.next:\n            fast = fast.next.next\n            prev = slow\n            slow = slow.next\n\n        # separate linkedlist into half\n        if prev:\n            prev.next = None\n\n        # construct root node\n        root = TreeNode(slow.val)\n\n        # check if there's only one element in ll (base case)\n        if slow == head:\n            return root\n\n        # recursively construct left and right subtrees\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n\n        return root\n```\n\n**复杂度分析**\nTime: O(NlogN) we find middle of the linkedlist in every recursive step, which means n/2 number of nodes every time and get mid takes O(N) time.\nSpace: O(logN) because the heightbalanced binary search tree has logN height and adding one node in each recursive call takes O(1) space, it ends up as O(LogN) overall","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1445248823","body":"### 思路\r\ntwo pointers, one at head a, one at head b. \r\ncalculate lengths of 2 lists\r\nmove the pointer with longer list with the difference between the 2 lists\r\niterate the 2 lists using 2 pointers, return when 2 pointers meet\r\nelse return None\r\n\r\n#### Clarifying Questions\r\n1. Can we modifiy the original list or are we returning a new list\r\n2. Can the intersection point be at the end or in the middle of the linkedlist\r\n3. Can the linkedlist contain duplicates\r\n\r\n### 代码\r\n```python\r\ndef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n\tp1, p2 = headA, headB\r\n        l1 = l2 = 0\r\n        while p1:\r\n            l1 += 1\r\n            p1 = p1.next\r\n        while p2:\r\n            l2 += 1\r\n            p2 = p2.next\r\n        p1, p2 = headA, headB\r\n        if l2 < l1:\r\n            for i in range(l1 - l2):\r\n                p1 = p1.next\r\n        else:\r\n            for i in range(l2 - l1):\r\n                p2 = p2.next\r\n\r\n        while p1 and p2:\r\n            if p1 == p2:\r\n                return p1\r\n            p1 = p1.next\r\n            p2 = p2.next\r\n        return None\r\n\t\r\n```\r\n\r\n**复杂度分析**\r\nTime: O(M+N) worst case each list is traversed twice (2M+2N)\r\nSpace: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1445243695","body":"### 思路\r\nslow and fast pointer to find the intersection point first. Once the two met, we'll use a third pointer start starting from head to construct a second meet between pointers slow and start.\r\n\r\n### 代码\r\n```python\r\ndef detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n\r\n\tfast = slow = head\r\n\t\r\n\twhile fast and fast.next:\r\n\t\r\n\t\tfast = fast.next.next\r\n\t\t\r\n\t\tslow = slow.next\r\n\t\r\n\t\tif fast == slow:\r\n\t\t\r\n\t\t\tstart= head\r\n\t\t\t\r\n\t\t\twhile start != slow:\r\n\t\t\t\r\n\t\t\t\tstart = start.next\r\n\t\t\t\t\r\n\t\t\t\tslow = slow.next\r\n\t\t\t\r\n\t\t\treturn start\r\n\t\t\r\n\t\treturn None\r\n```\r\n\r\n**复杂度分析**\r\nTime: O(N) we exactly had 2 runs over all elements\r\nSpace: O(1) only pointers","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445194328","body":"### 思路\nrecursively traverse the tree to the leaf. Base case is reaching leaf node, in this case the depth is 1 (for the leaf itself). We will calculate the depth of left and right subtrees and return the max of the two, plus 1 for depth of root node.\n\n### 代码\n```python\nclass Solution:\ndef maxDepth(self, root: Optional[TreeNode]) -> int:\n\tif not root:\n\t\treturn 0\n\tif root.left == None and root.right == None:\n\t\treturn 1\n\t\n\tleft = self.maxDepth(root.left)\n\t\n\tright = self.maxDepth(root.right)\n\t\n\treturn max(left, right)+1\n```\n\n**复杂度分析**\nTime: O(N) we visit each node exactly once\nSpace: O(log(N)) worst case is O(N) aka height of the tree, best case with a balanced tree height is log(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445433635","body":"### 思路\nrecursively check every node in the two trees. \nbase case: both nodes are none (True)\n\n### 代码\n```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if (not p or not q) or p.val != q.val:\n            return False\n        left = self.isSameTree(p.left, q.left)\n        right = self.isSameTree(p.right, q.right)\n        return left and right\n```\n\n**复杂度分析**\nTime: O(N), number of nodes\nSpace: O(N), number of nodes in recursion stack for an unbalanced tree","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447196767","body":"### 思路\r\n- iteratively search through the tree\r\n- use stack to get root and curr Number\r\n- if at leaf, update curr else get left and right\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        # iteratively search through the tree\r\n        # use stack to get root and curr Number\r\n        # if at leaf, update curr\r\n        # else get left and right\r\n\r\n        stack = [(root, 0)]\r\n        total = 0\r\n\r\n        while stack:\r\n            node, curr = stack.pop()\r\n            curr = curr * 10 + node.val\r\n\r\n            if not node.left and not node.right:\r\n                total += curr\r\n            if node.left:\r\n                stack.append((node.left, curr))\r\n            if node.right:\r\n                stack.append((node.right, curr))\r\n                \r\n\r\n        return total\r\n```\r\n\r\n**复杂度分析**\r\nTime: O(N) all nodes in tree\r\nSpace:O(H) height of tree","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449248874","body":"### 思路\n- bfs using queue to traverse tree level by level\n- when enqueuing, we will make sure to enqueue right childs first to make sure the last node in queue is the leftmost child\n\n### 代码\n```python\nfrom collections import deque\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        q = deque()\n        q.append(root)\n        res = 0\n\n        # level order bfs from right to left\n        while q:\n            node = q.popleft()\n            res = node.val\n            if node.right:\n                q.append(node.right)\n            if node.left:\n                q.append(node.left)\n\n        return res\n```\n\n**复杂度分析**\nTime: O(N) number of nodes in tree\nSpace: O(w) w is the maximum width of the binary tree, aka max size of queue (one level in binary tree)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1452877610","body":"### 思路\nsorting and dfs\n\n### 代码\n```python\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        nodes = []\n        # dfs for getting vertical order list of nodes\n        def dfs(row, col, node):\n            if not node:\n                return\n            nodes.append((col, row, node.val))\n            dfs(row+1, col-1, node.left)\n            dfs(row+1, col+1, node.right)\n        dfs(0, 0, root)\n\n        # sort list based on col index to restore the order\n        nodes.sort()\n\n        # gather return nodes\n        res = []\n        curr_col_idx = nodes[0][0]\n        curr_col = []\n        for col, row, val in nodes:\n            if col == curr_col_idx:\n                curr_col.append(val)\n            else:\n                # add col\n                res.append(curr_col)\n                # reset\n                curr_col = []\n                # set to cur idx\n                curr_col_idx = col\n                # append cur node as start node\n                curr_col = [val]\n        # add leftover\n        res.append(curr_col)\n        return res\n```\n\n**复杂度分析**\nTime: O(NlogN) for sorting all nodes in tree (dfs is O(N))\nSpace: O(N) for all nodes in tree","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1454978548","body":"class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        # build freq map\n        # get unique elements (keys)\n        # generate random pivot inedx\n        # get the sorted pivot position by partition\n        # quickselect to find the k smallest element idnex\n        # if k == pivotidx, end\n        # if k < pivot, we move to left side of pivot\n        # else right side\n        # return the n-k's elements in arr\n\n        freqs = collections.Counter(nums)\n        unique = list(freqs.keys())\n\n\n        def partition(start, end, pivot_idx):\n            # get val of pivot\n            pivot_freq = freqs[unique[pivot_idx]]\n            # move to end\n            unique[pivot_idx], unique[end] = unique[end], unique[pivot_idx]\n            # set store\n            store_idx = start\n\n            for i in range(start, end):\n                if pivot_freq > freqs[unique[i]]:\n                    unique[i], unique[store_idx] = unique[store_idx], unique[i]\n                    store_idx += 1\n            unique[store_idx], unique[end] = unique[end], unique[store_idx]\n            return store_idx\n\n\n        def quickselect(left, right, k_smallest):\n            # base case only 1 element\n            if left == right:\n                return\n\n            pivot_idx = random.randint(left, right)\n            pivot_idx = partition(left, right, pivot_idx)\n\n            if k_smallest == pivot_idx:\n                return\n            elif k_smallest < pivot_idx:\n                quickselect(left, pivot_idx-1, k_smallest)\n            else:\n                quickselect(pivot_idx+1, right, k_smallest)\n\n        n = len(unique)\n        quickselect(0, n-1, n-k)\n        return unique[n-k:]","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461257444","body":"class Solution:\n    def minSubarray(self, nums, p):\n        # Step 1: Find the sum of all the elements in the array.\n        total_sum = sum(nums)\n        \n        # Step 2: Find the remainder of the sum divided by p.\n        remainder = total_sum % p\n        \n        # Step 3: If the remainder is 0, return 0 as we don't need to remove any subarray.\n        if remainder == 0:\n            return 0\n        \n        # Initialize the prefix sum array and the hashmap.\n        prefix_sum = [0]\n        for num in nums:\n            prefix_sum.append((prefix_sum[-1] + num) % p)\n        hashmap = {0: 0}\n        \n        # Initialize the minimum length of the subarray to be removed.\n        min_length = len(nums)\n        \n        # Traverse the prefix sum array and update the hashmap.\n        for i in range(1, len(prefix_sum)):\n            target = (prefix_sum[i] - remainder) % p\n            if target in hashmap:\n                # If we find a key in the hashmap that matches our target, update the minimum length of the subarray.\n                min_length = min(min_length, i - hashmap[target])\n            hashmap[prefix_sum[i]] = i\n        \n        # If we couldn't find a subarray whose sum has the remainder 'remainder', return -1.\n        if min_length == len(nums):\n            return -1\n        \n        # Otherwise, return the length of the smallest subarray we found.\n        return min_length","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yfu6":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428552417","body":"1. My main purpose is to divide this problem into a simple adding and spliting problem. We can start with the smallest one, for example: [1, 0, 0] and 123. We use the last '0' to add the 123, and then divide it by 10 and leave the remainer. The last element of the list will be changed from 0 to 3, meanwhile, we will add the '0' with 120. We do the divide part again and again. In the end, we have walk through all the elements of the num list. If there is still k value, we will do the other iterate to add the new list element to num.\n2. class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        for i in range(len(num) - 1, -1, -1):\n            if not k: break\n            k, num[i] = divmod(num[i] + k, 10)\n            # returns the quotient and remainder of （num[i] + k） / 10\n        while k:\n            k, a = divmod(k, 10)\n            num = [a] + num\n        return num\n3. The time and space complexity is O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430471180","body":"``\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        a,n=[],len(s)\n        for i in range(n):\n            if s[i]==c:\n                a.append(i)\n        answer=[]\n        j=0\n        for i in range(n):\n            if s[i]==c:\n                answer.append(0)\n                j+=1\n            elif i<a[0]:\n                answer.append(a[0]-i)\n            elif i>a[-1]:\n                answer.append(i-a[-1])\n            else:\n                answer.append(min((a[j]-i),(i-a[j-1])))\n        return answer\n``","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432089783","body":"```python\n# 1.  Use simple python push and pop function to solve the Problem\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = []\n        self.maxSize = maxSize\n\n\n    def push(self, x: int) -> None:\n        if len(self.stk) < self.maxSize:\n            self.stk.append(x)\n\n\n    def pop(self) -> int:\n        if not self.stk: return -1\n        return self.stk.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i < len(self.stk):\n                self.stk[i] += val\n```\n3. The Time: O(k)\nSpace: O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1433601834","body":"1. The probem can be solved by creating a stack to store the repeat string and the number to repeat. We will loop each character in the string to store the information and compute the final result.\n2.\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        cur_num = cur_str = ''\n        for c in s:\n            if c == '[':\n                stack.append(cur_str)\n                stack.append(int(cur_num))\n                cur_num = cur_str = ''\n            elif c == ']':\n                num = stack.pop()\n                prev_str = stack.pop()\n                cur_str = prev_str + cur_str * num\n            elif c.isdigit():\n                cur_num += c\n            else:\n                cur_str += c\n        return cur_str\n```\n3. Both O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435079362","body":"1. We can use python's append and pop function to build a stack and implement these functions.\n2 Code:\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.arr=[]\n    \n    def push(self, x: int) -> None:\n        self.arr.append(x)\n\n    def pop(self) -> int:\n        return self.arr.pop(0)\n\n    def peek(self) -> int:\n        return self.arr[0]\n        \n\n    def empty(self) -> bool:\n        return not self.arr\n```\n3. Time and Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435917825","body":"1. Use stack to store the number and compare the max value to return the result\n2. Code:\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            largest = num\n            while stack and stack[-1] > num:\n                largest = max(largest, stack.pop())\n            stack.append(largest)\n        return len(stack)\n```\n3.  O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436059651","body":"1. Use the n - k % n - 1 to calculate the new ring tail with the old ring head\n2. \n```python\nclass Solution:\n    def rotateRight(self, head: 'ListNode', k: 'int') -> 'ListNode':\n        if not head:\n            return None\n        if not head.next:\n            return head\n\n        old_tail = head\n        n = 1\n        while old_tail.next:\n            old_tail = old_tail.next\n            n += 1\n        old_tail.next = head\n        \n        new_tail = head\n        for i in range(n - k % n - 1):\n            new_tail = new_tail.next\n        new_head = new_tail.next\n        \n        new_tail.next = None\n        \n        return new_head\n```\n3.O(n)\nO(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1440511224","body":"```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        B = set()\n\n        while headB is not None:\n            B.add(headB)\n            headB = headB.next\n\n        while headA is not None:\n            if headA in B:\n                return headA\n            headA = headA.next\n\n        return None\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447619967","body":"```python\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        root_to_leaf = 0\n        stack = [(root, 0) ]\n        \n        while stack:\n            root, curr_number = stack.pop()\n            if root is not None:\n                curr_number = curr_number * 10 + root.val\n                if root.left is None and root.right is None:\n                    root_to_leaf += curr_number\n                else:\n                    stack.append((root.right, curr_number))\n                    stack.append((root.left, curr_number))\n                        \n        return root_to_leaf\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1448999319","body":"```python\nclass Solution:\n    def findBottomLeftValue(self, root: TreeNode) -> int:\n        \n        tree = [root]\n        ans = 0\n        while tree:\n            nx = []\n            for node in tree:\n                if node.left:\n                    nx.append(node.left)\n                if node.right:\n                    nx.append(node.right)\n            if not nx:\n                ans = tree[0].val\n                break\n            tree = nx\n        return ans\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455386385","body":"```python\nclass Solution:\n    def numberOfBoomerangs(self, points):\n        n = 0\n        for a,b in points:\n            counter = {}\n            for x,y in points:\n                key = (x-a)**2 + (y-b)**2\n                if key in counter:\n                    n += 2*counter[key]\n                    counter[key] += 1\n                else:\n                    counter[key] = 1\n        return n\n```\nT= O(n*n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465174043","body":"```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums)-1\n        while r>=l:\n            i = (l+r)//2\n            if nums[i]==target:\n                return i\n            if nums[i]>target:\n                r = i-1\n            else:\n                l = l+1\n        return r+1\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473011960","body":"```python\nclass Solution(object):\n    def judgeCircle(self, moves):\n        x = y = 0\n        for move in moves:\n            if move == 'U': y -= 1\n            elif move == 'D': y += 1\n            elif move == 'L': x -= 1\n            elif move == 'R': x += 1\n\n        return x == y == 0\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mengsixing":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428927200","body":"var addToArrayForm = function(num, k) {\n    let result = []\n    for(let i=num.length-1;i>=0;i--){\n        let sum = num[i] + k % 10;\n        k = Math.floor(k/10);\n        if(sum >=10){\n            sum-=10;\n            k++;\n        }\n        result.push(sum)\n    }\n    while(k > 0){\n        result.push(k % 10);\n        k = Math.floor(k/10);\n    }\n    return result.reverse();\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431464685","body":"```js\nvar shortestToChar = function(s, c) {\nlet result = Array.from(s).fill(0);\nlet idx = -s.length;\nfor(let i=0;i<s.length;i++){\n    if(s[i]=== c){\n        idx = i;\n    }\n    result[i] = i-idx;\n}\n\nidx =s.length * 2;\nfor(let i=s.length-1;i>=0;--i){\n    if(s[i]=== c){\n        idx = i;\n    }\n    result[i] = Math.min(idx-i,result[i]);\n}\n\nreturn result\n\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438503295","body":"```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode pre = new ListNode(0);\n        pre.next = head;\n        ListNode temp = pre;\n        while(temp.next != null && temp.next.next != null) {\n            ListNode start = temp.next;\n            ListNode end = temp.next.next;\n            temp.next = end;\n            start.next = end.next;\n            end.next = start;\n            temp = start;\n        }\n        return pre.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439277735","body":"```js\nvar sortedListToBST = function(head) {\n    let arr = [];\n    let child = head;\n    while(child){\n        arr.push(child.val);\n        child = child.next;\n    }\n\n    function buildTree(arr,start,end){\n        if(start>end){\n            return null;\n        }\n        if(end  === start){\n            return new TreeNode(arr[start],null,null);\n        }\n        if(end-start===1){\n            const root = new TreeNode(arr[end],null,null);\n            root.left = new TreeNode(arr[start],null,null);\n        }\n\n        const mid = Math.floor((start+end)/2);\n        const root = new TreeNode(arr[mid],null,null);\n        root.left = buildTree(arr,start,mid-1);\n        root.right = buildTree(arr,mid+1,end);\n        return root;\n    }\n\n    return buildTree(arr,0,arr.length-1);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441086287","body":"```js\nvar getIntersectionNode = function(headA, headB) {\n    var h1 = headA;\n    var h2 = headB;\n    while(h1 != h2){\n        h1 = h1 == null ? headB : h1.next;\n        h2 = h2 == null ? headA : h2.next;\n    }\n    return h1\n   \n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447380225","body":"```js\nvar sumNumbers = function(root) {\n    return helper(root,0)\n};\n\nfunction helper(node,value){\n    if(node === null){\n        return 0;\n    }\n    let temp = value * 10 +  node.val;\n\n    if(node.left===null && node.right===null){\n        return temp\n    }\n\n    return helper(node.left,temp)+helper(node.right,temp)\n\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450283413","body":"```js\nvar findBottomLeftValue = function(root) {\n    let result = 0;\n    const queue= [root];\n    while(queue.length){\n        const item = queue.shift();\n        if(item.right){\n            queue.push(item.right)\n        }\n        if(item.left){\n            queue.push(item.left)\n        }\n        result = item.val; \n    }\n    return result\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451111049","body":"```js\nvar serialize = function(root) {\n    return rserialize(root, '');\n};\n\nvar deserialize = function(data) {\n    const dataArray = data.split(\",\");\n    return rdeserialize(dataArray);\n};\n\nconst rserialize = (root, str) => {\n    if (root === null) {\n        str += \"None,\";\n    } else {\n        str += root.val + '' + \",\";\n        str = rserialize(root.left, str);\n        str = rserialize(root.right, str);\n    }\n    return str;\n}\n\nconst rdeserialize = (dataList) => {\n    if (dataList[0] === \"None\") {\n        dataList.shift();\n        return null;\n    }\n\n    const root = new TreeNode(parseInt(dataList[0]));\n    dataList.shift();\n    root.left = rdeserialize(dataList);\n    root.right = rdeserialize(dataList);\n\n    return root;\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"import-ant":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428956544","body":"\n\n## 思路\n将k转化为数组，然后数组k和数组num遍历，按位相加。\n- 加数1：k[j]\n- 加数3：num[i]\n- 进位：c\n- **结果result**:(k[j]+num[i]+c) % 10\n-  **下一个进位** ：Math.floor(result / 10)\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    //利用数组 字符串api (大数超出的风险)\n    // return (+num.join('')+k + '').split('');\n\n    //将k转化成数组，遍历num做加法运算。\n    k = (k+'').split('');\n    const length1 = num.length;\n    const length2 = k.length;\n    let i = length1-1,j=length2-1,c=0,result = [];\n    while(i >= 0 || j >= 0){\n        const add1 = i >= 0 ? num[i] : 0;\n        const add2 = j >= 0 ? +k[j] : 0;\n        const sum = add1 + add2 + c;\n        c = Math.floor(sum / 10);\n        result.unshift(sum % 10);\n        i --;\n        j --;\n    }\n    if(c != 0){\n        result.unshift(c);\n    }\n    return result\n};\n\n```\n\n\n**复杂度分析**\n令 n 为Math.max(k.length,num.length)。\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431234199","body":"\n\n## 思路\n- 将数组s中字符c出现的索引放到一个临时数组中。\n- 遍历数组s，对于s中的每个元素，遍历存放索引的临时数组，去找abs(temp(j)-i)最小的那个值。\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    const length = s.length;\n    const answer = new Array(length).fill(0);\n    const temp = [];\n    for(let i = 0;i < length;i ++){\n        if(s[i] == c){\n            temp.push(i);\n        }\n    }\n    for(let i = 0;i < length;i ++){\n        let t = Infinity\n        for(let j = 0;j < temp.length;j ++){\n            t = Math.min(Math.abs(temp[j]-i),t);\n        }\n        answer[i] = t;\n    }\n    return answer;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。k为数组中字符c的数量\n\n- 时间复杂度：$O(n*k)$\n- 空间复杂度：$O(k)$ ，忽略结果数组\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432342758","body":"\n## 思路\n- 增量数组，前缀和思想\n- 先记录增加的值，在pop的时候加上该增加的值。\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = [];\n    this.maxSize = maxSize;\n    //记录增量\n    this.add = new Array(maxSize).fill(0);\n    this.size = 0;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.size < this.maxSize){\n        this.stack[this.size] = x;\n        this.size ++;\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.size == 0){\n        return -1;\n    }\n    if(this.size >= 2){\n        this.add[this.size-2] += this.add[this.size-1];\n    }\n    const num = this.stack[this.size-1] + this.add[this.size-1];\n    this.add[this.size-1] = 0;\n    this.size --;\n    return num;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const num = Math.min(k,this.size);\n    this.add[num-1] += val;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n**复杂度分析**\n\n令 maxSize 为栈最大长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(maxSize)$ 增量数组\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joriscai":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428969365","body":"# 思路\n先将k转成数组，再利用双指针分别从k和num的最后一位开始按位计算。注：需要考虑最后一次进位的情况。\n\n# 代码\njavascript\n\n```javascript\n/*\n * @lc app=leetcode.cn id=989 lang=javascript\n *\n * [989] 数组形式的整数加法\n */\n\n// @lc code=start\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n  const kArr = (k + '').split('')\n  let temp = 0\n  const ret = []\n  let i = num.length - 1\n  let j = kArr.length - 1\n  while(i >= 0 || j >= 0) {\n    const sum = (num[i] || 0) + parseInt(kArr[j] || 0) + temp\n    ret.unshift(sum % 10)\n    temp = parseInt(sum / 10)\n    i--\n    j--\n  }\n  if (temp) {\n    ret.unshift(temp)\n  }\n\n  return ret\n};\n// @lc code=end\n\n```\n\n# 复杂度分析\n时间复杂度：O(max(n, log k))，其中 n 为数组的长度。log k为k的位，即log 10(k)，10为底k的对数。\n空间复杂度：O(max(n, log k))。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1433309147","body":"# 思路\n- 先正序遍历数组，找目标字符跟右边元素的距离\n- 再反序遍历数组，找目标字符与左边元素的距离，同时取两次距离的最小值\n\n# 代码\njavascript\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n  let dis = Infinity\n  const ret = []\n  for (let i = 0; i < s.length; i++) {\n    const cur = s[i]\n    if (cur === c) {\n      dis = 0\n    } else {\n      dis++\n    }\n    ret.push(dis)\n  }\n\n  for (let i = s.length - 1; i >= 0; i--) {\n    const cur = s[i]\n    if (cur === c) {\n      dis = 0\n    } else {\n      dis++\n    }\n    ret[i] = Math.min(dis, ret[i])\n  }\n\n  return ret\n};\n\n```\n\n# 复杂度分析\n- 时间复杂度：O(n)，需要遍历两次数组，正序和反序\n- 空间复杂度：O(n)，返回结果的大小","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433304413","body":"# 思路\n- push方法要限制超过长度时不入栈\n- pop方法为了让所有操作都为O(1)的话，在出栈时再进行增加操作\n  - 出栈时要取出对应的增加值，并与栈顶值相加\n  - 由于数据出栈了，对应位置的加值无用，故对应位置的加值设为0，即默认值\n  - 由于inc方法的k是指栈底的 k 个元素，故此时下一位的加值要加上此次取出的加值，inc方法是栈底k个元素都增加val。\n- increment方法在对应的位置累加上加值即可 O(1)\n\n# 代码\njavascript\n\n```javascript\n/*\n * @lc app=leetcode.cn id=1381 lang=javascript\n *\n * [1381] 设计一个支持增量操作的栈\n */\n\n// @lc code=start\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.size = maxSize\n  this.stack = []\n  this.add = []\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length < this.size) {\n    this.stack.push(x)\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  // 方法一\n  // return this.stack.pop() || -1\n\n  // 方法二\n  const len = this.stack.length\n  if (len === 0) {\n    return -1\n  }\n\n  const add = this.add[len] || 0\n  // 由于只记录当前栈顶的增加值\n  // 故要更新下一个栈顶\n  this.add[len - 1] = this.add[len - 1] || 0\n  this.add[len - 1] += add\n  // 出栈后，对应位置的增加值无用，重置为0\n  this.add[len] = 0\n\n  const curr = this.stack.pop()\n\n  return curr + add\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  // 方法一\n  // const len = Math.min(this.stack.length, k)\n  // for (let i = 0; i < len; i++) {\n  //   this.stack[i] += val\n  // }\n\n  // 方法二\n  const index = Math.min(this.stack.length, k)\n  this.add[index] = this.add[index] || 0\n  this.add[index] += val\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n// @lc code=end\n\n```\n\n# 复杂度分析\n- 时间复杂度：O(1)，三个方法都是O(1)\n- 空间复杂度：O(n)，一个栈空间和一个加值存放空间，两个都是n的长度","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436016562","body":"# 思路\n- 哈希表\n- 一段区间内，若原数组的总和与排序后的数组的总和相等，则说明该区间排序后所在的位置与全部排序后相对应\n- 判断可以分块后，故要将重新保持一致，找下一个分块\n\n# 代码\njavascript\n\n```javascript\n/*\n * @lc app=leetcode.cn id=768 lang=javascript\n *\n * [768] 最多能完成排序的块 II\n */\n\n// @lc code=start\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n  const sortArr = [...arr].sort((a, b) => a - b)\n  let sum1 = 0\n  let sum2 = 0\n  let count = 0\n  for (let i = 0; i < arr.length; i++) {\n    // 判断原数组与排序后的数组的总和是否一样\n    sum1 += arr[i]\n    sum2 += sortArr[i]\n    // 若一样，则说明当前区间可以排序最终的结果，可以分块\n    if (sum1 === sum2) {\n      count += 1\n      // 由于已经分块，故要将重新保持一致，找下一个分块\n      // 其实两个结果都相等才能成立分块，已经保持一致了，下面的可不用置零\n      // 考虑到可以溢出的问题，建议设置为零\n      sum1 = 0\n      sum2 = 0\n    }\n  }\n  return count\n};\n// @lc code=end\n\n```\n\n# 复杂度分析\n- 时间复杂度：O(NlogN)，只遍历一次数组，但是数组的排序更加耗时，数组排序大概是O(NlogN)\n- 空间复杂度：O(N)，用了三个变量，还有存放排序后的数组，故为O(N)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441117243","body":"# 思路\n- 当不相交部分的长度一样时，故两个指针同时前进，最终相遇\n- 当不相交部分的长度不一致时，可使用双指针消除不相交部分的长度差\n  - 两指针分别从a,b链表头节点开始，同时前进\n  - 当有一个指针走到尾节点时，改成指向另一个链表\n  - 当两个指针都进行了交换时，此时链表的长度差消除\n  - 即可以当成不相交部分长度一致了，同时前进最终会相遇\n# 代码\njavascript\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    if (!headA || !headB) return null\n    let curA = headA\n    let curB = headB\n    while (curA !== curB) {\n        curA = curA ? curA.next : headB\n        curB = curB ? curB.next : headA\n    }\n\n    return curA\n};\n```\n\n# 复杂度分析\n- 时间复杂度：O(n)，每个链表最多被遍历两次，即2*n次，n = lenA + lenB\n- 空间复杂度：O(1)，只用了常数空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442702867","body":"# 思路\n- 双指针的方法\n- 首先要判断是否链表有环\n- 当链表有环时，两个指针会在环内相遇\n- 2(L+C) = L + 2C + D\n- 因此，相遇后将另一个指针重新从表头部走，最终将再入环点相遇\n# 代码\njavascript\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if (!head || !head.next) return null\n    let slow = head\n    let fast = head\n    while (fast.next && fast.next.next) {\n        slow = slow.next\n        fast = fast.next.next\n        while (slow === fast) {\n            // 相遇点到入环点的距离 == 链头到入环点的距离\n            slow = head\n            while (slow !== fast) {\n                slow = slow.next\n                fast = fast.next\n            }\n            return slow\n        }\n    }\n    return null\n};\n```\n\n# 复杂度分析\n- 时间复杂度：O(n)，对于慢指针，走a+b到相遇点，后面再走c到入环点，刚好把整个链表走完\n- 空间复杂度：O(1)，只用了两个指针空间","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449537606","body":"# 思路\n- 使用广度优先遍历\n- 每次记录队列最左侧值，若当前层级都无子节点时，即为结果\n# 代码\njavascript\n\n```javascript\n/*\n * @lc app=leetcode.cn id=513 lang=javascript\n *\n * [513] 找树左下角的值\n */\n\n// @lc code=start\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n    if (!root) return null\n    let res = root.val\n    const queue = [root]\n    while (queue.length) {\n        res = queue[0].val\n        let len = queue.length\n        while (len) {\n            const node = queue.shift()\n            if (node.left) {\n                queue.push(node.left)\n            }\n            if (node.right) {\n                queue.push(node.right)\n            }\n            len--\n        }\n    }\n    return res\n};\n// @lc code=end\n\n```\n\n# 复杂度分析\n时间复杂度：O(n)，访问一次节点即可\n\n空间复杂度：O(n)，空间大小为节点最多那一层的节点数，最坏情况是，整个队列有n个节点","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457374954","body":"# 思路\n- 用哈希表来记录当前字符的下一个位置。由于对应的子字符串已经进行比较，便于直接取下一个子串\n- 定义不重复的子串开始为left，结束位置是当前的index\n- 随着index遍历后移，判断子串中是否有相同的字符，此时将字符作为哈希表的key值，可以判断key是否在map中\n- 若遇到非本身且相同时，其value必然大于本身的值，需要left的值（在更新left，并不是跳到下一个相同的字符，因为value是index + 1的）。\n- 无论是否更新left，都要更新哈希表对应key的value，更新时是index + 1，还要比较大小取遍历过程中最大的结果（最长子串）\n# 代码\njavascript\n\n```javascript\n/*\n * @lc app=leetcode.cn id=3 lang=javascript\n *\n * [3] 无重复字符的最长子串\n */\n\n// @lc code=start\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n  if (s.length === 0) return 0\n  const map = {}\n  let max = 0\n  let left = 0\n  let right = 0\n  while (right < s.length) {\n    const char = s[right]\n    if (char in map) {\n      left = Math.max(left, map[char])\n    }\n    // 存当前节点的下一位\n    // 即left指针的下次调整值\n    map[char] = right + 1\n    max = Math.max(max, right - left + 1)\n    right++\n  }\n  return max\n};\n// @lc code=end\n\n\n```\n\n# 复杂度分析\n时间复杂度：O(N)，只需要遍历一次字符串\n\n空间复杂度：O(N)，需要用map来记录字符串的位置","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467206461","body":"# 思路\n- 根据题意，法官不信任其他人，其他人都信任法官，故法官有n-1个人信任\n- 遍历每个人的信任情况，统计每个人的被信任值，当信任值等于n-1时，则此人为法官\n\n# 代码\njavascript\n\n```javascript\n/*\n * @lc app=leetcode.cn id=997 lang=javascript\n *\n * [997] 找到小镇的法官\n */\n\n// @lc code=start\n/**\n * @param {number} n\n * @param {number[][]} trust\n * @return {number}\n */\nvar findJudge = function(n, trust) {\n  const counts = new Array(n + 1).fill(0)\n\n  // 计算信任值\n  // 被信任就是流入，信任别人就是流出\n  for (const [i, j] of trust) {\n    counts[i] -= 1\n    counts[j] += 1\n  }\n\n  for (let i = 1; i < counts.length; i++) {\n    if (counts[i] === (n - 1)) {\n      return i\n    }\n  }\n\n  return -1\n};\n// @lc code=end\n```\n\n# 复杂度分析\n- 时间复杂度：O(n)，遍历一次信任数组，最后再遍历计数的数组，耗时为2n，即O(n)\n- 空间复杂度：O(n)，需要存放每个人的信任值","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475805009","body":"# 思路\n- 分别统计两个字符串各个字符出现的个数\n- 从a到z开始来计算三种情况下变换最小的次数，同时统计到当前字符前，其他字符的个数（前缀和sum）\n- 遍历中以当前字符做为最终变换的值或者边界，则三种情况分别为\n  - a全部小于b时，则a大于当前的所有字符都要变换（即a中仍未遍历到的字符，aLen - aSum），b中小于当前字符的都要变换（b中遍历到的都要变换，bSum）\n  - a全部大于b时，则a小于当前的所有字符都要变换（a中遍历到的都要变换，aSum），b中大于当前字符的都要变换（b中仍未遍历到的字符，bLen - bSum）\n  - a和b的字符都变成当前字符，则a要变换除了当前的，即aLen - aCount[i]。b也同理\n- 当字符为z时，三种情况只能符合全部都相同的情况了，即全部都变成z字符。\n\n\n\n# 代码\njavascript\n\n```javascript\n/*\n * @lc app=leetcode.cn id=1737 lang=javascript\n *\n * [1737] 满足三条件之一需改变的最少字符数\n */\n\n// @lc code=start\n/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\nvar minCharacters = function(a, b) {\n  const aCount = new Array(26).fill(0)\n  const bCount = new Array(26).fill(0)\n  for (let i = 0; i < a.length; i++) {\n    aCount[a.charCodeAt(i) - 97]++\n  }\n  for (let i = 0; i < b.length; i++) {\n    bCount[b.charCodeAt(i) - 97]++\n  }\n\n  const aLen = a.length\n  const bLen = b.length\n  let aSum = 0\n  let bSum = 0\n  let res = Number.MAX_SAFE_INTEGER\n  for (let i = 0; i < 25; i++) {\n    aSum += aCount[i]\n    bSum += bCount[i]\n    res = Math.min(res,\n      // 两个字符串要相同时的变换时，\n      // a和b字符串除了当前，其余都被当前字符串的次数\n      aLen - aCount[i] + bLen - bCount[i],\n      // a字符串都小于b字符串，a中要变换次数 + b中要变换次数\n      aLen - aSum + bSum,\n      // b字符串都小于a字符串，b中要变换次数 + a中要变换次数\n      bLen - bSum + aSum)\n  }\n\n  // 当字符为z时，此时只能a、b字符串都为z字符\n  // 那么两个字符串除了z字符外，都要变换\n  return Math.min(res, aLen - aCount[25] + bLen - bCount[25])\n};\n// @lc code=end\n\n```\n\n# 复杂度分析\n- 时间复杂度：O(m + n)，先是统计两个字符串的字母，m + n，再遍历出现的字母比较最小操作，最多26个\n- 空间复杂度：O(1)，常量空间，只需要两个26个字母的map表","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangqianqian202301":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429058772","body":"##### 思路\n可理解为三个数相加， 记为first, second, third, 只要有任何一个数不为0， 则需要循环\n##### 代码\n```py\nfrom typing import List\ndef addNumber(arr: List, num: int):\n    third = 0\n    index = len(arr) - 1\n    while num != 0 or index >= 0 or third > 0:\n        if index < 0:\n            arr.insert(0, 0)\n            index = 0\n        second = num % 10\n        first = arr[index]\n        arr[index] = (first + second + third) % 10\n        third = (first + second + third) // 10\n        index = index - 1\n        num = num // 10\n\n    return arr\n\nprint(addNumber([1, 2, 1], 89))\nprint(addNumber([1, 2, 1], 890))\n            \n```\n##### 算法复杂度\n- 时间复杂度O(n)\n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430808614","body":"##### 思路\n使用两个变量存储要查找的字符的位置，取距离两个字符的最小者\n##### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        length = len(s)\n        lIndex = -length\n        rIndex = s.index(c)\n        rtnArr = [0 for i in range(length)]\n        for i in range(len(s)):\n            if s[i] == c:\n                lIndex, rIndex = rIndex, i\n                for j in range(lIndex + 1, rIndex):\n                    rtnArr[j] = min(abs(j - lIndex), abs(j - rIndex))\n\n            else:\n                rtnArr[i] = min(abs(i - lIndex), abs(i - rIndex))\n        return rtnArr\n```\n##### 复杂度\nO(mn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432761016","body":"##### 思路\n使用一个数组，一个index, index指向最新数据\n##### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.data = [None] * maxSize\n        self.index = -1\n\n    def push(self, x: int) -> None:\n        if (self.index + 1) < self.maxSize:\n            self.index = self.index + 1\n            self.data[self.index] = x\n\n    def pop(self) -> int:\n        if self.index >= 0:\n            self.index = self.index - 1\n            return self.data[self.index + 1]\n        else:\n            return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        to = min(k - 1, self.index)\n        for i in range(0, to + 1):\n            self.data[i] = self.data[i] + val\n\n```\n##### 复杂度\nO(1)\nO(1)\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434235254","body":"##### 思路\n使用两个stack, 一个存原始数据， 一个存局部数据\n##### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        res = \"\"\n        seg = \"\"\n        stack = []\n        segStack = []\n        index = 0\n        while (index + 1) <= len(s):\n            c = s[index]\n            if c != ']':\n                stack.append(c)\n            else:\n                repeatStr = \"\"\n                while stack[-1] != '[':\n                    if stack[-1] == '#':\n                        stack.pop()\n                        repeatStr = segStack.pop() + repeatStr\n                    else:\n                        repeatStr = stack.pop() + repeatStr\n                stack.pop()\n                times = \"\"\n                while len(stack) > 0 and stack[-1].isdigit():\n                    times = stack.pop() + times\n                seg = \"\"\n                for i in range(int(times)):\n                    seg = repeatStr + seg\n                if len(stack) == 0:\n                    res = res + seg\n                else:\n                    stack.append('#')\n                    segStack.append(seg)\n                seg = \"\"\n\n            index = index + 1\n        temp = \"\"\n        while len(stack) > 0:\n            if stack[-1] == '#':\n                stack.pop()\n                temp = segStack.pop() + temp\n            else:\n                temp = stack.pop() + temp\n\n        return res + temp\n\n```\n##### 时间复杂度\nO(nm)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435457615","body":"##### 思路\nstack1用于push, stack2用于pop\n如果stack2没有元素pop, stack1中的全部元素弹出到stack2中\n##### 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if len(self.stack2) == 0:\n            length = len(self.stack1)\n            for i in range(length):\n                self.stack2.append(self.stack1.pop())\n        if len(self.stack2) == 0:\n            return None\n        else:\n            return self.stack2.pop()\n        \n\n    def peek(self) -> int:\n        peekEle = self.pop()\n        if peekEle is not None:\n            self.stack2.append(peekEle)\n        return peekEle\n\n    def empty(self) -> bool:\n        return len(self.stack1) == 0 and len(self.stack2) == 0\n```\n\n##### 复杂度\npush O(1)\npop O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435996892","body":"##### 思路\n如果可以分成多块，那么前一块中的最大指小于下一块的最小值\n遍历这个列表，碰到比当前值小，则与前面各块最大值比较，确定是否合并\n碰到比当前值大或者相等，记作一块\n##### 代码\n```python\nfrom typing import List\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        leftMaxArr = []\n        leftMaxEle = (0, arr[0])\n        for i in range(1, len(arr)):\n            if leftMaxEle[1] <= arr[i]:\n                leftMaxArr.append(leftMaxEle)\n                leftMaxEle = (i, arr[i])\n            else:\n                while leftMaxArr and leftMaxArr[-1][1] > arr[i]:\n                    leftMaxArr.pop()\n                if leftMaxArr:\n                    leftMaxEle = (i, leftMaxEle[1])\n        leftMaxArr.append(leftMaxEle)\n        return len(leftMaxArr)\n\n```\n##### 复杂度分析\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436441566","body":"##### 思路\n把列表做成一个环，走length - k步， 就是新的头结点\n##### 代码\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0:\n            return head\n        if not head:\n            return None\n        temp = head\n        length = 1\n        while temp.next :\n            length = length + 1\n            temp = temp.next\n        k = k % length\n        if k == 0:\n            return head\n        temp.next = head\n\n        step = length - k\n        temp = head\n        while step > 1:\n            temp = temp.next\n            step = step - 1\n        head = temp.next\n        temp.next = None\n\n        return head\n```\n##### 复杂度\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437810938","body":"##### 思路\n使用两个变量， 一个pre, 一个left结点实现两两逆转\n##### 代码\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None or head.next is None:\n            return head\n\n        pre = ListNode()\n        pre.next = head\n        left = head\n        head = pre\n        while left is not None and left.next is not None:\n            pre.next = left.next\n            left.next = left.next.next\n            pre.next.next = left\n            pre = left\n            left = left.next\n        pre = None\n\n        return head.next\n```\n##### 复杂度\nO(n)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439519838","body":"##### 思路\n1. 选中中间结点\n2. 递归设置左结点和右结点\n##### 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if head is None or head.next is None:\n            return head\n\n        length = 0\n        temp = head\n        while temp is not None:\n            length = length + 1\n            temp = temp.next\n        return self.list2Tree(head, length)\n\n    def list2Tree(self, head: Optional[ListNode], length: int) -> Optional[TreeNode]:\n        if length <= 1:\n            return TreeNode(head.val, None, None)\n        middle = (length - 1) // 2\n        temp = head\n        tempMiddle = middle\n        while tempMiddle > 0:\n            temp = temp.next\n            tempMiddle = tempMiddle - 1\n\n        root = TreeNode(temp.val, None, None)\n        if middle > 0:\n            root.left = self.list2Tree(head, middle) \n\n        root.right = self.list2Tree(temp.next, length - middle - 1) \n\n        return root\n\n```\n\n##### 复杂度\n?","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441186594","body":"##### 思路\n先找出长度差异 ， 再循环比较 \n##### 代码\n```python\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if headA == headB:\n            return headA\n        if headA is None or headB is None:\n            return None\n        tempA = headA\n        tempB = headB\n        while True:\n            tempA = tempA.next;\n            tempB = tempB.next;\n            if tempA == tempB:\n                return tempA\n            if tempA is None:\n                tempA = headA\n                break\n            if tempB is None:\n                tempB = headB\n                break\n        if tempA == headA:\n            while tempB:\n                tempB = tempB.next\n                headB = headB.next\n            tempB = headB\n        else:\n            while tempA:\n                tempA = tempA.next\n                headA = headA.next\n            tempA = headA\n\n        while tempA:\n            if tempA == tempB:\n                return tempA\n            tempA = tempA.next\n            tempB = tempB.next\n\n        return None\n\n\n```\n##### 复杂度\nO(m + n)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442840748","body":"##### 思路\n使用快慢指针判断是否有环\n从第一次相遇处断开， 分两路再往下走， 如果一个指针到头， 换到另一路，直到相遇\n##### 代码\n```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None:\n            return None        \n        oneStep = head\n        twoStep = head.next\n        while oneStep is not None and twoStep is not None:\n            if oneStep == twoStep:\n                twoStep = oneStep.next\n                oldHead = head\n                newHead = twoStep\n                oneStep.next = None\n                while head != twoStep:\n                    head = head.next\n                    twoStep = twoStep.next\n                    if head is None:\n                        head = newHead\n                    if twoStep is None:\n                        twoStep = oldHead\n                return head\n            oneStep = oneStep.next\n            twoStep = twoStep.next\n            if twoStep is not None:\n                twoStep = twoStep.next\n            else:\n                break\n        return None\n\n```\n##### 复杂度\nO(n)\nO(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447643006","body":"##### 思路\n1. 遍历二叉树， 构造出所有结点的前结点， 存在hash中\n2. 对当前位做加法\n3. 合并最终结果\n##### 代码\n```python\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n                if root is None:\n            return 0\n        preHash = {}\n        list = []\n        toAdd = []\n        list.append(root)\n        while list:\n            e = list.pop()\n            if e.left:\n                list.append(e.left)\n                preHash[e.left] = e\n            if e.right:\n                list.append(e.right)\n                preHash[e.right] = e\n\n            if e.left is None and e.right is None:\n                toAdd.append(e)\n\n        result = []\n\n        temp = 0\n        while toAdd:\n            preNodeArr = []\n            for n in toAdd:\n                temp = temp + n.val\n                if preHash[n]:\n                    preNodeArr.append(preHash[n])\n            result.append(temp % 10)\n            temp = temp // 10\n            toAdd = preNodeArr\n        if temp > 0:\n            result.append(temp)\n\n        sum = 0\n        while result:\n            sum = sum * 10 + result.pop()\n\n        return sum\n\n```\n##### 复杂度\nO(n)\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449418500","body":"##### 思路\n使用一个队列，从右到左遍历二叉树， 同时设置最左边结点\n##### 代码\n```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return None\n        l = []\n        bottomLeft = root\n        l.append(root)\n        while l:\n            temp = l.pop(0)\n            if temp.right:\n                l.append(temp.right)\n                bottomLeft = temp.right\n            if temp.left:\n                l.append(temp.left)\n                bottomLeft = temp.left\n        return bottomLeft.val\n```\n##### 复杂度\nO(n)\nO(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453209132","body":"##### 思路\n1. 使用队列遍历二叉树\n2. 使用一个2000长度的数组，把各个列表存起来\n3. 对列表中的元素进行排序\n4. 这个思路， 我描述的我自己也看不明白\n##### 代码\n```python\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if root is None:\n            return None\n        respArr = [[] for i in range(2000)]\n        queue = []\n        queue.append((root, 0, 1000))\n        while queue:\n            e = queue.pop(-1)\n            respArr[e[2]].append(e)\n\n            if e[0].left is not None:\n                queue.append((e[0].left, e[1] + 1, e[2] - 1))\n\n            if e[0].right is not None:\n                queue.append((e[0].right, e[1] + 1, e[2] + 1))\n\n        res = []\n        for i in range(2000):\n            if len(respArr[i]) > 0:\n                respArr[i].sort(key=lambda x : x[1] * 1000000 + x[2] * 1000 + x[0].val)\n                res.append(map(lambda x : x[0].val, respArr[i]))\n        \n        return res\n\n```\n##### 复杂度\n可能是O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454349266","body":"##### 思路\n##### code\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        numsHash = {}\n        for i in range(len(nums)):\n            current = nums[i]\n            key = target - current\n            if key in numsHash.keys():\n                return [numsHash[target - current], i]\n            else:\n                numsHash[current] = i\n        return [None, None]\n```\n##### 复杂度\nO(n)\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1454970898","body":"##### 思路\n1. 遍历数组， 把值和次数放放map\n2. 把map的values进行排序\n3. 取前k个\n##### 代码\n```python\n        if nums is None:\n            return nums\n\n        timesHash = {}\n        for c in nums:\n            if c in timesHash.keys():\n                timesHash[c] = (c, timesHash[c][1] + 1)\n            else:\n                timesHash[c] = (c, 1)\n\n        keys = list(timesHash.values())\n        keys.sort(key=lambda x : x[1], reverse=True)\n        if len(keys) > k:\n            return list(map(lambda x : x[0], keys[0:k]))\n        else:\n            return list(map(lambda x : x[0], keys))\n\n```\n##### 复杂度\nO(nlog(n))\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455802300","body":"##### 思路\n##### 代码\n```python\n        pointsLength = len(points)\n        count = 0\n        for i in range(pointsLength):\n            dHash = {}\n            for j in range(pointsLength):\n                if i == j:\n                    continue\n                d = self.distance(points[i], points[j])\n                if d in dHash.keys():\n                    dHash[d] = dHash[d] + 1\n                else:\n                    dHash[d] = 0\n                    dHash[d] = dHash[d] + 1\n            for v in list(dHash.values()):\n                print(f'v = {v}')\n                if v == 2:\n                    count = count + 2\n                elif v == 3:\n                    count = count + 6\n                elif v == 4:\n                    count = count + 12\n                else:\n                    continue\n\n\n        return count\n    def distance(self, p1: List[int], p2: List[int]) -> int:\n        distance = 0\n        if p1[0] > p2[0]:\n            distance = distance + (p1[0] - p2[0]) * (p1[0] - p2[0])\n        else:\n            distance = distance + (p2[0] - p1[0]) * (p2[0] - p1[0])\n\n        if p1[1] > p2[1]:\n            distance = distance + (p1[1] - p2[1]) * (p1[1] - p2[1])\n        else:\n            distance = distance + (p2[1] - p1[1]) * (p2[1] - p1[1])\n        return distance\n```\n##### 复杂度\nO(n2)\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457543766","body":"##### 思路\n1. 使用两个变量指向不重复的串的开头和结尾\n2. 把不重复的字母和坐标记在hash中\n3. 碰到重复的， begin设置 到hash中记录的位置 \n4. 如果有重复的， 计算最长串\n5. 最后再比较一下end - begin + 1和max\n##### 代码\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if len(s) == 0:\n            return 0\n        begin = 0\n        end = 0\n        currentHash = {}\n        max = 0\n        for i, c in enumerate(s):\n            end = i\n            if c in currentHash.keys():\n                max = max if max > (end - begin) else (end - begin)\n                repeatIndex = currentHash[c]\n#                print(f'repeatIndex = {repeatIndex} i = {i} c = {c} begin = {begin} end = {end}')\n                while begin <= repeatIndex:\n                    del currentHash[s[begin]]\n                    begin = begin + 1\n#                print(f'repeatIndex = {repeatIndex} i = {i} c = {c} begin = {begin} end = {end}')\n            currentHash[c] = i\n        max = max if max > (end - begin + 1) else (end - begin + 1)\n        return max\n```\n##### 复杂度\nO(n)\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459609177","body":"##### 思路\n逐一比较\n##### 代码\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        windowSize = len(words[0]) * len(words)\n        if len(s) < windowSize:\n            return []\n\n        rtnList = []\n        wordsHash = {}\n        for w in words:\n            if w in wordsHash.keys():\n                wordsHash[w] = wordsHash[w] + 1\n            else:\n                wordsHash[w] = 1\n\n\n        begin = 0\n        while begin < len(s) - windowSize + 1:\n#            print(f'begin = {begin} windowSize = {windowSize}')\n            if self.find(s[begin:begin + windowSize], wordsHash):\n                rtnList.append(begin)\n            begin = begin + 1\n\n        return rtnList\n    \n    def find(self, s, wordsHash):\n        wordLength = len(list(wordsHash.keys())[0])\n        wh = {}\n        for i in range(0, len(s), wordLength):\n            k = s[i:i + wordLength]\n            if k not in wordsHash.keys():\n                return False\n            else:\n                if k in wh.keys():\n                    wh[k] = wh[k] + 1\n                else:\n                    wh[k] = 1\n\n        for k in wh.keys():\n            if wh[k] != wordsHash[k]:\n                return False\n                \n        return True\n```\n##### 复杂度\nO(nk)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461478942","body":"#####. 思路\n使用前缀和相关知识 点\n##### 代码\n```python\n        remainder = 0\n        for n in nums:\n            remainder = (remainder + n) % p\n\n        min = len(nums)\n        remainderHash = {0: -1}\n        current = 0\n        for i, n in enumerate(nums):\n            current = (current + n) % p\n            remainderHash[current] = i\n            if (current - remainder) % p in remainderHash.keys():\n                if min > (i - remainderHash[(current - remainder) % p]):\n                    min = i - remainderHash[(current - remainder) % p]\n\n        min = -1 if min == len(nums) else min\n        return min\n```\n##### 复杂度\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463143134","body":"##### 思路\n快慢指针\n##### 代码\n```python\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dumy = ListNode()\n        dumy.next = head\n        slow, fast = dumy, dumy\n        while fast is not None:\n            slow = slow.next\n            fast = fast.next\n            if fast is not None:\n                fast = fast.next\n        return slow\n```\n##### 复杂度\nO(n)\nO(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465946457","body":"##### 思路\n用一个list , 0位置放最大值， 最右面放k个数之内可能的最大值。\n每滑动一个值 ， 和右面的数比较 ， 比右面的数大， 就弹出\n0位置的数，根据当前坐标， 滑动过去， 就弹出， 弹出后， 如果数组内还有元素， 则最左边（0位置）就是最大数。\n如果没有了， 那当前数就是最大数。\n\n##### 代码\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        res = []\n        dq = []\n\n        for i in range(len(nums)):\n            while dq and dq[0] <= i - k:\n                dq.pop(0)\n            while dq and nums[dq[-1]] < nums[i]:\n                dq.pop()\n            dq.append(i)\n            if i >= k - 1:\n                res.append(nums[dq[0]])\n        \n        return res\n```\n#####\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467980037","body":"##### 思路\n用一个数组进行记录\n##### 代码\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        if len(trust) == 0:\n            if n == 1:\n                return 1\n            else:\n                return -1\n        arr = [0 for i in range(10000)]\n        for p in trust:\n            a, b = p\n            arr[a] = -1\n            if arr[b] >= 0:\n                arr[b] = arr[b] + 1\n        for i, c in enumerate(arr):\n            if c == n - 1:\n                return i\n        return -1\n\n```\n##### 复杂度\nO(n)\nO(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473098271","body":"##### 思路\n往上走的步数和往下走的相同\n向左的和向右的步数相同\n##### 代码\n```python\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        udlrHash = {'U':0, 'D':0, 'L':0, 'R':0}\n        for c in moves:\n            udlrHash[c] = udlrHash[c] + 1\n        return udlrHash['U'] == udlrHash['D'] and udlrHash['L'] == udlrHash['R']\n\n```\n##### 复杂度\nO(n)\nO(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476056836","body":"```python\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        m, n = len(a), len(b)\n        c1 = Counter(ord(c) - 97 for c in a)\n        c2 = Counter(ord(c) - 97 for c in b)\n        res = m + n - max((c1 + c2).values()) # condition 3\n        for i in range(25):\n            c1[i + 1] += c1[i]\n            c2[i + 1] += c2[i]\n            res = min(res, m - c1[i] + c2[i]) # condition 1\n            res = min(res, n - c2[i] + c1[i]) # condition 2\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477328878","body":"##### 思路\nmerge sort, 不能用快排， 在有序状态下时间复杂度变为O(n2)\n##### 代码\n```python\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        return self.mergeSort(nums)\n\n    def mergeSort(self, nums):\n        def recur(left, right):\n            nonlocal tmp\n            if left >= right: return\n\n            mid = (left + right) // 2\n            recur(left, mid)\n            recur(mid + 1, right)\n\n            pl, pr, pt = left, mid + 1, left\n            while pl <= mid and pr <= right:\n                if nums[pl] <= nums[pr]:\n                    tmp[pt] = nums[pl]\n                    pl += 1\n                else:\n                    tmp[pt] = nums[pr]\n                    pr += 1\n                pt += 1\n            if pl < mid + 1:\n                tmp[pt:right + 1] = nums[pl:mid + 1]\n            elif pr < right + 1:\n                tmp[pt:right + 1] = nums[pr:right + 1]\n            nums[left:right + 1] = tmp[left:right + 1]\n\n        l = len(nums)\n        tmp = [None] * l\n        recur(0, l - 1)\n        return nums\n```\n##### 复杂度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1478863525","body":"##### 思路\n二分加循环\n##### 代码\n```python\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 1:\n            return 1\n        t = x >> 1\n        while t * t > x:\n            t = t >> 1\n        t = t << 1\n        while t * t > x:\n            t = t - 1\n        return t\n```\n##### 复杂度\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480555449","body":"```python\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        l , r , ans = 1, n, -1\n\n        while l <= r:\n            mid = (l + r) >> 1\n            if isBadVersion(mid):\n                ans = mid\n                r = mid - 1\n            else:\n                l = mid + 1\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482301767","body":"##### 思路\n分治法， 先分组， 再排序\n##### 代码\n```python\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        return self.countPairs(nums, 0, len(nums) - 1)\n\n    def countPairs(self, nums: List[int], start: int, end: int) -> int:\n        if start >= end:\n            return 0\n        mid = (start + end) // 2\n        count = self.countPairs(nums, start, mid) + self.countPairs(nums, mid + 1, end)\n        i, j = start, mid + 1\n        while i <= mid and j <= end:\n            if nums[i] > nums[j] * 2:\n                count = count + end - j + 1\n                i = i + 1\n            else:\n                j = j + 1\n\n        nums[start : end + 1] = sorted(nums[start : end + 1], reverse=1)\n        return count\n```\n##### 复杂度\nO(nlogn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483734464","body":"##### 思路\n一次挪一个， 比较整体\n##### 代码\n```python\n        if s == goal:\n            return True\n        s, goal = [*s], [*goal]\n        for x in range(len(s)):\n            a = s[0]\n            s.pop(0)\n            s.append(a)\n            if s == goal:\n                return True\n        return False\n```\n##### 复杂度\nO(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486144639","body":"##### 思路\n一个循环\n##### 代码\n```python\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        def isVowel(c: str) -> bool:\n            return c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u'\n\n        length = len(s)\n        max = float(\"-inf\")\n        count = 0\n        for i, c in enumerate(s):\n            if i < k:\n                if isVowel(c):\n                    count = count + 1\n            else:\n                if isVowel(c):\n                    count = count + 1\n                if isVowel(s[i - k: i - k + 1]):\n                    count = count - 1\n            max = max if max > count else count\n        return max\n```\n##### 复杂度\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488176784","body":"##### 思路\ndp + huadongchuangkou\n##### 代码\n```python\n        if k == 0 or n >= k + maxPts - 1:\n            return 1.0\n        dp = [0] * (n + 1)\n        weight = 1.0\n        response = 0.0\n        dp[0] = 1.0\n        for i in range(1, n + 1):\n            dp[i] = weight / maxPts\n            if i < k:\n                weight = weight + dp[i]\n            else:\n                response = response + dp[i]\n            if i - maxPts >= 0:\n                weight = weight - dp[i - maxPts]\n        return response\n```\n##### 复杂度\nO(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491230842","body":"##### 思路\n##### 代码\n```python\nfrom collections import Counter\nfrom collections import deque\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        t_counts = Counter(t)\n        w = Counter()\n        r = ''\n        window = deque()\n        for ch in s:\n            window.append(ch)\n            w[ch] += 1\n            if all(w[c] >= t_counts[c] for c in t_counts.keys()):\n                while window and w[window[0]] > t_counts[window[0]]:\n                    w[window.popleft()] -= 1\n                if r == '' or len(window) < len(r):\n                    r = ''.join(window)\n                if window:\n                    w[window.popleft()] -= 1\n        return r\n\ns = Solution()\nprint(s.minWindow(\"abcdefg\", \"ac\"))\n\n```\n##### 复杂度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1492874714","body":"```python\nclass Solution(object):\n    def minOperations(self, nums, x):\n        target = sum(nums) - x\n        \n        if target == 0:\n            return len(nums)\n        \n        left, right = 0, 0 \n        curr, cnt = 0, 0 \n        \n        while right < len(nums):\n            curr = curr + nums[right]\n            \n            while left < right and curr > target:\n                curr = curr - nums[left]\n                left = left + 1\n            if curr == target:\n                cnt = max(cnt, right - left + 1)\n            right = right + 1\n            \n        if cnt == 0:\n            return -1 \n        else:\n            return len(nums) - cnt \n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495496921","body":"##### 思路\nbfs\n##### 代码\n```python\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n        rows, cols = len(grid), len(grid[0])\n        visited = set()\n        curArea = 0\n        maxArea = 0\n\n        def bfs(r,c):\n            queue = collections.deque()\n            area = 1\n            queue.append((r,c))\n            visited.add((r,c))\n            while queue:\n                row, col = queue.popleft()\n                directions = [\n                    [1,0],     \n                    [-1,0],    \n                    [0,1],     \n                    [0,-1]     \n                ]\n                for dr, dc in directions:\n                    r,c = row+dr,col+dc\n                    if (\n                            r in range(rows) and\n                            c in range(cols) and\n                            grid[r][c] == 1 and\n                            (r,c) not in visited\n                    ):\n                        visited.add((r,c))\n                        queue.append((r,c))\n                        area += 1\n            return area\n\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == 1 and (r,c) not in visited:\n                    curArea = bfs(r,c)\n                    maxArea = max(maxArea, curArea)\n\n        return maxArea\n\n```\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1499962724","body":"```python\nclass newNode:\n    def __init__(self, key):\n        self.data = key\n        self.left = None\n        self.right = None\n        self.hd = 0\ndef topview(root):\n    if(root == None):\n        return\n    q = []\n    m = dict()\n    hd = 0\n    root.hd = hd\n    q.append(root)\n    while(len(q)):\n        root = q[0]\n        hd = root.hd\n        if hd not in m:\n            m[hd] = root.data\n        if(root.left):\n            root.left.hd = hd - 1\n            q.append(root.left)\n\n        if(root.right):\n            root.right.hd = hd + 1\n            q.append(root.right)\n\n        q.pop(0)\n    for i in sorted(m):\n        print(m[i], end=\" \")\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501735514","body":"##### 代码\n```python\nclass Solution:\n    def findNumberOfLIS(self, nums):\n        if not nums: return 0\n    \n        decks, ends_decks, paths = [], [], []\n        for num in nums:\n            deck_idx = bisect.bisect_left(ends_decks, num)\n            n_paths = 1\n            if deck_idx > 0:\n                l = bisect.bisect(decks[deck_idx-1], -num)\n                n_paths = paths[deck_idx-1][-1] - paths[deck_idx-1][l]\n                \n            if deck_idx == len(decks):\n                decks.append([-num])\n                ends_decks.append(num)\n                paths.append([0,n_paths])\n            else:\n                decks[deck_idx].append(-num)\n                ends_decks[deck_idx] = num\n                paths[deck_idx].append(n_paths + paths[deck_idx][-1])\n              \n        return paths[-1][-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1502921367","body":"```python\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        def lcs(X, Y, m, n):\n            if m == 0 or n == 0:\n                return 0\n            elif X[m-1] == Y[n-1]:\n                return 1 + lcs(X, Y, m-1, n-1)\n            else:\n                return max(lcs(X, Y, m, n-1), lcs(X, Y, m-1, n))\n        return lcs(text1, text2, len(text1), len(text2))\n\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511041871","body":"```python\nclass Solution(object):\n    def coinChange(self, coins, amount):\n        def dp_solver(index, target, dp):\n            if index == 0:\n                if target % coins[0] == 0:\n                    return target / coins[0]\n\n                return 1e9\n\n            if dp.get((index,target)):\n                return dp.get((index,target))\n\n\n            not_take = dp_solver(index -1, target, dp)\n            take = sys.maxsize\n\n            if coins[index] <= target:\n                take = 1 + dp_solver(index, target - coins[index], dp)\n\n            dp[(index, target)] = min(take, not_take)\n            return dp[(index, target)]\n\n        ans =  dp_solver(len(coins)-1, amount, {})\n        if ans >= 1e9:\n            return -1\n        return ans\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514093215","body":"```python\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        count, i, j = 0, 0, 0\n        \n        while(i < len(g) and j < len(s)):\n            if g[i] <= s[j]:\n                count = count + 1\n                i = i + 1\n                j = j + 1\n            else:\n                j = j + 1\n        return count\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517743806","body":"```python\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        length = len(nums)\n        if length == 1 or length == 0:\n            return True\n        index = length - 2\n        while nums[index] >= (length - index - 1):\n            if self.canJump(nums[0:index]):\n                return True\n        return False\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1519996001","body":"```python\nclass Solution:\n    def beautifulArray(self, n: int) -> List[int]:\n        nums = list(range(1, n+1))\n        def ba(arr, count):\n            if count < 3:\n                return arr\n            odd = arr[1::2]\n            even = arr[0::2]\n            return ba(odd, len(odd)) + ba(even, len(even))\n        return ba(nums, n)\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1525554214","body":"```python\nclass TrieNode:\n    def __init__(self):\n        self.word=False\n        self.children={}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node=self.root\n        for i in word:\n            if i not in node.children:\n                node.children[i]=TrieNode()\n            node=node.children[i]\n        node.word=True\n    def search(self, word):\n        node=self.root\n        for i in word:\n            if i not in node.children:\n                return False\n            node=node.children[i]\n        return node.word\n    def startsWith(self, prefix):\n        node=self.root\n        for i in prefix:\n            if i not in node.children:\n                return False\n            node=node.children[i]\n        return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1527365262","body":"```python\nclass TrieNode:\n    def __init__(self):\n        self.children = collections.defaultdict(TrieNode)\n        self.value = 0\n        \nclass MapSum:\n    def __init__(self):\n        self.t = TrieNode()\n        self.m = {}\n\n    def insert(self, key: str, val: int) -> None:\n        delta = val - self.m.get(key,0)\n        self.m[key] = val\n        node = self.t\n        for char in key:\n            node = node.children[char]\n            node.value += delta\n        \n    def sum(self, prefix: str) -> int:\n        node = self.t\n        for char in prefix:\n            node = node.children.get(char)\n            if not node:\n                return 0\n        return node.value\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1536088004","body":"```python\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n\n        candidates = sorted(candidates)\n        return self.rec_combinations([], candidates, target)\n\n    def rec_combinations(self, comb, candidates, target):\n        res = []\n        if sum(candidates) < target:\n            return res\n        if target == 0:\n            res = [comb]\n            return res\n        \n        for i, c in enumerate(candidates):\n            if i > 0 and candidates[i-1] == c:\n                continue\n\n            if c <= target:\n                res += self.rec_combinations(comb+[c], candidates[i+1:], target-c)\n            if c > target:\n                break\n        \n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1537038011","body":"```python\nclass Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        nums.sort()\n        self.dfs(nums, [], res)\n        return res\n    \n    def dfs(self, nums, path, res):\n        if not nums:\n            res.append(path)\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                    continue\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\n```","onTime":true},null,null,null,null,null,null,null,null,null],"airwalkers":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429071130","body":"```java\n// 思路，类似与归并排序，num数组末尾与k末尾数字相加，记录进位carray，插入到列表头\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> sum = new LinkedList<>();\n        int i = num.length - 1;\n        int carry = 0;\n        while (i >= 0 || k > 0) {\n            if (i >= 0) {\n                carry += num[i--];\n            }\n            if (k > 0) {\n                carry += k%10;\n                k /= 10;\n            }\n            sum.addFirst(carry % 10 );\n            carry /= 10;\n        }\n        if (carry > 0) {\n            sum.addFirst(carry);\n        }\n        return sum;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431007168","body":"```java\n// 思路，从左向右扫描记录左侧最近下标入left数组，\n// 从右向左扫描右侧最近下标入right数组\n// 根据left，right数组以及i计算最近结果\n\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] chars = s.toCharArray();\n        int[] left = new int[chars.length];\n        int[] right = new int[chars.length];\n\n        for (int i = 0, pre = -1; i < chars.length; i++) {\n            if (chars[i] == c) {\n                pre = i;\n            }\n            left[i] = pre;\n        }\n\n        for (int i = chars.length - 1, pre = -1; i >= 0; i--) {\n            if (chars[i] == c) {\n                pre = i;\n            }\n            right[i] = pre;\n        }\n\n        int[] res = new int[chars.length];\n        for (int i = 0; i < chars.length; i++) {\n            if (left[i] == -1) {\n                res[i] = right[i] - i;\n            } else if (right[i] == -1) {\n                res[i] = i - left[i];\n            } else {\n                res[i] = Math.min(i - left[i], right[i] - i);\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432451659","body":"```java\n// 思路，数组模拟栈，增加一个差分数组记录栈底k个数字需要累加的值\n// 复杂度，push O(1)，pop O(1)，increment O(1)\n\nclass CustomStack {\n    int[] stack;\n    int[] acc;\n    int maxSize;\n    int i;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.acc = new int[maxSize];\n        this.maxSize = maxSize;\n        this.i = 0;\n    }\n    \n    public void push(int x) {\n        if (i < maxSize) {\n            stack[i++] = x;\n        }\n    }\n    \n    public int pop() {\n        if (i == 0) {\n            return -1;\n        }\n        --i;\n        if (i - 1 >= 0) {\n            acc[i - 1] += acc[i];\n        }\n        stack[i] += acc[i];\n        acc[i] = 0;\n        return stack[i];\n    }\n    \n    public void increment(int k, int val) {\n        if (i > 0) {\n            acc[Math.min(k - 1, i - 1)] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1437795687","body":"```java\r\n // [ push\r\n // ] pop\r\n // num or letter, append peek\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        char[] str = s.toCharArray();\r\n        Deque<StringBuilder> stack = new LinkedList<>();\r\n        stack.push(new StringBuilder());\r\n\r\n        for (char c : str) {\r\n            if (c == '[') {\r\n                stack.push(new StringBuilder());\r\n            } else if (c >= 'a' && c <= 'z') {\r\n                stack.peek().append(c);\r\n            } else if (c >= '0' && c <= '9') {\r\n                stack.peek().append(c);\r\n            } else if (c == ']') {\r\n                StringBuilder letters = stack.pop();\r\n                StringBuilder peek = stack.peek();\r\n                int k = getK(peek);\r\n                while (k > 0) {\r\n                    peek.append(letters);\r\n                    --k;\r\n                }\r\n            }\r\n        }\r\n\r\n        return stack.peek().toString();\r\n    }\r\n\r\n    private int getK(StringBuilder s) {\r\n        if (s.length() == 0) {\r\n            return 1;\r\n        }\r\n        int k = 0;\r\n        for (int i = s.length() - 1, b = 1; i >= 0 && s.charAt(i) >= '0' && s.charAt(i) <= '9'; i--) {\r\n            char c = s.charAt(i);\r\n            s.deleteCharAt(i);\r\n            k += b * (c - '0');\r\n            b *= 10;\r\n        }\r\n        return k == 0 ? 1 : k;\r\n    }\r\n}\r\n```","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437982956","body":"```java\npublic ListNode swapPairs(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        \n        ListNode pre = new ListNode();\n        pre.next = head;\n        ListNode p = pre, q = p.next;\n        while (q != null && q.next != null) {\n            ListNode r = q.next;\n            ListNode next = r.next;\n            r.next = q;\n            q.next = next;\n            p.next = r;\n            p = q;\n            q = next;\n        }\n        return pre.next;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439729876","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\n// 1 ->  2 -> null\n// p     s     f\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        // 0 结点\n        if (head == null) {\n            return null;\n        }\n        // 1 结点\n        if (head.next == null) {\n            return new TreeNode(head.val);\n        }\n        // ≥2 结点\n        ListNode prev = head;\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        // dfs\n        TreeNode root = new TreeNode(slow.val);\n        prev.next = null;\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(slow.next);\n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441168021","body":"```java\n// 思路，找到两条链路的长度差，从长的那一条先走，走到补齐的位置时两条链路同时遍历，直到找到第一个相同的节点\n\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int lenA = 0;\n        ListNode p = headA;\n        while (p != null) {\n            lenA++;\n            p = p.next;\n        }\n\n        int lenB = 0;\n        p = headB;\n        while (p != null) {\n            lenB++;\n            p = p.next;\n        }\n\n        p = headA;\n        ListNode q = headB;\n        while (lenA > lenB) {\n            p = p.next;\n            lenA--;\n        }\n        while (lenB > lenA) {\n            q = q.next;\n            lenB--;\n        }\n        while (p != null && p != q) {\n            p = p.next;\n            q = q.next;\n        }\n        return p;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442698456","body":"```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n\n            if (fast == slow) {\n                break;\n            }\n        }\n\n        if (fast == null || fast.next == null) {\n            return null;\n        }\n\n        fast = head;\n        while (fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return fast;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445246015","body":"```java\n public int maxDepth(TreeNode root) {\n        return root == null ? 0 \n            : Math.max(maxDepth(root.left) + 1, maxDepth(root.right) + 1);\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445554382","body":"```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n\n        if (p != null && q != null) {\n            return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n        \n        return false;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447437505","body":"```java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        if (root.left == null && root.right == null) {\n            return root.val;\n        }\n\n        int ret = 0;\n\n        if (root.left != null) {\n            root.left.val += root.val * 10;\n            ret += sumNumbers(root.left);\n        }\n\n        if (root.right != null) {\n            root.right.val += root.val * 10;\n            ret += sumNumbers(root.right);\n        }\n\n        return ret;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449221315","body":"```java\n// 思路：中序遍历，比较当前高度与记录的最高高度，如果当前高度更高，说明是第一次进入下一层，也就是那一层的最左节点\n\nclass Solution {\n    int maxHeight = 0, res = 0;\n\n    public int findBottomLeftValue(TreeNode root) {\n        dfs(root, 1);\n        return res;\n    }\n\n    // 前序遍历\n    private void dfs(TreeNode root, int height) {\n        if (height > maxHeight) {\n            res = root.val;\n            maxHeight = height;\n        }\n\n        if (root.left != null) {\n            dfs(root.left, height + 1);\n        }\n\n        if (root.right != null) {\n            dfs(root.right, height + 1);\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451237256","body":"```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    //  ser:  1, 2, #, #, 3, 4, #, #, 5, #, #\n    public String serialize(TreeNode root) {\n        return ser(root).toString();\n    }\n\n    private StringBuilder ser(TreeNode root) {\n        if (root == null) {\n            return new StringBuilder().append('#');\n        }\n\n        StringBuilder builder = new StringBuilder().append(root.val).append(',');\n        builder.append(ser(root.left)).append(',');\n        builder.append(ser(root.right));\n        return builder;\n    }\n\n    int i = 0;\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String[] nodesStr = data.split(\",\");\n        i = 0;\n        return des(nodesStr);\n    }\n\n    private TreeNode des(String[] nodesStr) {\n        String nodeStr = nodesStr[i++];\n\n        if (nodeStr.equals(\"#\")) {\n            return null;\n        }\n\n        TreeNode root = new TreeNode(Integer.parseInt(nodeStr));\n        root.left = des(nodesStr);\n        root.right = des(nodesStr);\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1455349248","body":"```java\n public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(target - nums[i])) {\n                return new int[]{map.get(target - nums[i]), i};\n            } else {\n                map.put(nums[i], i);\n            }\n        }\n        return new int[] {-1, -1};\n    }\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1457721262","body":"```java\nclass Solution {\n    // top k\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> counts = new HashMap<>();\n        for (int num: nums) {\n            counts.put(num, counts.getOrDefault(num, 0) + 1);\n        }\n        int[] keys = new int[counts.size()];\n        int[] cnts = new int[counts.size()];\n        int n = 0;\n        for (Map.Entry<Integer, Integer> entry : counts.entrySet()) {\n            keys[n] = entry.getKey();\n            cnts[n++] = entry.getValue();\n        }\n\n        // bs top k\n        int[] cnts1 = Arrays.copyOf(cnts, n);\n        int left = 0, right = n - 1, m = 0;\n        k = n - k;\n        if (k == 0) {\n            return keys;\n        }\n        while (left < right) {\n            // 前 k 个数 => m + 1 == k\n            // partition=> m, m + 1\n            m = partition(cnts1, left, right);\n            if (m - left + 1 == k) {\n                left = m;\n                break;\n            } else if (m - left + 1 < k) {\n                k -= m - left + 1;\n                left = m + 1;\n            } else {\n                right = m - 1;\n            }\n        }\n\n        List<Integer> res = new ArrayList<>();\n        for (int i  = 0, t = cnts1[left]; i < n; i++){\n            if (cnts[i] > t) {\n                res.add(keys[i]);\n            }\n        }\n\n        return res.stream().mapToInt(Integer::intValue).toArray();\n    }\n\n    // [0, i) [i, j) [j, n)\n    // <t     未分类  >=t\n    // i=0, j=n - 1\n    private int partition(int[] nums, int l, int r) {\n        int i = l, j = r;\n        while (i < j) {\n            if (nums[i] < nums[r]) {\n                i++;\n            } else {\n                swap(nums, i, --j);\n            }\n        }\n        swap(nums, i, r);\n        return i;\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```","onTime":false},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465426870","body":"```java\n//    输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n//    输出：[3,3,5,5,6,7]\n//    解释：\n//         1 ,3 -1  -3  5  3\n//         滑动窗口的位置                最大值\n//        ---------------               -----\n//        [1  3  -1] -3  5  3  6  7       3\n//         1 [3  -1  -3] 5  3  6  7       3\n//         1  3 [-1  -3  5] 3  6  7       5\n//         1  3  -1 [-3  5  3] 6  7       5\n//         1  3  -1  -3 [5  3  6] 7       6\n//         1  3  -1  -3  5 [3  6  7]      7\n\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        Deque<Integer> stack = new LinkedList<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (stack.isEmpty() || nums[stack.peek()] <= nums[i]) {\n                stack.push(i);\n            } else {\n                while (!stack.isEmpty() && nums[stack.peek()] > nums[i]) {\n                    int pop = stack.pop();\n                    \n                }\n            }\n        }\n\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467214427","body":"```java\n\\\\ 思路，统计出入度\n\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] in = new int[n + 1];\n        int[] out = new int[n + 1];\n        for (int[] t: trust) {\n            in[t[1]]++;\n            out[t[0]]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            if (in[i] == n - 1 && out[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469207463","body":"```java\n// 思路：无向图的二分图标记，mark[] 分为0，1，-1，dfs遍历时 v->w ，mark[w] 为0正常dfs，不为0时判断与v的mark是否相反\n\nclass Solution {\n    int[] marked;\n    int n;\n    List<Integer>[] adj;\n    boolean part = true;\n\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        this.n = n;\n        this.marked = new int[n];\n        this.adj = new List[n];\n        for (int i = 0; i < n; i++) {\n            adj[i] = new ArrayList<>();\n        }\n        for (int[] edge : dislikes) {\n            // u -> v\n            int u = edge[0] - 1, v = edge[1] - 1;\n            adj[u].add(v);\n            adj[v].add(u);\n        }\n        for (int v = 0; v < n; v++) {\n            if (marked[v] == 0 && part) {\n                dfs(v, 1);\n            }\n        }\n        return part;\n    }\n\n    // v -> w\n    private void dfs(int v, int mark) {\n        marked[v] = mark;\n        for (int w : adj[v]) {\n            if (!part) {\n                return;\n            }\n\n            if (marked[w] == 0) {\n                dfs(w, -mark);\n            } else if (marked[w] + mark != 0){\n                part = false;\n                return;\n            }\n        }\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473307718","body":"```java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int i = 0, j = 0;\n        for (char ch: moves.toCharArray()) {\n            if (ch == 'U') {\n                i++;\n            } else if (ch == 'D') {\n                i--;\n            } else if (ch == 'L') {\n                j--;\n            } else {\n                j++;\n            }\n        }\n        return i==0 && j==0;\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1479944752","body":"```java\n/* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); */\n\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        return binary(1, n);\n    }\n\n    public int binary(int i, int j) {\n        if (j == i) {\n            return i;\n        }\n        int m = i + (j - i) / 2;\n        if (isBadVersion(m)) {\n            return binary(i, m);\n        } else {\n            return binary(m + 1, j);\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489566377","body":"```java\nclass Solution {\n     //   c b a e b a b a c d\n    //   i\n    //         j\n    //[i,j)\n    public List<Integer> findAnagrams(String s, String p) {\n        int[] cnt = new int[26];\n        for (char ch: p.toCharArray()) {\n            cnt[ch - 'a']++;\n        }\n\n        int i = 0, j = 0, diff = p.length();\n        char[] chars = s.toCharArray();\n        List<Integer> ret = new ArrayList<>();\n        while (j < chars.length) {\n            // j\n            cnt[chars[j] - 'a']--;\n\n            if (cnt[chars[j] - 'a'] >= 0) {\n                diff--;\n            } else {\n                diff++;\n                while (cnt[chars[j] - 'a'] < 0) {\n                    // i\n                    if (cnt[chars[i] - 'a'] < 0) {\n                        diff--;\n                    } else {\n                        diff++;\n                    }\n                    cnt[chars[i] - 'a']++;\n                    i++;\n                }\n            }\n\n\n            if (diff == 0) {\n                ret.add(i);\n            }\n            j++;\n        }\n        return ret;\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497014229","body":"```java\n\nclass Solution {\n    static int[] dx = {-1, 0, 1, 0};\n    static int[] dy = {0, 1, 0, -1};\n    int n;\n    int[][] grid;\n\n    public int maxDistance(int[][] grid) {\n        this.n = grid.length;\n        this.grid = grid;\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 0) {\n                    ans = Math.max(ans, findNearestLand(i, j));\n                }\n            }\n        }\n        return ans;\n    }\n\n    public int findNearestLand(int x, int y) {\n        boolean[][] vis = new boolean[n][n];\n        Queue<int[]> queue = new LinkedList<int[]>();\n        queue.offer(new int[]{x, y, 0});\n        vis[x][y] = true;\n        while (!queue.isEmpty()) {\n            int[] f = queue.poll();\n            for (int i = 0; i < 4; ++i) {\n                int nx = f[0] + dx[i], ny = f[1] + dy[i];\n                if (!(nx >= 0 && nx < n && ny >= 0 && ny < n)) {\n                    continue;\n                }\n                if (!vis[nx][ny]) {\n                    queue.offer(new int[]{nx, ny, f[2] + 1});\n                    vis[nx][ny] = true;\n                    if (grid[nx][ny] == 1) {\n                        return f[2] + 1;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1504458755","body":"```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m + 1][n + 1];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (i == 1 && j == 1) {\n                    dp[i][j] = 1;\n                } else {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1512354068","body":"```java\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int m = coins.length, n = amount;\n        int[][] dp = new int[m + 1][n + 1];\n        for (int i = 1; i <= m; i++) {\n            dp[i][0] = 1;\n            for (int j = 1; j <= n; j++) {\n                dp[i][j] += dp[i - 1][j];\n                if (j >= coins[i - 1]) {\n                    dp[i][j] += dp[i][j - coins[i - 1]];\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1518951327","body":"```java\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists.length == 0) {\n            return null;\n        }\n\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((o1, o2) -> o1.val - o2.val);\n        \n        for (ListNode head: lists) {\n            if (head != null) {\n                pq.add(head);\n            }\n            \n        }\n\n        ListNode pre = new ListNode();\n        ListNode p = pre;\n\n        while (!pq.isEmpty()) {\n            ListNode poll = pq.poll();\n            if (poll.next != null) {\n                pq.add(poll.next);\n            }\n            p.next = poll;\n            p = p.next;\n            poll.next = null;\n        }\n\n        return pre.next;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhumengcheng":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429106157","body":"```javascript\r\n思路,末位数相加,超10进1,直接添加到数组的首位,如果是10则添加0,如果大于10取余数,\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  let i = num.length - 1;\r\n  let ys = 0;\r\n  let res = [];\r\n  while (i >= 0 || k > 0) {\r\n    let x = i >= 0 ? num[i] : 0;\r\n    let y = k % 10;\r\n    k = Math.floor(k / 10);\r\n    ys = x + y;\r\n    if (ys >= 10) {\r\n      if (ys == 10) {\r\n        ys = 0;\r\n      } else {\r\n        ys = ys % 10;\r\n      }\r\n      k++;\r\n    }\r\n    i--;\r\n    res.unshift(ys);\r\n  }\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n- 复杂度\r\n\r\n1. 时间复杂度：O(max⁡(n,log⁡k))，其中 nnn 为数组的长度。\r\n2. 空间复杂度：O(1)\r\n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431409149","body":"```javascript\r\n解题思路: 第一层循环判断出c字符串的位置,第二层循环判断当前字符距离目标字符的距离Math.abs(i - j)判断距离\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n  let len = s.length;\r\n  const res = new Array(len).fill(len);\r\n  for (let i = 0; i < len; i++) {\r\n    if (s.substring(i, i + 1) === c) {\r\n      for (let j = 0; j < len; j++) {\r\n        res[j] = Math.min(Math.abs(i - j), res[j]);\r\n      }\r\n    }\r\n  }\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n- 复杂度\r\n\r\n时间复杂度 O(n^2)\r\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433063870","body":"```javascript\r\n实现思路: 使用数组完成\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = new Array();\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.stack.length < this.maxSize) {\r\n    this.stack.push(x);\r\n  } else {\r\n    return;\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  return this.stack.length > 0 ? this.stack.pop() : -1;\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  let len = this.stack.length < k ? this.stack.length : k;\r\n  for (let i = 0; i < len; i++) {\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n\r\n```\r\n复杂度分析\r\n时间复杂度：O(1)\r\n空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434406149","body":"```javascript\r\n思路: 记录数字表示重复次数,记录括号内的字符为重复自负,次数和字符都单独存起来,如果没有数字和字符直接累加\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    // 重复次数\r\n    let repetStack=[];\r\n    // 重复字符串\r\n    let resStack=[];\r\n    // 拼接的字符串\r\n    let resStr = \"\";\r\n    // 当前字符的重复次数\r\n    let repet = 0;\r\n\r\n    for(let i=0;i<s.length;i++){\r\n        let cur = s.charAt(i);\r\n        if(cur == '['){\r\n            repetStack.push(repet);\r\n            resStack.push(resStr);\r\n            // 重置\r\n            repet = 0;\r\n            resStr = \"\";\r\n        }else if(cur == ']'){\r\n            let count = repetStack.pop();\r\n            // 根据重复次数生成重复字符串，给temp赋值，并和累积的字符串resStr拼接\r\n            let temp = \"\";\r\n            for(let i = 0;i<count;i++){\r\n                temp += resStr;\r\n            }\r\n            // 字符串拼接\r\n            resStr = resStack.pop() + temp;\r\n        }else if(cur>='0' && cur<='9'){\r\n            repet = repet*10 + (cur-'0');\r\n        }else{\r\n            resStr += cur;\r\n        }\r\n    }\r\n    return resStr;\r\n \r\n};\r\n```\r\n\r\n复杂度\r\n时间复杂度：O(s)\r\n空间复杂度：O(s)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443119508","body":"```javascript\r\n 给每个节点记录下来,如果相同则有环\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    let map = new Map();\r\n    while (head !== null) {\r\n        if (map.has(head)) {\r\n            return head;\r\n        }\r\n        map.set(head);\r\n        head = head.next;\r\n    }\r\n    return null;\r\n \r\n};\r\n\r\n```\r\n复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445139754","body":"```javascript\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n    this.map = new Map();\r\n    this.capacity = capacity;\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    if(this.map.has(key)){\r\n        let value = this.map.get(key)\r\n        this.map.delete(key)\r\n        this.map.set(key, value)\r\n        return value\r\n    }\r\n    return -1\r\n \r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n if (this.map.has(key)) { \r\n      this.map.delete(key) \r\n    }\r\n    this.map.set(key, value)\r\n    if(this.map.size > this.capacity){\r\n        this.map.delete(this.map.keys().next().value)\r\n    }\r\n \r\n};\r\n```\r\n复杂度分析\r\n时间复杂度：O(1)\r\n空间复杂度：O(N)\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450064978","body":"```javascript\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar findBottomLeftValue = function(root) {\r\n\r\n    let curHeight = 0;\r\n    let curVal = 0;\r\n\r\n    const dfs = (root, height) => {\r\n        if (!root) {\r\n            return;\r\n        }\r\n        height++;\r\n        dfs(root.left, height);\r\n        dfs(root.right, height);\r\n        if (height > curHeight) {\r\n            curHeight = height;\r\n            curVal = root.val;\r\n        }\r\n    }\r\n\r\n    dfs(root, 0);\r\n    return curVal;\r\n\r\n};\r\n```\r\n\r\n- 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454706146","body":"```javascript\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number[]}\r\n */\r\nvar twoSum = function(nums, target) {\r\n    let map = new Map();\r\n    for(let i = 0, len = nums.length; i < len; i++){\r\n        if(map.has(target - nums[i])){\r\n            return [map.get(target - nums[i]), i];\r\n        }else{\r\n            map.set(nums[i], i);\r\n        }\r\n    }\r\n    return [];\r\n};\r\n```\r\n复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455095673","body":"```javascript\r\nmap存值, 排序后取前k值\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar topKFrequent = function(nums, k) {\r\n    const countMap = new Map();\r\n    for (let num of nums) {\r\n        countMap.set(num, (countMap.get(num) || 0) + 1);\r\n    }\r\n    // tS没有最小堆的数据结构，所以直接对整个数组进行排序，取前k个元素\r\n    return [...countMap.entries()]\r\n        .sort((a, b) => b[1] - a[1])\r\n        .slice(0, k)\r\n        .map(i => i[0]);\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456389399","body":"```javascript\r\n没看懂题,看了答案很久才弄明白\r\n/**\r\n * @param {number[][]} points\r\n * @return {number}\r\n */\r\nvar numberOfBoomerangs = function(points) {\r\n let ans = 0;\r\n    for (const p of points) {\r\n        const cnt = new Map();\r\n        for (const q of points) {\r\n            const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\r\n            cnt.set(dis, (cnt.get(dis) || 0) + 1);\r\n        }\r\n        for (const [_, m] of cnt.entries()) {\r\n            ans += m * (m - 1);\r\n        }\r\n    }\r\n    return ans;\r\n};\r\n```\r\n复杂度分析\r\n\r\n时间复杂度：O(n2)\r\n\r\n空间复杂度：O(n)。\r\n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457961287","body":"```javascript\r\n双指针\r\n/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar lengthOfLongestSubstring = function (s) {\r\n  if (s.length <= 1) {\r\n    return s.length;\r\n  }\r\n  let left = 0;\r\n  let right = 1;\r\n  let max = 0;\r\n  let temp;\r\n  while (right < s.length) {\r\n    temp = s.slice(left, right);\r\n    if (temp.indexOf(s.charAt(right)) > -1) {\r\n      left++;\r\n      continue;\r\n    } else {\r\n      right++;\r\n    }\r\n    if (right - left > max) {\r\n      max = right - left;\r\n    }\r\n  }\r\n  return max;\r\n};\r\n\r\n```\r\n复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460085469","body":"```javascript\r\n这个题的写法在答案基础上写的,后续根据答案反推,就用了这个,主要还是没想到更简单的方法\r\n// 1. words每个单词的长度相同，统计这个长度，以及单词个数，可得我们遍历s时的窗口\r\n// 2. 枚举窗口，按单词长度切割，切割后与words的哈希计数相同，则算一个\r\nvar findSubstring = function (s, words) {\r\n  const res = [];\r\n\r\n  const m = words.length, // 数组的长度\r\n    n = words[0].length, //表示循环字符的长度\r\n    ls = s.length; // 需要循环的总字符的长度\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    // 如果需要拼接的字符和长度超过了剩余需要查找的字符的长度,则停止查找, 全部的字符长度根据数组的总字符的长度去滑动\r\n    if (i + m * n > ls) {\r\n      break;\r\n    }\r\n    // 需要找到对应的字符信息\r\n    const differ = new Map();\r\n    for (let j = 0; j < m; j++) {\r\n      // 截取需要判断的字符的长度 是否符合数组中的字符,如果符合则保存到Map中\r\n      const word = s.substring(i + j * n, i + (j + 1) * n);\r\n      differ.set(word, (differ.get(word) || 0) + 1);\r\n    }\r\n\r\n    for (const word of words) {\r\n      // 查找存在于数组中的字符,如果存在Map中删除\r\n      differ.set(word, (differ.get(word) || 0) - 1);\r\n      if (differ.get(word) === 0) {\r\n        differ.delete(word);\r\n      }\r\n    }\r\n    // 每次滑动窗口后,需要遍历一遍总字符串的长度\r\n    for (let start = i; start < ls - m * n + 1; start += n) {\r\n      if (start !== i) {\r\n        // 截取每一段数组长度的字符,判断是否存在于differ符合Map中并新增\r\n        let word = s.substring(start + (m - 1) * n, start + m * n);\r\n        differ.set(word, (differ.get(word) || 0) + 1);\r\n        if (differ.get(word) === 0) {\r\n          differ.delete(word);\r\n        }\r\n        // 如果当前截取的字符串匹配后,更新到最新的Map值中并相减\r\n        word = s.substring(start - n, start);\r\n        differ.set(word, (differ.get(word) || 0) - 1);\r\n        if (differ.get(word) === 0) {\r\n          differ.delete(word);\r\n        }\r\n      }\r\n      // 当前Map不存在值后, 当前起始位置即为拼接字符的起始位置\r\n      if (differ.size === 0) {\r\n        res.push(start);\r\n      }\r\n    }\r\n  }\r\n  return res;\r\n};\r\n\r\nlet s = \"abcdefabcdghcdabigkabcdabcdecdaacd\";\r\nlet words = [\"ab\", \"cd\"];\r\n\r\nconst lenIndex = findSubstring(s, words);\r\nconsole.log(lenIndex);\r\n\r\n```\r\n复杂度分析\r\n时间复杂度：O（mnk）\r\n空间复杂度：O（m）","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463786148","body":"```javascript\r\n快慢指针 快指针是慢指针的2倍 快指针到达结尾,慢指针到中间位置\r\nvar middleNode = function(head) {\r\n    slow = fast = head;\r\n    while (fast && fast.next) {\r\n        slow = slow.next;\r\n        fast = fast.next.next;\r\n    }\r\n    return slow;\r\n};\r\n\r\n```\r\n复杂度分析\r\n时间复杂度：O（n）\r\n空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464803394","body":"```javascript\r\nvar removeDuplicates = function (nums) {\r\n  // 如果长度为0, 则返回0\r\n  const n = nums.length;\r\n  if (n === 0) {\r\n    return 0;\r\n  }\r\n  //   定义快慢指针\r\n  let fast = 1,\r\n    slow = 1;\r\n  // 循环次数快指针小于数组长度, 快指针每移动一次如果和慢指针值不同,则更换慢指针值,下标加一,快指针继续移动,如果不同继续替换\r\n  while (fast < n) {\r\n    if (nums[fast] !== nums[fast - 1]) {\r\n      nums[slow] = nums[fast];\r\n      ++slow;\r\n    }\r\n\r\n    ++fast;\r\n  }\r\n  return slow;\r\n};\r\n\r\nlet nums = [\r\n  0, 1, 1, 2, 2, 2, 2, 3, 3, 4, 5, 5, 5, 5, 5, 5, 6, 7, 8, 8, 8, 8, 8, 8, 9, 9,\r\n  9, 10,\r\n];\r\nconst arrLen = removeDuplicates(nums);\r\nconsole.log(arrLen);\r\n\r\n```\r\n复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465212238","body":"```javascript\r\n二分\r\nvar searchInsert = function (nums, target) {\r\n  let l = 0,\r\n    r = nums.length - 1,\r\n    ans = nums.length;\r\n\r\n  while (l <= r) {\r\n    const mid = l + Math.floor((r - l) >> 1);\r\n\r\n    if (target > nums[mid]) {\r\n      l = mid + 1;\r\n    } else {\r\n      ans = mid;\r\n      r = mid - 1;\r\n    }\r\n  }\r\n\r\n  return ans;\r\n};\r\n```\r\n复杂度\r\n\r\n时间复杂度: O(logn)\r\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466252631","body":"```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar maxSlidingWindow = function(nums, k) {\r\n const queue = [],\r\n          result = []\r\n    for (let i = 0; i < nums.length; i++) {\r\n        // 如果队列不为空，且要入队的元素大于队尾元素, 队尾元素出队\r\n        while (queue.length > 0 && nums[i] > nums[queue[queue.length - 1]]) {\r\n            queue.pop()\r\n        }\r\n        queue.push(i)\r\n\r\n        // j 是把 i 为作为滑动窗口最后一个值时滑动窗口第一个值的索引\r\n        const j = i - k + 1\r\n        // j >= 0 说明滑动窗口已构建完毕\r\n        if (j >= 0) {\r\n            // 当队首元素不属于当前滑动窗口时出队\r\n            if (queue[0] < j) queue.shift()\r\n            // 把队首元素添加到结果数组中\r\n            result.push(nums[queue[0]])\r\n        }\r\n    }\r\n    return result\r\n \r\n};\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476077419","body":"```javascript\r\n/**\r\n * @param {string} a\r\n * @param {string} b\r\n * @return {number}\r\n */\r\nvar minCharacters = function(a, b) {\r\n    let da = new Array(26).fill(0);\r\n    let db = new Array(26).fill(0);\r\n    for(let i in a) {\r\n        da[a.charCodeAt(i) - 97] ++;\r\n    }\r\n    for(let i in b) {\r\n        db[b.charCodeAt(i) - 97] ++;\r\n    }\r\n    let an = a.length, bn = b.length, asum = 0, bsum = 0, res = Number.MAX_SAFE_INTEGER;\r\n    for(let i = 0 ; i < 25 ; i ++) {\r\n        // 前缀和计算\r\n        asum += da[i];\r\n        bsum += db[i];\r\n        // 找最小值\r\n        res = Math.min(res, an+bn-da[i]-db[i], an-asum+bsum, bn-bsum+asum);\r\n    }\r\n    // z的特殊处理\r\n    return Math.min(res, an+bn-da[25]-db[25]);\r\n};\r\n \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477237074","body":"```javascript\r\nvar sortArray = function(nums) {\r\n  const n = nums.length;\r\n  for (let i = 0; i < n - 1; ++i) {\r\n    let minIndex = i;\r\n    for (let j = i + 1; j < n; ++j) {\r\n      if (nums[minIndex] > nums[j]) {\r\n        minIndex = j;\r\n      }\r\n    }\r\n    [nums[i], nums[minIndex]] = [nums[minIndex], nums[i]];\r\n  }\r\n  return nums;\r\n};\r\n \r\n```\r\n复杂度\r\n时间复杂度：O(n²)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479097687","body":"```javascript\r\n/**\r\n * @param {number} x\r\n * @return {number}\r\n */\r\nvar mySqrt = function(x) {\r\n    if (x==0 || x ==1) {\r\n        return x;\r\n    }\r\n    for (let i = 0 ; i <= x; i++){\r\n        if ( i * i <= x && (i+1) * (i+1) > x ){\r\n            return i;\r\n        }\r\n    }\r\n};\r\n```\r\n复杂度分析\r\n时间复杂度：O(logn)\r\n空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482708873","body":"```javascript\r\n看懂了题目,但没思路, 答案参考题解\r\n/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar reversePairs = function(nums) {\r\n    if (nums.length === 0) {\r\n        return 0;\r\n    }\r\n    return reversePairsRecursive(nums, 0, nums.length - 1);\r\n};\r\n\r\nconst reversePairsRecursive = (nums, left, right) => {\r\n    if (left === right) {\r\n        return 0;\r\n    } else {\r\n        const mid = Math.floor((left + right) / 2);\r\n        const n1 = reversePairsRecursive(nums, left, mid);\r\n        const n2 = reversePairsRecursive(nums, mid + 1, right);\r\n        let ret = n1 + n2;\r\n\r\n        let i = left;\r\n        let j = mid + 1;\r\n        while (i <= mid) {\r\n            while (j <= right && nums[i] > 2 * nums[j]) {\r\n                j++;\r\n            }\r\n            ret += j - mid - 1;\r\n            i++;\r\n        }\r\n\r\n        const sorted = new Array(right - left + 1);\r\n        let p1 = left, p2 = mid + 1;\r\n        let p = 0;\r\n        while (p1 <= mid || p2 <= right) {\r\n            if (p1 > mid) {\r\n                sorted[p++] = nums[p2++];\r\n            } else if (p2 > right) {\r\n                sorted[p++] = nums[p1++];\r\n            } else {\r\n                if (nums[p1] < nums[p2]) {\r\n                    sorted[p++] = nums[p1++];\r\n                } else {\r\n                    sorted[p++] = nums[p2++];\r\n                }\r\n            }\r\n        }\r\n        for (let k = 0; k < sorted.length; k++) {\r\n            nums[left + k] = sorted[k];\r\n        }\r\n        return ret;\r\n    }\r\n\r\n};\r\n\r\n```\r\n\r\n复杂度分析\r\n\r\n时间复杂度：O(Nlog⁡N)\r\n\r\n空间复杂度：O(N)\r\n ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kofzhang":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429132721","body":"### 思路\r\n1.将列表转成数值\r\n2.加上K\r\n3.转成列表\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        n = 0\r\n        for i in num:\r\n            n=n*10+i\r\n        s = n+k\r\n        res = []\r\n        for i in str(s):\r\n            res.append(int(i))\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430562184","body":"### 思路\r\n1.先找到所有字符位置，添加到一个列表里\r\n2.双指针，一个指向字符位置列表，一个指向原列表\r\n3.如果位置列表存在下一个位置，并且下一个位置到当前字符位置的绝对值小于当前位置到当前字符位置的绝对值，字符位置列表索引+1，并计算位置。否则以当前字符位置直接计算距离。\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        positions = [index for index,i in enumerate(s) if i==c]\r\n        res = []\r\n        p = 0\r\n        for index,i in enumerate(s):\r\n            if p<len(positions)-1 and abs(positions[p+1]-index)<abs(positions[p]-index):\r\n                p += 1                \r\n            res.append(abs(positions[p]-index))\r\n        return res\r\n                \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432719597","body":"### 思路\r\n两个列表分别记录数据和增量。\r\n当increment的时候，只记录位置和增量，pop时增量向下累加\r\n### 复杂度\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.data = [0]*maxSize\r\n        self.add = [0]*maxSize\r\n        self.cursor = -1\r\n\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cursor<self.maxSize-1:\r\n            self.cursor+=1\r\n            self.data[self.cursor]=x\r\n            self.add[self.cursor]=0\r\n            \r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.cursor==-1:\r\n            return -1\r\n        r = self.data[self.cursor]+self.add[self.cursor]\r\n        \r\n        if self.cursor>=1:\r\n            self.add[self.cursor-1]+=self.add[self.cursor]        \r\n        self.cursor-=1\r\n        return r\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.cursor<k:\r\n            k = self.cursor+1\r\n        self.add[k-1]+=val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434176805","body":"### 思路\r\n从右向左，有点烦\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        l = len(s) - 1\r\n        stack = []\r\n        while l >= 0:\r\n            t = s[l]\r\n            if t.isdigit():\r\n                numstack = []\r\n                while l >= 0 and s[l].isdigit():\r\n                    numstack.append(s[l])\r\n                    l -= 1\r\n\r\n                temp = []\r\n                stack.pop()\r\n                while (p := stack.pop()) != ']':\r\n                    temp.append(p)\r\n                c = ''.join(temp) * int(\"\".join(numstack[::-1]))\r\n                stack.append(c)\r\n            else:\r\n                stack.append(t)\r\n                l -= 1\r\n        return ''.join(stack[::-1])\r\n```\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435469313","body":"### 思路\r\n两个栈，instack和outstack\r\n每次入队列的时候放入instack。\r\n出队列的时候从outstack出。如果outstack没有数据了就把所有的instack的数据倒到outstack里。\r\n### 复杂度\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.instack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.outstack:\r\n            self.in2out()\r\n        return self.outstack.pop()\r\n\r\n    def in2out(self) -> None:        \r\n            while self.instack:\r\n                self.outstack.append(self.instack.pop())\r\n\r\n    def peek(self) -> int:\r\n        if not self.outstack:\r\n            self.in2out()\r\n        return self.outstack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        if self.instack or self.outstack:\r\n            return False\r\n        return True\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435939146","body":"### 思路\r\n单调栈，记录当前块的最大值。\r\n如果栈空，或者当前值大于最大值，就把它作为单独一块，放入栈。\r\n否则，合块。记录最大值，把栈中比当前值大的值全弹出。放入记录的最大值。\r\n结果是栈的长度。\r\n### 复杂度\r\nO(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for i in arr:\r\n            if not stack or stack[-1]<=i:\r\n                stack.append(i)\r\n            else:\r\n                m = stack[-1]\r\n                while stack and i<stack[-1]:\r\n                    stack.pop()\r\n                stack.append(m)\r\n        return len(stack)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436194556","body":"### 思路\r\n找出链表长度\r\n取一下模，然后向后走\r\n最后记得断开链表\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        dummy = head\r\n        l = 1\r\n        while head.next:\r\n            head = head.next\r\n            l += 1\r\n        \r\n        k = (l - k % l)%l\r\n        if k == 0 :\r\n            return dummy\r\n        head.next = dummy\r\n        head = dummy\r\n        while k > 1:   \r\n            head = head.next\r\n            k -= 1\r\n        res = head.next\r\n        head.next = None\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438008324","body":"### 思路\r\n模拟\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        \r\n        dummy = ListNode(-1,head)\r\n        left = dummy\r\n        cur = head\r\n        right = head.next\r\n        while cur and cur.next:\r\n            left.next = right\r\n            cur.next = right.next\r\n            right.next = cur\r\n            \r\n            left = cur\r\n            cur = cur.next\r\n            if cur and cur.next:\r\n                right = cur.next\r\n        return dummy.next\r\n            \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439278722","body":"### 思路\r\n快慢指针\r\n### 复杂度\r\n时间复杂度：O(nlogn)  //分治思想\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return head\r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n        slow = head\r\n        fast = head\r\n        slow_left = head\r\n        while fast and fast.next:\r\n            slow_left = slow\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n\r\n        right = slow.next\r\n        slow.next = None\r\n        slow_left.next=None\r\n        left = head\r\n        root = TreeNode(slow.val)\r\n        root.left = self.sortedListToBST(left)\r\n        root.right = self.sortedListToBST(right)\r\n        return root\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441305049","body":"### 思路\r\n这个题做过，印象很深刻，双指针，一个走A，一个走B\r\nA走完，走B。B走完，走A。\r\n两个指针同时走完了AB，那么没有交点。\r\n如果没走完相等了，就有交点。\r\n### 复杂度：\r\n时间复杂度：O(m+n)\r\n空间复杂度：O(1)\r\n### 代码：\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        curA,curB = headA,headB        \r\n        while curA != curB:\r\n            curA = curA.next if curA else headB\r\n            curB = curB.next if curB else headA\r\n        return curA\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442638333","body":"### 思路\r\n快慢指针，快指针两步，慢指针一步。\r\n如果走完不相遇，就返回None\r\n如果相遇，slow从头再走，都是一步一步走，直到相遇，即为所求。\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return None\r\n        slow = head\r\n        fast = head\r\n        while fast and fast.next:\r\n            slow=slow.next\r\n            fast=fast.next.next\r\n            if slow==fast:\r\n                break\r\n        if not fast or not fast.next:\r\n            return None\r\n        slow = head\r\n        while slow!=fast:\r\n            slow = slow.next\r\n            fast = fast.next            \r\n        return slow\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1444968626","body":"### 思路\r\nOrderedDict\r\n### 复杂度\r\n时间复杂度：O(1)\r\n空间复杂度：O(N)\r\n### 代码\r\n```python\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.cache = OrderedDict()\r\n        self.size = capacity\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        if key  not in self.cache:\r\n            return -1\r\n        value = self.cache.pop(key)\r\n        self.cache[key]=value\r\n        return value\r\n\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.cache and len(self.cache)>=self.size:\r\n            self.cache.popitem(last=False)\r\n        if key in self.cache:\r\n            self.cache.pop(key)\r\n        self.cache[key]=value\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445789160","body":"### 思路\r\n递归计算左右节点深度\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(h)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        left = self.maxDepth(root.left) \r\n        right = self.maxDepth(root.right)\r\n        return max(left,right)+1\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445795243","body":"### 思路\r\n递归比较所有节点\r\n如果两个节点都是None，返回True。如果一个是None，返回False。\r\n如果两个节点值相等，则分别比较左右节点。\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(h)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        if not p or not q:\r\n            return False\r\n        if p.val==q.val:\r\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\r\n        else:\r\n            return False\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447305691","body":"### 思路\r\n深度优先搜索\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(h)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        \r\n        def calcsub(node: Optional[TreeNode],current: int) -> int:            \r\n            if not node:\r\n                return 0\r\n            s = current*10+node.val\r\n            if not node.left and not node.right:                \r\n                return s\r\n            return calcsub(node.left,s)+calcsub(node.right,s)        \r\n        \r\n        return calcsub(root,0)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450137588","body":"### 思路\r\n深度优先搜索\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(h)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        def findBottom(node,curdep):            \r\n            c = curdep+1,node.val\r\n            l = findBottom(node.left,c[0]) if node.left else (-1,-1)\r\n            r = findBottom(node.right,c[0]) if node.right else (-1,-1)\r\n            return max([c,l,r],key=lambda x:x[0])\r\n        \r\n        return findBottom(root,0)[1]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451241725","body":"### 思路\r\n使用队列实现\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nfrom collections import deque\r\n\r\nclass Codec:\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if not root:\r\n            return \"\"\r\n        res = []\r\n        q = deque()\r\n        \r\n        q.append(root)\r\n        while q:\r\n            node = q.popleft()\r\n            if not node:\r\n                res.append(None)\r\n            else:\r\n                res.append(node.val)\r\n                q.append(node.left)\r\n                q.append(node.right)\r\n        return \",\".join(map(str,res))\r\n            \r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if not data:\r\n            return None\r\n        q = deque()\r\n        datalist = list(map(eval,data.split(',')))\r\n        length = len(datalist)\r\n        root = TreeNode(datalist[0])\r\n        q.append(root)\r\n        cur = 1\r\n        while q:\r\n            \r\n            node = q.popleft()\r\n            if cur<length:\r\n                if datalist[cur]!=None:\r\n                    l = TreeNode(datalist[cur])\r\n                    node.left = l\r\n                    q.append(l)\r\n                else:\r\n                    node.left = None\r\n                cur += 1\r\n            else:\r\n                break\r\n            if cur<length:\r\n                if datalist[cur]!=None:\r\n                    r = TreeNode(datalist[cur])\r\n                    node.right = r\r\n                    q.append(r)\r\n                else:\r\n                    node.right = None\r\n                cur += 1\r\n            else:\r\n                break\r\n        return root\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1452818531","body":"### 思路\r\n先用一个defaultdict按列存储，存储的时候要记录深度值，后期排序需要\r\n然后全部存进去以后开始排序\r\n### 复杂度\r\n时间复杂度：O(nlogn)    有排序\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        d = defaultdict(list)\r\n        def dfs(node,row,col):\r\n            if not node:\r\n                return \r\n            d[col].append((row,node.val))\r\n            dfs(node.left,row+1,col-1)\r\n            dfs(node.right,row+1,col+1)\r\n            return\r\n        \r\n        dfs(root,0,0)\r\n\r\n        res = [x[1] for x in sorted(list(d.items()), key=lambda x: (x[0]))]\r\n        ans = []\r\n        for l in res:\r\n            ans.append([x[1] for x in sorted(l, key=lambda x:(x[0], x[1]))])\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454676128","body":"### 思路\r\n用字典节省时间\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        s = {}\r\n        for index,i in enumerate(nums):\r\n            r = target-i\r\n            if r in s:\r\n                return [s[r],index]\r\n            else:\r\n                s[i]=index\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1454936888","body":"### 思路\r\n用counter来计数，用most_common来返回结果，或者用堆\r\n### 复杂度\r\n时间复杂度：O(nlogn)   堆化logn\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        c = Counter(nums)\r\n        return heapq.nlargest(k,c,key=lambda x:(c[x],x))\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455339587","body":"### 思路\r\n用字典计算每一个点到其他点的距离数量\r\n然后以该点为中心点，距离为d的点的数量为n，那么回旋镖数量为n*(n-1)\r\n### 复杂度\r\n时间复杂度：O(n^2)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        l = len(points)\r\n\r\n        res = 0\r\n        for i in range(0, l):\r\n            times = defaultdict(lambda :0)\r\n            for j in range(0, l):\r\n                if i == j:\r\n                    continue\r\n                dis = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\r\n                times[dis] += 1\r\n            for t in times.values():\r\n                res += t * (t-1)\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457521629","body":"### 思路\r\n双指针，用一个set保存当前窗口的元素。\r\n右指针遇到重复元素，左指针开始右移，同时set移除元素\r\n移除完毕，右指针元素进入set，并计算长度。储存最大值。\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        if not s:\r\n            return 0\r\n        c = set()\r\n        l,r,m=0,0,0\r\n        while r<len(s):\r\n            if s[r] in c:\r\n                while s[l]!=s[r]:\r\n                    c.remove(s[l])\r\n                    l += 1\r\n                c.remove(s[l])\r\n                l += 1            \r\n            c.add(s[r])\r\n            m = max(r-l+1,m)\r\n            r += 1            \r\n        return m\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459446397","body":"### 思路\r\n用Counter存储目标和当前窗口统计\r\n如果当前的Counter和目标Counter一致，就加到结果里\r\n如果不一致，光标往后面挪\r\n### 复杂度\r\n时间复杂度：O(n*m)  n为字符串长度 m为字符串数组长度\r\n空间复杂度：O(m) m为字符串数组长度\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        words_length = len(words)\r\n        words_counter = Counter(words)\r\n        lword = len(words[0])\r\n        cursor = 0\r\n        res = []\r\n        while cursor<=len(s)-lword*words_length:\r\n            cur = Counter()\r\n            flag = True\r\n            for i in range(words_length):\r\n                t = s[cursor+i*lword:cursor+i*lword+lword]\r\n                if t not in words_counter or cur[t]>=words_counter[t]:                    \r\n                    flag = False\r\n                    break\r\n                cur[t]+=1\r\n            if flag:\r\n                res.append(cursor)\r\n            cursor += 1\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461098033","body":"### 思路\r\n先求出需要的余数\r\n使用字典记录当前前n项的余数\r\n遍历列表，计算前缀和，放到字典里。\r\n计算当前余数和需求余数之间的差（多了多少余数）\r\n在字典里找多了的余数对应位置。\r\n找到了就更新最小值数量。\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(k)  # 余数\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def minSubarray(self, nums: List[int], p: int) -> int:\r\n        require = sum(nums)%p\r\n        if require ==0:\r\n            return 0\r\n        recentlypos = {0:-1}  # 这里要有数据，否则正好的时候过不去\r\n        cur_reminder = 0\r\n        m = len(nums)\r\n        for index,n in enumerate(nums):\r\n            cur_reminder = (cur_reminder+n)%p\r\n            recentlypos[cur_reminder]=index\r\n            if (cur_reminder-require)%p in recentlypos:\r\n                m = min(m,index-recentlypos[(cur_reminder-require)%p])\r\n        return m if m!=len(nums) else -1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463045509","body":"### 思路\r\n快慢指针\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        slow=fast=head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        return slow\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1465433722","body":"### 思路\r\n快慢指针，遇到重复的快指针往前走慢指针不走\r\n遇到不一样的往前覆盖\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        slow = fast = 0\r\n        while fast<len(nums):\r\n            if slow!=fast and nums[slow]!=nums[fast]:\r\n                slow+=1\r\n                nums[slow]=nums[fast]\r\n            fast += 1\r\n        return slow+1\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465450418","body":"### 思路\r\n二分法\r\n### 复杂度\r\n时间复杂度：O(logn)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        left = 0\r\n        right =len(nums)-1\r\n        while left<=right:          \r\n            if target==nums[right+left>>1]:\r\n                return right+left>>1\r\n            elif target>nums[right+left>>1]:\r\n                left = (right+left>>1)+1\r\n            else:\r\n                right = (right+left>>1)-1\r\n        return left\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465498099","body":"### 思路\r\n双端队列，当前值大于队列前面值，把前面的弹出，把当前值放进去。\r\n当队首失效，也就是失效值=队首值，队首出队。\r\n当index大于k的时候，队首为最大值，把队首扔进res。\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(k)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        cur = 0\r\n        q  = deque()\r\n        res = []        \r\n        while cur<len(nums):\r\n            while q and  nums[cur]>q[-1]:\r\n                q.pop()\r\n            q.append(nums[cur])\r\n            if cur>=k and nums[cur-k]==q[0]:\r\n                q.popleft()\r\n            if cur>=k-1:    \r\n                res.append(q[0])\r\n            cur += 1\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467228098","body":"### 思路\r\n用一个列表存放每个人被信任的次数\r\n如果这个人信任别人，把被信任次数变为-1\r\n最后找到最大的被信任次数。如果等于n-1，返回这个人的位置\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\r\n        if not trust and n==1:\r\n            return 1\r\n        faguan = [0]*(n+1)\r\n        for a,b in trust:  \r\n            faguan[b]+=1  \r\n            faguan[a]=-1\r\n        res = max(faguan)\r\n        if res == n-1:\r\n            return faguan.index(res)\r\n        return -1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469061856","body":"### 思路\r\n广度优先搜索，染色法\r\n先处理图，然后用一个列表记录节点的三种状态，1为第一组，0为未访问，-1为第二组\r\n分别遍历每一个节点，利用广度优先搜索处理连接节点。\r\n如果遇到冲突直接返回False。没有冲突则返回True。\r\n### 复杂度\r\n时间复杂度：O(m+n)，人数和dislike列表大小\r\n空间复杂度：O(m+n)，人数和dislike\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n        if not dislikes:\r\n            return True\r\n\r\n        tu = defaultdict(set)\r\n        for a,b in dislikes:\r\n            tu[a].add(b)\r\n            tu[b].add(a)\r\n        group = [0]*(n+1)  # 1,-1,0\r\n        for index, gp in enumerate(group):\r\n            if gp==0:\r\n                group[index]=1\r\n                q = deque()\r\n                q.append(index)\r\n                while q:\r\n                    t = q.popleft()\r\n                    for sub in tu[t]:\r\n                        if group[sub]==group[t]:\r\n                            return False\r\n                        if group[sub]==0:\r\n                            group[sub]=-group[t]\r\n                            q.append(sub)\r\n        return True\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1471140306","body":"### 思路\r\n拓扑排序（不会做）\r\n### 复杂度\r\n挺高的\r\n### 代码（抄的）\r\n```python\r\nclass Solution:\r\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\r\n        for i in range(n):\r\n            if group[i] == -1:\r\n                group[i] = m\r\n                m = m + 1\r\n        groupAdj, itemAdj = [[] for _ in range(m)], [[] for _ in range(n)]\r\n        groupsIndegree, itemsIndegree = [0] * m, [0] * n\r\n        for i in range(n):\r\n            currentGroup = group[i]\r\n            for item in beforeItems[i]:\r\n                beforeGroup = group[item]\r\n                if beforeGroup != currentGroup:\r\n                    groupAdj[beforeGroup].append(currentGroup)\r\n                    groupsIndegree[currentGroup] += 1\r\n        \r\n        for i in range(n):\r\n            for item in beforeItems[i]:\r\n                itemAdj[item].append(i)\r\n                itemsIndegree[i] += 1\r\n        \r\n        groupsList = self.topologicalSort(groupAdj, groupsIndegree, m)\r\n        if not groupsList: return []\r\n        itemsList = self.topologicalSort(itemAdj, itemsIndegree, n)\r\n        if not itemsList: return []\r\n\r\n        groups2items = collections.defaultdict(list)\r\n        for item in itemsList:\r\n            groups2items[group[item]].append(item)\r\n\r\n        ans = []\r\n        for group in groupsList:\r\n            ans.extend(groups2items[group])\r\n        return ans\r\n\r\n    def topologicalSort(self, adj, indegree, n):\r\n        queue, res = [], []\r\n        for i in range(n):\r\n            if indegree[i] == 0:\r\n                queue.append(i)\r\n        \r\n        while queue:\r\n            node = queue.pop(0)\r\n            res.append(node)\r\n            for i in adj[node]:\r\n                indegree[i] -= 1\r\n                if indegree[i] == 0:\r\n                    queue.append(i)\r\n        return res if len(res) == n else None\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1472896275","body":"### 思路\r\n统计每个字母出现的次数，上下相同，左右相同就能回来。\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def judgeCircle(self, moves: str) -> bool:\r\n        c = Counter(moves)\r\n        return c['R']==c['L'] and c['U']==c['D']\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1475450151","body":"### 思路\r\n用一个列表记录按时间排序的索引。\r\n用堆来保存当前所有任务，每次获取执行时间最小的任务。\r\n### 复杂度\r\n时间复杂度：O(nlogn)  有排序，有堆\r\n空间复杂度：O(n) \r\n### 代码\r\n```python\r\nclass Solution:\r\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\r\n        order = list(range(len(tasks)))\r\n        order.sort(key=lambda x:tasks[x][0])\r\n\r\n        res = []\r\n        q = []\r\n        currentTime = 0\r\n        cursor = 0\r\n\r\n        for i in range(len(tasks)):\r\n            if not q:\r\n                currentTime = max(currentTime,tasks[order[cursor]][0])\r\n            while cursor<len(tasks) and tasks[order[cursor]][0]<=currentTime:\r\n                heapq.heappush(q,(tasks[order[cursor]][1],order[cursor]))\r\n                cursor+=1\r\n            \r\n            processTime, index = heapq.heappop(q)\r\n            currentTime += processTime\r\n            res.append(index)\r\n        return res\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475457644","body":"### 思路\r\n计算一下时间\r\n### 复杂度\r\n时间复杂度：O(1)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\r\n        loginTimeH,loginTimeM = map(int,loginTime.split(':'))\r\n        logoutTimeH,logoutTimeM = map(int,logoutTime.split(':'))\r\n        if logoutTimeH*60+logoutTimeM<loginTimeH*60+loginTimeM:\r\n            logoutTimeH+=24\r\n        loginTimeM = math.ceil(loginTimeM/15)*15\r\n        logoutTimeM = logoutTimeM//15*15\r\n        totalTime = logoutTimeH*60+logoutTimeM-loginTimeH*60-loginTimeM\r\n        if totalTime<0:\r\n            totalTime=0\r\n        return totalTime//15\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475469643","body":"### 思路\r\n先统计每个字符串中字符出现次数。\r\n从字符'a'遍历到字符'y'，要么第一种方案要么第二种方案。取最小值\r\n最后还要计算一下 全部都变成字符'z'的情况。\r\n### 复杂度\r\n时间复杂度：O(m+n)  统计字符出现数量\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def minCharacters(self, a: str, b: str) -> int:\r\n        countA = Counter(a)\r\n        countB = Counter(b)\r\n        la,lb = len(a),len(b)\r\n\r\n        res = 10**5+1\r\n        suma ,sumb = 0,0\r\n        for i in range(ord('a'),ord('z')):\r\n            suma += countA[chr(i)]\r\n            sumb += countB[chr(i)]\r\n            res = min(min(res,la-countA[chr(i)]+lb-countB[chr(i)]),min(la-suma+sumb,lb-sumb+suma))\r\n        res = min(res,la-countA['z']+lb-countB['z'])\r\n        return res\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477198261","body":"### 思路：各种排序（该死的官方针对我的快速排序，Python过不了）\r\n归并排序\r\n### 复杂度\r\n时间复杂度：O(nlogn)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def sortArray(self, nums: List[int]) -> List[int]:\r\n        if len(nums)<=1:\r\n            return nums\r\n        mid = len(nums)>>1\r\n        left = self.sortArray(nums[:mid])\r\n        right = self.sortArray(nums[mid:])\r\n        l = 0\r\n        r = 0\r\n        res = []\r\n        while l<len(left) and r<len(right):\r\n            if left[l]<right[r]:\r\n                res.append(left[l])\r\n                l+=1\r\n            else:\r\n                res.append(right[r])\r\n                r += 1\r\n        while l<len(left):\r\n            res.append(left[l])\r\n            l += 1\r\n        while r<len(right):\r\n            res.append(right[r])\r\n            r += 1\r\n        return res\r\n     \r\n```   \r\n     ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1478926663","body":"### 思路\r\n二分，取中间。如果平方后比原数大，那右边界=中间-1。如果小，则左边界=中间。\r\n取中间时需要向上取整。\r\n### 复杂度\r\n时间复杂度：O(logn)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def mySqrt(self, x: int) -> int:\r\n        l = 0\r\n        r = int(x/2+0.5)\r\n        while l != r:\r\n            mid = int(((l + r)/2+0.5))\r\n            if mid * mid == x:\r\n                return mid\r\n            if mid * mid > x:\r\n                r = mid - 1\r\n            else:\r\n                l = mid\r\n        return l\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480649478","body":"### 思路\r\n二分\r\n### 复杂度\r\n时间复杂度：O(logn)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def firstBadVersion(self, n: int) -> int:\r\n        left = 1\r\n        right = n\r\n        while left < right:\r\n            mid = left+right>>1\r\n            if isBadVersion(mid):\r\n                right = mid\r\n            else:\r\n                left = mid+1\r\n        return left\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482149318","body":"### 思路（偷个懒吧）\r\n维护一个有序list\r\n### 复杂度\r\n时间复杂度：O(n^2)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def reversePairs(self, nums: List[int]) -> int:\r\n        res = 0\r\n        target = []\r\n        for i in nums[::-1]:\r\n            insert = bisect_left(target,i/2)\r\n            res += insert\r\n            insort(target,i)\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1484404875","body":"### 思路\r\n双指针\r\n### 复杂度\r\n时间复杂度：O(nlogn)  排序\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\r\n        houses.sort()\r\n        heaters.sort()\r\n        cur = 0\r\n        hindex = 0\r\n        hmax = len(heaters)-1\r\n        for h in houses:\r\n            while hindex < hmax and abs(h-heaters[hindex+1]) <= abs(h-heaters[hindex]):\r\n                hindex += 1\r\n            cur = max(cur,abs(h-heaters[hindex]))\r\n        return cur\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1484425276","body":"### 思路\r\n根据结果进行二分（能力二分？）\r\n### 复杂度\r\n时间复杂度：O(nlogn)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\r\n        nums.sort()\r\n        left = 0\r\n        right = max(nums)-min(nums)\r\n        while left<right:\r\n            cnt = 0\r\n            mid = left+right>>1\r\n            pos = 0\r\n           \r\n            for index,num in enumerate(nums):\r\n                while num-nums[pos]>mid:\r\n                    pos += 1\r\n                cnt += index - pos\r\n            if cnt < k:\r\n                left = mid + 1\r\n            if cnt >= k:\r\n                right = mid\r\n        return left\r\n            \r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484618117","body":"### 思路\r\n二分，深度优先搜索\r\n### 复杂度\r\n时间复杂度：O((n^2)*logn)\r\n空间复杂度：O(n^2)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def swimInWater(self, grid: List[List[int]]) -> int:\r\n        n = len(grid)\r\n        l = max(grid[0][0],grid[-1][-1])\r\n        r = n*n-1\r\n\r\n        def possible(t):\r\n            temp_grid = [[False]*n for _ in range(n)]\r\n            \r\n            def dfs(x,y,t):\r\n                if y<0 or x<0 or y==n or x==n:\r\n                    return     \r\n                if temp_grid[x][y]==True:\r\n                    return \r\n                if grid[x][y]<=t:                    \r\n                    temp_grid[x][y] = True \r\n                    if x == n - 1 and y == n - 1:\r\n                        return                   \r\n                    dfs(x+1,y,t)\r\n                    dfs(x-1,y,t)\r\n                    dfs(x,y+1,t)\r\n                    dfs(x,y-1,t)\r\n            dfs(0,0,t)\r\n            if temp_grid[n-1][n-1]==True:\r\n                return True\r\n            return False\r\n        while l<r:\r\n            mid = l+r>>1\r\n            if possible(mid):\r\n                r = mid\r\n            else:\r\n                l = mid + 1\r\n        return l\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486076850","body":"### 思路\r\n滑动窗口，双指针\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxVowels(self, s: str, k: int) -> int:\r\n        curmax = 0\r\n        cur = 0\r\n        left = 0\r\n        for index,c in enumerate(s):\r\n            if c in \"aeiou\":\r\n                cur += 1\r\n            if index-left+1>k:\r\n                if s[left] in \"aeiou\":\r\n                    cur -=1\r\n                left += 1            \r\n            curmax = max(curmax,cur)\r\n        return curmax\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1487783743","body":"### 思路\r\n动态规划，从后向前，依次计算概率（因为前面的牌面依赖后面的点数概率）\r\n### 复杂度\r\n时间复杂度：O(k+maxPts)\r\n空间复杂度：O(k+maxPts)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\r\n        dp=[0]*(k+maxPts)\r\n        s = 0  # 右边maxpts张牌的概率累积\r\n        for i in range(k,k+maxPts):\r\n            dp[i] = 1 if i<=n else 0\r\n            s += dp[i]\r\n        for i in range(k-1,-1,-1):\r\n            dp[i]=1/maxPts*s\r\n            s = s - dp[i+maxPts] + dp[i]\r\n        return dp[0]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489525136","body":"### 思路\r\n滑动窗口\r\n双指针，统计窗口中的每个字符个数，与p的统计相比较，一样就加入答案\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def findAnagrams(self, s: str, p: str) -> List[int]:\r\n        if len(s)<len(p):\r\n            return []\r\n        pos = 0\r\n        l = len(p)\r\n        c = Counter(p)\r\n        for i in range(l):\r\n            c[s[i]]-=1\r\n        res = []\r\n        diff = sum([abs(i) for i in c.values()])\r\n\r\n        if diff==0:\r\n            res.append(0)\r\n        for i in s[l:]:\r\n            if c[i]>0:\r\n                diff -= 1\r\n            else:\r\n                diff += 1\r\n            c[i]-=1\r\n            if c[s[pos]] <0:\r\n                diff -= 1\r\n            else:\r\n                diff += 1\r\n            c[s[pos]]+=1\r\n            pos += 1\r\n            if diff==0:\r\n                res.append(pos)\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491154087","body":"### 思路\r\n滑动窗口，和昨天的题差不多\r\n用diff记录是否符合结果\r\n右指针右移，期间计算左指针可不可以右移，每次计算长度是否比预设长度小，如果小，更新最小长度，并记录结果\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def minWindow(self, s: str, t: str) -> str:\r\n        left = 0\r\n        right = 0\r\n        curmax = float(inf)\r\n        c = Counter(t)\r\n        diff = sum(c.values())\r\n        resleft = 0\r\n        resright = 0\r\n        while right<len(s):\r\n            if s[right] in c:\r\n                if c[s[right]]>0:\r\n                    diff -= 1\r\n                c[s[right]]-=1\r\n            else:\r\n                right +=1\r\n                continue\r\n            while (left<len(s)) and ((s[left] not in c) or (c[s[left]]<0)):\r\n                if s[left] in c and c[s[left]]<0:\r\n                    c[s[left]]+=1\r\n                left += 1\r\n            if diff == 0 and right-left+1<curmax:\r\n                curmax = right-left+1\r\n                resleft = left\r\n                resright = right\r\n            right += 1\r\n        return s[resleft:resright+1] if curmax<=len(s) else \"\"\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1493485683","body":"### 思路\r\n滑动窗口，两边减少k，即中间等于sum(nums)-k\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def minOperations(self, nums: List[int], x: int) -> int:\r\n        s = sum(nums)\r\n        req = s - x\r\n        if req < 0:\r\n            return -1\r\n        l = 0\r\n        cur = 0\r\n        resmin = float(inf)\r\n        for r in range(len(nums)):\r\n            cur += nums[r]\r\n            while cur>req:\r\n                cur-=nums[l]\r\n                l += 1\r\n\r\n            if cur==req:\r\n                resmin = min(resmin,len(nums)-r-1+l)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493954960","body":"```python\r\nclass Solution:\r\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\r\n        times = [8,4,2,1,32,16,8,4,2,1]\r\n        res = []\r\n        def helper(idx,h,m,cnt):\r\n            if cnt == turnedOn:\r\n                res.append(\"%d:%02d\"%(h,m))\r\n                return\r\n            \r\n            if idx==len(times):\r\n                return\r\n            if idx<=3:\r\n                if h+times[idx]<=11:\r\n                    helper(idx+1,h+times[idx],m,cnt+1)\r\n                helper(idx+1,h,m,cnt)\r\n            else:\r\n                if m+times[idx]<=59:\r\n                    helper(idx+1,h,m+times[idx],cnt+1)\r\n                helper(idx+1,h,m,cnt)\r\n        helper(0,0,0,0)\r\n        return res\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494256868","body":"### 思路\r\n回溯法，用的方法比较笨\r\n### 复杂度\r\n时间复杂度：O(n!)\r\n空间复杂度：O(n^2)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def totalNQueens(self, n: int) -> int:\r\n        board = [[0] * n for _ in range(n)]\r\n        res = 0\r\n\r\n        def helper(level):\r\n            for i in range(n):\r\n                if judge(level, i):\r\n                    if level == n-1:\r\n                        nonlocal res\r\n                        res += 1\r\n                        return\r\n                    if level < n-1:\r\n                        board[level][i] = 1\r\n                        helper(level + 1)\r\n                        board[level][i] = 0\r\n            return\r\n\r\n        def judge(level, index):\r\n\r\n            # zong            \r\n            for i in range(n):\r\n                if board[i][index] == 1:\r\n                    return False\r\n            # xie            \r\n            mi = min(level, index)\r\n            startlevel = level - mi\r\n            startindex = index - mi\r\n            while startlevel < n and startindex < n:\r\n                if board[startlevel][startindex] == 1:\r\n                    return False\r\n                    \r\n                startlevel += 1\r\n                startindex += 1\r\n            ma = min(level, n - index-1)\r\n            startlevel = level - ma\r\n            startindex = index + ma\r\n            while startlevel < n and startindex >= 0:\r\n                if board[startlevel][startindex] == 1:\r\n                    return False\r\n                    \r\n                startlevel += 1\r\n                startindex -= 1\r\n            return True\r\n\r\n        helper(0)\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495182379","body":"### 思路\r\n深度优先搜索\r\n### 复杂度\r\n时间复杂度：O(mn)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\r\n        row = len(grid)\r\n        col = len(grid[0])\r\n\r\n        def dfs(m,n):\r\n            if m<0 or m>=row or n<0 or n>=col or grid[m][n]!=1:\r\n                return 0\r\n            cnt = 1\r\n            grid[m][n]=0\r\n            cnt +=dfs(m-1,n)+dfs(m+1,n)+dfs(m,n-1)+dfs(m,n+1)\r\n            return cnt\r\n        res = 0\r\n        for i in range(row):\r\n            for j in range(col):\r\n                if grid[i][j]==1:\r\n                    res = max(res,dfs(i,j))\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1498317744","body":"### 思路\r\n广度优先搜索\r\n### 复杂度\r\n时间复杂度：O(n^2)  n为行或列的数量\r\n空间复杂度：O(n^2) \r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxDistance(self, grid: List[List[int]]) -> int:\r\n        q = deque()\r\n        n = len(grid)\r\n        d = [(-1,0),(1,0),(0,-1),(0,1)]\r\n        for row in range(n):\r\n            for col in range(n):\r\n                if grid[row][col]==1:\r\n                    for x,y in d:\r\n                        if 0<=row+x<n and 0<=col+y<n and grid[row+x][col+y]==0:\r\n                            q.append((row+x,col+y,1))\r\n        res = -1\r\n        while q:\r\n            row,col,dist = q.popleft()\r\n            if grid[row][col] != 0:\r\n                continue\r\n            grid[row][col]=dist\r\n            for x,y in d:\r\n                if 0<=row+x<n and 0<=col+y<n and grid[row+x][col+y]==0:\r\n                    q.append((row+x,col+y,dist+1))                \r\n            res = dist        \r\n        return res\r\n            \r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498483843","body":"### 思路\r\n广度优先搜索\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\r\n        ownboxes = set()\r\n        ownkeys = set()\r\n        kaiguo = set()\r\n        res = 0\r\n        q = deque()\r\n        for i in initialBoxes:\r\n            if status[i]:\r\n                q.append(i)\r\n                kaiguo.add(i)\r\n            else:\r\n                ownboxes.add(i)        \r\n        while q:\r\n            curbox = q.popleft() \r\n            res += candies[curbox]\r\n            ownkeys.discard(curbox)\r\n            ownboxes.discard(curbox)\r\n            \r\n            for key in keys[curbox]:\r\n                if key in ownboxes:\r\n                    if key not in kaiguo:\r\n                        q.append(key)\r\n                        kaiguo.add(key)\r\n                else:\r\n                    ownkeys.add(key)\r\n            for box in containedBoxes[curbox]:\r\n                if status[box]==1 or (box in ownkeys):\r\n                    if box not in kaiguo:\r\n                        q.append(box)\r\n                        kaiguo.add(box)\r\n                else:\r\n                    ownboxes.add(box)\r\n        return res\r\n        \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1499846337","body":"### 思路\r\nDFS ，好像刚做过？\r\n### 复杂度\r\n时间复杂度：O(nlogn)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        d = defaultdict(list)\r\n        def dfs(node,row,col):\r\n            if not node:\r\n                return \r\n            d[col].append((row,node.val))\r\n            dfs(node.left,row+1,col-1)\r\n            dfs(node.right,row+1,col+1)\r\n            return\r\n        \r\n        dfs(root,0,0)\r\n        ans = []\r\n        \r\n        for k,v in sorted(d.items(),key=lambda x:x[0]):\r\n            v.sort()\r\n            ans.append([val for _,val in v])\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1501007417","body":"### 思路\r\n动态规划\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\r\n        l = len(cost)\r\n        dp = [0]*l\r\n        dp[0]=cost[0]\r\n        dp[1]=cost[1]\r\n        for i in range(2,l):\r\n            dp[i]=min(dp[i-2],dp[i-1])+cost[i]\r\n        return min(dp[-1],dp[-2])\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501008798","body":"### 思路\r\n动态规划，当前房屋累计结果应该等于前前个房屋的累计结果+当前房屋的钱数 或是 前面房间的累计结果。即dp[i]=max(dp[i-2]+nums[i],dp[i-1])\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def rob(self, nums: List[int]) -> int:\r\n        m = []\r\n        l = len(nums)\r\n        if l==1:\r\n            return nums[0]\r\n        m.append(nums[0])\r\n        m.append(max(nums[0],nums[1]))\r\n        for i in range(2,l):\r\n            m.append(max(m[i-2]+nums[i],m[i-1]))\r\n        return m[-1]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501606382","body":"### 思路\r\n动态规划，记录两个值，分别是以当前值结尾的最长长度和以当前值结尾的数量\r\n### 复杂度\r\n时间复杂度：O(n^2)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def findNumberOfLIS(self, nums: List[int]) -> int:\r\n        m = 0 \r\n        l = len(nums)\r\n        res = 0\r\n        dp = [0]*l\r\n        count = [0]*l\r\n        for index,n in enumerate(nums):\r\n            dp[index]=1\r\n            count[index]=1\r\n            for i in range(index):\r\n                if n>nums[i]:\r\n                    if dp[index]<dp[i]+1:\r\n                        dp[index]=dp[i]+1\r\n                        count[index]=count[i]\r\n                    elif dp[index]==dp[i]+1:\r\n                        count[index]+=count[i]\r\n            if dp[index]>m:\r\n                m = dp[index]\r\n                res = count[index]\r\n            elif dp[index]==m:\r\n                res += count[index]\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1502545968","body":"### 思路\r\n动态规划，二维。\r\n当两个值相等的时候取左上值+1，不相等的时候取上面或左面最大值\r\n### 复杂度\r\n时间复杂度：O(mn)\r\n空间复杂度：O(mn)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\r\n        l1 = len(text1)\r\n        l2 = len(text2)\r\n        dp = [[0]*(l2+1) for _ in range(l1+1)]\r\n        for i in range(1,l1+1):\r\n            for j in range(1,l2+1):\r\n                if text1[i-1]==text2[j-1]:\r\n                    dp[i][j]=dp[i-1][j-1]+1\r\n                else:\r\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1])\r\n        return dp[l1][l2]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1504272259","body":"### 思路\r\n动态规划，令所有格子都初始化为1，从第二行第二列开始，dp[i][j]等于上面的格子值+左边的格子值\r\n可以简化到一维进行累积。\r\n### 复杂度\r\n时间复杂度：O(mn)\r\n空间复杂度：O(m or n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def uniquePaths(self, m: int, n: int) -> int:\r\n        dp = [1]*n\r\n        for i in range(1,m):\r\n            for j in range(1,n):\r\n                dp[j]=dp[j]+dp[j-1]\r\n        return dp[-1]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506126627","body":"### 思路\r\n多层动态规划，当前位置当前步骤的下一步概率为上一步周边八个位置概率和的八分之一。\r\n### 复杂度\r\n时间复杂度：O(k*n^2)\r\n空间复杂度：O(k*n^2)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\r\n        delta = [(-2,1),(-2,-1),(-1,2),(-1,-2),(1,2),(1,-2),(2,-1),(2,1)]\r\n        dp = [[[0]*(k+1) for _ in range(n)] for _ in range(n)]  # dp[x][y][step]\r\n        for i in range(n):\r\n            for j in range(n):\r\n                dp[i][j][0]=1\r\n        for step in range(1,k+1):\r\n            for i in range(n):\r\n                for j in range(n):\r\n                    for dx,dy in delta:\r\n                        x = i+dx\r\n                        y = j+dy\r\n                        if 0<=x<n and 0<=y<n:\r\n                            dp[i][j][step]+=dp[x][y][step-1]/8\r\n        return dp[row][column][k]\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1507826356","body":"### 思路\r\n动态规划\r\n### 复杂度\r\n时间复杂度：O(2^n)\r\n空间复杂度：O(2^n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\r\n        if maxChoosableInteger>desiredTotal:\r\n            return True\r\n        if (1+maxChoosableInteger)*maxChoosableInteger/2<desiredTotal:\r\n            return False\r\n        \r\n\r\n        def helper(state,remainTotal,dp):\r\n            if dp[state]!=None:\r\n                return dp[state]\r\n            for i in range(1,maxChoosableInteger+1):\r\n                ch = 1<<(i-1)\r\n                if ch & state !=0:  # 已经被选过了\r\n                    continue\r\n                if i>=remainTotal:  # 如果再直接选一张就能赢，则当前状态一定赢\r\n                    dp[state] = True\r\n                    return True\r\n                if not helper(ch | state,remainTotal-i,dp):  # 如果对方选牌没有赢\r\n                    dp[state] = True\r\n                    return True\r\n            dp[state]=False  # 不能赢就肯定输\r\n            return False\r\n        \r\n        return helper(0,desiredTotal,[None]*(2**maxChoosableInteger-1))\r\n                      \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1510103476","body":"### 思路\r\n动态规划，01背包问题\r\n### 复杂度\r\n时间复杂度：O(mn)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def canPartition(self, nums: List[int]) -> bool:\r\n        n = len(nums)\r\n        if n < 2:\r\n            return False\r\n        \r\n        total = sum(nums)\r\n        if total % 2 != 0:\r\n            return False\r\n        \r\n        target = total // 2\r\n        dp = [True] + [False] * target\r\n        for i, num in enumerate(nums):\r\n            for j in range(target, num - 1, -1):\r\n                dp[j] |= dp[j - num]\r\n        \r\n        return dp[target]\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510119374","body":"### 思路\r\n动态规划\r\n### 复杂度\r\n时间复杂度：O(n*(sum-target))\r\n空间复杂度：O(n*(sum-target))\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\r\n        s = sum(nums)\r\n\r\n        neg = s-target\r\n        if neg<0 or neg%2!=0:\r\n            return 0\r\n        neg = neg//2\r\n        dp = [[0]*(neg+1) for _ in range(len(nums)+1)]\r\n        dp[0][0]=1\r\n        for i in range(1,len(nums)+1):\r\n            for j in range(neg+1):\r\n                dp[i][j] = dp[i-1][j]\r\n                if j>=nums[i-1]:\r\n                    dp[i][j] += dp[i-1][j-nums[i-1]]\r\n        return dp[len(nums)][neg]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1510995646","body":"### 思路\r\n动态规划\r\n遍历钱数，当前最小值取 当前值和从前面对应钱数过来，取最小值。dp[i]=min(dp[i],dp[i-coin]+1)\r\n### 复杂度\r\n时间复杂度：O(c*amount)\r\n空间复杂度：O(amount)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def coinChange(self, coins: List[int], amount: int) -> int:\r\n        if amount == 0:\r\n            return 0\r\n        dp = [float(inf)]*(amount+1)\r\n        dp[0]=0\r\n        for c in coins:\r\n            for i in range(c,amount+1):\r\n                dp[i]=min(dp[i],dp[i-c]+1)\r\n        if dp[amount]!=float(inf):\r\n            return dp[amount]\r\n        else:\r\n            return -1\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1512673488","body":"### 思路\r\n动态规划，和昨天的题差不多 \r\n### 复杂度\r\n时间复杂度：O(n*amount)\r\n空间复杂度：O(amount)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def change(self, amount: int, coins: List[int]) -> int:\r\n        if amount == 0:\r\n            return 0\r\n        dp = [0]*(amount+1)\r\n        dp[0]=1\r\n        for c in coins:\r\n            for i in range(c,amount+1):\r\n                dp[i] += dp[i-c]\r\n        return dp[amount]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1513913759","body":"### 思路\r\n贪心算法\r\n### 复杂度\r\n时间复杂度：O(mlogm+nlogn)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\r\n        g.sort()\r\n        s.sort()\r\n        cnt = 0\r\n        pos = 0\r\n        for i in g:\r\n            while pos<len(s) and s[pos]<i:\r\n                pos += 1\r\n            if pos<len(s):\r\n                cnt+=1\r\n                pos += 1\r\n            else:\r\n                break\r\n        return cnt\r\n            \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1515645541","body":"### 思路\r\n贪心算法，以右端点从小到大排序，依次遍历，对于每一个右端点检测是否和前一个冲突，不冲突计数+1。最终总数量-不冲突数量就是答案。\r\n### 复杂度\r\n时间复杂度：O(nlogn)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\r\n        if not intervals:\r\n            return 0\r\n        intervals.sort(key=lambda x : x[1])\r\n        cnt = 0\r\n        current = -float(\"inf\")\r\n        for l,r in intervals:\r\n            if l>=current:\r\n                cnt += 1\r\n                current = r\r\n        return len(intervals)-cnt\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517097977","body":"### 思路\r\n记录当前能到达的最大位置，遍历列表，如果当前位置大于记录的最大位置，说明到不了。\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def canJump(self, nums: List[int]) -> bool:\r\n        pos = 0\r\n        for index,n in enumerate(nums):\r\n            if pos<index:\r\n                return False\r\n            if index+n>pos:\r\n                pos = index+n\r\n        return True\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518989358","body":"### 思路\r\n递归，分治\r\n### 复杂度\r\n时间复杂度：O(n^2)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    @cache\r\n    def numTrees(self, n: int) -> int:\r\n        if n==0 or n==1:\r\n            return 1\r\n        s = 0\r\n        for i in range(1,n+1):\r\n            s += self.numTrees(i-1)*self.numTrees(n-i)\r\n        return s\r\n```\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1518990585","body":"### 思路\r\n归并排序\r\n### 复杂度\r\n时间复杂度：O(knlogk)\r\n空间复杂度：O(logk)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:        \r\n        def devide(ls):\r\n            if not ls:\r\n                return None\r\n            n = len(ls)\r\n            if n == 1:\r\n                return ls[0]\r\n            half = n // 2\r\n            return merge(devide(ls[:half]), devide(ls[half:]))\r\n\r\n        def merge(l1, l2):\r\n            if not l1:\r\n                return l2\r\n            if not l2:\r\n                return l1\r\n            d = ListNode(-1)\r\n            cur = d\r\n            while l1 and l2:                \r\n                if l1.val <= l2.val:\r\n                    cur.next = l1\r\n                    l1 = l1.next\r\n                else:\r\n                    cur.next = l2\r\n                    l2 = l2.next\r\n                cur = cur.next    \r\n            if not l1:\r\n                cur.next = l2                \r\n            elif not l2:\r\n                cur.next = l1\r\n                \r\n                \r\n            return d.next\r\n\r\n        return devide(lists)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1519228871","body":"### 思路\r\n分治\r\n### 复杂度\r\n时间复杂度：O(nlogn)\r\n空间复杂度：O(nlogn)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def beautifulArray(self, n: int) -> List[int]:\r\n        \r\n        def helper(n):\r\n            res = []\r\n            if n!=1:\r\n                for x in helper((n+1)//2):\r\n                    res.append(2*x-1)\r\n                for x in helper(n//2):\r\n                    res.append(2*x)\r\n            else:\r\n                res.append(1)\r\n            return res\r\n        \r\n        return helper(n)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521031141","body":"### 思路\r\n分组异或\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def singleNumber(self, nums: List[int]) -> List[int]:\r\n        yihuohe = reduce(lambda x,y:x^y,nums)\r\n        flag = yihuohe^(yihuohe&(yihuohe-1))\r\n        x1 = 0\r\n        x2 = 0\r\n        for n in nums:\r\n            if n & flag !=0:\r\n                x1 = x1 ^ n\r\n            else:\r\n                x2 = x2 ^ n\r\n        return [x1,x2]\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1522871185","body":"### 思路\r\nDFS，两种选择，要么扔进去，要么不扔进去。到最后一个的时候添加答案。\r\n### 复杂度\r\n时间复杂度：O(n*2^n)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def subsets(self, nums: List[int]) -> List[List[int]]:\r\n        res = []\r\n        def dfs(cur,li):\r\n            if cur<len(nums):\r\n                dfs(cur+1,li)\r\n                dfs(cur+1,li+[nums[cur]])\r\n            else:\r\n                res.append(li)\r\n        dfs(0,[])\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1524242869","body":"### 思路\r\n用字典实现\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(26^n)\r\n### 代码\r\n```python\r\nclass TrieNode:\r\n    def __init__(self):\r\n        self.nodes = defaultdict(TrieNode)\r\n        self.end = False\r\n\r\nclass Trie:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.root = TrieNode()\r\n\r\n\r\n    def insert(self, word: str) -> None:\r\n        \"\"\"\r\n        Inserts a word into the trie.\r\n        \"\"\"\r\n        t = self.root\r\n        for i in word:            \r\n            t = t.nodes[i] \r\n        t.end=True\r\n        \r\n\r\n\r\n\r\n    def search(self, word: str) -> bool:\r\n        \"\"\"\r\n        Returns if the word is in the trie.\r\n        \"\"\"\r\n        t = self.root\r\n        for i in word:\r\n            if i in t.nodes:\r\n                t = t.nodes[i]\r\n            else:\r\n                return False\r\n        return t.end\r\n        \r\n\r\n\r\n    def startsWith(self, prefix: str) -> bool:\r\n        \"\"\"\r\n        Returns if there is any word in the trie that starts with the given prefix.\r\n        \"\"\"\r\n        t = self.root\r\n        for i in prefix:\r\n            if i in t.nodes:\r\n                t = t.nodes[i]\r\n            else:\r\n                return False\r\n        return True\r\n        \r\n\r\n\r\n\r\n# Your Trie object will be instantiated and called as such:\r\n# obj = Trie()\r\n# obj.insert(word)\r\n# param_2 = obj.search(word)\r\n# param_3 = obj.startsWith(prefix)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1527285086","body":"### 思路\r\nTrie树应用\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(k*n)\r\n### 代码\r\n```python\r\nclass TreeNode:\r\n    def __init__(self):\r\n        self.nodes = defaultdict(TreeNode)\r\n        self.end = False\r\n        self.value = 0\r\n        self.passvalue=0\r\n\r\nclass MapSum:\r\n\r\n    def __init__(self):\r\n        self.data = TreeNode()\r\n\r\n    def getvalue(self,key:str) -> int:\r\n        index = 0\r\n        node = self.data\r\n        while index<len(key):\r\n            node = node.nodes[key[index]]\r\n            index += 1\r\n        if node.end:\r\n            return node.value\r\n        else:\r\n            return 0\r\n\r\n    def insert(self, key: str, val: int) -> None:  \r\n        oldvalue = self.getvalue(key)\r\n        index = 0\r\n        node = self.data\r\n        while index<len(key):\r\n            node = node.nodes[key[index]]\r\n            node.passvalue += val-oldvalue\r\n            index += 1\r\n        node.end = True\r\n        node.value = val\r\n\r\n\r\n\r\n    def sum(self, prefix: str) -> int:\r\n        index = 0\r\n        node = self.data\r\n        while index<len(prefix):\r\n            node = node.nodes[prefix[index]]     \r\n            index += 1\r\n        return node.passvalue      \r\n\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1533911732","body":"### 没有思路\r\nKMP不会，记不住\r\n```python\r\nclass Solution:\r\n    def multiSearch(self, big: str, smalls: List[str]) -> List[List[int]]:\r\n        res = []\r\n        for i in smalls:\r\n            if i==\"\":\r\n                res.append([])\r\n                continue\r\n            t = i+\"#\"+big\r\n            pi = [0]*len(t)\r\n            for j in range(1,len(t)):\r\n                k = pi[j-1]\r\n                while k>0 and t[j]!=t[k]:\r\n                    k = pi[k-1]\r\n                if t[j]==t[k]:\r\n                    k+=1\r\n                pi[j]=k\r\n            res.append([p-2*len(i) for p in range(len(t)) if pi[p]==len(i)])\r\n        return res \r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1533913426","body":"### 思路\r\n深度优先搜索\r\n### 复杂度\r\n时间复杂度：O(n^2)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\r\n        d = {}\r\n        s = set(range(len(isConnected)))\r\n        @lru_cache(None)\r\n        def dfs(k,n):\r\n            if k not in s:\r\n                return\r\n            if n not in d:\r\n                d[n]=[n]\r\n            s.remove(k)\r\n            for i in range(len(isConnected)):\r\n                if isConnected[k][i] == 1:   \r\n                    d[n].append(i)                                        \r\n                    dfs(i,n)\r\n        for a in range(len(isConnected)):\r\n            dfs(a,a)\r\n        return len(d)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1533914163","body":"### 思路\r\n并查集\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\r\n        res = []\r\n        nodes = [-1] * len(graph)\r\n        def union(a ,b ,nodes):\r\n            a = find(a ,nodes)\r\n            b = find(b ,nodes)\r\n            if a == b:\r\n                return a\r\n            elif a < b:\r\n                nodes[b] = a\r\n            else:\r\n                nodes[a] = b\r\n\r\n        def find(a ,nodes):\r\n            t = a\r\n            while nodes[t]>=0:\r\n                t = nodes[t]\r\n            while t!= a:\r\n                nodes[a], a = t, nodes[a]\r\n            return t\r\n\r\n        for i in range(len(graph)):\r\n            for j in range(i + 1, len(graph)):\r\n                if graph[i][j] == 1:\r\n                    union(i, j, nodes)\r\n\r\n        for e in initial:\r\n            s = set()\r\n            for i in initial:\r\n                if i != e:\r\n                    s.add(find(i, nodes))\r\n            r = len(s)\r\n            for i in nodes:\r\n                if i in s:\r\n                    r += 1\r\n            res.append((r, e))\r\n\r\n        res.sort(key=lambda x: (x[0], x[1]))\r\n        return res[0][1]\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1533914493","body":"### 思路\r\n并查集\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\r\n        if len(connections)<n-1:\r\n            return -1\r\n        comps = [-1]*n\r\n        def find(com):\r\n            t = com\r\n            while comps[t]>=0:\r\n                t = comps[t]\r\n            while t!=com:\r\n                comps[com],com=t,comps[com]\r\n            return t\r\n        \r\n        def union(c1,c2):\r\n            root1 = find(c1)\r\n            root2 = find(c2)\r\n            if root1==root2:\r\n                return\r\n            elif root1<root2:\r\n                comps[root2]=root1\r\n            else:\r\n                comps[root1]=root2\r\n        \r\n        for i,j in connections:\r\n            union(i,j)\r\n        \r\n        count = 0\r\n        for i in comps:\r\n            if i==-1:\r\n                count += 1\r\n        return count-1\r\n            \r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1533915073","body":"### 思路\r\n深度优先搜索\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def pruneTree(self, root: TreeNode) -> TreeNode:\r\n\r\n        def dfs(node):\r\n            if not node:\r\n                return None\r\n            node.left = dfs(node.left)\r\n            node.right = dfs(node.right)\r\n            if node.val or node.left or node.right:\r\n                return node\r\n            else:\r\n                return None\r\n        \r\n        return dfs(root)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1533915560","body":"### 思路\r\n深度优先搜索\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\r\n        res = []\r\n        def dfs(tar,cur,cur_list):\r\n            if tar<0:\r\n                return \r\n            if tar==0:\r\n                res.append(cur_list.copy())\r\n                return\r\n            \r\n            for i in range(cur,len(candidates)):\r\n                cur_list.append(candidates[i])\r\n                dfs(tar-candidates[i],i,cur_list)\r\n                cur_list.pop()\r\n        \r\n        dfs(target,0,[])\r\n        return res\r\n            \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1535566977","body":"### 思路\r\n回溯法\r\n### 复杂度\r\n时间复杂度：O(n*2^n)，copy是n，回溯是2^n\r\n空间复杂度：O(n)   存储临时列表\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\r\n        \r\n        c = list(Counter(candidates).items())\r\n        l = len(c)\r\n        res = []\r\n\r\n        def dfs(index,reminder,curlist):            \r\n            if reminder==0:\r\n                res.append(curlist.copy())\r\n                return            \r\n            if index==l or reminder<0:\r\n                return\r\n            val,times = c[index]\r\n            for i in range(times+1):                \r\n                curlist.extend([val]*i)\r\n                dfs(index+1,reminder-val*i,curlist)\r\n                for j in range(i):\r\n                    curlist.pop()\r\n        \r\n        dfs(0,target,[])\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1537033179","body":"```python\r\nclass Solution:\r\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\r\n        res = set()\r\n        n = len(nums)\r\n        nums.sort()\r\n        def dfs(a ,li):\r\n            if len(li )==n:\r\n                res.add(tuple(li.copy()))\r\n                return\r\n            for i in range(len(a)):\r\n                if i== 0:\r\n                    li.append(a[0])\r\n                    dfs(a[1:], li)\r\n                    li.pop()\r\n                if i > 0 and a[i] != a[i - 1]:\r\n                    a[0], a[i] = a[i], a[0]\r\n                    li.append(a[0])\r\n                    dfs(a[1:], li)\r\n                    li.pop()\r\n                    a[0], a[i] = a[i], a[0]\r\n\r\n        dfs(nums, [])\r\n        return list(res)\r\n```","onTime":true},null,null,null,null,null,null,null,null,null],"leonalhq":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429140638","body":"class Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # treat the num as a stack\n        res = []\n        carry = k\n        while num:\n            val = num.pop() + carry\n            carry = val/10\n            res.insert(0, val%10)\n\n        while carry:\n            res.insert(0, carry%10)\n            carry = carry/10\n        return res\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431559494","body":"class Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        left=[]\n        lens = len(s)\n        right=[0]*lens\n        \n        t = sys.maxsize\n        for i in range(0,lens):\n            if s[i]== c:\n                t = i\n            left.append(t)\n            \n        t = sys.maxsize\n        for i in range(lens-1,-1,-1):\n            if s[i]== c:\n                t = i\n            right[i] = t\n\n        ans = []\n        for i in range(0,lens):\n            ans.append(min(abs(left[i]-i),abs(right[i]-i)))\n            \n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433193022","body":"class CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.stacks=[]\r\n        self.cnt=0\r\n        self.size = maxSize\r\n        self.incre = [0]*maxSize\r\n        \r\n        \r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if self.cnt<self.size:\r\n            self.stacks.append(x)\r\n            self.cnt+=1\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.cnt<=0:\r\n            return -1\r\n        inc = self.incre[self.cnt-1]\r\n        self.incre[self.cnt-1] = 0\r\n        if self.cnt>1:\r\n            self.incre[self.cnt-2] +=inc\r\n        \r\n        self.cnt-=1\r\n        return self.stacks.pop() + inc\r\n        \r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if(self.cnt):\r\n            if k <= self.cnt:\r\n                self.incre[k-1] += val\r\n            if k > self.cnt:","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434053932","body":"### 思路  \n  \n这种计算器类【】相关的第一反应就是栈，\n特别想用recurrsion，写了半天发现没考虑两位数这种case，int_stack发现似乎也不必要\n  \n### 代码  \n  \n```python\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        int_stack= []\n        def subDecode(s, i, temp):\n            int_temp = \"\"\n            while i < len(s):\n                if s[i] == ']':\n                    return i, temp\n                elif s[i] == '[':\n                    int_stack.append(int(int_temp))\n                    int_temp = \"\"\n                    i, cur_str = subDecode(s, i+1, \"\")\n                    temp = temp + int_stack.pop() * cur_str\n                elif s[i].isnumeric():\n                    int_temp+=s[i]\n                else:\n                    temp += s[i]\n                i=i+1\n            return temp\n        t = subDecode(s, 0, \"\")\n\n        return t\n```\n  \n**复杂度分析**  \n- 时间复杂度：O(N)，其中 N 为数组长度。  \n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435438598","body":"class MyQueue(object):\n\n    def __init__(self):\n        self.s = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.s.insert(0,x)\n        \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.s.pop()\n        \n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.s[-1]\n        \n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return not self.s\n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435907313","body":"### 思路  \n  \n单项栈的Stack的做法实在是太巧妙\n  \n### 代码  \n  \n  \n```py（此处换成你的语言，比如js，py 等）  \nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        for a in arr:\n            if not stack:\n                stack.append(a)\n            else:\n                if stack[-1] < a:\n                    stack.append(a)\n                else:\n                    top = stack[-1]\n                    while stack and stack[-1] > a:\n                        stack.pop()\n                    stack.append(top)\n                    \n        return len(stack)\n```  \n  \n  \n```  \n  \n**复杂度分析**  \n- 时间复杂度：O(kN)，其中 N 为数组长度。  \n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436305996","body":"```\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :type k: int\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head or k == 0:\r\n            return head\r\n\r\n        act = head\r\n        l = 1\r\n        while act.next:\r\n            act = act.next\r\n            l +=1\r\n        act.next = head\r\n        \r\n        a_k = k%l\r\n        a_l = l - a_k - 1\r\n    \r\n        # Find the new head\r\n        new_tail = head\r\n        for i in range(a_l):\r\n            new_tail = new_tail.next\r\n\r\n        new_head = new_tail.next\r\n        # print(a_l, new_head)\r\n        # cut from previous end\r\n        new_tail.next = None\r\n\r\n        return new_head\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438631353","body":"class Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next: \n            return head\n\n        nextNode = head.next\n        head.next = self.swapPairs(nextNode.next)\n        nextNode.next = head\n\n        return nextNode","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439507693","body":"### 思路  \n  \n有点难，所以最好 重新看一下\n1.快慢指针的写法\n  \n### 代码  \n  \n  \n```python\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n        \n        #获取当前链表的中点\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        #以链表中点为根\n        mid = TreeNode(slow.val)\n        # 没有就 maximum recursion depth exceeded\n        if slow == fast:\n            return mid\n        #中点左边的值都小于它,可以构造左子树\n        mid.left = self.sortedListToBST(head)\n        #同理构造右子树\n        mid.right = self.sortedListToBST(slow.next)\n\n        return mid\n```\n  \n**复杂度分析**  \n- 时间复杂度：O(NlogN)，其中 N 为数组长度。  \n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441204487","body":"class Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummyA = headA\n        dummyB = headB\n        # inter = set()\n        # interA = None\n        # while dummyA:\n        #     inter.add(dummyA)\n        #     dummyA = dummyA.next\n        \n        # while dummyB:\n        #     if dummyB in inter:\n        #         return dummyB\n        #     else:\n        #         dummyB = dummyB.next\n\n        while dummyA != dummyB:\n            if not dummyA and not dummyB:\n                return None\n            if not dummyA:\n                dummyA = headB\n            else:\n                dummyA = dummyA.next\n            if not dummyB:\n                dummyB = headA\n            else:\n                dummyB = dummyB.next\n\n        return dummyA","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442848858","body":"class Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        slow = fast = head\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n            if slow == fast:\n                while slow != head:\n                    slow, head = slow.next, head. next\n                return slow\n        return None","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445004962","body":"\n\n思路大混乱，照着lc和答案抄了一下+\n  \n### 代码  \n  \n  \n```py\nclass Node:  \n    def __init__(self, key, val):  \n        self.key = key  \n        self.val = val  \n        self.prev = None  \n        self.next = None  \n  \nclass LRUCache:  \n  \n    def __init__(self, capacity: int):  \n        # 构建双向链表首尾节点, 使之相连  \n        self.head = Node(0, 0)  \n        self.tail = Node(0, 0)  \n        self.head.next = self.tail  \n        self.tail.prev = self.head  \n\t\t# 记录位置\n        self.lookup = dict()  \n        self.max_len = capacity  \n  \n    def get(self, key: int) -> int:  \n        if key in self.lookup:  \n            node = self.lookup[key]  \n            self.remove(node)  \n            self.add(node)  \n            return node.val  \n        else:  \n            return -1  \n  \n    def put(self, key: int, value: int) -> None:  \n        if key in self.lookup:  \n            self.remove(self.lookup[key])  \n        #满了要删掉了\n        if len(self.lookup) == self.max_len:  \n            self.remove(self.head.next)  \n        self.add(Node(key, value))\n    # 删除链表节点  \n    def remove(self, node):  \n        del self.lookup[node.key]  \n        node.prev.next = node.next  \n        node.next.prev = node.prev  \n    # 加在链表尾  \n    def add(self, node): \n\t    # 记录每个 key 对应的链表节点引用 \n        self.lookup[node.key] = node  \n        #+到尾巴之前\n        pre_tail = self.tail.prev  \n        node.next = self.tail  \n        self.tail.prev = node  \n        pre_tail.next = node  \n        node.prev = pre_tail\n```\n  \n```  \n  \n**复杂度分析**  \n- 时间复杂度：O(1)，其中 N 为数组长度。  \n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445251375","body":"class Solution(object):\n    def __init__(self):\n        self.mm = 0\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        self.pre_order(root, 1)\n        return self.mm\n    def pre_order(self, root, depth):\n        if not root:\n            return 0\n        if not root.left and not root.right:\n            self.mm = max(depth, self.mm)\n        \n        self.pre_order(root.left, depth + 1)\n        self.pre_order(root.right, depth + 1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445473402","body":"```\r\nclass Solution(object):\r\n    def isSameTree(self, p, q):\r\n        \"\"\"\r\n        :type p: TreeNode\r\n        :type q: TreeNode\r\n        :rtype: bool\r\n        \"\"\"\r\n        if not p and not q:\r\n            return True\r\n        elif not p or not q:\r\n            return False\r\n\r\n        \r\n        # if p.val == q.val:\r\n        #     return True\r\n        left = self.isSameTree(p.left, q.left)\r\n        right = self.isSameTree(p.right, q.right)\r\n\r\n        return p.val == q.val and left and right\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447588655","body":"### 思路  \n  \n（此处撰写思路）  \n  \n### 代码  \n  \n  \n```py（此处换成你的语言，比如js，py 等）  \nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        return self.dfs(root, 0)\n\n    def dfs(self, root, now):\n        if not root: \n            return 0\n        if not root.left and not root.right:\n            return now * 10 + root.val\n        \n        return self.dfs(root.left, now*10 +root.val) + self.dfs(root.right, now*10 +root.val)\n        \n```\n  \n  \n```  \n  \n**复杂度分析**  \n- 时间复杂度：O(N)\n- 空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450186062","body":"```\r\nclass Solution(object):\r\n    def findBottomLeftValue(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n\r\n        # BFS, find by level\r\n        queue = collections.deque()\r\n        queue.append(root)\r\n        top = None\r\n        while queue:\r\n            length = len(queue)\r\n            top = queue[-1]\r\n            for _ in range(length):\r\n                head = queue.popleft()\r\n                if head.right:\r\n                    queue.append(head.right)\r\n                if head.left:\r\n                    queue.append(head.left)\r\n\r\n        return top.val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451324712","body":"class Codec:\n    def serialize(self, root):\n        ans=[]\n        stc=[root]\n        while(len(stc)>0):\n            tstc=[]\n            for a in stc:\n                if(a==None):\n                    ans.append(\"N\")\n                else:\n                    ans.append(str(a.val))\n                if(a!=None):\n                    tstc.append(a.left)\n                    tstc.append(a.right)\n            stc=tstc\n        ans=\"x\".join(ans)\n        return ans\n    def deserialize(self, data):\n        data=data.split(\"x\")\n        if(data[0]==\"N\"):\n            return None\n        root=TreeNode(data[0])\n        stc=[root]\n        i=1\n        while(len(stc)>0):\n            if(data[i]!=\"N\"):\n                stc[0].left=TreeNode(int(data[i]))\n                i+=1\n                stc.append(stc[0].left)\n            else:\n                stc[0].left=None\n                i+=1\n            if(data[i]!=\"N\"):\n                stc[0].right=TreeNode(int(data[i]))\n                i+=1\n                stc.append(stc[0].right)\n            else:\n                stc[0].right=None\n                i+=1\n            stc.pop(0)\n        return root\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455119402","body":"class Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        dic = {}\n        for n in nums:\n            dic[n] = dic.get(n, 0) + 1\n            \n        dic = sorted(dic.items(), key=lambda x: x[1], reverse = True)\n        ans = []\n        for i in range(k):\n            ans.append(dic[i][0])\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455334678","body":"class Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for i in range(len(points)):\n            m = {}\n            for j in range(len(points)):\n                dist = abs(\n                    points[i][0] - points[j][0]\n                ) ** 2  + abs(\n                    points[i][1] - points[j][1]\n                ) ** 2\n                m[dist] = m.get(dist, 0) + 1 \n            for count in m.values():\n                ans += count * (count-1)\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457541406","body":"class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ls, res =0,0\n        d = set()\n        for i, j in enumerate(s):\n            while j in d:\n                d.remove(s[ls])\n                ls += + 1\n            d.add(j)\n            res = max(i - ls + 1, res)\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459486053","body":"class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen = len(words[0])\n        wslen = len(words) * len(words[0])\n        res = []\n        \n        for pos in range(wlen):\n            i = pos\n            d = Counter(words)\n            \n            for j in range(i, len(s) + 1 - wlen, wlen):\n                word = s[j: j + wlen]\n                d[word] -= 1\n                \n                while d[word] < 0:\n                    d[s[i: i + wlen]] += 1\n                    i += wlen\n                if i + wslen == j + wlen:\n                    res. append(i)\n        \n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461265543","body":"def minSubarray(self, nums: List[int], p: int) -> int:\n    result = len(nums)\n\t# reminder that we need to remove from given array\n    need = sum(nums) % p\n\t# exit if nothing to remove\n    if need == 0:\n        return 0\n\t# at the beginning our prefix sum is zero with location -1 for correct length calculations for subarrays starting at 0\n    prefix_pos = {0: -1}\n\t# current prefix sum\n    prefix = 0\n    for i, num in enumerate(nums):\n\t\t# increase prefix by current num and take reminder\n        prefix = (prefix + num) % p\n\t\t# this is the current value we need to find in already seen positions\n        cur = (prefix - need) % p\n\t\t# if it's present calculate and update result if necessary\n        if cur in prefix_pos:\n            result = min(i - prefix_pos[cur], result)\n\t\t# remember current prefix position\n        prefix_pos[prefix] = i\n\t# if the only available result is the whole array, than it should be -1 \n    if result == len(nums):\n        result = -1\n    return result","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463735006","body":"from math import ceil\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        mapped = []\n        n = 0\n        while head:\n            mapped.append(head)\n            n += 1\n            head = head.next\n        k = n // 2 if n % 2 else ceil(n/2)\n        return mapped[k]","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465083885","body":"class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        first=0\n        last=len(nums)-1\n        pf=0\n        pl=len(nums)-1\n        mid=(first+last)//2\n        while(first<=last):\n            mid=(first+last)//2\n            if(nums[mid]==target):\n                return mid\n            elif(nums[mid]<target):\n                pf=first\n                first=mid+1\n            else:\n                pl=last\n                last=mid-1\n        mid=(pf+pl)//2\n        if(nums[mid]>target):\n            return mid\n        else:\n            return mid+1","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hjy-u":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429146539","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carryon = 0\n        i = len(num) - 1\n        res = []\n        while (i >= 0 or k != 0):\n            current_num = num[i] if i >= 0 else 0\n            current_k = k%10 if k!=0 else 0\n            value = current_num + current_k + carryon\n            carryon = value // 10\n            k //= 10\n            i -= 1\n            res.insert(0, value % 10)\n        if carryon != 0:\n            res.insert(0, carryon)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430735051","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        res = [0] * n\n        idx = -n\n        for i in range(n):\n            if s[i] == c:\n                idx = i\n            res[i] = i - idx\n        idx = 2 * n\n        for i in range(n - 1, -1, -1):\n            if s[i] == c:\n                idx = i\n            res[i] = min(res[i], idx - i)\n        return res\n```\nTC: O(n)\nSC: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1437915096","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if len(self.stack) == 0:\n            return -1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) < k:\n            self.stack = [i+val for i in self.stack]\n        else:\n            for i in range(k):\n                self.stack[i] += val\n        return self.stack\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"csthaha":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429151521","body":"#### 思路：\n   1.将 K 也转换成对应的数组。\n   2. 遍历最长的一个数组。从末尾进行相加。\n   3. 获取res后 对数组进行替换。\n   4. 遍历完之后判断是否仍有进位。\n#### 复杂度：\n  时间复杂度：O(n)\n  空间复杂度：O(n)\n#### 代码：\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(arr, k) {\n    // k 数组形式\n    const strK = String(k)\n    const arrK = []\n    for(let i = 0; i < strK.length; i++) {\n        arrK.push(+strK[i])\n    }\n    let pos = 0 // 进位\n    const longArr = arrK.length > arr.length ? arrK : arr\n    for(let j = 0; j < longArr.length; j++) {\n        const A = arrK[arrK.length - 1 - j];\n        const B = arr[arr.length - 1 - j];\n        const sum = (A || 0) + (B || 0) + pos;\n        const res = sum % 10;\n        pos = Math.floor(sum / 10)\n        longArr[longArr.length - 1 - j] = res;\n    }\n    if(pos) {\n        longArr.unshift(pos)\n    }\n    return longArr\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430803730","body":"#### 思路：\n  - 获取字符**c**在**s**中的所有索引列表\n  - `getDistance` 获取字符在索引列表中的最小值。\n#### 复杂度：\n  - 时间复杂度: O(n^2)\n  - 空间复杂度: O(n)\n#### 代码：\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    const res = []\n    const indexList = []\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] === c) {\n            indexList.push(i)\n        }\n    }\n    const getDistance = (list, index) => {\n        let min = Number.MAX_VALUE;\n        for(let i = 0; i < list.length; i++) {\n            min = Math.min(Math.abs(list[i] - index), min)\n        }\n        return min\n    }\n    for(let i = 0; i < s.length; i++) {\n        res.push(getDistance(indexList, i))\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432615804","body":"#### 复杂度：\n时间复杂度：O(min(k, maxSize))\n空间复杂度：O(1)\n#### 代码：\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.list = [];\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.size() >= this.maxSize) {\n        return;\n    };\n    this.list.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.size() === 0) return -1;\n    return this.list.pop();\n};\n\nCustomStack.prototype.size = function() {\n    return this.list.length;\n}\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0; i < Math.min(this.size(), k); i++) {\n        this.list[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434160030","body":"\n\n #### 思路：\n - 遍历字符串\n - 若遇到数字计算倍数\n - 若遇到 *[* 进行 倍数、之前结果进行入栈 *[num, res]* ，并将 *num*、*res* 重置\n - 若遇到 *]* 则进行出栈操作。当前拼接的 res 为需要重复的字符串，而出栈的 res 则为之前的结果字符串。二者进行拼接。\n - 若遇到其他字符则进行结果拼接。\n\n #### 复杂度：\n - 时间复杂度： O(n)\n - 空间复杂度：O(l) l为嵌套层数。\n #### 代码：\n ```javascript\n /**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let res = '';\n    const stack = [];\n    let num = 0;\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] >= 0) {\n            num = +s[i] + num * 10;\n            continue;\n        }\n        if(s[i] === '[') {\n            stack.push([num, res]);\n            num = 0;\n            res = '';\n            continue\n        }\n        if(s[i] === ']') {\n            const [num, stackRes] = stack.pop();\n            res = stackRes + res.repeat(num)\n            continue;\n        }\n        res += (s[i] > 0 ? '' : s[i])\n    }\n    return res\n};\n ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435476966","body":"\n#### 复杂度：\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)\n\n#### 代码：\n```javascript\nclass MyQueue {\n    constructor() {\n        this.list = [];\n    }\n\n    push(x) {\n        this.list.push(x);\n    }\n\n    pop() {\n        if(!this.size()) return;\n        return this.list.shift();\n    }\n\n    size() {\n        return this.list.length;\n    }\n\n    peek() {\n        if(!this.size()) return;\n        return this.list[0];\n    }\n\n    empty() {\n        return this.size() === 0;\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435828337","body":"#### 复杂度：\n时间复杂度：O(n)\n空间复杂度：O(n) while循环次数 最大为 n\n#### 代码：\n```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    // 单调栈， 维护块的最大元素。\n    const stack = [];\n    for(let item of arr) {\n        // 小于 或者 等于的都可以当做一个块\n        if(stack.length === 0 || stack[stack.length - 1] <= item) {\n            stack.push(item)\n        } else {\n            const max = stack.pop();  // 弹出栈顶元素 重新分配块。\n            // 如果 最大元素大于当前元素。 则继续弹出栈顶元素。\n            while(stack.length && stack[stack.length - 1] > item) {\n                stack.pop()\n            }\n            stack.push(max)\n        }\n    }\n    return stack.length;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436227015","body":"\n#### 复杂度：\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n#### 代码：\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let cur = head;\n    let count = 0;\n    while(cur) {\n        count++;\n        if(!cur.next) {\n            // 成环\n            cur.next = head;\n            break;\n        } else {\n            cur = cur.next;\n        }\n    }\n    let remain = k % count; //求余数\n\n    // head 需要移动 remain 下， 成环后（cur.next = head） ， cur 需要移动 add 下。\n    // cur.next 为 头节点。然后断开环。\n    let add = count - remain;\n\n    if(add === count) {\n        cur.next = null;\n        return head;\n    }\n\n    let res = null;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    res = cur.next;\n    cur.next = null;\n    \n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437789687","body":"\n#### 思路：\n - 递归进行两两交换即可。 \n#### 复杂度：\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n#### 代码：\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    var cb = head => {\n        if(!head || !head.next) return head;\n        let cur;\n        cur =  head.next;\n        next = cur.next;\n        cur.next = head;\n        head.next = null;\n        head = cur;\n        if(next) {\n            head.next.next = cb(next)\n        }\n        return head;\n    }\n    return  cb(head);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1441147294","body":"\r\n#### 复杂度：\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n#### 代码：\r\n```javascript\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n    if (!head) return null;\r\n    var cb = (head, tail) => {\r\n        if(head === tail) return null;\r\n        let slow = head,\r\n            fast = head;\r\n        while(fast !== tail && fast.next != tail) {\r\n            slow = slow.next;\r\n            fast = fast.next.next\r\n        }\r\n        // 此时 slow 在链表的中点了。\r\n        const root = new TreeNode(slow.val);\r\n        root.left = cb(head, slow)\r\n        root.right = cd(slow.next, tail)\r\n        return root\r\n    }\r\n    return cb(head, null);\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441168494","body":"#### 复杂度：\n- 时间复杂度：O(n + m) headA length + m 相交前 B 的节点。\n- 空间复杂度：O(n) headA length\n#### 代码：\n```javascript\n/**  160\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    const visited = new Set();\n    let temp = headA;\n    while (temp) {\n        visited.add(temp);\n        temp = temp.next;\n    }\n    temp = headB;\n    while (temp) {\n        if (visited.has(temp)) {\n            return temp;\n        }\n        temp = temp.next;\n    }\n    return null;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442685900","body":"\n#### 复杂度：\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n#### 代码：\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    const visited = new Set();\n    let res = null,\n        cur = head;\n    while(cur) {\n        if(!visited.has(cur)) {\n            visited.add(cur)\n            cur = cur.next;\n        } else {\n            res = cur;\n            break;\n        }\n    }\n\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445061398","body":"\n#### 代码：\n```javascript\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.map = new Map();\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if(!this.map.has(key)) return -1;\n    const v = this.map.get(key);\n    //删掉再新加。\n    this.map.delete(key);\n    this.map.set(key, v);\n    return v;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    // 需要先判断是否存在。因为如果是满的情况且更新值的情况会删错。\n    if(this.map.get(key)) {\n        // 存在先删除\n        this.map.delete(key)\n    }\n    if(this.map.size >= this.capacity) {\n        // 删除最久未使用\n        // next().value 返回的是第一组键 \n        this.map.delete(this.map.keys().next().value);\n    }\n    this.map.set(key, value)\n\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445608658","body":"#### 复杂度：\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(h)\r\n#### 代码：\r\n```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n    if(!root) return 0;\r\n    if(!root.left && !root.right) return 1;\r\n    let deep = 1;\r\n    let leftDeep = 0;\r\n    let rightDeep = 0;\r\n    if(root.left) {\r\n        leftDeep += maxDepth(root.left);\r\n    }\r\n    if(root.right) {\r\n        rightDeep += maxDepth(root.right);\r\n    }\r\n    return deep + (leftDeep > rightDeep ? leftDeep : rightDeep);\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445619746","body":"#### 复杂度：\n- 时间复杂度：O(n)\n- 空间复杂度：O(h)\n\n#### 代码：\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    if(!p && !q) return true;\n    if(!p || !q) return false;\n    const rootBool = p.val === q.val;\n    return rootBool && isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447477643","body":"#### 复杂度：\n- 时间复杂度：O(n)\n- 空间复杂度：O(m) m：路径\n#### 代码：\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    const list = [];\n    \n    const help = (root, path) => {\n        if(!root) return;\n        path += root.val\n        if(!root.left && !root.right) {\n            list.push(path)\n            return;\n        };\n        help(root.left,  path)\n        help(root.right, path)\n    }\n    help(root, '');\n    return list.reduce((a, b) => (a + (+b)), 0)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449251547","body":"#### 复杂度：\n- 时间复杂度：O(n)\n- 空间复杂度：O(h)\n\n#### 代码：\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n    //层次遍历 二维数组最后一个的第一个元素。\n    if(!root) return root;\n    const res = [];\n    let queue = [root];\n    while(queue.length > 0) {\n        let temp = [];\n        let values = [];\n        for(let item of queue) {\n            values.push(item.val);\n            if(item.left) {\n                temp.push(item.left);\n            }\n            if(item.right) {\n                temp.push(item.right)\n            }\n        }\n        res.push(values);\n        queue = temp;\n    }\n    return res[res.length - 1][0]\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1452872292","body":"#### 复杂度：\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n#### 代码：\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n    const map = {};\n    const help = (node, row, col) => {\n        if(!node) return;\n        // if(map[col]) {\n        //     map[col].push(node.val)\n        // } else {\n        //     map[col] = [node.val]\n        // }\n        if(map[col]) {\n            // map[col][row].push(node.val)\n            if(map[col][row]) {\n                map[col][row].push(node.val)\n            } else {\n                map[col][row] = [node.val]\n            }\n            map[col][row] = map[col][row].sort((a, b) => a - b)\n        } else {\n            map[col] = {}\n            map[col][row] = [node.val]\n        }\n        if(node.left) {\n            help(node.left, row + 1, col - 1);\n        }\n        if(node.right) {\n            help(node.right, row + 1, col + 1);\n        }\n    }\n    help(root, 0, 0)\n    return Object.keys(map)\n            .sort((a, b) => a - b)\n            .map(key => Object.values(map[key])\n            .reduce((a, b) => [...a, ...b], []))\n};\n```javascript","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454337024","body":"#### 复杂度：\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n#### 代码：\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    const map = new Map();\n    for(let i = 0; i < nums.length; i++) {\n        const remain = target - nums[i];\n        if(!map.has(remain)) {\n            map.set(nums[i], i)\n        } else {\n            return [map.get(remain), i]\n        }\n    }\n    return [];\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1454962882","body":"#### 复杂度：\n- 时间复杂度：O(nlongn)\n- 空间复杂度：O(n)\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function(nums, k) {\n    const map = new Map();\n    for(let num of nums) {\n        if(!map.has(num)) {\n            map.set(num, 1)\n        } else {\n            let count = map.get(num) + 1;\n            map.set(num, count)\n        }\n    }\n    const res = [];\n    let values = [...map.values()].sort((a, b) => b - a);\n    let keys =  [...map.keys()]\n    console.log(map, keys, values);\n    for(let i = 0; i < k; i++) {\n        let key = keys.find(key => map.get(key) === values[i])\n        res.push(key)\n        map.delete(key)\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455542602","body":"\n#### 复杂度：\n- 时间复杂度：O(n^3)\n- 空间复杂度：O(1)\n\n#### 代码：\n```javascript\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n    const res = [];\n    const clcDistance = (p1, p2) => {\n        const x = Math.pow(p1[0] - p2[0], 2)\n        const y = Math.pow(p1[1] - p2[1], 2)\n        return Math.sqrt(x + y)\n    }\n    for(let i = 0; i < points.length; i++) {\n        for(let j = 0; j < points.length; j++) {\n            if(i === j) continue;\n            const d1 = clcDistance(points[i], points[j])\n            for(let k = 0; k < points.length; k++) {\n                if(k === i || k === j) continue;\n                const d2 = clcDistance(points[i], points[k])\n                if(\n                    d1 === d2\n                ) {\n                    res.push(\n                        [points[i], points[j], points[k]]\n                    )\n                }\n            }\n        }\n    }\n    return res.length;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457389525","body":"\n##### 复杂度：\n- 时间复杂度：O(n)\n- 空间复杂度：O(s) s 为 count。\n\n#### 代码：\n```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    let res = '',\n        count = 0;\n    for(let i = 0; i < s.length; i++) {\n        if(res.indexOf(s[i]) > -1) {\n            // 存在\n            res = res.slice(res.indexOf(s[i]) + 1)\n        }\n        res += s[i];\n        count = Math.max(count, res.length)\n    }\n    return count;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459837572","body":"\n#### 代码：\n```javascript\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    // 满足条件的字串长度。\n    words.sort();\n    let wordLen = words[0].length\n    let slen = words.length * wordLen;\n    if(s.length < slen) return [];\n    const res = [];\n    for(let i = 0; i <= s.length - slen; i++) {\n        let curS = s.slice(i, slen + i);\n        // 长度 len 分一组。\n        const curArr = [];\n        while(curS.length) {\n            curArr.push(curS.slice(0, wordLen));\n            curS = curS.slice(wordLen);\n        }\n        // 不能使用该方式判断。words 中可能存在相同的字符串。\n        // if(\n        //     [...new Set(curArr)].length === words.length && \n        //     curArr.every(item => words.indexOf(item) > -1)\n        // ) {\n        //     res.push(i)\n        // }\n\n        // 其实就是判断两个数组是否完全相同。\n        curArr.sort();\n        let l = 0;\n        for(let k = 0; k < words.length; k++){\n            if(curArr[l] === words[k]) {\n                l++;\n            }\n        }\n        if(l === words.length) {\n            res.push(i)\n        }\n\n    }\n    return res;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463175618","body":"#### 复杂度：\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n\n#### 代码：\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function(head) {\n    // 第一想法快慢指针。\n    let slow = head;\n    let fast = head;\n\n    while(fast.next && fast.next.next) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    // 这个时候要么 false 走到底了 slow 在中点。\n\n    return fast.next ? slow.next :\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464818145","body":"#### 复杂度：\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n\n#### 代码：\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    // 读写指针\n    let slow = 0;\n    let k = 1;\n    for(let i = 0; i < nums.length; i++) {\n        if(slow < k || nums[i] !== nums[slow - 1]) {\n            nums[slow] = nums[i];\n            slow++\n        }\n    }\n    return slow;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465068375","body":"```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    let left = 0,\n        right = nums.length - 1\n    while(left <= right) {\n        mid = Math.floor((left + right) / 2);\n        if(nums[mid] === target) return mid;\n        if(nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = right - 1;\n        }\n    }\n    return left;\n};\n```\nTC: O(longn)\nSC: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467441806","body":"```javascript\n/**\n * @param {number} n\n * @param {number[][]} trust\n * @return {number}\n */\nvar findJudge = function(n, trust) {\n    const inDegrees = new Array(n + 1).fill(0);\n    const outDegrees = new Array(n + 1).fill(0);\n    for (const edge of trust) {\n        const x = edge[0], y = edge[1];\n        inDegrees[y]++;\n        outDegrees[x]++;\n    }\n    for (let i = 1; i <= n; ++i) {\n        if (inDegrees[i] === n - 1 && outDegrees[i] === 0) {\n            return i;\n        }\n    }\n    return -1;\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473257911","body":"```javascript\n/**\n * @param {string} moves\n * @return {boolean}\n */\nvar judgeCircle = function(moves) {\n    let x = 0;\n    let y = 0;\n\n    for(let item of moves) {\n        switch(item) {\n            case \"R\":\n            case \"L\":\n                if(item === 'R') {\n                    x++;\n                } else {\n                    x--;\n                }\n                break;\n            case \"U\":\n            case \"D\":\n                if(item === 'U') {\n                    y++;\n                } else {\n                    y--;\n                }\n                break;\n        }\n    }\n\n    return x === 0 && y === 0\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475153893","body":"```javascript\n/**\n * @param {string} loginTime\n * @param {string} logoutTime\n * @return {number}\n */\nvar numberOfRounds = function(loginTime, logoutTime) {\n    let start = parseInt(loginTime.slice(0, 2)) * 60 + parseInt(loginTime.slice(3));\n\n    let end = parseInt(logoutTime.slice(0, 2)) * 60 + parseInt(logoutTime.slice(3));\n\n    if (end < start) end += 24 * 60;\n\n    let ans = Math.floor(end / 15) - Math.ceil(start / 15);\n\n    return ans < 0 ? 0 : ans;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1478828624","body":"```javascript\r\nvar sortArray = function(arr) {\r\n    for (let i = 1; i < arr.length; i++) {\r\n    let j = i;\r\n        while (j > 0 && arr[j] < arr[j - 1]) {\r\n            [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]];\r\n            j--;\r\n        }\r\n    }\r\n    return arr;\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1478834642","body":"```javascript\n/**\n * @param {number} x\n * @return {number}\n */\nvar mySqrt = function(x) {\n    if(x === 1) return 1;\n    let left = 1;\n    let right = x >> 1;\n    while(left <= right) {\n        let mid = (left + right) >> 1;\n        if(Math.pow(mid,2) === x) return mid;\n        if(Math.pow(mid, 2) < x) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return left - 1;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480475415","body":"```javascript\n/**\n * Definition for isBadVersion()\n * \n * @param {integer} version number\n * @return {boolean} whether the version is bad\n * isBadVersion = function(version) {\n *     ...\n * };\n */\n\n/**\n * @param {function} isBadVersion()\n * @return {function}\n */\nvar solution = function (isBadVersion) {\n    /**\n     * @param {integer} n Total versions\n     * @return {integer} The first bad version\n     */\n    return function (n) {\n        let left = 1;\n        let right = n;\n        while (left < right) {\n            let mid = left + Math.floor( (right - left) / 2);\n            if (isBadVersion(mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    };\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486126156","body":"```javascript\n/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar maxVowels = function(s, k) {\n    //固定长度的滑动窗口。\n    let slow = 0;\n\n    let max = 0\n    let ans = 0;\n    const vowel = ['a', 'e','i', 'o', 'u']\n    for(let i = 0; i < s.length; i++) {\n        if(i - slow + 1 > k) {\n            slow++\n            if(vowel.includes(s[slow - 1])) {\n                max--;\n            }\n        }\n        if(vowel.includes(s[i])) {\n            max++;\n        }\n        ans = Math.max(ans, max)\n    }\n    return ans;\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493244988","body":"```javascript\n/**\n * @param {number} turnedOn\n * @return {string[]}\n */\nvar readBinaryWatch = function(turnedOn) {\n    // 枚举所有时间转成二进制、然后 计算符合条件的 1个数 === turnedOn\n    const ans = [];\n    for(let i = 0; i < 12; i++) {\n        for(let j = 0; j < 60; j++) {\n            if(\n                i.toString(2).split('0').join('').length + j.toString(2).split('0').join('').length === turnedOn\n            ) {\n                ans.push(i + \":\" + (j < 10 ? \"0\" : \"\") + j);\n            }\n        }\n    }\n    return ans;\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500827509","body":"```javascript\nvar minCostClimbingStairs = function(cost) {\n    const n = cost.length;\n    const dp = new Array(n + 1);\n    dp[0] = dp[1] = 0;\n    for (let i = 2; i <= n; i++) {\n        dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1502994758","body":"```javascript\nlet m = text1.length,\n        n = text2.length,\n        dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    for(let i = 1; i <= m; i++) {\n        const c1 = text1[i  -1];\n        for(let j = 1; j <= n; j++) {\n            const c2 = text2[j - 1];\n            if(c1 === c2) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i  -1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[m][n]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1504539938","body":"```javascript\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function(m, n) {\n    // 二维 爬楼梯。dp[i, j] = dp[i -  1, j] + dp[i, j. -1];\n    if(m === 0 && n === 0) return 0;\n    // 用于记忆\n    const array = new Array(m).fill(new Array(n).fill(0));\n\n    // 第一行、第一列 都只有一种路径。\n    for(let i = 0; i < m; i++) {\n        array[i][0] = 1;\n    }\n    for(let j = 0; j < n; j++) {\n        array[0][j] = 1;\n    }\n\n    for(let i = 1; i < m; i++) {\n        for(let j = 1; j < n; j++) {\n            array[i][j] = array[i - 1][j] + array[i][j - 1];\n        }\n    }\n    return array[m - 1][n - 1]\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506384192","body":"```javascript\n/**\n * @param {number} n\n * @param {number} k\n * @param {number} row\n * @param {number} column\n * @return {number}\n */\nvar knightProbability = function(n, k, row, column) {\n    // 可移动的方向\n    const direction = [[1, 2], [2, 1], [2, -1], [1, -2], [-1, -2], [-2, -1], [-2, 1], [-1, 2]];\n    // 初始化状态\n    const dp = new Array(k + 1).fill(0).map(() => new Array(n).fill(0).map(() => new Array(n).fill(0)));\n    // 当前位置走到下个位置的概率为 1/8: dp[step][i][j] += dp[step - 1][ni][nj] / 8\n    for(let step = 0; step <= k; step++) {\n        for(let i = 0; i < n; i++) {\n            for(let j = 0; j < n; j++) {\n                if(step === 0) {\n                    dp[step][i][j] = 1;\n                } else {\n                    for(const [row, col] of direction) {\n                        const ni = i + row;\n                        const nj = j + col;\n                        if(ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                            dp[step][i][j] += dp[step - 1][ni][nj] / 8\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dp[k][row][column]\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1510617198","body":"```javascript\n/**\n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\nvar coinChange = function(coins, amount) {\n    if(!coins || coins.length === 0 || amount <= 0) return 0\n    const dp = new Array(amount + 1).fill(amount + 1);\n    dp[0] = 0;\n    for(let c of coins) {\n        for(let i = c; i <= amount; i++) {\n            dp[i] = Math.min(dp[i], dp[i - c] + 1)\n        }\n    }\n\n    return dp[amount] === amount + 1 ? -1 : dp[amount]\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1512542300","body":"```javascript\n/**\n * @param {number} amount\n * @param {number[]} coins\n * @return {number}\n */\nvar change = function(amount, coins) {\n    const dp = new Array(amount + 1).fill(0);\n    dp[0] = 1; // amount = 0 什么也不选结果 1\n    for(let item of coins) {\n        for(let i = item; i <= amount; i++) {\n            dp[i] = dp[i] + dp[i - item]\n        }\n    }\n    return dp[amount]\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514199059","body":"```javascript\n/**\n * @param {number[]} g\n * @param {number[]} s\n * @return {number}\n */\nvar findContentChildren = function(g, s) {\n    const sortG = g.sort((a, b) => a - b),\n          sortS = s.sort((a, b) => a - b);\n    if(s.length === 0) return 0;\n    let i = 0,\n        j = 0;\n    while(i < sortG.length && j < sortS.length){\n        if(sortG[i] <= sortS[j]) {\n            i++;\n        }\n        j++;\n    }\n    return i;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1515607032","body":"```javascript\n/**\n * @param {number[][]} intervals\n * @return {number}\n */\nvar eraseOverlapIntervals = function(intervals) {\n    intervals.sort((a, b) => a[1] - b[1])\n\n    let arr = [intervals[0]], temp = intervals[0]\n    for(let i = 1; i < intervals.length; i++) {\n        if(intervals[i][0] >= temp[1]) {\n            arr.push(intervals[i])\n            temp = intervals[i]\n        }\n    }\n\n    return intervals.length ? intervals.length - arr.length : 0\n\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1522849943","body":"```javascript\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function(nums) {\n    const res = [];\n    const backTrack = (path, index) => {\n        if(index === nums.length) {\n            res.push([...path]);\n            return;\n        }\n        path.push(nums[index]) // 当前元素选择\n        backTrack(path, index + 1);\n        path.pop();   // 当前元素不选择。\n        backTrack(path, index + 1)\n    }\n    backTrack([], 0)\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1524824631","body":"```javascript\nvar Trie = function() {\n    this.children = {}\n};\n\n/** \n * @param {string} word\n * @return {void}\n */\nTrie.prototype.insert = function(word) {\n    let curNode = this.children;\n    for(let str of word) {\n        if(!curNode[str]) {\n            curNode[str] = {}\n        }\n        curNode = curNode[str]\n    }\n    curNode.end = true;\n};\n\n/** \n * @param {string} word\n * @return {boolean}\n */\nTrie.prototype.search = function(word) {\n    let node = this.children;\n    for(let i = 0; i < word.length; i++) {\n        const char = word[i];\n        if(!node[char]) {\n            return false;\n        }\n        node = node[char];\n    }\n    return node !== undefined && node.end !== undefined;\n};\n\n/** \n * @param {string} prefix\n * @return {boolean}\n */\nTrie.prototype.startsWith = function(prefix) {\n    let node = this.children;\n    for(let i = 0; i < prefix.length; i++) {\n        const char = prefix[i];\n        if(!node[char]) {\n            return false;\n        }\n        node = node[char];\n    }\n    return node !== undefined;\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * var obj = new Trie()\n * obj.insert(word)\n * var param_2 = obj.search(word)\n * var param_3 = obj.startsWith(prefix)\n */\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1532590203","body":"```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar pruneTree = function(root) {\n    if(!root) return null;\n    root.left = pruneTree(root.left);\n    root.right = pruneTree(root.right);\n    if(root.val === 0 && !root.left && !root.right) return null;\n    return root;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1533976839","body":"```javascript\n/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum = function (candidates, target) {\n    var res = [];\n    var backTrack = (path,index) => {\n        var sum = path.reduce((cur, next) => cur + next, 0)\n        if (sum >= target) {\n            sum === target && res.push(path)\n            return\n        }\n\n        for (let j = index; j < candidates.length; j++) {\n            path.push(candidates[j])\n            backTrack(path.concat(), j)\n            path.pop()\n        }\n    }\n    backTrack([], 0)\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1535615627","body":"```javascript\n/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum2 = function(candidates, target) {\n  const res = [];\n  const visited = new Array(candidates.length).fill(false);\n  const backTrack = (path, start) => {\n    const total = path.reduce((a, b) => a + b, 0);\n    if (total > target) return;\n    if (total === target) {\n      res.push(path.slice());\n      return;\n    }\n\n    for (let i = start; i < candidates.length; i++) {\n      if (\n        visited[i] ||\n        (i > start && candidates[i] === candidates[i - 1] && !visited[i - 1])\n      ) {\n        continue;\n      }\n      path.push(candidates[i]);\n      visited[i] = true;\n      backTrack(path, i + 1);\n      path.pop();\n      visited[i] = false;\n    }\n  };\n  candidates.sort((x, y) => x - y);\n  backTrack([], 0);\n  return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1536982690","body":"```javascript\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permuteUnique = function(nums) {\n    const res = [];\n    const visited = new Array(nums.length).fill(false);\n    const  backTrack = (path) => {\n        if(path.length === nums.length) {\n            res.push(path);\n            return;\n        }\n\n        for(let i = 0; i < nums.length; i++) {\n            if(visited[i] || (i > 0 && nums[i] === nums[i - 1] && !visited[i - 1])) continue;\n            path.push(nums[i]);\n            visited[i] = true;\n            backTrack(path.concat());\n            path.pop();\n            visited[i] = false;\n        }\n    }\n    nums.sort((x, y) => x - y);\n    backTrack([])\n    return res;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null],"zepherust":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429177324","body":"\n- 最简单的思路\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        A = 0\n        for i in num:\n            A = A*10 + i\n        k = k+A\n        result = []\n        while k!= 0:\n            result = [k%10] + result\n            k = k//10\n        return result if result != [] else [0]\n```\n结果： 2388ms/ 14.3MB\n原因分析: 两次O(n)循环，创建了一个数组\n\n- 尝试改进一次O(n)\n\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        n = len(num)\n        addition = 0\n        result = []\n        for i in range(0,n):\n            t = num[n-i-1] + k%10 + addition\n            addition = 1 if t >=10 else 0\n            t = t %10\n            result = [t] + result\n            k = k // 10\n        while k>0:\n            t = k%10 + addition\n            addition = 1 if t >=10 else 0\n            t = t %10\n            result = [t] + result\n            k = k//10\n        if addition > 0:\n            result = [1] + result\n        return result \n```\n结果 : 1336ms/13.6MB\n分析：比上次几乎节省一半时间，合理\n\n- 尝试更优解法\n\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        n = len(num) - 1\n        addition = 0\n        while n >= 0:\n            num[n] = num[n] + k%10 + addition\n            addition = 1 if num[n] >=10 else 0\n            num[n] = num[n] %10\n            k = k // 10\n            n -= 1\n        while k>0:\n            t = k%10 + addition\n            addition = 1 if t >=10 else 0\n            t = t %10\n            num = [t] + num\n            k = k//10\n        if addition > 0:\n            num = [1] + num\n        return num\n```\n结果:  56ms/13.4MB\n分析：直接使用原来的数组，省去创造数组的时间\n\n- 群友的最优解法\n\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        i= len(num) - 1\n        while k>0 and i>=0:\n            num[i] += k\n            k = num[i] // 10\n            num[i] %= 10\n            i -= 1\n        while k>0:\n            num = [k%10] + num\n            k //= 10\n        return num\n```\n结果： 36/13.7\n分析：直接省去进位（把进位体现到k上），进一步节省时间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431456932","body":"class Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        # forward \n        n = len(s)\n        result = [n for i in range(n)]\n        k = 0\n        for i in range(n):\n            if s[i] != c:\n                result[i] = abs(n-k-1)\n                k += 1\n            else:\n                result[i] = 0\n                k = n\n        print(result)\n        #backward\n        k = n-1\n        for i in range(n-1,-1,-1):\n            if s[i] != c:\n                result[i] = min(result[i],abs(k))\n                k -= 1\n            else:\n                result[i] = 0\n                k = -1\n        return result","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432932626","body":"- 使用Python自带的数组\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.capability = maxSize\r\n        self.size = 0\r\n        self.values = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.capability:\r\n            self.values.append(x)\r\n            self.size+=1\r\n\r\n    def pop(self) -> int:\r\n        if self.size > 0:\r\n            v = self.values.pop()\r\n            self.size -=1\r\n            return v\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k > self.size:\r\n            l = self.size\r\n        else:\r\n            l = k\r\n        for i in range(l):\r\n            self.values[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n- 空间换时间\r\n```\r\n class CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.capability = maxSize\r\n        self.size = 0\r\n        self.values = [0 for i in range(maxSize)]\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.capability:\r\n            self.size+=1\r\n            self.values[self.size -1] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.size > 0:\r\n            v = self.values[self.size-1]\r\n            self.size -=1\r\n            return v\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k > self.size:\r\n            l = self.size\r\n        else:\r\n            l = k\r\n        for i in range(l):\r\n            self.values[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feefeefee":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429180682","body":"```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n const len = num.length\n let i = len - 1 \n let carry = 0\n let res = []\n  while(i>=0 || k!==0){\n      let x = i>=0 ? num[i] : 0\n      let y = k !== 0 ? k % 10 :0\n      const sum = x + y +carry\n      carry = sum >= 10 ? 1 : 0\n      res.push(sum % 10);\n      k = Math.floor(k / 10)\n      i-- \n  \n  }\n  if(carry){\n     res.push(carry)\n  }\nreturn res.reverse()\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430664602","body":"```javaScript \n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let len = s.length\n    const arr = Array(s.length)\n    let l_current = null\n    let r_current = null\n\n    for(let i = 0; i < len ; i++){\n        l_current = s[i] === c ? i :l_current\n        arr[i] = l_current !== null ? Math.abs(i - l_current) : Infinity\n    }\n\n     for(let i = len-1; i >=0 ; i--){\n        r_current = s[i] === c ? i : r_current\n        if(r_current !== null){\n            const abs = Math.abs(i -r_current)\n            arr[i] = arr[i] < abs ? arr[i]:abs\n        }\n    }\n    return arr\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432628609","body":"```javaScript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  const len = this.stack.length;\n  if (len < this.maxSize) {\n    this.stack.push(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  const len = this.stack.length;\n  return len === 0 ? -1 : this.stack.pop();\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  const len = this.stack.length;\n\n  const y = len < k ? len :k\n   for (let i = 0; i < y; i++) {\n      this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hughlin07":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429183075","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        \n        List<Integer> res= new ArrayList();\n        int index = num.length - 1;\n        \n        while( index >= 0 || k > 0){\n            if(index >= 0 ){\n                k = k + num[index];\n            }\n            res.add(k%10);\n            k = k/10;\n            index -- ;\n        }\n\n        Collections.reverse(res);\n        \n        return res;\n    }\n}\n\n\nComplexity Analysis:\nTime: O(n), n is the length of array\nSpace: O(n),","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432861018","body":"class CustomStack {\n    \n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top != stack.length-1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n\n        if(top != -1){\n            --top;\n            return stack[top+1 ];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < Math.min(k, top+1); i++){\n            stack[i] += val;\n        }\n    }\n}\n\nTime Complexity: \nPush, Pop: O(1)\nIncrement: O(k)\n\nSpace Complexity: O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434403006","body":"class Solution {\n    public String decodeString(String s) {\n        \n        Stack<Integer> times = new Stack<>();\n        Stack<String> temp_String = new Stack<>();\n        StringBuilder result = new StringBuilder();\n        int count = 0;\n        \n        for(char c : s.toCharArray()){\n            if( c == '['){\n                times.push(count);\n                temp_String.push(result.toString());\n                count = 0;\n                result = new StringBuilder();\n            }\n            else if(c == ']'){\n                StringBuilder temp = new StringBuilder();\n                int temp_times = times.pop();\n                \n                for(int i = 0; i < temp_times; i++){\n                    temp.append(result);\n                }\n                result = new StringBuilder(temp_String.pop() + temp.toString());\n            }\n            else if(c >= '0' && c <= '9'){\n                count = count * 10 + c - '0';\n            }\n            else{\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n}\n\nSpace Complexity:\nO(m+n), m and n are the size of stack\nTime Complexity:\nO(n*count), iterate count times for total.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435524905","body":"class MyQueue {\n\n    Stack<Integer> s1 = new Stack<>();\n    Stack<Integer> s2 = new Stack<>();\n\n    public MyQueue() {\n        \n    }\n    \n    public void push(int x) {\n        while(!s1.isEmpty()){\n            s2.push(s1.pop());\n        }\n\n        s2.push(x);\n\n        while(!s2.isEmpty()){\n            s1.push(s2.pop());\n        }\n    }\n    \n    public int pop() {\n        return s1.pop();\n    }\n    \n    public int peek() {\n        return s1.peek();\n    }\n    \n    public boolean empty() {\n        return s1.isEmpty();\n    }\n}\n\nTime Complexity: O(n)\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435951030","body":"class Solution {\r\n    \r\n    public int maxChunksToSorted(int[] arr) {\r\n\r\n        Stack<Integer> result = new Stack<Integer>();\r\n\r\n        for(int num : arr){\r\n            int tmp = num;\r\n            while(result.size() > 0 && result.peek() > num){\r\n                tmp = Math.max(tmp, result.peek());\r\n                result.pop();\r\n            }\r\n            result.push(tmp);\r\n        }\r\n        return result.size();\r\n    }\r\n}\r\n\r\nTime Complexity: O(n)\r\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436651376","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null){\n            return head;\n        }\n\n        ListNode curNode = head;\n        int length = 1;\n        while(curNode.next != null){    \n            curNode = curNode.next;\n            length ++;\n        }\n\n        ListNode tailNode = curNode;\n        curNode.next = head;\n        curNode = head;\n\n        int loopCount = length - (k%length);\n        for(int i = 0; i < loopCount; i++){\n            curNode = curNode.next;\n            tailNode = tailNode.next;\n        }\n        tailNode.next = null;\n        return curNode;\n    }\n}\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438051979","body":"class Solution {\r\n\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n\r\n        ListNode temp = head.next;\r\n        head.next = swapPairs(temp.next);\r\n        temp.next = head;\r\n        return temp;\r\n    }\r\n}\r\n\r\nTime Complexity: O(N)\r\nSpace Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439700654","body":"class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        \n       if(head == null){\n            return null;\n        }\n        return dfs(head, null);\n    }\n\n    public TreeNode dfs(ListNode head, ListNode tail){\n        if(head == tail) return null;\n        ListNode fast = head, slow = head;\n        while(fast != tail && fast.next != tail){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = dfs(head, slow);\n        root.right = dfs(slow.next, tail);\n        return root;\n    }\n}\n\nTime Complexity: O(nlogn)\n\nSpace Complexity: O(logn)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443479591","body":"public class Solution {\r\n\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null) return null;\r\n        ListNode slow = head, fast = head;\r\n        while(true){\r\n            if(fast == null || fast.next == null){\r\n                return null;\r\n            }\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n\r\n            if(fast == slow)break;\r\n        }   \r\n\r\n        fast = head;\r\n        while(fast != slow){\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }   \r\n\r\n}\r\n\r\nTime: O(N)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445050359","body":"class LRUCache {\n\n    class DoubleLinkedNode{\n        int key, value;\n        DoubleLinkedNode prev, next;\n        public DoubleLinkedNode(){}\n        public DoubleLinkedNode(int _key, int _value){\n            key = _key;\n            value = _value;\n        }\n    }\n\n    private Map<Integer, DoubleLinkedNode> cache = new HashMap<Integer, DoubleLinkedNode>();\n    private int size, cap;\n    private DoubleLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n        head = new DoubleLinkedNode();\n        tail = new DoubleLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        DoubleLinkedNode node = cache.get(key);\n        if(node == null){\n            return -1;\n        }\n        moveToHead(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        DoubleLinkedNode node = cache.get(key);\n        if(node == null){\n            DoubleLinkedNode newNode = new DoubleLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if(size > cap){\n                DoubleLinkedNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        }\n        else{\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DoubleLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DoubleLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DoubleLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DoubleLinkedNode removeTail(){\n        DoubleLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n\n\n\nTime: O(1)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445323200","body":"class Solution {\r\n\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null) return 0;\r\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n    }\r\n\r\n}\r\n\r\nTime: O(N), N is the total nodes\r\nSpace: O(h), h is the depth of the tree","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446025644","body":"class Solution {\r\n\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(q == null && p == null) return true;\r\n        if(q == null || p == null) return false;\r\n        if(p.val != q.val) return false;\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n\r\n}\r\n\r\nTime: O(N)\r\nSpace: O(h)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449138399","body":"class Solution {\n\n    int maxLevel = 0;\n    Map<Integer, Integer> map = new HashMap<>();\n    public int findBottomLeftValue(TreeNode root) {\n        // if(root == null) return 0;\n        dfs(root, 0);\n        return map.get(maxLevel);\n    }\n\n    public void dfs(TreeNode root, int level){\n        if(root==null)return;\n        int newLevel = level +1;\n        dfs(root.left, newLevel);\n        if(newLevel > maxLevel && !map.containsKey(newLevel)){\n            map.put(newLevel, root.val);\n            maxLevel = newLevel;\n        }\n        dfs(root.right, newLevel);\n    }\n\n}\n\nTime Complexity: O(N)\n\nSpace Complexity: O(h), h is the height of the tree","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451524846","body":"public class Codec {\n\n    private static final String spliter = \",\";\n    private static final String NN = \"X\";\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        buildString(root, sb);\n        return sb.toString();\n    }\n\n    private void buildString(TreeNode node, StringBuilder sb) {\n        if (node == null) {\n            sb.append(NN).append(spliter);\n        } else {\n            sb.append(node.val).append(spliter);\n            buildString(node.left, sb);\n            buildString(node.right,sb);\n        }\n    }\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        Deque<String> nodes = new LinkedList<>();\n        nodes.addAll(Arrays.asList(data.split(spliter)));\n        return buildTree(nodes);\n    }\n    \n    private TreeNode buildTree(Deque<String> nodes) {\n        String val = nodes.remove();\n        if (val.equals(NN)) return null;\n        else {\n            TreeNode node = new TreeNode(Integer.valueOf(val));\n            node.left = buildTree(nodes);\n            node.right = buildTree(nodes);\n            return node;\n        }\n    }\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453160006","body":"class Triplet<F, S, T> {\n\n    public final F first;\n    public final S second;\n    public final T third;\n\n    public Triplet(F first, S second, T third) {\n        this.first = first;\n        this.second = second;\n        this.third = third;\n    }\n}\n\nclass Solution {\n    List<Triplet<Integer, Integer, Integer>> nodeList = new ArrayList<>();\n\n    private void DFS(TreeNode node, Integer row, Integer column) {\n        if (node == null)\n            return;\n        nodeList.add(new Triplet(column, row, node.val));\n        // preorder DFS traversal\n        this.DFS(node.left, row + 1, column - 1);\n        this.DFS(node.right, row + 1, column + 1);\n    }\n\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<List<Integer>> output = new ArrayList();\n        if (root == null) {\n            return output;\n        }\n\n        // step 1). DFS traversal\n        DFS(root, 0, 0);\n\n        // step 2). sort the list by <column, row, value>\n        Collections.sort(this.nodeList, new Comparator<Triplet<Integer, Integer, Integer>>() {\n            @Override\n            public int compare(Triplet<Integer, Integer, Integer> t1,\n                    Triplet<Integer, Integer, Integer> t2) {\n                if (t1.first.equals(t2.first))\n                    if (t1.second.equals(t2.second))\n                        return t1.third - t2.third;\n                    else\n                        return t1.second - t2.second;\n                else\n                    return t1.first - t2.first;\n            }\n        });\n\n        // step 3). extract the values, grouped by the column index.\n        List<Integer> currColumn = new ArrayList();\n        Integer currColumnIndex = this.nodeList.get(0).first;\n\n        for (Triplet<Integer, Integer, Integer> triplet : this.nodeList) {\n            Integer column = triplet.first, value = triplet.third;\n            if (column == currColumnIndex) {\n                currColumn.add(value);\n            } else {\n                output.add(currColumn);\n                currColumnIndex = column;\n                currColumn = new ArrayList();\n                currColumn.add(value);\n            }\n        }\n        output.add(currColumn);\n\n        return output;\n    }\n\n}\n\nTime Complexity: O(nlogn)\n\nSpace Complexity: O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455037192","body":"class Solution {\n\n    public int[] topKFrequent(int[] nums, int k) {\n        \n        if(nums.length == k) return nums;\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int x:nums){\n            map.put(x, map.getOrDefault(x, 0)+1);\n        }\n\n        Queue<Integer> queue = new PriorityQueue<>(\n            (a, b) -> map.get(a) - map.get(b) \n        );\n        for(int y : map.keySet()){\n            queue.add(y);\n            if(queue.size() > k){\n                queue.poll();\n            }\n        }\n\n        int result[] = new int[k];\n        for(int i=0; i < k; i++ ){\n            result[i] = queue.poll();\n        }\n        return result;\n    }\n\n}\n\nTime Complexity: O(Nlogk)\n\nSpace Complexity: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455791250","body":"class Solution {\r\n\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        HashMap<Integer, Integer> map = new HashMap();\r\n        int boomerangs = 0;\r\n        for (int[] p1 : points) {\r\n            for (int[] p2 : points) {\r\n                int dist = (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\r\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\r\n            }\r\n            for (Integer count : map.values())\r\n                boomerangs += count * (count - 1);\r\n            map.clear();\r\n        }\r\n        return boomerangs;\r\n    }\r\n\r\n}\r\n\r\nSpace Complexity: O(n)\r\n\r\nTime Complexity: O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457677454","body":"class Solution {\n\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length();\n        int start = 0, end = 0, maxLong = 0;\n        Set<Character> set = new HashSet<>();\n        while(end < n){\n            if(set.contains(s.charAt(end))){\n                set.remove(s.charAt(start));\n                start++;\n            }\n            else{\n                set.add(s.charAt(end));\n                end++;\n                maxLong = Math.max(maxLong, (end-start));\n            }\n        }\n        return maxLong;\n    }\n\n}\n\nSpace Complexity: O(s)\n\nTime Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459790942","body":"class Solution {\n\n    public List<Integer> findSubstring(String s, String[] words) {\n\n        if (words == null || words.length == 0)\n            return new ArrayList<>();\n\n        List<Integer> res = new ArrayList<>();\n        Map<String, Integer> map = new HashMap<>();\n\n        for (String word : words){\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int sLen = s.length(), wordLen = words[0].length(), count = words.length;\n\n        for (int i = 0; i < sLen - wordLen * count + 1; i++) {\n\n            String cur = s.substring(i, i + wordLen * count);\n            Map<String, Integer> temp = new HashMap<>();\n            int j;\n\n            for (j=0; j < cur.length(); j += wordLen) {\n\n                String word = cur.substring(j, j + wordLen);\n                if (!map.containsKey(word))\n                    break;\n\n                temp.put(word, temp.getOrDefault(word, 0) + 1);\n                if (temp.get(word) > map.get(word))\n                    break;\n            }\n\n            if (j == cur.length())\n                res.add(i);\n        }\n\n        return res;\n    }\n\n}\n\nTime: O(nmk)\nSpace:O(m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461575819","body":"class Solution {\n\n    public int minSubarray(int[] nums, int p) {\n        int tar = 0;\n        for (int n : nums){\n            tar += n;\n        }\n        tar = Math.floorMod(tar, p);\n        \n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n        int prefix = 0, res = nums.length;\n\n        for (int i = 0; i < nums.length; i++) {\n            prefix += nums[i];\n            int mod = Math.floorMod(prefix, p);\n            map.put(mod, i);\n            if (map.containsKey(Math.floorMod(prefix - tar, p))){\n                res = Math.min(res, i - map.get(Math.floorMod(prefix - tar, p)));\n            }\n        }\n\n        return res == nums.length ? -1 : res;\n    }\n\n}\n\nTime:\nO(n)\n\nSpace:\nO(min(n,k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463564796","body":"class Solution {\n\n    public ListNode middleNode(ListNode head) {\n        ListNode fast = head, slow = head;\n        while(fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n\n}\n\nTime: O(n)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464879389","body":"class Solution {\n\n    public int removeDuplicates(int[] nums) {\n        if(nums.length == 0){\n            return 0;\n        }\n\n        int fast = 1, slow = 0;\n        while(fast < nums.length){\n            if(nums[fast] != nums[slow]){\n                slow++;\n                nums[slow] = nums[fast];\n            }\n            fast++;\n        }\n        return slow + 1;\n    }\n\n}\n\nTime: O(n)\n\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465163593","body":"class Solution {\n\n    public int searchInsert(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        int mid;\n        while(left <= right){\n            mid = left + (right-left)/2;\n            if(nums[mid]==target){\n                return mid;\n            }\n            else if(target < nums[mid] ){\n                right = mid - 1;\n            }\n            else{\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n\n}\n\nTime: O(logn)\n\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465827442","body":"class Solution {\n\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int[] res = new int[nums.length-k+1];\n        Deque<Integer> deque = new ArrayDeque<>();\n\n        for(int i=0; i < nums.length; i++){\n            if(!deque.isEmpty() && deque.peekFirst() + k<= i){\n                deque.pollFirst();\n            }\n            while(!deque.isEmpty() && deque.peekLast() <= nums[i]){\n                deque.pollLast();\n            }\n            deque.offerLast(i);\n            if(i-k+1 >= 0){\n                res[i-k+1] = nums[deque.peekFirst()];\n            }\n        }\n        return res;\n    }\n\n}\n\nTime: O(n)\n\nSpace: O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467744974","body":"class Solution {\n\n    public int findJudge(int n, int[][] trust) {\n        int[] arr = new int[n+1];\n        for(int [] tmp : trust){\n            arr[tmp[0]]--;\n            arr[tmp[1]]++;\n        }\n\n        for(int i = 1; i < n+1; i++){\n            if(arr[i] == n-1){\n                return i;\n            }\n        }\n        return -1;\n    }\n\n}\n\nTime: O(n)\n\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469674127","body":"class Solution {\n\n    public boolean dfs(int node, int nodeColor, Map<Integer, List<Integer>> adj, int[] color) {\n        color[node] = nodeColor;\n        if (!adj.containsKey(node))\n            return true;\n        for (int neighbor : adj.get(node)) {\n            if (color[neighbor] == color[node])\n                return false;\n            if (color[neighbor] == -1) {\n                if (!dfs(neighbor, 1 - nodeColor, adj, color))\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        Map<Integer, List<Integer>> adj = new HashMap<>();\n        for (int[] edge : dislikes) {\n            int a = edge[0], b = edge[1];\n            adj.computeIfAbsent(a, value -> new ArrayList<Integer>()).add(b);\n            adj.computeIfAbsent(b, value -> new ArrayList<Integer>()).add(a);\n        }\n        int[] color = new int[n + 1];\n        Arrays.fill(color, -1); // 0 stands for red and 1 stands for blue.\n\n        for (int i = 1; i <= n; i++) {\n            if (color[i] == -1) {\n                // For each pending component, run DFS.\n                if (!dfs(i, 0, adj, color))\n                    // Return false, if there is conflict in the component.\n                    return false;\n            }\n        }\n        return true;\n    }\n\n}\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473763483","body":"class Solution {\n\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        for(char move: moves.toCharArray()) {\n            if(move == 'R') {\n                x++;\n            } else if(move == 'L') {\n                x--;\n            } else if(move == 'U') {\n                y++;\n            } else if(move == 'D') {\n                y--;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n\n}\n\nTime:\nO(n)\n\nSpace:\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474794207","body":"class Solution {\n\n    public int[] getOrder(int[][] tasks) {\n        int n = tasks.length;\n        int[] ans = new int[n];\n        int[][] extTasks = new int[n][3];\n        for(int i = 0; i < n; i++) {\n            extTasks[i][0] = i;\n            extTasks[i][1] = tasks[i][0];\n            extTasks[i][2] = tasks[i][1];\n        }\n        Arrays.sort(extTasks, (a,b)->a[1] - b[1]);\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[2] == b[2] ? a[0] - b[0] : a[2] - b[2]);\n        int time = 0;\n        int ai = 0;\n        int ti = 0;\n        while(ai < n) {\n            while(ti < n && extTasks[ti][1] <= time) {\n                pq.offer(extTasks[ti++]);\n\n            }\n            if(pq.isEmpty()) {\n                time = extTasks[ti][1];\n                continue;\n            }\n            int[] bestFit = pq.poll();\n            ans[ai++] = bestFit[0];\n            time += bestFit[2];\n        }\n        return ans;\n    }\n\n}\n\nTime:\nO(nlogn)\n\nSpace: \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475222626","body":"class Solution {\r\n\r\n    public int numberOfRounds(String startTime, String finishTime) {\r\n        Integer startHH = Integer.parseInt(startTime.substring(0,2));\r\n        Integer startMM = Integer.parseInt(startTime.substring(3));\r\n        Integer finishHH = Integer.parseInt(finishTime.substring(0,2));\r\n        Integer finishMM = Integer.parseInt(finishTime.substring(3));\r\n        \r\n        int start = startHH*60 +startMM;\r\n        int end = finishHH*60 +finishMM;\r\n        if (start > end) {\r\n           end += 24*60;\r\n        }\r\n        \r\n        return (int) Math.floor(end / 15.00) - (int) Math.ceil(start / 15.00);\r\n    }\r\n\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475932296","body":"   public int minCharacters(String a, String b) {\n\n        int m = a.length(), n = b.length(), res = m + n;\n        int[] c1 = new int[26], c2 = new int[26];\n        for (int i = 0; i < m; ++i)\n            c1[a.charAt(i) - 'a']++;\n        for (int i = 0; i < n; ++i)\n            c2[b.charAt(i) - 'a']++;\n\n        for (int i = 0; i < 26; ++i) {\n            res = Math.min(res, m + n - c1[i] - c2[i]); // condition 3\n            if (i > 0) {\n                c1[i] += c1[i - 1];\n                c2[i] += c2[i - 1];\n            }\n            if (i < 25) {\n                res = Math.min(res, m - c1[i] + c2[i]); // condition 1\n                res = Math.min(res, n - c2[i] + c1[i]); // condition 2\n            }\n        }\n        return res;\n\n    }\n\nTime: O(m + n)\nSpace: O(26)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477589947","body":"class Solution {\n\n    public int[] sortArray(int[] nums) {\n        \n        HashMap<Integer, Integer> counts = new HashMap<>();\n        int minVal = nums[0], maxVal = nums[0];\n\n        for(int i = 0; i < nums.length; i++){\n            minVal = Math.min(minVal, nums[i]);\n            maxVal = Math.max(maxVal, nums[i]);\n            counts.put(nums[i], counts.getOrDefault(nums[i], 0) + 1);\n        }\n\n        int index = 0;\n        for(int i = minVal; i <= maxVal;i++){\n            while(counts.getOrDefault(i, 0) > 0){\n                nums[index] = i;\n                index++;\n                counts.put(i, counts.get(i)-1);\n            }\n        }\n\n        return nums;\n    }\n\n}\n\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479232531","body":"class Solution {\n\n    public int mySqrt(int x) {\n        if(x < 2) return x;\n        int pin, left = 2, right = x/2;\n        while(left<= right){\n            pin = left + (right - left)/2;\n            long nums = (long)pin * pin;\n            if(nums > x){\n                right = pin - 1;\n            }\n            else if(nums < x){\n                left = pin + 1;\n            }\n            else{\n                return pin;\n            }\n        }\n        return right;\n    }\n\n}\n\nTime: O(logN)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480551733","body":"public class Solution extends VersionControl {\n\n    public int firstBadVersion(int n) {\n        int l = 1, r = n;\n        while(l <= r){\n            int m = l + (r - l)/2;\n            if(isBadVersion(m)){\n                r = m - 1;\n            }\n            else{\n                l = m + 1;\n            }\n        }\n        return l;\n    }\n\n}\n\nTime: O(logN)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482134000","body":"class Solution {\n\n    public int reversePairs(int[] nums) {\n        return mergeSort(nums, 0, nums.length-1);\n    }\n\n    public int mergeSort(int[] nums, int left, int right){\n        if(left >= right) return 0;\n        int mid = left + (right - left)/2;\n        int result = mergeSort(nums, left, mid);\n        result += mergeSort(nums, mid + 1, right);\n        result += merge(nums, left, mid, right);\n        return result;\n    }\n\n    public int merge(int[] nums, int left, int mid, int right){\n        int cnt = 0;\n        int j = mid + 1;\n        for(int i = left; i <= mid; i++){\n            while(j <= right && nums[i] > 2* (long)nums[j]){\n                j++;\n            }\n            cnt += (j - (mid + 1));\n        }\n\n        ArrayList<Integer> tempNum = new ArrayList<>();\n        int leftPin = left, rightPin = mid + 1;\n        while(leftPin <= mid && rightPin <= right){\n            if(nums[leftPin] <= nums[rightPin]){\n                tempNum.add(nums[leftPin++]);\n            }\n            else{\n                tempNum.add(nums[rightPin++]);\n            }\n        }\n\n        while(leftPin <= mid){\n            tempNum.add(nums[leftPin++]);\n        }\n\n        while(rightPin <= right){\n            tempNum.add(nums[rightPin++]);\n        }\n\n        for(int i=left; i <= right; i++){\n            nums[i] = tempNum.get(i-left);\n        }\n\n        return cnt; \n    }\n\n}\n\nTime: O(nlogn)\n\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483764048","body":"class Solution {\n\n    public double solve(int[] nums) {\n        Arrays.sort(nums);\n        int streetLength = nums[nums.length - 1] - nums[0];\n        int low = 0, high = streetLength / 3 + 1;\n        while (low + 1 < high) {\n            int mid = low + (high - low) / 2;\n            if (isPossible(nums, mid, 3)) {\n                high = mid;\n            } else {\n                low = mid;\n            }\n        }\n        if (isPossible(nums, low, 3)) {\n            return low / 2D;\n        }\n        return high / 2D;\n    }\n\n    private boolean isPossible(int[] nums, int diameter, int lightNumber) {\n        int lightDiameter = -1;\n        int currentLightNum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > lightDiameter) {\n                currentLightNum++;\n                lightDiameter = nums[i] + diameter;\n            }\n            if (currentLightNum > lightNumber) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1484029812","body":" \r\npublic int flipgame(int[] f, int[] b) {\r\n\r\n        HashSet<Integer> same = new HashSet<>();\r\n        for (int i = 0; i < f.length; ++i) if (f[i] == b[i]) same.add(f[i]);\r\n        int res = 3000;\r\n        for (int i : f) if (!same.contains(i)) res = Math.min(res, i);\r\n        for (int i : b) if (!same.contains(i)) res = Math.min(res, i);\r\n        return res % 3000;\r\n\r\n    }\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484847392","body":"class Solution {\n\n    public int swimInWater(int[][] grid) {\n        int N = grid.length;\n        int lo = grid[0][0], hi = N * N;\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (!possible(mi, grid)) {\n                lo = mi + 1;\n            } else {\n                hi = mi;\n            }\n        }\n        return lo;\n    }\n\n    public boolean possible(int T, int[][] grid) {\n        int N = grid.length;\n        Set<Integer> seen = new HashSet();\n        seen.add(0);\n        int[] dr = new int[]{1, -1, 0, 0};\n        int[] dc = new int[]{0, 0, 1, -1};\n\n        Stack<Integer> stack = new Stack();\n        stack.add(0);\n\n        while (!stack.empty()) {\n            int k = stack.pop();\n            int r = k / N, c = k % N;\n            if (r == N-1 && c == N-1) return true;\n\n            for (int i = 0; i < 4; ++i) {\n                int cr = r + dr[i], cc = c + dc[i];\n                int ck = cr * N + cc;\n                if (0 <= cr && cr < N && 0 <= cc && cc < N\n                        && !seen.contains(ck) && grid[cr][cc] <= T) {\n                    stack.add(ck);\n                    seen.add(ck);\n                }\n            }\n        }\n\n        return false;\n    }\n\n}\n\n\nTime:O((N^2)logN).\nSpace: O(N^2)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488297152","body":"class Solution {\n\n    public double new21Game(int n, int k, int maxPts) {\n        if(k==0) return 1.00;\n        if(k==1 && maxPts<=n) return 1.00;\n        double dp[] = new double[n+1];\n        dp[0] = 1.00;\n        double prev=0.00;\n        for(int i=1; i<=n; i++){\n            if((i-maxPts-1)>=0){\n                prev-=dp[i-1-maxPts];\n            }\n            if((i-1)<k){\n                prev+=dp[i-1];\n            }\n            dp[i]=prev/maxPts;            \n        }\n\n        double res = 0.00;\n        for(int i=k; i<=n; i++){\n            res+=dp[i];\n        }\n        return res;        \n    }\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489986492","body":"class Solution {\n\n    public List<Integer> findAnagrams(String s, String p) {\n        int sl = s.length(), pl = p.length();\n        if(sl < pl){\n            return new ArrayList();\n        }\n        \n        int[] pCount = new int[26];\n        int[] sCount = new int[26];\n        \n        for(char c : p.toCharArray()){\n            pCount[(int) (c - 'a')] ++;\n        }\n        \n        List<Integer> result = new ArrayList();\n        \n        for(int i = 0; i < sl; i++){\n            sCount[(int) (s.charAt(i) - 'a')]++;\n            if(i >= pl){\n                sCount[(int)(s.charAt(i - pl) - 'a')] -- ; \n            }\n            \n            if(Arrays.equals(pCount, sCount)){\n                result.add(i - pl + 1);\n            }\n        }\n        \n        return result;\n    }\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491522830","body":"class Solution {\r\n\r\n    public String minWindow(String s, String t) {\r\n\r\n        if (s.length() == 0 || t.length() == 0) {\r\n            return \"\";\r\n        }\r\n\r\n        Map<Character, Integer> dictT = new HashMap<Character, Integer>();\r\n\r\n        for (int i = 0; i < t.length(); i++) {\r\n            int count = dictT.getOrDefault(t.charAt(i), 0);\r\n            dictT.put(t.charAt(i), count + 1);\r\n        }\r\n\r\n        int required = dictT.size();\r\n\r\n        List<Pair<Integer, Character>> filteredS = new ArrayList<Pair<Integer, Character>>();\r\n        for (int i = 0; i < s.length(); i++) {\r\n            char c = s.charAt(i);\r\n            if (dictT.containsKey(c)) {\r\n                filteredS.add(new Pair<Integer, Character>(i, c));\r\n            }\r\n        }\r\n\r\n        int l = 0, r = 0, formed = 0;\r\n        Map<Character, Integer> windowCounts = new HashMap<Character, Integer>();\r\n        int[] ans = { -1, 0, 0 };\r\n\r\n        while (r < filteredS.size()) {\r\n            char c = filteredS.get(r).getValue();\r\n            int count = windowCounts.getOrDefault(c, 0);\r\n            windowCounts.put(c, count + 1);\r\n\r\n            if (dictT.containsKey(c) && windowCounts.get(c).intValue() == dictT.get(c).intValue()) {\r\n                formed++;\r\n            }\r\n\r\n            while (l <= r && formed == required) {\r\n                c = filteredS.get(l).getValue();\r\n\r\n                int end = filteredS.get(r).getKey();\r\n                int start = filteredS.get(l).getKey();\r\n                if (ans[0] == -1 || end - start + 1 < ans[0]) {\r\n                    ans[0] = end - start + 1;\r\n                    ans[1] = start;\r\n                    ans[2] = end;\r\n                }\r\n\r\n                windowCounts.put(c, windowCounts.get(c) - 1);\r\n                if (dictT.containsKey(c) && windowCounts.get(c).intValue() < dictT.get(c).intValue()) {\r\n                    formed--;\r\n                }\r\n                l++;\r\n            }\r\n            r++;\r\n        }\r\n        return ans[0] == -1 ? \"\" : s.substring(ans[1], ans[2] + 1);\r\n    }\r\n\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1492913133","body":"class Solution {\n\n    public int maxScore(int[] cardPoints, int k) {\n\n        int blockSize = cardPoints.length - k;\n        int sum = 0;\n        for(int i = 0; i< blockSize; i++){\n            sum += cardPoints[i];\n        }\n\n        int minSum = sum;\n        for(int i = blockSize; i < n; i++){\n            sum += cardPoints[i] - cardPoints[i - blockSize];\n            minSum = minSum < sum ? minSum : sum; \n        }\n\n        return Arrays.stream(cardPoints).sum() - minSum;\n    }\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493285890","body":"public class Solution {\n\n    public List<String> readBinaryWatch(int num) {\n        List<String> res = new ArrayList<>();\n        int[] nums1 = new int[]{8, 4, 2, 1}, nums2 = new int[]{32, 16, 8, 4, 2, 1};\n        for(int i = 0; i <= num; i++) {\n            List<Integer> list1 = generateDigit(nums1, i);\n            List<Integer> list2 = generateDigit(nums2, num - i);\n            for(int num1: list1) {\n                if(num1 >= 12) continue;\n                for(int num2: list2) {\n                    if(num2 >= 60) continue;\n                    res.add(num1 + \":\" + (num2 < 10 ? \"0\" + num2 : num2));\n                }\n            }\n        }\n        return res;\n    }\n\n    private List<Integer> generateDigit(int[] nums, int count) {\n        List<Integer> res = new ArrayList<>();\n        generateDigitHelper(nums, count, 0, 0, res);\n        return res;\n    }\n\n    private void generateDigitHelper(int[] nums, int count, int pos, int sum, List<Integer> res) {\n        if(count == 0) {\n            res.add(sum);\n            return;\n        }\n        \n        for(int i = pos; i < nums.length; i++) {\n            generateDigitHelper(nums, count - 1, i + 1, sum + nums[i], res);    \n        }\n    }\n\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495744222","body":"class Solution {\n\n    public int maxAreaOfIsland(int[][] grid) {\n        boolean[][] seen = new boolean[grid.length][grid[0].length];\n        int[] dr = new int[]{1, -1, 0, 0};\n        int[] dc = new int[]{0, 0, 1, -1};\n\n        int ans = 0;\n        for (int r0 = 0; r0 < grid.length; r0++) {\n            for (int c0 = 0; c0 < grid[0].length; c0++) {\n                if (grid[r0][c0] == 1 && !seen[r0][c0]) {\n                    int shape = 0;\n                    Stack<int[]> stack = new Stack();\n                    stack.push(new int[]{r0, c0});\n                    seen[r0][c0] = true;\n                    while (!stack.empty()) {\n                        int[] node = stack.pop();\n                        int r = node[0], c = node[1];\n                        shape++;\n                        for (int k = 0; k < 4; k++) {\n                            int nr = r + dr[k];\n                            int nc = c + dc[k];\n                            if (0 <= nr && nr < grid.length &&\n                                    0 <= nc && nc < grid[0].length &&\n                                    grid[nr][nc] == 1 && !seen[nr][nc]) {\n                                stack.push(new int[]{nr, nc});\n                                seen[nr][nc] = true;\n                            }\n                        }\n                    }\n                    ans = Math.max(ans, shape);\n                }\n            }\n        }\n        return ans;\n    }\n\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498719815","body":"    public int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {\n\n        int res = 0;\n        Queue<Integer> q = new LinkedList<>();\n        for (int i : initialBoxes)\n            if ((status[i] += 5000) > 5000)\n                q.add(i);\n        while (q.size() > 0) {\n            int b = q.remove();\n            res += candies[b];\n            for (int i : keys[b])\n                if ((status[i] += 5) == 5005)\n                    q.add(i);\n            for (int i : containedBoxes[b])\n                if ((status[i] += 5000) > 5000)\n                    q.add(i);\n        }\n        return res;\n\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1500207249","body":"class Solution {\n\n    public int maxSubArray(int[] nums) {\n        \n        int sum = nums[0];\n        int res = nums[0];\n        \n        for(int i = 1; i < nums.length; i++){\n            sum = Math.max(nums[i], sum + nums[i]);\n            res = Math.max(sum, res);\n            \n        }\n        \n        return res;\n    }\n\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501105433","body":"class Solution {\n\n    public int rob(int[] nums) {\n        \n        int rob = 0, notrob = 0;\n        for(int x: nums){\n            int temp = rob;\n            rob = notrob + x;\n            notrob = temp;\n        }\n        \n        return Math.max(rob, notrob);\n        \n    }\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501662376","body":"public int findNumberOfLIS(int[] nums) {\n\n        int n = nums.length, res = 0, max_len = 0;\n        int[] len =  new int[n], cnt = new int[n];\n        for(int i = 0; i<n; i++){\n            len[i] = cnt[i] = 1;\n            for(int j = 0; j <i ; j++){\n                if(nums[i] > nums[j]){\n                    if(len[i] == len[j] + 1)cnt[i] += cnt[j];\n                    if(len[i] < len[j] + 1){\n                        len[i] = len[j] + 1;\n                        cnt[i] = cnt[j];\n                    }\n                }\n            }\n            if(max_len == len[i])res += cnt[i];\n            if(max_len < len[i]){\n                max_len = len[i];\n                res = cnt[i];\n            }\n        }\n        return res;\n\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1503038397","body":"class Solution {\n\n    public int longestCommonSubsequence(String t1, String t2) {\n        int[] memo = new int[t2.length() + 1];\n        char[] t1c = t1.toCharArray(), t2c = t2.toCharArray();\n        for (int i = t1c.length - 1; i > -1; i--) {\n            int previousRigth = 0, newRight = 0;\n            for (int j = t2c.length - 1; j > -1; j--) {\n                int tmp = memo[j];\n                int max;\n                if (t1c[i] == t2c[j]) max = previousRigth + 1;\n                else max = Math.max(tmp, newRight);\n                memo[j] = newRight = max;\n                previousRigth = tmp;\n            }\n        }\n        return memo[0];\n    }\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1505046267","body":"class Solution {\n\n    public int uniquePaths(int m, int n) {\n        int dp[][] = new int[m][n];\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(i == 0 || j == 0){\n                    dp[i][j] = 1;\n                }\n                else{\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1];\n                }\n            }\n        }\n        return dp[m-1][n-1];\n    }\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506776573","body":"class Solution {\n\n    int[] dir1= {-2,-1,1,2,2,1,-1,-2};\n    int[] dir2= {1,2,2,1,-1,-2,-2,-1};\n    \n    public double knightProbability(int n, int k, int row, int col) {\n        if(k==0){\n            return 1.0;\n        }\n        double[][][] dp= new double[30][30][101];\n        \n        for(int i=0; i<30; i++){\n            for(int j=0; j<30; j++){\n                for(int l=0; l<101; l++){\n                    dp[i][j][l]= 0.0;\n                }\n            }\n        }\n        \n        return solve(n,k,row,col,dp);\n    }\n    \n    public boolean isValid(int i, int j, int n){\n        if(i<0 || j<0 || i>=n || j>=n){\n            return false;\n        }\n        \n        return true;\n    }\n    \n    public double solve(int n, int k, int i, int j, double[][][] dp){\n        if(k<=0){\n            return 1;\n        }\n        \n        if(i<0 || j<0 || i>=n || j>=n){\n            return 0.0;\n        }\n        \n        if(dp[i][j][k]!= 0.0){\n            return dp[i][j][k];\n        }\n        \n        double res=0.0;\n        double num= 1.0;\n        double denom= 8.0;\n        for(int l=0; l<8; l++){\n            int x= i+dir1[l];\n            int y= j+dir2[l];\n            if(isValid(x,y,n)){\n                res+= solve(n,k-1,x,y,dp)*(num/denom);\n            }\n        }\n        \n        return dp[i][j][k]= res;\n    }\n\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510170110","body":"class Solution {\n\n    int count = 0;\n    public int findTargetSumWays(int[] nums, int target) {\n        calculate(nums, 0, 0, target);\n        return count;\n    }\n    \n    public void calculate(int[] nums, int i, int sum, int target){\n        if(i == nums.length){\n            if(sum == target){\n                count++;\n            }\n        }\n        else{\n            calculate(nums, i + 1, sum + nums[i], target);\n            calculate(nums, i + 1, sum - nums[i], target);\n        }\n    }\n\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514975880","body":"class Solution {\n\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        \n        int i = 0, j = 0;\n        while(i < g.length && j < s.length){\n            if(g[i] <= s[j]){\n                i++;\n            }\n            j++;\n        }\n        return i;\n    }\n\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518633395","body":"class Solution {\n\n    public int numTrees(int n) {\n        int[] dp = new int[n+1];\n        dp[0] = 1;\n        dp[1] = 1;\n        for(int i = 2; i <= n; i++ ){\n            for(int j = 1; j <= i; j++){\n                dp[i] = dp[i] + dp[j-1] * dp[i-j];\n            }\n        }\n        return dp[n];\n    }\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519048598","body":"class Solution {\n\n    public ListNode mergeKLists(ListNode[] lists) {\n        \n        if(lists == null){\n            return null;\n        }\n        \n        int len = lists.length;\n        int interval = 1; \n        while(interval < len){\n            for(int i = 0; i + interval < len; i = i + 2 * interval){\n                lists[i] = merge(lists[i], lists[i+interval]);\n            }\n            interval = interval * 2;\n        }\n        return len != 0 ? lists[0] : null;\n    }\n    \n    public ListNode merge(ListNode l1, ListNode l2){\n        ListNode result = new ListNode(0);\n        ListNode tail = result;\n        \n        while(l1 != null && l2 != null){\n            if(l1.val < l2.val){\n                tail.next = l1;\n                l1 = l1.next;\n            }\n            else{\n                tail.next = l2;\n                l2 = l2.next;\n            }\n            tail = tail.next;\n        }\n        \n        if(l1 != null){\n            tail.next = l1;\n        }\n        else{\n            tail.next = l2;\n        }\n        return result.next;\n    }\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1520339767","body":"class Solution {\n\n    public int[] beautifulArray(int n) {\n        int[] ans = new int[n];\n        for(int i = 0; i  < n; i++){\n            ans[i] = i+1;\n        }\n        recursion(ans, 0, n-1);\n        return ans;\n    }\n    \n    public void recursion(int[] arr, int left, int right){\n        if(left >= right)\n            return;\n        ArrayList<Integer> l = new ArrayList<>();\n        ArrayList<Integer> r = new ArrayList<>();\n\t\t\n        boolean alt = true\n\t\t\t\t\t\t\t\n        for(int i = left; i <= right; i++){ \n            if(alt)\n                l.add(arr[i]);\n            else\n                r.add(arr[i]);\n            alt = !alt;\n        }\n\n        for(int i = left; i <= right; i++){ \n            if(!l.isEmpty())\n                arr[i] = l.remove(0);\n            else\n                arr[i] = r.remove(0);\n        }\n        recursion(arr, left, (right+left)/2);\n        recursion(arr, (left+right)/2+1, right);\n    }\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521445519","body":"class Solution {\n\n    public int[] singleNumber(int[] nums) {\n        int res = 0;\n\n        for(int i=0; i<nums.length;i++){\n            res ^= nums[i];\n        }\n\n        res = res & ~(res-1);\n        int bit = (int)(Math.log(res)/Math.log(2));\n        \n        int num1 = 0;\n        int num2 = 0;\n        \n        for(int i=0; i<nums.length;i++){\n            if((nums[i] & (1<<bit)) > 0) num1 ^= nums[i];\n            else num2 ^= nums[i];\n        }\n\n        return new int[] {num1,num2};\n    }\n\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528768903","body":"class Solution {\n\n    class Trie{\n        TrieNode root;\n        public Trie(String[] words){\n            root = new TrieNode();\n            for(String word : words){\n                TrieNode node = root;\n                for(char w : word.toCharArray()){\n                    int i = w - 'a';\n                    if(node.next[i] == null){\n                        node.next[i] = new TrieNode();\n                    }\n                    node = node.next[i];\n                }\n                node.end = word;\n            }\n        }\n\n        public List<String> search(String str){\n            TrieNode node = root;\n            List<String> res = new ArrayList<>();\n            for(char c : str.toCharArray()){\n                int i = c - 'a';\n                if(node.next[i] == null){\n                    break;\n                }\n                node = node.next[i];\n                if(node.end != null){\n                    res.add(node.end);\n                }\n            }\n            return res;\n        }  \n    }\n\n    class TrieNode{\n        String end;\n        TrieNode[] next = new TrieNode[26];\n    }\n\n\n    public int[][] multiSearch(String big, String[] smalls) {\n        Trie trie = new Trie(smalls);\n        Map<String, List<Integer>> hit = new HashMap<>();\n        for(int i = 0; i < big.length(); i++){\n            List<String> matchs = trie.search(big.substring(i));\n            for(String word: matchs){\n                if(!hit.containsKey(word)){\n                    hit.put(word, new ArrayList<>());\n                }\n                hit.get(word).add(i);\n            }\n        }\n        \n        int[][] res = new int[smalls.length][];\n        for(int i = 0; i < smalls.length; i++){\n            List<Integer> list = hit.get(smalls[i]);\n            if(list == null){\n                res[i] = new int[0];\n                continue;\n            }\n            int size = list.size();\n            res[i] = new int[size];\n            for(int j = 0; j < size; j++){\n                res[i][j] = list.get(j);\n            }\n        }\n        return res;\n    }\n\n\n}\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1536445151","body":"class Solution {\n\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<Integer> list = new ArrayList<>();\n        List<List<Integer>> result = new ArrayList<>();\n        if(candidates == null) {return result;}\n        Arrays.sort(candidates);\n        backtrack(candidates, result, list, target, 0);\n        return result;    \n    }\n    \n    private void backtrack(int[] candidates, List<List<Integer>> result, List<Integer> list, int target, int i){\n        if(target < 0){\n            return;\n        }\n        \n        if(target == 0){\n            result.add(new ArrayList<Integer>(list));\n            return;\n        }\n    \n        for(int p = i; p < candidates.length; p++){\n            \n            if(p > i && candidates[p-1] == candidates[p]){\n                continue;\n            }\n            \n            list.add(candidates[p]);\n            backtrack(candidates, result, list, target-candidates[p], p + 1);\n            list.remove(list.size()-1);\n        }\n    }\n\n}","onTime":true},null,null,null,null,null,null,null,null,null,null],"huizsh":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429183316","body":"### 解题思路\n逐位相加\n\n### 代码\n\n```golang\nfunc addToArrayForm(A []int, K int) []int {\n    carry := 0\n    for i := len(A) - 1; i >= 0; i-- {\n        A[i], carry = (carry + A[i] + K % 10) % 10, (carry + A[i] + K % 10) / 10\n        K /= 10\n    }\n    B := make([]int, 0)\n    carry = carry + K\n    for carry > 0 {\n        B = append([]int{carry % 10}, B...)\n        carry /= 10\n    }\n    return append(B, A...)\n}\n```\n\n### 复杂度分析\n时间复杂度：O(max(n, log k))\n空间复杂度：O(max(n, log k))","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434713052","body":"```\nfunc decodeString(s string) string {\n    var stack []string\n    for i := 0; i < len(s); i++ {\n        c := string(s[i])\n        if c == \"]\" {\n            var repeatStr string\n            var repeatCount string\n            for len(stack) > 0 && stack[len(stack)-1] != \"[\" {\n                repeatStr = stack[len(stack)-1] + repeatStr\n                stack = stack[:len(stack)-1]\n            }\n    \n            stack = stack[:len(stack)-1]\n            for len(stack) > 0 && isNumeric(stack[len(stack)-1]) {\n                repeatCount = stack[len(stack)-1] + repeatCount\n                stack = stack[:len(stack)-1]\n            }\n            repeatCountInt, _ := strconv.Atoi(repeatCount)\n            stack = append(stack, strings.Repeat(repeatStr, repeatCountInt))\n        } else {\n            stack = append(stack, c)\n        }\n    }\n    return strings.Join(stack, \"\")\n}\n\nfunc isNumeric(s string) bool {\n    _, err := strconv.Atoi(s)\n    return err == nil\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435978918","body":"```\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc maxChunksToSorted(arr []int) int {\n    count_a := make(map[int]int)\n    count_b := make(map[int]int)\n    ans := 0\n\n    sortedArr := make([]int, len(arr))\n    copy(sortedArr, arr)\n    sort.Ints(sortedArr)\n\n    for i, val := range arr {\n        count_a[val]++\n        count_b[sortedArr[i]]++\n        if reflect.DeepEqual(count_a, count_b) {\n            ans++\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    arr := []int{4, 3, 2, 1, 0}\n    fmt.Println(maxChunksToSorted(arr))\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437036780","body":"```\nfunc rotateRight(head *ListNode, k int) *ListNode {\n    if head == nil || k == 0 {\n        return head\n    }\n\n    p1, p2 := head, head\n    count := 1\n    i := 0\n    for i < k {\n        if p2.Next != nil {\n            count++\n            p2 = p2.Next\n        } else {\n            k = k % count\n            i = -1\n            p2 = head\n        }\n        i++\n    }\n\n    for p2.Next != nil {\n        p1 = p1.Next\n        p2 = p2.Next\n    }\n\n    tmp := p1.Next\n    if tmp != nil {\n        p1.Next = nil\n        p2.Next = head\n        return tmp\n    }\n    return head\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441538956","body":"```\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    if headA == nil || headB == nil {\n        return nil\n    }\n\n    pA := headA\n    pB := headB\n    for pA != pB {\n        if pA == nil {\n            pA = headB\n        } else {\n            pA = pA.Next\n        }\n        if pB == nil {\n            pB = headA\n        } else {\n            pB = pB.Next\n        }\n    }\n\n    return pA\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443645578","body":"```\n\nfunc detectCycle(head *ListNode) *ListNode {\n    if head == nil {\n        return nil\n    }\n    slow, fast := head, head\n    for fast != nil && fast.Next != nil {\n        if slow == fast {\n            fast = head\n            for slow != fast {\n                slow = slow.Next\n                fast = fast.Next\n            }\n            return fast\n        }\n        slow = slow.Next\n        fast = fast.Next.Next\n    }\n    return nil\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445358315","body":"```\nfunc maxDepth(root *TreeNode) int {\n    if root == nil {\n        return 0\n    } else {\n        return int(math.Max(float64(maxDepth(root.Left)), float64(maxDepth(root.Right)))) + 1\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445649787","body":"```\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\n    if (p == nil && q == nil) {\n        return true\n    }\n    if (p == nil && q != nil) {\n        return false\n    }\n    if (p != nil && q == nil) {\n        return false\n    }\n    return p.Val == q.Val && isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447414650","body":"```\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc sumNumbers(root *TreeNode) int {\n    return dfs(root, 0)\n}\n\nfunc dfs(root *TreeNode, cur int) int {\n    if (root == nil) {\n        return 0\n    }\n    if (root.Left == nil && root.Right == nil) {\n        return cur*10 + root.Val\n    }\n    return dfs(root.Left, cur*10 + root.Val) + dfs(root.Right, cur*10 + root.Val)\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450373498","body":"```\nfunc findBottomLeftValue(root *TreeNode) int {\n    queue := []*TreeNode{root}\n    var res int\n    for len(queue) > 0 {\n        length := len(queue)\n        res = queue[0].Val\n        for i := 0; i < length; i++ {\n            cur := queue[0]\n            queue = queue[1:]\n            if cur.Left != nil {\n                queue = append(queue, cur.Left)\n            }\n            if cur.Right != nil {\n                queue = append(queue, cur.Right)\n            }\n        }\n    }\n    return res\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454699953","body":"```\nfunc twoSum(nums []int, target int) []int {\n\tnumsMap := map[int]int{}\n\tfor i, j := range nums {\n\t\tv, ok := numsMap[target-j]\n\t\tif ok {\n\t\t\treturn []int{i, v}\n\t\t}\n\t\tnumsMap[j] = i\n\t}\n\treturn nil\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457397953","body":"```\nfunc lengthOfLongestSubstring(s string) int {\n\tseen := make(map[byte]int)\n\tmaxLen, l, r := 0, 0, 0\n\tfor r < len(s) {\n\t\tif _, ok := seen[s[r]]; ok {\n\t\t\tlastPos := seen[s[r]]\n\t\t\tif lastPos >= l && lastPos <= r {\n\t\t\t\tl = lastPos + 1\n\t\t\t}\n\t\t}\n\t\tmaxLen = max(maxLen, r-l+1)\n\t\tseen[s[r]] = r\n\t\tr++\n\t}\n\treturn maxLen\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461483005","body":"```\nimport (\n    \"math\"\n)\n\nfunc minSubarray(nums []int, k int) int {\n    tar := 0\n\n    for _, n := range nums {\n        tar += n\n    }\n\n    tar = int(math.Mod(float64(tar), float64(k)))\n\n    mp := make(map[int]int)\n    mp[0] = -1\n\n    prefix, res := 0, len(nums)\n\n    for i := 0; i < len(nums); i++ {\n        prefix += nums[i]\n        mod := int(math.Mod(float64(prefix), float64(k)))\n        mp[mod] = i\n\n        if val, ok := mp[int(math.Mod(float64(prefix-tar), float64(k)))]; ok {\n            res = int(math.Min(float64(res), float64(i-val)))\n        }\n    }\n\n    if res == len(nums) {\n        return -1\n    }\n\n    return res\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465113569","body":"```\nfunc searchInsert(nums []int, target int) int {\n    left := 0\n    right := len(nums) - 1\n\n    for left <= right {\n        mid := (left + right) / 2\n        if nums[mid] == target {\n            return mid\n        } else if nums[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n\n    return left\n}\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473797498","body":"```\nfunc judgeCircle(moves string) bool {\n    x, y := 0, 0\n    for _, move := range moves {\n        if move == 'R' {\n            x++\n        } else if move == 'L' {\n            x--\n        } else if move == 'U' {\n            y++\n        } else if move == 'D' {\n            y--\n        }\n    }\n    return x == 0 && y == 0\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474629148","body":"```\npackage main\n\nimport (\n    \"container/heap\"\n    \"sort\"\n)\n\nfunc getOrder(tasks [][]int) []int {\n    n := len(tasks)\n    ans := make([]int, n)\n    extTasks := make([][3]int, n)\n    for i := 0; i < n; i++ {\n        extTasks[i] = [3]int{i, tasks[i][0], tasks[i][1]}\n    }\n    sort.Slice(extTasks, func(i, j int) bool {\n        return extTasks[i][1] < extTasks[j][1]\n    })\n    pq := make(PriorityQueue, 0)\n    time, ai, ti := 0, 0, 0\n    for ai < n {\n        for ti < n && extTasks[ti][1] <= time {\n            pq = append(pq, &Item{extTasks[ti][0], extTasks[ti][1], extTasks[ti][2]})\n            ti++\n        }\n        if len(pq) == 0 {\n            time = extTasks[ti][1]\n            continue\n        }\n        heap.Init(&pq)\n        bestFit := heap.Pop(&pq).(*Item)\n        ans[ai] = bestFit.value\n        ai++\n        time += bestFit.priority\n    }\n    return ans\n}\n\ntype Item struct {\n    value    int\n    priority int\n    index    int\n}\n\ntype PriorityQueue []*Item\n\nfunc (pq PriorityQueue) Len() int { return len(pq) }\n\nfunc (pq PriorityQueue) Less(i, j int) bool {\n    if pq[i].priority == pq[j].priority {\n        return pq[i].value < pq[j].value\n    }\n    return pq[i].priority < pq[j].priority\n}\n\nfunc (pq PriorityQueue) Swap(i, j int) {\n    pq[i], pq[j] = pq[j], pq[i]\n    pq[i].index = i\n    pq[j].index = j\n}\n\nfunc (pq *PriorityQueue) Push(x interface{}) {\n    n := len(*pq)\n    item := x.(*Item)\n    item.index = n\n    *pq = append(*pq, item)\n}\n\nfunc (pq *PriorityQueue) Pop() interface{} {\n    old := *pq\n    n := len(old)\n    item := old[n-1]\n    item.index = -1 // for safety\n    *pq = old[0 : n-1]\n    return item\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482031474","body":"‘‘‘\nfrom sortedcontainers import SortedList\nclass Solution:\n    def reversePairs(self, A):\n        d = SortedList()\n        ans = 0\n\n        for a in A:\n            i = d.bisect_right(a * 2)\n            ans += len(d) - i\n            d.add(a)\n        return ans\n‘‘‘","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1483994310","body":"class Solution:\n    def solve(self, A, k):\n        A.sort()\n        def count_not_greater(diff):\n            i = ans = 0\n            for j in range(1, len(A)):\n                while A[j] - A[i] > diff:\n                    i += 1\n                ans += j - i\n            return ans\n        l, r = 0, A[-1] - A[0]\n        k += 1 # zero based -> one based\n        while l <= r:\n            mid = (l + r) // 2\n            if count_not_greater(mid) >= k:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1487943683","body":"```\nclass Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        # 滑动窗口优化（固定窗口大小为 W 的滑动窗口）\n        dp = [0] * (K + W)\n        win_sum = 0\n        for i in range(K, K + W):\n            if i <= N:\n                dp[i] = 1\n            win_sum += dp[i]\n\n        for i in range(K - 1, -1, -1):\n            dp[i] = win_sum / W\n            win_sum += dp[i] - dp[i + W]\n        return dp[0]\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494242088","body":"```\n/**\n * @param {number} n\n * @return {number}\n * @param row 当前层\n * @param col 列\n * @param pie 左斜线\n * @param na 右斜线\n */\nconst totalNQueens = function (n) {\n  let res = 0;\n  const dfs = (n, row, col, pie, na) => {\n    if (row >= n) {\n      res++;\n      return;\n    }\n    // 将所有能放置 Q 的位置由 0 变成 1，以便进行后续的位遍历\n    // 也就是得到当前所有的空位\n    let bits = ~(col | pie | na) & ((1 << n) - 1);\n    while (bits) {\n      // 取最低位的1\n      let p = bits & -bits;\n      // 把P位置上放入皇后\n      bits = bits & (bits - 1);\n      // row + 1 搜索下一行可能的位置\n      // col ｜ p 目前所有放置皇后的列\n      // (pie | p) << 1 和 (na | p) >> 1) 与已放置过皇后的位置 位于一条斜线上的位置\n      dfs(n, row + 1, col | p, (pie | p) << 1, (na | p) >> 1);\n    }\n  };\n  dfs(n, 0, 0, 0, 0);\n  return res;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1505205824","body":"```\nfunc uniquePaths(m int, n int) int {\n    dp := make([][]int, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]int, n)\n        for j := 0; j < n; j++ {\n            if i == 0 || j == 0 {\n                dp[i][j] = 1\n            } else {\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n            }\n        }\n    }\n    return dp[m-1][n-1]\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506214085","body":"```\nclass Solution {\n\n    private int[][] dir = {{-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}};\n\n    public double knightProbability(int N, int K, int r, int c) {\n\n        double[][] dp = new double[N][N];\n        dp[r][c] = 1;\n\n        for (int step = 1; step <= K; step++) {\n\n            double[][] dpTemp = new double[N][N];\n\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                    for (int[] direction : dir) {\n\n                        int lastR = i - direction[0];\n                        int lastC = j - direction[1];\n                        if (lastR >= 0 && lastR < N && lastC >= 0 && lastC < N)\n                            dpTemp[i][j] += dp[lastR][lastC] * 0.125;\n                    }\n\n            dp = dpTemp;\n        }\n\n        double res = 0;\n\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                res += dp[i][j];\n\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1507891959","body":"```\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        if desiredTotal <= maxChoosableInteger:\n            return True\n        if sum(range(maxChoosableInteger + 1)) < desiredTotal:\n            return False\n        # picked 用于保存当前已经选择过的数。\n        # acc 表示当前累计的数字和\n        def backtrack(picked, acc):\n            if acc >= desiredTotal:\n                return False\n            if len(picked) == maxChoosableInteger:\n                # 说明全部都被选了，没得选了，返回 False， 代表输了。\n                return False\n            for n in range(1, maxChoosableInteger + 1):\n                if n not in picked:\n                    picked.add(n)\n                    # 对方有一种情况赢不了，我就选这个数字就能赢了，返回 true，代表可以赢。\n                    if not backtrack(picked, acc + n):\n                        picked.remove(n)\n                        return True\n                    picked.remove(n)\n            return False\n\n        # 初始化集合，用于保存当前已经选择过的数。\n        return backtrack(set(), 0)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510001634","body":"public int findTargetSumWays(int[] nums, int target) {\n\n    int sum = 0;\n    for (int num : nums)\n        sum += num;\n\n    if (sum < Math.abs(target))\n        return 0;\n\n    if (((sum + target) & 1) == 1)\n        return 0;\n\n    sum = (sum + target) / 2;\n    int[] dp = new int[sum + 1];\n    dp[0] = 1;\n\n    for (int i = 0; i < nums.length; i++)\n        for (int j = sum; j >= nums[i]; j--)\n            dp[j] = dp[j] + dp[j - nums[i]];\n\n    return dp[sum];","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1512281980","body":"class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n\n        for j in range(len(coins)):\n            for i in range(1, amount + 1):\n                if i >= coins[j]:\n                    dp[i] += dp[i - coins[j]]\n\n        return dp[-1]\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516348927","body":"class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        n = len(intervals)\n        if n == 0: return 0\n        dp = [1] * n\n        ans = 1\n        intervals.sort(key=lambda a: a[0])\n\n        for i in range(len(intervals)):\n            for j in range(i - 1, -1, -1):\n                if intervals[i][0] >= intervals[j][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n                    break # 由于是按照开始时间排序的, 因此可以剪枝\n\n        return n - max(dp)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521334130","body":"```\nclass Solution {\n    public int[] singleNumber(int[] nums) {\n\n        int xor = 0;\n        for (int i : nums)\n            xor ^= i;\n\n        int mask = 1;\n        while ((mask & xor) == 0)\n            mask <<= 1;\n\n        int[] res = new int[2];\n        for (int i : nums) {\n\n            if ((i & mask) == 0)\n                res[0] ^= i;\n            else\n                res[1] ^= i;\n        }\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1522800875","body":"```\nclass Solution {\n\n    public List<List<Integer>> subsets(int[] nums) {\n\n        List<List<Integer>> res = new LinkedList<>();\n\n        int start = 0, end = 1 << nums.length;\n\n        for (int sign = start; sign < end; sign++) {\n\n            List<Integer> list = new LinkedList<>();\n\n            for (int i = 0; i < nums.length; i++)\n                if (((1 << i) & sign) != 0)\n                    list.add(nums[i]);\n\n            res.add(list);\n        }\n\n        return res;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1526864206","body":"class MapSum:\n\n    def __init__(self):\n        self.m = {}\n    def insert(self, key, val):\n        self.m[key] = val\n\n    def sum(self, prefix):\n        count = 0\n        for key in self.m:\n            if key.startswith(prefix):\n                count += self.m[key]\n        return count\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528611637","body":"class Solution {\n\n    private Node root = new Node();\n\n    public int[][] multiSearch(String big, String[] smalls) {\n\n        int n = smalls.length;\n        // 初始化结果集\n        List<Integer>[] res = new List[n];\n        for(int i = 0 ; i < n ; i++)\n            res[i] = new ArrayList<>();\n        // 建树\n        for(int i = 0 ; i < smalls.length; i++)\n            insert(smalls[i], i);\n\n        for(int i = 0 ; i < big.length(); i++){\n\n            Node tmp = root;\n\n            for(int j = i ; j < big.length(); j++){\n                //不存在以该串为prefix的敏感词\n                if(tmp.children[big.charAt(j) - 'a'] == null)\n                    break;\n\n                tmp = tmp.children[big.charAt(j) - 'a'];\n\n                if(tmp.isWord)\n                    res[tmp.id].add(i);\n            }\n        }\n        // 返回二维数组\n        int[][] ret = new int[n][];\n\n        for(int i = 0 ; i < n ; i++){\n\n            ret[i] = new int[res[i].size()];\n\n            for(int j = 0 ; j < ret[i].length; j++)\n                ret[i][j] = res[i].get(j);\n        }\n\n        return ret;\n    }\n\n    private void insert(String word, int id){\n\n        Node tmp = root;\n\n        for(int i = 0; i < word.length(); i++){\n\n            if(tmp.children[word.charAt(i) - 'a'] == null)\n                tmp.children[word.charAt(i) - 'a'] = new Node();\n\n            tmp = tmp.children[word.charAt(i) - 'a'];\n        }\n\n        tmp.isWord = true;\n        tmp.id = id;\n    }\n\n    class Node {\n\n        Node[] children;\n        boolean isWord;\n        int id;\n\n        public Node() {\n\n            children = new Node[26];\n            isWord = false;\n            id = 0;\n        }\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1529778802","body":"class Solution {\n    \n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int n = graph.length;\n        UF uf = new UF(n);\n        for(int i=0;i<n;i++) {\n            for(int j=i+1;j<n;j++) {\n                if(graph[i][j]==1) {\n                    uf.union(i,j);\n                }\n            }\n        }\n        int[] count = new int[n];\n        for(int node: initial) {\n            count[uf.find(node)]++;\n        }\n        int ans=-1, ansSize=-1;\n        for(int node: initial) {\n            int root = uf.find(node);\n            if(count[root]==1) {\n                int currSize = uf.getSize(root);\n                if(currSize>ansSize) {\n                    ansSize=currSize;\n                    ans=node;\n                }\n                else if(currSize == ansSize && node < ans) {\n                    ans=node;\n                }\n            }\n        }\n        if(ans==-1) {\n            ans=n+1;\n            for(int node: initial) {\n                ans = Math.min(node,ans);\n            }\n        }\n        return ans;\n        \n    }\n    class UF {\n        int[] parent;\n        int[] size;\n        \n        public UF(int n) {\n            parent = new int[n];\n            size = new int[n];\n            for(int i=0;i<n;i++) {\n                parent[i]=i;\n                size[i]=1;\n            }\n        }\n        public int find(int x) {\n            while(parent[x]!=x) {\n                parent[x]=parent[parent[x]];\n                x=parent[x];\n            }\n            return parent[x];\n        }\n        public int getSize(int x) {\n            return size[find(x)];\n        }\n        public void union(int x, int y) {\n            int xroot = find(x);\n            int yroot = find(y);\n            if(xroot!=yroot) {\n                if(size[xroot]>size[yroot]) {\n                    parent[yroot]=xroot;\n                    size[xroot]+=size[yroot];\n                }\n                else {\n                    parent[xroot]=yroot;\n                    size[yroot]+=size[xroot];\n                }\n            }\n            \n        }\n        \n    }\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1537078378","body":"public List<List<Integer>> permuteUnique(int[] nums) {\n\n    List<List<Integer>> res = new ArrayList<>();\n\n    if (nums == null || nums.length == 0)\n        return res;\n\n    boolean[] visited = new boolean[nums.length];\n    Arrays.sort(nums);\n    dfs(nums, res, new ArrayList<Integer>(), visited);\n\n    return res;\n}\n\npublic void dfs(int[] nums, List<List<Integer>> res, List<Integer> tmp, boolean[] visited) {\n\n    if (tmp.size() == nums.length) {\n\n        res.add(new ArrayList(tmp));\n        return;\n    }\n\n    for (int i = 0; i < nums.length; i++) {\n\n        if (i > 0 && nums[i] == nums[i - 1] && visited[i - 1])\n            continue;\n\n        //backtracking\n        if (!visited[i]) {\n\n            visited[i] = true;\n            tmp.add(nums[i]);\n            dfs(nums, res, tmp, visited);\n            visited[i] = false;\n            tmp.remove(tmp.size() - 1);\n        }\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null],"chanceyliu":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429188828","body":"### 思路\r\n\r\n逐位相加，注意处理进位，将进位直接用 K 接收\r\n\r\n### 代码\r\n\r\n```typescript\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n  let res: number[] = [];\r\n  for (let i = num.length - 1; i >= 0; i--) {\r\n    let sum = num[i] + (k % 10);\r\n    // 给k消位\r\n    k = Math.floor(k / 10);\r\n    // 有进位\r\n    if (sum >= 10) {\r\n      k++;\r\n      sum -= 10;\r\n    }\r\n    console.log(sum);\r\n    res.push(sum);\r\n  }\r\n  for (; k > 0; k = Math.floor(k / 10)) {\r\n    res.push(k % 10);\r\n  }\r\n  return res.reverse();\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(max(n,log k)) 其中 N 为数组长度\r\n- 空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430857093","body":"### 思路\n\n两次遍历，从前往后，在从后往前取最小距离\n\n### 代码\n\n```typescript\nfunction shortestToChar(s: string, c: string): number[] {\n  const n = s.length;\n  const res = new Array(n).fill(0);\n\n  for (let i = 0, idx = -n; i < n; i++) {\n    if (s[i] === c) {\n      idx = i;\n    }\n    res[i] = i - idx;\n  }\n\n  for (let i = n - 1, idx = 2 * n; i >= 0; i--) {\n    if (s[i] === c) {\n      idx = i;\n    }\n    res[i] = Math.min(res[i], idx - i);\n  }\n\n  return res;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N) 其中 N 为数组长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432657977","body":"\n### 代码\n\n```typescript\n\nexport class CustomStack {\n  private data: any[];\n  private maxSize: number;\n\n  constructor(maxSize: number) {\n    this.data = [];\n    this.maxSize = maxSize;\n  }\n\n  push(x: number): void {\n    if (this.data.length < this.maxSize) {\n      this.data.push(x);\n    }\n  }\n\n  pop(): number {\n    console.log(this.data);\n    if (this.data.length === 0) {\n      return -1;\n    }\n    return this.data.pop();\n  }\n\n  increment(k: number, val: number): void {\n    for (let i = 0; i < Math.min(k, this.data.length); i++) {\n      this.data[i] += val;\n    }\n  }\n}\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：push、pop O(1) ; increment O(n)\n- 空间复杂度：O(maxSize)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434272307","body":"### 思路\n\n使用两个栈，分别存放重复次数和累加后的字符，针对特定的四种情况分别做处理，做好之前字符的记录工作，最后完成拼接\n\n### 代码\n\n```typescript\nfunction decodeString(s: string): string {\n  let numStack = [];\n  let strStack: string[] = [];\n  let num = 0;\n  let result = \"\";\n\n  for (const str of s) {\n    // 是数字\n    if (!isNaN(+str)) {\n      num = +(num + str);\n    } else if (str === \"[\") {\n      // 是[，就是字符重复的开始，所以将之前的记录存档\n      numStack.push(num);\n      num = 0;\n      strStack.push(result);\n      result = \"\";\n    } else if (str === \"]\") {\n      // 是]，就准备收口，返回重复后的字符\n      let report = numStack.pop();\n      result = strStack.pop() + result.repeat(report as number);\n    } else {\n      // 是字符串，就要拼接起来\n      result += str;\n    }\n  }\n\n  return result;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n) n为s字符长度\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1436474768","body":"\n### 思路\n\n使用两个栈，一个用来放主栈中颠倒过后的数据，这样只用 POP 方法，我们就能移出栈底部的元素\n\n### 代码\n\n```typescript\nclass MyQueue {\n  private intStack: any[];\n  private outStack: any[];\n\n  constructor() {\n    this.intStack = [];\n    this.outStack = [];\n  }\n\n  push(x: number): void {\n    this.intStack.push(x);\n  }\n\n  pop(): number {\n    if (!this.outStack.length) {\n      while (this.intStack.length) {\n        this.outStack.push(this.intStack.pop());\n      }\n    }\n    return this.outStack.pop();\n  }\n\n  peek(): number {\n    if (!this.outStack.length) {\n      while (this.intStack.length) {\n        this.outStack.push(this.intStack.pop());\n      }\n    }\n    return this.outStack[this.outStack.length - 1];\n  }\n\n  empty(): boolean {\n    return !this.intStack.length && !this.outStack.length;\n  }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：push 和 empty 为 O(1)，pop 和 peek 为 O(n)\n- 空间复杂度：O(n)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436667533","body":"### 代码\n\n```typescript\nclass ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}\n\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n  if (k === 0 || !head || !head.next) {\n    return head;\n  }\n  let n = 1;\n  let cur = head;\n  while (cur.next) {\n    cur = cur.next;\n    n++;\n  }\n\n  let add = n - (k % n);\n  if (add === n) {\n    return head;\n  }\n\n  cur.next = head;\n  while (add) {\n    cur = cur.next as ListNode;\n    add--;\n  }\n\n  const ret = cur.next;\n  cur.next = null;\n  return ret;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439547196","body":"### 代码\n\n```typescript\nclass ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}\n\nclass TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n  const arr: number[] = [];\n  while (head) {\n    arr.push(head.val);\n    head = head.next;\n  }\n\n  const buildBST = (start, end) => {\n    if (start > end) return null;\n    const mid = (start + end) >>> 1;\n    const root = new TreeNode(arr[mid]);\n    root.left = buildBST(start, mid - 1);\n    root.right = buildBST(mid + 1, end);\n    return root; // 返回当前子树\n  };\n\n  return buildBST(0, arr.length - 1);\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441279581","body":"### 代码\n\n```typescript\nexport class ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}\n\nfunction getIntersectionNode(\n  headA: ListNode | null,\n  headB: ListNode | null\n): ListNode | null {\n  const visited = new Set();\n  let temp = headA;\n  while (temp !== null) {\n    visited.add(temp);\n    temp = temp.next;\n  }\n  temp = headB;\n  while (temp !== null) {\n    if (visited.has(temp)) {\n      return temp;\n    }\n    temp = temp.next;\n  }\n  return null;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(m + n) m 和 n 分别为 headA 和 deadB 的长度\n- 空间复杂度：O(m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442714912","body":"### 代码\n\n```typescript\nexport class ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}\n\nfunction detectCycle(head: ListNode | null): ListNode | null {\n  const visited = new Set();\n  while (head !== null) {\n    if (visited.has(head)) {\n      return head;\n    }\n    visited.add(head);\n    head = head.next;\n  }\n  return null;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447488418","body":"### 代码\n\n```typescript\nexport class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n\nfunction sumNumbers(root: TreeNode | null): number {\n  // 结果\n  let result: number = 0;\n  // 临时数组\n  let temp: number[] = [];\n\n  const dfs = (node: TreeNode | null) => {\n    if (!node) {\n      return;\n    }\n    // 判断叶子节点，进行求和赋值\n    if (!node.left && !node.right) {\n      const strSum = temp.join(\"\") + `${node.val}`;\n      const numSum = Number(strSum);\n      result += numSum;\n      return;\n    }\n    // 普通节点纳入数组\n    temp.push(node.val);\n    if (node.left) {\n      dfs(node.left);\n    }\n    if (node.right) {\n      dfs(node.right);\n    }\n    // 只有当左右节点已经计算完成的时候，才进行回溯\n    temp.pop();\n  };\n\n  dfs(root);\n\n  return result;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449230412","body":"### 代码\n\n```typescript\nexport class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n\nfunction findBottomLeftValue(root: TreeNode | null): number {\n  let curVal = 0;\n  const dfs = (root: TreeNode | null, height: number) => {\n    if (!root) {\n      return;\n    }\n    height++;\n    dfs(root.left, height);\n    dfs(root.right, height);\n    if (height > curHeight) {\n      curHeight = height;\n      curVal = root.val;\n    }\n  };\n\n  let curHeight = 0;\n  dfs(root, 0);\n  return curVal;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1452827941","body":"### 代码\n\n```typescript\nclass TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n\nfunction verticalTraversal(root: TreeNode | null): number[][] {\n  const nodes = [];\n\n  const dfs = (node, row, col, nodes) => {\n    if (node === null) {\n      return;\n    }\n    nodes.push([col, row, node.val]);\n    dfs(node.left, row + 1, col - 1, nodes);\n    dfs(node.right, row + 1, col + 1, nodes);\n  };\n\n  dfs(root, 0, 0, nodes);\n  nodes.sort((tuple1, tuple2) => {\n    if (tuple1[0] !== tuple2[0]) {\n      return tuple1[0] - tuple2[0];\n    } else if (tuple1[1] !== tuple2[1]) {\n      return tuple1[1] - tuple2[1];\n    } else {\n      return tuple1[2] - tuple2[2];\n    }\n  });\n\n  const ans: number[][] = [];\n  let lastcol = -Number.MAX_VALUE;\n  for (const tuple of nodes) {\n    let col = tuple[0],\n      row = tuple[1],\n      value = tuple[2];\n    if (col !== lastcol) {\n      lastcol = col;\n      ans.push([]);\n    }\n    ans[ans.length - 1].push(value);\n  }\n  return ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1455937356","body":"### 代码\n\n```typescript\nfunction twoSum(nums: number[], target: number): number[] {\n  let helperMap: Map<number, number> = new Map();\n  let index: number | undefined;\n  let resArr: number[] = [];\n  for (let i = 0, length = nums.length; i < length; i++) {\n    index = helperMap.get(target - nums[i]);\n    if (index !== undefined) {\n      resArr = [i, index];\n    }\n    helperMap.set(nums[i], i);\n  }\n  return resArr;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455920004","body":"### 代码\n\n```typescript\nfunction numberOfBoomerangs(points: number[][]): number {\n  let ans = 0;\n  for (const p of points) {\n    const cnt = new Map();\n    for (const q of points) {\n      const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n      cnt.set(dis, (cnt.get(dis) || 0) + 1);\n    }\n    for (const [_, m] of cnt.entries()) {\n      ans += m * (m - 1);\n    }\n  }\n  return ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N \\* N) 其中 N 为数组长度\n- 空间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461906866","body":"\n### 代码\n\n```typescript\nfunction minSubarray(nums: number[], p: number): number {\n  let x = 0;\n  for (const num of nums) {\n    x = (x + num) % p;\n  }\n  if (x === 0) {\n    return 0;\n  }\n  const index = new Map();\n  let y = 0;\n  let res = nums.length;\n  for (let i = 0; i < nums.length; i++) {\n    index.set(y, i); // f[i] mod p = y，因此哈希表记录 y 对应的下标为 i\n    y = (y + nums[i]) % p;\n    if (index.has((y - x + p) % p)) {\n      res = Math.min(res, i - index.get((y - x + p) % p) + 1);\n    }\n  }\n  return res === nums.length ? -1 : res;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463488900","body":"### 代码\n\n```typescript\nexport class ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}\n\nfunction middleNode(head: ListNode | null): ListNode | null {\n  let n = 0;\n  let cur = head;\n  while (cur != null) {\n    ++n;\n    cur = cur.next;\n  }\n  let k = 0;\n  cur = head;\n  while (k < Math.trunc(n / 2)) {\n    ++k;\n    cur = cur?.next || null;\n  }\n  return cur;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465438483","body":"### 代码\n\n```typescript\nfunction searchInsert(nums: number[], target: number): number {\n  const n = nums.length;\n  let left = 0,\n    right = n - 1,\n    ans = n;\n  while (left <= right) {\n    let mid = ((right - left) >> 1) + left;\n    if (target <= nums[mid]) {\n      ans = mid;\n      right = mid - 1;\n    } else {\n      left = mid + 1;\n    }\n  }\n  return ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465435269","body":"### 代码\n\n```typescript\nfunction maxSlidingWindow(nums: number[], k: number): number[] {\n  const n = nums.length;\n  const q = [];\n  for (let i = 0; i < k; i++) {\n    while (q.length && nums[i] >= nums[q[q.length - 1]]) {\n      q.pop();\n    }\n    q.push(i);\n  }\n\n  const ans = [nums[q[0]]];\n  for (let i = k; i < n; i++) {\n    while (q.length && nums[i] >= nums[q[q.length - 1]]) {\n      q.pop();\n    }\n    q.push(i);\n    while (q[0] <= i - k) {\n      q.shift();\n    }\n    ans.push(nums[q[0]]);\n  }\n  return ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467431802","body":"\n### 代码\n\n```typescript\nfunction findJudge(n: number, trust: number[][]): number {\n  const inDegrees = new Array(n + 1).fill(0);\n  const outDegrees = new Array(n + 1).fill(0);\n  for (const edge of trust) {\n    const x = edge[0],\n      y = edge[1];\n    ++inDegrees[y];\n    ++outDegrees[x];\n  }\n  for (let i = 1; i <= n; ++i) {\n    if (inDegrees[i] === n - 1 && outDegrees[i] === 0) {\n      return i;\n    }\n  }\n  return -1;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469240933","body":"### 代码\n\n```typescript\nconst p = new Array<number>(4010).fill(0);\nfunction find(x: number): number {\n  if (p[x] != x) p[x] = find(p[x]);\n  return p[x];\n}\nfunction union(a: number, b: number): void {\n  p[find(a)] = p[find(b)];\n}\nfunction query(a: number, b: number): boolean {\n  return find(a) == find(b);\n}\n\nfunction possibleBipartition(n: number, dislikes: number[][]): boolean {\n  for (let i = 1; i <= 2 * n; i++) p[i] = i;\n  for (const info of dislikes) {\n    const a = info[0],\n      b = info[1];\n    if (query(a, b)) return false;\n    union(a, b + n);\n    union(b, a + n);\n  }\n  return true;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1475697103","body":"### 代码\n\n```typescript\nfunction judgeCircle(moves: string): boolean {\n  let table = {\n    U: 0,\n    D: 0,\n    R: 0,\n    L: 0,\n  };\n  for (let move of moves) {\n    table[move]++;\n  }\n  return table[\"U\"] == table[\"D\"] && table[\"R\"] == table[\"L\"];\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475726775","body":"### 代码\n\n```typescript\nfunction toMinutes(time: string) {\n  let [h, m] = time.split(\":\");\n  return Number(h) * 60 + Number(m);\n}\n\nfunction numberOfRounds(loginTime: string, logoutTime: string): number {\n  let m1 = toMinutes(loginTime),\n    m2 = toMinutes(logoutTime);\n\n  if (m1 > m2) {\n    m2 += 24 * 60;\n  }\n\n  let ans = Math.floor(m2 / 15) - Math.ceil(m1 / 15);\n  return ans < 0 ? 0 : ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475732403","body":"### 代码\n\n```typescript\nfunction minCharacters(a: string, b: string): number {\n  let da = new Array(26).fill(0);\n  let db = new Array(26).fill(0);\n  for (let i in a as any) {\n    da[a.charCodeAt(+i) - 97]++;\n  }\n  for (let i in b as any) {\n    db[b.charCodeAt(+i) - 97]++;\n  }\n  let an = a.length,\n    bn = b.length,\n    aSum = 0,\n    bSum = 0,\n    res = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < 25; i++) {\n    aSum += da[i];\n    bSum += db[i];\n    res = Math.min(\n      res,\n      an + bn - da[i] - db[i],\n      an - aSum + bSum,\n      bn - bSum + aSum\n    );\n  }\n  return Math.min(res, an + bn - da[25] - db[25]);\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1480530971","body":"### 思路\n\n插入排序\n\n### 代码\n\n```typescript\nfunction sortArray(nums: number[]): number[] {\n  const n = nums.length;\n  for (let i = 1; i < n; ++i) {\n    let j = i - 1;\n    const tmp = nums[i];\n    while (j >= 0 && tmp < nums[j]) {\n      nums[j + 1] = nums[j];\n      --j;\n    }\n    nums[j + 1] = tmp;\n  }\n  return nums;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：平均 O(n²)、最好 O(n)、最坏 O(n²)\n- 空间复杂度：O(1)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480538233","body":"### 代码\n\n```typescript\n/**\n * The knows API is defined in the parent class Relation.\n * isBadVersion(version: number): boolean {\n *     ...\n * };\n */\n\nvar solution = function (isBadVersion: any) {\n  return function (n: number): number {\n    let l = 0,\n      r = n;\n    while (l <= r) {\n      let m = Math.floor((l + r) / 2);\n      if (isBadVersion(m) && !isBadVersion(m - 1)) return m;\n      else isBadVersion(m) ? (r = m - 1) : (l = m + 1);\n    }\n    return -1;\n  };\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(logn) \n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482330961","body":"### 代码\n\n```typescript\nconst reversePairsRecursive = (nums, left, right) => {\n  if (left === right) {\n    return 0;\n  } else {\n    const mid = Math.floor((left + right) / 2);\n    const n1 = reversePairsRecursive(nums, left, mid);\n    const n2 = reversePairsRecursive(nums, mid + 1, right);\n    let ret = n1 + n2;\n\n    let i = left;\n    let j = mid + 1;\n    while (i <= mid) {\n      while (j <= right && nums[i] > 2 * nums[j]) {\n        j++;\n      }\n      ret += j - mid - 1;\n      i++;\n    }\n\n    const sorted = new Array(right - left + 1);\n    let p1 = left,\n      p2 = mid + 1;\n    let p = 0;\n    while (p1 <= mid || p2 <= right) {\n      if (p1 > mid) {\n        sorted[p++] = nums[p2++];\n      } else if (p2 > right) {\n        sorted[p++] = nums[p1++];\n      } else {\n        if (nums[p1] < nums[p2]) {\n          sorted[p++] = nums[p1++];\n        } else {\n          sorted[p++] = nums[p2++];\n        }\n      }\n    }\n    for (let k = 0; k < sorted.length; k++) {\n      nums[left + k] = sorted[k];\n    }\n    return ret;\n  }\n};\n\nfunction reversePairs(nums: number[]): number {\n  if (nums.length === 0) {\n    return 0;\n  }\n  return reversePairsRecursive(nums, 0, nums.length - 1);\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N log N)\n- 空间复杂度：O(N)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484671732","body":"### 代码\n\n```typescript\nconst check = (grid, threshold) => {\n  if (grid[0][0] > threshold) {\n    return false;\n  }\n  const n = grid.length;\n  const visited = new Array(n).fill(0).map(() => new Array(n).fill(false));\n  visited[0][0] = true;\n  const queue = [[0, 0]];\n\n  const directions = [\n    [0, 1],\n    [0, -1],\n    [1, 0],\n    [-1, 0],\n  ];\n  while (queue.length) {\n    const square = queue.shift() || [];\n    const i = square[0];\n    const j = square[1];\n\n    for (const direction of directions) {\n      const ni = i + direction[0],\n        nj = j + direction[1];\n      if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n        if (!visited[ni][nj] && grid[ni][nj] <= threshold) {\n          queue.push([ni, nj]);\n          visited[ni][nj] = true;\n        }\n      }\n    }\n  }\n  return visited[n - 1][n - 1];\n};\n\nfunction swimInWater(grid: number[][]): number {\n  const n = grid.length;\n  let left = 0,\n    right = n * n - 1;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    if (check(grid, mid)) {\n      right = mid;\n    } else {\n      left = mid + 1;\n    }\n  }\n  return left;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n2 logn)\n- 空间复杂度：O(n2)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1489877551","body":"### 代码\n\n```typescript\nfunction new21Game(n: number, k: number, maxPts: number): number {\n  let dp = new Array(k + maxPts).fill(0);\n  dp[n] = 1;\n  for (let i = n - 1; i >= 0; i--) {\n    if (i >= k && i <= n) {\n      dp[i] = 1;\n    }\n    if (i < k) {\n      for (let j = 1; j <= maxPts; j++) {\n        if (i + j <= n) {\n          dp[i] += dp[i + j] / maxPts;\n        }\n      }\n    }\n  }\n  return dp[0];\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489846001","body":"\n### 代码\n\n```typescript\nfunction findAnagrams(s: string, p: string): number[] {\n  const sLen = s.length,\n    pLen = p.length;\n\n  if (sLen < pLen) {\n    return [];\n  }\n\n  const ans: number[] = [];\n  const sCount = new Array(26).fill(0);\n  const pCount = new Array(26).fill(0);\n  for (let i = 0; i < pLen; ++i) {\n    ++sCount[s[i].charCodeAt(0) - \"a\".charCodeAt(0)];\n    ++pCount[p[i].charCodeAt(0) - \"a\".charCodeAt(0)];\n  }\n\n  if (sCount.toString() === pCount.toString()) {\n    ans.push(0);\n  }\n\n  for (let i = 0; i < sLen - pLen; ++i) {\n    --sCount[s[i].charCodeAt(0) - \"a\".charCodeAt(0)];\n    ++sCount[s[i + pLen].charCodeAt(0) - \"a\".charCodeAt(0)];\n\n    if (sCount.toString() === pCount.toString()) {\n      ans.push(i + 1);\n    }\n  }\n\n  return ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491798955","body":"### 代码\n\n```typescript\nfunction minWindow(s: string, t: string): string {\n  let l = 0;\n  let r = 0;\n  const need = new Map();\n  for (let c of t) {\n    need.set(c, need.has(c) ? need.get(c) + 1 : 1);\n  }\n\n  let needType = need.size;\n  let res = \"\";\n  while (r < s.length) {\n    let c = s[r];\n    if (need.has(c)) {\n      need.set(c, need.get(c) - 1);\n      if (need.get(c) === 0) needType -= 1;\n    }\n\n    while (needType === 0) {\n      const newRes = s.substring(l, r + 1);\n      if (!res || newRes.length < res.length) res = newRes;\n\n      const c2 = s[l];\n      if (need.has(c2)) {\n        need.set(c2, need.get(c2) + 1);\n        if (need.get(c2) === 1) needType += 1;\n      }\n      l += 1;\n    }\n    r += 1;\n  }\n  return res;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493567706","body":"### 代码\n\n```typescript\nfunction readBinaryWatch(turnedOn: number): string[] {\n  const ans = [];\n  for (let h = 0; h < 12; ++h) {\n    for (let m = 0; m < 60; ++m) {\n      if (\n        h.toString(2).split(\"0\").join(\"\").length +\n          m.toString(2).split(\"0\").join(\"\").length ===\n        turnedOn\n      ) {\n        ans.push(h + \":\" + (m < 10 ? \"0\" : \"\") + m);\n      }\n    }\n  }\n  return ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1493565652","body":"### 代码\n\n```typescript\nconst backtrack = (\n  n: number,\n  row: number,\n  columns: Set<any>,\n  diagonals1: Set<any>,\n  diagonals2: Set<any>\n) => {\n  if (row === n) {\n    return 1;\n  } else {\n    let count = 0;\n    for (let i = 0; i < n; i++) {\n      if (columns.has(i)) {\n        continue;\n      }\n      const diagonal1 = row - i;\n      if (diagonals1.has(diagonal1)) {\n        continue;\n      }\n      const diagonal2 = row + i;\n      if (diagonals2.has(diagonal2)) {\n        continue;\n      }\n      columns.add(i);\n      diagonals1.add(diagonal1);\n      diagonals2.add(diagonal2);\n      count += backtrack(n, row + 1, columns, diagonals1, diagonals2);\n      columns.delete(i);\n      diagonals1.delete(diagonal1);\n      diagonals2.delete(diagonal2);\n    }\n    return count;\n  }\n};\n\nfunction totalNQueens(n: number): number {\n  const columns = new Set();\n  const diagonals1 = new Set();\n  const diagonals2 = new Set();\n  return backtrack(n, 0, columns, diagonals1, diagonals2);\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N!)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1498553780","body":"### 代码\n\n```typescript\nfunction maxAreaOfIsland(grid: number[][]): number {\n  let row = grid.length;\n  let col = grid[0].length;\n  function dfs(x, y) {\n    //越界判断 当grid[x][y] === 0时 直接返回\n    if (x < 0 || x >= row || y < 0 || y >= col || grid[x][y] === 0) return 0;\n    grid[x][y] = 0; //当grid[x][y] === 1时，将当前单元格置为0\n    let ans = 1,\n      dx = [-1, 1, 0, 0],\n      dy = [0, 0, 1, -1]; //方向数组\n    for (let i = 0; i < dx.length; i++) {\n      //上下左右不断递归，计算每个岛屿的大小\n      ans += dfs(x + dx[i], y + dy[i]);\n    }\n    return ans;\n  }\n  let res = 0;\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < col; j++) {\n      res = Math.max(res, dfs(i, j)); //循环网格 更新最大岛屿\n    }\n  }\n  return res;\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1498556625","body":"### 代码\n\n```typescript\nfunction maxDistance(grid: number[][]): number {\n  if (grid.length < 2) return -1;\n  let n = grid.length;\n  // 创建 dp 状态矩阵\n  let dp = new Array(n);\n  for (let i = 0; i < n; i++) {\n    dp[i] = new Array(n);\n  }\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      dp[i][j] = grid[i][j] ? 0 : Infinity;\n    }\n  }\n  // 从左上向右下遍历\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j]) continue;\n      if (i - 1 >= 0) dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + 1);\n      if (j - 1 >= 0) dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + 1);\n    }\n  }\n  // 从右下向左上遍历\n  for (let i = n - 1; i >= 0; i--) {\n    for (let j = n - 1; j >= 0; j--) {\n      if (grid[i][j]) continue;\n      if (i + 1 < n) dp[i][j] = Math.min(dp[i][j], dp[i + 1][j] + 1);\n      if (j + 1 < n) dp[i][j] = Math.min(dp[i][j], dp[i][j + 1] + 1);\n    }\n  }\n  let ans = -1;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (!grid[i][j]) ans = Math.max(ans, dp[i][j]);\n    }\n  }\n  if (ans === Infinity) {\n    return -1;\n  } else {\n    return ans;\n  }\n}\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1499874285","body":"### 思路\n\n二叉树的垂序遍历做过\n\n### 代码\n\n```typescript\nclass TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n\nfunction verticalTraversal(root: TreeNode | null): number[][] {\n  const nodes = [];\n\n  const dfs = (node, row, col, nodes) => {\n    if (node === null) {\n      return;\n    }\n    nodes.push([col, row, node.val]);\n    dfs(node.left, row + 1, col - 1, nodes);\n    dfs(node.right, row + 1, col + 1, nodes);\n  };\n\n  dfs(root, 0, 0, nodes);\n  nodes.sort((tuple1, tuple2) => {\n    if (tuple1[0] !== tuple2[0]) {\n      return tuple1[0] - tuple2[0];\n    } else if (tuple1[1] !== tuple2[1]) {\n      return tuple1[1] - tuple2[1];\n    } else {\n      return tuple1[2] - tuple2[2];\n    }\n  });\n\n  const ans: number[][] = [];\n  let lastcol = -Number.MAX_VALUE;\n  for (const tuple of nodes) {\n    let col = tuple[0],\n      row = tuple[1],\n      value = tuple[2];\n    if (col !== lastcol) {\n      lastcol = col;\n      ans.push([]);\n    }\n    ans[ans.length - 1].push(value);\n  }\n  return ans;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1501343787","body":"### 代码\n\n```typescript\nfunction minCostClimbingStairs(cost: number[]): number {\n  const n = cost.length;\n  const dp = new Array(n + 1);\n  dp[0] = dp[1] = 0;\n  for (let i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n  }\n  return dp[n];\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n) \n- 空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501342655","body":"### 代码\n\n```typescript\nfunction rob(nums: number[]): number {\n  const len = nums.length;\n  if (len == 0) return 0;\n  const dp = new Array(len + 1);\n  dp[0] = 0;\n  dp[1] = nums[0];\n  for (let i = 2; i <= len; i++) {\n    dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);\n  }\n  return dp[len];\n}\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501340667","body":"### 代码\n\n```typescript\nfunction findNumberOfLIS(nums: number[]): number {\n  let n = nums.length,\n    maxLen = 0,\n    ans = 0;\n  const dp = new Array(n).fill(0);\n  const cnt = new Array(n).fill(0);\n  for (let i = 0; i < n; ++i) {\n    dp[i] = 1;\n    cnt[i] = 1;\n    for (let j = 0; j < i; ++j) {\n      if (nums[i] > nums[j]) {\n        if (dp[j] + 1 > dp[i]) {\n          dp[i] = dp[j] + 1;\n          cnt[i] = cnt[j]; // 重置计数\n        } else if (dp[j] + 1 === dp[i]) {\n          cnt[i] += cnt[j];\n        }\n      }\n    }\n    if (dp[i] > maxLen) {\n      maxLen = dp[i];\n      ans = cnt[i]; // 重置计数\n    } else if (dp[i] === maxLen) {\n      ans += cnt[i];\n    }\n  }\n  return ans;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n2) \n- 空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1504441827","body":"### 代码\n\n```typescript\nfunction uniquePaths(m: number, n: number): number {\n  const f = new Array(m).fill(0).map(() => new Array(n).fill(0));\n  for (let i = 0; i < m; i++) {\n    f[i][0] = 1;\n  }\n  for (let j = 0; j < n; j++) {\n    f[0][j] = 1;\n  }\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      f[i][j] = f[i - 1][j] + f[i][j - 1];\n    }\n  }\n  return f[m - 1][n - 1];\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(mn) m 和 n 是第一个和第二个参数\n- 空间复杂度：O(mn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506447621","body":"### 代码\n\n```typescript\nconst dirs = [\n  [-2, -1],\n  [-2, 1],\n  [2, -1],\n  [2, 1],\n  [-1, -2],\n  [-1, 2],\n  [1, -2],\n  [1, 2],\n];\n\nfunction knightProbability(\n  n: number,\n  k: number,\n  row: number,\n  column: number\n): number {\n  const dp = new Array(k + 1)\n    .fill(0)\n    .map(() => new Array(n).fill(0).map(() => new Array(n).fill(0)));\n  for (let step = 0; step <= k; step++) {\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < n; j++) {\n        if (step === 0) {\n          dp[step][i][j] = 1;\n        } else {\n          for (const dir of dirs) {\n            const ni = i + dir[0],\n              nj = j + dir[1];\n            if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n              dp[step][i][j] += dp[step - 1][ni][nj] / 8;\n            }\n          }\n        }\n      }\n    }\n  }\n  return dp[k][row][column];\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1512387982","body":"### 代码\n\n```typescript\nfunction canIWin(maxChoosableInteger: number, desiredTotal: number): boolean {\n  const memo = new Map();\n  const dfs = (\n    maxChoosableInteger,\n    usedNumbers,\n    desiredTotal,\n    currentTotal\n  ) => {\n    if (!memo.has(usedNumbers)) {\n      let res = false;\n      for (let i = 0; i < maxChoosableInteger; i++) {\n        if (((usedNumbers >> i) & 1) === 0) {\n          if (i + 1 + currentTotal >= desiredTotal) {\n            res = true;\n            break;\n          }\n          if (\n            !dfs(\n              maxChoosableInteger,\n              usedNumbers | (1 << i),\n              desiredTotal,\n              currentTotal + i + 1\n            )\n          ) {\n            res = true;\n            break;\n          }\n        }\n      }\n      memo.set(usedNumbers, res);\n    }\n    return memo.get(usedNumbers);\n  };\n  if (((1 + maxChoosableInteger) * maxChoosableInteger) / 2 < desiredTotal) {\n    return false;\n  }\n  return dfs(maxChoosableInteger, 0, desiredTotal, 0);\n}\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1512385753","body":"### 代码\n\n```typescript\nfunction canPartition(nums: number[]): boolean {\n  const n = nums.length;\n  if (n < 2) {\n    return false;\n  }\n  let sum = 0,\n    maxNum = 0;\n  for (const num of nums) {\n    sum += num;\n    maxNum = maxNum > num ? maxNum : num;\n  }\n  if (sum & 1) {\n    return false;\n  }\n  const target = Math.floor(sum / 2);\n  if (maxNum > target) {\n    return false;\n  }\n  const dp = new Array(target + 1).fill(false);\n  dp[0] = true;\n  for (const num of nums) {\n    for (let j = target; j >= num; --j) {\n      dp[j] |= dp[j - num];\n    }\n  }\n  return dp[target];\n}\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1512380364","body":"### 代码\n\n```typescript\nfunction findTargetSumWays(nums: number[], target: number): number {\n  let count = 0;\n  const backtrack = (nums, target, index, sum) => {\n    if (index === nums.length) {\n      if (sum === target) {\n        count++;\n      }\n    } else {\n      backtrack(nums, target, index + 1, sum + nums[index]);\n      backtrack(nums, target, index + 1, sum - nums[index]);\n    }\n  };\n\n  backtrack(nums, target, 0, 0);\n  return count;\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1512378086","body":"### 代码\n\n```typescript\nfunction coinChange(coins: number[], amount: number): number {\n  if (!amount) {\n    return 0;\n  }\n\n  let dp = Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n\n  for (let i = 0; i < coins.length; i++) {\n    for (let j = coins[i]; j <= amount; j++) {\n      dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j]);\n    }\n  }\n\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(amount * n) n 为 coins 数组长度\n- 空间复杂度：O(amount)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1512373694","body":"### 思路\n\n动态规划\n\n### 代码\n\n```typescript\nfunction change(amount: number, coins: number[]): number {\n  const dp = new Array(amount + 1).fill(0);\n  dp[0] = 1;\n  for (const coin of coins) {\n    for (let i = coin; i <= amount; i++) {\n      dp[i] += dp[i - coin];\n    }\n  }\n  return dp[amount];\n}\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(amount * n) n 为 coins 数组长度\n- 空间复杂度：O(amount)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514356374","body":"### 代码\n\n```typescript\nfunction findContentChildren(g: number[], s: number[]): number {\n  g.sort((a, b) => a - b);\n  s.sort((a, b) => a - b);\n  const m = g.length, n = s.length;\n  let count = 0;\n  for (let i = 0, j = 0; i < m && j < n; i++, j++) {\n      while (j < n && g[i] > s[j]) {\n          j++;\n      }\n      if (j < n) {\n          count++;\n      }\n  }\n  return count;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1517195665","body":"### 代码\n\n```typescript\nfunction eraseOverlapIntervals(intervals: number[][]): number {\n  if (!intervals.length) {\n    return 0;\n  }\n\n  intervals.sort((a, b) => a[1] - b[1]);\n\n  const n = intervals.length;\n  let right = intervals[0][1];\n  let ans = 1;\n  for (let i = 1; i < n; ++i) {\n    if (intervals[i][0] >= right) {\n      ++ans;\n      right = intervals[i][1];\n    }\n  }\n  return n - ans;\n}\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517192209","body":"### 思路\n\n贪心\n\n### 代码\n\n```typescript\nfunction canJump(nums: number[]): boolean {\n  let rightmost = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (rightmost >= nums.length - 1) {\n      return true;\n    }\n    if (i > rightmost) {\n      return false;\n    }\n    rightmost = Math.max(rightmost, i + nums[i]);\n  }\n  return false;\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1519297421","body":"### 代码\n\n```typescript\nfunction beautifulArray(n: number): number[] {\n  if (n === 1) return [1];\n  return [\n    ...beautifulArray(Math.ceil(n / 2)).map((i) => 2 * i - 1),\n    ...beautifulArray(Math.floor(n / 2)).map((i) => 2 * i),\n  ];\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1524590556","body":"\n### 思路\n\n哈希表\n\n### 代码\n\n```typescript\nfunction singleNumber(nums: number[]): number[] {\n  const obj = new Map()\n  const res: number[] = []\n  for (const i of nums) {\n    obj.set(i, (obj.get(i) || 0) + 1)\n  }\n\n  for (const [key, value] of obj.entries()) {\n    if (value === 1) {\n      res.push(key)\n    }\n  }\n\n  return res\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n) \n- 空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1524568178","body":"### 代码\n\n```typescript\nfunction subsets(nums: number[]): number[][] {\n  const ans: number[][] = [];\n  const n = nums.length;\n  for (let mask = 0; mask < 1 << n; ++mask) {\n    const t: number[] = [];\n    for (let i = 0; i < n; ++i) {\n      if (mask & (1 << i)) {\n        t.push(nums[i]);\n      }\n    }\n    ans.push(t);\n  }\n  return ans;\n}\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1524557859","body":"### 代码\n\n```typescript\nclass Trie {\n  private children: any;\n\n  constructor() {\n    this.children = {};\n  }\n\n  insert(word: string): void {\n    let node = this.children;\n    for (const ch of word) {\n      if (!node[ch]) {\n        node[ch] = {};\n      }\n      node = node[ch];\n    }\n    node.isEnd = true;\n  }\n\n  searchPrefix(prefix: string): any {\n    let node = this.children;\n    for (const ch of prefix) {\n      if (!node[ch]) {\n        return false;\n      }\n      node = node[ch];\n    }\n    return node;\n  }\n\n  search(word: string): boolean {\n    const node = this.searchPrefix(word);\n    return node !== undefined && node.isEnd !== undefined;\n  }\n\n  startsWith(prefix: string): boolean {\n    return this.searchPrefix(prefix);\n  }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * var obj = new Trie()\n * obj.insert(word)\n * var param_2 = obj.search(word)\n * var param_3 = obj.startsWith(prefix)\n */\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1534437571","body":"### 代码\n\n```typescript\nfunction treeNode(val?: any) {\n  this.val = val\n  this.children = {}\n}\n\nfunction multiSearch(big: string, smalls: string[]): number[][] {\n  const res = smalls.map(() => [])\n  if (!big) {\n    return res\n  }\n  let tree = new treeNode()\n  let now;\n  smalls.forEach((small, index) => {\n    now = tree;\n    for (let i = 0; i < small.length; i++) {\n      if (!now.children[small[i]]) {\n        now.children[small[i]] = new treeNode(small[i])\n      }\n      now = now.children[small[i]]\n    }\n    now.children['last'] = index\n  })\n\n  for (let i = 0; i < big.length; i++) {\n    let now = tree;\n    for (let j = i; j < big.length; j++) {\n      if (!now.children[big[j]]) {\n        break\n      }\n      now = now.children[big[j]]\n      if (now.children.last !== undefined) {\n        res[now.children.last].push(i)\n      }\n    }\n  }\n  return res\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1534415941","body":"### 代码\n\n```typescript\nconst dfs = (isConnected: number[][], visited: Set<unknown>, cities: number, i: number) => {\n  for (let j = 0; j < cities; j++) {\n    if (isConnected[i][j] == 1 && !visited.has(j)) {\n      visited.add(j);\n      dfs(isConnected, visited, cities, j);\n    }\n  }\n};\n\n\n\nfunction findCircleNum(isConnected: number[][]): number {\n  const cities = isConnected.length;\n  const visited = new Set();\n  let provinces = 0;\n  for (let i = 0; i < cities; i++) {\n    if (!visited.has(i)) {\n      dfs(isConnected, visited, cities, i);\n      provinces++;\n    }\n  }\n  return provinces;\n\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n*n) \n- 空间复杂度：O(n)\n","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1534403539","body":"### 代码\n\n```typescript\nconst dfs = (u, used, edges) => {\n  used[u] = 1;\n  if (edges.get(u)) {\n    for (const v of edges.get(u)) {\n      if (!used[v]) {\n        dfs(v, used, edges);\n      }\n    }\n  }\n}\n\n\nfunction makeConnected(n: number, connections: number[][]): number {\n  if (connections.length < n - 1) {\n    return -1;\n  }\n\n  const edges = new Map();\n  for (const [x, y] of connections) {\n    edges.get(x) ? edges.get(x).push(y) : edges.set(x, [y]);\n    edges.get(y) ? edges.get(y).push(x) : edges.set(y, [x]);\n  }\n\n  const used = new Array(n).fill(0);\n\n  let ans = 0;\n  for (let i = 0; i < n; i++) {\n    if (!used[i]) {\n      dfs(i, used, edges);\n      ans++;\n    }\n  }\n  return ans - 1;\n};\n```\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1534396146","body":"### 代码\n\n```typescript\nclass TreeNode {\n  val: number\n  left: TreeNode | null\n  right: TreeNode | null\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = (val === undefined ? 0 : val)\n    this.left = (left === undefined ? null : left)\n    this.right = (right === undefined ? null : right)\n  }\n}\n\nfunction pruneTree(root: TreeNode | null): TreeNode | null {\n  if (!root) {\n    return null;\n  }\n  root.left = pruneTree(root.left);\n  root.right = pruneTree(root.right);\n  if (!root.left && !root.right && root.val === 0) {\n    return null;\n  }\n  return root;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n) \n- 空间复杂度：O(n)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1534385170","body":"### 代码\n\n```typescript\nfunction combinationSum(candidates: number[], target: number): number[][] {\n  const ans: number[][] = [];\n  const dfs = (target, combine, idx) => {\n    if (idx === candidates.length) {\n      return;\n    }\n    if (target === 0) {\n      ans.push(combine);\n      return;\n    }\n    // 直接跳过\n    dfs(target, combine, idx + 1);\n    // 选择当前数\n    if (target - candidates[idx] >= 0) {\n      dfs(target - candidates[idx], [...combine, candidates[idx]], idx);\n    }\n  };\n\n  dfs(target, [], 0);\n  return ans;\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1535925345","body":"### 代码\n\n```typescript\nfunction combinationSum2(candidates: number[], target: number): number[][] {\n  candidates.sort((a, b) => a - b);\n  const resArr: number[][] = [];\n  function backTracking(\n    candidates: number[],\n    target: number,\n    curSum: number,\n    startIndex: number,\n    route: number[]\n  ) {\n    if (curSum > target) return;\n    if (curSum === target) {\n      resArr.push(route.slice());\n      return;\n    }\n    for (let i = startIndex, length = candidates.length; i < length; i++) {\n      if (i > startIndex && candidates[i] === candidates[i - 1]) {\n        continue;\n      }\n      let tempVal: number = candidates[i];\n      route.push(tempVal);\n      backTracking(candidates, target, curSum + tempVal, i + 1, route);\n      route.pop();\n    }\n  }\n  backTracking(candidates, target, 0, 0, []);\n  return resArr;\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null],"hshen11":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429194671","body":"#思路\n1. 把A数给转成数字aNum\n2. 数字aNum和K相加得到数字sum\n3. sum再转成数组\n```\n public int[] getInt(int[] A, int K) {\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < A.length; i++) {\n            builder.append(A[i]);\n        }\n        String aString = builder.toString();\n        int aNum = Integer.valueOf(aString);\n        int sum = K + aNum;\n\n        String[] split = String.valueOf(sum).split(\"\");\n        int[] result = new int[split.length];\n        for (int i = 0; i < split.length; i++) {\n            result[i] = Integer.valueOf(split[i]);\n        }\n        return result;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431305704","body":"```java\n public int[] shortestToChar(String s, char c) {\n        char[] chars = s.toCharArray();\n        int n = chars.length;\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (chars[i] == c) {\n                list.add(i);\n            }\n              \n        }\n        int[] result = new int[n];\n        for (int i = 0; i < n; i++) {\n            int k = n;\n            for (int j = 0; j < list.size(); j++) {\n                int b = Math.abs(i - list.get(j));\n                k = k - b <= 0 ? k: b;\n            }\n            result[i] = k;\n        }\n\n        return result;\n\n    }\n```\n### 复杂度\n- 时间O(n)\n- 空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433035535","body":"## 思路\n数组模拟栈\n```java\npublic class CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n\n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n\n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n\n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n```\n## 复杂度分析\n- 参见官方题解\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434145289","body":"\n## 题目地址(394. 字符串解码)\n\nhttps://leetcode.cn/problems/decode-string/\n\n## 题目描述\n\n```\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n \n\n示例 1：\n\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n\n\n示例 2：\n\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n\n\n示例 3：\n\n输入：s = \"2[abc]3[cd]ef\"\n输出：\"abcabccdcdcdef\"\n\n\n示例 4：\n\n输入：s = \"abc3[cd]xyz\"\n输出：\"abccdcdcdxyz\"\n\n\n \n\n提示：\n\n1 <= s.length <= 30\ns 由小写英文字母、数字和方括号 '[]' 组成\ns 保证是一个 有效 的输入。\ns 中所有整数的取值范围为 [1, 300] \n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public String decodeString(String s) {\n        int k = 0;\n        Stack<Integer> kStack = new Stack<>();\n        Stack<StringBuilder> letterStack = new Stack<>();\n        StringBuilder res = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (c == '[') {\n                kStack.push(k);\n                k = 0;\n                letterStack.push(res);\n                res = new StringBuilder();\n            } else if (c == ']') {\n                int curr=  kStack.pop();\n                StringBuilder temp = new StringBuilder();\n                for (int i = 0; i < curr; i++) {\n                    temp.append(res);\n                }\n                res = letterStack.pop().append(temp);\n            } else if (Character.isDigit(c)) {\n                k = c - '0' + k * 10;\n            } else {\n                res.append(c);\n            }\n\n        }\n\n        return res.toString();\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436575647","body":"\n## 题目地址(61. 旋转链表)\n\nhttps://leetcode.cn/problems/rotate-list/\n\n## 题目描述\n\n```\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n\n \n\n示例 1：\n\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n\n\n示例 2：\n\n输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n\n\n \n\n提示：\n\n链表中节点的数目在范围 [0, 500] 内\n-100 <= Node.val <= 100\n0 <= k <= 2 * 109\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437730060","body":"\n## 题目地址(24. 两两交换链表中的节点)\n\nhttps://leetcode.cn/problems/swap-nodes-in-pairs/\n\n## 题目描述\n\n```\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n\n \n\n示例 1：\n\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n\n\n示例 2：\n\n输入：head = []\n输出：[]\n\n\n示例 3：\n\n输入：head = [1]\n输出：[1]\n\n\n \n\n提示：\n\n链表中节点的数目在范围 [0, 100] 内\n0 <= Node.val <= 100\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n\npublic ListNode swapPairs(ListNode head) {\n\t\t//递归的终止条件\n\t\tif(head==null || head.next==null) {\n\t\t\treturn head;\n\t\t}\n\t\t//假设链表是 1->2->3->4\n\t\t//这句就先保存节点2\n\t\tListNode tmp = head.next;\n\t\t//继续递归，处理节点3->4\n\t\t//当递归结束返回后，就变成了4->3\n\t\t//于是head节点就指向了4，变成1->4->3\n\t\thead.next = swapPairs(tmp.next);\n\t\t//将2节点指向1\n\t\ttmp.next = head;\n\t\treturn tmp;\n\t}\n\n\n    \n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为链表长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439644615","body":"## 参考官方\n```java\npublic TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    private TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left,mid);\n        root.right = buildTree(mid.next,right);\n        return root;\n    }\n\n    private ListNode getMedian(ListNode left, ListNode right) {\n        ListNode slow = left;\n        ListNode fast = left;\n        while (fast != right && fast.next != right) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441513004","body":"\n## 题目地址(160. 相交链表)\n\nhttps://leetcode.cn/problems/intersection-of-two-linked-lists/\n\n## 题目描述\n\n```\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n自定义评测：\n\n评测系统 的输入如下（你设计的程序 不适用 此输入）：\n\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\nlistA - 第一个链表\nlistB - 第二个链表\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\n\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\n\n \n\n示例 1：\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。\n\n\n \n\n示例 2：\n\n输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n示例 3：\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\n\n \n\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n1 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <= m\n0 <= skipB <= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]\n\n \n\n进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n先对两条链表扫描一遍，取两者长度，然后让长链表先走「两者长度的差值」，然后再同时走，遇到第一个节点就是答案\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA , ListNode headB ) {\n        int c1 = 0, c2 = 0;\n        ListNode t1 = headA, t2 = headB;\n        while (t1 != null && ++c1 > 0) t1 = t1.next;\n        while (t2 != null && ++c2 > 0) t2 = t2.next;\n        int sub = Math.abs(c1 - c2);\n        while (sub-- > 0) {\n            if (c1 > c2) headA = headA.next;\n            else headB = headB.next;\n        }\n       \n        while (headA != null&&headB!=null) {\n            if (headA.equals(headB)) return headA;\n            else {\n                headA = headA.next;\n                headB = headB.next;\n            }\n        }\n\n        return null;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(m+n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442907525","body":"## 思路\n快慢指针\n起始使用slow和fast作为快慢指针（slow每次走一步，fast每次走两步），起始均为head。若fast顺利走到结尾，说明链表无环，直接返回null；\n\n若两者成功相遇，说明链表有环。我们定义链表起点到环入口距离为x，环内节点数量为y。那么从链表起点到环入口的任意路径都能归纳成x+k * y（其中k>=0）。\n\n当两者首次相遇时，假设slow走的距离为d1，而fast走的距离为d2，根据速度的差定义可知d2=d1 * 2。同时根据「141.环形链表」结论，两者必然在环中相遇，并且一定是fast在环内从后面追上slow，因此d2相比于d1必然是多走了y的整数倍，即有d2=d1+m * y（其中m为圈数），即可推导出d1=m * y。\n\n同时根据链表起点到环入口的任意路径均表示为x+k * y，我们知道如果 slow再走x步会到达环入口，同时链表起点到环入口也是x步，因此我们可以复用fast，将其复位到链表起点，和slow一起每次往前一步，当两者再次相遇，必然是同时位于环口。\n```java\npublic ListNode detectCycle(ListNode head) {\n        ListNode fast = head, slow = head;\n        boolean flag = false;\n        while (!flag && fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) flag = true;\n        }\n        if (!flag) return null;\n        fast = head;\n        while (fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n```\n时间复杂度O(n)\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445222856","body":"## 思路\n将LRU翻译成大白话就是：当不得不淘汰某些数据时（通常是容量已满），选择最久未被使用的数据进行淘汰。题目让我们实现一个容量固定的LRUCache。如果插入数据时，发现容器已满时，则先按照LRU规则淘汰一个数据，再将新数据插入，其中「插入」和「查询」都算作一次“使用”。\n\n可以通过下面来理解，假设我们有容量为2的LRUCache和测试键值对[1-1，2-2，3-3]，将其按照顺序进行插入&查询；\n\n- 插入1-1，此时最新的使用数据为1-1\n- 插入2-2，此时最新使用数据为2-2\n- 查询1-1，此时最新使用数据为1-1\n- 插入3-3，由于容器已经达到容量，需要先淘汰已有的数据才能插入，这是会淘汰2-2，3-3成为最新使用的数据\n\n**键值对存储方面，我们可以使用「哈希表」来确保插入和查询的复杂度为O(1)。**\n\n另外我们还需要额外维护一个「使用顺序」序列。\n\n我们期望当「新数据被插入」或「发生键值查询」时，能够将当前键值对放到序列头部，这样当触发LRU淘汰时，只需要从序列尾部进行数据删除即可。\n\n**期望在O(1)复杂度内调整某个节点在序列中的位置，很自然想到双向链表。**\n\n**双向链表**\n\n具体的，我们使用哈希表来存储「键值对」，键值对的键作为哈希表的Key,而哈希表的Value则使用我们自己封装的Node类，Node同时作为双向链表的节点。\n\n- 插入：检查当前键值对是否已经存在于哈希表：\n\n  - 如果存在，则更新键值对，并将当前键值对所对应的**Node**节点调整到链表头部(refresh操作)\n  - 如果不存在，则检查哈希表容量是否已经到达容量：\n    - 没达到容量：插入哈希表，并将当前键值对所对应的**Node**节点调整到链表头部（refresh操作）\n    - 已到达容量：先从链表尾部找到待删除元素进行删除（delete操作），然后再插入哈希表，并将当前键值对所对应的Node节点调整到链表头部（refresh操作）\n\n- 查询：如果没在哈希表中找到该Key，直接返回-1；如果存在该Key，则将对应的值返回，并将当前键值对所对应的Node节点调整到链表头部（refresh操作）\n\n一些细节：\n\n* 为了减少双向链表左右节点的「判空」操作，我们预先建立两个「哨兵」节点head和tail。\n```java\npublic class LRUCache {\n    class Node {\n        int key, value;\n        Node pre, post;\n\n        public Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    int max;\n    Node head, tail;\n    Map<Integer, Node> map;\n\n    public LRUCache(int capacity) {\n         head = new Node(-1, -1);\n         tail = new Node(-1, -1);\n        head.post = tail;\n        tail.pre = head;\n        this.max = capacity;\n        map = new HashMap<>();\n    }\n\n    public int get(int key) {\n        if (map.containsKey(key)) {\n            Node node = map.get(key);\n            refresh(node);\n            return node.value;\n        }\n        return -1;\n    }\n\n    /*\n    检查当前键是否已经存在于哈希表\n    如果存在，则更新键值对，并将当前键值对所对应的Node节点调整到链表头部（refresh）操作\n    如果不存在，则检查哈希表是否到达容量：\n        没有到达容量，插入哈希表并将当前键所对应的Node调整到链表头部（refresh）操作\n        达到容量，先从链表尾部找到待删除的元素进行删除（delete）操作，然后再插入哈希表，并将\n          当前键值所对应的Node调整到链表头部（refresh）操作。\n\n    * */\n    public void put(int key, int value) {\n        Node node;\n        if (map.containsKey(key)) {\n            node = map.get(key);\n            node.value = value;\n        } else {\n            if (map.size() == max) {\n                Node del = tail.pre;\n                map.remove(del.key);\n                delete(del);\n            }\n            node = new Node(key, value);\n            map.put(key, node);\n        }\n        refresh(node);\n\n    }\n/*\nrefresh操作分为两步\n1.先将当前节点从双向链表中删除(如果该节点本身存在于双向链表中的话)\n2. 将当前节点添加到双向链表的头部\n* */\n    private void refresh(Node node) {\n        delete(node);\n        node.post = head.post;\n        node.pre = head;\n        head.post.pre = node;\n        head.post = node;\n\n    }\n\n    private void delete(Node node) {\n        if (node.pre != null && node.post != null) {\n            node.pre.post = node.post;\n            node.post.pre = node.pre;\n        }\n    }\n}\n```\n- 时间复杂度：各操作均为 O(1)\n- 空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445223851","body":"```java\n public int height(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(height(root.left), height(root.right)) + 1;\n\n    }\n```\n- 时间复杂度O(n)\n- 空间复杂度O(nlogn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445838300","body":"\n## 题目地址(100. 相同的树)\n\nhttps://leetcode.cn/problems/same-tree/\n\n## 题目描述\n\n```\n给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。\n\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n \n\n示例 1：\n\n输入：p = [1,2,3], q = [1,2,3]\n输出：true\n\n\n示例 2：\n\n输入：p = [1,2], q = [1,null,2]\n输出：false\n\n\n示例 3：\n\n输入：p = [1,2,1], q = [1,1,2]\n输出：false\n\n\n \n\n提示：\n\n两棵树上的节点数目都在范围 [0, 100] 内\n-104 <= Node.val <= 104\n```\n\n## 前置知识\n递归\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n     public boolean isSameTree(TreeNode p, TreeNode q) {\n          if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$，其中n为树的节点个数\n- 空间复杂度：$O(h)$，其中h为树的深度\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447930155","body":"\n## 题目地址(129. 求根节点到叶节点数字之和)\n\nhttps://leetcode.cn/problems/sum-root-to-leaf-numbers/\n\n## 题目描述\n\n```\n给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。\n\n每条从根节点到叶节点的路径都代表一个数字：\n\n例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。\n\n计算从根节点到叶节点生成的 所有数字之和 。\n\n叶节点 是指没有子节点的节点。\n\n \n\n示例 1：\n\n输入：root = [1,2,3]\n输出：25\n解释：\n从根到叶子节点路径 1->2 代表数字 12\n从根到叶子节点路径 1->3 代表数字 13\n因此，数字总和 = 12 + 13 = 25\n\n示例 2：\n\n输入：root = [4,9,0,5,1]\n输出：1026\n解释：\n从根到叶子节点路径 4->9->5 代表数字 495\n从根到叶子节点路径 4->9->1 代表数字 491\n从根到叶子节点路径 4->0 代表数字 40\n因此，数字总和 = 495 + 491 + 40 = 1026\n\n\n \n\n提示：\n\n树中节点的数目在范围 [1, 1000] 内\n0 <= Node.val <= 9\n树的深度不超过 10\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n  public int ans;\n\n    public int sumNumbers(TreeNode root) {\n        dfs(root, 0);\n        return ans;\n    }\n\n    public void dfs(TreeNode root, int last){\n        if(root == null) return;\n        if(root.left == null && root.right == null) {\n            ans += last * 10 + root.val;\n            return;\n        }\n        dfs(root.left, last * 10 + root.val);\n        dfs(root.right, last * 10 + root.val);\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n令 n 为节点总数， h 为树的高度。\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(h)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450250303","body":"\n## 题目地址(513. 找树左下角的值)\n\nhttps://leetcode.cn/problems/find-bottom-left-tree-value/\n\n## 题目描述\n\n```\n给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。\n\n假设二叉树中至少有一个节点。\n\n \n\n示例 1:\n\n输入: root = [2,1,3]\n输出: 1\n\n\n示例 2:\n\n输入: [1,2,3,4,null,5,6,null,null,7]\n输出: 7\n\n\n \n\n提示:\n\n二叉树的节点个数的范围是 [1,104]\n-231 <= Node.val <= 231 - 1 \n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n  Deque<TreeNode> d = new ArrayDeque<>();\n        d.addLast(root);\n        int ans = 0;\n        while (!d.isEmpty()) {\n            int sz = d.size();\n            ans = d.peek().val;\n            while (sz-- > 0) {\n                TreeNode poll = d.pollFirst();\n                if (poll.left != null) d.addLast(poll.left);\n                if (poll.right != null) d.addLast(poll.right);\n            }\n        }\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"horace7":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429210148","body":"### 思路\n从右往左依次相加，如果大于10则处理进位\n\n### 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n    // 把k转换为数组\n    k = (k+'').split('');\n    // 从右往左依次相加\n    let l1 = num.length - 1;\n    let l2 = k.length - 1;\n    // c作为进位\n    let c = 0, result = [];\n    while (l1 >= 0 || l2 >=0) {\n        const num1 = l1 >= 0 ? +num[l1] : 0;\n        const num2 = l2 >= 0 ? +k[l2] : 0;\n        const sum = num1 + num2 + c;\n        // c取十位，数组push个位\n        c = Math.floor(sum / 10);\n        result.unshift(sum % 10);\n        l1--;\n        l2--;\n    }\n    // 退出循环时如果c大于0\n    if (c > 0) result.unshift(c);\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431022168","body":"```javascript\nvar shortestToChar = function(s, c) {\n    let res = Array(s.length).fill(0);\n\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] !== c) {\n            res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1] + 1;\n        }\n    }\n\n    for (let i = s.length - 1; i >= 0; i--) {\n         if (res[i] === Infinity || res[i + 1] + 1 < res[i]) {\n             res[i] = res[i + 1] + 1;\n         }\n    }\n\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432706661","body":"### 思路\n可以直接用js中的方法实现\n\n### 复杂度\n`时间复杂度：push pop：O(1); inc: O(k)`\n\n`空间复杂度：O(maxSize)`\n\n### 代码\n\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.arr = [];\n    this.len = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.arr.length < this.len) this.arr.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n     return this.arr.pop() || -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    this.arr = this.arr.map((item, index) => index < k ? item + val : item)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434396620","body":"```javascript\nvar decodeString = function(s) {\n    // define num stock & str stock\n    let numStock = [];\n    let strStock = [];\n    let num = 0, res = '';\n\n    for (let item of s) {\n        if (!isNaN(item)) {\n            num = num * 10 + parseInt(item);\n        } else if (item === '[') { // 开始入栈\n            numStock.push(num);\n            strStock.push(res);\n            num = 0;\n            res = ''\n        } else if (item === ']') { // 开始出栈\n            // 拿到次数\n            const times = numStock.pop()\n            res = strStock.pop() + res.repeat(times)\n        } else {\n            res += item\n        }\n    }\n\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435476440","body":"```javascript\nvar MyQueue = function() {\n    this.os = []; // 出队栈\n    this.is = []; // 入队栈\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.is.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (!this.os.length) {\n        while(this.is.length) {\n            this.os.push(this.is.pop())\n        }\n    }\n    return this.os.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (!this.os.length) {\n        while(this.is.length) {\n            this.os.push(this.is.pop())\n        }\n    }\n    return this.os[this.os.length - 1]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.os.length && !this.is.length\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435996327","body":"```javascript\nvar maxChunksToSorted = function(arr) {\n    const stack = [];\n    for (const num of arr) {\n        if (stack.length === 0 || num >= stack[stack.length - 1]) {\n            stack.push(num);\n        } else {\n            const mx = stack.pop();\n            while (stack.length && stack[stack.length - 1] > num) {\n                stack.pop();\n            }\n            stack.push(mx);\n        }\n    }\n    return stack.length;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436687590","body":"```javascript\nvar rotateRight = function(head, k) {\n    if (!head || !head.next || k === 0) return head;\n    let point = head, len = 1;\n    while (point.next) {\n        len++;\n        point = point.next;\n    }\n    if (k % len === 0) return head;\n\n    let n = len - (k % len);\n    point.next = head;\n    while (n > 0) {\n        point = point.next;\n        n--;\n    }\n    let res = point.next;\n    point.next = null;\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438603949","body":"```javascript\nvar swapPairs = function(head) {\n    if (!head || !head.next) return head\n    let pre = head.next\n    let next = head\n    let tmp = pre.next\n    head = head.next\n    while (next.next) {\n        pre.next = next\n        next.next = tmp ? (tmp.next || tmp) : null\n        if (tmp) {\n            pre = tmp.next\n            next = tmp\n            tmp = pre ? pre.next : null\n        }\n    }\n    return head\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439794180","body":"```javascript\nvar sortedListToBST = function(head) {\n    const buildTree = function(head, tail) {\n        if (head === tail) return null\n        // 快慢指针\n        var p1 = head, p2 = head;\n        while(p2 !== tail) {\n            p2 = p2.next;\n            if (p2 !== tail) {\n                p1 = p1.next;\n                p2 = p2.next\n            }\n        }\n        var tree = new TreeNode(p1.val);\n        tree.left = buildTree(head, p1);\n        tree.right = buildTree(p1.next, tail);\n        return tree\n    }\n    return buildTree(head, null)\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443417268","body":"```javascript\nvar detectCycle = function(head) {\n  // 快慢指针初始化指向 head\n  let slow = head;\n  let fast = head;\n  // 快指针走到末尾时停止\n  while (fast && fast.next) {\n    // 慢指针走一步，快指针走两步\n    slow = slow.next;\n    fast = fast.next.next;\n    // 快慢指针相遇，说明含有环\n    if (slow == fast) {\n      // 任一一节点指向头节点\n      fast = head;\n      // 同步向前进\n      while (fast != slow) {\n        fast = fast.next;\n        slow = slow.next;\n      }\n      // 返回入口节点\n      return fast;\n    }\n  }\n  return null; \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445113706","body":"```javascript\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.size = capacity;\n    this.map = new Map();\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    let val = -1;\n    if (this.map.has(key)) {\n        val = this.map.get(key);\n        this.map.delete(key);\n        this.map.set(key, val);\n    }\n    return val;\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if (this.map.has(key)) {\n        this.map.delete(key);\n    }\n    this.map.set(key, value);\n    if (this.map.size > this.size) {\n        this.map.delete(this.map.keys().next().value);\n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445386256","body":"```javascript\nvar maxDepth = function (root) {\n  if (!root) return 0;\n  return Math.max(maxDepth(root.left) + 1, maxDepth(root.right) + 1);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446062081","body":"```javascript\nvar isSameTree = function(p, q) {\n  if (p == null || q == null) return p == q;\n  return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447898959","body":"```javascript\nconst sumNumbers = (root) => {\n  const helper = (root, cur) => {\n    if (root == null) {\n      return 0;\n    }\n    cur = 10 * cur + root.val;\n    if (root.left == null && root.right == null) {\n      return cur;\n    }\n    return helper(root.left, cur) + helper(root.right, cur);\n  };\n  return helper(root, 0);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449844245","body":"```javascript\nfunction findBottomLeftValue(root) {\n  let curLevel = [root];\n  while (curLevel.length) {\n    let nextLevel = [];\n    for (let i = 0; i < curLevel.length; i++) {\n      let node = curLevel[i];\n      node.left && nextLevel.push(node.left);\n      node.right && nextLevel.push(node.right);\n    }\n    if (!nextLevel.length) {\n      return curLevel[0].val;\n    }\n    curLevel = nextLevel;\n  }\n\n  return curLevel[0].val;\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454720829","body":"```javascript\nvar twoSum = function(nums, target) {\n    let map = new Map();\n    for(let i = 0 ; i < nums.length ; i++){\n        if(map.has(target - nums[i])) {\n            return [map.get(target - nums[i]), i];\n        } else{\n            map.set(nums[i], i);\n        }\n    }\n    return [];\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455888313","body":"```javascript\nvar numberOfBoomerangs = function (points) {\n  let res = 0;\n  for (const p of points) {\n    const map = new Map();\n    for (const q of points) {\n      const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n      map.set(dis, (map.get(dis) || 0) + 1);\n    }\n    for (const [_, m] of map.entries()) {\n      res += m * (m - 1);\n    }\n  }\n  return res;\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464864024","body":"```javascript\nvar removeDuplicates = function(nums) {\n    // 读写指针\n    let slow = 0;\n    let k = 1;\n    for(let i = 0; i < nums.length; i++) {\n        if(slow < k || nums[i] !== nums[slow - 1]) {\n            nums[slow] = nums[i];\n            slow++\n        }\n    }\n    return slow;\n};\n```\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467304125","body":"```javascript\nvar findJudge = function(n, trust) {\n    const cnts = new Array(n + 1), out = new Array(n + 1)\n    cnts.fill(0)\n    out.fill(0)\n    for(const t of trust){\n        cnts[t[1]]++\n        out[t[0]]++\n    }\n    for(let i = 1; i <= n; i++)\n        if(out[i] == 0 && cnts[i] == n - 1)\n            return i\n    return -1\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475692473","body":"```javascript\nvar minCharacters = function(a, b) {\n   const fA = new Array(26).fill(0);\n    const fB = new Array(26).fill(0);\n    const fC = new Array(26).fill(0);\n    for (let i = 0; i < a.length; ++i)\n        fA[a[i].charCodeAt(0) - 97]++;\n    for (let i = 0; i < b.length; ++i)\n        fB[b[i].charCodeAt(0) - 97]++;\n    const c = a + b;\n    for (let i = 0; i < c.length; ++i)\n        fC[c[i].charCodeAt(0) - 97]++;\n    let ans = _.sum(fC) - Math.max(...fC);\n    for (let i = 1; i < 26; ++i) {\n        ans = Math.min(ans, _.sum(fA.slice(0, i)) + _.sum(fB.slice(i)));\n        ans = Math.min(ans, _.sum(fB.slice(0, i)) + _.sum(fA.slice(i)));\n    }\n    \n    return ans;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477313660","body":"```javascript\nvar sortArray = function(nums) {\n    return nums.sort((a, b) => a - b)\n};\n```\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484416948","body":"```javascript\nconst swimInWater = function (grid) {\n    let left = 0,right = Math.max(...grid.flat())\n    const len = grid.length\n    while (left <= right) {\n        const mid = ((right - left) >> 1) + left\n        const set = new Set()\n        if (test(mid, 0, 0, set)) {\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n    return left\n\n    function test(mid, x, y, set) {\n        if (x < 0 || x > len - 1 || y < 0 || y > len - 1) return false\n        if (grid[x][y] > mid) return false\n        if (x === len - 1 && y === len - 1) return true\n        if (set.has(`${x}-${y}`)) return false\n        set.add(`${x}-${y}`)\n        return test(mid, x - 1, y, set) || test(mid, x + 1, y, set) || test(mid, x, y - 1, set) || test(mid, x, y + 1, set)\n    }\n\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzh0114":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429234314","body":"### 思路：  \n· 从低位到高位计算；  \n· 对k取整，将个位数与num[i]相加得到sum，k除10。  \n· 判断sum是否大于等于0，若true，除过10的k+1；将sum-10 push_back进列表；  \n· 若k比num长，经过上述循环后的k仍大于0，对k取整push_back后除10；  \n· reverse列表。    \n\n### 代码：  \n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for(int i = n - 1; i >= 0; --i){\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if(sum >= 10){\n                ++k;\n                sum -= 10;\n            }\n            res.push_back(sum);\n        }\n        while(k > 0){\n            res.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n\n### 复杂度分析：\n· 时间复杂度O(n)，n为列表长度；   \n· 空间复杂度O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431551686","body":"### 思路\n---\n### 代码      \n```cpp    \nclass Solution {\npublic:\n   vector<int> shortestToChar(string S, char C) {\n       vector<int> ans(S.size(), 0);\n       int prev = -10000;\n       for(int i = 0; i < S.size(); i ++){\n           if(S[i] == C) prev = i;\n           ans[i] = i - prev;\n       }\n       prev = 20000;\n       for(int i = S.size() - 1; i >= 0; i --){\n           if(S[i] == C) prev = i;\n           ans[i] = min(ans[i], prev - i);\n       }\n       return ans;\n   }\n};\n```   \n---      \n### 复杂度分析       \ntc:O(n)     \nsc:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433223214","body":"### 思路\n- 用vector实现      \n---\n### 代码    \n```cpp\nclass CustomStack {\nprivate:\n    vector<int> stack;\n    int maxSize_;\npublic:\n    CustomStack(int maxSize) {\n        maxSize_ = maxSize;\n        stack.reserve(maxSize);\n    }\n    \n    void push(int x) { \n        if (stack.size() >= maxSize_) {\n            return;\n        }\n        stack.push_back(x);\n    }\n    \n    int pop() {\n        if(!stack.empty()){\n            int top = stack.back();\n            stack.pop_back();\n            return top;\n        }\n        else return -1;\n    }\n    \n    void increment(int k, int val) {\n        if(stack.size() <= k){\n            for(int i = 0; i < stack.size(); i++){\n                stack[i] = stack[i] + val;\n            }\n        }\n        else{\n            for(int i = 0; i < k; i++){\n                stack[i] = stack[i] + val;\n            }\n        }\n    }\n};\n```\n---\n### 复杂度分析    \n- TC：O(N)，N为k    \n- SC：O(N)，N为maxSize\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434451645","body":"### 思路   \n- 题解\n---\n### 代码   \n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n    stack<int> numStack;\n    stack<string> resStack;\n    int num = 0;\n    string res;\n    for (int i = 0; i < s.size(); i++) {\n        if (isalpha(s[i])) {\n            res.push_back(s[i]);\n        } else if (isdigit(s[i])) {\n            num = num * 10 + s[i] - '0';\n        } else if (s[i] == '[') {\n            resStack.push(res);\n            res = \"\";\n            numStack.push(num);\n            num = 0;\n        } else {\n            for (int j = 0; j < numStack.top(); j++) {\n                resStack.top() += res;\n            }\n            numStack.pop();\n            res = resStack.top();\n            resStack.pop();\n        }\n    }\n    return res;\n}\n};\n```\n### 复杂度分析   \n- TC:O(N)\n- SC:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435639094","body":"### 思路\n- 构造正反两个方向的栈，在需要pop或peek队列时，访问反向栈的栈顶\n---\n### 代码\n```cpp\nclass MyQueue {\nprivate:\n    stack<int> pos;\n    stack<int> neg;\n\n    void pos2neg(){\n        while(!pos.empty()){\n            neg.push(pos.top());\n            pos.pop();\n        }    \n    }\npublic:\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        pos.push(x);\n    }\n    \n    int pop() {\n        if(neg.empty()) pos2neg();\n        int res = 0;\n        res = neg.top();\n        neg.pop();\n        return res;\n    }\n    \n    int peek() {\n        if(neg.empty()) pos2neg();\n        return neg.top();\n    }\n    \n    bool empty() {\n        return pos.empty() && neg.empty();\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(1)\n- SC:O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435958026","body":"### 思路\n- （题解）单调栈\n---\n### 代码\n```cpp\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> stack;\n        for(int i = 0; i < arr.size(); i++){\n            if(!stack.empty() && stack.top() > arr[i]){\n                int cur = stack.top();\n                while(!stack.empty() && stack.top() > arr[i]){\n                    stack.pop();\n                }\n                stack.push(cur);\n            }\n            else stack.push(arr[i]);\n        }\n        return stack.size();\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(N)\n- SC:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437201057","body":"### 思路\n- 闭合为环\n---\n### 代码\n```cpp\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (k == 0 || head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        int n = 1;\n        ListNode* iter = head;\n        while (iter->next != nullptr) {\n            iter = iter->next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter->next = head;\n        while (add--) {\n            iter = iter->next;\n        }\n        ListNode* ret = iter->next;\n        iter->next = nullptr;\n        return ret;\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(N)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438668716","body":"### 思路\n- 迭代\n---\n### 代码\n```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* dummyHead = new ListNode(0);\n        dummyHead->next = head;\n        ListNode* tmp = dummyHead;\n        while(tmp->next != nullptr && tmp->next->next != nullptr){\n            ListNode* n1 = tmp->next;\n            ListNode* n2 = tmp->next->next;\n            tmp->next = n2;\n            n1->next = n2->next;\n            n2->next = n1;\n            tmp = n1;\n        }\n        return dummyHead->next;\n        \n    }\n};\n```\n----\n### 复杂度分析\n- TC:O(N)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439885770","body":"### 思路\n- 题解\n----\n### 代码\n```cpp\nclass Solution {\npublic:\n    int getLength(ListNode* head) {\n        int ret = 0;\n        for (; head != nullptr; ++ret, head = head->next);\n        return ret;\n    }\n\n    TreeNode* buildTree(ListNode*& head, int left, int right) {\n        if (left > right) {\n            return nullptr;\n        }\n        int mid = (left + right + 1) / 2;\n        TreeNode* root = new TreeNode();\n        root->left = buildTree(head, left, mid - 1);\n        root->val = head->val;\n        head = head->next;\n        root->right = buildTree(head, mid + 1, right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        int length = getLength(head);\n        return buildTree(head, 0, length - 1);\n    }\n};\n```\n-----\n### 复杂度分析\n- TC:O(N)\n- SC:O(log n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441325526","body":"### 思路\n- 双指针\n----\n### 代码\n```cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *A = headA, *B = headB;\n        while (A != B) {\n            A = A != nullptr ? A->next : headB;\n            B = B != nullptr ? B->next : headA;\n        }\n        return A;\n    }\n};\n```\n----\n### 复杂度分析\n- TC:O(m+n)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443824184","body":"### 思路\n- 快慢指针\n---\n### 代码\n```cpp\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head, *fast = head;\n        while (fast != nullptr) {\n            slow = slow->next;\n            if (fast->next == nullptr) {\n                return nullptr;\n            }\n            fast = fast->next->next;\n            if (fast == slow) {\n                ListNode *ptr = head;\n                while (ptr != slow) {\n                    ptr = ptr->next;\n                    slow = slow->next;\n                }\n                return ptr;\n            }\n        }\n        return nullptr;\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(N)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445058006","body":"### 思路\n- （题解）双向链表＋哈希表\n---\n### 代码\n```cpp\nstruct DListNode{\n    int key, value;\n    DListNode* prev;\n    DListNode* next;\n    DListNode() : key(0), value(0), prev(nullptr), next(nullptr){}\n    DListNode(int _key, int _value):key(_key), value(_value), \n            prev(nullptr), next(nullptr){}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, DListNode*> map;\n    DListNode* head;\n    DListNode* tail;\n    int size;\n    int capacity;\n\npublic:\n    LRUCache(int _capacity): capacity(_capacity), size(0){\n        head = new DListNode();\n        tail = new DListNode();\n        head->next = tail;\n        tail->next = head;\n    }\n    \n    int get(int key) {\n        if(!map.count(key)){\n            return -1;\n        }\n        DListNode* node = map[key];\n        moveToHead(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        if(!map.count(key)){\n            DListNode* node = new DListNode(key, value);\n            map[key] = node;\n            addToHead(node);\n            ++size;\n            if(size > capacity){\n                DListNode* rm = removeTail();\n                map.erase(rm->key);\n                delete rm;\n                --size;\n            }\n        }\n        else{\n            DListNode* node = map[key];\n            node->value = value;\n            moveToHead(node);\n        }\n    }\n\n    void addToHead(DListNode* node){\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n\n    void removeNode(DListNode* node){\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void moveToHead(DListNode* node){\n        removeNode(node);\n        addToHead(node);\n    }\n\n    DListNode* removeTail(){\n        DListNode* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};\n```\n----\n### 复杂度分析\n- TC:(1)\n- SC:(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445311148","body":"### 思路\n- DFS\n-----\n### 代码\n```CPP\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr) return 0;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};\n```\n----\n### 时间复杂度\n- TC:O(N)\n- SC:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445917518","body":"### 思路\n- 递归\n---\n### 代码\n```cpp\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q) return true;\n        if(!p || !q) return false;\n        if(p->val != q->val) return false;\n        return isSameTree(p->left, q->left) \n            && isSameTree(p->right, q->right);\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(N)\n- SC:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447842742","body":"### 思路\n- 递归\n---\n### 代码\n```cpp\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        return helper(root ,0);\n    }\n\nprivate:\n    int helper(const TreeNode* root, int _val){\n        if(!root) return 0;\n        int ret = root->val + _val * 10;\n        if(!root->left && !root->right) return ret;\n        int l = helper(root->left, ret);\n        int r = helper(root->right, ret);\n        return l + r;\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(N)\n- SC:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450073125","body":"### 思路\n- BFS DFS\n---\n### 代码\n```cpp\n/*BFS*/\nclass Solution1 {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> Q;\n        TreeNode* ans = nullptr;\n        Q.push(root);\n        while(!Q.empty()){\n            ans = Q.front();\n            int size = Q.size();\n            while(size--){\n                TreeNode* curr = Q.front();\n                Q.pop();\n                if(curr->left) Q.push(curr->left);\n                if(curr->right) Q.push(curr->right);\n            }\n        }\n        return ans->val;\n    }\n};\n```\n```CPP\n/*DFS*/\nclass Solution2 {\n    public:\n        int ret;\n        int maxDepth = 0;\n        void dfs(TreeNode* root, int depth){\n            if(!root->left && !root->right){\n                if(depth > maxDepth){\n                    maxDepth = depth;\n                    ret = root->val;\n                }\n                return;\n            }\n            else{\n                if(root->left) dfs(root->left, depth + 1);\n                if(root->right) dfs(root->right,depth + 1);\n            }\n        }\n\n        int findBottomLeftValue(TreeNode* root) {\n            dfs(root, 1);\n            return ret;\n        }\n};\n```\n---\n### 复杂度分析\n- TC:O(N)，N为树的节点数\n- SC:O(N)，BFS中N为队列Q的长度，DFS中N为树的高度\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451340611","body":"### 思路\n- DFS\n---\n### 代码\n```cpp\nclass Codec {\npublic:\n    void tree2string(TreeNode* root, string& str){\n        if(!root){\n            str += \"null,\";\n        }\n        else{\n            str += to_string(root->val) + \",\";\n            tree2string(root->left, str);\n            tree2string(root->right, str);\n        }\n    }\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        string ret;\n        tree2string(root ,ret);\n        return ret;\n    }\n\n    TreeNode* string2tree(list<string>& list){\n        if(list.front() == \"null\"){\n            list.erase(list.begin());\n            return nullptr;\n        }\n        TreeNode* root = new TreeNode(stoi(list.front()));\n        list.erase(list.begin());\n        root->left = string2tree(list);\n        root->right = string2tree(list);\n        return root;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        list<string> dataList;\n        string str;\n        for(auto& ch : data){\n            if(ch == ','){\n                dataList.push_back(str);\n                str.clear();\n            }\n            else{\n                str.push_back(ch);\n            }\n        }\n        if(!str.empty()){\n            dataList.push_back(str);\n            str.clear();\n        }\n        return string2tree(dataList);\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(N)\n- SC:O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453202619","body":"### 思路\n- 题解\n---\n### 代码\n```cpp\nclass Solution {\npublic:\n    struct node\n    {\n        int val;\n        int x;\n        int y;\n        node(int v,int X,int Y):val(v),x(X),y(Y){};\n    };\n    static bool cmp(node a,node b)\n    {\n        if(a.x^b.x)\n            return a.x<b.x;\n        if(a.y^b.y)\n            return a.y<b.y;\n        return a.val<b.val;\n    }\n    vector<node> a;\n    int minx=1000,maxx=-1000;\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        dfs(root,0,0);\n        sort(a.begin(),a.end(),cmp);\n        vector<vector<int>>ans(maxx-minx+1);\n        for(auto xx:a)\n        {\n            ans[xx.x-minx].push_back(xx.val);\n        }\n        return ans;\n    }\n    void dfs(TreeNode* root,int x,int y)\n    {\n        if(root==nullptr)\n            return;\n        if(x<minx)\n            minx=x;\n        if(x>maxx)\n            maxx=x;\n        a.push_back(node(root->val,x,y));\n        dfs(root->left,x-1,y+1);\n        dfs(root->right,x+1,y+1);\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(NlogN)\n- SC:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454683532","body":"### 思路\n- 哈希表查找元素时间复杂度为O(1)\n---\n### 代码\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> map;\n        for(int i = 0; i < nums.size(); i++){\n            int tar = target - nums[i];\n            if(map.count(tar)) return {map[tar], i};\n            map[nums[i]] = i;\n        }\n        return {};\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(N)\n- SC:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455045562","body":"```cpp\nclass Solution {\npublic:\n    static bool cmp(pair<int, int>& m, pair<int, int>& n) {\n        return m.second > n.second;\n    }\n\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> occurrences;\n        for (auto& v : nums) {\n            occurrences[v]++;\n        }\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);\n        for (auto& [num, count] : occurrences) {\n            if (q.size() == k) {\n                if (q.top().second < count) {\n                    q.pop();\n                    q.emplace(num, count);\n                }\n            } else {\n                q.emplace(num, count);\n            }\n        }\n        vector<int> ret;\n        while (!q.empty()) {\n            ret.emplace_back(q.top().first);\n            q.pop();\n        }\n        return ret;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456156606","body":"### 代码\n```cpp\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>> &points) {\n        int ans = 0;\n        for (auto &p : points) {\n            unordered_map<int, int> cnt;\n            for (auto &q : points) {\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n                ++cnt[dis];\n            }\n            for (auto &[_, m] : cnt) {\n                ans += m * (m - 1);\n            }\n        }\n        return ans;\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(N^2)\n- SC:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457653788","body":"### 思路\n- 滑动窗口+哈希表\n---\n### 代码\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int ret = 0;\n        int start = 0;\n\n        unordered_map<char, int> map;\n\n        for(int i = 0; i < s.size(); i++){\n            char alpha = s[i];\n            if(map.count(alpha))\n                start = max(start, map[alpha]+1);\n            ret = max(ret, i-start+1);\n            map[alpha] = i;\n        }\n        return ret;\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(N)\n- SC:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460152453","body":"### 思路\n- 双哈希表\n---\n### 代码\n```cpp\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> ret;\n        int word_cnt = words.size();\n        if(word_cnt == 0) return {};\n        int word_size = words[0].size();\n\n        unordered_map<string, int> m1;\n        for(int i = 0; i < word_cnt; i++)\n            m1[words[i]]++;\n        \n        unordered_map<string, int> m2;\n        for(int j = 0; j + word_cnt * word_size <= s.size(); j++){\n            int k = 0;\n            for(k = j; k < j + word_cnt * word_size; k = k + word_size){\n                string tmp = s.substr(k, word_size);\n                if(m1[tmp] == 0)\n                    break;\n                else{\n                    m2[tmp]++;\n                    if(m1[tmp] < m2[tmp])\n                        break;\n                }\n            }\n            if(k == j + word_cnt * word_size)\n                ret.push_back(j);\n            m2.clear();\n        }\n        return ret;\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(n*m)，其中n为s的size，m为words中的单词数量\n- SC:O(m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462123201","body":"### 思路\n- 前缀和+哈希表\n---\n### 代码\n```cpp\nclass Solution {\npublic:\n    int minSubarray(vector<int>& nums, int p) {\n        long long allSum = 0;\n        for (auto& num : nums)\n            allSum += num;        \n        if (allSum < p) return -1;\n\n        int mod = 0;        \n        mod = allSum % p;\n        if (mod == 0) return 0;\n        unordered_map<int, int> dict; \n        dict[0] = -1;\n        const int len = nums.size();\n        int minLen = len;\n        long long preSum = 0;\n        for (int i = 0; i < len; i++)\n        {\n            preSum += nums[i];\n            int curMod = preSum % p;\n            int target = (curMod - mod + p) % p;\n            if (dict.count(target))\n                minLen = min(minLen, i - dict[target]);\n            dict[curMod] = i; \n        }\n        return minLen == len ? -1 : minLen;\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(N)\n- SC:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463125882","body":"### 思路\n- 快慢指针\n---\n### 代码\n```cpp\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while(fast && fast->next){\n            slow = slow->next;\n            fast = fast->next->next;    \n        }\n        return slow;\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(N)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464887256","body":"### 代码\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int diff = 0;\n        for(int i = 0; i < nums.size() - 1; i++){\n            if(nums[i] != nums[i + 1]){\n                diff++;\n                nums[diff] = nums[i+1];\n            }\n        }\n        return diff + 1;\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(N)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465144880","body":"### 思路\n- 二分查找\n---\n### 代码\n```cpp\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l = 0, r = nums.size() - 1;\n        while(l <= r){\n            int m = l + (r - l)/2;\n            if(nums[m] == target) return m;\n            else if (nums[m] < target) l = m + 1;\n            else r = m - 1;\n        }\n        return l;\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(logn)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466046144","body":"### 代码\n```cpp\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size();\n        priority_queue<pair<int, int>> q;\n        for (int i = 0; i < k; ++i) {\n            q.emplace(nums[i], i);\n        }\n        vector<int> ans = {q.top().first};\n        for (int i = k; i < n; ++i) {\n            q.emplace(nums[i], i);\n            while (q.top().second <= i - k) {\n                q.pop();\n            }\n            ans.push_back(q.top().first);\n        }\n        return ans;\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(nlogn)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468054219","body":"### 思路\n- 有向图中节点的入度和出度\n---\n### 代码\n```cpp\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        vector<int> inDegree(n + 1);\n        vector<int> outDegree(n + 1);\n\n        for(auto& edge : trust){\n            int x = edge[0];\n            int y = edge[1];\n            inDegree[y]++;\n            outDegree[x]++;\n        }\n        for(int i = 1; i <= n; i++){\n            if(inDegree[i] == n - 1 && outDegree[i] == 0)\n                return i;\n        }\n        return -1;\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(N)\n- SC:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469865399","body":"### 代码\n```cpp\nclass Solution {\npublic:\n    bool dfs(int curnode, int nowcolor, vector<int>& color, const vector<vector<int>>& g) {\n        color[curnode] = nowcolor;\n        for (auto& nextnode : g[curnode]) {\n            if (color[nextnode] && color[nextnode] == color[curnode]) {\n                return false;\n            }\n            if (!color[nextnode] && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<int> color(n + 1, 0);\n        vector<vector<int>> g(n + 1);\n        for (auto& p : dislikes) {\n            g[p[0]].push_back(p[1]);\n            g[p[1]].push_back(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```\n### 复杂度分析\n- TC:O(n+m)\n- SC:O(n+m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1471935944","body":"```cpp\nclass Solution {\npublic:\n    vector<int> topologicalSort(vector<vector<int>> &Adj, vector<int> &Indegree, int n){\n        vector<int> res;\n        queue<int> q;\n        for(int i = 0;i<n;i++){\n            if(Indegree[i]==0){\n                q.push(i);\n            }\n        }\n        while(!q.empty()){\n            int front = q.front();\n            q.pop();\n            res.push_back(front);\n            for(int successor: Adj[front]){\n                Indegree[successor]--;\n                if(Indegree[successor]==0){\n                    q.push(successor);\n                }\n            }\n        }\n        if(res.size()==n){return res;}\n        return vector<int>();\n    }\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        // 第 1 步：数据预处理，给没有归属于一个组的项目编上组号\n        for(int i=0;i<group.size();i++){\n            if(group[i] == -1){\n                group[i] = m;\n                m++;\n            }\n        }\n        // 第 2 步：实例化组和项目的邻接表\n        vector<vector<int>> groupAdj(m, vector<int>());\n        vector<vector<int>> itemAdj(n, vector<int>());\n\n        // 第 3 步：建图和统计入度数组\n        vector<int> groupsIndegree(m, 0);\n        vector<int> itemIndegree(n, 0);\n\n        int len = group.size();\n        for(int i=0;i<len;i++){\n            int currentGroup = group[i];\n            for(int beforeItem: beforeItems[i]){\n                int beforeGroup = group[beforeItem];\n                if(beforeGroup!=currentGroup){\n                    groupAdj[beforeGroup].push_back(currentGroup);\n                    groupsIndegree[currentGroup]++;\n                }\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int item: beforeItems[i]){\n                itemAdj[item].push_back(i);\n                itemIndegree[i]++;\n            }\n        }\n        // 第 4 步：得到组和项目的拓扑排序结果\n        vector<int> groupList = topologicalSort(groupAdj, groupsIndegree, m);\n        if(groupList.size()==0){\n            return vector<int> ();\n        }\n        vector<int> itemList = topologicalSort(itemAdj, itemIndegree, n);\n        if(itemList.size()==0){\n            return vector<int> ();\n        }\n        // 第 5 步：根据项目的拓扑排序结果，项目到组的多对一关系，建立组到项目的一对多关系\n        // key：组，value：在同一组的项目列表\n        map<int, vector<int>> group2Items;\n        for(int item: itemList){\n            group2Items[group[item]].push_back(item);\n        }\n        // 第 6 步：把组的拓扑排序结果替换成为项目的拓扑排序结果\n        vector<int> res;\n        for(int groupId: groupList){\n            vector<int> items = group2Items[groupId];\n            for(int item: items){\n                res.push_back(item);\n            }\n        }\n        return res;\n    } \n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473581289","body":"### 代码\n```cpp\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int x = 0, y = 0;\n        for (const auto& move: moves) {\n            if (move == 'U') {\n                y--;\n            }\n            else if (move == 'D') {\n                y++;\n            }\n            else if (move == 'L') {\n                x--;\n            }\n            else if (move == 'R') {\n                x++;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n};\n```\n### 复杂度分析\n- TC:O(N)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474785765","body":"### 代码\n```cpp\nclass Solution {\nprivate:\n    using PII = pair<int, int>;\n    using LL = long long;\n\npublic:\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        int n = tasks.size();\n        vector<int> indices(n);\n        iota(indices.begin(), indices.end(), 0);\n        sort(indices.begin(), indices.end(), [&](int i, int j) {\n            return tasks[i][0] < tasks[j][0];\n        });\n\n        vector<int> ans;\n        // 优先队列\n        priority_queue<PII, vector<PII>, greater<PII>> q;\n        // 时间戳\n        LL timestamp = 0;\n        // 数组上遍历的指针\n        int ptr = 0;\n        \n        for (int i = 0; i < n; ++i) {\n            // 如果没有可以执行的任务，直接快进\n            if (q.empty()) {\n                timestamp = max(timestamp, (LL)tasks[indices[ptr]][0]);\n            }\n            // 将所有小于等于时间戳的任务放入优先队列\n            while (ptr < n && tasks[indices[ptr]][0] <= timestamp) {\n                q.emplace(tasks[indices[ptr]][1], indices[ptr]);\n                ++ptr;\n            }\n            // 选择处理时间最小的任务\n            auto&& [process, index] = q.top();\n            timestamp += process;\n            ans.push_back(index);\n            q.pop();\n        }\n        \n        return ans;\n    }\n};\n```\n### 复杂度分析\n- TC:O(nlogn)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475163170","body":"### 代码\n```cpp\nclass Solution {\npublic:\n    int numberOfRounds(string startTime, string finishTime) {\n        int t0 = 60 * stoi(startTime.substr(0, 2)) + stoi(startTime.substr(3, 5));\n        int t1 = 60 * stoi(finishTime.substr(0, 2)) + stoi(finishTime.substr(3, 5));\n        if (t1 < t0){\n            t1 += 1440;\n        }\n        t1 = t1 / 15 * 15;\n        return max(0, (t1 - t0)) / 15;\n    }\n};\n```\n### 复杂度分析\n- TC:O(1)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476157792","body":"```cpp\nclass Solution {\npublic:\n    int minCharacters(string a, string b) {\n        int n = a.size(), m = b.size();\n        vector<int> va(26, 0), vb(26, 0);\n        for(char c : a) va[c - 'a']++;\n        for(char c : b) vb[c - 'a']++;\n        \n        int ret = n + m;\n        \n        int case1 = n + m;\n        for(int i = 0; i < 25; i++) {\n            int cur = 0;\n            for(int j = i + 1; j < 26; j++) cur += va[j];\n            for(int j = 0; j <= i; j++) cur += vb[j];\n            case1 = min(case1, cur);\n        }\n        ret = min(ret, case1);\n        \n        int case2 = n + m;\n        for(int i = 0; i < 25; i++) {\n            int cur = 0;\n            for(int j = i + 1; j < 26; j++) cur += vb[j];\n            for(int j = 0; j <= i; j++) cur += va[j];\n            case2 = min(case2, cur);\n        }\n        ret = min(ret, case2);\n        \n        int case3 = n + m;\n        for(int i = 0; i < 26; i++) {\n            int cur = 0;\n            for(int j = 0; j < 26; j++) {\n                if(j == i) continue;\n                cur += va[j] + vb[j];\n            }\n            case3 = min(case3, cur);\n        }\n        ret = min(ret, case3);\n        return ret;\n    }\n};\n```\n- TC:O(N)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477428762","body":"### 思路\n- 归并排序\n---\n### 代码\n```cpp\nclass Solution{\n    vector<int> tmp;\n    void mergeSort(vector<int>& nums, int l, int r) {\n        if (l >= r) return;\n        int mid = (l + r) >> 1;\n        mergeSort(nums, l, mid);\n        mergeSort(nums, mid + 1, r);\n        int i = l, j = mid + 1;\n        int cnt = 0;\n        while (i <= mid && j <= r) {\n            if (nums[i] <= nums[j]) {\n                tmp[cnt++] = nums[i++];\n            }\n            else {\n                tmp[cnt++] = nums[j++];\n            }\n        }\n        while (i <= mid) {\n            tmp[cnt++] = nums[i++];\n        }\n        while (j <= r) {\n            tmp[cnt++] = nums[j++];\n        }\n        for (int i = 0; i < r - l + 1; ++i) {\n            nums[i + l] = tmp[i];\n        }\n    }\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n       tmp.resize((int)nums.size(), 0);\n        mergeSort(nums, 0, (int)nums.size() - 1);\n        return nums;\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(nlogn)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479633325","body":"### 思路\n- 二分\n---\n### 代码\n```cpp\nclass Solution{\npublic:\n    int mySqrt(int x){\n        int l = 0, r = x, ans = -1;\n        while(l <= r){\n            int m = l + (r - l)/2;\n            if((long long)m * m <= x){\n                ans = m;\n                l = m + 1;\n            }\n            else r = m - 1;\n        }\n        return ans;\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(logn)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480458032","body":"### 思路\n- 二分\n---\n### 代码\n```cpp\n// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int l = 1, r = n;\n        while(l <= r){\n            int m = l + (r - l)/2;\n            if(isBadVersion(m))\n                r = m - 1;            \n            else\n                l = m + 1;\n        }\n        return l;\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(logn)\n- SC:O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482607758","body":"```cpp\nclass Solution {\npublic:\n    int reversePairsRecursive(vector<int>& nums, int left, int right) {\n        if (left == right) {\n            return 0;\n        } else {\n            int mid = (left + right) / 2;\n            int n1 = reversePairsRecursive(nums, left, mid);\n            int n2 = reversePairsRecursive(nums, mid + 1, right);\n            int ret = n1 + n2;\n            int i = left;\n            int j = mid + 1;\n            while (i <= mid) {\n                while (j <= right && (long long)nums[i] > 2 * (long long)nums[j]) j++;\n                ret += (j - mid - 1);\n                i++;\n            }\n            vector<int> sorted(right - left + 1);\n            int p1 = left, p2 = mid + 1;\n            int p = 0;\n            while (p1 <= mid || p2 <= right) {\n                if (p1 > mid) {\n                    sorted[p++] = nums[p2++];\n                } else if (p2 > right) {\n                    sorted[p++] = nums[p1++];\n                } else {\n                    if (nums[p1] < nums[p2]) {\n                        sorted[p++] = nums[p1++];\n                    } else {\n                        sorted[p++] = nums[p2++];\n                    }\n                }\n            }\n            for (int i = 0; i < sorted.size(); i++) {\n                nums[left + i] = sorted[i];\n            }\n            return ret;\n        }\n    }\n\n    int reversePairs(vector<int>& nums) {\n        if (nums.size() == 0) return 0;\n        return reversePairsRecursive(nums, 0, nums.size() - 1);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483769848","body":"```cpp\nclass Solution {\npublic:\n    int findRadius(vector<int> &houses, vector<int> &heaters) {\n        int ans = 0;\n        sort(heaters.begin(), heaters.end());\n        for (int house: houses) {\n            int j = upper_bound(heaters.begin(), heaters.end(), house) - heaters.begin();\n            int i = j - 1;\n            int rightDistance = j >= heaters.size() ? INT_MAX : heaters[j] - house;\n            int leftDistance = i < 0 ? INT_MAX : house - heaters[i];\n            int curDistance = min(leftDistance, rightDistance);\n            ans = max(ans, curDistance);\n        }\n        return ans;\n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1484028907","body":"```cpp\nclass Solution {\npublic:\n    int smallestDistancePair(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size(), left = 0, right = nums.back() - nums.front();\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            int cnt = 0;\n            for (int j = 0; j < n; j++) {\n                int i = lower_bound(nums.begin(), nums.begin() + j, nums[j] - mid) - nums.begin();\n                cnt += j - i;\n            }\n            if (cnt >= k) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n};\n```\n- TC:O(nlogn)\n- SC:O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484665994","body":"```cpp\nclass Solution {\npublic:\n    typedef pair<int, int> PII;\n    int dirs[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\n    int swimInWater(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int l = 0, r = n * n;\n        while (l < r) {\n            int mid = (l + r) >> 1;\n            if (dfs(grid, mid)) r = mid;\n            else l = mid + 1;\n        }\n        return l;\n    }\n\n    bool dfs(vector<vector<int>> &grid, int time) {\n        if (time < grid[0][0]) return false;\n        int n = grid.size();\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\n        queue<PII> que;\n        que.push({0, 0});\n        vis[0][0] = true;\n        while (!que.empty()) {\n            auto [i, j] = que.front();\n            que.pop();\n            for (auto dir : dirs) {\n                int x = i + dir[0];\n                int y = j + dir[1];\n                if (x < 0 || y < 0 || x >= n || y >= n) continue;\n                if (grid[x][y] > time || vis[x][y] == true) continue;\n                vis[x][y] = true;\n                que.push({x, y});\n            }\n        }\n        return vis[n - 1][n - 1];\n    }\n};\n```\n- TC:O(n^2logn)\n- SC:O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486277470","body":"### 思路\n- 滑动窗口\n### 代码\n```cpp\nclass Solution {\npublic:\n    int isVowel (char c){\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n            return 1;\n        return 0;\n    }\n    int maxVowels(string s, int k) {\n        int cnt = 0, ans = 0;\n        for(int i = 0; i < s.size(); i++){\n            cnt += isVowel(s[i]);\n            if(i >= k){\n                cnt -= isVowel(s[i - k]);\n            }\n            ans = max(ans, cnt);\n        }\n        return ans;\n    }\n};\n```\n### 复杂度分析\n- TC:O(n)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1487823792","body":"```cpp\nclass Solution {\npublic:\n    double new21Game(int n, int k, int maxPts) {\n        if (k == 0) {\n            return 1.0;\n        }\n        vector<double> dp(k + maxPts);\n        for (int i = k; i <= n && i < k + maxPts; i++) {\n            dp[i] = 1.0;\n        }\n        dp[k - 1] = 1.0 * min(n - k + 1, maxPts) / maxPts;\n        for (int i = k - 2; i >= 0; i--) {\n            dp[i] = dp[i + 1] - (dp[i + maxPts + 1] - dp[i + 1]) / maxPts;\n        }\n        return dp[0];\n    }\n};\n```\n- TC:O(min(n,k+maxPts))\n- SC:O(k+maxPts)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489552793","body":"```cpp\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string t) {\n        unordered_map<char, int> need, window;\n        for (char c : t) need[c]++;\n        int left = 0, right = 0;\n        int valid = 0;\n        vector<int> res; \n        while (right < s.size()) {\n            char c = s[right];\n            right++;\n            if (need.count(c)) {\n                window[c]++;\n                if (window[c] == need[c]) \n                    valid++;\n            }\n            while (right - left >= t.size()) {\n                if (valid == need.size())\n                    res.push_back(left);\n                char d = s[left];\n                left++;\n                if (need.count(d)) {\n                    if (window[d] == need[d])\n                        valid--;\n                    window[d]--;\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n- TC:O(N)\n- SC:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491166340","body":"```cpp\nclass Solution {\npublic:\n    string minWindow(string s, string t) {\n        unordered_map<char, int> need, window;\n        for (char c : t) need[c]++;\n\n        int left = 0, right = 0;\n        int valid = 0;\n        // 记录最小覆盖子串的起始索引及长度\n        int start = 0, len = INT_MAX;\n        while (right < s.size()) {\n            // c 是将移入窗口的字符\n            char c = s[right];\n            // 右移窗口\n            right++;\n            // 进行窗口内数据的一系列更新\n            if (need.count(c)) {\n                window[c]++;\n                if (window[c] == need[c])\n                    valid++;\n            }\n\n            // 判断左侧窗口是否要收缩\n            while (valid == need.size()) {\n                // 在这里更新最小覆盖子串\n                if (right - left < len) {\n                    start = left;\n                    len = right - left;\n                }\n                // d 是将移出窗口的字符\n                char d = s[left];\n                // 左移窗口\n                left++;\n                // 进行窗口内数据的一系列更新\n                if (need.count(d)) {\n                    if (window[d] == need[d])\n                        valid--;\n                    window[d]--;\n                }                    \n            }\n        }\n        // 返回最小覆盖子串\n        return len == INT_MAX ?\n            \"\" : s.substr(start, len);\n    }\n};\n```\n- TC:O(N)\n- SC:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1492897030","body":"```cpp\nclass Solution {\npublic:\n    int minOperations(vector<int>& nums, int x) {\n        int newTarget = 0;\n        int sum = 0;\n        for(auto e:nums){\n            sum += e;\n        }\n        newTarget = sum - x;\n        if(newTarget == 0)return nums.size();\n        int left = 0;\n        int tempSum = 0;\n        int maxlen = 0;\n        for(int i=left; i<nums.size(); i++){\n            tempSum += nums[i];\n            while(tempSum >= newTarget && i>=left){\n                if(tempSum == newTarget){\n                    maxlen = max(maxlen, i-left+1);\n                }\n                tempSum -= nums[left];\n                left++;\n            }\n            \n        }\n        return maxlen == 0 ? -1 : nums.size() - maxlen;\n    }\n};\n```\n- TC:O(N)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493310421","body":"```cpp\nclass Solution {\npublic:\n    vector<string> readBinaryWatch(int turnedOn) {\n        vector<string> ans;\n        for (int i = 0; i < 1024; ++i) {\n            int h = i >> 6, m = i & 63; \n            if (h < 12 && m < 60 && __builtin_popcount(i) == turnedOn) {\n                ans.push_back(to_string(h) + \":\" + (m < 10 ? \"0\" : \"\") + to_string(m));\n            }\n        }\n        return ans;\n    }\n};\n```\n- TC:O(1)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1493778160","body":"```cpp\nclass Solution {\npublic:\n    int totalNQueens(int n) {\n        return solve(n, 0, 0, 0, 0);\n    }\n\n    int solve(int n, int row, int columns, int diagonals1, int diagonals2) {\n        if (row == n) {\n            return 1;\n        } else {\n            int count = 0;\n            int availablePositions = ((1 << n) - 1) & (~(columns | diagonals1 | diagonals2));\n            while (availablePositions != 0) {\n                int position = availablePositions & (-availablePositions);\n                availablePositions = availablePositions & (availablePositions - 1);\n                count += solve(n, row + 1, columns | position, (diagonals1 | position) << 1, (diagonals2 | position) >> 1);\n            }\n            return count;\n        }\n    }\n};\n```\n- TC:O(N!)\n- SC:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495221693","body":"```cpp\nclass Solution {\n    int getArea(vector<vector<int>>&  grid, int i, int j){\n        if (i == grid.size() || i < 0)\n            return 0;\n        else if (j == grid[0].size() || j < 0)\n            return 0; ;\n        if (grid[i][j] == 1){\n            grid[i][j] = 0;\n            return 1 + getArea(grid, i + 1, j) + getArea(grid, i - 1, j ) + getArea(grid, i, j + 1) + getArea(grid, i, j - 1);\n        }\n        return 0;\n    }\n\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int maxArea = 0;\n        int area = 0;\n        for (int i = 0; i < grid.size(); i++)\n        {\n            for (int j = 0; j < grid[0].size(); j++)\n            {\n                if (grid[i][j] == 1)\n                {\n                    area = getArea(grid, i, j);\n                    maxArea = maxArea > area ? maxArea : area;\n                }\n            }\n        }\n        return maxArea;\n    }\n};\n```\n- TC:O(mn)\n- SC:O(mn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497174895","body":"```cpp\nclass Solution {\npublic:\n    static constexpr int MAX_N = 100 + 5;\n    static constexpr int INF = int(1E6);\n    static constexpr int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\n\n    int n;\n    int d[MAX_N][MAX_N];\n\n    struct Coordinate {\n        int x, y;\n    };\n\n    queue <Coordinate> q;\n\n    int maxDistance(vector<vector<int>>& grid) {\n        this->n = grid.size();\n        auto &a = grid;\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                d[i][j] = INF;\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (a[i][j]) {\n                    d[i][j] = 0;\n                    q.push({i, j});\n                }\n            }\n        }\n\n        while (!q.empty()) {\n            auto f = q.front(); q.pop();\n            for (int i = 0; i < 4; ++i) {\n                int nx = f.x + dx[i], ny = f.y + dy[i];\n                if (!(nx >= 0 && nx <= n - 1 && ny >= 0 && ny <= n - 1)) continue;\n                if (d[nx][ny] > d[f.x][f.y] + 1) {\n                    d[nx][ny] = d[f.x][f.y] + 1;\n                    q.push({nx, ny});\n                }\n            }\n        }\n\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (!a[i][j]) {\n                    ans = max(ans, d[i][j]);\n                }\n            }\n        }\n\n        return (ans == INF) ? -1 : ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498433331","body":"```cpp\nclass Solution {\npublic:\n    int maxCandies(vector<int>& status, vector<int>& candies, vector<vector<int>>& keys, vector<vector<int>>& containedBoxes, vector<int>& initialBoxes) {\n        int n = status.size();\n        vector<bool> can_open(n), has_box(n), used(n);\n        for (int i = 0; i < n; ++i) {\n            can_open[i] = (status[i] == 1);\n        }\n\n        queue<int> q;\n        int ans = 0;\n        for (int box: initialBoxes) {\n            has_box[box] = true;\n            if (can_open[box]) {\n                q.push(box);\n                used[box] = true;\n                ans += candies[box];\n            }\n        }\n        \n        while (!q.empty()) {\n            int big_box = q.front();\n            q.pop();\n            for (int key: keys[big_box]) {\n                can_open[key] = true;\n                if (!used[key] && has_box[key]) {\n                    q.push(key);\n                    used[key] = true;\n                    ans += candies[key];\n                }\n            }\n            for (int box: containedBoxes[big_box]) {\n                has_box[box] = true;\n                if (!used[box] && can_open[box]) {\n                    q.push(box);\n                    used[box] = true;\n                    ans += candies[box];\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n```\n- TC:O(N)\n- SC:O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500848169","body":"```cpp\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        for (int i = 2; i < cost.size(); i++) {\n            cost[i] = min(cost[i - 2], cost[i - 1]) + cost[i];\n        }\n        return min(cost[cost.size() - 2], cost[cost.size() - 1]);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501044477","body":"```cpp\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int prev = 0;\n        int curr = 0;\n        for (int i : nums) {\n            // dp[k] = max{ dp[k-1], dp[k-2] + i }\n            int temp = max(curr, prev + i);\n            prev = curr;\n            curr = temp;\n        }\n        return curr;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501765405","body":"```cpp\nclass Solution {\npublic:\n    int findNumberOfLIS(vector<int> &nums) {\n        int n = nums.size(), maxLen = 0, ans = 0;\n        vector<int> dp(n), cnt(n);\n        for (int i = 0; i < n; ++i) {\n            dp[i] = 1;\n            cnt[i] = 1;\n            for (int j = 0; j < i; ++j) {\n                if (nums[i] > nums[j]) {\n                    if (dp[j] + 1 > dp[i]) {\n                        dp[i] = dp[j] + 1;\n                        cnt[i] = cnt[j];\n                    } else if (dp[j] + 1 == dp[i]) {\n                        cnt[i] += cnt[j];\n                    }\n                }\n            }\n            if (dp[i] > maxLen) {\n                maxLen = dp[i];\n                ans = cnt[i];\n            } else if (dp[i] == maxLen) {\n                ans += cnt[i];\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1503460007","body":"```cpp\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m = text1.length(), n = text2.length();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n        for (int i = 1; i <= m; i++) {\n            char c1 = text1.at(i - 1);\n            for (int j = 1; j <= n; j++) {\n                char c2 = text2.at(j - 1);\n                if (c1 == c2) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1505195516","body":"```cpp\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> f(m, vector<int>(n));\n        for (int i = 0; i < m; ++i) {\n            f[i][0] = 1;\n        }\n        for (int j = 0; j < n; ++j) {\n            f[0][j] = 1;\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                f[i][j] = f[i - 1][j] + f[i][j - 1];\n            }\n        }\n        return f[m - 1][n - 1];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506654197","body":"```cpp\nclass Solution {\npublic:\n    vector<vector<int>> dirs = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}};\n\n    double knightProbability(int n, int k, int row, int column) {\n        vector<vector<vector<double>>> dp(k + 1, vector<vector<double>>(n, vector<double>(n)));\n        for (int step = 0; step <= k; step++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (step == 0) {\n                        dp[step][i][j] = 1;\n                    } else {\n                        for (auto & dir : dirs) {\n                            int ni = i + dir[0], nj = j + dir[1];\n                            if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                                dp[step][i][j] += dp[step - 1][ni][nj] / 8;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[k][row][column];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1508201454","body":"```cpp\nclass Solution {\npublic:\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\n        int sum = (1+maxChoosableInteger)*maxChoosableInteger/2;\n        if(sum < desiredTotal){\n            return false;\n        }\n        unordered_map<int,int> d;\n        return dfs(maxChoosableInteger,0,desiredTotal,0,d);\n    }\n\n    bool dfs(int n,int s,int t,int S,unordered_map<int,int>& d){\n        if(d[S]) return  d[S];\n        int& ans = d[S];\n\n        if(s >= t){\n            return ans = true;\n        }\n        if(S == (((1 << n)-1) << 1)){\n            return ans = false;\n        }\n\n        for(int m = 1;m <=n;++m){\n            if(S & (1 << m)){\n                continue;\n            }\n            int nextS = S|(1 << m);\n            if(s+m >= t){\n                return ans = true;\n            }\n            bool r1 = dfs(n,s+m,t,nextS,d);\n            if(!r1){\n                return ans = true;\n            }\n        }\n        return ans = false;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509620816","body":"```cpp\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int n = nums.size();\n        if (n < 2) {\n            return false;\n        }\n        int sum = 0, maxNum = 0;\n        for (auto& num : nums) {\n            sum += num;\n            maxNum = max(maxNum, num);\n        }\n        if (sum & 1) {\n            return false;\n        }\n        int target = sum / 2;\n        if (maxNum > target) {\n            return false;\n        }\n        vector<int> dp(target + 1, 0);\n        dp[0] = true;\n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            for (int j = target; j >= num; --j) {\n                dp[j] |= dp[j - num];\n            }\n        }\n        return dp[target];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510149104","body":"```cpp\nclass Solution {\npublic:\n    int findTargetSumWays(vector<int> &nums, int target) {\n        target += accumulate(nums.begin(), nums.end(), 0);\n        if (target < 0 || target % 2) return 0;\n        target /= 2;\n\n        int f[target + 1];\n        memset(f, 0, sizeof(f));\n        f[0] = 1;\n        for (int x : nums)\n            for (int c = target; c >= x; --c)\n                f[c] += f[c - x];\n        return f[target];\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dragonfcl":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429257693","body":"### 思路\n\n两个数组，从右往左处理数据，和大于0，则处理进位（注意空值默认0处理）\n\n### 代码\n\n\n```javascript\n     const addToArrayForm = function (aSource, plusNum) {\n        let aRes = []\n        let aTarget = Array.from(plusNum.toString());\n        while (aTarget.length > 0) {\n          let sum = (+aSource.pop() || 0) + (+aTarget.pop() || 0)\n          if (sum >= 10) {\n            aTarget.push((+aTarget.pop() || 0) + 1)\n            aRes.unshift(sum % 10)\n          } else {\n            aRes.unshift(sum)\n          }\n        }\n        aRes = [...aSource, ...aRes];\n        return aRes;\n      };\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431534561","body":"### 思路\n\n先记录c的Index，遍历字符串，记录距离的绝对值，取最小值\n\n### 代码\n\n\n```JavaScript\nvar shortestToChar = function(s, c) {\n    const aS = s.split('');\n    const aCIndex = [];\n    const aRes = new Array(aS.length).fill(aS.length);\n    for(let i = 0; i < aS.length; i++){\n        if(aS[i] == c) {\n            aCIndex.push(i)\n        }\n    }\n    for(let i = 0; i < aS.length; i++){\n        for(let j = 0; j < aCIndex.length; j++){\n            aRes[i] = Math.min(aRes[i],Math.abs(i-aCIndex[j]))\n        }\n    }\n    return aRes;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433317498","body":"\r\nvar CustomStack = function(maxSize) {\r\n  this.stack = [];\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  let stack = this.stack;\r\n  if (stack.length < this.maxSize) {\r\n    stack.push( x );\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  let stackTemp = this.stack;\r\n  if (stackTemp.length > 0){\r\nreturn stackTemp.pop();\r\n} \r\n  return -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let stack = this.stack;\r\n  for (let i = 0; i < Math.min(stack.length, k); i++) {\r\n    stack[i] += val;\r\n  }\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434836053","body":"```javascript\r\nvar decodeString = function(s) {\r\n    let repetStack=[],resStack=[];\r\n    let resStr = \"\";\r\n    let repet = 0;\r\n    for(let i=0;i<s.length;i++){\r\n        let cur = s.charAt(i);\r\n        if(cur == '['){\r\n            repetStack.push(repet);\r\n            resStack.push(resStr);\r\n            repet = 0;\r\n            resStr = \"\";\r\n        }else if(cur == ']'){\r\n            let count = repetStack.pop();\r\n            let temp = \"\";\r\n            for(let i = 0;i<count;i++){\r\n                temp += resStr;\r\n            }\r\n            resStr = resStack.pop() + temp;\r\n        }else if(cur>='0' && cur<='9'){\r\n            repet = repet*10 + (cur-'0');\r\n        }else{\r\n            resStr += cur;\r\n        }\r\n    }\r\n    return resStr;\r\n};\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441956905","body":"```javascript\nvar getIntersectionNode = function(headA, headB) {\n    let arrA=[]\n    let arrB=[]\n    while (headA!=null){\n        arrA.push(headA)\n        headA=headA.next\n    }\n    while (headB!=null){\n        arrB.push(headB)\n        headB=headB.next\n    }\n    for(let item of arrA){\n        for(let obj of arrB){\n            if(item ===obj){\n                console.log(item)\n                return item\n            }\n        }\n    }\n    return null\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445139682","body":"```javascript\nvar LRUCache = function(capacity) {\n    this.cap = capacity;\n    this.cache = {};\n    this.length = 0;\n};\nLRUCache.prototype.get = function(key) {\n    if(this.cache[key] != undefined) {\n        var temp = this.cache[key];\n        delete this.cache[key];\n        console.log(this.cache); \n        this.cache[key] = temp;\n        \n        return temp;\n    } else {\n        return -1;\n    } \n          \n};\n\nLRUCache.prototype.put = function(key, value) {\n    if(this.length < this.cap && this.cache[key] == undefined) {\n        this.cache[key] = value;\n        this.length++;\n    } else if(this.length == this.cap && this.cache[key] == undefined) {\n        var arr = Object.keys(this.cache);\n        delete this.cache[arr[0]];\n        this.cache[key] = value;\n    }\n    console.log(this.cache);\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446580692","body":"```javascript\nvar isSameTree = function(p, q) {\n    let stack1 = []\n\tlet stack2 = []\n\twhile (p || stack1.length || q || stack2.length) {\n\t\twhile (p !== null && q !== null) {\n\t\t\tstack1.push(p)\n\t\t\tstack2.push(q)\n\t\t\tp = p.left\n\t\t\tq = q.left\n\t\t}\n\t\tif (q === null && p === null) {\n\t\t\tp = stack1.pop()\n\t\t\tq = stack2.pop()\n\t\t\tif (p.val != q.val) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tp = p.right\n\t\t\tq = q.right\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448329080","body":"```javascript\nvar sumNumbers = function(root) {\n    return count(root, 0);\n};\nconst count = (cur, preSum) => {\n    if(!cur) return 0;\n    let sum = preSum * 10 + cur.val;\n    if(!cur.left && !cur.right) return sum;\n    else return count(cur.left, sum) + count(cur.right, sum);\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450298755","body":"```javascript\nvar findBottomLeftValue = function(root) {\n    let level = -1\n    let val = 0\n    function dfs (node, current) {\n        if (!node) return\n        if (current > level) {\n            val = node.val\n            level = current\n        }\n        dfs(node.left, current + 1)\n        dfs(node.right, current + 1)\n    }\n    dfs(root, 0)\n    return val\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453636315","body":"```javascript\nvar verticalTraversal = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    // 二维数组 存坐标和值，形式如 [[x, y, val], [...]]\n    let locationList = []; \n\n    // 先dfs前序遍历记录下节点坐标和值\n    const dfs = function(root, x, y) {\n        if (!root) {\n            return;\n        }\n        locationList.push([x, y, root.val]);\n        dfs(root.left, x - 1, y - 1);\n        dfs(root.right, x + 1, y - 1);\n    }\n    dfs(root, 0, 0);\n    \n    // 按照x升序，y降序，val升序\n    locationList = locationList.sort((a, b) => {\n        if(a[0] != b[0]) {\n            return a[0] - b[0];\n        }\n        if (a[1] != b[1]) {\n            return b[1] - a[1]\n        }\n        return a[2] - b[2];\n    });\n    \n    // curValOfX当前遍历的节点的x的值，默认先取第一个节点的x值\n    let curValOfX = locationList[0][0];\n    let result = [[locationList[0][2]]];\n\n    // 从第2个节点开始遍历坐标数组，把x相同的val分成一组\n    for (let i = 1; i < locationList.length; i++) {\n        let location = locationList[i];\n        let x = location[0];\n        if (x == curValOfX) {\n            let last = result[result.length - 1];\n            last.push(location[2]);\n        } else {\n            curValOfX = x;\n            result.push([location[2]]); \n        }\n    }\n    return result;\n};\n```","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464938723","body":"```javascript\nvar removeDuplicates = function (nums) {\n  let j = 1;\n  // [0,...j] 保持 0-j是非重复元素。将新元素添加到0-j尾部\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] !== nums[i - 1]) {\n      nums[j] = nums[i];\n      j++;\n    }\n  }\n\n  return j;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466356543","body":"```javascript\nvar maxSlidingWindow = function(nums, k) {\n   const deque=[];\n   const  result=[]; \n   for(let i=0;i<nums.length;i++){\n     if(i-deque[0]>=k) deque.shift();\n     while(nums[deque[deque.length-1]]<=nums[i]){\n         deque.pop(); \n     }\n     deque.push(i);\n     if(i>=k-1) {  \n         result.push(nums[deque[0]]);\n     }\n   }\n   return result;\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474855281","body":"```javascript\nvar getOrder = function (tasks) {\n  const res = []\n  const n = tasks.length\n  // 每个 task 添加一项，记录原本的 index\n  for (let i = 0; i < n; ++i) {\n    tasks[i].push(i)\n  }\n  // 按照 enqueueTime 从小到大的顺序排序\n  tasks.sort((task1, task2) => task1[0] - task2[0])\n  // 优先队列：processingTime 不同则更小的优先级更高；相同则 index 更小的优先级更高\n  const taskQueue = new PriorityQueue({\n    compare: (task1, task2) => {\n      if (task1[1] !== task2[1]) return task1[1] - task2[1]\n      return task1[2] - task2[2]\n    }\n  });\n  // 记录当前时间\n  let timestamp = 0\n  let idx = 0\n  // dequeue 至多执行 n 次\n  for (let i = 0; i < n; ++i) {\n    // 队列为空，代表 CPU 空闲，更新当前时间\n    if (taskQueue.isEmpty() && idx < n) {\n      timestamp = Math.max(timestamp, tasks[idx][0])\n    }\n    while (idx < n && tasks[idx][0] <= timestamp) {\n      taskQueue.enqueue(tasks[idx++])\n    }\n    if (taskQueue.isEmpty()) break\n    // 执行任务，并更新 timestamp\n    let [_, processingTime, index] = taskQueue.dequeue()\n    timestamp += processingTime\n    res.push(index)\n  }\n  return res\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483816995","body":"```javascript\n\nvar findRadius = function(houses, heaters) {\n    houses.sort((a,b) => a-b)\n    heaters.sort((a,b) => a-b)\n    let res = 0\n    for(let i = 0, j = 0; i < houses.length; i++){\n        let curD = Math.abs(houses[i] - heaters[j])\n        while(j < heaters.length - 1 && Math.abs(houses[i] - heaters[j]) >= Math.abs(houses[i] - heaters[j + 1])){\n            j++\n            curD = Math.abs(houses[i] - heaters[j])\n        }\n        res = Math.max(res, curD)\n    }\n    return res\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1492006041","body":"```javascript\nvar minWindow = function(s, t) {\n    const needs = {},\n    window = {};\n  for (const c of t) {\n    if (needs[c] === undefined) {\n      needs[c] = 0;\n    }\n    needs[c]++;\n    window[c] = 0;\n  }\n  const needsSize = Object.keys(needs).length;\n\n  let left = 0,\n    right = 0;\n  let valid = 0;\n  let start = 0,\n    len = Infinity;\n  while (right < s.length) {\n    const c = s[right];\n    right++;\n    if (needs[c] !== undefined) {\n      window[c]++;\n      if (window[c] === needs[c]) {\n        valid++;\n      }\n    }\n    while (valid === needsSize) {\n      if (right - left < len) {\n        start = left;\n        len = right - left;\n      }\n      const d = s[left];\n      left++;\n      if (needs[d] !== undefined) {\n        if (window[d] === needs[d]) valid--;\n        window[d]--;\n      }\n    }\n  }\n  return len === Infinity ? \"\" : s.substr(start, len);\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495934946","body":"```javascript\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar maxAreaOfIsland = function(grid) {\n    let max = 0;\n    let count = 0;\n    function dfs(row, col) {\n        if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] === 0) {\n            return 0;\n        }\n        grid[row][col] = 0;\n        count = 1\n        count += dfs(row+1, col)\n        count += dfs(row-1, col)\n        count += dfs(row, col+1)\n        count += dfs(row, col-1)\n        return count;\n    }\n    for(let i = 0; i < grid.length; i++) {\n        for(let j = 0; j < grid[0].length; j++){\n            if(grid[i][j] === 1) {\n                max = Math.max(max, dfs(i, j))\n            }\n        }\n    }\n    return max;\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501117329","body":"```javascript\nvar rob = function (nums) {\n\tconst len = nums.length;\n\tif (len === 0) return 0;\n\tconst dp = new Array(len + 1);\n\tdp[0] = 0;\n\tdp[1] = nums[0];\n\tfor (let i = 2; i <= len; i++)\n\t\tdp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);\n\treturn dp[len];\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509733657","body":"```javascript\nvar canPartition = function (nums) {\n  var sum = nums.reduce((a, b) => a + b);\n  if (sum % 2 === 1) return false;\n  let bgSize = sum / 2; // 两个子集的和\n  let len = nums.length;\n  let dp = new Array(bgSize + 1).fill(0); // dp初始化\n  // 先遍历物品\n  for (let i = 0; i < len; i++) {\n    for (let j = bgSize; j >= nums[i]; j--) {\n      dp[j] = Math.max(\n        dp[j], // 不放改物品\n        dp[j - nums[i]] + nums[i], // 放物品\n      );\n    }\n  }\n  return dp[bgSize] === bgSize;\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518671497","body":"```javascript\nvar numTrees = function (n) {\n  const dp = new Array(n+1).fill(0);\n  dp[0] = 1;\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= i; j++) {\n      dp[i] += dp[j-1]*dp[i-j]\n    }\n  }\n  return dp[n]\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huifeng248":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429283375","body":"###### thoughts\r\n        # convert the array form interger into int\r\n        # add them and turn the sum into array form\r\n\r\n```py\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]: \r\n        sub_total = 0 \r\n        i = len(num)-1\r\n        j = 0\r\n        while j < len(num):\r\n            digit = num[j] * (10**i)\r\n            sub_total += digit\r\n            j+= 1\r\n            i -= 1 \r\n        \r\n        \r\n        sub_total += k \r\n\r\n        res = list(str(sub_total))\r\n        return [int(i) for i in res]\r\n```\r\n######    Complexity \r\n        # time complexity is O(n), n is the max(len(num), len(sum))\r\n        # space complexity is O(n), n is the max(len(num), len(sum))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430562334","body":"###### 思路： 左右指针算距离上一个的距离。然后比对两个array 的最小值\n```py\n\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # Algorithm\n\n        # When going left to right, we'll remember the index prev of the last character C we've seen. Then the answer is i - prev.\n        # When going right to left, we'll remember the index prev of the last character C we've seen. Then the answer is prev - i.\n        # We take the minimum of these two answers to create our final answer.\n\n        left_res = [None]*len(s)\n        right_res = [None]*len(s)\n        res = []\n        \n        prev = float('-inf')\n        # check from left\n        for i, char in enumerate(s):    \n            if char == c:\n                prev = i\n            left_res[i] = i - prev\n        \n        # check from right\n        right_prev = float('inf')\n        for j in range(len(s)-1, -1, -1):\n            right_res[j] = float('inf')\n            if s[j] == c:\n                right_prev = j\n            right_res[j] = right_prev - j\n   \n        for i in range(len(s)):\n            ele = min(left_res[i], right_res[i])\n            res.append(ele)\n        return res\n```\n\n\n    # time complexity O(n)\n    # space complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1431833638","body":"```python \nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.arr = []\n        \n\n    def push(self, x: int) -> None:\n        if len(self.arr) < self.maxSize:\n            self.arr.append(x)\n        \n    def pop(self) -> int:\n        if len(self.arr) >= 1:\n            res = self.arr.pop()\n            return res\n        else:\n            return -1\n        \n\n    def increment(self, k: int, val: int) -> None:\n        # print(\"stack\", self.arr, \"k\", k, val)\n        if len(self.arr) <= k:\n            self.arr = [i+val for i in self.arr]\n            # print([k, val], self.arr, )\n        else:\n            for i in range(k):\n                self.arr[i] += val\n            # print([k, val], self.arr, )\n        \n\n```\n\n##### time complexity: push, pop is O(1); increment is O(n) and n is equal to the min(len(stack), k)\n##### space complexity is O(n) n is the length of stack","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1435527470","body":"``` python\nclass Solution:\n\n    def decodeString(self, s:str) -> str:\n        stack = []\n        cur_str = \"\"\n        cur_num = 0\n        for char in s:\n            if char.isalpha():\n                cur_str += char\n                print(\"letter\", char)\n            elif char.isdigit():\n                cur_num = cur_num * 10 + int(char)\n                print(\"digit\", char)\n            elif char == \"[\":\n                stack.append(cur_str)\n                stack.append(cur_num)\n                cur_num = 0\n                cur_str = \"\"\n                print(\"stack after [\", stack)\n            elif char == \"]\":\n                print(\"stack ]\", stack)\n                num_multi = stack.pop()\n                pre_str = stack.pop()\n                print(\"cur_str\", cur_str, \"prev_str\", pre_str, \"num_multi\", num_multi, \"stack\", stack)\n                cur_str = pre_str + num_multi * cur_str\n        return cur_str\n            \ns = \"2[ee]2[3[a2[c]]]\"\n# s = \"2[abc]3[cd]ef\"\n# s = \"3[a]2[bc]\"           \n    \nsample = Solution()\nprint(sample.decodeString(s))\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435170344","body":"###### use only one stack. python pop(0) and append can do the work\n``` python \nclass MyQueue:\n\n    def __init__(self):\n        self.stack_one = []\n        # self.stack_two = []\n\n    def push(self, x: int) -> None:\n        self.stack_one.append(x)\n        # self.stack_two.insert(0, x)\n\n    def pop(self) -> int:\n        res = self.stack_one.pop(0)\n        # res = self.stack_two.pop(0)\n        return res\n\n    def peek(self) -> int:\n        return self.stack_one[0]\n        \n    def empty(self) -> bool:\n        return len(self.stack_one) == 0\n\n```\npop(0) is O(n). others are O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436458587","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        # count the number of max in the chunk. the previous chunk's max must be smaller than the next chunk's smallest\n        max_num = arr[0]\n        stack = []\n        for i in arr:\n            if  i >= max_num:\n                stack.append(i)\n                max_num = i\n            else: \n                top = stack[-1]\n                while len(stack) > 0 and stack[-1]> i:\n                    stack.pop()\n                \n                stack.append(top)\n        return len(stack)\n\n# time comeplexity: O(n)\n# space comeplexity: O(n)\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436635875","body":"``` python \n# make a circle and move along in k step, return the elements after the k.\n# there is still edge cases for this one, I will update it tmr to close the cases. \n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        # need to walk through the total linked list and get the total number of node\n        # total - k is the one that need to point to none, and the second half till end need to point to head \n        # return the second half head.\n        if k == 0:\n            return head\n        if head is None:\n            return None\n        if head.next is None:\n            return head\n        arr = [head.val]\n        current = head \n        while current.next:\n            arr.append(current.next.val)\n            current = current.next\n        current.next = head\n        total_len = len(arr)\n        \n        move_step = k % total_len\n        print(\"move_step\", move_step)\n        if move_step == 0:\n            return head\n        \n        new_tail = head\n        count = 0\n        while count< move_step:\n            count += 1\n            new_tail = new_tail.next\n        print(\"new_tail\", new_tail, \"new_tail.next\",new_tail.next)\n        \n        new_head = new_tail.next\n        new_tail.next = None\n        return new_head\n        \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438695028","body":"``` python\n#use recursion to swap the first two node, and pass the remainding and attached to the back of the first node\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None or head.next is None:\n            return head\n\n        first_Node = head\n        second_node = head.next\n\n        # assuming the remaining is working, the temp is the next nodes need to attached to the first_Node\n\n        temp = self.swapPairs(second_node.next)\n        first_Node.next = temp\n        second_node.next = first_Node\n        return second_node\n\n# Time Complexity: O(N), the size of the linked list.\n# Space Complexity: O(N), stack space utilized for recursion.\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1445176983","body":"``` python\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n\n    # def findMiddle(self, head):\n    #     if head is None or head.next is None:\n    #         return head\n    #     slow = head\n    #     fast = head\n    #     prev = None\n    #     while fast and fast.next:\n    #         prev = slow\n    #         slow = slow.next \n    #         print(\"fast\", fast.val)\n    #         fast = fast.next.next\n    #     prev.next = None\n    #     print(\"slow~~\", slow.val)\n    #     return slow\n\n    # def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n    #     if head is None or head.next is None:\n    #         return head\n    #     mid = self.findMiddle(head)\n    #     left = self.sortedListToBST(head)\n    #     right = self.sortedListToBST(mid)\n    #     head.left = left\n    #     head.right = right\n    #     return head    \n    \n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return head\n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head\n        prev = None\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next \n            print(\"fast\", fast.val)\n            fast = fast.next.next\n        prev.next = None\n        node = TreeNode(slow.val)\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        \n        return node\n\n# Time Complexity: O(Nlog⁡N)\n# Space Complexity: O(log⁡N)\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1447052525","body":"```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        def build_dict(headA):\r\n            current = headA\r\n            visited = set()\r\n            count = 0\r\n            while current:\r\n\r\n                visited.add(current)\r\n                current = current.next\r\n            return visited\r\n        \r\n        visited = build_dict(headA)\r\n        currnt_b = headB\r\n        while currnt_b:\r\n            if currnt_b in visited:\r\n                return currnt_b\r\n            else:\r\n                currnt_b = currnt_b.next\r\n        return None\r\n\r\n# time complexity 0(M+N)\r\n# space complexity O(M)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1447148927","body":"``` python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n\n        visited_dict = {}\n        count = 0\n        current = head\n        while current:\n            if current not in visited_dict:\n                visited_dict[current] = count\n                count += 1\n                current = current.next\n            else:\n                return current\n        return None\n\n    # time complexity O(n)\n    # space complexity O(n)\n\n```\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1447244592","body":"```python\nfrom collections import OrderedDict\n\nclass LRUCache(OrderedDict):\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity \n        \n\n    def get(self, key: int) -> int:\n        if key not in self:\n            return -1\n        \n        self.move_to_end(key)\n        return self[key]\n\n        \n\n    def put(self, key: int, value: int) -> None:\n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.capacity:\n            self.popitem(last = False)\n\n\n# time complexity O(1)\n# space complexity O(capacity)\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1447298485","body":"``` python\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n# solution one: recursion \n# class Solution:\n#     def maxDepth(self, root: Optional[TreeNode]) -> int:\n#         if root is None:\n#             return 0\n#         left = self.maxDepth(root.left) + 1\n#         right = self.maxDepth(root.right) + 1\n#         return max(left, right)\n\n# time complexity O(n) n is the number of nodes, as we visit each node once\n# space complexity is the height of the trees, if the tress is balance the space complexity would be O(log(n)), if the tree is completely unbalanced, it would be O(n).\n\n# iteration solution\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n\n        stack = [[root, 1]]\n        depth = float('-inf')\n        while stack:\n            node, level = stack.pop()\n            if level > depth:\n                depth = level\n            if node.left:\n                stack.append([node.left, level+1])\n            if node.right:\n                stack.append([node.right, level +1])\n        return depth\n            \n# time complexity O(n) n is the number of nodes, as we visit each node once\n# space complexity is the height of the trees, if the tress is balance the space complexity would be O(log(n)), if the tree is completely unbalanced, it would be O(n).\n\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1447343263","body":"```python\n\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        \n        if not p or not q:\n            return False\n        \n        if q.val != p.val:\n            return False\n        \n        left = self.isSameTree(p.left, q.left)\n        right = self.isSameTree(p.right, q.right)\n        return left and right\n\n# Time complexity : O(N), where N is a number of nodes in the tree, since one visits each node exactly once.\n\n# Space complexity : O(N) in the worst case of completely unbalanced tree, to keep a recursion stack\n\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447824511","body":"```python\n\n##### i will update the thought process later on \n\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        def dfs(root, cur):\n            if not root:\n                return 0\n\n            cur = cur * 10 + root.val\n\n            if not root.left and not root.right:\n                return cur\n            \n            return dfs(root.left, cur) + dfs(root.right, cur)\n\n        return dfs(root, 0)\n        \n\n# Time Complexity : O(N), where N is the number of nodes in the tree. We are doing a standard DFS traversal which takes O(N) time\n# Space Complexity : O(H), where H is the maximum depth of tree. This space is required for implicit recursive stack space. In the worst case, the tree maybe skewed and H = N in which case space required is equal to O(N).\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449521867","body":"``` python \nfrom collections import deque\n\n# BFS, the leftmost value will appear first, and the level if greater than the max_level, leftmost value would be updated. \n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n\n        max_level = float('-inf')\n        left_most = root.val\n        queue = deque([(root, 0)])\n\n        while queue:\n            current, level = queue.popleft()\n\n            if level > max_level:\n                max_level = level\n                left_most = current.val\n\n            if current.left:\n                queue.append((current.left, level +1 ))\n            if current.right:\n                queue.append((current.right, level+1))\n\n        return left_most\n\n\n# time complexity: O(n), n is the number of nodes\n# space complexity: O(n), n is the number of nodes\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1450902205","body":"```python\n\nfrom collections import deque\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        def helper_a(root, arr):\n            if root is None:\n                arr.append(None)\n            else:\n                arr.append(root.val)\n                helper_a(root.left, arr)\n                helper_a(root.right, arr)\n        \n            # print(\"arr\", arr)\n            # # print(\"str\", res_str)\n            # return res_str\n        \n        arr = []\n        helper_a(root, arr)\n        print(arr)\n        return \"#\".join([str(i) for i in arr]) \n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        arr = data.split(\"#\")\n        print(arr)\n        arr = deque(arr)\n        # head = TreeNode(arr[0])\n        return self.helper(arr)\n    \n\n    def helper(self, arr):\n        if arr[0] == 'None':\n            arr.popleft()\n            return None\n        \n        node = TreeNode(arr[0])\n        arr.popleft()\n        node.left = self.helper(arr)\n        node.right = self.helper(arr)\n        return node\n        \n\n# time complexity: O(n) n is the number of nodes\n# space complexity: O(n) \n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1452800050","body":"```python \n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        # node_list = []\n        row = 0\n        col = 0\n        node_list = self.get_nodes(root, {}, row, col)\n\n        res = []\n        keys = sorted(node_list.keys())\n        print(keys)\n\n        for key in keys:\n            num_point = len(node_list[key])\n            if num_point == 1:\n                res.append([node_list[key][0][2]])\n\n            else:\n                sorted_sub_list = sorted(node_list[key])\n                temp = []\n                \n                for point in sorted_sub_list:\n                    temp.append(point[2])\n                res.append(temp)\n        return res\n\n\n    def get_nodes(self, root, node_list, row, col):\n        if not root:\n            return \n        \n        if col not in node_list:\n            node_list[col] = []\n        node_list[col].append([col, row, root.val])\n        \n        self.get_nodes(root.left, node_list, row+1, col-1)\n        self.get_nodes(root.right, node_list, row+1, col+1)\n        return node_list\n\n# time complexity: O(nlog(n) for the sorting\n# space complexity: O(M) M is the number of columns \n\n\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454800363","body":"```python\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        diffs = {}\n        for i, num in enumerate(nums):\n            if num not in diffs:\n                comp = target - num\n                diffs[comp] = i\n            else:\n                return [diffs[num], i]\n\n# time complexity O(n)\n# space complexity O(n)\n\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455006036","body":"``` python\r\n\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        if k == len(nums):\r\n            return nums        \r\n\r\n        dict = {}\r\n        for num in nums:\r\n            if num not in dict:\r\n                dict[num] = 0\r\n            dict[num] += 1\r\n        \r\n        # buckets = [[] for _ in range(len(nums))] creates a list of separate empty list objects, while buckets = [[]] * len(nums) creates a list of references to the same empty list object is due to the way Python handles list initialization\r\n        buckets = [[] for i in range(len(nums)+1)]\r\n    \r\n        for key in dict.keys():\r\n            value = dict[key]\r\n            buckets[value].append(key)\r\n\r\n        flatten = []\r\n        for i in range(len(buckets)-1, -1, -1):\r\n            if len(buckets[i]) != 0:\r\n                #extend used to spread the array, and append it to the list, cause * cannot use here.\r\n                flatten.extend(buckets[i])\r\n        return flatten[:k]\r\n\r\n\r\n# time O(N)\r\n# space O(N) \r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455616019","body":"```python \n\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n\n# use map to keep track of the number of boomerange for each iteration, thus the map need to be cleared for the next iteration\n# distance means delta x square + delta y square\n        res = 0\n        map = {}\n        for i in range(len(points)):\n            for j in range(len(points)):\n                if i == j:\n                    continue\n                d = self.get_distance(points[i], points[j])\n                if d not in map:\n                    map[d] = 0\n                map[d] += 1\n            \n            for value in map.values():\n                res += value * (value -1)\n            \n            map = {}\n        \n        return res\n\n    def get_distance(self, a, b):\n        x = a[0] - b[0]\n        y = a[1] - b[1]\n        return x**2 + y**2\n\n\n# time O(n^2) n is the number of points. This is because the function uses a nested loop to iterate over all pairs of points, resulting in n * (n-1) iterations.\n# space O(n) the space required to store the map HashMap. In the worst case, the map can contain n-1 keys, each with a value of n-1, which adds up to n * (n-1) entries. However, since the map is cleared at the end of each iteration, the maximum number of entries it can contain at any given time is n-1. Therefore, the space complexity of the function is O(n).\n\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1458872805","body":"```python\n\n# sliding window\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        start = 0\n        end = 0\n        visited = set()\n        res = 0\n        while end < len(s):\n            if s[end] not in visited:\n                visited.add(s[end])\n                end += 1\n                res = max(res, len(visited))\n            else:\n                visited.remove(s[start])\n                start += 1\n        return res\n\n# time complexity: O(N)\n# space complexity: O(N) n is for len of the visited set\n\n\n\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1461006914","body":"``` python\n\nfrom collections import defaultdict, Counter\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:\n            return []\n        \n        word_count = Counter(words)\n        word_len = len(words[0])\n        window_len = word_len * len(words)\n        res = []\n\n        for i in range(len(s) - window_len + 1):\n            sub_str = s[i: i+window_len]\n            sub_str_counter = self.get_counter(sub_str, word_len)\n\n            if sub_str_counter == word_count:\n                res.append(i)\n        return res\n    \n    def get_counter(self, sub_str, word_len):\n        dict = {}\n        for i in range(0, len(sub_str), word_len):\n            chars = sub_str[i: i+word_len]\n            if chars not in dict:\n                dict[chars] = 0\n            dict[chars] += 1\n        return dict\n#     The time complexity of the above code is O(NLM), where N is the length of the input string s, L is the length of each word in words, and M is the number of words in words.\n# The space complexity is O(M), as we store the frequency of each word in words in a Counter. \n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461150113","body":"```python\n\nclass Solution:\n    def minSubarray(self, nums, p) -> int:\n        sum_l = sum(nums)        \n        remainder = sum_l % p\n        print(\"remainder\", remainder)\n        if remainder == 0:\n            return 0\n        prefix_sum = [0]\n        for num in nums:\n            prefix_sum.append((prefix_sum[-1]+num) % p)\n        \n        print(prefix_sum)\n        seen = {0:0}\n        min_len = float('inf')\n        for i in range(1, len(prefix_sum), 1):\n            complement = (prefix_sum[i] - remainder) % p\n            # print((prefix_sum[i] - remainder) % p, \"i-\", i, \"ele-\", prefix_sum[i], \"comp-\", complement, \"seen key-\", seen.keys())\n            if complement in seen:\n                sub_arr_len = i - seen[complement]\n                min_len = min(min_len, sub_arr_len)\n            seen[prefix_sum[i]] = i\n\n      \n        if min_len == len(nums): # min_len >= len(nums) also work, cause need to rule exausting all prefix \n            return -1\n        else:\n            return min_len\n\n\n# time complexity is O(N), where N is the length of the input list nums.\n# space complexity is O(p), which is the size of the seen dictionary. In the worst case, if all the prefix sums have distinct values, the dictionary will contain p key-value pairs.\n        \n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1462708547","body":"``` python\n\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow \n\n#[1, 2, 3]\n#[1, 2, 3, 4]\n# # time complexity: O(N)\n# # space complexity: O(1)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1466872027","body":"```python \n\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) == 0:\n            return 0\n        j = 0\n        i = 1\n\n        while i < len(nums):\n            next = nums[i]\n            current = nums[j]\n            if next > current:\n                j += 1\n                nums[j] = next\n                i += 1\n                \n            if next == current:\n                i += 1\n        return j+1\n\n# time complexity: O(N)\n# space complexity: O(1)\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1466931118","body":"```python \n\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        if len(nums) == 0:\n            return 0\n        print(\"target\", target)\n        min_i = 0\n        max_i = len(nums)-1\n        while min_i <= max_i: \n            \n            mid = (max_i + min_i)//2  \n            # print(\"Min\", min_i, \"max\", max_i, \"mid\", mid, \"target\", target, \"middle\", nums[mid])\n            if target == nums[mid]:\n                return mid\n            elif target > nums[mid]:\n                min_i = mid +1 \n            elif target < nums[mid]:\n                max_i = mid -1\n        return min_i\n\n\n# Time complexity : O(log⁡N)\n# Space complexity : O(1)\n\n\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467452256","body":"```python\n\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        dict_trust = {}\n        has_trust = {}\n        for i in range(1, n+1, 1):\n            dict_trust[i] = []\n            has_trust[i] = []\n        for pair in trust:\n            a, b = pair[0], pair[1]\n            dict_trust[a].append(b)\n            has_trust[b].append(a)\n        \n        for item in dict_trust.items():\n            value = item[1]\n            key = item[0]\n            if len(value) == 0 and len(has_trust[key]) == n-1:\n                return key\n        \n        return -1\n\n\n# time complexity: O(Max(n, e)) n is the no of people, e is the no of trust pair.\n# space complexity: O(n) n is the no of people\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1470862272","body":"```python \r\nclass Solution:\r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n        if not dislikes:\r\n            return True\r\n        graph = {}\r\n        for pair in dislikes:\r\n            a,b = pair[0], pair[1]\r\n            if a not in graph:\r\n                graph[a] = []\r\n            if b not in graph:\r\n                graph[b] = []\r\n            graph[a].append(b)\r\n            graph[b].append(a)\r\n        color_dict = {}\r\n        visited = set()\r\n\r\n        for node in graph:\r\n            if node not in visited: \r\n                if not self.helper(node, visited, color_dict, graph):\r\n                    return False \r\n        return True\r\n\r\n    def helper(self, node, visited, color_dict, graph):\r\n        stack = [(node, 1)]\r\n        while stack:\r\n            current, color = stack.pop()\r\n            if current not in color_dict:\r\n                color_dict[current] = color\r\n                visited.add(current)\r\n            else:\r\n                if color_dict[current] != color:\r\n\r\n                    return False\r\n            for neighbor in graph[current]:\r\n                if neighbor not in visited:\r\n                    stack.append((neighbor, -color))\r\n        return True\r\n\r\n# time complexity: O(N+E) E is the number of dislikes, and n is the number of nodes.\r\n# space complexity: O(N+E) N is the number of nodes。 We also require O(E)and O(N)space for the adjacency list\r\n```\r\n","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1472533941","body":"```python\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        arrs = []\n        for move in moves:\n            if move == \"U\":\n                arrs.append([-1, 0])\n            elif move == \"D\":\n                arrs.append([1,0])\n            elif move == \"L\":\n                arrs.append([0, -1])\n            elif move ==\"R\":\n                arrs.append([0, 1])\n        print(arrs)\n        row, col = 0, 0\n        for pos in arrs:\n            r_delta, col_delta = pos\n            row += r_delta\n            col += col_delta\n        print([row, col])\n        return [row, col] == [0, 0]\n\n# time complexity: O(N)\n# space complexity: O(1)\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1476836318","body":"```python \n\nfrom collections import deque\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) == 1:\n            return nums\n        \n        mid = len(nums)//2\n        left = self.sortArray(nums[:mid])\n        right = self.sortArray(nums[mid:])\n\n        res = self.merge(left, right)\n        return res\n    \n    def merge(self, left, right):\n        left = deque(left)\n        right = deque(right)\n        res = []\n        while left and right:\n            if left[0] <= right[0]:\n                res.append(left[0])\n                left.popleft()\n            else:\n                res.append(right[0])\n                right.popleft()\n        if left:\n            res += left\n        if right: \n            res += right\n        return res\n        \n# time complexity: O(nlog(n))\n# spece complexity: tbd\n\n\n        \n\n```python ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1487665892","body":"```python \nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        if n == 0:\n            return False\n        left = 0\n        right = n\n        while left <= right:\n            mid = (left+right)//2\n            if isBadVersion(mid-1) == False and isBadVersion(mid)== True:\n                return mid\n            elif isBadVersion(mid)== True:\n                right = mid -1\n            else:\n                left = mid+1\n        \n# time complexity: O(log(n))\n# space complexity:O(1)\n\n\n```","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486309484","body":"```python\n\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        s_list = list(s)\n        vowels = ['a', 'e', 'i', 'o', 'u']\n        cnt = 0\n        for i in range(k):\n            if s_list[i] in vowels:\n                cnt = cnt + 1\n        max_num = cnt\n        for end in range(k,len(s)):\n            start = end - k + 1\n            if s_list[start-1] in vowels:\n                cnt = cnt - 1\n            if s_list[end] in vowels:\n                cnt = cnt + 1\n            max_num = max(max_num, cnt)\n\n        return max_num  \n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1490681385","body":"``` python\r\nfrom collections import Counter, defaultdict\r\n\r\n# sliding window with harsh map\r\n# we keep increase the window size until P, and compare the two Counter\r\n# when greater then P, we need to move left+1, and update the Counter_s and re-compare. \r\n# continue this process untill r reach the end.\r\n\r\n\r\nclass Solution:\r\n    def findAnagrams(self, s: str, p: str) -> List[int]:\r\n        counter_p = Counter(p)\r\n        counter_s = Counter()\r\n        i = 0\r\n        left = 0\r\n        res = []\r\n        for i in range(len(s)):\r\n            if i < len(p):\r\n                counter_s[s[i]]+=1\r\n            else:\r\n                counter_s[s[left]]-= 1\r\n                counter_s[s[i]]+=1\r\n                if counter_s[s[left]] == 0:\r\n                    del counter_s[s[left]]\r\n                left += 1\r\n            \r\n            if counter_p == counter_s:\r\n                res.append(left)\r\n        return res\r\n\r\n# time complexity: O(N) N is the length of s\r\n# space complexity: O(1) becase of limited 26 letters\r\n\r\n\r\n\r\n\r\n\r\n```","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1494839688","body":"```python\n\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        visited = set()\n        res = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if (i, j) not in visited:\n                    count = self.dfs(i, j, visited, grid)\n                    res = max(res, count)\n        \n        return res\n    \n\n    def dfs(self, row, col, visited, grid):\n        stack = [(row, col)]\n        count = 0\n        while stack:\n            r, c = stack.pop()\n            if (r, c) not in visited and grid[r][c] == 1:\n                count += 1\n                visited.add((r,c))\n            \n            dirs = [[1,0], [-1,0], [0,-1], [0,1]]\n            for point in dirs:\n                n_r = r + point[0]\n                n_c = c + point[1]\n                valid_row = 0 <= n_r < len(grid)\n                valid_col = 0 <= n_c < len(grid[0])\n                if valid_row and valid_col and (n_r, n_c) not in visited and grid[r][c] == 1:\n                    stack.append((n_r, n_c))\n        \n        return count \n# time complexity: O(mn) m is len of row, and n is the len of col.\n# space complexity:O(mn) m is len of row, and n is the len of col.\n\n            \n\n\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sarah11qing":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429288563","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num) - 1\n        num[n] += k\n        carry = 0\n\n        # first, process the num arr\n        for i in range(n, -1, -1):\n            temp = num[i] + carry\n            num[i] = temp % 10\n            carry = temp // 10\n\n        # second, check carry\n        # if no carry, return num dirrectly\n        # else, create an addtional carry arr\n        if carry:\n            carry_arr = []\n            while carry:\n                carry_arr.append(carry % 10)\n                carry //= 10\n\n            # note that carry_arr need to be reversed\n            num = carry_arr[::-1] + num\n        \n        return num\n\n        # time: O(max(len(num), logk))\n        # space: O(max(len(num), logk))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430988519","body":"```py\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n        # Find all index of c\n        c_index = []\n        for i, ch in enumerate(s):\n            if ch == c:\n                c_index.append(i)\n\n        # Initialize the res arr and a pointer     \n        res = [0] * len(s)\n        p = 0\n        \n        # Deal with three situations:\n        # when i < the first c's index\n        for i in range(0, c_index[0]):\n            res[i] = c_index[0] - i\n\n        # when i >= the last c's index\n        for i in range(c_index[-1], len(s)):\n            res[i] = i - c_index[-1]\n\n        # when first <= i < last\n        for i in range(c_index[0], c_index[-1]):\n            if i >= c_index[p + 1]:\n                p += 1\n            res[i] = min(i - c_index[p], c_index[p + 1] - i)\n\n        return res\n\n        # time: O(len(s)), traverse twice\n        # space: len(c_index), max = len(s)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432686892","body":"```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.increments = []\n        self.size = 0\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.stack.append(x)\n            self.increments.append(0)\n            self.size += 1\n        \n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n\n        # the value to pop = sum of two stacks' tops\n        top_ele = self.stack.pop()\n        top_inc = self.increments.pop()\n        self.size -= 1\n\n        # if stack is not empty, calculate the increments's top\n        if self.size:\n            self.increments[self.size - 1] += top_inc\n\n        return top_ele + top_inc\n\n\n    def increment(self, k: int, val: int) -> None:\n        if self.size == 0:\n            return\n        \n        # Add the val only to the index where the inc will be the first one to pop\n        self.increments[min(k, self.size) - 1] += val\n\n\n    # Delayed calcutation\n    # time: O(1) for push, pop, increment operations\n    # space: O(maxSize), two stacks\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434158232","body":"```py\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n\n        for ch in s:\n            # kepp pushing\n            if ch != \"]\":\n                stack.append(ch)\n\n            else:\n                ele = \"\"\n                count = \"\"\n\n                while stack[-1].isalpha():\n                    ele = stack.pop() + ele\n                # pop \"]\"\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    count = stack.pop() + count\n\n                stack.append(int(count) * ele)\n        \n        return \"\".join(stack)\n\n        # time: O(N)\n        # space: O(N)\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435648159","body":"```py\nclass MyQueue:\n    def __init__(self):\n        self.in_stack = []\n        self.out_stack = []\n        \n    def push(self, x: int) -> None:\n        self.in_stack.append(x)\n        \n    def pop(self) -> int:\n        self.supplementOutStack()\n        return self.out_stack.pop()\n\n    def peek(self) -> int:\n        self.supplementOutStack()\n        return self.out_stack[-1]\n    \n    def supplementOutStack(self) -> None:\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n           \n    def empty(self) -> bool:\n        return not self.in_stack and not self.out_stack\n    \n    # Two stacks, one for enqueueing and another for dequeueing\n    # time: \n    # - push, empty: O(1)\n    # - pop, peek  amortized O(1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435906419","body":"```py\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n\n        for num in arr:\n            largest = num\n            while stack and stack[-1] > num:\n                largest = max(largest, stack.pop())\n            stack.append(largest)\n        \n        return len(stack)\n\n        # mono stack\n        # time: O(n)\n        # space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436962757","body":"```py\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next: \n            return head\n\n        # in order to make it a circular linked list and count the length,\n        # iterate to find the tail node and link the tail.next to head\n        length = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            length += 1\n        cur.next = head\n\n        newTail = head\n        for i in range(length - k % length - 1):\n            newTail = newTail.next\n        newHead = newTail.next\n        newTail.next = None\n\n        return newHead\n        \n        # time: O(N)\n        # space: O(1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438101482","body":"```py\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(-1)\n        dummy.next = head\n        \n        pre = dummy\n        first = head\n\n        while first and first.next:\n            second = first.next \n            suc = second.next\n\n            # Swap the two nodes\n            pre.next = second\n            second.next = first\n            first.next = suc\n            \n            # Move prev pointer to first node in swapped pair\n            pre = first\n            first = suc\n        \n        return dummy.next\n\n        # iteration \n        # time: O(n)\n        # space: O(1)\n```\n\n```py\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        \n        first = head\n        second = head.next\n\n        first.next = self.swapPairs(second.next)\n        second.next = first\n\n        return second\n\n        # recursion\n        # time: O(n)\n        # space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439669532","body":"```py\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n\n        def get_length(node):\n            length = 0\n            cur = node\n            while cur:\n                cur = cur.next\n                length += 1\n            return length\n        \n        def build_bst(left, right):\n            nonlocal head\n            # Base case: \n            # when the start index exceeds the end index, return None\n            if left > right:\n                return None\n\n            mid = (left + right) // 2\n\n            # Recursively construct the left and right subtrees of the current root node\n            left = build_bst(left, mid - 1)\n            # Create the root node using the middle element\n            root = TreeNode(head.val)\n            root.left = left\n\n            head = head.next\n\n            right = build_bst(mid + 1, right)\n            root.right = right\n\n            return root\n\n        length = get_length(head)\n        return build_bst(0, length - 1)\n\n    # time: O(nlogn)\n    # space: O(logn)\n```\n\n```py\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        # The pointer used to disconnect the left half from the mid node.\n        def getMiddle(node):\n            pre = None\n            slow = node\n            fast = node\n            \n            # Iterate until fast pointer doesn't reach the end of the linked list.\n            while fast and fast.next:\n                pre = slow\n                slow = slow.next\n                fast = fast.next.next\n            \n            # Handling the case when slow pointer was equal to head.\n            if pre:\n                pre.next = None\n            \n            return slow\n        \n        if not head:\n            return None\n        \n        # The mid becomes the root of the BST.\n        mid = getMiddle(head)\n        root = TreeNode(mid.val)\n\n         # Base case: \n         # when there is just one element in the linked list\n        if head == mid:\n            return root\n        \n        # Recursively form balanced BSTs using the left and right halves of the original list.\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n\n        return root\n\n    # time: O(nlogn)\n   # space: O(logn)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441283015","body":"```py\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        pa = headA\n        pb = headB\n\n        while pa != pb:\n            pa = pa.next if pa else headB\n            pb = pb.next if pb else headA\n        \n        return pa\n       \n        # two pointers\n        # time: O(len(A) + len(B))\n        # space: O(1)\n\n        # In the case lists do not intersect, the pointers for A and B  will still line up in the 2nd iteration, \n        # just that here won't be a common node down the list and both will reach their respective ends at the same time. \n        # So pA will be NULL in that case.\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442803315","body":"- hashing\n```py\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return None\n\n        node_set = set()\n        cur = head\n\n        while cur:\n            if cur in node_set:\n                return cur\n            node_set.add(cur)\n            cur = cur.next\n        \n        return None\n\n        # hashing\n        # time: O(n)\n        # space: O(n)\n```\n\n- Floyd's cycle-finding\n```py\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return None\n        \n        fast = head\n        slow = head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n            if slow == fast:\n                # reset slow to head and keep fast at the point where they met\n                slow = head\n                while slow != fast:\n                    slow = slow.next\n                    fast = fast.next\n                return slow\n        \n        return None\n\n        # Floyd's cycle-finding algorithm\n        # time: O(n)\n        # space: O(1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445046830","body":"```py\nclass ListNode:\n    def __init__(self, key=None, val=None):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            node = self.cache[key]\n            self.remove(node)\n            self.add_to_head(node)\n            return node.val\n        else:\n            return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            node = self.cache[key]\n            self.remove(node)\n        if len(self.cache) == self.capacity:\n            self.remove(self.head.next)\n        self.add_to_head(ListNode(key, value))       \n    \n    def remove(self, node):\n        del self.cache[node.key]\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_head(self, node):\n        self.cache[node.key] = node\n        pre_tail = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n        pre_tail.next = node\n        node.prev = pre_tail\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445304344","body":"```py\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n\n        # recursion, dfs\n        # time: O(n) n = number of node\n        # space: O(h) h = height of tree\n        #        best: balanced, O(logn) \n        #        worst: complemetely unbalanced, O(n)\n        #        average: usually close to balanced, O(logn)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445931694","body":"```py\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        \n        if not p or not q:\n            return False\n        \n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\n        # dfs\n        # time: O(n)\n        # space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447751968","body":"```py\nclass Solution:\n    def __init__(self, root_to_leaf=0):\n        self.root_to_leaf = root_to_leaf\n    \n    def preorder(self, root: TreeNode, cur: int) -> None:\n        # base case\n        if not root:\n            return\n        \n         # update the current sum\n        cur = cur * 10 + root.val\n\n        # if node is a leaf node, add the current sum to the total sum\n        if not root.left and not root.right:\n            self.root_to_leaf += cur\n        \n        # recurse on the left subtree and right subtree\n        self.preorder(root.left, cur)\n        self.preorder(root.right, cur)\n\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        self.preorder(root, 0)\n        return self.root_to_leaf\n    \n    # dfs, preorder tranveral\n    # time: O(n) \n    # space: O(h)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449664681","body":"- dfs\n```py\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        self.max_height = 0\n        self.res = 0\n        self.dfs(root, 1)\n        return self.res\n\n    def dfs(self, root, height):\n        if not root:\n            return\n        height += 1\n        if height > self.max_height:\n            self.max_height = height\n            self.res = root.val\n        \n        self.dfs(root.left, height)\n        self.dfs(root.right, height)\n\n    # dfs \n    # time: O(n)\n    # space: O(h)\n```\n\n- bfs\n```py\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue = collections.deque()\n        queue.append(root)\n        left_bottom = 0\n\n        while queue:\n            size = len(queue)  \n            # to save space, level lists are not needed\n            for _ in range(size):\n                node = queue.popleft()\n\n                # append from right to left, so that the last node we traverse is the leftmost node\n                if node.right:\n                    queue.append(node.right)\n                if node.left:\n                    queue.append(node.left)\n\n                # update left_bottom when iterating every level\n                left_bottom = node.val\n\n        return left_bottom\n\n        # bfs, level order \n        # time: O(n)\n        # space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451449129","body":"- dfs\n```py\nclass Codec:\n\n    def serialize(self, root):\n        return self.serialize_helper(root, '')\n\n    def serialize_helper(self, root, string):\n        if not root:\n            string += 'None,'\n        else:\n            string += str(root.val) + ','\n            string = self.serialize_helper(root.left, string)\n            string = self.serialize_helper(root.right, string)\n        return string    \n\n    def deserialize(self, data):\n        data_queue = collections.deque(data.split(','))\n        root = self.deserialize_helper(data_queue)\n        return root\n\n    def deserialize_helper(self, queue):\n        if not queue:\n            return None\n        if queue[0] == 'None':\n            queue.popleft()\n            return None\n        \n        root = TreeNode(queue.popleft())\n        root.left = self.deserialize_helper(queue)\n        root.right = self.deserialize_helper(queue)\n        return root\n```\n\n- bfs\n```py\nclass Codec:\n\n    def serialize(self, root):\n        if not root:\n            return ''\n\n        queue = collections.deque()\n        queue.append(root)\n        res_ls = []\n\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                node = queue.popleft()\n                if node:\n                    res_ls.append(str(node.val))\n                    queue.append(node.left)\n                    queue.append(node.right)\n                else:\n                    res_ls.append('None')\n        return ','.join(res_ls)\n\n\n    def deserialize(self, data):\n        if not data:\n            return None\n\n        data_ls = data.split(',')\n        root = TreeNode(int(data_ls[0]))\n\n        queue = collections.deque()\n        queue.append(root)   \n        i = 1\n\n        while queue and i < len(data_ls):\n            node = queue.popleft()\n            if data_ls[i] != 'None':\n                node.left = TreeNode(int(data_ls[i]))\n                queue.append(node.left)\n            i += 1\n            if data_ls[i] != 'None':\n                node.right = TreeNode(int(data_ls[i]))\n                queue.append(node.right)\n            i += 1\n        return root\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453214360","body":"```py\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        self.node_ls = []\n\n        # step1: construct the node list, with the coordinates\n        self.dfs(root, 0, 0)\n\n        # step2: sort the node list globally, according to the coordinates\n        y_map = collections.defaultdict(list)\n        for y, x, val in sorted(self.node_ls):\n            y_map[y].append(val)\n\n        return list(y_map.values())\n\n\n    def dfs(self, root, y, x):\n        if not root:\n            return \n        # preorder\n        self.node_ls.append((y, x, root.val))\n        self.dfs(root.left, y - 1, x + 1)\n        self.dfs(root.right, y + 1, x + 1)\n\n\n    # dfs preorder + sort + dict\n    # time: O(nlogn)\n    # space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454672536","body":"```py\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        pairs = {}\n\n        for i, num in enumerate(nums):\n            if target - num in pairs:\n                return [pairs[target- num], i]\n            pairs[num] = i\n\n        return [-1, -1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455013840","body":"```py\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        if len(nums) == 1:\n            return nums\n\n        freqs = collections.Counter(nums)\n        minheap = []\n        heapq.heapify(minheap)\n\n        for num, freq in freqs.items():\n            if len(minheap) < k or freq > minheap[0][0]:\n                heapq.heappush(minheap, (freq, num))\n            if len(minheap) > k:\n                heapq.heappop(minheap)\n        \n        return [num for freq, num in minheap]\n\n        # heap top k\n        # time: O(nlogk)\n        # space: O(n + k)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455744240","body":"```py\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n        # For each point, compute the distance to all other points in the set\n        for p in points:\n            # Store the distances in a dict, where the keys are the distances and the values are the number of points that are that distance away\n            freqs = collections.defaultdict(int)\n            for q in points:\n                dis = (p[0] - q[0]) **2 + (p[1] - q[1]) **2\n                freqs[dis] += 1\n\n            # For each point, iterate through the dict and count the number of boomerangs that can be formed using that point \n            for freq in freqs.values():\n                res += freq * (freq - 1)\n \n        return res\n\n        # hash + permutation\n        # time: O(n^2)\n        # space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457738768","body":"```py\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if len(s) <= 1:\n            return len(s)\n        \n        unique = set()\n        max_len = 0\n        start = 0\n\n        for end, ch in enumerate(s):\n            while ch in unique:\n                unique.remove(s[start])\n                start += 1\n            \n            unique.add(ch)\n            max_len = max(max_len, len(unique))\n        \n        return max_len\n\n        # two pointers\n        # time: O(n)\n        # space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459696608","body":"```py\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        ans = []\n        s_size = len(s)\n        word_len = len(words[0])\n        word_count = collections.Counter(words)\n\n        def sliding_window(left):\n            found_count = collections.defaultdict(lambda: 0)\n            total_matched = 0\n\n            for right in range(left, len(s), word_len):\n                if right + word_len > s_size:\n                    break\n                \n                new_word = s[right: right + word_len]\n                if new_word not in word_count:\n                    found_count = collections.defaultdict(lambda: 0)\n                    total_matched = 0\n                    left = right + word_len\n                else:\n                    found_count[new_word] += 1\n                    if found_count[new_word] > word_count[new_word]:\n                        while found_count[new_word] > word_count[new_word]:\n                            left_most = s[left: left + word_len]\n                            found_count[left_most] -= 1\n                            left += word_len\n                            if left_most != new_word:\n                                total_matched -= 1\n                    else:\n                        total_matched += 1\n\n                if total_matched == len(words):\n                    ans.append(left)\n\n        for i in range(word_len):\n            sliding_window(i)\n\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461703472","body":"```py\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        remainder = sum(nums) % p\n        if remainder == 0:\n            return 0\n        \n        hashmap = {0:-1}\n        presum = 0\n        res = len(nums)\n\n        for i, num in enumerate(nums):\n            presum += num\n            hashmap[presum % p] = i\n\n            target = (presum - remainder) % p\n            if target in hashmap:\n                res = min(res, i - hashmap[target])    \n   \n        return res if res < len(nums) else -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463495832","body":"```py\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return None\n\n        slow = head\n        fast = head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464878106","body":"```py\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:        \n        slow = 0\n        fast = 0\n\n        while fast < len(nums):\n            while fast < len(nums) and nums[fast] == nums[slow]:\n                fast += 1\n            slow += 1\n                \n            if fast == len(nums):\n                break\n            nums[slow] = nums[fast]\n\n        return slow\n\n        # two pointers\n        # time: O(n)\n        # space: O(1)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465146111","body":"```py\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left = 0\n        right = len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            if target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return left\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465637076","body":"- max heap\r\n```py\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        maxheap = [(-nums[i], i) for i in range(k)]\r\n        heapq.heapify(maxheap)\r\n\r\n        res = []\r\n        res.append(-maxheap[0][0])\r\n\r\n        for i in range(k, len(nums)):\r\n            heapq.heappush(maxheap, (-nums[i], i))\r\n\r\n            while i - maxheap[0][1] >= k:\r\n                heapq.heappop(maxheap)\r\n            res.append(-maxheap[0][0])\r\n        \r\n        return res\r\n\r\n        # max heap\r\n        # time: O(n * logn)\r\n        # space: O(n)\r\n```\r\n\r\n- mono deque\r\n```py\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        deque = collections.deque()\r\n        for i in range(k):\r\n            while deque and nums[i] >= deque[-1][0]:\r\n                deque.pop()\r\n            deque.append((nums[i], i))\r\n        \r\n        res = []\r\n        res.append(deque[0][0])\r\n\r\n        for i in range(k, len(nums)):\r\n            while deque and nums[i] >= deque[-1][0]:\r\n                deque.pop()\r\n            deque.append((nums[i], i))\r\n        \r\n            while i - deque[0][1] >= k:\r\n                deque.popleft()\r\n            res.append(deque[0][0])\r\n        \r\n        return res\r\n\r\n        # desending mono-deque\r\n        # time: O(n)\r\n        # space: O(n)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467630710","body":"```py\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        if len(trust) < n - 1:\n            return -1\n        \n        if len(trust) <= 1:\n            return trust[0][1] if trust else 1\n        \n        \n        scores = [0] * (n + 1)\n\n        for a, b in trust:\n            scores[a] -= 1\n            scores[b] += 1\n        \n        for i, score in enumerate(scores):\n            if score == n - 1:\n                return i\n        \n        return -1\n    \n    # time: O(n)\n    # space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469669699","body":"```py\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        neighbors = [[] for _ in range(n + 1)]\n        for x, y in dislikes:\n            neighbors[x].append(y)\n            neighbors[y].append(x)\n        colors = [-1] * (n + 1)\n\n        for i in range(1, n + 1):\n            if colors[i] == -1:\n                if not self.dfs(i, 0, colors, neighbors):\n                    return False\n        return True\n    \n    def dfs(self, n, color, colors, neighbors):\n        colors[n] = color\n        for neighbor in neighbors[n]:\n            if colors[neighbor] == colors[n]: \n                return False\n            if colors[neighbor] == -1:\n                if not self.dfs(neighbor, 1 - color, colors, neighbors):\n                    return False\n        return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1471475779","body":"```py\nclass Solution:\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for project in range(n):\n            if group[project] == -1:\n                group[project] = max_group_id\n                max_group_id += 1\n\n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n\n        for project in range(n):\n            group_projects[group[project]].append(project)\n\n            for pre in pres[project]:\n                if group[pre] != group[project]:\n                    # 小组关系图\n                    group_indegree[group[project]] += 1\n                    group_neighbors[group[pre]].append(group[project])\n                else:\n                    # 项目关系图\n                    project_indegree[project] += 1\n                    project_neighbors[pre].append(project)\n\n        ans = []\n        # 先对组进行拓扑排序\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\n\n        if len(group_queue) != max_group_id:\n            return []\n\n        for group_id in group_queue:\n            # 对小组中的项目进行拓扑排序\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n\n            if len(project_queue) != len(group_projects[group_id]):\n                return []\n            ans += project_queue\n\n        return ans\n\n\n    def tp_sort(self, items, indegree, neighbors):\n        q = collections.deque([])\n        ans = []\n        for item in items:\n            if not indegree[item]:\n                q.append(item)\n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if not indegree[neighbor]:\n                    q.append(neighbor)\n\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473399737","body":"```py\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        x = 0\n        y = 0\n        for move in moves:\n            match move:\n                case \"U\":\n                    y += 1\n                case \"D\":\n                    y -= 1\n                case \"L\":\n                    x -= 1\n                case \"R\":\n                    x += 1\n        return x == 0 and y == 0\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474785971","body":"```py\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        # sorting key: the shortest processing time; smallest index\n        processes = [(enqueueTime, i, processingTime) for i, (enqueueTime, processingTime) in enumerate(tasks)]\n        processes.sort()\n        \n        # store the res: order (index)\n        order = []\n        # store the task queue, minheap\n        queue = []\n        heapq.heapify(queue)\n\n        n = len(tasks)\n        timestamp = 0\n        pos = 0\n\n        for _ in range(n):\n            # if task queue is empty, fast forward\n            if not queue:\n                timestamp = max(timestamp, processes[pos][0])\n            while pos < n and processes[pos][0] <= timestamp:\n                heapq.heappush(queue, (processes[pos][2], processes[pos][1]))\n                pos += 1\n            processingTime, i = heapq.heappop(queue)\n            timestamp += processingTime\n            order.append(i)\n        \n        return order\n\n        # time: O(n * logn)\n        # space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475200508","body":"```py\nclass Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        def convertToMinutes(tempTime):\n            return 60 * int(tempTime[:2] + int(tempTime[3:]))\n        \n        t0 = convertToMinutes(loginTime)\n        t1 = convertToMinutes(logoutTime)\n\n        if t1 < t0:\n            t1 += 24 * 60\n        \n        t1 = t1 // 15 * 15\n        return (t1 - t0) // 15\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475835060","body":"```py\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        counter_a = self.getCounter(a)\n        counter_b = self.getCounter(b)\n\n        condition1 = self.lessThanAnother(counter_a, counter_b)\n        condition2 = self.lessThanAnother(counter_b, counter_a)\n        condition3 = self.bothDistinct(a, b, counter_a, counter_b)\n\n        print(condition1, condition2, condition3)\n        return min(condition1, condition2, condition3)\n\n    def getCounter(self, s: str) -> List[int]:\n        counter = [0] * 26\n        for ch in s:\n            counter[ord(ch) - ord('a')] += 1\n        return counter\n    \n    def lessThanAnother(self, counter1: List[int], counter2: List[int]):\n        min_op = sys.maxsize\n        for i in range(1, 26):\n            op = sum(counter1[i:]) + sum(counter2[:i])\n            min_op = min(min_op, op)\n        return min_op\n\n    def bothDistinct(self, s1: str, s2: str, counter1: List[int], counter2: List[int]):\n        min_op = sys.maxsize\n        len1 = len(s1)\n        len2 = len(s2)\n        for i in range(26):\n            op = (len1 - counter1[i]) + (len2 - counter2[i])\n            min_op = min(min_op, op)\n        return min_op\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477432814","body":"```py\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        # convert arr to a max heap\n        for i in range(n // 2, -1, -1):\n            self.heapify(nums, n, i)\n        # extract the maximum element and place it at the end of arr\n        for i in range(n - 1, 0, -1):\n            nums[i], nums[0] = nums[0], nums[i]\n            self.heapify(nums, i, 0)\n        return nums\n    \n    def heapify(self, arr, n, i):\n        # assume the current node i is the largest\n        largest = i\n        # find the left and right child nodes of the current nod\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        # if the left child is larger than the current node,\n        # update the largest index\n        if left < n and arr[i] < arr[left]:\n            largest = left\n        # if the right child is larger than the current node or the left child,\n        # update the largest index\n        if right < n and arr[largest] < arr[right]:\n            largest = right\n        # if the largest index is not the current node,\n        # recusively heapify the subtree rooted at the largest index\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            self.heapify(arr, n, largest)\n    \n    # heap sort\n    # time: O(nlogn)\n    # space: O(1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479043422","body":"```py\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x <= 1:\n            return x\n        \n        left = 2\n        right = x // 2\n        while left <= right:\n            pivot = left + (right - left) // 2\n            num = pivot ** 2\n            if num == x:\n                return pivot\n            if num < x:\n                left = pivot + 1\n            else:\n                right = pivot - 1\n            \n        return right\n            \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480598432","body":"```py\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        left = 1\n        right = n\n\n        while left < right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482466841","body":"```py\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        # define a helper function to count the number of reverse pairs recursively\n        def mergeSort(start: int, end: int) -> int:\n            # base case: if the subarray has less than 2 elements, return 0\n            if start >= end:\n                return 0\n            \n            mid = start + (end - start) // 2\n            count = mergeSort(start, mid) + mergeSort(mid + 1, end)\n            \n            # count the number of reverse pairs between the two halves of the subarray\n            i, j = start, mid + 1\n            while i <= mid and j <= end:\n                if nums[i] > 2 * nums[j]:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            \n            # sort the subarray by merging its two halves\n            nums[start:end+1] = sorted(nums[start:end+1])\n            \n            return count\n        \n        # call the helper function on the entire array and return the result\n        return mergeSort(0, len(nums) - 1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483747821","body":"```py\nclass Solution:\n    def solve(self, nums):\n        nums.sort()\n        N = len(nums)\n        if N <= 3:\n            return 0\n        LIGHTS = 3\n\n        def possible(diameter):\n            start = nums[0]\n            end = start + diameter\n            for i in range(LIGHTS):\n                idx = bisect_right(nums, end)\n                if idx >= N:\n                    return True\n                start = nums[idx]\n                end = start + diameter\n            return False\n\n        l, r = 0, nums[-1] - nums[0]\n        while l <= r:\n            mid = (l + r) // 2\n            if possible(mid):\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l / 2\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1484028643","body":"```py\nclass Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        # binary search\n        nums.sort()\n        left = 0\n        # kth dist always falls in [0, max(nums) - min(nums)]\n        right = nums[-1] - nums[0]\n        while left < right:\n            mid = left + (right - left) // 2\n            count = self.countPairsWithSmallerDistance(nums, mid)\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\n    def countPairsWithSmallerDistance(self, nums, mid) -> int:\n        # Counts the number of pairs with a pair distance less than or equal to mid.    \n        # two pointers\n        count = 0\n        i = 0\n        for j in range(len(nums)):\n            while nums[j] - nums[i] > mid:\n                i += 1\n            count += j - i\n        return count\n\n    \n    # time: O(nlogn + nlogd)\n    # space: O(logn)\n    # d = max(nums) - min(nums)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484845772","body":"```py\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        def bfs(t, x, y, visited):\n            if x == y == n - 1:\n                return True\n            visited[x][y] = True\n            for dx, dy in ((-1,0),(1,0),(0,-1),(0,1)):\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] <= t:     \n                    if bfs(t, nx, ny, visited):\n                        return True\n            return False\n\n        left = max(grid[0][0], grid[-1][-1])\n        right = n * n - 1\n        while left <= right:\n            mid = (left + right) // 2\n            visited = [[False] * n for _ in range(n)]\n            if bfs(mid, 0, 0, visited):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486332433","body":"```py\r\nclass Solution:\r\n    def maxVowels(self, s: str, k: int) -> int:\r\n        vow = set(['a', 'e', 'i', 'o', 'u'])\r\n\r\n        # construct first window\r\n        count = 0\r\n        for ch in s[:k]:\r\n           count += ch in vow\r\n        \r\n        # slide from k to len(s) - 1\r\n        # update max_count dynamically\r\n        left = 0\r\n        max_count = count    \r\n        for i in range(k, len(s)):\r\n            count -= s[left] in vow\r\n            count += s[i] in vow\r\n            left += 1\r\n            max_count = max(max_count, count)\r\n        return max_count\r\n\r\n        # sliding window\r\n        # time: O(n)\r\n        # space: O(5)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488200993","body":"```py\nclass Solution:\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\n        if k == 0:\n            return 1.0\n        \n        dp = [0.0] * (k + maxPts)\n        for i in range(k, min(n, k + maxPts - 1) + 1):\n            dp[i] = 1.0\n        \n        dp[k - 1] = float(min(n - k + 1, maxPts)) / maxPts\n\n        for i in range(k - 2, -1, -1):\n            dp[i] = dp[i + 1] - (dp[i + maxPts + 1] - dp[i + 1]) / maxPts\n        return dp[0]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1490040177","body":"```py\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        if len(s) < len(p):\n            return []\n\n        p_count, s_count = [0] * 26, [0] * 26\n\n        for ch in p:\n            p_count[ord(ch) - ord('a')] += 1\n        \n        res = []\n        # sliding window on the string s\n        for i in range(len(s)):\n            s_count[ord(s[i]) - ord('a')] += 1  # add\n            if i >= len(p):\n                s_count[ord(s[i - len(p)]) - ord('a')] -= 1  # remove\n            # compare array in the sliding window with the reference array\n            if p_count == s_count:\n                res.append(i - len(p) + 1)\n        \n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491768446","body":"```py\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        l, counter, N, ct = 0, Counter(), len(s), Counter(t)\n        k = 0\n        ret, ans = inf, \"\"\n        for r in range(N):\n            counter[s[r]] += 1\n            if s[r] in t and counter[s[r]] == ct[s[r]]:\n                k += 1\n            while k == len(ct):\n                if r - l + 1 < ret:\n                    ans = s[l:r+1]\n                ret = min(r - l + 1, ret)\n                counter[s[l]] -= 1\n                if s[l] in t and counter[s[l]] == ct[s[l]]-1:\n                    k -= 1\n                l += 1\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1492912730","body":"```py\nclass Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints)\n        totalSum = sum(cardPoints)\n        windowSum = sum(cardPoints[:n - k])\n        maxPoints = totalSum - windowSum\n\n        for i in range(k):\n            windowSum += cardPoints[n - k + i] - cardPoints[i]\n            maxPoints = max(maxPoints, totalSum - windowSum)\n        \n        return maxPoints\n\n        # sliding window\n        # time: O(n)\n        # space: O(1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493279003","body":"```py\nclass Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        res = []\n        for h in range(12):\n            for m in range(60): \n                if bin(h).count('1') + bin(m).count('1') == turnedOn:\n                    res.append(str(h) + ':' + (\"0\" if m < 10 else \"\") + str(m))\n        return res\n\n        # enumeration\n        # time: O(1) 12*60\n        # space: O(1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1493865754","body":"```py\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        cols = set()\n        dia1 = set()\n        dia2 = set()\n\n        def backtrack(row):\n            if row == n:\n                return 1\n            \n            count = 0\n            for i in range(n):\n                if i in cols or row - i in dia1 or row + i in dia2:\n                    continue\n                cols.add(i)\n                dia1.add(row - i)\n                dia2.add(row + i)\n                count += backtrack(row + 1)\n\n                cols.remove(i)\n                dia1.remove(row - i)\n                dia2.remove(row + i)\n            return count\n        \n        return backtrack(0)\n\n        # backtrack\n        # time: O(n!)\n        # space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495467717","body":"```py\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        max_area = 0\n        visited = set()\n\n        def dfs(r, c):\n            if not (0 <= r < len(grid) and 0 <= c < len(grid[0])):\n                return 0\n            if (r, c) in visited:\n                return 0 \n            if grid[r][c] == 0:\n                return 0\n            visited.add((r, c))\n            area = 1\n            for dir_r, dir_c in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                area += dfs(r + dir_r, c + dir_c)\n            return area\n        \n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == 1:\n                    max_area = max(max_area, dfs(r, c))\n        return max_area\n\n        # matrix dfs\n        # time: O(r * c)\n        # time: O(r * c)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497157024","body":"```py\nclass Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n       \n        max_dist = 0\n        n = len(grid)\n        land_q = collections.deque()\n        visited = set()\n\n        def isNewSource(i, j):\n            return 0 <= i < n and 0 <= j < n and (i, j) not in visited and grid[i][j] == 0\n\n        for r in range(n):\n            for c in range(n):\n                if grid[r][c] == 1:\n                    land_q.append((r, c, 0))\n                    visited.add((r, c))\n\n        if not land_q or len(land_q) == n**2:           \n            return -1\n        \n        while land_q:\n            len_q = len(land_q)\n            for _ in range(len_q):\n                r, c, dist = land_q.popleft()\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    new_r = r + dr\n                    new_c = c + dc\n                \n                    if isNewSource(new_r, new_c):\n                        land_q.append((new_r, new_c, dist + 1))\n                        visited.add((new_r, new_c))\n                        max_dist = max(max_dist, dist + 1)\n        return max_dist\n\n        # multisource bfs\n        # time: O(n**2)\n        # space: O(**2)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498652634","body":"```py\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        n = len(status)\n        has_box = [0] * n\n        visited = [0] * n\n\n        q = collections.deque()\n        res = 0\n\n        for box in initialBoxes:\n            has_box[box] = 1\n            if status[box]:\n                q.append(box)\n                visited[box] = 1\n                res += candies[box]\n        \n        while q:\n            big_box = q.popleft()\n            for key in keys[big_box]:\n                status[key] = 1\n                if not visited[key] and has_box[key]:\n                    q.append(key)\n                    visited[key] = 1\n                    res += candies[key]\n            for box in containedBoxes[big_box]:\n                has_box[box] = 1\n                if not visited[box] and status[box]:\n                    q.append(box)\n                    visited[box] = 1\n                    res += candies[box]\n        return res\n\n        # bfs\n        # time: O(n)\n        # space: o(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1500070260","body":"```py\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        self.node_ls = []\n        # construct the node list, with the coordinates\n        self.dfs(root, 0, 0)\n        # sort the node list globally, according to the coordinates\n        y_map = collections.defaultdict(list)\n        for y, x, val in sorted(self.node_ls):\n            y_map[y].append(val)\n\n        return list(y_map.values())\n\n    def dfs(self, root, y, x):\n        if not root:\n            return \n        # preorder\n        self.node_ls.append((y, x, root.val))\n        self.dfs(root.left, y - 1, x + 1)\n        self.dfs(root.right, y + 1, x + 1)\n\n        # dfs + sort\n        # time: O(nlogn)\n        # space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500836153","body":"```py\nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        tab = [0] * (len(cost) + 1)\n   \n        for i in range(2, len(cost) + 1):\n            tab[i] = min(tab[i - 1] + cost[i - 1], tab[i - 2] + cost[i - 2])\n        \n        return tab[-1]\n\n        # time: O(n)\n        # space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501075269","body":"```py\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return nums[0]\n\n        tab = [0] * len(nums)\n        tab[0] = nums[0]\n        tab[1] = max(nums[0], nums[1])\n\n        for i in range(2, len(tab)):\n            tab[i] = max(tab[i - 2] + nums[i], tab[i - 1])\n        print(tab)\n        return tab[-1]\n        \n        # time: O(n)\n        # space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501468321","body":"```py\nclass Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 1\n        \n        dp = [[1, 1] for _ in range(n)] \n        # [length, count]\n        # length: 以 nums[i] 结尾的最长递增子序列的长度\n        # count: 以 nums[i] 结尾的最长递增子序列的个数\n        max_length = 1  # 最长递增子序列的长度\n\n        for i in range(1, n):\n            for j in range(i):\n                if nums[j] < nums[i]:\n                    # 如果长度更长，则更新\n                    if dp[j][0] + 1 > dp[i][0]:\n                        dp[i][0] = dp[j][0] + 1\n                        dp[i][1] = dp[j][1]\n                    # 如果长度相等，则累加个数\n                    elif dp[j][0] + 1 == dp[i][0]:\n                        dp[i][1] += dp[j][1]\n            # 更新最长递增子序列长度\n            max_length = max(max_length, dp[i][0])\n\n        res = 0\n        for k in range(n):\n            if dp[k][0] == max_length:\n                res += dp[k][1]\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1502802681","body":"```py\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        m, n = len(text1), len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        # 在 A[0:i] 与 B[0:j] 之间匹配得到的想要的结果\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[m][n]\n        \n        # 2d\n        # time: O(mn)\n        # space: O(mn)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1504763337","body":"```py\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[1] * n for _ in range(m)]\n\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n        return dp[m - 1][n - 1]\n\n        # dp 2d\n        # time: O(m * n)\n        # space: O(m * n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506572203","body":"```py\nclass Solution:\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n        dp = [[[0] * n for _ in range(n)] for _ in range(k + 1)]\n        for step in range(k + 1):\n            for i in range(n):\n                for j in range(n):\n                    if step == 0:\n                        dp[step][i][j] = 1\n                    else:\n                        for di, dj in ((-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2)):\n                            ni, nj = i + di, j + dj\n                            if 0 <= ni < n and 0 <= nj < n:\n                                dp[step][i][j] += dp[step - 1][ni][nj] / 8\n        return dp[k][row][column]\n\n# dp 3d\n# time: O(k × n**2)\n# space: O(k × n**2)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1508200589","body":"```py\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        if desiredTotal <= maxChoosableInteger:\n            return True\n        if sum(range(maxChoosableInteger + 1)) < desiredTotal:\n            return False\n        \n        @lru_cache(None)\n        def dp(used, cur_total):\n            if cur_total >= desiredTotal:\n                return False\n            if used == (1 << (maxChoosableInteger + 1)) - 1:\n                return False\n            for n in range(1, maxChoosableInteger + 1):\n                if used & 1 << n == 0:\n                    if not dp(used | 1 << n, cur_total + n):\n                        return True\n            return False\n\n        return dp(0, 0)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509718793","body":"```py\nclass Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        total = sum(nums)\n\n        if total % 2 == 1:\n            return False\n\n        subtotal = total // 2\n        n = len(nums)\n\n        dp = [False] * (subtotal + 1)\n        dp[0] = True\n\n        for num in nums:\n            for j in range(subtotal, num - 1, -1):\n                dp[j] = dp[j] or dp[j - num]\n        \n        return dp[subtotal]\n\n        # knapsack \n        # time: O(m * n)\n        # space: O(m)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510225340","body":"```py\nclass Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total = sum(nums)\n        if abs(target) > total or (target + total) % 2 == 1:\n            return 0\n\n        size = (total + target) // 2\n        dp = [0] * (size + 1)\n        dp[0] = 1\n\n        for i in range(len(nums)):\n            for j in range(size, nums[i] - 1, -1):\n                dp[j] += dp[j - nums[i]]\n\n        return dp[size]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1510928884","body":"```py\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [sys.maxsize] * (amount + 1)\n        dp[0] = 0\n\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] = min(dp[x], dp[x - coin] + 1)\n        \n        return dp[amount] if dp[amount] != sys.maxsize else -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1512743108","body":"```py\nclass Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n\n        for j in range(len(coins)):\n            for i in range(1, amount + 1):\n                if i >= coins[j]:\n                    dp[i] += dp[i - coins[j]]\n\n        return dp[-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514407773","body":"```py\r\nclass Solution:\r\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\r\n        g.sort()\r\n        s.sort()\r\n\r\n        i = 0\r\n        j = 0\r\n        res = 0\r\n\r\n        while i < len(g) and j < len(s):\r\n            while j < len(s) and g[i] > s[j]:\r\n                j += 1\r\n            if j < len(s):\r\n                res += 1\r\n            i += 1\r\n            j += 1\r\n        \r\n        return res\r\n\r\n        # time: O(mlogm+nlogn)\r\n        # space: O(logm+logn)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516021965","body":"```py\nclass Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key = lambda x:x[1])\n        count = 1\n        prev = intervals[0]\n        for interval in intervals[1:]:\n            if prev[1] <= interval[0]:\n                count += 1\n                prev = interval\n        return len(intervals) - count\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517559228","body":"```py\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        rightmost = 0\n        for i in range(len(nums)):\n            if i > rightmost:\n                return False\n            rightmost = max(rightmost, i + nums[i])\n        return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518589706","body":"```py\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n\n        for i in range(2, n + 1):\n            # 枚举根节点的位置 j（其值在 1~i 之间）\n            for j in range(1, i + 1):\n                dp[i] += dp[j - 1] * dp[i - j]\n        \n        return dp[-1]\n\n        # time: O(n ** 2)\n        # space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519018972","body":"```py\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if not lists:\n            return None\n            \n        n = len(lists)\n        interval = 1\n        while interval < n:\n            for i in range(0, n - interval, interval * 2):\n                lists[i] = self.merge2Lists(lists[i], lists[i + interval])\n            interval *= 2\n        \n        return lists[0]\n\n    def merge2Lists(self, l1, l2):\n        dummy = ListNode(0)\n        cur = dummy\n        while l1 and l2:\n            if l1.val <= l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n            cur = cur.next\n        \n        cur.next = l1 if l1 else l2\n        return dummy.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1519692912","body":"```py\nclass Solution:\n    def beautifulArray(self, n: int) -> List[int]:\n        memo = {}\n        return self.divide(n, memo)\n    \n    def divide(self, n, memo):\n        if n in memo:\n            return memo[n]        \n        if n == 1:\n            return [1]\n\n        odds = self.divide((n + 1) // 2, memo)\n        evens = self.divide(n // 2, memo)\n\n        left = [2*x-1 for x in odds]\n        right = [2*x for x in evens]\n\n        memo[n] =  left + right\n        return left + right\n\n        # divide\n        # time: (n logn)\n        # space: (n logn)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521399929","body":"```py\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        xorsum = 0\n        for num in nums:\n            xorsum ^= num\n        # xorsum = a ⊕ b, res = [a, b]\n\n        leastSignificantBit = xorsum ^ (-xorsum)\n        # isolate the rightmost 1-bit\n        # get a binary number that has only the least significant 1-bit of \"xorsum\" set to 1 and all other bits set to 0\n\n        a, b = 0, 0\n        for num in nums:\n            if num & leastSignificantBit:\n                a ^= num\n            else:\n                b ^= num\n    \n        return [a, b]\n\n        # time: O(n)\n        # space: O(1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1522983056","body":"```py\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        subset = []\n        n = len(nums)\n        for i in range(1 << n):\n            for j in range(n):\n                if i & (1 << j):\n                    subset.append(nums[j])\n            res.append(subset)\n            subset = []\n        \n        return res\n\n        # time: O(2ⁿ * n)\n        # space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1525379110","body":"```py\nclass TrieNode:\n    def __init__(self, char=\"\"):\n        self.char = char\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()    \n\n    def insert(self, word: str) -> None:\n        cur = self.root\n        for ch in word:\n            if ch in cur.children:\n                cur = cur.children[ch]\n            else:\n                new_node = TrieNode(ch)\n                cur.children[ch] = new_node\n                cur = new_node\n        cur.is_end = True     \n\n    def search(self, word: str) -> bool:\n        cur = self.root\n        for ch in word:\n            if ch not in cur.children:\n                return False\n            cur = cur.children[ch]\n        # Reach at the end of word.\n        # return True if word is present, i.e is_end = True else False\n        return cur.is_end\n        \n    def startsWith(self, prefix: str) -> bool:\n        cur = self.root\n        for ch in prefix:\n            if ch not in cur.children:\n                return False\n            cur = cur.children[ch]\n        return True\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startsWith(prefix)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1527208219","body":"```py\nclass TrieNode:\n    def __init__(self, value=0):\n        self.value = value\n        self.children = {}\n\nclass MapSum:\n    def __init__(self):\n        self.root = TrieNode()\n        self.map = {}\n        \n    def insert(self, key: str, val: int) -> None:\n        # diff between new val and old val(if exists) for the same key\n        delta = val - self.map.get(key, 0)\n        self.map[key] = val\n\n        cur = self.root\n        for ch in key:\n            if ch not in cur.children:\n                cur.children[ch] = TrieNode()\n            cur = cur.children[ch]\n            cur.value += delta \n\n        # time: O(len(key))\n        # space: O(number of keys * max length of keys)      \n\n\n    def sum(self, prefix: str) -> int:\n        cur = self.root\n        for ch in prefix:\n            if ch not in cur.children:\n                return 0\n            cur = cur.children[ch]\n        return cur.value\n\n        # time: O(len(prefix))\n        # space: O(len(prefix))\n        \n# Your MapSum object will be instantiated and called as such:\n# obj = MapSum()\n# obj.insert(key,val)\n# param_2 = obj.sum(prefix)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528720901","body":"```py\nclass TrieNode:\n    def __init__(self, ch=\"\"):\n        self.ch = ch\n        self.children = {}\n        self.stored_word = None\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, words):\n        for word in words:\n            cur = self.root\n            for ch in word:\n                if ch not in cur.children:\n                    cur.children[ch] = TrieNode(ch)\n                cur = cur.children[ch]\n            cur.stored_word = word\n\n    def search(self, s):\n        res = []\n        cur = self.root \n        \n        for ch in s:\n            if ch not in cur.children:\n                break\n            cur = cur.children[ch]\n            if cur.stored_word:    \n                res.append(cur.stored_word) \n        return res\n            \n\nclass Solution:\n    def multiSearch(self, big: str, smalls: List[str]) -> List[List[int]]:\n        trie = Trie()\n        trie.insert(smalls)\n        hit = collections.defaultdict(list)\n\n        for i in range(len(big)):\n            matches = trie.search(big[i:])\n            for word in matches:\n                hit[word].append(i)\n        \n        res = []\n        for word in smalls:\n            res.append(hit[word])\n        return res\n\n    # time：O(len(big) * len(smalls))\n    # space：O(len(smalls) * max len of smalls[i])\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1528968128","body":"```py\nclass UnionFind:\n    def __init__(self, size: int):\n        self.root = [i for i in range(size)]\n        self.rank = [1] * size\n        self.component_count = size\n    \n    def find(self, x: int) -> int:\n        if x == self.root[x]:\n            return x\n        return self.find(self.root[x])\n    \n    def union(self, x: int, y: int) -> None:\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx == ry:\n            return\n        if self.rank[rx] >= self.rank[ry]:\n            self.root[ry] = rx\n            rank_up = 1 if self.rank[rx] == self.rank[ry] else 0\n            self.rank[rx] += rank_up\n        else:\n            self.root[rx] = ry\n        self.component_count -= 1\n\nclass Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        size = len(isConnected)\n        uf = UnionFind(size)\n        for i in range(size):\n            for j in range(size):\n                if isConnected[i][j] == 1:\n                    uf.union(i, j)\n        return uf.component_count\n\n        # time: O(n**2 * α(n))\n        # space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1529442532","body":"```py\nclass DSU:\n    def __init__(self, n):\n        self.root = list(range(n))\n        self.rank = [1] * n\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.root[x] != x:\n            self.root[x] = self.find(self.root[x])\n        return self.root[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return\n        xrank, yrank = self.rank[xr], self.rank[yr]\n        if xrank >= yrank:\n            self.root[yr] = xr\n            self.size[xr] += self.size[yr]\n            rank_up = 1 if xrank == yrank else 0\n            self.rank[xr] += rank_up \n        else:\n            self.root[xr] = yr\n            self.size[yr] += self.size[xr]\n\n    def get_size(self, x):\n        return self.size[self.find(x)]\n\n\nclass Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        n = len(graph)\n        dsu = DSU(n)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if graph[i][j] == 1:\n                    dsu.union(i, j)\n\n        count = collections.Counter(dsu.find(u) for u in initial)\n        res = (-1, min(initial))\n        for node in initial:\n            root = dsu.find(node)\n            if count[root] == 1:  # unique color\n                if dsu.get_size(root) > res[0]:\n                    res = dsu.get_size(root), node\n                elif dsu.get_size(root) == res[0] and node < res[1]:\n                    res = dsu.get_size(root), node\n\n        return res[1]\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1531041962","body":"```py\r\nclass UnionFind:\r\n    def __init__(self, n):\r\n        self.root = list(range(n))\r\n        self.rank = [1] * n\r\n        self.set_count = n\r\n\r\n    def find(self, x: int) -> int:\r\n        if x == self.root[x]:\r\n            return x\r\n        return self.find(self.root[x])\r\n\r\n    def union(self, x: int, y: int):\r\n        root_x, root_y = self.find(x), self.find(y)\r\n        if root_x == root_y:\r\n            return\r\n        rank_x, rank_y = self.rank[root_x], self.rank[root_y]\r\n        if rank_x >= rank_y:\r\n            self.root[root_y] = root_x\r\n            rank_up = 1 if rank_x == rank_y else 0\r\n            self.rank[root_x] += rank_up\r\n        else:\r\n            self.root[root_x] = root_y\r\n        self.set_count -= 1\r\n    \r\n    def connected(self, x: int, y: int) -> bool:\r\n        return self.find(x) == self.find(y)\r\n\r\nclass Solution:\r\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\r\n        if len(connections) < n - 1:\r\n            return -1\r\n\r\n        uf = UnionFind(n)\r\n        for x, y in connections:\r\n            uf.union(x, y)\r\n\r\n        return uf.set_count - 1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1532565866","body":"```py\nclass Solution:\n    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n        \n        root.left = self.pruneTree(root.left)\n        root.right = self.pruneTree(root.right)\n        if not root.left and not root.right and root.val == 0:\n            return None\n        return root\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1534245046","body":"```py\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        res = []\n        self.backtrack(candidates, target, 0, [], res)\n        return res\n    \n    def backtrack(self, candidates, remain, start, comb, res):\n        if remain < 0:\n            return\n        if remain == 0:\n            res.append(list(comb))\n        for i in range(start, len(candidates)):\n            comb.append(candidates[i])\n            self.backtrack(candidates, remain - candidates[i], i, comb, res)\n            comb.pop()\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1536022665","body":"```py\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n        res = []\n        self.backtrack(candidates, target, 0, [], res)\n        return res\n\n    def backtrack(self, candidates, remain, start, comb, res):\n        if remain == 0:\n            res.append(list(comb))\n            return\n\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n\n            temp = remain - candidates[i]\n            if temp < 0:\n                break\n\n            comb.append(candidates[i])\n            self.backtrack(candidates, temp, i + 1, comb, res)\n            comb.pop()\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1537104554","body":"```py\nclass Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        used = [False] * len(nums)\n        nums.sort()\n        self.backtrack(nums, 0, used, [], res)\n        return res\n    \n    def backtrack(self, nums, start, used, perm, res):\n        if start == len(nums):\n            res.append(perm[:])\n            return\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            # pruning\n            if i > 0 and nums[i] == nums[i - 1] and used[i - 1]:\n                continue\n                \n            perm.append(nums[i])\n            used[i] = True\n            self.backtrack(nums, start + 1, used, perm, res)\n            perm.pop()\n            used[i] = False\n```","onTime":true},null,null,null,null,null,null,null,null,null],"el1as7":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429303877","body":"思路：两个数组，从最后位开始依次计算。遇到结果大于10的留位。\n\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        length=len(num)\n        res=[]\n        n=length-1\n        summary,carry=0,0\n        while n >=0 or k !=0: \n            upper_end=num[n] if n>=0 else 0\n            low_end=k%10 if k !=0 else 0\n            summary=upper_end+low_end+carry\n            carry = summary // 10\n            k//=10\n            n-=1\n            res.append(summary%10)\n        if carry !=0: \n            res.append(carry)\n        return res[::-1]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431302350","body":"\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        l = r = 0\n        n = len(s)\n        res = [n] * n\n        flag = False  \n        while r <= n - 1:\n            if s[r] == c:\n                res[r] = 0\n                while l <= r:\n                    res[l] = min(res[l], r - l)\n                    l += 1\n                r += 1\n                flag = True\n            else:\n                if flag:\n                    res[r] = res[r-1] + 1\n                r += 1\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432934190","body":"class CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top < self.maxSize - 1:\n            self.top += 1\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        value = self.stack[self.top]\n        self.top -= 1\n        return value\n\n    def inc(self, k: int, val: int) -> None:\n        length = min(k, self.top + 1)\n        for i in range(length):\n            self.stack[i] += val\n首先检查栈是否为空，如果为空，则返回 -1。否则的话弹出栈顶元素并将其返回","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434703109","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zcytm3000":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429313172","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        a=0\n        for i in num:\n            a = i + a*10\n        s = a + k\n        ar=[]\n        for i in str(s):\n            ar.append(int(i))\n        return ar","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430688419","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        a=[]\n        b=[]\n        for i,ch in enumerate(s):\n            if ch==c:\n                b.append(int(i))\n        return([min(abs(x-i) for i in b) for x in range(len(s))])","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432919837","body":"class CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.stack:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i]+=val","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434390170","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n       num_stack = [] \n       char_stack = []\n       res = ''\n       num_str = ''\n       for i in s:\n           if i.isdigit():\n               num_str+=i\n           elif i == '[':\n               char_stack.append(res)\n               num_stack.append(num_str)\n               res = ''\n               num_str = ''\n           elif i == ']':\n               res = char_stack.pop() + int(num_stack.pop()) * res \n           else:\n               res += i\n       return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435690424","body":"class MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack_in = []\r\n        self.stack_out = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_in.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n        \r\n        if self.stack_out:\r\n            return self.stack_out.pop()\r\n        else:\r\n            for i in range(len(self.stack_in)):\r\n                self.stack_out.append(self.stack_in.pop())\r\n            return self.stack_out.pop()\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack_out.append(ans)\r\n        return ans\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not (self.stack_in or self.stack_out)\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435995168","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        cnt = Counter()\n        res = 0\n        for x, y in zip(arr, sorted(arr)):\n            cnt[x] += 1\n            if cnt[x] == 0:\n                del cnt[x]\n            cnt[y] -= 1\n            if cnt[y] == 0:\n                del cnt[y]\n            if len(cnt) == 0:\n                res += 1\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436633696","body":"class Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n        \r\n        n = 1\r\n        cur = head\r\n        while cur.next:\r\n            cur = cur.next\r\n            n += 1\r\n        \r\n        if (add := n - k % n) == n:\r\n            return head\r\n        \r\n        cur.next = head\r\n        while add:\r\n            cur = cur.next\r\n            add -= 1\r\n        \r\n        ret = cur.next\r\n        cur.next = None\r\n        return ret","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439834914","body":"class Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        \n        return buildTree(head, None)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441397067","body":"class Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        unordered_set<ListNode *> visited;\n        ListNode *temp = headA;\n        while (temp != nullptr) {\n            visited.insert(temp);\n            temp = temp->next;\n        }\n        temp = headB;\n        while (temp != nullptr) {\n            if (visited.count(temp)) {\n                return temp;\n            }\n            temp = temp->next;\n        }\n        return nullptr;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445142640","body":"class LRUCache(collections.OrderedDict):\n\n    def __init__(self, capacity: int):\n        super().__init__()\n        self.capacity = capacity\n\n\n    def get(self, key: int) -> int:\n        if key not in self:\n            return -1\n        self.move_to_end(key)\n        return self[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.capacity:\n            self.popitem(last=False)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445387724","body":"class Solution:\n    def maxDepth(self, root):\n        if root is None: \n            return 0 \n        else: \n            left_height = self.maxDepth(root.left) \n            right_height = self.maxDepth(root.right) \n            return max(left_height, right_height) + 1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446092921","body":"class Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447913792","body":"class Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        def dfs(root: TreeNode, prevTotal: int) -> int:\n            if not root:\n                return 0\n            total = prevTotal * 10 + root.val\n            if not root.left and not root.right:\n                return total\n            else:\n                return dfs(root.left, total) + dfs(root.right, total)\n\n        return dfs(root, 0)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449428655","body":"class Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        curVal = curHeight = 0\n        def dfs(node: Optional[TreeNode], height: int) -> None:\n            if node is None:\n                return\n            height += 1\n            dfs(node.left, height)\n            dfs(node.right, height)\n            nonlocal curVal, curHeight\n            if height > curHeight:\n                curHeight = height\n                curVal = node.val\n        dfs(root, 0)\n        return curVal","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461750640","body":"class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        x = sum(nums) % p\n        if x == 0:\n            return 0\n        y = 0\n        index = {0: -1}\n        ans = len(nums)\n        for i, v in enumerate(nums):\n            y = (y + v) % p\n            if (y - x) % p in index:\n                ans = min(ans, i - index[(y - x) % p])\n            index[y] = i\n        return ans if ans < len(nums) else -1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463459713","body":"class Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        A = [head]\n        while A[-1].next:\n            A.append(A[-1].next)\n        return A[len(A) // 2]","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465201777","body":"class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            middle = (left + right) // 2\n\n            if nums[middle] < target:\n                left = middle + 1\n            elif nums[middle] > target:\n                right = middle - 1\n            else:\n                return middle\n        return right + 1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465942248","body":"class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        q = [(-nums[i], i) for i in range(k)]\n        heapq.heapify(q)\n\n        ans = [-q[0][0]]\n        for i in range(k, n):\n            heapq.heappush(q, (-nums[i], i))\n            while q[0][1] <= i - k:\n                heapq.heappop(q)\n            ans.append(-q[0][0])\n        \n        return ans","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pangjiadai":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429328694","body":"## Python3\n```python\nimport math \nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num_value = 0\n        num_length = len(num)\n\n        for i in num:\n            if i != 0:\n                num_value += i * pow(10, num_length-1)\n            num_length -= 1\n\n        total = num_value + k\n        return [int(x) for x in str(total)]\n```\n\n## Complexity:\n- time: O(n)\n- space: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432506382","body":"```Python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        # stack: FILO, append, pop\n        self.stack = []\n        self.size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        pointer = 0\n        for i in range(min(k, len(self.stack))):\n            self.stack[pointer] += val \n            pointer += 1\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439490333","body":"```python3\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head: return None\n        if not head.next: return TreeNode(head.val)\n\n        fast = slow = head\n        prev = None\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        root = TreeNode(slow.val)\n        prev.next = None\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xb798298436":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429336757","body":"addToArrayForm(array,k){\n    let str = \"\";\n    for(let i in array){\n      str += array[i];\n    }\n    let res = (parseInt(str)+k).toString().split('');\n    return res;\n  }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430913022","body":"getDistance(s, c) {\n    let n = s.length;\n    let res = [];\n    let pos = -n;\n    for (let i = 0; i < n; i++) {\n      if (s[i] === c) {\n        pos = i;\n      }\n      res[i] = i - pos;\n    }\n\n    for (let i = n - 1; i >= 0; i--) {\n      if (s[i] === c) {\n        pos = i;\n      }\n      res[i] = Math.min(res[i], pos - i);\n    }\n\n    return res;\n  }","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436422001","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        int len = 1;\n        ListNode p = head;\n        while(p.next != null){\n            p = p.next;\n            len++;\n        }\n        p.next = head;\n        k = k % len;\n        k = len - k;\n        for(int i = 0; i < k; i++) {\n            p = p.next;\n        }\n        ListNode res = p.next;\n        p.next =null;\n        return res;\n    }\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445116867","body":"var LRUCache = function(capacity) {\n    this.size = capacity;\n    this.map = new Map();\n};\n\nLRUCache.prototype.get = function(key) {\n    let val = -1;\n    if (this.map.has(key)) {\n        val = this.map.get(key);\n        this.map.delete(key);\n        this.map.set(key, val);\n    }\n    return val;\n};\n\nLRUCache.prototype.put = function(key, value) {\n    if (this.map.has(key)) {\n        this.map.delete(key);\n    }\n    this.map.set(key, value);\n    if (this.map.size > this.size) {\n        this.map.delete(this.map.keys().next().value);\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445328157","body":"class Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftMax = maxDepth(root.left);\n        int rightMax = maxDepth(root.right);\n        return 1 + Math.max(leftMax, rightMax);\n    }\n}\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454676499","body":"var twoSum = function(nums, target) {\n    let map = new Map();\n    for(let i = 0 ; i < nums.length ; i++){\n        if(map.has(target - nums[i])) {\n            return [map.get(target - nums[i]), i];\n        } else{\n            map.set(nums[i], i);\n        }\n    }\n    return [];\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461490442","body":"minSubarray(nums, k) {\n    var map = new Map();\n    map.set(0, -1);\n    var res = nums.length;\n    var target = 0;\n    var currSum = 0;\n    for (let i = 0; i < nums.length; i++) {\n      target += nums[i];\n    }\n    target = target % k;\n    for (let i = 0; i < nums.length; i++) {\n      currSum = (nums[i] + currSum) % k;\n      map.set(currSum, i);\n      var prevSum = (((currSum - target) % k) + k) % k;\n      if (map.has(prevSum)) {\n        res = Math.min(res, i - map.get(prevSum));\n      }\n    }\n    return res === nums.length ? -1 : res;\n  },","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465394895","body":"solution(nums, k) {\n    const res = [];\n    let array = nums.splice(0,k);\n    let curMax = -Infinity;\n    for (let i = 0; i < k; i++) {\n      curMax = Math.max(array[i], curMax);\n    }\n    res.push(curMax);\n    for (let i = 0; i < nums.length; i++) {\n      if(nums[i]>curMax){\n        curMax = nums[i];\n        res.push(curMax)\n      }else{\n        res.push(curMax)\n      }\n    }\n    return res;\n  },","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473321328","body":"var judgeCircle = function (moves) {\n  let p = [0, 0];\n  for (let i = 0; i < moves.length; i++) {\n    if (moves[i] === \"U\") p[0] += 1;\n    if (moves[i] === \"D\") p[0] -= 1;\n    if (moves[i] === \"L\") p[1] -= 1;\n    if (moves[i] === \"R\") p[1] += 1;\n  }\n  return p[0] === 0 && p[1] === 0;\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1478788596","body":"class Solution {\n    public int mySqrt(int x) {\n        if(x==1)\n            return 1;\n        int left=0;\n        int right=46340;\n        while(left<=right){\n            int mid=left+(right-left)/2;\n            if(mid*mid>x){\n                right=mid-1;\n            }else if(mid*mid<x){\n                left=mid+1;\n            }else{\n                return mid;\n            }\n        }\n        return right;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480430204","body":"var solution = function (isBadVersion) {\n  /**\n   * @param {integer} n Total versions\n   * @return {integer} The first bad version\n   */\n  return function (n) {\n    let left = 1;\n    let right = n;\n\n    while (left <= right) {\n      let mid = Math.floor((right + left) / 2);\n\n      if (isBadVersion(mid)) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    }\n\n    return left;\n  };\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486052537","body":"var maxVowels = function (s, k) {\n  const dict = new Set([\"a\", \"e\", \"i\", \"o\", \"u\"]);\n  let ret = 0;\n  for (let i = 0; i < k; i++) {\n    if (dict.has(s[i])) ret++;\n  }\n\n  let temp = ret;\n  for (let i = k, j = 0; i < s.length; i++, j++) {\n    if (dict.has(s[i])) temp++;\n    if (dict.has(s[j])) temp--;\n\n    ret = Math.max(temp, ret);\n  }\n\n  return ret;\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491444727","body":"public String minWindow(String s, String t) {\n\n    Map<Character, Integer> map = new HashMap<>();\n\n    int num = t.length();\n\n    for (int i = 0; i < num; i++)\n        map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) - 1);\n\n    int len = Integer.MAX_VALUE, match = 0, resLeft = 0, resRight = 0;\n\n    int left = 0, right = 0;\n\n    while (right < s.length()) {\n\n        char ch = s.charAt(right);\n\n        if (map.containsKey(ch)) {\n\n            int val = map.get(ch) + 1;\n            if (val <= 0)\n                match++;\n            map.put(ch, val);\n        }\n\n        while (match == num) {\n\n            if (right - left + 1 < len) {\n\n                len = right - left + 1;\n                resLeft = left;\n                resRight = right;\n            }\n\n            char c = s.charAt(left);\n            if (map.containsKey(c)) {\n\n                int val = map.get(c) - 1;\n                if (val < 0)\n                    match--;\n                map.put(c, val);\n            }\n\n            left++;\n        }\n\n        right++;\n    }\n\n    return len == Integer.MAX_VALUE ? \"\" : s.substring(resLeft, resRight + 1);\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498564039","body":" public int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {\n        int res = 0;\n        Queue<Integer> q = new LinkedList<>();\n        for (int i : initialBoxes)\n            if ((status[i] += 5000) > 5000)\n                q.add(i);\n        while (q.size() > 0) {\n            int b = q.remove();\n            res += candies[b];\n            for (int i : keys[b])\n                if ((status[i] += 5) == 5005)\n                    q.add(i);\n            for (int i : containedBoxes[b])\n                if ((status[i] += 5000) > 5000)\n                    q.add(i);\n        }\n        return res;\n    }","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501287652","body":"```\r\nclass Solution:\r\n    def findNumberOfLIS(self, nums: List[int]) -> int:\r\n        n = len(nums)\r\n        # dp[i][0] ->  LIS\r\n        # dp[i][1] -> NumberOfLIS\r\n        dp = [[1, 1] for i in range(n)]\r\n        ans = [1, 1]\r\n        longest = 1\r\n        for i in range(n):\r\n            for j in range(i + 1, n):\r\n                if nums[j] > nums[i]:\r\n                    if dp[i][0] + 1 > dp[j][0]:\r\n                        dp[j][0] = dp[i][0] + 1\r\n                        # 下面这行代码容易忘记，导致出错\r\n                        dp[j][1] = dp[i][1]\r\n                        longest = max(longest, dp[j][0])\r\n                    elif dp[i][0] + 1 == dp[j][0]:\r\n                        dp[j][1] += dp[i][1]\r\n        return sum(dp[i][1] for i in range(n) if dp[i][0] == longest)\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1507863556","body":"public class Solution {\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n\n        if (maxChoosableInteger >= desiredTotal) return true;\n        if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) return false;\n\n        Boolean[] dp = new Boolean[(1 << maxChoosableInteger) - 1];\n        return dfs(maxChoosableInteger, desiredTotal, 0, dp);\n    }\n\n    private boolean dfs(int maxChoosableInteger, int desiredTotal, int state, Boolean[] dp) {\n        if (dp[state] != null)\n            return dp[state];\n        for (int i = 1; i <= maxChoosableInteger; i++){\n            int tmp = (1 << (i - 1));\n            if ((tmp & state) == 0){\n                if (desiredTotal - i <= 0 || !dfs(maxChoosableInteger, desiredTotal - i, tmp|state, dp)) {\n                    dp[state] = true;\n                    return true;\n                }\n            }\n        }\n        dp[state] = false;\n        return false;\n    }\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514008424","body":"```\r\nconst findContentChildren = function (g, s) {\r\n  g = g.sort((a, b) => a - b);\r\n  s = s.sort((a, b) => a - b);\r\n  let gi = 0; // 胃口值\r\n  let sj = 0; // 饼干尺寸\r\n  let res = 0;\r\n  while (gi < g.length && sj < s.length) {\r\n    // 当饼干 sj >= 胃口 gi 时，饼干满足胃口，更新满足的孩子数并移动指针\r\n    if (s[sj] >= g[gi]) {\r\n      gi++;\r\n      sj++;\r\n      res++;\r\n    } else {\r\n      // 当饼干 sj < 胃口 gi 时，饼干不能满足胃口，需要换大的\r\n      sj++;\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ywang525":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429339866","body":"class Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        add = 0\r\n        res = [0]*len(num)\r\n        for i in range(len(num)-1, -1, -1):\r\n            if num[i] + k%10 + add < 10:\r\n                res[i] = num[i] + k%10 + add\r\n                add = 0  \r\n            else:\r\n                res[i] = num[i] + k%10 + add - 10\r\n                add = 1\r\n            k = k // 10\r\n        if add == 0 and k == 0:\r\n            return res\r\n        else:\r\n            n = add + k\r\n            while (n % 10 != 0) or (n // 10 != 0):\r\n                res = [n%10] + res\r\n                n = n//10\r\n            return res\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1432642389","body":"class Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        output = [0]*len(s)\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                res.append(i)\r\n        for i in range(len(s)):\r\n            minV = inf\r\n            for j in range(len(res)):\r\n                minV = min(minV, abs(res[j]-i))\r\n            output[i] = minV\r\n        return output","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"limbo42":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429352458","body":"```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> vec;\n        while(k) {\n            vec.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(vec.begin(), vec.end());\n        int add = 0;\n        vector<int> ans;\n        int i = vec.size()-1;\n        int j = num.size()-1;\n        while(i >= 0 && j >= 0) {\n            int sum = vec[i] + num[j] + add;\n            if(sum >= 10) {\n                sum -= 10;\n                add = 1;\n            } else {\n                add = 0;\n            }\n            ans.push_back(sum);\n            i--;\n            j--;\n        }\n        // cout << 1;\n        while(i >= 0) {\n            int sum = vec[i] + add;\n            if(sum >= 10) {\n                sum -= 10;\n                add = 1;\n            } else {\n                add = 0;\n            }\n            ans.push_back(sum);\n            i--;\n        }\n        // cout << 2;\n        while(j >= 0) {\n            int sum = num[j] + add;\n            if(sum >= 10) {\n                sum -= 10;\n                add = 1;\n            } else {\n                add = 0;\n            }\n            ans.push_back(sum);\n            j--;\n        }\n        // cout << 3;\n        if(add) {\n            ans.push_back(1);\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430607361","body":"```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> ans(s.length(), s.length());\n        int pre = 2 * s.length();\n        for(int i = 0; i < s.length(); ++i) {\n            // 先记录离左边最近的\n            if(s[i] == c) {\n                pre = i;\n            }\n            ans[i] = min(abs(i - pre), ans[i]);\n        }\n        pre = 2 * s.length();\n        for(int i = s.length()-1; i >=0; --i) {\n            // 先记录离左边最近的\n            if(s[i] == c) {\n                pre = i;\n            }\n            ans[i] = min(abs(i - pre), ans[i]);\n        }\n        return ans;\n    }\n}c++;\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432323315","body":"```C++\nclass CustomStack {\npublic:\n    // 差分数组\n    vector<int> vec;\n    vector<int> add;\n    int size_;\n    CustomStack(int maxSize) {\n        size_ = maxSize;\n    }\n    \n    void push(int x) {\n        if(vec.size() < size_) {\n            vec.push_back(x);\n            add.push_back(0);\n        }\n    }\n    \n    int pop() {\n        if(vec.size() == 0) return -1;\n        int num = vec.back();\n        vec.pop_back();\n        int diff = add.back();\n        num += diff;\n        add.pop_back();\n        if(add.size() >= 1)\n            add[add.size()-1] += diff;\n        return num;\n    }\n    \n    void increment(int k, int val) {\n        // 支持范围+val\n        if(vec.size() == 0) return;\n        if(vec.size() < k) {\n            add[vec.size()-1] += val;\n        } else {\n            add[k-1] += val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434009949","body":"```C++\nclass Solution {\npublic:\n    \n    string decodeString(string s) {\n        int num = 0;\n        string ans = \"\";\n        int pre = 0;\n        int i = 0;\n        while(i < s.length()) {\n            if(s[i] >= 'a' && s[i] <= 'z') {\n                ans += s[i++];\n            } else if(isdigit(s[i])) {\n                int num = 0;\n                int j = i;\n                for(; j < s.length(); ++j) {\n                    if(isdigit(s[j])) {\n                        num *= 10;\n                        num += s[j] - '0';\n                    } else {\n                        break;\n                    }\n                }\n                // cout << num << \" \";\n                int count = 0;\n                int k = j;\n                for(; k < s.length(); ++k) {\n                    if(s[k] == '[') count++;\n                    else if(s[k] == ']') count--;\n                    if(count == 0) break;\n                }\n                // k指向] , j 为[\n                string str = s.substr(j+1, k-j-1);\n                // cout << str << \" \";\n                for(int p = 0; p < num; ++p) {\n                    ans += decodeString(str);\n                }\n                i = k + 1;\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435433089","body":"```C++\nclass MyQueue {\nprivate:\n    stack<int> st1;\n    stack<int> st2;\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        st1.push(x);\n    }\n    \n    int pop() {\n        if(!st2.empty()) {\n            int res = st2.top();\n            st2.pop();\n            return res;\n        }\n        while(!st1.empty()) {\n            int num = st1.top();\n            st1.pop();\n            st2.push(num);\n        }\n        int res = st2.top();\n            st2.pop();\n            return res;\n    }\n    \n    int peek() {\n        if(!st2.empty()) {\n            int res = st2.top();\n            return res;\n        }\n        while(!st1.empty()) {\n            int num = st1.top();\n            st1.pop();\n            st2.push(num);\n        }\n        return st2.top();\n    }\n    \n    bool empty() {\n        return st1.empty() && st2.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435992621","body":"```C++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        // 右边的最小值，需要大于左边的最大值\n        vector<int> rightMIN(arr.size(), 0);\n        int min_num = arr[arr.size()-1];\n        for(int i = arr.size()-1; i >= 0; --i) {\n            min_num = min(min_num, arr[i]);\n            rightMIN[i] = min_num;\n        }\n        int count = 0;\n        int cur_max = arr[0];\n        for(int i = 0; i + 1 < arr.size(); ++i) {\n            if(cur_max <= rightMIN[i+1]) {\n                count++;\n                cur_max = arr[i+1];\n            } else {\n                cur_max = max(cur_max, arr[i]);\n            }\n        }\n        return count + 1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436154766","body":"```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head == nullptr) return head;\n        int size = 0;\n        ListNode* cur = head;\n        while(cur) {\n            cur = cur->next;\n            size++;\n        }\n        if(size == 0) return head;\n        int num = k % size;\n        if(num == 0) return head;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(num) {\n            num--;\n            fast = fast->next;\n        }\n        while(fast->next) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        ListNode* ans = slow->next;\n        slow->next = nullptr;\n        fast->next = head;\n        return ans;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438220031","body":"```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr) return head;\n        if(head->next == nullptr) return head;\n        ListNode* cur = head;\n        ListNode* pre = nullptr;\n        ListNode* ans = nullptr;\n        while(cur) {\n            ListNode* next = cur->next;\n            if(ans == nullptr) ans = next;\n            if(next == nullptr) break;\n            ListNode* node = next->next;\n            if(pre != nullptr) {\n                pre->next = next;\n            }\n            pre = cur;\n            cur->next = node;\n            next->next = cur;\n            cur = node;\n        }\n        return ans;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439305515","body":"```C++\nclass Solution {\npublic:\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        // 递归\n        // 找到中间节点作为根节点\n        if(head == nullptr) return nullptr;\n        if(head->next == nullptr) return new TreeNode(head->val);\n        // cout << head->val<< \" \" ;\n        ListNode* pre = nullptr;\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while(fast != nullptr && fast->next) {\n            pre = slow;\n            slow = slow->next;\n            if(fast->next == nullptr) break;\n            fast = fast->next->next;\n        }\n        if(pre != nullptr) {\n            pre->next = nullptr;\n        }\n\n        TreeNode* root = new TreeNode(slow->val);\n        root->left = sortedListToBST(head);\n        root->right = sortedListToBST(slow->next);\n        return root;\n\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445065934","body":"```\nclass LRUCache {\nstruct Node{\n    int key;\n    int val;\n    Node* prev;\n    Node *next;\n    Node() {\n        \n    }\n    Node(int k, int v) : key(k), val(v) {\n\n    }\n};\nunordered_map<int, Node*> m;\nNode* head = nullptr;\nNode* tail = nullptr;\nint capacity_;\n\nvoid addHead(Node* node) {\n    head->next->prev = node;\n    node->next = head->next;\n    node->prev = head;\n    head->next = node;\n}\nvoid deleteNode(Node* node) {\n    node->prev->next = node->next;\n    node->next->prev = node->prev;\n}\npublic:\n    LRUCache(int capacity) {\n        capacity_ = capacity;\n        head = new Node;\n        tail = new Node;\n        head->next = tail;\n        tail->next = head;\n        head->prev = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if(m.count(key)) {\n            int res = m[key]->val;\n            Node *node = m[key];\n            deleteNode(node);\n            addHead(node);\n            return res;\n        }\n        return -1;\n    }\n    \n    void put(int key, int value) {\n        if(m.count(key)) {\n            Node* node = m[key];\n            node->val = value;\n            deleteNode(node);\n            addHead(node);\n            return;\n        }\n        Node* node = new Node(key, value);\n        addHead(node);\n        m[key] = node;\n        if(m.size() > capacity_) {\n            Node* last = tail->prev;\n            m.erase(last->key);\n            deleteNode(last);\n        }\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445242434","body":"```\nclass Solution {\npublic:\n    int max_dep = 0;\n    void dfs(TreeNode* root, int depth) {\n        if(root == nullptr) {\n            max_dep = max(max_dep, depth);\n            return;\n        }\n        dfs(root->left, depth+1);\n        dfs(root->right, depth+1);\n    }\n    int maxDepth(TreeNode* root) {\n        dfs(root, 0);\n        return max_dep;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445534020","body":"```C++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p == nullptr && q != nullptr) return false;\n        if(p != nullptr && q == nullptr) return false;\n        if(p == nullptr && q == nullptr) return true;\n        if(p->val != q->val) return false;\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451196517","body":"```C++\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        string str = \"\";\n        queue<TreeNode*> que;\n        que.push(root);\n        while(!que.empty()) {\n            int size = que.size();\n            for(int i = 0; i < size; ++i) {\n                TreeNode* node = que.front();\n                que.pop();\n                if(node == NULL) {\n                    str += \"X,\";\n                    continue;\n                } else {\n                    str += to_string(node->val) + \",\";\n                    que.push(node->left);\n                    que.push(node->right);\n                }\n            }\n        }\n        // cout << str;\n        return str;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        istringstream iss(data);\n        vector<string> chs;\n        string tmp;\n        while(getline(iss, tmp, ',')) {\n            chs.push_back(tmp);\n        }\n        queue<TreeNode*> que;\n        TreeNode* root;\n        if(chs[0] == \"X\") {\n            return NULL;\n        } else {\n            root = new TreeNode(atoi(chs[0].c_str()));\n        }\n        que.push(root);\n        int l = 1; int r = 2;\n        while(r < chs.size()) {\n            TreeNode* node = que.front();\n            que.pop();\n            TreeNode* left = NULL;\n            TreeNode* right = NULL;\n            if(chs[l] != \"X\") {\n                left = new TreeNode(atoi(chs[l].c_str()));\n                que.push(left);\n            }\n            if(chs[r] != \"X\") {\n                right = new TreeNode(atoi(chs[r].c_str()));\n                que.push(right);\n            }\n            l += 2;\n            r += 2;\n            node->left = left;\n            node->right = right;\n        }\n        return root;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1452793047","body":"```C++\nclass Solution {\npublic:\n    map<int, vector<pair<int, int>>> m;\n    void dfs(TreeNode* root, int num, int height) {\n        if(root == nullptr) return;\n        m[num].push_back(make_pair(height, root->val));\n        dfs(root->left, num-1, height+1);\n        dfs(root->right, num+1, height+1);\n    }\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        dfs(root, 0, 0);\n        vector<vector<int>> ans;\n        for(auto it : m) {\n            auto &vec = it.second;\n            sort(vec.begin(), vec.end(), [&](const pair<int, int> &a, const pair<int, int> &b) {\n                if(a.first == b.first) {\n                    return a.second < b.second;\n                }\n                return a.first < b.first;\n            });\n            vector<int> tmp(vec.size());\n            for(int i = 0; i < vec.size(); ++i) {\n                tmp[i] = vec[i].second;\n            }\n            ans.push_back(tmp);\n        }\n        return ans;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454312545","body":"```\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<pair<int, int>> vec(nums.size());\n        for(int i = 0; i < nums.size(); ++i) {\n            vec[i] = make_pair(nums[i], i);\n        }\n        sort(vec.begin(), vec.end());\n        \n        int i = 0; int j = nums.size()-1;\n        while(i < j) {\n            int sum = vec[i].first + vec[j].first;\n            if(sum > target) {\n                j--;\n            } else if(sum < target) {\n                i++;\n            } else {\n                return {vec[i].second, vec[j].second};\n            }\n        }\n        return {};\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1454945786","body":"```C++\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> m;\n        for(int num : nums) {\n            m[num]++;\n        }\n        // 小根堆，出现频率最小的在前\n        auto cmp = [&](const pair<int, int> &a, const pair<int, int> &b) {\n            return a.second > b.second;\n        };\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> que(cmp);\n        for(auto it : m) {\n            if(que.size() < k) {\n                que.push(it);\n            } else {\n                auto top = que.top();\n                if(it.second > top.second) {\n                    que.pop();\n                    que.push(it);\n                }\n            }\n        }\n        vector<int> ans;\n        while(!que.empty()) {\n            auto it = que.top();\n            que.pop();\n            ans.push_back(it.first);\n        }\n        return ans;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457293887","body":"```\nclass Solution {\npublic:\n    bool check(unordered_map<char, int> &m) {\n        // 不包含重复字符返回 true\n        for(auto it : m) {\n            if(it.second > 1) return false;\n        }\n        return true;\n    }\n    int lengthOfLongestSubstring(string s) {\n        unordered_map<char, int> m;\n        int i = 0; int j = 0;\n        int max_len = 0;\n        for(; j < s.length(); ++j) {\n            m[s[j]]++;\n            // 出现重复\n            while(i < j && !check(m)) {\n                m[s[i++]]--;\n            }\n            max_len = max(max_len, j - i + 1);\n        }\n\n        return max_len;\n    }\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464739249","body":"```C++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int i = 0;\n        int j = 0;\n        while(j < nums.size()) {\n            if(j == 0 || nums[j] != nums[j-1]) {\n                nums[i++] = nums[j++];\n            } else {\n                j++;\n            }\n        }\n        return i;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477147243","body":"```C++\nclass Solution {\npublic:\n    /* 快排\n    void randomnum(vector<int> &nums, int l, int r) {\n        int x = rand() % (r - l + 1) + l;\n        swap(nums[r], nums[x]);\n    }\n    int partition(vector<int> &nums, int l, int r) {\n        randomnum(nums, l, r);\n        int &num = nums[r];\n        while(l < r) {\n            while(l < r && nums[l] <= num) l++;\n            while(l < r && nums[r] >= num) r--;\n            swap(nums[l], nums[r]);\n        }\n        swap(nums[l], num);\n        return l;\n    }\n    void quicksort(vector<int> &nums, int l, int r) {\n        if(l >= r) return;\n        int pivot = partition(nums, l, r);\n        quicksort(nums, l, pivot - 1);\n        quicksort(nums, pivot + 1, r);\n    }*/\n\n    // 归并排序\n    void mergesort(vector<int> &nums, int l, int r) {\n        if(l >= r) return;\n        int mid = (r - l) / 2 + l;\n        mergesort(nums, l, mid);\n        mergesort(nums, mid + 1, r);\n        // 合并\n        vector<int> tmp(r - l + 1);\n        int i = l; int j = mid + 1;\n        int count = 0;\n        while(i <= mid && j <= r) {\n            if(nums[i] <= nums[j]) {\n                tmp[count++] = nums[i];\n                i++;\n            } else {\n                tmp[count++] = nums[j];\n                j++;\n            }\n        }\n        while(i <= mid) {\n            tmp[count++] = nums[i++];\n        }\n        while(j <= r) {\n            tmp[count++] = nums[j++];\n        }\n        for(int k = 0; k < r - l + 1; ++k) {\n            nums[l + k] = tmp[k];\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        // 写个快排\n        // srand(time(0));\n        // quicksort(nums, 0, nums.size() - 1);\n        mergesort(nums, 0, nums.size() - 1);\n        return nums;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480424958","body":"```C++\n// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int left = 1;\n        int right = n;\n        while(left <= right) {\n            int mid = (right - left) / 2 + left;\n            if(isBadVersion(mid)) {\n                right = mid - 1;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483701870","body":"```\nclass Solution {\npublic:\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\n        sort(houses.begin(), houses.end());\n        sort(heaters.begin(), heaters.end());\n        int l = 0; int r = max(houses[houses.size()-1], heaters[heaters.size()-1]) + 1;\n\n        auto judge = [&](int r) -> bool {\n            // 区域合并\n            // cout << r << \" \";\n            int j = 0;\n            for(int i = 0; i < houses.size(); ++i) {\n                while(j < heaters.size() && heaters[j] + r < houses[i]) {\n                    j++;\n                }\n                if(j == heaters.size()) return false;\n                if(abs(heaters[j] - houses[i]) <= r) continue;\n                return false;\n            }\n            return true;\n        };\n\n        while(l < r) {\n            int mid = (r - l) / 2 + l;\n            if(judge(mid)) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489520909","body":"```C++\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        vector<int> ans;\n        unordered_map<char, int> m;\n        for(char ch : p) {\n            m[ch]++;\n        }\n        int i = 0; int j = 0;\n        unordered_map<char, int> c;\n        for(; j < p.length(); ++j) {\n            c[s[j]]++;\n        }\n        if(m == c) {\n            ans.push_back(0);\n        }\n        for(; j < s.length(); ++j) {\n            c[s[i]]--;\n            if(c[s[i]] == 0) c.erase(s[i]);\n            i++;\n            c[s[j]]++;\n            if(m == c) {\n                ans.push_back(i);\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491134431","body":"```C++\nclass Solution {\npublic:\n    bool judge(unordered_map<char, int> &a, unordered_map<char, int> &target) {\n        for(auto &it : target) {\n            // cout<<it.first<<\" \";\n            // if(a.count(it.first) < target.count(it.first)) {\n            //     return false;\n            // }\n            if(a.count(it.first) == 0 || a[it.first] < target[it.first]) {\n                return false;\n            }\n        }\n        // print(a);\n        return true;\n    }\n    void print(unordered_map<char, int> &a) {\n        for(auto &it : a) {\n            cout<<it.first<<\":\"<<it.second<<\" \";\n        }\n        cout<<endl;\n    }\n    string minWindow(string s, string t) {\n        int l, r = 0;\n        unordered_map<char, int> map;\n        for(auto &ch : t) {\n            map[ch]++;\n        }\n        for(; l < s.length(); ++l) {\n            if(map.count(s[l])) {\n                break;\n            }\n        }\n        r = l;\n        // cout<<\"1\";\n        unordered_map<char, int> cur;\n        string res = \"\";\n        while(l < s.length() && r <= s.length()) {\n            bool flag = judge(cur, map);\n            if(flag == false) {\n                cur[s[r]]++;\n                r++;\n                // if(r >= s.length()) break;\n            }else {\n                // r--;\n                string tmp = s.substr(l, r-l);\n                // cout<<tmp<<\" \";\n                if(res == \"\" || tmp.length() < res.length()) {\n                    res = tmp;\n                }\n                // print(cur);\n                cur[s[l]]--;\n                l++;\n                for(; l < s.length(); ++l) {\n                    cur[s[l]]--;\n                    if(map.count(s[l])) {\n                        cur[s[l]]++;\n                        break;\n                    }\n                }\n                // print(cur);\n                // cout<<l<<\" \";\n                // print(cur);\n            }\n        }\n        // if(judge(cur, map)) {\n        //     string tmp = s.substr(l, r-l);\n        //     // cout<<tmp<<\" \";\n        //     if(res == \"\" || tmp.length() < res.length()) {\n        //         res = tmp;\n        //     }\n        // }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1492775469","body":"滑动窗口题，只需要使得中间连续出现和为sum-k的窗口即可","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1493496108","body":"```C++\ngrid[i] 代表第 i 行的棋子放在 grid[i] 列；\n如何判断能放在哪一列：枚举 row - k 到 row + k，看相减的结果\n```C++\nclass Solution {\npublic:\n    int ans = 0;\n    void dfs(vector<int> &grid, int row, vector<bool> &used) {\n        if(row == grid.size()) {\n            ans++;\n            return;\n        }\n        int n = grid.size();\n        // 代表i行的棋子在grid[i]列\n        for(int j = 0; j < n; ++j) {\n\n            if(used[j]) continue;\n            bool flag = true;\n            for(int k = 1; k < n; k++) {\n                if(row - k >= 0) {\n                    int num = abs(j - grid[row-k]);\n                    if(grid[row-k] == -1) num = grid[row];\n                    if(num == k) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if(row + k < n) {\n                    int num = abs(j - grid[row+k]);\n                    if(grid[row+k] == -1) num = grid[row];\n                    if(num == k) {\n                        flag = false;\n                        break;\n                    }\n                }\n            }\n            if(flag == false) {\n                continue;\n            }\n\n            used[j] = true;\n            grid[row] = j;\n            dfs(grid, row + 1, used);\n            used[j] = false;\n            grid[row] = -1;\n        }\n    }\n    int totalNQueens(int n) {\n        vector<int> grid(n, -1);\n        vector<bool> used(n, false);\n        dfs(grid, 0, used);\n        return ans;\n\n    }\n};\n```\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498347864","body":"```C++\nclass Solution {\npublic:\n    int maxCandies(vector<int>& status, vector<int>& candies, vector<vector<int>>& keys, vector<vector<int>>& containedBoxes, vector<int>& initialBoxes) {\n        // BFS\n        queue<int> que;\n        int n = status.size();\n        vector<bool> used(n, false);\n\n        vector<bool> canopen(n, false);\n        for(int i = 0; i < n; ++i) {\n            if(status[i] == 1) {\n                canopen[i] = true;\n            }\n        }\n\n        vector<int> boxs(n, false);\n\n        for(int initial : initialBoxes) {\n            if(canopen[initial]) {\n                used[initial] = true;\n                que.push(initial);\n            } else {\n                boxs[initial] = true;\n            }\n            // que.push(initial);\n        }\n\n        int ans = 0;\n        while(!que.empty()) {\n            int index = que.front();\n            que.pop();\n            for(int i : keys[index]) {\n                canopen[i] = true;\n            }\n            ans += candies[index];\n            for(int i : containedBoxes[index]) {\n                if(canopen[i] && !used[i]) {\n                    used[i] = true;\n                    que.push(i);\n                }\n                if(!canopen[i] && !used[i]) {\n                    // boxs.push_back(i);\n                    boxs[i] = true;\n                }\n            }\n            for(int i = 0; i < n; ++i) {\n                if(boxs[i] == true && canopen[i]) {\n                    used[i] = true;\n                    que.push(i);\n                    boxs[i] = false;\n                }\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1499794928","body":"```C++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        map<int, vector<pair<int, int>>> m;\n        queue<pair<TreeNode*, int>> que;\n        que.push(make_pair(root, 0));\n        int row = 0;\n        while(!que.empty()) {\n            int size = que.size();\n            for(int i = 0; i < size; ++i) {\n                auto it = que.front();\n                que.pop();\n                TreeNode* node = it.first;\n                int index = it.second;\n                m[index].push_back(make_pair(node->val, row));\n                if(node->left) {\n                    que.push(make_pair(node->left, index-1));\n                }\n                if(node->right) {\n                    que.push(make_pair(node->right, index+1));\n                }\n            }\n            row++;\n        }\n        vector<vector<int>> ans;\n        for(auto &it : m) {\n            auto vec = it.second;\n            sort(vec.begin(), vec.end(), [&](const pair<int, int> &a, const pair<int, int> &b){\n                if(a.second == b.second) {\n                    return a.first < b.first;\n                }\n                return a.second < b.second;\n            });\n            // ans.push_back(vec);\n            vector<int> p(vec.size());\n            for(int i = 0; i < vec.size(); ++i) {\n                p[i] = vec[i].first;\n            }\n            ans.push_back(p);\n        }\n        return ans;\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501273569","body":"```C++\nclass Solution {\npublic:\n    int findNumberOfLIS(vector<int>& nums) {\n        // 以nums[i]为结尾的子序列的长度\n        vector<int> dp(nums.size(), 1);\n        vector<int> ans(nums.size(), 1);\n        int max_num = 1;\n        for(int i = 0; i < nums.size(); ++i) {\n            for(int j = 0; j < i; ++j) {\n                if(nums[i] > nums[j]) {\n                    if(dp[i] == dp[j] + 1) {\n                        ans[i] += ans[j];\n                    } else if(dp[i] < dp[j] + 1){\n                        dp[i] = dp[j] + 1;\n                        ans[i] = ans[j];\n                    }\n                }\n            }\n            \n            max_num = max(max_num, dp[i]);\n        }\n\n        int count = 0;\n        for(int i = 0; i < nums.size(); ++i) {\n            if(max_num == dp[i]) {\n                count += ans[i];\n            }\n        }\n        return count;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1502542725","body":"```C++\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        // dp[i][j] = dp[i-1][j-1]+1, dp[i-1][j], dp[i][j-1]\n        vector<vector<int>> dp(text1.length()+1, vector<int>(text2.length()+1, 0));\n        for(int i = 1; i <= text1.length(); ++i) {\n            for(int j = 1; j <= text2.length(); ++j) {\n                if(text1[i-1] == text2[j-1]) {\n                    dp[i][j] = max(dp[i-1][j-1]+1, dp[i][j]);\n                } else {\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n                }\n            }\n        }\n        return dp[text1.length()][text2.length()];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1505096792","body":"```C++\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        // dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n        for(int i = 1; i <= m; ++i) {\n            dp[i][1] = 1;\n        }\n        for(int i = 1; i <= n; ++i) {\n            dp[1][i] = 1;\n        }\n        for(int i = 2; i <= m; ++i) {\n            for(int j = 2; j <= n; ++j) {\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\n            }\n        }\n        return dp[m][n];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506152108","body":"```C++\nclass Solution {\npublic:\n    double knightProbability(int n, int k, int row, int column) {\n        vector<vector<vector<double>>> dp(k+1, vector<vector<double>>(n, vector<double>(n, 0)));\n        dp[0][row][column] = 1;\n        vector<pair<int, int>> dir = {{-2, 1}, {2, 1}, {-2, -1}, {2, -1}, {1, 2}, {1, -2}, {-1, 2}, {-1, -2}};\n        for(int p = 1; p <= k; ++p) {\n            for(int i = 0; i < n; ++i) {\n                for(int j = 0; j < n; ++j) {\n                    for(int x = 0; x < 8; ++x) {\n                        int r = i + dir[x].first;\n                        int c = j + dir[x].second;\n                        if(r >= 0 && r < n && c >= 0 && c < n) {\n                            dp[p][i][j] += dp[p-1][r][c] / 8.0;\n                        }\n                    }\n                }\n            }\n        }\n        double ans = 0;\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                ans += dp[k][i][j];\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509446171","body":"```C++\r\nclass Solution {\r\npublic:\r\n    bool canPartition(vector<int>& nums) {\r\n        // 背包问题，问能不能是一般\r\n        int sum = accumulate(nums.begin(), nums.end(), 0);\r\n        if(sum % 2 == 1) return false;\r\n        sum /= 2;\r\n        // 问能不能求\r\n        vector<vector<bool>> dp(nums.size() + 1, vector<bool>(sum + 1, false));\r\n        // dp[i][j] = dp[i-1][j] | dp[i-1][j-nums[i-1]]\r\n        dp[0][0] = true;\r\n        for(int i = 1; i <= nums.size(); ++i) {\r\n            for(int j = 1; j <= sum; ++j) {\r\n                if(j >= nums[i-1]) {\r\n                    dp[i][j] = dp[i-1][j] | dp[i-1][j-nums[i-1]];\r\n                } else {\r\n                    dp[i][j] = dp[i-1][j];\r\n               }\r\n            }\r\n        }\r\n        return dp[nums.size()][sum];\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1510538953","body":"```C++\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        int n = coins.size();\n        vector<vector<int>> dp(n + 1, vector<int>(amount + 1, INT_MAX-1));\n        for(int i = 0; i <= n; ++i) {\n            dp[i][0] = 0;\n        }\n        for(int i = 1; i <= n; ++i) {\n            for(int j = 1; j <= amount; ++j) {\n                if(j >= coins[i-1]) {\n                    dp[i][j] = min({dp[i][j-coins[i-1]] + 1, dp[i-1][j]});\n                } else {\n                    dp[i][j] = min(dp[i][j], dp[i-1][j]);\n                }\n            }\n        }\n        return dp[n][amount] == INT_MAX - 1 ? -1 : dp[n][amount];\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1515600660","body":"```C++\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        // 最大的互不重叠的情况\n        sort(intervals.begin(), intervals.end(), [&](const vector<int>& a, vector<int> &b){\n            return a[1] < b[1];\n        });\n        int end = INT_MIN;\n        int count = 0;\n        for(int i = 0; i < intervals.size(); ++i) {\n            if(intervals[i][0] >= end) {\n                count++;\n                end = intervals[i][1];\n            }\n        }\n        return intervals.size() - count;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517105084","body":"```\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        // if(nums.size() == 1) return true;\n        // // vector<bool>(nums.size(), false) dp;\n        // vector<bool> dp(nums.size(), false);\n        // dp[nums.size()-1] = true;\n        // for(int i = nums.size()-2; i >= 0; --i) {\n        //     for(int j = 1; j <= nums[i] && i + j < nums.size(); ++j) {\n        //         if(dp[i+j]) {\n        //             dp[i] = true;\n        //             break;\n        //         }\n        //     }\n        // }\n        // return dp[0];\n        int energy = nums[0];\n        for(int i = 1; i < nums.size(); ++i) {\n            // 当走到energy更大的时候，直接选那个节点\n            energy--;\n            if(energy < 0) return false;\n            energy = max(energy, nums[i]);\n        }\n        return true;\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1519234296","body":"```C++\nclass Solution {\n    public int[] beautifulArray(int N) {\n        int[] a = new int[N];\n        Arrays.fill(a, 1);\n        part(a, 0, N - 1);\n        return a;\n    }\n    public void part(int[] a, int lo, int hi) {\n        if (hi <= lo) return;\n        int mid = lo + (hi - lo) / 2;\n        part(a, lo, mid);\n        part(a, mid + 1, hi);\n        for (int i = lo; i <= mid; i++) {\n            a[i] = 2 * a[i] - 1;\n        } \n        for (int i = mid + 1; i <= hi; i++) {\n            a[i] = 2 * a[i];\n        }\n        return;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521011919","body":"```C++\nclass Solution {\npublic:\n    vector<int> singleNumber(vector<int>& nums) {\n        // 按照异或处理 x = a^b\n        int x = 0;\n        for(int num : nums) {\n            x = x ^ num;\n        }\n        // 找到 x 第一个不为 0 的位置\n        int tmp = x;\n        int count = 0;\n        while((tmp & 1) == 0) {\n            tmp = tmp >> 1;\n            count++;\n        }\n        int a = 0; int b = 0;\n        for(int num : nums) {\n            if(((num >> count) & 1) == 1) {\n                a = a ^ num;\n            } else {\n                b = b ^ num;\n            }\n        }\n        return {a, b};\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1522598183","body":"```C++\nclass Solution {\npublic:\n    vector<vector<int>> ans;\n    void dfs(int index, vector<int> &vec, vector<int> &nums) {\n        if(index >= nums.size()) {\n            ans.push_back(vec);\n            return;\n        }\n        // for(int i = index)\n        dfs(index+1, vec, nums);\n        vec.push_back(nums[index]);\n        dfs(index+1, vec, nums);\n        vec.pop_back();\n    }\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<int> vec;\n        dfs(0, vec, nums);\n        return ans;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1526905971","body":"```C++\nclass MapSum {\npublic:\n    /** Initialize your data structure here. */\n    struct trieNode{\n        char ch;\n        unordered_map<char, trieNode*> next;\n        bool end = false;\n        int val = 0;\n        trieNode() {\n\n        }\n        trieNode(char c) {\n            ch = c;\n        }\n    };\n    trieNode* root = new trieNode;\n    unordered_map<string, int> key2val;\n    MapSum() {\n\n    }\n    \n    void insert(string key, int val) {\n        int diff = 0;\n        // if(key2val.count(key)) {\n        //     diff = key2val[key];\n        // }\n        key2val[key] = val;\n        int add = val - diff;\n        trieNode* node = root;\n        for(char ch : key) {\n            if(!node->next.count(ch)) {\n                trieNode* tmp = new trieNode(ch);\n                node->next[ch] = tmp;\n            }\n            node = node->next[ch];\n            // node->val += add;\n        }\n        node->end = true;\n        // node->val += add;\n        node->val = val;\n    }\n    void dfs(trieNode* root, int &sum) {\n        if(root == nullptr) return;\n        sum += root->val;\n        for(auto it : root->next) {\n            dfs(it.second, sum);\n        }\n    }\n    int sum(string prefix) {\n        int ans = 0;\n        trieNode* node = root;\n        for(char ch : prefix) {\n            if(!node->next.count(ch)) return ans;\n            node = node->next[ch];\n        }\n        // return node->val;\n        // int ans = 0;\n        dfs(node, ans);\n        return ans;\n    }\n};\n\n/**\n * Your MapSum object will be instantiated and called as such:\n * MapSum* obj = new MapSum();\n * obj->insert(key,val);\n * int param_2 = obj->sum(prefix);\n */\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1532318056","body":"```C++\r\nbool dfs(TreeNode* root) {\r\n        if(root == nullptr) return false;\r\n        bool flag1 = dfs(root->left);\r\n        bool flag2 = dfs(root->right);\r\n        // false 代表不包含1\r\n        // true 代表包含1\r\n        if(flag1 == false) {\r\n            root->left = nullptr;\r\n        }\r\n        if(flag2 == false) {\r\n            root->right = nullptr;\r\n        }\r\n        if(!flag1 && !flag2 && root->val != 1) return false;\r\n        return true;\r\n    }\r\n    TreeNode* pruneTree(TreeNode* root) {\r\n        // 左右根\r\n        bool flag = dfs(root);\r\n        if(flag == false) return nullptr;\r\n        return root;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1533925252","body":"```python3\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n        n = len(candidates)\n        res = []\n        def dfs(start, num, vec):            \n            if num == 0:\n                res.append(vec)\n                return\n            if start >= n or num < 0:\n                return\n            for i in range(start, n):\n                num = num - candidates[i]\n                dfs(i, num, vec + [candidates[i]])\n                num = num + candidates[i]\n                \n        dfs(0, target, [])\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1535577760","body":"```python3\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n        vec = []\n        n = len(candidates)\n        used = [False] * n\n        ans = []\n        def dfs(vec, start, num, used):\n            if num == 0:\n                ans.append(vec[:])\n                return\n            if start >= n or num < 0:\n                return\n            for i in range(start, n):\n                if i >= 1 and candidates[i] == candidates[i-1] and used[i-1] == False:\n                    continue\n                if used[i] == False:\n                    used[i] = True\n                    vec.append(candidates[i])\n                    dfs(vec, i+1, num-candidates[i], used)\n                    used[i] = False\n                    vec.pop()\n        dfs(vec, 0, target, used)\n        return ans\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1536949022","body":"```python3\nclass Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        ans = []\n        vec = []\n        nums.sort()\n        n = len(nums)\n        used = [False] * n\n        def dfs(vec, used):\n            if len(vec) == n:\n                ans.append(vec[:])\n                return\n            for i in range(0, n):\n                if i >= 1 and nums[i] == nums[i-1] and used[i-1] == False:\n                    continue\n                if used[i] == False:\n                    used[i] = True\n                    vec.append(nums[i])\n                    dfs(vec, used)\n                    used[i] = False\n                    vec.pop()\n        dfs(vec, used)\n        return ans\n```","onTime":true},null,null,null,null,null,null,null,null,null],"dorapocket":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429417644","body":"```c++\r\nclass Solution {\r\n\r\npublic:\r\n    vector<int> num2arr(int num){\r\n        vector<int> v;\r\n        while(num!=0){\r\n            int last = num%10;\r\n            num = num/10;\r\n            v.push_back(last);\r\n        }\r\n        return v;\r\n    }\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> kv = num2arr(k);\r\n        vector<int> res;\r\n        reverse(num.begin(),num.end());\r\n        int i=0;\r\n        int over = 0;\r\n        while(i<num.size()&&i<kv.size()){\r\n            int n = num[i]+kv[i]+over;\r\n            over = n/10;\r\n            res.push_back(n%10);\r\n            i++;\r\n        }\r\n        while(i<num.size()||i<kv.size()){\r\n            int n = ((i<num.size())?num[i]:kv[i])+over;\r\n            over = n/10;\r\n            res.push_back(n%10);\r\n            i++;\r\n        }\r\n        if(over) res.push_back(over);\r\n        reverse(res.begin(),res.end());\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431470683","body":"```c++\nclass Solution {\npublic:\n    int getMinDis(string s,int idx,char c){\n        int i=idx;\n        int tmp = s.size()+1;\n        while(i>=0){\n            if(s[i]==c) {tmp = min(tmp,idx-i);break;}\n            i--;\n        }\n        i=idx;\n        while(i<s.size()&&i-idx<tmp){\n            if(s[i]==c) {tmp = min(tmp,i-idx);break;}\n            i++;\n        }\n        return tmp;\n    }\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> v;\n        for(auto i=0;i<s.size();i++){\n            v.emplace_back(getMinDis(s,i,c));\n        }\n        return v;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432999782","body":"```c++\r\nclass CustomStack {\r\npublic:\r\n    int maxSize=0;\r\n    vector<int> v;\r\n    CustomStack(int m) {\r\n        maxSize=m;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(v.size()<maxSize) v.emplace_back(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if(v.size()>0){\r\n            int i = v.back();\r\n            v.pop_back();\r\n            return i;\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for(int i=0;i<k&&i<v.size();i++){\r\n            v[i]+=val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434734823","body":"```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res;\n        for (int i = 0; i < s.size(); ++i) {\n            if (s[i] == '[') {\n                int k, l=i-1, r=i, n=1;\n                while (l >= 0 && isdigit(s[l])) --l;\n                ++l;\n                k = stoi(s.substr(l, i - l));\n                while (n != 0) {\n                    ++i;\n                    if (s[i] == '[') ++n;\n                    if (s[i] == ']') --n;\n                }\n                string str = decodeString(s.substr(r + 1, i - r - 1));\n                for (int i = 0; i < k; ++i) res += str; \n            }\n            if (isalpha(s[i])) res += s[i];\n        }\n        return res == \"\" ? s : res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435642202","body":"```c++\nclass MyQueue {\npublic:\n        stack<int> rev;\n        stack<int> q;\n        bool isRev=true;\n    MyQueue() {\n\n    }\n    void _q2rev(){\n        while(!q.empty()){\n            rev.push(q.top());\n            q.pop();\n        }\n        isRev=true;\n    }\n    void _rev2q(){\n        while(!rev.empty()){\n            q.push(rev.top());\n            rev.pop();\n        }\n        isRev=false;\n    }\n\n    void push(int x) {\n        if(!isRev) _q2rev();\n        rev.push(x);\n    }\n    \n    int pop() {\n        if(isRev) _rev2q();\n        int i=q.top();\n        q.pop();\n        return i; \n    }\n    \n    int peek() {\n        if(isRev) _rev2q();\n        return q.top(); \n    }\n    \n    bool empty() {\n        return rev.empty()&&q.empty();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436182301","body":"```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        vector<int> maxV(arr.size());\n        vector<int> minV(arr.size());\n        int maxi = INT_MIN;\n        for (int i = 0; i < arr.size(); ++i)\n            maxV[i] = maxi = max(maxi, arr[i]);\n        int mini = INT_MAX;\n        for (int i = arr.size() - 1; i >= 0; --i)\n            minV[i] = mini = min(mini, arr[i]);\n        int result = 0;\n        for (int i = 0; i < arr.size(); ++i)\n            if (i == arr.size() - 1 || maxV[i] <= minV[i + 1])\n            ++result;\n        return result;\n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436201012","body":"```c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head==nullptr) return head;\n        vector<ListNode*> l;\n        ListNode* p=head;\n        while(p!=nullptr) { l.emplace_back(p); p=p->next;}\n        k=k%l.size();\n        if(k==0) return head;\n        l[l.size()-1]->next = l[0];\n        l[l.size()-k-1]->next = nullptr;\n        return l[l.size()-k];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438516556","body":"```c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head==nullptr) return head;\n        ListNode top(-1,head);\n        ListNode* p0=&top,*p1=head,*p2=head->next,*p3;\n        p2=p1==nullptr?nullptr:p1->next;\n        while(p1!=nullptr&&p2!=nullptr){\n            p3=p2->next;\n            p0->next=p2;\n            p0=p2->next=p1;\n            p1=p1->next=p3;\n            p2=p3==nullptr?p3:p3->next;\n            p3=p2==nullptr?p3:p2->next;\n        }\n        return top.next;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440162927","body":"```c++\nclass Solution {\npublic:\n    ListNode* mid(ListNode* l,ListNode* r){\n        ListNode* p1=l,*p2=l;\n        while(p2!=r&&p2->next!=r){\n            p1=p1->next;\n            p2=p2->next->next;\n        }\n        return p1;\n    }\n    TreeNode* build(ListNode* l,ListNode* r){\n        if(l==r) return nullptr;\n        TreeNode* t = new TreeNode();\n        ListNode* m = mid(l,r);\n        t->val = m->val;\n        t->left = build(l,m);\n        t->right = build(m->next,r);\n        return t;\n    }\n    TreeNode* sortedListToBST(ListNode* head) {\n        return build(head,nullptr);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441967425","body":"```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (headA == nullptr || headB == nullptr) {\n            return nullptr;\n        }\n        ListNode *pA = headA, *pB = headB;\n        while (pA != pB) {\n            pA = pA == nullptr ? headB : pA->next;\n            pB = pB == nullptr ? headA : pB->next;\n        }\n        return pA;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443906881","body":"```c++\r\n\r\nclass Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null || head.next == null)\r\n            return null;\r\n        \r\n        ListNode slow = head, fast = head;\r\n        while (fast != null && fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            if (slow == fast) break;\r\n        }\r\n        if (fast == null || fast.next == null)\r\n            return null;\r\n        slow = head;\r\n        while (slow != fast) {\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445381416","body":"```c++\nclass DBList {\n    public:\n        DBList* next;\n        DBList* prev;\n        int key;\n        int value;\n        DBList(int key,int val){\n            this->next = nullptr;\n            this->prev = nullptr;\n            this->value = val;\n        }\n        DBList(DBList* pre,int key,int val){\n            this->next = nullptr;\n            this->prev = pre;\n            this->value = val;\n            prev->next = this;\n        }\n};\nclass LRUCache {\npublic:\n    int cap = 0;\n    DBList* head;\n    DBList* end;\n    unordered_map<int,DBList*> m;\n    LRUCache(int capacity) {\n        this->cap = capacity;\n        this->head = new DBList(-1,-1);\n        this->end = new DBList(this->head,-1,-1);\n    }\n    \n    int get(int key) {\n        auto it = m.find(key);\n        if(it!=m.end()){\n            auto node = it->second;\n            node->prev->next = node->next;\n            node->next->prev = node->prev;\n            node->next = this->head->next;\n            node->prev = this->head;\n            this->head->next->prev = node;\n            this->head->next = node;\n            return node->value;\n        }else return -1;\n    }\n    \n    void put(int key, int value) {\n        auto it = m.find(key);\n        if(it!=m.end()){\n            it->second->value = value;\n            auto node = it->second;\n            node->prev->next = node->next;\n            node->next->prev = node->prev;\n            node->next = this->head->next;\n            node->prev = this->head;\n            this->head->next->prev = node;\n            this->head->next = node;\n        }else{\n            DBList* tmp = new DBList(key,value);\n            if(m.size()>=cap){\n                m.erace(this->end->prev->key);\n                this->end->prev = this->end->prev->prev;\n                this->end->prev->prev->next=this->end;\n            }\n            m[key] = tmp;\n            tmp->next = this->head->next;\n            tmp->prev = this->head;\n            this->head->next = tmp;\n            tmp->next->prev = tmp;\n        }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445362841","body":"```c++\nclass Solution {\npublic:\n    int getMaxDep(TreeNode* root,int depth){\n        int dep = depth;\n        if(root->left!=nullptr) dep=max(getMaxDep(root->left,depth+1),dep);\n        if(root->right!=nullptr) dep=max(getMaxDep(root->right,depth+1),dep);\n        return dep;\n    }\n    int maxDepth(TreeNode* root) {\n        if(root==nullptr) return 0;\n        return getMaxDep(root,1);\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoeyzyzyzy":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429421064","body":"``` java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        List<Integer> res = new ArrayList<>();\n        int i = n - 1, sum = 0, carry = 0;\n        while (i >= 0 || k != 0) {\n            int x = i >= 0 ? num[i] : 0;\n            int y = k != 0 ? k % 10 : 0;\n\n            sum = x + y + carry;\n            carry = sum / 10;\n            k = k / 10;\n\n            i--;\n            res.add(0, sum % 10);\n        }\n        if (carry != 0)\n            res.add(0, carry);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430987728","body":"### Thought\n- thinking of how to get distance between c and s.charAt(i);\n- go through the string twice 1 order and 1 reverse order;\n- in order is to traverse c in left situation, for first part(left has no c): make idx to -n;\n- reverse order is to traverse c in right situation, for last part(right has no c): make idx to 2*n;\n- find minium.\n### Code\n``` java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] res = new int[n];\n\n        for (int i = 0, idx = -n; i < n; i++) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            res[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            res[i] = Math.min(res[i], idx - i);\n        }\n        return res;\n    }\n}\n```\n### Complexity\nTime complexity : O(n), traverse twice\n\nSpace complexity : O(n) array with size n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432758412","body":"``` java\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1433583760","body":"### Thought\nSince this problem we need to process the string in a nested manner, that is we need to process substring inside brackets before processing the outer substrings. A stack is a natural choice for this kind of problem because it allows us keep track of the order in which we encounter brackets.  Step by step:\n\n1. Initialize a string \"res\" to store the final decoded string, an integer \"curNumber\" to store the current number being processed, and two empty stacks: one to store the previous results and another to store the previous numbers.\n\n2. Loop through each character in the input string \"s\":\n\n    -  If the current character \"ch\" is a digit, update the current number \"curNumber\" by appending the digit to the end of the current number.\n\n    -  If the current character \"ch\" is an opening bracket '[', push the current number \"curNumber\" and the current result \"res\" onto their respective stacks, and reset \"curNumber\" and \"res\" to empty strings to start processing the substring inside the brackets.\n\n    -  If the current character \"ch\" is a closing bracket ']', pop the top element \"prevRes\" from the result stack and the top element \"prevNum\" from the number stack. Repeat the substring \"res\" \"prevNum\" times and append the resulting string to \"prevRes\". Set \"res\" to the new \"prevRes\" and continue processing the rest of the string.\n\n    -  If the current character \"ch\" is a letter, append it to the current result \"res\".\n\n3. Once the loop is complete, return the final decoded string \"res\".\n\n### Code\n``` java\nclass Solution {\n    public String decodeString(String s) {\n        LinkedList<String> stringStack = new LinkedList<>();\n        LinkedList<Integer> numStack = new LinkedList<>();\n        StringBuilder sb = new StringBuilder();\n        int curNum = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            char cur = s.charAt(i);\n            if (cur >= '0' && cur <= '9') {\n                curNum = curNum * 10 + (cur - '0');\n            } else if (cur == '[') {\n                stringStack.push(sb.toString());\n                numStack.push(curNum);\n                curNum = 0;\n                sb = new StringBuilder();\n            } else if (cur == ']') {\n                StringBuilder tem = new StringBuilder();\n                int cur_num = numStack.pop();\n                for (int j = 0; j < cur_num; j++) {\n                    tem.append(sb);\n                }\n                sb = new StringBuilder(stringStack.pop() + tem);\n            } else {\n                sb.append(cur);\n            }\n        }\n        return sb.toString();\n    }\n}\n```\n\n### Complexity:\nTime: O(n), loop through the input string 1 once.\n\nSpace: O(n), in the worst case, where the input string is fully nested, the maximum size of the stacks would be O(n/2). ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435129875","body":"``` java\n/* \n * imlpement a FIFO queue using only 2 stacks, stack is FILO, \n * so we can think of use one stack to store In and other for Out.\n * We can also have a variable to store front value to decrease time complexity.\n */\n\nclass MyQueue {\n    LinkedList<Integer> stackIn;\n    LinkedList<Integer> stackOut;\n\n    public MyQueue() {\n        stackIn = new LinkedList<>();\n        stackOut = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        stackIn.push(x);\n    }\n\n    public int pop() {\n        if (stackOut.isEmpty()) {\n            while (!stackIn.isEmpty()) {\n                stackOut.push(stackIn.pop());\n            }\n        }\n        return stackOut.pop();\n    }\n\n    public int peek() {\n        if (stackOut.isEmpty()) {\n            while (!stackIn.isEmpty()) {\n                stackOut.push(stackIn.pop());\n            }\n        }\n        return stackOut.peek();\n    }\n\n    public boolean empty() {\n        return stackIn.isEmpty() && stackOut.isEmpty();\n    }\n}\n\n//Time Complexity: push(), empty(): O(1), pop() and peek() amortized time complexity(best situation) : O(1)\n//Space Complexity: O(n)\n\nclass MyQueue1 {\n    LinkedList<Integer> stack1;\n    LinkedList<Integer> stack2;\n    int front;\n\n    public MyQueue1() {\n        stack1 = new LinkedList<>();\n        stack2 = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        if (stack1.isEmpty())\n            front = x;\n        stack1.push(x);\n    }\n\n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n\n    }\n\n    public int peek() {\n        if (!stack2.isEmpty())\n            return stack2.peek();\n        return front;\n    }\n\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n\n//Time Complexity: push(), empty(), peek(): O(1), pop(): amortized time complexity(best situation) : O(1)\n//Space Complexity: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435938082","body":"``` java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436655593","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438202403","body":"```java\nclass Solution {\n   public ListNode swapPairs(ListNode head) {\n      ListNode node = new ListNode(0);\n        node.next = head;\n        ListNode ptr = head;\n        while (ptr!= null && ptr.next != null) {\n            ListNode newNode = ptr.next;\n            ptr.next = newNode.next;\n            newNode.next = ptr;\n            ptr = ptr.next;\n        }\n        return node.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1438987722","body":"```java\nclass Solution {\n    // Initial thought: put each node's val in to map and recursively access this\n    // map build tree.\n    // optimization: can use array istead of map to save space\n    // howerver did not use property of LinkedList\n    // time complexity: O(n), space complexity: O(n + logN)\n    HashMap<Integer, Integer> map = new HashMap<>();\n\n    public TreeNode sortedListToBST1(ListNode head) {\n        int index = 0;\n        ListNode l1 = head;\n        while (l1 != null) {\n            map.put(index, l1.val);\n            l1 = l1.next;\n            index++;\n        }\n        // System.out.println(index);\n        return helper(0, index - 1);\n    }\n\n    private TreeNode helper(int start, int end) {\n        TreeNode root = new TreeNode();\n        if (start > end)\n            return null;\n        int mid = (start + end) >>> 1;\n        root.val = map.get(mid);\n        root.left = helper(start, mid - 1);\n        root.right = helper(mid + 1, end);\n        return root;\n    }\n\n    // Another thought: use fast and slow pointer to find the midian node;\n    // important note : we need a pointer - pre to make the left part of linkedList's length change, otherwise we can not know the end of left part.\n    // time complexity : O(N),  space complexity: O(logN)\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null)\n            return null;\n        if (head.next == null)\n            return new TreeNode(head.val);\n\n        ListNode p = head, q = head, pre = null;\n        while (q != null && q.next != null) {\n            pre = p;\n            p = p.next;\n            q = q.next.next;\n        }\n        pre.next = null;\n\n        TreeNode root = new TreeNode(p.val);\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(p.next);\n        return root;\n    }\n\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1440765717","body":"```java\r\npublic class Solution {\r\n    // A : a + c B: b + c  if A & B intersect, if will have a+b+c; else a+b => null\r\n   // TC:O(m+n) SC:O(1)\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode p1 = headA, p2 = headB;\r\n        while (p1 != p2) {\r\n            p1 = p1 == null ? headB : p1.next;\r\n            p2 = p2 == null ? headA : p2.next;\r\n        }\r\n        return p1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443152487","body":"```java\n/*\n * suppose length of linklist is a + b (b is circle's length),\n * when fast & slow meet the fast's distance: f = 2 * s , f = s + nb\n * (相遇时a比b多走了nb)\n * => s = nb , f = 2nb; start from head, if we want to find the start of the\n * circle,\n * we should have k = a + nb, at this time, s alreay get nb, it needs another a;\n * there is a new pointer start from head, this pointer will meet slow at the\n * start of circle,\n * which will take a steps;\n * time complexity: O(n), space complexity: O(1);\n */\n\nclass Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null)\n            return null;\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {\n                fast = head;\n                while (fast != slow) {\n                    fast = fast.next;\n                    slow = slow.next;\n                }\n                return slow;\n            }\n        }\n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1444997357","body":"```java\n//Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n//Use doubly LinkedList to implement get & put with O(1) time complexity\n//Compared to singly linkedlist, the delete operation is pretty efficient, because we know current node's previous one\n//In this LRU, we need HashMap to help us restore key & node, to help us easily find target.\n//we need doubly linkedlist to help us record most & least recently used.\n//use 4 helper functions: addToHead, deleteTail, removeNode, moveNodeToHead.\n//remember when get/put, we need update not only doubly linkedlist but also hashMap.\n\n// Time Complexity: O(1), Space Complexity:O(capacity)\nclass LRUCache {\n    class DNode {\n        DNode pre;\n        DNode next;\n        int val;\n        int key;\n\n        DNode() {\n        }\n\n        DNode(int key, int value) {\n            this.key = key;\n            this.val = value;\n        }\n    }\n\n    private HashMap<Integer, DNode> map = new HashMap<>();\n    private DNode dummHead;\n    private DNode dummTail;\n    private int size, capacity;\n\n    public LRUCache(int capacity) {\n        this.dummHead = new DNode();\n        this.dummTail = new DNode();\n        dummHead.next = dummTail;\n        dummTail.pre = dummHead;\n        this.size = 0;\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        DNode cur = map.get(key);\n        if (cur == null)\n            return -1;\n        moveNodeToHead(cur);\n        return cur.val;\n\n    }\n\n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            DNode cur = map.get(key);\n            cur.val = value;\n            moveNodeToHead(cur);\n        } else {\n            DNode newNode = new DNode(key, value);\n            map.put(key, newNode);\n            addToHead(newNode);\n            size++;\n            while (size > capacity) {\n                DNode res = deleteTail();\n                map.remove(res.key);\n                size--;\n            }\n        }\n    }\n\n    private void addToHead(DNode node) {\n        // DNode temp = dummHead.next;\n        node.pre = dummHead;\n        node.next = dummHead.next;\n        dummHead.next.pre = node;\n        dummHead.next = node;\n    }\n\n    private void removeNode(DNode node) {\n        node.pre.next = node.next;\n        node.next.pre = node.pre;\n    }\n\n    private void moveNodeToHead(DNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DNode deleteTail() {\n        DNode res = dummTail.pre;\n        removeNode(res);\n        return res;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445201342","body":"```java\n\n// Find max depth means we need to find max between left and right; Think of recursion first.\nclass Solution {\n    // Recursive Method: Time Complexity: O(n), Space Complexity: O(height)\n    // 1. preorder: \n    int max = 0;\n\n    public int maxDepth1(TreeNode root) {\n        preOrder(root, 1);\n        return max;\n    }\n\n    private void preOrder(TreeNode root, int depth) {\n        if (root == null)\n            return;\n        if (root.left == null && root.right == null) {\n            max = Math.max(max, depth);\n        }\n        preOrder(root.left, depth + 1);\n        preOrder(root.right, depth + 1);\n    }\n\n    //2. postOrder:\n    public int maxDepth2(TreeNode root) {\n        if (root == null)\n            return 0;\n        int left = maxDepth2(root.left);\n        int right = maxDepth2(root.right);\n        return Math.max(left, right) + 1;\n\n    }\n    //3. combination & simplification\n    public int maxDepth(TreeNode root) {\n        if (root == null)\n            return 0;\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n\n    //4. Level Order Traversal : Time coplexity: O(n), worst Space Complexity: O(n)\n    public int maxDepth3(TreeNode root) {\n        int level = 0;\n        if (root == null)\n            return max;\n        LinkedList<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            level++;\n            while (size-- > 0) {\n                TreeNode cur = queue.poll();\n                if (cur.left != null)\n                    queue.offer(cur.left);\n                if (cur.right != null)\n                    queue.offer(cur.right);\n            }\n        }\n        return level;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445500400","body":"``` java\npackage Tree;\n\nimport java.util.LinkedList;\n\n/* Given the roots of two binary trees p and q, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\n*/\n\n// Definition for a binary tree node.\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode() {\n    }\n\n    TreeNode(int val) {\n        this.val = val;\n    }\n\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    // think of that with preoder trversal, first compare current node, then compare\n    // left & right.\n    // only current.val & left & right are all same , the tree could be same\n\n    // Recursive method:\n    // Time Complexity: O(min(m,n)) - need to compare each node and stop when arrive\n    // less total number,\n    // Space Complexity: O(min(m,n)) - recursion space depends on tree height, worst\n    // case tree's height equals to nodes.\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null)\n            return true;\n        if (p == null || q == null)\n            return false;\n        if (p.val != q.val)\n            return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n\n    // Iterative method:\n    // Time Complexity: O(min(m+n)); Space Complexity: O(min(m,n));\n    public boolean isSameTree1(TreeNode p, TreeNode q) {\n        if (p == null && q == null)\n            return true;\n        if (p == null || q == null)\n            return false;\n        LinkedList<TreeNode> queue1 = new LinkedList<>();\n        LinkedList<TreeNode> queue2 = new LinkedList<>();\n        queue1.offer(p);\n        queue2.offer(q);\n        while (!queue1.isEmpty() && !queue2.isEmpty()) {\n            TreeNode cur1 = queue1.poll();\n            TreeNode cur2 = queue2.poll();\n            if (cur1.val != cur2.val)\n                return false;\n            TreeNode left1 = cur1.left, right1 = cur1.right,\n                    left2 = cur2.left, right2 = cur2.right;\n            if (left1 == null ^ left2 == null) {\n                return false;\n            }\n            if (right1 == null ^ right2 == null) {\n                return false;\n            }\n            if (left1 != null)\n                queue1.offer(left1);\n            if (right1 != null)\n                queue1.offer(right1);\n            if (left2 != null)\n                queue2.offer(left2);\n            if (right2 != null)\n                queue2.offer(right2);\n        }\n        return queue1.isEmpty() && queue2.isEmpty();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447327034","body":"```java\nclass Solution {\n    // DFS: thinking of most easy case first: [1,2,3], and how to convey root.val *\n    // 10 at each recursion\n    // need have a parameter to record the sum before current tree node;\n    // Be careful about a Tree only have left part / right part;\n    // Time complexity:O(n), Space complexity O(n)\n    int total = 0;\n\n    public int sumNumbers(TreeNode root) {\n        dfs(root, 0);\n        return total;\n    }\n\n    private void dfs(TreeNode root, int pre) {\n        if (root.left == null && root.right == null) {\n            total += pre + root.val;\n            return;\n        }\n        pre = (pre + root.val) * 10;\n        if (root.left != null)\n            dfs(root.left, pre);\n        if (root.right != null)\n            dfs(root.right, pre);\n    }\n\n    // BFS: use 2 queues to record node & value\n    // Time Complexity: O(n), Space Complexity:O(n)\n    public int sumNumbersBFS(TreeNode root) {\n        if (root.left == null && root.right == null)\n            return root.val;\n        LinkedList<TreeNode> queue = new LinkedList<>();\n        LinkedList<Integer> curValue = new LinkedList<>();\n        queue.offer(root);\n        curValue.offer(root.val);\n        int sum = 0;\n        while (!queue.isEmpty()) {\n            TreeNode cur = queue.poll();\n            int curNum = curValue.poll();\n            TreeNode left = cur.left, right = cur.right;\n            if (left == null && right == null) {\n                sum += curNum;\n            } else {\n                if (left != null) {\n                    queue.offer(left);\n                    curValue.offer(curNum * 10 + left.val);\n                }\n                if (right != null) {\n                    queue.offer(right);\n                    curValue.offer(curNum * 10 + right.val);\n                }\n            }\n        }\n        return sum;\n    }\n\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449440918","body":"```java\n//Given the root of a binary tree, return the leftmost value in the last row of the tree.\n\nclass Solution {\n    // recursion: if we do preorder traverse, when we arrive at the max depth, \n    // we only need to care the first value we meet.\n    // Time Complexity: O(n), Space Complexity: O(n)\n\n    int res = 0;\n    int maxDepth = 0;\n\n    public int findBottomLeftValue(TreeNode root) {\n        maxDepth(root, 1);\n        return res;\n    }\n    \n    private void maxDepth(TreeNode root, int depth) {\n        if (root == null)\n            return;\n        if (root.left == null && root.right == null) {\n            if (depth > maxDepth) {\n                maxDepth = depth;\n                res = root.val;\n            }\n        }\n        maxDepth(root.left, depth + 1);\n        maxDepth(root.right, depth + 1);\n    }\n\n    //BFS：level of traversal, instead of read from left to right, we can read from right to left,\n    //thus, the last element should be the leftmost value in the last row.\n    //Time Complexity: O(n), Space Complexity: O(n);\n    public int findBottomLeftValue1(TreeNode root) {\n        if (root.left == null && root.right == null)\n            return root.val;\n        LinkedList<TreeNode> queue = new LinkedList<>();\n        int res = 0;\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            while (size-- > 0) {\n                TreeNode curr = queue.poll();\n                if (curr.right != null) {\n                    res = curr.right.val;\n                    queue.offer(curr.right);\n                }\n                if (curr.left != null) {\n                    res = curr.left.val;\n                    queue.offer(curr.left);\n                }\n            }\n        }\n        return res;\n    }\n\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451508151","body":"```java\r\npublic class Codec {\r\n\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        if(root == null) return \"\";\r\n        StringBuilder sb = new StringBuilder();\r\n        LinkedList<TreeNode> queue = new LinkedList<>();\r\n        queue.offer(root);\r\n        while(!queue.isEmpty()){\r\n            TreeNode cur = queue.poll();\r\n            if(cur == null) {\r\n                sb.append(\"x,\");\r\n            } else {\r\n                sb.append(cur.val+\",\");\r\n                queue.offer(cur.left);\r\n                queue.offer(cur.right);\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        if(data == \"\") return null;\r\n        String[] arr = data.split(\",\");\r\n        LinkedList<String> queue = new LinkedList<>(Arrays.asList(arr));\r\n        TreeNode root = new TreeNode(Integer.parseInt(queue.poll()));\r\n        LinkedList<TreeNode> rootQ = new LinkedList<>();\r\n        rootQ.offer(root);\r\n        while(!rootQ.isEmpty()){\r\n            TreeNode cur = rootQ.poll();\r\n            String left = queue.poll();\r\n            String right = queue.poll();\r\n            if(!left.equals(\"x\")){\r\n                cur.left = new TreeNode(Integer.parseInt(left));\r\n                rootQ.offer(cur.left);\r\n            }\r\n            if(!right.equals(\"x\")){\r\n                cur.right = new TreeNode(Integer.parseInt(right));\r\n                rootQ.offer(cur.right);\r\n            }\r\n        }\r\n        return root;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453226485","body":"```java\nclass Solution {\n    Map<TreeNode, int[]> map = new HashMap<>();\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        map.put(root, new int[] { 0, 0, root.val });\n        dfs(root);\n        List<int[]> list = new ArrayList<>(map.values());\n        Collections.sort(list, (a,b) -> {\n        if (a[0] != b[0]) return a[0] - b[0];\n        if (a[1] != b[1]) return a[1] - b[1];\n            return a[2] - b[2];\n        });\n        List<List<Integer>> res = new ArrayList<>();\n        int size = 0;\n        int preCol = Integer.MIN_VALUE;\n        for (int[] info : list) {\n            if (preCol != info[0]) {\n                preCol = info[0];\n                res.add(new ArrayList<Integer>());\n                size++;\n            }\n            res.get(size - 1).add(info[2]);\n        }\n        return res;\n    }\n\n    private void dfs(TreeNode root) {\n        if (root == null)\n            return;\n        int[] info = map.get(root);\n        int col = info[0], row = info[1], val = info[2];\n        if (root.left != null) {\n            map.put(root.left, new int[] { col - 1, row + 1, root.left.val });\n            dfs(root.left);\n        }\n        if (root.right != null) {\n            map.put(root.right, new int[] { col + 1, row + 1, root.right.val });\n            dfs(root.right);\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454257240","body":"```java\r\n//Time Complexity: O(n), Space Complexity: O(n);\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        for (int i = 0; i < nums.length; i++) {\r\n            if (map.containsKey(target - nums[i])) {\r\n                return new int[] { i, map.get(target - nums[i]) };\r\n            }\r\n            map.put(nums[i], i);\r\n        }\r\n        return new int[2];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455029368","body":"```java\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        for (int num : nums) {\r\n            map.put(num, map.getOrDefault(num, 0) + 1);\r\n        }\r\n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>(\r\n                (a, b) -> b.getValue() - a.getValue());\r\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\r\n            pq.offer(entry);\r\n        }\r\n        int[] res = new int[k];\r\n        for (int i = 0; i < k; i++) {\r\n            res[i] = pq.poll().getKey();\r\n        }\r\n        return res;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455681763","body":"```java\nclass Solution {\n    // 对于每个回旋镖三元组而言，本质是在统计给定i的情况下，与i距离相等的(j,k)组合个数为多少；\n    // 由于本题排列顺序会影响结果，所以有A（n,2) = n * (n - 1);\n    // Time Complexity: O(n^2), Space Complexity: O(n)\n    public int numberOfBoomerangs(int[][] points) {\n        int ans = 0;\n        for (int[] p : points) {\n            Map<Integer, Integer> map = new HashMap<>();\n            for (int[] q : points) {\n                int xDiff = p[0] - q[0];\n                int yDiff = p[1] - q[1];\n                int distance = xDiff * xDiff + yDiff * yDiff;\n                map.put(distance, map.getOrDefault(distance, 0) + 1);\n            }\n            for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n                int temp = entry.getValue();\n                ans += temp * (temp - 1);\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1456547557","body":"```java\r\nclass Solution {\r\n    //Using sliding window to store each character \r\n    //if there is a repeated character we can know that we should change left edge to current character's next\r\n    //put the lastest index of character into map, calculate the max substring until now\r\n    //Time Complexity: O(n), Space Complexity: O(m), m is the length of ASCII [0,128) \r\n    public int lengthOfLongestSubstring(String s) {\r\n        int left = 0, max = 0;\r\n        Map<Character, Integer> map = new HashMap<>();\r\n        for (int i = 0; i < s.length(); i++) {\r\n            char c = s.charAt(i);\r\n            if (map.containsKey(c)) {\r\n                left = Math.max(left, map.get(c) + 1);\r\n            }\r\n            map.put(c, i);\r\n            max = Math.max(max, i - left + 1);\r\n        }\r\n        return max;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459557076","body":"```java\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        // initialize all values\r\n        List<Integer> res = new ArrayList<>();\r\n        int oneWordLength = words[0].length();\r\n        int wordsNum = words.length;\r\n        int wordsLength = wordsNum * oneWordLength;\r\n        int sLen = s.length();\r\n        //if length of string less than words' length, there is no qualified result\r\n        if (sLen < wordsLength)\r\n            return res;\r\n        // Use a map to record all words and there will be repeated value, so record the amount of each word.\r\n        Map<String, Integer> allWords = new HashMap<>();\r\n        for (String word : words) {\r\n            if (s.indexOf(word) == -1)\r\n                return res;\r\n            allWords.put(word, allWords.getOrDefault(word, 0) + 1);\r\n        }\r\n\r\n        //Only need to traverse oneWordLength number, because we can cover the situation from second word in s\r\n        //left will help to track from second word to last - words' length word. \r\n        for (int i = 0; i < oneWordLength; i++) {\r\n            int left = i, right = i, count = 0;\r\n            //store word + number in [left,right) \r\n            Map<String, Integer> map = new HashMap<>();\r\n            // right's range from i to slen - oneWordLength.\r\n            while (right + oneWordLength <= sLen) {\r\n                String cur = s.substring(right, right + oneWordLength);\r\n                right += oneWordLength;\r\n                if (allWords.containsKey(cur)) {\r\n                    map.put(cur, map.getOrDefault(cur, 0) + 1);\r\n                    count++;\r\n                    while (map.get(cur) > allWords.get(cur)) {\r\n                        String delString = s.substring(left, left + oneWordLength);\r\n                        map.put(delString, map.get(delString) - 1);\r\n                        left += oneWordLength;\r\n                        count--;\r\n                    }\r\n                } else {\r\n                    left = right;\r\n                    map.clear();\r\n                    count = 0;\r\n                }\r\n                if (count == wordsNum)\r\n                    res.add(left);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1513572231","body":"```java\r\nclass Solution {\r\n    public int subarraysDivByK(int[] nums, int k) {\r\n        Map<Integer, Integer> record = new HashMap<>();\r\n        record.put(0, 1);\r\n        int sum = 0, ans = 0;\r\n        for (int elem : nums) {\r\n            sum += elem;\r\n            int modulus = (sum % k + k) % k;\r\n            int same = record.getOrDefault(modulus, 0);\r\n            ans += same;\r\n            record.put(modulus, same + 1);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1462708762","body":"```java\nclass Solution {\n    //Use slow and fast pointers to traverse list, every time slow with 1 step, fast with 2 step\n    //when fast reach the end of list, slow is in the middle of list.\n    //Time Complexity: O(N), Space Complexity:O(1)\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464590240","body":"```java\r\nclass Solution {\r\n    // Two Pointers, one to traverse the array, the other to record next unique element.\r\n    // Time complexity: O(n), Space complexity: O(1)\r\n    public int removeDuplicates(int[] nums) {\r\n        int p = 0, q = 0;\r\n        while (q < nums.length) {\r\n            if (nums[p] == nums[q]) {\r\n                q++;\r\n            } else {\r\n                nums[++p] = nums[q];\r\n            }\r\n\r\n        }\r\n        return p + 1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465016059","body":"```java\nclass Solution {\n    // sorted array with distinct value and wish to find taget => binary search\n    // if array contains target, just return the index, otherwise, we can use left edge to help.\n    // Time Complexity: O(log n), Space Complexity: O(1)\n    public int searchInsert(int[] nums, int target) {\n        int n = nums.length;\n        int left = 0, right = n - 1;\n        while (left <= right) {\n            int mid = (left + right) >> 1;\n            if (nums[mid] == target)\n                return mid;\n            if (target > nums[mid]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return left;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465320364","body":"```java\r\nclass Solution {\r\n    //Method1: PriorityQueue + Array with length 2;\r\n    //Time Complexity: O(nlogn) in worst case, the array is monotonically increasing, put n elements in pq need n*logn time\r\n    //Space Complexity: O(n) pq need n to store n elements.\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        int n = nums.length;\r\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);\r\n        int[] res = new int[n - k + 1];\r\n        for (int i = 0; i < n; i++) {\r\n            pq.offer(new int[] { nums[i], i });\r\n            while (pq.peek()[1] <= i - k) {\r\n                pq.poll();\r\n            }\r\n            if (i + 1 >= k) {\r\n                res[i - k + 1] = pq.peek()[0];\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    //method2: monotonic queue, use deque as monotonic queue\r\n    //reason to use monotonic queue: because deque can be removed from both head and tail.\r\n    //Time Complexity: O(n), Space complexity: O(k);\r\n    public int[] maxSlidingWindow1(int[] nums, int k) {\r\n        int n = nums.length;\r\n        LinkedList<Integer> dequeue = new LinkedList<>();\r\n        int[] res = new int[n - k + 1];\r\n        for (int i = 0; i < n; i++) {\r\n            dequeue.add(i);\r\n            while (!dequeue.isEmpty() && nums[dequeue.peekLast()] <= nums[i]) {\r\n                dequeue.removeLast();\r\n            }\r\n            dequeue.addLast(i);\r\n            while (dequeue.peek() <= i - k) {\r\n                dequeue.removeFirst();\r\n            }\r\n            if (i + 1 >= k) {\r\n                res[i + 1 - k] = nums[dequeue.peek()];\r\n            }\r\n\r\n        }\r\n        return res;\r\n    }\r\n    //method3:create a monotonic queue manually\r\n        class MonotonicQueue {\r\n            private LinkedList<Integer> maxq = new LinkedList<>();\r\n    \r\n            //删除所有小于n的元素\r\n            public void push(int n) {\r\n                while (!maxq.isEmpty() && maxq.getLast() < n) {\r\n                    maxq.pollLast();\r\n                }\r\n                maxq.addLast(n);\r\n            }\r\n    \r\n            public int max() {\r\n                return maxq.getFirst();\r\n            }\r\n    \r\n            public void pop(int n) {\r\n                if (n == maxq.getFirst()) {\r\n                    maxq.pollFirst();\r\n                }\r\n            }\r\n        }\r\n    \r\n        public int[] maxSlidingWindow2(int[] nums, int k) {\r\n            MonotonicQueue window = new MonotonicQueue();\r\n            int n = nums.length;\r\n            int[] res = new int[n + 1 - k];\r\n            for (int i = 0; i < n; i++) {\r\n                window.push(nums[i]);\r\n                if (i >= k - 1) {\r\n                    res[i - k + 1] = window.max();\r\n                    window.pop(nums[i + 1 - k]);\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467431278","body":"```java\r\nclass Solution {\r\n    //Think of this situation as a directed graph,every node has indegree and out degree.\r\n    //If curr node represents judge, we can know its indegree is n-1, outdegree is 0.\r\n    //Time Complexity:O(m + n) m is length of trust, Space Complexity: O(n)\r\n    public int findJudge(int n, int[][] trust) {\r\n        int[] indegree = new int[n + 1];\r\n        int[] outdegree = new int[n + 1];\r\n        for (int i = 0; i < trust.length; i++) {\r\n            outdegree[trust[i][0]]++;\r\n            indegree[trust[i][1]]++;\r\n        }\r\n        for (int i = 1; i < n + 1; i++) {\r\n            if (indegree[i] == n - 1 && outdegree[i] == 0) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    //Optimize: use only one array to represent both indegree and outdegree.\r\n    public int findJudge1(int n, int[][] trust) {\r\n        int[] record = new int[n + 1];\r\n        for (int[] cur : trust) {\r\n            record[cur[0]]--;\r\n            record[cur[1]]++;\r\n            if (record[cur[1]] == n - 1)\r\n                return cur[1];\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477306376","body":"```java\r\nclass Solution {\r\n    // quick sort\r\n    int[] nums1;\r\n\r\n    public int[] sortArray(int[] nums) {\r\n        this.nums1 = nums;\r\n        quicksort(0, nums.length - 1);\r\n        return nums1;\r\n    }\r\n\r\n    private void quicksort(int left, int right) {\r\n        if (left >= right)\r\n            return;\r\n        int pivot = partition(left, right);\r\n        quicksort(left, pivot - 1);\r\n        quicksort(pivot + 1, right);\r\n    }\r\n    \r\n    private int partition(int left, int right) {\r\n        Random random = new Random();\r\n        int pivot = left + random.nextInt(right - left + 1);\r\n        swap(right, pivot);\r\n        int i = left;\r\n        for (int j = left; j < right; j++) {\r\n            if (nums1[j] < nums1[right]) {\r\n                if (i == j)\r\n                    i++;\r\n                else {\r\n                    swap(i, j);\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        swap(right, i);\r\n        return i;\r\n    }\r\n\r\n    private void swap(int a, int b) {\r\n        int temp = nums1[a];\r\n        nums1[a] = nums1[b];\r\n        nums1[b] = temp;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1478892639","body":"```java\r\nclass Solution {\r\n    // binary-search\r\n    // Randomly choose a number and use binary search to find the answer.\r\n    // Just guess, similar to guess price.\r\n    // Time Complexity: O(logX), Space Complexity: O(1)\r\n    public int mySqrt(int x) {\r\n        if (x == 0)\r\n            return x;\r\n        long left = 1;\r\n        long right = x;\r\n        while (left <= right) {\r\n            long mid = (right + left) >> 1;\r\n            if (mid * mid == x) {\r\n                return (int) mid;\r\n            } else if (mid * mid > x) {\r\n                right = mid - 1;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        return (int)right;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1479992999","body":"```java\n    /*  278. first bad version\n     * >>:有符号右移运算符，将int值的二进制位向右移动指定的位数，并将符号位扩展。\n     * 即，如果值为正，则在左侧插入0；如果值为负，则在左侧插入1。\n     * 例如，对于int类型的-8（即二进制表示为11111111111111111111111111111000），执行-8>>2操作将得到-2（即二进制表示为11111111111111111111111111111110）。\n     * >>>:无符号右移运算符，将int值的二进制位向右移动指定的位数，但是不扩展符号位，而是在左侧插入0。\n     * 即，无论值是正还是负，都在左侧插入0。\n     * 例如，对于int类型的-8，执行-8>>>2操作将得到1073741822（即二进制表示为00111111111111111111111111111110）。\n     */\n    // Time Complexity: O(logn), Space Complexity: O(1)\n    public int firstBadVersion(int n) {\n        int left = 1, right = n;\n        while (left <= right) {\n            // >> 为有符号右移（插入符号位会导致数据溢出)， >>>为无符号右移 \n            int mid = (left + right) >>> 1;\n            if (isBadVersion(mid)) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1481825597","body":"```java\r\nclass Solution {\r\n    int[] nums;\r\n    int[] temp;\r\n    int count = 0;\r\n    int n;\r\n\r\n    public int reversePairs(int[] nums) {\r\n        this.nums = nums;\r\n        this.n = nums.length;\r\n        this.temp = new int[n];\r\n        mergeSort(0, n - 1);\r\n        return count;\r\n    }\r\n\r\n    private void mergeSort(int left, int right) {\r\n        if (left == right)\r\n            return;\r\n        int mid = (left + right) >>> 1;\r\n        mergeSort(left, mid);\r\n        mergeSort(mid + 1, right);\r\n\r\n        int i = left, j = mid + 1;\r\n        while (i <= mid && j <= right) {\r\n            if ((long)nums[i] > (long)2 * nums[j]) {\r\n                count += mid - i + 1;\r\n                j++;\r\n            } else {\r\n                i++;\r\n            }\r\n        }\r\n        i = left;\r\n        j = mid + 1;\r\n        for (int p = left; p <= right; p++) {\r\n            temp[p] = nums[p];\r\n        }\r\n        for (int p = left; p <= right; p++) {\r\n            if (i == mid + 1) {\r\n                nums[p] = temp[j++];\r\n            } else if (j == right + 1 || temp[i] <= temp[j]) {\r\n                nums[p] = temp[i++];\r\n            } else {\r\n                nums[p] = temp[j++];\r\n            }\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483504928","body":"```java\r\nclass Solution {\r\n    // Sort + Binary Search\r\n    //Time Complexity : O((n + m)log(m)) 排序heater: mlogm, 遍历二分 nlogm ; Space Complexity: O(logn) sort need space\r\n    public int findRadius(int[] houses, int[] heaters) {\r\n        Arrays.sort(heaters);\r\n        int res = 0;\r\n        for (int house : houses) {\r\n            int left = binartSearch(heaters, house);\r\n            int right = left + 1;\r\n            int leftDistance = left >= 0 ? house - heaters[left] : Integer.MAX_VALUE;\r\n            int rightDistance = right >= heaters.length ? Integer.MAX_VALUE : heaters[right] - house;\r\n            res = Math.max(res, Math.min(leftDistance, rightDistance));\r\n        }\r\n        return res;\r\n    }\r\n\r\n    private int binartSearch(int[] nums, int target) {\r\n        if (nums[0] > target)\r\n            return -1;\r\n        int left = 0, right = nums.length - 1;\r\n        while (left <= right) {\r\n            int mid = (left + right) >>> 1;\r\n            if (nums[mid] > target) {\r\n                right = mid - 1;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        return right;\r\n    }\r\n\r\n    // Sort + 2 Pointers\r\n    // Time Comlexity: O(mlogm + nlogn) sort need , we can ignore m+n(traverse need), Space Complexity: O(mlogm+nlogn) sort need\r\n    public int findRadius1(int[] houses, int[] heaters) {\r\n        Arrays.sort(houses);\r\n        Arrays.sort(heaters);\r\n        int res = 0;\r\n        for (int i = 0, j = 0; i < houses.length; i++) {\r\n            int curDistance = Math.abs(houses[i] - heaters[j]);\r\n            while (j < heaters.length - 1 && curDistance >= Math.abs(houses[i] - heaters[j + 1])) {\r\n                j++;\r\n                curDistance = Math.min(curDistance, Math.abs(houses[i] - heaters[j]));\r\n            }\r\n            res = Math.max(res, curDistance);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1483917853","body":"```java\n/* \n * 对解空间二分，在其中找到一个差diff，使其绝对值小于等于diff的个数为x，判断x和k之间的关系\n * 1.解空间上下界限： [0, max-min]\n * 2. 计算小于等于diff的个数： 先排序，再利用双指针遍历，若nums[j] - nums[i] > diff，收缩i，直到小于等于\n * 此时可知j结尾的差<=diff的个数，遍历计算所有j的个数\n * \n * Time Complexity: O(nlogn) 有排序， Space Complexity: O(1).\n * When you assign an array to another array variable in Java, you are simply copying the reference to the original array. \n * This means that both variables refer to the same array object in memory.\n */\n\nclass Solution {\n    int[] nums;\n\n    public int smallestDistancePair(int[] _nums, int k) {\n        nums = _nums;\n        Arrays.sort(nums);\n        int left = 0, right = nums[nums.length - 1] - nums[0];\n        while (left <= right) {\n            int mid = (left + right) >>> 1;\n            System.out.println(mid);\n            if (countNotGreater(mid) < k)\n                left = mid + 1;\n            else\n                right = mid - 1;\n\n        }\n        return left;\n\n    }\n\n    private int countNotGreater(int diff) {\n        int count = 0, i = 0;\n        for (int j = 1; j < nums.length; j++) {\n            while (nums[j] - nums[i] > diff) {\n                i++;\n            }\n            count += j - i;\n        }\n        System.out.println(\"count:\" + count);\n        return count;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1496183446","body":"```java\r\nclass Solution {\r\n    public int dfs(int i, int j, int[][] grid){\r\n        grid[i][j]=2;\r\n        int c = 1;\r\n        int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};\r\n        for(int[] d : directions){\r\n            int new_x = i+d[0];\r\n            int new_y = j+d[1];\r\n            if(new_x>=0 && new_x<grid.length && new_y>=0 && new_y<grid[0].length && grid[new_x][new_y]==1){\r\n                c+=dfs(new_x, new_y, grid);\r\n            }\r\n        }\r\n        return c;\r\n    }\r\n    public int maxAreaOfIsland(int[][] grid) {\r\n        int max = 0;\r\n        for(int i=0; i<grid.length; i++){\r\n            for(int j=0; j<grid[0].length; j++){\r\n                if(grid[i][j]==1){\r\n                    int area = dfs(i, j, grid);\r\n                    max = Math.max(max,area);\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1496312825","body":"```java\nclass Solution {\n    // BFS,利用陆地扩张来找到最后的答案\n    // Time Complexity: O(n^2), Space Complexity: O(n^2);\n    public int maxDistance(int[][] grid) {\n        int[][] directions = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };\n        int m = grid.length;\n        int n = grid[0].length;\n        LinkedList<int[]> queue = new LinkedList<>();\n        //先把所有陆地入队\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    queue.offer(new int[] { i, j });\n                }\n            }\n        }\n        //从各个陆地开始，一圈一圈遍历海洋，最后遍历到的海洋就是与陆地有最远距离的海洋\n        boolean hasOcean = false;\n        int[] land = null;\n        while (!queue.isEmpty()) {\n            land = queue.poll();\n            //将四周海洋入队\n            for (int[] direction : directions) {\n                int newX = land[0] + direction[0];\n                int newY = land[1] + direction[1];\n                if (newX < 0 || newX >= m || newY < 0 || newY >= n || grid[newX][newY] != 0)\n                    continue;\n                grid[newX][newY] = grid[land[0]][land[1]] + 1;\n                hasOcean = true;\n                queue.offer(new int[] { newX, newY });\n            }\n        }\n        //没有陆地or没有海洋的情况\n        if (!hasOcean || land == null)\n            return -1;\n        \n        //返回最后遍历到的海洋到陆地的距离，由于初始陆地坐标为1，故需要增加1\n        return grid[land[0]][land[1]] - 1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498561817","body":"```java\r\n\r\nclass Solution {\r\n    //要点：对于第i个盒子，只有拥有这个盒子（初始时拥有/从某个盒子里开出）并且能打开它（初始状态为1/得到了他的钥匙）才能获得其中糖果\r\n    //Analysis: 1. hasBox - shows whether we have this box, canOpen - shows if the state is 1 / we have the key, used - we've already calculated it. \r\n    //          2. initial canOpen depends on initial state. Use a queue to record if this box can be added.\r\n    //              a. we have these initial boxes, however, we only care box that we can open at first step.\r\n    //              b. we need to find more boxes through previous opened boxes. Because all the boxes in the queue can be opened, so we can use cur box's key set to open more boxes.\r\n    //              c. we also need to find if cur keys can open cur box's boxes, if can, we add it into queue for further caculate.\r\n    //          3. When the queue is emepty, we return the answer cuz we find all we need.\r\n\r\n    //Time Complexity: O(n+m) m is the number of keys, Space Complexity: O(n)\r\n\r\n\r\n    public int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {\r\n        int n = status.length;\r\n        int[] canOpen = new int[n];\r\n        int[] hasBox = new int[n];\r\n        int[] used = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            canOpen[i] = status[i];\r\n        }\r\n\r\n        LinkedList<Integer> queue = new LinkedList<>();\r\n        int res = 0;\r\n        for (int box : initialBoxes) {\r\n            hasBox[box] = 1;\r\n            if (canOpen[box] == 1) {\r\n                queue.offer(box);\r\n                used[box] = 1;\r\n                res += candies[box];\r\n            }\r\n        }\r\n\r\n        while (!queue.isEmpty()) {\r\n            int cur = queue.poll();\r\n            for (int key : keys[cur]) {\r\n                canOpen[key] = 1;\r\n                if (used[key] == 0 && hasBox[key] == 1) {\r\n                    queue.offer(key);\r\n                    used[key] = 1;\r\n                    res += candies[key];\r\n                }\r\n            }\r\n            for (int box : containedBoxes[cur]) {\r\n                hasBox[box] = 1;\r\n                if (used[box] == 0 && canOpen[box] == 1) {\r\n                    queue.offer(box);\r\n                    used[box] = 1;\r\n                    res += candies[box];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1499991578","body":"```java\r\nclass SolutionApr6 {\r\n    //Method 1: HashMap + sort + DFS\r\n    Map<TreeNode, int[]> map = new HashMap<>();\r\n\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        map.put(root, new int[] { 0, 0, root.val });\r\n        dfs(root);\r\n        List<int[]> list = new ArrayList<>(map.values());\r\n        Collections.sort(list, (a, b) -> {\r\n            if (a[0] != b[0])\r\n                return a[0] - b[0];\r\n            if (a[1] != b[1])\r\n                return a[1] - b[1];\r\n            return a[2] - b[2];\r\n        });\r\n        List<List<Integer>> res = new ArrayList<>();\r\n        int preCol = Integer.MIN_VALUE;\r\n        for (int[] each : list) {\r\n            if (each[0] != preCol) {\r\n                preCol = each[0];\r\n                res.add(new ArrayList<>());\r\n            }\r\n            res.get(res.size() - 1).add(each[2]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    private void dfs(TreeNode root) {\r\n        if (root == null)\r\n            return;\r\n        int[] info = map.get(root);\r\n        int col = info[0], row = info[1], value = info[2];\r\n        if (root.left != null) {\r\n            map.put(root.left, new int[] { col - 1, row + 1, root.left.val });\r\n            dfs(root.left);\r\n        }\r\n        if (root.right != null) {\r\n            map.put(root.right, new int[] { col + 1, row + 1, root.right.val });\r\n            dfs(root.right);\r\n        }\r\n    }\r\n\r\n    //Method2: BFS\r\n    //The difference between BFS and DFS would only be the traverse process.\r\n        //其实分为两步：1. BFS将这些组合添加进去； 2. 分组排序\r\n        public List<List<Integer>> verticalTraversal1(TreeNode root) {\r\n            List<int[]> tuples = BFS(root);\r\n            Collections.sort(tuples, (a, b) -> {\r\n                if (a[0] != b[0])\r\n                    return a[0] - b[0];\r\n                if(a[1] != b[1])\r\n                    return a[1] - b[1];\r\n                return a[2] - b[2];\r\n            });\r\n            List<List<Integer>> res = new ArrayList<>();\r\n            int preCol = Integer.MIN_VALUE;\r\n            int size = 0;\r\n            for (int[] tuple : tuples) {\r\n                if (tuple[0] != preCol) {\r\n                    res.add(new ArrayList<>());\r\n                    size++;\r\n                    preCol = tuple[0];\r\n                }\r\n                res.get(size - 1).add(tuple[2]);\r\n            }\r\n            return res;\r\n        }\r\n    \r\n        class Tuple {\r\n            TreeNode node;\r\n            int col;\r\n            int row;\r\n    \r\n            Tuple(TreeNode node, int col, int row) {\r\n                this.node = node;\r\n                this.row = row;\r\n                this.col = col;\r\n            }\r\n        }\r\n        \r\n        private List<int[]> BFS(TreeNode node) {\r\n            ArrayList<int[]> res = new ArrayList<>();\r\n            LinkedList<Tuple> queue = new LinkedList<>();\r\n            queue.offer(new Tuple(node, 0, 0));\r\n            Tuple cur;\r\n            int size, row, col;\r\n            \r\n            while (!queue.isEmpty()) {\r\n                size = queue.size();\r\n                while (size-- > 0) {\r\n                    cur = queue.poll();\r\n                    col = cur.col;\r\n                    row = cur.row;\r\n                    res.add(new int[] { col, row, cur.node.val });\r\n                    if (cur.node.left != null)\r\n                        queue.add(new Tuple(cur.node.left, col - 1, row + 1));\r\n                    if (cur.node.right != null)\r\n                        queue.add(new Tuple(cur.node.right, col + 1, row + 1));\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n\r\n\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500438563","body":"```java\r\nclass Solution {\r\n    // point: 到这一阶楼梯不收钱，只有从这个楼梯跳过去才收钱\r\n    // Time Complexity: O(n), Space Complexity: O(n)\r\n    public int minCostClimbingStairs(int[] cost) {\r\n        int n = cost.length;\r\n        int[] dp = new int[n + 1];\r\n        dp[0] = 0;\r\n        dp[1] = 0;\r\n        for (int i = 2; i < n + 1; i++) {\r\n            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\r\n        }\r\n        return dp[n];\r\n    }\r\n\r\n    // 用滚动数组思想，将Space Complexity 减至O(1)\r\n    public int minCostClimbingStairs1(int[] cost) {\r\n        int n = cost.length;\r\n        int[] dp = new int[n + 1];\r\n        dp[0] = 0;\r\n        dp[1] = 0;\r\n        for (int i = 2; i < n + 1; i++) {\r\n            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\r\n        }\r\n        return dp[n];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1502161866","body":"```java\r\nclass Solution {\r\n    //Time Complexity: O(n), Space Complexity: O(n)\r\n    public int rob(int[] nums) {\r\n        int n = nums.length;\r\n        if (n == 1)\r\n            return nums[0];\r\n        int[] dp = new int[n + 1];\r\n        dp[0] = nums[0];\r\n        dp[1] = Math.max(nums[0], nums[1]);\r\n        for (int i = 2; i < n; i++) {\r\n            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\r\n        }\r\n        return dp[n - 1];\r\n    }\r\n\r\n    //Optimize the Space Complexity\r\n    //Space Complexity: O(1)\r\n    public int rob1(int[] nums) {\r\n        int n = nums.length;\r\n        if (n == 1)\r\n            return nums[0];\r\n        int pre = nums[0];\r\n        int cur = Math.max(pre, nums[1]);\r\n        for (int i = 2; i < n; i++) {\r\n            int temp = cur;\r\n            cur = Math.max(pre + nums[i], cur);\r\n            pre = temp;\r\n        }\r\n        return cur;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1504593598","body":"```java\r\nclass Solution {\r\n    // 利用之前300题计算最大长度的方法计算出最大长度，\r\n    // count[i]为已nums[i]为结尾的字符串最长递增子序列的个数\r\n    // 再遍历一遍dp[i]，把最长递增序列长度对应的count[i]累计下来就是结果了。\r\n    // Time Complexity: O(n^2) Space Complexity:O(n^2)\r\n    public int findNumberOfLIS(int[] nums) {\r\n        int n = nums.length;\r\n        if (n == 1)\r\n            return n;\r\n        int[] dp = new int[n];\r\n        Arrays.fill(dp, 1);\r\n        int[] count = new int[n];\r\n        Arrays.fill(count, 1);\r\n        int maxCount = 1;\r\n        for (int i = 1; i < n; i++) {\r\n            for (int j = 0; j < i; j++) {\r\n                if (nums[i] > nums[j]) {\r\n                    if (dp[j] + 1 > dp[i]) {\r\n                        count[i] = count[j];\r\n                    } else if (dp[j] + 1 == dp[i]) {\r\n                        count[i] += count[j];\r\n                    }\r\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\r\n                }\r\n                if (dp[i] > maxCount)\r\n                    maxCount = dp[i];\r\n            }\r\n        }\r\n        int res = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            if (maxCount == dp[i])\r\n                res += count[i];\r\n        }\r\n        return res;\r\n    }\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1502076838","body":"```java\r\nclass Solution {\r\n    //tips: 单个数组/字串用dp时，将dp[i]定义为nums[0:i]中想要的结果，\r\n    // 两个数组/字串用dp时，将其定义为dp[i][j]，含义为在A[0:i]和B[0:j]之间匹配得到想要的结果\r\n\r\n    /* \r\n     * 定义：dp[i][j]为text1[0:i-1]和text2[0:j-1]的最长公共子序列，\r\n     * 这样表示可以在i = 0||j =0时，dp[i][j] 为空字符串和另一个字符串的匹配结果，便于初始化为0\r\n     * 递推公式：如果当前（i- 1) 与(j - 1)字符相同，则目前结果+1，若不同，则结果等于dp[i][j - 1], dp[i - 1][j]中的较大者。（画图可以清晰表示）\r\n     * 初始化：空字符串与另一个字符串的比较结果始终为0\r\n     * 遍历顺序：从小到大\r\n     */\r\n\r\n    //Time Complexity: O(mn), Space Complexity: O(mn)\r\n    public int longestCommonSubsequence(String text1, String text2) {\r\n        int m = text1.length();\r\n        int n = text2.length();\r\n        int[][] dp = new int[m + 1][n + 1];\r\n        for (int i = 1; i <= m; i++) {\r\n            for (int j = 1; j <= n; j++) {\r\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\r\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\r\n                } else {\r\n                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);\r\n                }\r\n            }\r\n        }\r\n        return dp[m][n];\r\n    }\r\n\r\n    //递归版本，没有用缓存，会超时\r\n    String text1, text2;\r\n    public int longestCommonSubsequence1(String text1, String text2) {\r\n        this.text1 = text1;\r\n        this.text2 = text2;\r\n        return dfs(text1.length(), text2.length());\r\n    }\r\n    \r\n    private int dfs(int len1, int len2) {\r\n        if (len1 == 0 || len2 == 0)\r\n            return 0;\r\n        if (text1.charAt(len1 - 1) == text2.charAt(len2 - 1))\r\n            return dfs(len1 - 1, len2 - 1) + 1;\r\n        return Math.max(dfs(len1 - 1, len2), dfs(len1, len2 - 1));\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1503778873","body":"```java\r\nclass Solution {\r\n    // dp[i][j] 到达（i, j)有dp[i][j]条路径\r\n    // dp[i][j] = dp[i-1][j] + dp[i][j-1]\r\n    // 初始化：i = 0, j = 0 => 1\r\n    // 遍历顺序：从上到下，从左到右\r\n    // Time Complexity: O(m*n), Space Complexity: O(m*n)\r\n    public int uniquePaths(int m, int n) {\r\n        int[][] dp = new int[m][n];\r\n        for (int i = 0; i < m; i++) {\r\n            dp[i][0] = 1;\r\n        }\r\n        for (int j = 0; j < n; j++) {\r\n            dp[0][j] = 1;\r\n        }\r\n        for (int i = 1; i < m; i++) {\r\n            for (int j = 1; j < n; j++) {\r\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\r\n            }\r\n        }\r\n        return dp[m - 1][n - 1];\r\n    }\r\n        //利用滚动数组优化空间： 由于dp[i][j]仅依赖于上边和左边的元素\r\n        public int uniquePaths1(int m, int n) {\r\n            int[] dp = new int[n];\r\n            Arrays.fill(dp, 1);\r\n            //外层循环走一次，内层循环走一圈时，表示第一行第i列的总可能数\r\n            //外层循环走2次，内层循环走两圈时，表示第2行第i列的总可能数\r\n            for (int i = 1; i < m; i++) {\r\n                for (int j = 1; j < n; j++) {\r\n                    //“+=” is important! 说明一直在累加，内层循环为从左边加，外层循环再加为从上面加\r\n                    dp[j] += dp[j - 1];\r\n                }\r\n            }\r\n            return dp[n - 1];\r\n        }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1505752485","body":"```java\r\npackage DP;\r\n\r\nclass Solution {\r\n    // 记忆化搜索：向6个方向中每个方向前进的概率为1/8，只要没有走出去都可以增加1/8的概率，路径的1/8概率相乘为这条路径的概率，\r\n    // 然后再继续前进，求出所有可能路径的概率和\r\n    private static final int[][] directions = { { -2, 1 }, { -2, -1 }, { 2, 1 }, { 2, -1 }, { -1, 2 }, { -1, -2 },\r\n            { 1, 2 }, { 1, -2 } };\r\n    double[][][] memo;\r\n\r\n    public double knightProbability(int n, int k, int row, int column) {\r\n        this.memo = new double[n][n][k + 1];\r\n        return dfs(n, k, row, column);\r\n    }\r\n\r\n    private double dfs(int n, int k, int i, int j) {\r\n        if (i < 0 || j < 0 || i >= n || j >= n) {\r\n            return 0;\r\n        }\r\n        if (k == 0) {\r\n            return 1;\r\n        }\r\n        if (memo[i][j][k] != 0) {\r\n            return memo[i][j][k];\r\n        }\r\n\r\n        double ans = 0;\r\n        for (int[] direction : directions) {\r\n            ans += dfs(n, k - 1, i + direction[0], j + direction[1]) / 8;\r\n        }\r\n        memo[i][j][k] = ans;\r\n        return ans;\r\n    }\r\n    \r\n    // dp: 通过观察记忆化搜索，可知在dfs中有3个参数在变化，参考有:\r\n    // dp[i][j][k]表示第k步在（i,j)处的概率为dp[i][j][k].\r\n    // 当 k = k(输入的参数时)，可知其存在的(i,j)为最后路径存在的(i,j)将他们相加则得到最后总概率。\r\n    // 转移方程：dp[i][j][k] = 累加(从1到8) dp[i][j][k - 1]/8;要走到[i,j]的位置，必须要先走了k-1 步，到[i,j]8个方向的一个位置。\r\n    // private static final int[][] directions = { { -2, 1 }, { -2, -1 }, { 2, 1 }, { 2, -1 }, { -1, 2 }, { -1, -2 },\r\n    //         { 1, 2 }, { 1, -2 } };\r\n\r\n    public double knightProbability1(int n, int k, int row, int column) {\r\n        double[][][] dp = new double[n][n][k + 1];\r\n        for (int kk = 0; kk <= k; kk++) {\r\n            for (int i = 0; i < n; i++) {\r\n                for (int j = 0; j < n; j++) {\r\n                    if (kk == 0) {\r\n                        dp[i][j][kk] = 1;\r\n                    } else {\r\n                        for (int[] direction : directions) {\r\n                            int x = i + direction[0];\r\n                            int y = j + direction[1];\r\n                            if (x >= 0 && y >= 0 && x < n && y < n) {\r\n                                dp[i][j][kk] += dp[x][y][kk - 1] / 8.0;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return dp[row][column][k];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1507336500","body":"```java\r\nclass Solution {\r\n    // improvement 1: 用一个int state来标识公共整数池的使用情况 instead of set to avoid copy &\r\n    // maxChoosableInteger space\r\n    int maxChoosableInteger, desiredTotal;\r\n     // 用state来标记整个公共整数池的使用情况，eg: state = 0 -> binary:0 没有数字被用过； state = 18 -> 10010 表示1和4已经被用过了\r\n    // visted[i] = 0 未被访问， visited[i] = 1 访问过，为true, visited[i] = 2 访问过，为false\r\n    int[] visited = new int[1 << 21];\r\n\r\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\r\n        this.maxChoosableInteger = maxChoosableInteger;\r\n        this.desiredTotal = desiredTotal;\r\n        if (desiredTotal <= maxChoosableInteger)\r\n            return true;\r\n        if (desiredTotal > maxChoosableInteger * (maxChoosableInteger + 1) / 2)\r\n            return false;\r\n        return dfs(0, 0);\r\n    }\r\n\r\n    private boolean dfs(int state, int sum) {\r\n        if (visited[state] == 1)\r\n            return true;\r\n        if (visited[state] == 2)\r\n            return false;\r\n        for (int x = 1; x <= maxChoosableInteger; x++) {\r\n            // x已经被选过了\r\n            if (((1 << x) & state) != 0)\r\n                continue;\r\n            if (x + sum >= desiredTotal) {\r\n                visited[state] = 1;\r\n                return true;\r\n            }\r\n            // 对方一定会输吗？\r\n            if (!dfs((1 << x) | state, sum + x)) {\r\n                visited[state] = 1;\r\n                return true;\r\n            }\r\n        }\r\n        visited[state] = 2;\r\n        return false;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1517150460","body":"```java\r\nclass Solution {\r\n    // 求出集合中是否存在和为sum/2的子集\r\n    // 可以将其转化为0-1背包问题，相当于有一堆物品重量为num[i],价值为nums[i] 看能否恰好装满容量为sum / 2的背包\r\n    // dp[j]: 容量为j的背包，所背物品的最大价值为dp[j]\r\n    // 递推公式： dp[j] = max(dp[j],dp[j - nums[i]] + nums[i])\r\n    // 初始化：让dp数组在递推的过程中取得最大的价值，而不是被初始值覆盖了, dp[0] = 0\r\n    // 遍历顺序： 物品遍历for在外围，正序遍历， 背包倒序遍历。 \r\n    // 最后需要判断 dp[sum / 2] ?= sum /2 即可\r\n    public boolean canPartition(int[] nums) {\r\n        int sum = 0;\r\n        for (int i = 0; i < nums.length; i++) {\r\n            sum += nums[i];\r\n        }\r\n        if (sum % 2 != 0)\r\n            return false;\r\n        int target = sum / 2;\r\n        int[] dp = new int[target + 1];\r\n        for (int i = 0; i < nums.length; i++) {\r\n            for (int j = target; j >= nums[i]; j--) {\r\n                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);\r\n            }\r\n        }\r\n        return dp[target] == target;\r\n    }\r\n}\r\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511778938","body":"```java\r\nclass Solution {\r\n    // dp[i]: 最小需要dp[i]个数来表示i，\r\n    // dp[i] = Math.min(dp[i],dp[i - j] + 1) j为数组中的所有数\r\n    // 初始化: dp[i] = amout + 1;\r\n    // 顺序：从左到右\r\n    public int coinChange(int[] coins, int amount) {\r\n        int[] dp = new int[amount + 1];\r\n        for (int i = 0; i <= amount; i++) {\r\n            dp[i] = amount + 1;\r\n        }\r\n        dp[0] = 0;\r\n        for (int i = 1; i <= amount; i++) {\r\n            for (int coin : coins) {\r\n                if (i - coin >= 0) {\r\n                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);\r\n                }\r\n            }\r\n        }\r\n        return dp[amount] == amount + 1 ? -1:dp[amount];\r\n    }\r\n}\r\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1513559035","body":"```java\r\nclass Solution {\r\n    // 贪心策略： 不考虑整体情况，每次只找出局部最优解。 为了让分到饼干的人数最多，先从胃口最小的孩子算起。\r\n    // TC: O(nlogN)(排序的时间复杂度) SC: O(1) 只需要两个指针来记录。\r\n    public int findContentChildren(int[] g, int[] s) {\r\n        Arrays.sort(g);\r\n        Arrays.sort(s);\r\n        int p = 0, q = 0;\r\n        int ans = 0;\r\n        while (p < g.length && q < s.length) {\r\n            if (g[p] <= s[q]) {\r\n                p++;\r\n                q++;\r\n                ans++;\r\n            } else {\r\n                q++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1515459331","body":"```java\r\nclass Solution {\r\n    // 首先通过排序，将附近的区间放在一起，设置第0的区间的右边界，\r\n    // 然后根据接下来区间的左边界判断是否在前一序列的右边界里，没重叠：新的end为区间的右边界，重叠，count++,新的end为最小值（为了满足去除的重复区间尽可能小）\r\n    //TC: O(nlogn) ->排序需要的时间 SC: O(1)\r\n    public int eraseOverlapIntervals(int[][] intervals) {\r\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\r\n        int end = intervals[0][1];\r\n        int count = 0;\r\n        for (int i = 1; i < intervals.length; i++) {\r\n            if (intervals[i][0] >= end)\r\n                end = intervals[i][1];\r\n            else {\r\n                count++;\r\n                end = Math.min(end, intervals[i][1]);\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517128156","body":"```java\r\nclass Solution {\r\n    // 想象每次跳跃能覆盖到的最大范围为多少，若覆盖最大范围的大小超过array length则说明可以到达last index,\r\n    // 若到最后也没能覆盖到last index，则说明不能跳过去\r\n    public boolean canJump(int[] nums) {\r\n        int range = 0;\r\n        for (int i = 0; i <= range; i++) {\r\n            range = Math.max(range, i + nums[i]);\r\n            if (range >= nums.length - 1)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518358250","body":"```java\r\nclass Solution {\r\n    //Leetcode 涂涂画画\r\n    // TC：O(n^2) SP: O(n)\r\n    public int numTrees(int n) {\r\n        int[] dp = new int[n + 1];\r\n        dp[0] = 1;\r\n        for (int i = 1; i <= n; i++) {\r\n            for (int j = 1; j <= i; j++) {\r\n                dp[i] += dp[j - 1] * dp[i - j];\r\n            }\r\n        }\r\n        return dp[n];   \r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519076743","body":"```java\r\nclass Solution {\r\n    //利用堆来处理\r\n    public ListNode mergeKLists(ListNode[] lists) {\r\n        if (lists.length == 0)\r\n            return null;\r\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\r\n        for (ListNode list : lists) {\r\n            if(list != null) pq.offer(list);\r\n        }\r\n        ListNode newHead = new ListNode(-1), ptr = newHead;\r\n        while (!pq.isEmpty()) {\r\n            ListNode cur = pq.poll();\r\n            ptr.next = cur;\r\n            ptr = ptr.next;\r\n            if (cur.next != null)\r\n                pq.offer(cur.next);\r\n        }\r\n        return newHead.next;\r\n    }\r\n}\r\n\r\nclass Solution1 {\r\n    // 先合并两个有序链表，再遍历合并接下来的链表 - 分治法合并\r\n    // 将k个链表两两配对，并将同一队中的链表合并，第一轮后还剩k/2 对链表待合并\r\n    ListNode[] Lists;\r\n\r\n    public ListNode mergeKLists(ListNode[] lists) {\r\n        this.Lists = lists;\r\n        return merge(0, lists.length - 1);\r\n    }\r\n\r\n    private ListNode merge(int left, int right) {\r\n        if (left == right)\r\n            return Lists[left];\r\n        if (left > right)\r\n            return null;\r\n        int mid = left + right >> 1;\r\n        return merge2Lists(merge(left, mid), merge(mid + 1, right));\r\n    }\r\n\r\n    private ListNode merge2Lists(ListNode l1, ListNode l2) {\r\n        if (l1 == null)\r\n            return l2;\r\n        if (l2 == null)\r\n            return l1;\r\n        ListNode sentinel = new ListNode(-1), cur = sentinel;\r\n        while (l1 != null && l2 != null) {\r\n            if (l1.val <= l2.val) {\r\n                cur.next = l1;\r\n                l1 = l1.next;\r\n            } else {\r\n                cur.next = l2;\r\n                l2 = l2.next;\r\n            }\r\n            cur = cur.next;\r\n        }\r\n        cur.next = l1 == null ? l2 : l1;\r\n        return sentinel.next;\r\n    }\r\n}\r\n\r\nclass Solution2 {\r\n    // 先合并两个有序链表，再遍历合并接下来的链表\r\n    // Time Complexity: O((m+n)^k) Space Complexity: O(1)\r\n    public ListNode mergeKLists(ListNode[] lists) {\r\n        if (lists.length == 0)\r\n            return null;\r\n        ListNode cur = lists[0];\r\n        for (int i = 1; i < lists.length; i++) {\r\n            cur = merge2Lists(cur, lists[i]);\r\n        }\r\n        return cur;\r\n    }\r\n\r\n    private ListNode merge2Lists(ListNode l1, ListNode l2) {\r\n        if (l1 == null)\r\n            return l2;\r\n        if (l2 == null)\r\n            return l1;\r\n        ListNode sentinel = new ListNode(-1), cur = sentinel;\r\n        while (l1 != null && l2 != null) {\r\n            if (l1.val <= l2.val) {\r\n                cur.next = l1;\r\n                l1 = l1.next;\r\n            } else {\r\n                cur.next = l2;\r\n                l2 = l2.next;\r\n            }\r\n            cur = cur.next;\r\n        }\r\n        cur.next = l1 == null ? l2 : l1;\r\n        return sentinel.next;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1520730533","body":"```java\r\nclass Solution {\r\n    // 2 * y != x + z; 2*y 是偶数，要想不等于只能是偶数+奇数 -> 奇数\r\n    // 如果一个数组是漂亮数组，那么各元素线性变换后也是漂亮数组\r\n    // eg: 同*：(2 * y) * a != x * a + z * a = > (x + z) * a\r\n    // 同+:  2 * (y + a) = 2 * y + 2 * a != x + a + z + a\r\n    // 线性变换： k * (2 * y) + b = 2*k*y + b ! = k *(x+z) + b\r\n    // f(n) 可以由之前的一系列变换而来\r\n    // N = 1 时有[1] , N = 2 时 通过N = 1 变换 1*2 -1 = 1 ， 1 *2 =2\r\n    // N = 3 时, 通过N = 2 和 N = 1 变换得到， N = 2 变换得到奇数部分 2 * 1 - 1 = 1， 2*2 - 1 = 3, N = 1 变换得到偶数部分：2 * 1 = 2 => [1,3,2]\r\n    // Time Complexity: O(nlogn) f(n) 调用logn次，每次消耗O（n): Space Complexity: O(nlogn) f(n)调用logn次形成大小为logn的递归栈，每次需要长度为n的数组存储结果\r\n    Map<Integer, int[]> memo;\r\n\r\n    public int[] beautifulArray(int n) {\r\n        memo = new HashMap<>();\r\n        memo.put(1, new int[] { 1 });\r\n        return f(n);\r\n    }\r\n\r\n    private int[] f(int n) {\r\n        if (!memo.containsKey(n)) {\r\n            int index = 0;\r\n            int[] res = new int[n];\r\n            for (int x : f((n + 1) / 2)) {\r\n                res[index++] = 2 * x - 1;\r\n            }\r\n            for (int x : f(n / 2)) {\r\n                res[index++] = 2 * x;\r\n            }\r\n            memo.put(n, res);\r\n        }\r\n        return memo.get(n);\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1520997102","body":"```java\r\nclass Solution {\r\n    // TC:O(n), SC:O(1)\r\n    public int[] singleNumber(int[] nums) {\r\n        int tempRes = 0, bit = 1;\r\n        for (int num : nums) {\r\n            tempRes ^= num;\r\n        }\r\n        while ((tempRes & bit) == 0) {\r\n            bit <<= 1;\r\n        }\r\n        int group1 = 0, group2 = 0;\r\n        for (int num : nums) {\r\n            if ((num & bit) != 0) {\r\n                group1 ^= num;\r\n            } else {\r\n                group2 ^= num;\r\n            }\r\n        }\r\n        return new int[] { group1, group2 };\r\n    }\r\n    \r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1522391150","body":"```java\r\nclass Solution {\r\n    //TC: O(n*2^n) SC: O(n)\r\n    List<List<Integer>> res = new ArrayList<>();\r\n    List<Integer> path = new ArrayList<>();\r\n    int[] nums;\r\n\r\n    public List<List<Integer>> subsets(int[] nums) {\r\n        this.nums = nums;\r\n        backtracking(0);\r\n        return res;\r\n    }\r\n\r\n    private void backtracking(int startIndex) {\r\n        res.add(new ArrayList<>(path));\r\n        for (int i = startIndex; i < nums.length; i++) {\r\n            path.add(nums[i]);\r\n            backtracking(i + 1);\r\n            path.remove(path.size() - 1);\r\n        }\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1532266884","body":"```java\r\nclass Solution {\r\n    public TreeNode pruneTree(TreeNode root) {\r\n        TreeNode ans = postOrder(root);\r\n        return ans;\r\n    }\r\n    private TreeNode postOrder(TreeNode cur) {\r\n        if (cur == null) {\r\n            return null;\r\n        }\r\n        TreeNode left = postOrder(cur.left);\r\n        TreeNode right = postOrder(cur.right);\r\n        if (left == null) {\r\n            cur.left = null;\r\n        }\r\n        if (right == null) {\r\n            cur.right = null;\r\n        }\r\n        if (left == null && right == null && cur.val == 0) {\r\n            cur = null;\r\n            return null;\r\n        }\r\n        return cur;\r\n    }\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1536750369","body":"```java\r\nclass Solution {\r\n    //存放结果\r\n    List<List<Integer>> result = new ArrayList<>();\r\n    //暂存结果\r\n    List<Integer> path = new ArrayList<>();\r\n\r\n    public List<List<Integer>> permuteUnique(int[] nums) {\r\n        boolean[] used = new boolean[nums.length];\r\n        Arrays.fill(used, false);\r\n        Arrays.sort(nums);\r\n        backTrack(nums, used);\r\n        return result;\r\n    }\r\n\r\n    private void backTrack(int[] nums, boolean[] used) {\r\n        if (path.size() == nums.length) {\r\n            result.add(new ArrayList<>(path));\r\n            return;\r\n        }\r\n        for (int i = 0; i < nums.length; i++) {\r\n            // used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过\r\n            // used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过\r\n            // 如果同⼀树层nums[i - 1]使⽤过则直接跳过\r\n            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {\r\n                continue;\r\n            }\r\n            //如果同⼀树⽀nums[i]没使⽤过开始处理\r\n            if (used[i] == false) {\r\n                used[i] = true;//标记同⼀树⽀nums[i]使⽤过，防止同一树枝重复使用\r\n                path.add(nums[i]);\r\n                backTrack(nums, used);\r\n                path.remove(path.size() - 1);//回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复\r\n                used[i] = false;//回溯\r\n            }\r\n        }\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null],"jasonqiu":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429514656","body":"- Convert `k` to string\r\n- Pointers `pn` `pk` against `num` `k` respectively\r\n- Start from the ends and continue until both go beyond the first element. One may finish earlier than the other - always set the value to `0` afterwards\r\n- Append the carried bit (if any) and reverse\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        pn = len(num) - 1\r\n        k = str(k)\r\n        pk = len(k) - 1\r\n        carry = 0\r\n        result = []\r\n        while pn >= 0 or pk >= 0:\r\n            a = num[pn] if pn >= 0 else 0\r\n            b = k[pk] if pk >= 0 else 0\r\n            s = int(a) + int(b) + carry\r\n            result.append(s % 10)\r\n            carry = 1 if s >= 10 else 0\r\n            pn -= 1\r\n            pk -= 1\r\n        if carry > 0:\r\n            result.append(1)\r\n        return result[::-1]\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431064325","body":"- Set `last` (last position of the character) to a large negative number\r\n-  Scan from the beginning. Distances to the nearest `c` in the left direction are calculated in this process. `last` will be updated at the position where `c` is found\r\n- Set `last` to a large positive number\r\n- Scan from the end of `s`. When distance to the nearest `c` in the right direction is shorter, update the answer with that distance. Again, `last` will be updated at the position where `c` is found\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        answer = []\r\n        last = -16383\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                last = i\r\n            answer.append(i - last)\r\n        last = 16384\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                last = i\r\n            answer[i] = min(last - i, answer[i])\r\n        return answer\r\n```\r\nTime: O(n)\r\nSpace: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432860740","body":"- Use List\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i] += val\r\n```\r\nTime: `push()` O(1), `pop()` O(1), `increment()` O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434634231","body":"- Create a string `k` and a stack where each element is [current_k, string_to_be_repeated] and initialise with [1, '']\r\n- Start from the beginning. If the character is\r\n        - a letter: append to the last string_to_be_repeated\r\n        - a digit: append to k\r\n        - `[`: append to `k` and append a new element [k, ''] to the stack\r\n        - `]`: pop the last element from the stack, generate the decoded string and append it to string_to_be_repeated of the last element of the stack\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = [[1, '']]\r\n        k = ''\r\n        for i in range(len(s)):\r\n            if s[i].isalpha():\r\n                queue[-1][1] += s[i]\r\n            elif s[i].isdigit():\r\n                k += s[i]\r\n            elif s[i] == '[':\r\n                stack.append([int(k), ''])\r\n                k = ''\r\n            elif s[i] == ']':\r\n                seg = stack.pop()\r\n                stack[-1][1] += seg[1] * seg[0]\r\n        return stack[0][1]\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435613618","body":"- Use the second stack as a reversed stack\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack = []\r\n        self.stackR = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stackR) == 0:\r\n            for i in range(len(self.stack)):\r\n                self.stackR.append(self.stack.pop(-1))\r\n        return self.stackR.pop(-1)\r\n\r\n    def peek(self) -> int:\r\n        if len(self.stackR) == 0:\r\n            for i in range(len(self.stack)):\r\n                self.stackR.append(self.stack.pop(-1))\r\n        return self.stackR[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return len(self.stack) == 0 and len(self.stackR) == 0\r\n```\r\nTime: `push()` `empty()` O(1), `pop()` `peek()` amortised O(1)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435995936","body":"- The presence of a smaller integer in the rear of the sequence will lead to the number of chunks being less, as that integer must be equal to or greater than any element in previous chunks\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = [arr[0]]\r\n        curMax = 0\r\n        for i in range(1, len(arr)):\r\n            if arr[i] >= stack[-1]:\r\n                stack.append(arr[i])\r\n            else:\r\n                curMax = stack[-1]\r\n                while stack and arr[i] < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(curMax)\r\n        return len(stack)\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437132602","body":"- Iterate along till the end and get the length of the linked list\r\n- Link the tail with the head to make it a ring\r\n- Move `length - (k % length)` steps to reach the last element of the new linked list\r\n- Make it the tail\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if head is None:\r\n            return None\r\n        p = head\r\n        length = 1\r\n        new_head = None\r\n        while p.next:\r\n            p = p.next\r\n            length += 1\r\n        p.next = head\r\n        for i in range(length - (k % length)):\r\n            p = p.next\r\n        new_head = p.next\r\n        p.next = None\r\n        return new_head\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438254173","body":"- Create dummy head `prev` and save the new `head`\r\n- Swap when there are at least two nodes remaining\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        prev = ListNode(0, head)\r\n        if head and head.next:\r\n            head = head.next\r\n        while prev.next and prev.next.next:\r\n            left = prev.next\r\n            right = left.next\r\n            prev.next = right\r\n            left.next = right.next\r\n            right.next = left\r\n            prev = left\r\n        return head\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439991415","body":"- Find the mid point and divide\r\n- Recurse on the left and right part\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n        if not head.next.next:\r\n            return TreeNode(head.next.val, TreeNode(head.val))\r\n        node_before_mid = self.findNodeBeforeMid(head)\r\n        root = TreeNode(node_before_mid.next.val, None, self.sortedListToBST(node_before_mid.next.next))\r\n        node_before_mid.next = None\r\n        root.left = self.sortedListToBST(head)\r\n        return root\r\n\r\n    def findNodeBeforeMid(self, head):\r\n        if not head:\r\n            return head\r\n        slow = head\r\n        fast = head.next\r\n        while fast.next and fast.next.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        return slow\r\n```\r\nTime: O(nlogn)\r\nSpace: O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441813234","body":"- Two pointers start from a list respectively, and once reaches the end, start from the other list\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        pa = headA\r\n        pb = headB\r\n        while pa != pb:\r\n            pa = pa.next if pa else headB\r\n            pb = pb.next if pb else headA\r\n        return pa\r\n```\r\nTime: O(m+n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443540397","body":"- The fast pointer is 1x more faster than the slow pointer\r\n- If the fast pointer reaches the end without joining the slow pointer, there is no ring in the linked list\r\n- If two pointer joins, reset the slow one to the head of the linked list. The two pointers will now move at the same pace and the next joining point will be the start of the ring\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        fast = head\r\n        slow = head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if slow == fast:\r\n                break\r\n        if not fast or not fast.next:\r\n            return None\r\n        slow = head\r\n        while fast != slow:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        return slow\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445142584","body":"```python\r\nclass ListNode:\r\n    def __init__(self, key, val):\r\n        self.key = key\r\n        self.val = val\r\n        self.prev = None\r\n        self.next = None\r\n \r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashmap = {}\r\n        self.head = ListNode(0, 0)\r\n        self.tail = ListNode(0, 0)\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    def insert(self, node: ListNode):\r\n        prev = self.tail.prev\r\n        prev.next = node\r\n        node.prev = prev\r\n        node.next = self.tail\r\n        self.tail.prev = node\r\n    \r\n    def remove(self, node: ListNode):\r\n        prev = node.prev\r\n        next = node.next\r\n        prev.next = next\r\n        next.prev = prev\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.hashmap:\r\n            self.remove(self.hashmap[key])\r\n            self.insert(self.hashmap[key])\r\n            return self.hashmap[key].val\r\n        else:\r\n            return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashmap:\r\n            self.remove(self.hashmap[key])\r\n        self.hashmap[key] = ListNode(key, value)\r\n        self.insert(self.hashmap[key])\r\n\r\n        if len(self.hashmap) > self.capacity:\r\n            lru = self.head.next\r\n            self.remove(lru)\r\n            del self.hashmap[lru.key]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445329370","body":"- DFS: recurse until the node is a leaf, and increase `depth` when returning\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446209272","body":"- Recurse root, left and right\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        if not p or not q:\r\n            return False\r\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\nTime: O(n)\r\nSpace: O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448120881","body":"- DFS\r\n```python\r\nclass Solution:\r\n    def sumTree(self, root, prefix):\r\n        prefix = prefix * 10 + root.val\r\n        left = self.sumTree(root.left, prefix) if root.left else 0\r\n        right = self.sumTree(root.right, prefix) if root.right else 0\r\n        sum = left + right\r\n        return sum if sum > 0 else prefix\r\n\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        return self.sumTree(root, 0)\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449783503","body":"- DFS\r\n```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        def dfs(root, depth):\r\n            if not root:\r\n                return\r\n            cur_depth = depth + 1\r\n            if cur_depth > self.max_depth:\r\n                self.max_depth = cur_depth\r\n                self.result = root.val\r\n            dfs(root.left, cur_depth)\r\n            dfs(root.right, cur_depth)\r\n        \r\n        self.max_depth = 0\r\n        self.result = root.val\r\n        dfs(root.left, 0)\r\n        dfs(root.right, 0)\r\n        return self.result\r\n```\r\nTime: O(n)\r\nSpace: O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451550180","body":"```python\r\nclass Codec:\r\n  def serialize(self, root: 'TreeNode') -> str:\r\n    s = []\r\n\r\n    def preorder(root: 'TreeNode') -> None:\r\n      if not root:\r\n        s.append('n')\r\n        return\r\n\r\n      s.append(str(root.val))\r\n      preorder(root.left)\r\n      preorder(root.right)\r\n\r\n    preorder(root)\r\n    return ' '.join(s)\r\n\r\n  def deserialize(self, data: str) -> 'TreeNode':\r\n    q = collections.deque(data.split())\r\n\r\n    def preorder() -> 'TreeNode':\r\n      s = q.popleft()\r\n      if s == 'n':\r\n        return None\r\n\r\n      root = TreeNode(s)\r\n      root.left = preorder()\r\n      root.right = preorder()\r\n      return root\r\n\r\n    return preorder()\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453492321","body":"- DFS\r\n- Use defaultdict to store node val and row info by column\r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        d_by_col = defaultdict(list)\r\n        \r\n        def dfs(node, row, col):\r\n            if node:\r\n                d_by_col[col].append((row, node.val))\r\n                dfs(node.left, row + 1, col - 1)\r\n                dfs(node.right, row + 1, col + 1)\r\n        \r\n        dfs(root, 0, 0)\r\n\r\n        d_by_col_sorted = [n[1] for n in sorted(list(d_by_col.items()), key=lambda n: (n[0]))]\r\n        result = []\r\n        for col in d_by_col_sorted:\r\n            result.append([n[1] for n in sorted(col, key=lambda n:(n[0], n[1]))])\r\n        return result\r\n```\r\nTime: O(nlogn)\r\nSpace: O(n()","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454772480","body":"- Use hashmap to memorise the seen numbers and their positions\r\n```python\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        hashmap = {}\r\n        for i, num in enumerate(nums):\r\n            diff = target - num\r\n            if diff in hashmap:\r\n                return [hashmap[diff], i]\r\n            hashmap[num] = i\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455036204","body":"- Bucket sort\r\n```python\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        frequency = {}\r\n        for num in nums:\r\n            frequency[num] = frequency.get(num, 0) + 1\r\n        buckets = [[] for _ in range(len(nums) + 1)]\r\n        for num, freq in frequency.items():\r\n            buckets[freq].append(num)\r\n        result = []\r\n        for i in range(len(buckets) - 1, -1, -1):\r\n            if len(result) < k:\r\n                result.extend(buckets[i])\r\n        return result\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456139461","body":"- Use dict to save distances\r\n```python\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        distances = {}\r\n        result = 0\r\n        for i in range(len(points)):\r\n            for j in range(i + 1, len(points)):\r\n                count = 0\r\n                d = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\r\n                if d in distances:\r\n                    if i in distances[d]: count += distances[d][i]\r\n                    if j in distances[d]: count += distances[d][j]\r\n                else:\r\n                    distances[d] = defaultdict(int)\r\n                distances[d][i] += 1\r\n                distances[d][j] += 1\r\n                result += count\r\n        return result * 2\r\n```\r\nTime: O(n^2)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457984519","body":"- Two pointers\r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        l, r, result = 0, 0, 0\r\n        substring = set()\r\n        while l < len(s) and r < len(s):\r\n            if s[r] in substring:\r\n                substring.remove(s[l])\r\n                l += 1\r\n            else:\r\n                substring.add(s[r])\r\n                r += 1\r\n                result = max(result, r - l)\r\n        return result\r\n```\r\nTime: O(n)\r\nSpace: O(min(n, m)) where `n` is the length of `s` and `m` is the cardinality of the character set","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460165292","body":"- Sliding window (width = 3)\r\n```python\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        def check_presence(i):\r\n            wc = collections.Counter(words)\r\n            words_found = 0\r\n\r\n            for j in range(i, i + size, len(words[0])):\r\n                sub = s[j:(j + len(words[0]))]\r\n                if wc[sub] == 0:\r\n                    break\r\n                wc[sub] -= 1\r\n                words_found += 1\r\n            return words_found == len(words)\r\n\r\n        result = []\r\n        size = len(words[0]) * len(words)\r\n        for i in range(len(s) - size + 1):\r\n            if check_presence(i):\r\n                result.append(i)\r\n        return result\r\n```\r\nTime: O(mn) where n is the word length and m is the number of words\r\nSpace: O(m + n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461087029","body":"- The task is equivalent to: finding the length of the shortest list, whose sum of elements also leaves a remainder of `sum(nums) % k`\r\n```python\r\nclass Solution:\r\n    def minSubarray(self, nums: List[int], k: int):\r\n        target = sum(nums) % k\r\n        prefix_remainder = {0: -1}\r\n        result = len(nums)\r\n        cur = 0\r\n        for i, num in nums.items():\r\n            cur = (cur + num) % k\r\n            prefix_remainder[cur] = i\r\n            if (cur - target) % k in prefix_remainder:\r\n                result = min(result, i - prefix_remainder[(cur - target) % k])\r\n        return result if result < len(nums) else -1\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463005203","body":" - Slow and fast pointers\r\n ```python\r\nclass Solution:\r\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        fast = head\r\n        slow = head\r\n        while fast.next:\r\n            if fast.next.next:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            else:\r\n                return slow.next\r\n        return slow\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464895301","body":"- Two pointers\r\n```python\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        left = 0\r\n        for right in range(1, len(nums)):\r\n            if nums[left] != nums[right]:\r\n                left += 1\r\n                nums[left] = nums[right]\r\n        return left + 1\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465018229","body":"- Binary search\r\n```python\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        left = 0\r\n        right = len(nums) - 1\r\n        if target <= nums[0]:\r\n            return 0\r\n        if target > nums[right]:\r\n            return right + 1\r\n        while (right - left) > 1:\r\n            i = int((left + right) / 2)\r\n            if target <= nums[i]:\r\n                right = i\r\n            else:\r\n                left = i\r\n        return left + 1\r\n```\r\nTime: O(logn)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465800049","body":"- Deque\r\n```python\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        window = deque()\r\n        result = []\r\n        for i in range(len(nums)):\r\n            while window and i - window[0] >= k:\r\n                window.popleft()\r\n            while window and nums[i] > nums[window[-1]]:\r\n                window.pop()\r\n            window.append(i)\r\n            if i >= k - 1:\r\n                result.append(nums[window[0]])\r\n        return result\r\n```\r\nTime: O(n)\r\nSpace: O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467764016","body":"- Find the node with `n - 1` indegree and `0` outdegree\r\n```python\r\nclass Solution:\r\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\r\n        out_d = defaultdict(int)\r\n        in_d = defaultdict(int)\r\n        for i in range(len(trust)):\r\n            out_d[trust[i][0]] += 1\r\n            in_d[trust[i][1]] += 1\r\n        for i in range(1, n + 1):\r\n            if out_d[i] == 0 and in_d[i] == n - 1:\r\n                return i\r\n        return -1\r\n```\r\nTime: O(E)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469621844","body":"- 'dislike' must be strictly increasing\r\n- DFS\r\n```python\r\nclass Solution:\r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n        edges = defaultdict(set)\r\n        labels = defaultdict(int)\r\n        for d in dislikes:\r\n            edges[d[0]].add(d[1])\r\n            edges[d[1]].add(d[0])\r\n            \r\n        def dfs(person, label):\r\n            labels[person] = label\r\n            for disliked_person in edges[person]:\r\n                if labels[disliked_person] == label or labels[disliked_person] == 0 and not dfs(disliked_person, label * -1):\r\n                    return False\r\n            return True\r\n\r\n        for person in range(1, n + 1):\r\n            if labels[person] == 0 and not dfs(person, 1):\r\n                return False\r\n        return True\r\n```\r\nTime: O(V + E)\r\nSpace: O(V + E)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1470934899","body":"- Assign each of the group-less items to a new group\r\n- Run Topological Sort on groups and items, respectively\r\n```python\r\nclass Solution:\r\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\r\n        def topoSort(nodes: List[int], adj_matrix: List[List[int]], in_degree: List[int]):\r\n            q = collections.deque()\r\n            result = []\r\n            for node in nodes:\r\n                if in_degree[node] == 0:\r\n                    q.append(node)\r\n            while q:\r\n                node = q.popleft()\r\n                result.append(node)\r\n                for next_node in adj_matrix[node]:\r\n                    in_degree[next_node] -= 1\r\n                    if in_degree[next_node] == 0:\r\n                        q.append(next_node)\r\n            return result if len(result) == len(nodes) else []\r\n        \r\n        for item_id, group_of_item in enumerate(group):\r\n            if group_of_item == -1:\r\n                group[item_id] = m\r\n            m += 1\r\n        \r\n        adj_item = defaultdict(list)\r\n        adj_group = defaultdict(list)\r\n        indegree_item = [0] * n\r\n        indegree_group = [0] * m\r\n        \r\n        for i in range(n):\r\n            for before_item in beforeItems[i]:\r\n                adj_item[before_item].append(i)\r\n                indegree_item[i] += 1\r\n        if (item_topo_sorted := topoSort(range(n), adj_item, indegree_item)) == []:\r\n            return []\r\n        \r\n        for i, curr_group in enumerate(group):\r\n            for before_item in beforeItems[i]:\r\n                group_of_before_item = group[before_item]\r\n                if curr_group != group_of_before_item:\r\n                    adj_group[group_of_before_item].append(curr_group)\r\n                    indegree_group[curr_group] += 1\r\n        if (group_topo_sorted := topoSort(range(m), adj_group, indegree_group)) == []:\r\n            return []\r\n        \r\n        item_by_group = defaultdict(list)\r\n        for item in item_topo_sorted:\r\n            item_by_group[group[item]].append(item)\r\n        result = []\r\n        for group in group_topo_sorted:\r\n            result.extend(item_by_group[group])\r\n        return result\r\n```\r\nTime: O(v + e)\r\nSpace: O(v + e)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1472771613","body":"```python\r\nclass Solution:\r\n    def judgeCircle(self, moves: str) -> bool:\r\n        trajectory = {\"U\": 0, \"D\": 0, \"L\": 0, \"R\": 0}\r\n        for m in moves:\r\n            trajectory[m] += 1\r\n        return trajectory[\"U\"] == trajectory[\"D\"] and trajectory[\"L\"] == trajectory[\"R\"]\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474500960","body":"- Sorting\r\n- Min-heap\r\n```python\r\nclass Solution:\r\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\r\n        tasks_sorted = sorted((task[0], task[1], i) for i, task in enumerate(tasks))\r\n        tasks_due = []\r\n        result = []\r\n        current_time = 0\r\n        pos = 0\r\n\r\n        for _ in tasks:\r\n            if not tasks_due and current_time < tasks_sorted[pos][0]:\r\n                current_time = tasks_sorted[pos][0]\r\n            while pos < len(tasks) and tasks_sorted[pos][0] <= current_time:\r\n                heapq.heappush(tasks_due, (tasks_sorted[pos][1], tasks_sorted[pos][2]))\r\n                pos += 1\r\n            processing_time, task_id = heapq.heappop(tasks_due)\r\n            result.append(task_id)\r\n            current_time += processing_time\r\n        \r\n        return result\r\n```\r\nTime: O(nlogn)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475026174","body":"- If goes over midnight, add 24 hours\r\n```python\r\nclass Solution:\r\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\r\n        ih, im = loginTime.split(':')\r\n        oh, om = logoutTime.split(':')\r\n        ih, im, oh, om = int(ih), int(im), int(oh), int(om)\r\n\r\n        if oh < ih or oh == ih and om < im:\r\n            oh += 24\r\n\r\n        if im > 45:\r\n            ih += 1\r\n            im = 0\r\n        elif im > 30:\r\n            im = 45\r\n        elif im > 15:\r\n            im = 30\r\n        elif im > 0:\r\n            im = 15\r\n        \r\n        if om < 15:\r\n            om = 0\r\n        elif om < 30:\r\n            om = 15\r\n        elif om < 45:\r\n            om = 30\r\n        else:\r\n            om = 45\r\n\r\n        minutes = (oh - ih) * 60 + om - im\r\n        return max(minutes, 0) // 15\r\n```\r\nTime: O(1)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475414615","body":"```python\r\nclass Solution:\r\n    def minCharacters(self, a: str, b: str) -> int:\r\n        freq_a = [0] * 26\r\n        freq_b = [0] * 26\r\n        ascii_a = ord('a')\r\n        for letter in a:\r\n            freq_a[ord(letter) - ascii_a] += 1\r\n        for letter in b:\r\n            freq_b[ord(letter) - ascii_a] += 1\r\n        \r\n        result = len(a) + len(b)\r\n\r\n        for i in range(26):\r\n            result = min(result, len(a) - freq_a[i] + len(b) - freq_b[i])\r\n\r\n        for boundary in range(1, 26):\r\n            total = 0\r\n            for i in range(boundary, 26):\r\n                total += freq_a[i]\r\n            for i in range(boundary):\r\n                total += freq_b[i]\r\n            result = min(result, total)\r\n            total = 0\r\n            for i in range(boundary, 26):\r\n                total += freq_b[i]\r\n            for i in range(boundary):\r\n                total += freq_a[i]\r\n            result = min(result, total)\r\n\r\n        return result\r\n```\r\nTime: O(m + n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477451698","body":"- Top-down merge sort\r\n```python\r\nclass Solution:\r\n    def sortArray(self, nums: List[int]) -> List[int]:\r\n        if len(nums) <= 1:\r\n            return nums\r\n        result = []\r\n        mid = len(nums) // 2\r\n        left = self.sortArray(nums[:mid])\r\n        right = self.sortArray(nums[mid:])\r\n        while left and right:\r\n            result.append(left.pop(0) if left[0] < right[0] else right.pop(0))\r\n        return result + left if left else result + right\r\n```\r\nTime: O(nlogn)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479213338","body":"- Binary search\r\n```python\r\nclass Solution:\r\n    def mySqrt(self, x: int) -> int:\r\n        left = 0\r\n        right = x // 2 + 1\r\n        while left < right:\r\n            mid = (left + right + 1) >> 1\r\n            if mid * mid <= x:\r\n                left = mid\r\n            else:\r\n                right = mid - 1\r\n        return left\r\n```\r\nTime: O(logn)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480406515","body":"- Binary search\r\n```python\r\nclass Solution:\r\n    def firstBadVersion(self, n: int) -> int:\r\n        left = 1\r\n        right = n\r\n        while left < right:\r\n            mid = (left + right) >> 1\r\n            if isBadVersion(mid):\r\n                right = mid\r\n            else:\r\n                left = mid + 1\r\n        return left\r\n```\r\nTime: O(logn)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482052034","body":"- Merge sort\r\n```python\r\nclass Solution(object):\r\n    def reversePairs(self, nums):\r\n        def mergeSort(nums, left, right):\r\n            if left >= right:\r\n                return 0\r\n            mid = left + (right - left) // 2\r\n            result = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\r\n            j = mid + 1\r\n            for i in range(left, mid + 1):\r\n                while j <= right and nums[i] > 2 * nums[j]:\r\n                    j += 1\r\n                result += j - (mid + 1)\r\n            nums[left:(right + 1)] = sorted(nums[left:(right + 1)])\r\n            return result\r\n\r\n        return mergeSort(nums, 0, len(nums) - 1)\r\n```\r\nTime: O(nlogn)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483505183","body":"- Binary search\r\n```python\r\nclass Solution:\r\n    def solve(self, nums):\r\n        nums.sort()\r\n\r\n        def can_light_up(diameter):\r\n            index = bisect(nums, nums[0] + diameter * 3)\r\n            return True if index >= len(nums) else False\r\n\r\n        left = 0\r\n        right = nums[-1] - nums[0]\r\n        while left <= right:\r\n            mid = (left + right) >> 1\r\n            if can_light_up(mid):\r\n                right = mid - 1\r\n            else:\r\n                left = mid + 1\r\n        return left >> 1\r\n```\r\nTime: O(nlogn)\r\nSpace: ?","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1483951020","body":"- Binary search\r\n```python\r\nclass Solution(object):\r\n    def smallestDistancePair(self, nums, k):\r\n        nums = sorted(nums)\r\n        left = 0\r\n        right = nums[-1] - nums[0]\r\n        while left < right:\r\n            mid = (left + right) >> 1\r\n            count = 0\r\n            j = 0\r\n            for i in range(len(nums)):\r\n                while j < len(nums) and nums[j] - nums[i] <= mid:\r\n                    j += 1\r\n                count += j - i - 1\r\n            if count < k:\r\n                left = mid + 1\r\n            else:\r\n                right = mid\r\n        return left\r\n```\r\nTime: O(nlogn)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1485073081","body":"- Dijkstra\r\n```python\r\nclass Solution(object):\r\n    def swimInWater(self, grid):\r\n        n = len(grid)\r\n        heap = []\r\n        heapq.heappush(heap, (grid[0][0], 0, 0))\r\n        visited = {0 * n + 0: 1}\r\n        directions = [-1, 0, 1, 0, -1]\r\n        \r\n        while heap:\r\n            cell = heapq.heappop(heap)\r\n            if cell[1] == n - 1 and cell[2] == n - 1:\r\n                return cell[0]\r\n            for i in range(4):\r\n                next_x = cell[1] + directions[i]\r\n                next_y = cell[2] + directions[i + 1]\r\n                if next_x < 0 or next_y < 0 or next_x >= n or next_y >= n or visited.get(next_x * n + next_y):\r\n                    continue\r\n                visited[next_x * n + next_y] = 1\r\n                heapq.heappush(heap, (max(cell[0], grid[next_y][next_x]), next_x, next_y))\r\n```\r\nTime: O((n^2)logn)\r\nSpace: O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1485947404","body":"```python\r\nclass Solution:\r\n    def maxVowels(self, s: str, k: int) -> int:\r\n        current = 0\r\n        result = 0\r\n        for pos in range(k):\r\n            if s[pos] in \"aeiou\":\r\n                current += 1\r\n        result = current\r\n        for pos in range(1, len(s) - k + 1):\r\n            if s[pos - 1] in \"aeiou\":\r\n                current -= 1\r\n            if s[pos + k - 1] in \"aeiou\":\r\n                current += 1\r\n            result = max(result, current)\r\n        return result\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488214760","body":"```python\r\nclass Solution:\r\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\r\n        dp = [1 if i <= N else 0 for i in range(k + maxPts)]\r\n        s = sum(dp[k:(k + maxPts)])\r\n        for i in range(k - 1, -1, -1):\r\n            dp[i] = s / maxPts\r\n            s -= dp[i + maxPts] + dp[i]\r\n        return dp[0]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489930855","body":"- Sliding window\r\n```python\r\nclass Solution:\r\n    def findAnagrams(self, s: str, p: str) -> List[int]:\r\n        if len(s) < len(p):\r\n            return []\r\n        freq = defaultdict(int)\r\n        result = []\r\n        counter_s = Counter(s[:(len(p) - 1)])\r\n        counter_p = Counter(p)\r\n        pos = 0\r\n        for pos in range(len(p) - 1, len(s)):\r\n            counter_s[s[pos]] += 1\r\n            if counter_s == counter_p:\r\n                result.append(pos - len(p) + 1)\r\n            counter_s[s[pos - len(p) + 1]] -= 1\r\n            if counter_s[s[pos - len(p) + 1]] == 0:\r\n                del counter_s[s[pos - len(p) + 1]]\r\n        return result\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491732495","body":"- Sliding window\r\n```python\r\nclass Solution:\r\n    def minWindow(self, s: str, t: str) -> str:\r\n        freq = defaultdict(int)\r\n        result = [-1, 100001] # [left, length]\r\n        n_diff_chars = 0\r\n        for c in t:\r\n            freq[c] += 1\r\n            if freq[c] == 1:\r\n                n_diff_chars += 1\r\n        left = 0\r\n        for right in range(len(s)):\r\n            freq[s[right]] -= 1\r\n            if freq[s[right]] == 0:\r\n                n_diff_chars -= 1\r\n            if n_diff_chars == 0:\r\n                while freq[s[left]] < 0:\r\n                    freq[s[left]] += 1\r\n                    left += 1\r\n                if result[0] == -1 or right - left < result[1]:\r\n                    result = [left, right - left]\r\n        return s[result[0]:(result[0] + result[1] + 1)] if result[0] >= 0 else \"\"\r\n```\r\nTime: O(m + n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1492717459","body":"- Two pointers\r\n```python\r\ndef removeFromSides(nums, target):\r\n\tresult = math.inf\r\n\tleft = len(nums) - 1\r\n\tright = len(nums)\r\n\ttarget -= sum(nums)\r\n\r\n\twhile left >= 0:\r\n\t\tif target <= 0:\r\n\t\t\ttarget += nums[left]\r\n\t\t\tleft -= 1\r\n\t\tif target > 0:\r\n\t\t\tright -= 1\r\n\t\t\ttarget -= nums[right]\r\n\t\tif target == 0:\r\n\t\t\tresult = min(result, left + 1 + len(nums) - right)\r\n\r\n\treturn result if result < math.inf else -1\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493355898","body":"```python\r\nclass Solution:\r\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\r\n        def dfs(turnedOn, hours, result):\r\n            if hours > turnedOn:\r\n                return\r\n            for h in combinations([1, 2, 4, 8], hours):\r\n                hour = sum(h)\r\n                if hour < 12:\r\n                    for m in combinations([1, 2, 4, 8, 16, 32], turnedOn - hours):\r\n                        minute = sum(m)\r\n                        if minute < 60:\r\n                            result.append(\"%d:%02d\" % (hour, minute))\r\n            dfs(turnedOn, hours + 1, result)\r\n\r\n        result = []\r\n        dfs(turnedOn, 0, result)\r\n        return result\r\n```\r\nTime: O(1)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494572555","body":"- Bit manipulation\r\n```python\r\nclass Solution:\r\n    def totalNQueens(self, n: int) -> int:\r\n        def dfs(row, col, diag1, diag2):\r\n            if row == n:\r\n                return 1\r\n            count = 0\r\n            available_pos = ((1 << n) - 1) & (~ (col | diag1 | diag2))\r\n            while available_pos:\r\n                position = available_pos & (-available_pos)\r\n                available_pos = available_pos & (available_pos - 1)\r\n                count += dfs(row + 1, col | position, (diag1 | position) << 1, (diag2 | position) >> 1)\r\n            return count\r\n\r\n        return dfs(0, 0, 0, 0)\r\n```\r\nTime: O(n!)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1496215413","body":"- BFS\r\n```python\r\nclass Solution:\r\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\r\n        islands = []\r\n        def search(x, y):\r\n            for i in range(len(islands)):\r\n                print(i, islands[i])\r\n                if (x, y) in islands[i]:\r\n                    print((x, y), \"in island\", i)\r\n                    return i\r\n        queue = [[0, 0]]\r\n        while queue:\r\n            [x, y] = queue.pop(0)\r\n            if grid[x][y] == 1:\r\n                if x > 0 and grid[x - 1][y] == 1:\r\n                    islands[search(x - 1, y)].add((x, y))\r\n                elif y > 0 and grid[x][y - 1] == 1:\r\n                    islands[search(x, y - 1)].add((x, y))\r\n                elif x < len(grid[0]) - 1 and grid[x + 1][y] == 1:\r\n                    islands[search(x + 1, y)].add((x, y))\r\n                elif y < len(grid) - 1 and grid[x][y + 1] == 1:\r\n                    islands[search(x, y + 1)].add((x, y))\r\n                else:\r\n                    islands.append(set([(x,y)]))\r\n            elif grid[x][y] == 0:\r\n                if x < len(grid[0]) - 1:\r\n                    queue.append([x + 1, y])\r\n                if y < len(grid) - 1:\r\n                    queue.append([x, y + 1])\r\n            grid[x][y] = -1\r\n        max_area = 0\r\n        for i in range(len(islands)):\r\n            if len(islands[i]) > max_area:\r\n                max_area = len(islands[i])\r\n        return max_area\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497112925","body":"- BFS\r\n```python\r\nclass Solution:\r\n    def maxDistance(self, grid: List[List[int]]) -> int:\r\n        lands = []\r\n        n = len(grid)\r\n        m = len(grid[0])\r\n        dx = [0, 0, 1, -1]\r\n        dy = [1, -1, 0, 0]\r\n        for i in range(n):\r\n            for j in range(m):\r\n                if grid[i][j] == 1:\r\n                    lands.append((i, j))\r\n        if len(lands) == 0 or len(lands) == n * m:\r\n            return -1\r\n        while lands:\r\n            (x, y) = lands.pop(0)\r\n            for i in range(4):\r\n                next_x = x + dx[i]\r\n                next_y = y + dy[i]\r\n                if 0 <= next_x < n and 0 <= next_y < m and grid[next_x][next_y] == 0:\r\n                    grid[next_x][next_y] = grid[x][y] + 1\r\n                    lands.append((next_x, next_y))\r\n        return grid[x][y] - 1\r\n```\r\nTime: O(n^2)\r\nSpace: O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498222975","body":"- BFS\r\n```python\r\nclass Solution:\r\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\r\n        queue = []\r\n        for b in initialBoxes:\r\n            if status[b]:\r\n                queue.append(b)\r\n            else:\r\n                status[b] = -1\r\n        result = 0\r\n        while queue:\r\n            box_current = queue.pop(0)\r\n            result += candies[box_current]\r\n            for box in containedBoxes[box_current]:\r\n                if status[box] == 1:\r\n                    queue.append(box)\r\n                else:\r\n                    status[box] = -1\r\n            for key in keys[box_current]:\r\n                if status[key] == -1:\r\n                    status[key] = 0\r\n                    queue.append(key)\r\n                else:\r\n                    status[key] = 1\r\n        return result\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1500221033","body":"- DFS\r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        d_by_col = defaultdict(list)\r\n        \r\n        def dfs(node, row, col):\r\n            if node:\r\n                d_by_col[col].append((row, node.val))\r\n                dfs(node.left, row + 1, col - 1)\r\n                dfs(node.right, row + 1, col + 1)\r\n        \r\n        dfs(root, 0, 0)\r\n\r\n        d_by_col_sorted = [n[1] for n in sorted(list(d_by_col.items()), key=lambda n: (n[0]))]\r\n        result = []\r\n        for col in d_by_col_sorted:\r\n            result.append([n[1] for n in sorted(col, key=lambda n:(n[0], n[1]))])\r\n        return result\r\n```\r\nTime: O(nlogn)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500900273","body":"```python\r\nclass Solution:\r\n\tdef minCostClimbingStairs(self, cost: List[int]) -> int:\r\n\t\tif not cost:\r\n\t\t\treturn 0\t\t\t\r\n\t\tdp = [0] * len(cost)     \r\n\t\tdp[0] = cost[0]\t\t\r\n\t\tif len(cost) >= 2:\r\n\t\t\tdp[1] = cost[1]\r\n\t\tfor i in range(2, len(cost)):\r\n\t\t\tdp[i] = cost[i] + min(dp[i-1], dp[i-2])\r\n\t\treturn min(dp[-1], dp[-2])\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501156376","body":"```python\r\nclass Solution:\r\n    def rob(self, nums: List[int]) -> int:\r\n        prev_2 = 0\r\n        prev = nums[0]\r\n        curr = nums[0]\r\n        for i in range(1, len(nums)):\r\n            curr = max(prev, prev_2 + nums[i])\r\n            prev_2 = prev\r\n            prev = curr\r\n        return curr\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1502006886","body":"```python\r\nimport bisect\r\nclass Solution(object):\r\n    def findNumberOfLIS(self, nums):\r\n        dp = []\r\n        tree = defaultdict(list)\r\n        for i in nums:\r\n            index = bisect.bisect_left(dp, i)\r\n            if idx == len(dp):\r\n                dp.append(i)\r\n            else:\r\n                dp[index] = i\r\n            total = 0\r\n            for counter, last_num in tree[index]:\r\n                if last_num < i:\r\n                    total += counter\r\n            tree[index + 1].append((max(1, total), i))\r\n        return sum(i[0] for i in tree[len(tree) - 1])\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1502857093","body":"```python\r\ndef longestCommonSubsequence(self, text1: str, text2: str) -> int:\r\n    dp = [[0] * (len(text2) + 1) for _ in range(len(text1) + 1)]\r\n    for i, c in enumerate(text1):\r\n        for j, d in enumerate(text2):\r\n            dp[i + 1][j + 1] = 1 + dp[i][j] if c == d else max(dp[i][j + 1], dp[i + 1][j])\r\n    return dp[-1][-1]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1503975985","body":"```python\r\nclass Solution:\r\n    def uniquePaths(self, m: int, n: int) -> int:\r\n        dp = [[1 for _ in range(n)]] + [[1] + [0 for _ in range(n - 1)] for _ in range(m - 1)]\r\n        for i in range(1, m):\r\n            for j in range(1, n):\r\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\r\n        return dp[m - 1][n - 1]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506509392","body":"```python\r\nclass Solution:\r\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\r\n        dp = [[0 for _ in range(n)] for _ in range(n)]\r\n        dp[row][column] = 1\r\n        directions = [(1, 2), (1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1), (-1, 2), (-1, -2)]\r\n        for step in range(k):\r\n            dp_k = [[0 for _ in range(n)] for _ in range(n)]\r\n            for i in range(n):\r\n                for j in range(n):\r\n                    for d in directions:\r\n                        x = i + d[0]\r\n                        y = j + d[1]\r\n                        if 0 <= x < n and 0 <= y < n:\r\n                            dp_k[x][y] += dp[i][j]\r\n            dp = dp_k\r\n        return sum(map(sum, dp)) / float(8 ** k)\r\n```\r\nTime: O(kn^2)\r\nSpace: O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1508702098","body":"- DFS\r\n```python\r\nclass Solution:\r\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\r\n        if maxChoosableInteger >= desiredTotal:\r\n            return True\r\n        if (1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal:\r\n            return False\r\n        visited = defaultdict(int)\r\n\r\n        def dfs(state, sum):\r\n            if visited[state] == 1:\r\n                return True\r\n            if visited[state] == 2:\r\n                return False\r\n            for number in range(1, maxChoosableInteger + 1):\r\n                if (1 << number) & state:\r\n                    continue\r\n                if sum + number >= desiredTotal:\r\n                    visited[state] = 1\r\n                    return True\r\n                if not dfs((1 << number) | state, sum + number):\r\n                    visited[state] = 1\r\n                    return True\r\n            visited[state] = 2\r\n            return False\r\n\r\n        return dfs(0, 0)\r\n```\r\nTime: O(m*2^m)\r\nSpace: O(2^m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509862856","body":"```python\r\nclass Solution:\r\n    def canPartition(self, nums: List[int]) -> bool:\r\n        if len(nums) == 0:\r\n            return False\r\n        s = sum(nums)\r\n        if s & 1 == 1:\r\n            return False\r\n        target = s // 2\r\n        dp = [False for _ in range(target + 1)]\r\n        for j in range(target + 1):\r\n            if nums[0] == j:\r\n                dp[j] = True\r\n                break\r\n        for i in range(1, len(nums)):\r\n            for j in range(target, -1, -1):\r\n                if j < nums[i]:\r\n                    break\r\n                dp[j] = dp[j] or dp[j - nums[i]]\r\n        return dp[-1]\r\n```\r\nTime: O(n*sum/2)\r\nSpace: O(sum/2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510393138","body":"```python\r\nclass Solution:\r\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\r\n        target += sum(nums)\r\n        if target < 0 or target % 2:\r\n            return 0\r\n        target //= 2\r\n\r\n        @cache\r\n        def dfs(i, capacity):\r\n            if i < 0:\r\n                return 1 if capacity == 0 else 0\r\n            if capacity < nums[i]:\r\n                return dfs(i - 1, capacity)\r\n            return dfs(i - 1, capacity) + dfs(i - 1, capacity - nums[i])\r\n        \r\n        return dfs(len(nums) - 1, target)\r\n```\r\nTime: O(n*target)\r\nSpace: O(n*target)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511296172","body":"```python\r\nclass Solution:\r\n    def coinChange(self, coins: List[int], amount: int) -> int:\r\n        dp = [(amount + 1) for i in range(amount + 1)]\r\n        dp[0] = 0\r\n        for coin in coins:\r\n            for i in range(coin, amount + 1):\r\n                dp[i] = min(dp[i], dp[i - coin] + 1)\r\n        return dp[amount] if dp[amount] < amount + 1 else -1\r\n```\r\nTime: O(n*amount)\r\nSpace: O(amount)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1512891473","body":"```python\r\nclass Solution:\r\n    def change(self, amount: int, coins: List[int]) -> int:\r\n        dp = [0] * (amount + 1)\r\n        dp[0] = 1\r\n        for coin in coins:\r\n            for i in range(1, amount + 1):\r\n                if coin <= i:\r\n                    dp[i] += dp[i - coin]\r\n        return dp[amount]\r\n```\r\nTime: O(n*amount)\r\nSpace: O(amount)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1513803003","body":"```python\r\nclass Solution:\r\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\r\n        heapq.heapify(g)\r\n        heapq.heapify(s)\r\n        result = 0\r\n        while g and s:\r\n            if s[0] >= g[0]:\r\n                heapq.heappop(g)\r\n                result += 1\r\n            heapq.heappop(s)\r\n        return result\r\n```\r\nTime: O(mlogm+nlogn)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516491817","body":"```python\r\nclass Solution:\r\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\r\n        if not intervals:\r\n            return 0\r\n        \r\n        intervals.sort(key=lambda x: x[1])\r\n        right = intervals[0][1]\r\n        result = 1\r\n\r\n        for i in range(1, len(intervals)):\r\n            if intervals[i][0] >= right:\r\n                result += 1\r\n                right = intervals[i][1]\r\n        \r\n        return len(intervals) - result\r\n```\r\nTime: O(nlogn)\r\nSpace: O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517992984","body":"```python\r\nclass Solution:\r\n    def canJump(self, nums: List[int]) -> bool:\r\n        pos = 0\r\n        for index, num in enumerate(nums):\r\n            if pos < index:\r\n                return False\r\n            if index + num > pos:\r\n                pos = index + num\r\n        return True\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518686089","body":"```python\r\nclass Solution:\r\n    def __init__(self):\r\n        self.dp = {}\r\n\r\n    def numTrees(self, n: int) -> int:\r\n        if n in self.dp:\r\n            return self.dp[n]\r\n        if n == 0 or n == 1:\r\n            return 1\r\n        result = 0\r\n        for i in range(1, n + 1):\r\n            result += self.numTrees(i - 1) * self.numTrees(n - i)\r\n        self.dp[n] = result\r\n        return result\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1518999483","body":"```python\r\nclass Solution:\r\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\r\n        heap = [(l.val, index) for index, l in enumerate(lists) if l]\r\n        heapq.heapify(heap)\r\n        head = curr = ListNode(None)\r\n        while heap:\r\n            value, index = heapq.heappop(heap)\r\n            curr.next = ListNode(value)\r\n            curr = curr.next\r\n            node = lists[index].next\r\n            lists[index] = lists[index].next\r\n            if node:\r\n                heapq.heappush(heap, (node.val, index))\r\n        return head.next\r\n```\r\nTime: O(nlogk)\r\nSpace: O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1519138173","body":"```python\r\nclass Solution:\r\n    def beautifulArray(self, n: int) -> List[int]:\r\n        result = [1]\r\n        while len(result) < n:\r\n            result = [2 * i - 1 for i in result] + [2 * i for i in result]\r\n        return [i for i in result if i <= n]\r\n```\r\nTime: O(nlogn)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521729802","body":"```python\r\nclass Solution:\r\n    def singleNumber(self, nums: List[int]) -> List[int]:\r\n        mask = 0\r\n        for n in nums:\r\n            mask ^= n\r\n        diff = mask & (-mask)\r\n        x = 0\r\n        for n in nums:\r\n            if n & diff:\r\n                x ^= n\r\n        return [x, x ^ mask]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1523555313","body":"```python\r\nclass Solution:\r\n    def subsets(self, nums: List[int]) -> List[List[int]]:\r\n        result = []\r\n        for i in range(1 << len(nums)):\r\n            current = []\r\n            for j in range(len(nums)):\r\n                if i >> j & 1:\r\n                    current.append(nums[j])\r\n            result.append(current)\r\n        return result\r\n```\r\nTime: O(n^2)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1525700255","body":"```python\r\nclass Trie:\r\n    def __init__(self):\r\n        self.dict = {}\r\n\r\n    def insert(self, word: str) -> None:\r\n        current = self.dict\r\n        for c in word:\r\n            if c not in current:\r\n                current[c] = {}\r\n            current = current[c]\r\n        current[\"#\"] = True\r\n\r\n    def search(self, word: str) -> bool:\r\n        current = self.dict\r\n        for c in word:\r\n            if c not in current:\r\n                return False\r\n            current = current[c]\r\n        return \"#\" in current\r\n        \r\n\r\n    def startsWith(self, prefix: str) -> bool:\r\n        current = self.dict\r\n        for c in prefix:\r\n            if c not in current:\r\n                return False\r\n            current = current[c]\r\n        return True\r\n```\r\nTime: O(1), O(n)\r\nSpace: O(n*26)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1527492265","body":"```python\r\nclass Node:\r\n    def __init__(self, count=0):\r\n        self.children = collections.defaultdict(Node)\r\n        self.count = count\r\n\r\nclass MapSum:\r\n    def __init__(self):\r\n        self.root = Node()\r\n        self.keys = {}\r\n\r\n    def insert(self, key: str, val: int) -> None:\r\n        delta = val - self.keys.get(key, 0)\r\n        self.keys[key] = val\r\n        current = self.root\r\n        current.count += delta\r\n        for c in key:\r\n            current = current.children[c]\r\n            current.count += delta\r\n\r\n    def sum(self, prefix: str) -> int:\r\n        current = self.root\r\n        for c in prefix:\r\n            if c not in current.children:\r\n                return 0\r\n            current = current.children[c]\r\n        return current.count\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528805014","body":"```python\r\nclass Trie:\r\n    def __init__(self, words):\r\n        self.d = {}\r\n        for word in words:\r\n            current = self.d\r\n            for c in word:\r\n                if c not in t:\r\n                    current[c] = {}\r\n                current = current[c]\r\n            current['end'] = word\r\n    \r\n    def search(self, string):\r\n        current = self.d\r\n        res = []\r\n        for w in string:\r\n            if w not in current:\r\n                break\r\n            current = current[w]\r\n            if 'end' in current:\r\n                res.append(current['end'])\r\n        return res\r\n\r\nclass Solution:\r\n    def multiSearch(self, big: str, smalls: List[str]) -> List[List[int]]:\r\n        trie = Trie(smalls)\r\n        hit = defaultdict(list)\r\n\r\n        for i in range(len(big)):\r\n            matchs = trie.search(big[i:])\r\n            for word in matchs:\r\n                hit[word].append(i)\r\n        \r\n        result = []\r\n        for word in smalls:\r\n            result.append(hit[word])\r\n        return result\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1529026367","body":"```python\r\nclass Solution:\r\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\r\n        visited = defaultdict(int)\r\n        result = 0\r\n\r\n        def dfs(current):\r\n            if not visited[current]:\r\n                visited[current] = 1\r\n            for i in range(len(isConnected)):\r\n                if isConnected[current][i] and not visited[i]:\r\n                    dfs(i)\r\n\r\n        for i in range(len(isConnected)):\r\n            if not visited[i]:\r\n                dfs(i)\r\n                result += 1\r\n        return result\r\n```\r\nTime: O(n^2)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1529749792","body":"```python\r\nclass Solution:\r\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\r\n        initial = set(initial)\r\n        group = set()\r\n        groups = defaultdict(list)\r\n\r\n        def dfs(node):\r\n            group.add(node)\r\n            for next_node in range(len(graph[node])):\r\n                if graph[node][next_node] and next_node not in group:\r\n                    dfs(next_node)\r\n\r\n        for n in sorted(initial):\r\n            dfs(n)\r\n            if group & initial == {n}:\r\n                print(group, initial, n)\r\n                groups[len(group)].append(n)\r\n            group = set()\r\n        \r\n        return groups[max(groups)][0] if groups else min(initial)\r\n```\r\nTime: O(n^2)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1531655519","body":"```python\r\nclass Solution:\r\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\r\n        if len(connections) < n - 1:\r\n            return -1\r\n        graph = defaultdict(list)\r\n        visited = set()\r\n        count = 0\r\n\r\n        for c in connections:\r\n            graph[c[0]].append(c[1])\r\n            graph[c[1]].append(c[0])\r\n\r\n        def dfs(current):\r\n            for next_node in graph[current]:\r\n                if next_node not in visited:\r\n                    visited.add(next_node)\r\n                    dfs(next_node)\r\n        \r\n        for node in range(n):\r\n            if node not in visited:\r\n                visited.add(node)\r\n                dfs(node)\r\n                count += 1\r\n        \r\n        return count - 1\r\n```\r\nTime: O(V+E)\r\nSpace: O(V+E)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1533030601","body":"```python\r\nclass Solution:\r\n    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\r\n        if not root:\r\n            return None\r\n        root.left = self.pruneTree(root.left)\r\n        root.right = self.pruneTree(root.right)\r\n        if not root.left and not root.right and not root.val:\r\n            return None\r\n        return root\r\n```\r\nTime: O(n)\r\nSpace: O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1534368737","body":"```python\r\nclass Solution:\r\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\r\n        candidates.sort()\r\n        result = []\r\n\r\n        def dfs(target, start, path):\r\n            if target == 0:\r\n                result.append(path[:])\r\n                return\r\n            for i in range(start, len(candidates)):\r\n                residue = target - candidates[i]\r\n                if residue < 0:\r\n                    break\r\n                path.append(candidates[i])\r\n                dfs(residue, i, path)\r\n                path.pop()\r\n\r\n        dfs(target, 0, [])\r\n        return result\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1536300266","body":"```python\r\nclass Solution:\r\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\r\n        candidates.sort()\r\n        result = []\r\n\r\n        def dfs(residue, start, path):\r\n            if residue == 0:\r\n                result.append(path[:])\r\n                return\r\n            for i in range(start, len(candidates)):\r\n                if candidates[i] > residue:\r\n                    break\r\n                if i > start and candidates[i - 1] == candidates[i]:\r\n                    continue\r\n                path.append(candidates[i])\r\n                dfs(residue - candidates[i], i + 1, path)\r\n                path.pop()\r\n\r\n        dfs(target, 0, [])\r\n        return result\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1537090909","body":"```python\r\nclass Solution:\r\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\r\n        nums.sort()\r\n        used = [False] * len(nums)\r\n        result = []\r\n\r\n        def dfs(start, permutation, used):\r\n            if start == len(nums):\r\n                result.append(permutation[:])\r\n                return\r\n            for i in range(len(nums)):\r\n                if not used[i]:\r\n                    if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\r\n                        continue\r\n                    used[i] = True\r\n                    permutation.append(nums[i])\r\n                    dfs(start + 1, permutation, used)\r\n                    used[i] = False\r\n                    permutation.pop()\r\n\r\n        dfs(0, [], used)\r\n        return result\r\n```","onTime":true},null,null,null,null,null,null,null,null,null],"lp1506947671":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429552710","body":"\n\n```python\n# 思路:从低位到高位依次相加(数组倒叙遍历,数值除10取余),对数值位数大于数组的长度的部分进行边界处理\n\nfrom typing import List\n\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in num[::-1]:\n            sum_item = i + k % 10\n            k //= 10\n            if sum_item >= 10:\n                k += 1\n                sum_item -= 10\n            res.insert(0, sum_item)\n        while k > 0:\n            res.insert(0, k % 10)\n            k //= 10\n        return res\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print(solution.addToArrayForm([1, 2, 0, 0], 34))\n    \n# 时间复杂度:O(max(n,n-k))\n# 空间复杂度:O(n)\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431458904","body":"### 思路\r\n\r\n先获取c字符在s字符中的标记记录在数组c_indices中\r\n\r\n然后遍历字符s中的每个字符,与c_indics中的值也就是c字符所在的索引逐一比较获取最小值\r\n\r\n\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        c_indices = []\r\n        for index, value in enumerate(s):\r\n            if value == c:\r\n                c_indices.append(index)\r\n        result = [None] * len(s)\r\n        for index, value in enumerate(s):\r\n            if value == c:\r\n                result[index] = 0\r\n                continue\r\n            for c_index in c_indices:\r\n                dist = abs(c_index - index)\r\n                if result[index] and dist >= result[index]:\r\n                    break\r\n                result[index] = dist\r\n\r\n        return result\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度: O(N∗K)，N 是 S 的长度，K 是字符 `C` 在字符串中出现的次数，K <= N。 \r\n\r\n空间复杂度 O(K)，K 为字符 `C` 出现的次数，这是记录字符 `C` 出现下标的辅助数组消耗的空间 \r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433144775","body":"### 思路\n\n通过列表的pop和append分别作为栈的出栈入栈操作,需要注意入栈的最大长度和出站的空临界情况\n\n### 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack: return -1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        end = k\n        if len(self.stack) <= k:\n            end = len(self.stack)\n        for index in range(0, end):\n            self.stack[index] += val\n```\n\n### 复杂度\n\n时间复杂度：push 和 pop 操作时间复杂度为O(1),而 increment 操作的时间复杂度为O(min(k,cnt))\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434788852","body":"### 思路\n\n- 构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\n  -  当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\n  - ​\t当 c 为字母时，在 res 尾部添加 c；\n  - ​\t当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 00：\n    - 记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\n    - 记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\n    - 进入到新 [ 后，res 和 multi 重新记录。\n  - 当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\n    - last_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\n    - cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\n- 返回字符串 res\n\n### 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        res = ''\n        stack = []\n        multi = 0\n        for c in s:\n            if c == \"[\":\n                stack.append((res, multi))\n                res = \"\"\n                multi = 0\n            elif c == \"]\":\n                last_res, cur_multi = stack.pop()\n                res = last_res + cur_multi * res\n            elif c.isnumeric():\n                multi = multi * 10 + int(c)\n            else:\n                res += c\n        return res\n```\n\n### 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435500538","body":"\n\n### 思路\n\n构建两个栈一个作为输入栈,一个作为输出栈,输入栈逐个弹出放到输出栈,再从输出栈逐个弹出元素,则可以负负的正\n\n实现先进先出\n\n\n\n### 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.in_stack = []\n        self.out_stack = []\n\n    def push(self, x: int) -> None:\n        self.in_stack.append(x)\n\n    def pop(self) -> int:\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n        return self.out_stack.pop()\n\n    def peek(self) -> int:\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n        return self.out_stack[-1]\n\n    def empty(self) -> bool:\n        if not self.in_stack and not self.out_stack:\n            return True\n        else:\n            return False\n\n```\n\n\n\n\n\n### 复杂度\n\n时间复杂度:push和empty的时间复杂度O(1),pop和peek时间复杂度为O(n)\n\n空间复杂度:O(n)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436010265","body":"### 思路\n\n对于已经分好块的数组，若块数大于 1，则可以得到以下结论：右边的块的所有数字均大于或等于左边的块的所有数字。考虑这个问题：对于已经分好块的数组，若在其末尾添加一个数字，如何求得新数组的分块方式？\n\n新添加的数字可能会改变原数组的分块方式。如果新添加的数字大于或等于原数组最后一个块的最大值，则这个新添加的数字可以自己形成一个块。如果新添加的数字小于原数组最后一个块的最大值，则它必须融入最后一个块。如果它大于或等于原数组倒数第二个块（如果有）的最大值，那么这个过程可以停止，新数组的分块方式已经求得。否则，它将继续融合原数组倒数第二个块，直到遇到一个块，使得该块的最大值小于或等于这个新添加的数，或者这个数字已经融合了所有块。\n\n上述分析过程中，我们只用到了块的最大值来进行比较，比较过程又是从右到左，符合栈的思想，因此可以用类似单调栈的数据结构来存储块的最大值。\n\n\n\n### 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for a in arr:\n            if not stack or a >= stack[-1]:\n                stack.append(a)\n            else:\n                mx = stack.pop()\n                while stack and stack[-1] > a:\n                    stack.pop()\n                stack.append(mx)\n        return len(stack)\n\n```\n\n\n\n### 复杂度\n\n时间复杂度:O(n),其中 n是输入数组 arr 的长度.需要遍历一遍数组,入栈的操作最多为 n次。\n\n空间复杂度:O(n).栈的长度最多为 n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437176312","body":"### 思路\n\n1.创建快慢指针，遍历链表找到快指针位置（倒数第k+1个节点的）；\n2.同时移动快慢指针直到快指针的next没有数据为止,此时慢指针指向新链表的尾节点(这里还要一个指针来记录快指针的前驱节点，这个要看移动情况来定用不用)\n3.对原链表进行拆分并返回新链表头节点即可\n\n\n\n### 代码\n\n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        # 双指针\n        if head:\n            p1 = head\n            p2 = head\n            count = 1\n            i = 0\n            while i < k:\n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                else:\n                    k = k % count\n                    i = -1\n                    p2 = head\n                i += 1\n\n            while p2.next:\n                p1 = p1.next\n                p2 = p2.next\n\n            if p1.next:\n                tmp = p1.next\n            else:\n                return head\n            p1.next = None\n            p2.next = head\n            return tmp\n\n```\n\n\n\n### 复杂度\n\n- 时间复杂度：节点最多只遍历两遍，时间复杂度为O(n)\n- 空间复杂度：未使用**额外**的空间，空间复杂度O(1)\n\n\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438699150","body":"### 思路\n\n1.创建一个空节点pre,让其next指向A,避免判断边界条件\n\n2.然后相邻的节点之间执行如下逆转步骤,直至整个链表被逆转\n\n```python\nA.next=B.next\nB.next=A\npre.next=B\n```\n\n\n\n### 代码\n\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        pre = ListNode(0)\n        pre.next = head\n        temp = pre\n        while temp.next and temp.next.next:\n            node1 = temp.next\n            node2 = temp.next.next\n\n            node1.next = node2.next\n            temp.next = node2\n            node2.next = node1\n\n            temp = node2\n        return pre.next\n```\n\n\n\n### 复杂度\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n\n\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440268193","body":"### 思路\n\n使用快慢双指针可定位中间元素,具体可参考双指针的讲义.这里我简单描述一下算法流程：\n\n1. 获取当前链表的中点\n2. 以链表中点为根\n3. 中点左边的值都小于它,可以构造左子树\n4. 同理构造右子树\n5. 循环第一步\n\n具体算法：\n\n1. 定义一个快指针每步前进两个节点，一个慢指针每步前进一个节点\n2. 当快指针到达尾部的时候，正好慢指针所到的点为中点\n\n\n\n\n\n### 代码\n\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n\n\n\n### 复杂度\n\n- 时间复杂度：递归树的深度为 logn,每一层的基本操作数为 n,因此总的时间复杂度为O(nlogn)\n- 空间复杂度：空间复杂度为O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441757147","body":"### 思路\n\n- 使用两个指针如指针 a, b 分别指向 A, B 这两条链表的头节点, 两个指针以相同的速度向后移动。\n- 当 a 到达链表 A 的尾部时，将它重定位到链表 B 的头节点；\n- 当 b 到达链表 B 的尾部时，将它重定位到链表 A 的头节点；\n- 若在此过程中 a, b 指针相遇，则相遇节点为两链表相交的起始节点，否则说明两个链表不存在相交点。\n\n\n\n### 代码\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a, b = headA, headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a\n```\n\n\n\n### 复杂度\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443850915","body":"### 思路\n\n- 双指针第一次相遇： 设两指针 fast，slow 指向链表头部 head，fast 每轮走 2步，slow 每轮走 1步；\n\n  第一种结果： fast 指针走过链表末端，说明链表无环，直接返回 null；\n\n  TIPS: 若有环，两指针一定会相遇。因为每走 1 轮，fast 与 slow 的间距 +1，fast 终会追上 slow；\n  第二种结果： 当fast == slow时， 两指针在环中 第一次相遇 。下面分析此时fast 与 slow走过的 步数关系 ：\n\n  设链表共有 a+b 个节点，其中 链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环 有 b 个节点（这里需要注意，a 和 b是未知数，例如图解上链表 a=4 ,b=5）；设两指针分别走了 f，s 步，则有：\n  fast 走的步数是slow步数的 2 倍，即 sf=2s；（解析： fast 每轮走 2 步）\n  fast 比 slow多走了 n 个环的长度，即f=s+nb；（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走 环的长度整数倍 ）；\n  以上两式相减得：f=2nb，s=nb，即fast和slow 指针分别走了2n，n 个 环的周长 （注意： n是未知数，不同链表的情况不同）。\n\n  \n\n### 代码\n\n```python\nclass Solution(object):\n    def detectCycle(self, head):\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n\n```\n\n\n\n### 复杂度\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445242214","body":"### 思路\n\nLRU( Least Recently Used ):最近最少使用,主要是通过哈希表辅以双向链表实现\n\n- 双向链表按照被使用的顺序存储这些键值对,靠近尾部的键值对是最近使用的,而靠近头部的键值对是最久未使用的\n- 哈希表及为普通的哈希映射,通过缓存数据的键映射到期双向链表中的位置\n\n\n\n### 代码\n\n```python\nclass Node:\n    def __init__(self, key, val):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n        self.lookup = {}\n        self.max_len = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.lookup:\n            return -1\n        node = self.lookup[key]\n        self.remove(node)\n        self.add(node)\n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.lookup:\n            self.remove(self.lookup[key])\n        if len(self.lookup) == self.max_len:\n            self.remove(self.head.next)\n        self.add(Node(key, value))\n\n    def remove(self, node):\n        del self.lookup[node.key]\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add(self, node):\n        self.lookup[node.key] = node\n        pre_tail = self.tail.prev\n        node.next = self.tail\n        node.prev = pre_tail\n        self.tail.prev = node\n        pre_tail.next = node\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```\n\n\n\n### 复杂度\n\n时间复杂度:put和get都是O(1)\n\n空间复杂度:O(capacity)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445247674","body":"### 思路\n\nDFS(Depth-First-Search):深度优先算法\n\n- 定义一个函数f(root),给定一个二叉树的节点,返回这个节点为根节点的子树的最大深度\n- 确定解决大问题f(root)的小问题为1+max(f(root.right)+f(root.left))\n- 递归终止条件为递归到叶子节点的时候,返回0即可\n\n\n\n### 代码\n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return 1+(max(self.maxDepth(root.right),self.maxDepth(root.left)))\n```\n\n\n\n### 复杂度\n\n时间复杂度:O(N)\n\n空间复杂度:O(h),其中h为树的深度,最坏的情况h等于N,其中N为节点树,此时树退化到链表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446369449","body":"## 思路\n\n步骤一: 确定isSameTree(p,q)\n\n步骤二:确定大问题和小问题间的关系` isSameTree(p,q)=isSameTree(p.left, q.left) and isSameTree(p.right, q.right)`\n\n步骤三:结束条件` not p and not q` 或者 `not p or not q` 或者`p.val != q.val`\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n\n\n## 复杂度\n\n时间复杂度:O(N)\n\n空间复杂度:O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448254042","body":"## 思路\n\n步骤一: 确定dfs(root, 0)\n\n步骤二:确定大问题和小问题间的关系`dfs(root1.left, cur * 10 + root1.val) + dfs(root1.right, cur * 10 + root1.val)`\n\n步骤三:结束条件` not root1` 或者 `cur * 10 + root1.val` 或者\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(root1, cur):\n            if not root1:\n                return 0\n            if not root1.left and not root1.right:\n                return cur * 10 + root1.val\n            return dfs(root1.left, cur * 10 + root1.val) + dfs(root1.right, cur * 10 + root1.val)\n\n        return dfs(root, 0)\n```\n\n\n\n## 复杂度\n\n时间复杂度:O(N)\n\n空间复杂度:O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450035520","body":"## 思路\n\n- 找到树的最后一行\n- 找到那一行的第一个节点\n\n## 代码\n\n```python\n# DFS\nclass Solution1:\n\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue = collections.deque()\n        queue.append(root)\n        res = root.val\n        while queue:\n            length=len(queue)\n            res = queue[0].val\n            for _ in range(length):\n                cur = queue.popleft()\n                if cur.left:\n                    queue.append(cur.left)\n                if cur.right:\n                    queue.append(cur.right)\n        return res\n\n\n# BFS\nclass Solution2:\n    def __init__(self):\n        self.res = 0\n        self.max_deep = 0\n\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n\n        def dfs(root1: Optional[TreeNode], deep):\n            if not root1:\n                return\n            if deep > self.max_deep:\n                self.res = root1.val\n                self.max_deep = deep\n\n            dfs(root1.left, deep + 1)\n            dfs(root1.right, deep + 1)\n\n        self.res = root.val\n        dfs(root, 0)\n        return self.res\n```\n\n\n\n## 复杂度\n\n时间复杂度:DFS:O(n) BFS:O(n)\n\n空间复杂度:DFS:O(Q)Q为队列长度最坏为n  BFS:O(Q)Q为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451904032","body":"## 思路\n\n- 找到树的最后一行\n- 找到那一行的第一个节点\n\n## 代码\n\n```python\nimport collections\n\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n\n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        q = collections.deque([root])\n        ans = ''\n        while q:\n            cur = q.popleft()\n            if cur:\n                ans += str(cur.val) + ','\n                q.append(cur.left)\n                q.append(cur.right)\n            else:\n                # 除了这里不一样，其他和普通的不记录层的 BFS 没区别\n                ans += 'null,'\n        # 末尾会多一个逗号，我们去掉它。\n        return ans[:-1]\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n\n        :type data: str\n        :rtype: Tr\n        \"\"\"\n        if data == 'null': return None\n        nodes = data.split(',')\n        root = TreeNode(nodes[0])\n        q = collections.deque([root])\n        i = 0\n        while q and i < len(nodes) - 2:\n            cur = q.popleft()\n            lv = nodes[i + 1]\n            rv = nodes[i + 2]\n            i += 2\n            if lv != 'null':\n                l = TreeNode(lv)\n                q.append(l)\n                cur.left = l\n            if rv != 'null':\n                r = TreeNode(rv)\n                q.append(r)\n                cur.right = r\n\n        return root\n\n```\n\n\n\n## 复杂度\n\n时间复杂度:serialize:O(n) deserialize:O(n) n为树的节点数\n\n空间复杂度:serialize:O(Q)deserialize:O(Q) Q为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1452710632","body":"## 思路\n\nx:代表树的x轴值,总的x个数代表树的宽度\n\ny:代表数的y轴值,总的y的个数代表树的高度\n\nv:代表数的值,总的v的个数代表树的节点数\n\n```json\n{\n    x1:{\n        y1:[v1],\n        y2:[v2],\n    }\n\tx2:{\n        y1:[v3],\n        y2:[v4],\n    }\n}\n```\n\n![](https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg)\n\n```json\n{\n    1:{\n    -1:[2],\n     1:[3],\n}\n   2:{\n    -2:[4],\n     0:[5,6],\n\t 2:[7] \t\n} \n}\n```\n\n\n\n## 代码\n\n```python\nclass Solution(object):\n    def verticalTraversal(self, root):\n        seen = collections.defaultdict(\n            lambda: collections.defaultdict(list))\n\n        def dfs(root, x=0, y=0):\n            if not root:\n                return\n            seen[x][y].append(root.val)\n            dfs(root.left, x-1, y+1)\n            dfs(root.right, x+1, y+1)\n\n        dfs(root)\n        ans = []\n        # x 排序、\n        for x in sorted(seen):\n            level = []\n            # y 排序\n            for y in sorted(seen[x]):\n                # 值排序\n                level += sorted(v for v in seen[x][y])\n            ans.append(level)\n\n        return ans\n```\n\n\n\n## 复杂度\n\n时间复杂度: O(NlogN) \n\n空间复杂度:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454343878","body":"## 思路\n\n1. 索整个数组的方式来判断 `target - num` 是否也存在 `nums` \n2. 使用哈希表  将寻找 `target - x` 的时间复杂度降低到从 O(N) 降低到 O(1), 对于每一个 `x`，我们首先查询哈希表中是否存在 `target - x`，然后将 `x` 插入到哈希表中，即可保证不会让 `x` 和自己匹配 \n\n\n\n## 代码\n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hashtable = dict()\n        for i, num in enumerate(nums):\n            if target - num in hashtable:\n                return [hashtable[target - num], i]\n            hashtable[nums[i]] = i\n        return []\n\n```\n\n\n\n## 复杂度\n\n时间复杂度:O(n)\n\n空间复杂度:O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455042973","body":"## 思路\n\n看到 求前 k 个 这样的描述自然会联想到用 堆 来进行排序。\n\n- 用 大顶堆 的话，需要将所有 [数字, 次数] 元组都入堆，再进行 k 次取极值的操作。\n- 用 小顶堆 的话，只需要维持堆的大小一直是 k 即可。\n\n这里我们采用第二种思路。\n\n1. 建立一个 size 为 K 的小顶堆，堆中存的是每个数的频次信息。堆初始化为空。\n2. 对每个频次 C ，与堆顶 T 比较，如果 C > T, C 替换 T，维持小顶堆性质。\n\n## 代码\n```python\nimport heapq\nimport collections\nfrom typing import List\n\nclass Solution:\n\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        occurrences = {}  # {'nums的值':'nums的值出现的次数'}\n        for i in nums:\n            occurrences[i] = occurrences.setdefault(i, 0) + 1\n        occurrences = collections.Counter(nums)\n        heap = [(-frequency, value) for value, frequency in occurrences.items()]\n        heapq.heapify(heap)\n\n        return [heapq.heappop(heap)[1] for i in range(k)]\n```\n\n## 复杂度\n\n- 时间复杂度: O(N * logK), N为数组长度\n- 空间复杂度: O(N)为数组长度，主要为哈希表开销","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456235447","body":"## 思路\n1. [[xi,yi],[xj,yj],[xk,yk]]\n2. (yj-yi)^2+(xj-xi)^2=(yj-yk)^2+(xj-xk)^2\n\n\n## 代码\n```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ans = 0\n        for i in range(n):\n            m = collections.defaultdict(int)\n            for j in range(n):\n                dist = abs(points[i][0] - points[j][0]) ** 2 + abs(points[i][1] - points[j][1]) ** 2\n                m[dist] += 1\n            for count in m.values():\n                ans += count * (count-1)\n        return ans\n```\n\n## 复杂度\n\n- 时间复杂度: O(n^2)\n- 空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1458282847","body":"## 思路\n\n\n\n## 代码\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        # 哈希集合，记录每个字符是否出现过\n        occ = set()\n        n = len(s)\n        # 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动\n        rk, ans = -1, 0\n        for i in range(n):\n            if i != 0:\n                # 左指针向右移动一格，移除一个字符\n                occ.remove(s[i - 1])\n            while rk + 1 < n and s[rk + 1] not in occ:\n                # 不断地移动右指针\n                occ.add(s[rk + 1])\n                rk += 1\n            # 第 i 到 rk 个字符是一个极长的无重复字符子串\n            ans = max(ans, rk - i + 1)\n        return ans\n\n```\n\n## 复杂度\n\n- 时间复杂度: O(N)\n- 空间复杂度: O(∣Σ∣)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460241532","body":"## 思路\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        res = []\n        m, n, ls = len(words), len(words[0]), len(s)\n        for i in range(n):\n            if i + m * n > ls:\n                break\n            differ = Counter()\n            for j in range(m):\n                word = s[i + j * n: i + (j + 1) * n]\n                differ[word] += 1\n            for word in words:\n                differ[word] -= 1\n                if differ[word] == 0:\n                    del differ[word]\n            for start in range(i, ls - m * n + 1, n):\n                if start != i:\n                    word = s[start + (m - 1) * n: start + m * n]\n                    differ[word] += 1\n                    if differ[word] == 0:\n                        del differ[word]\n                    word = s[start - n: start]\n                    differ[word] -= 1\n                    if differ[word] == 0:\n                        del differ[word]\n                if len(differ) == 0:\n                    res.append(start)\n        return res\n```\n\n\n\n## 复杂度\n\n时间复杂度：O(ls×n)，其中ls是输入s 的长度,n是 words 中每个单词的长度.需要做 n 次滑动窗口,每次需要遍历一次 s\n\n空间复杂度：O(m×n)，其中 m 是words 的单词数，n 是words 中每个单词的长度。每次滑动窗口时，需要用一个哈希表保存单词频次\n\n\n\n\n\n\n\n\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462118739","body":"## 思路\n\n\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        x = sum(nums) % p\n        if x == 0:\n            return 0\n        y = 0\n        index = {0: -1}\n        ans = len(nums)\n        for i, v in enumerate(nums):\n            y = (y + v) % p\n            if (y - x) % p in index:\n                ans = min(ans, i - index[(y - x) % p])\n            index[y] = i\n        return ans if ans < len(nums) else -1\n\n```\n\n\n\n## 复杂度\n\n时间复杂度：O(n)，其中 nn 是数组nums 的长度。遍历数组nums 需要 O(n) 的时间。\n\n空间复杂度：O(n)。保存哈希表需要O(n) 的空间。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1464008414","body":"## 思路\n\n\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n```\n\n\n\n## 复杂度\n\n- 时间复杂度: O(n)O(n)\n- 空间复杂度: O(1)O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464921491","body":"```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        n = len(nums)\n        fast = slow = 1\n        while fast < n:\n            if nums[fast] != nums[fast - 1]:\n                nums[slow] = nums[fast]\n                slow += 1\n            fast += 1\n        \n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465207201","body":"## 思路\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums) - 1\n\n        while(l<=r):\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l\n```\n\n\n\n## 复杂度\n\n令 n 为数组长度\n\n 时间复杂度: O(logn)\n\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466066863","body":"\n\n**代码**\n\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        if k == 0: return []\n        res = []\n        for r in range(k - 1, len(nums)):\n            res.append(max(nums[r - k + 1:r + 1]))\n        return res\n```\n\n**复杂度分析**\n\n令 n 为数组长度\n\n- 时间复杂度: O(n * k)\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468240702","body":"**代码**\n\n```python\nclass Solution:\n     def findJudge(self, N, trust):\n        count = [0] * (N + 1)\n        for i, j in trust:\n            count[i] -= 1\n            count[j] += 1\n        for i in range(1, N + 1):\n            if count[i] == N - 1:\n                return i\n        return -1\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469836090","body":"**代码**\n\n```python\nclass Solution:\n    def dfs(self, graph, colors, i, color, N):\n        colors[i] = color\n        for j in range(N):\n            # dislike eachother\n            if graph[i][j] == 1:\n                if colors[j] == color:\n                    return False\n                if colors[j] == 0 and not self.dfs(graph, colors, j, -1 * color, N):\n                    return False\n        return True\n\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = [[0] * N for i in range(N)]\n        colors = [0] * N\n        for a, b in dislikes:\n            graph[a - 1][b - 1] = 1\n            graph[b - 1][a - 1] = 1\n        for i in range(N):\n            if colors[i] == 0 and not self.dfs(graph, colors, i, 1, N):\n                return False\n        return True\n```\n\n**复杂度分析**\n\n V 和 E 分别为图中的点和边的数目。 \n\n- 时间复杂度： O(V+E) \n- 空间复杂度： O(V2) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1472138097","body":"Python3：\n\n```python\nclass Solution:\n    # 拓扑排序\n    def tp_sort(self, items, indegree, neighbors):\n        q = collections.deque([])\n        ans = []\n        for item in items:\n            if not indegree[item]:\n                q.append(item)\n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if not indegree[neighbor]:\n                    q.append(neighbor)\n\n        return ans\n\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for project in range(n):\n            if group[project] == -1:\n                group[project] = max_group_id\n                max_group_id += 1\n\n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n\n        for project in range(n):\n            group_projects[group[project]].append(project)\n\n            for pre in pres[project]:\n                if group[pre] != group[project]:\n                    # 小组关系图\n                    group_indegree[group[project]] += 1\n                    group_neighbors[group[pre]].append(group[project])\n                else:\n                    # 项目关系图\n                    project_indegree[project] += 1\n                    project_neighbors[pre].append(project)\n\n        ans = []\n        # 先对组进行拓扑排序\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\n\n        if len(group_queue) != max_group_id:\n            return []\n\n        for group_id in group_queue:\n            # 对小组中的项目进行拓扑排序\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n\n            if len(project_queue) != len(group_projects[group_id]):\n                return []\n            ans += project_queue\n\n        return ans\n```\n\n**复杂度分析**\n\n令 m 和 n 分别为图的边数和顶点数。\n\n- 时间复杂度：O(m + n)O(m+n)\n- 空间复杂度：O(m + n)O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1474034045","body":"```python\nclass Solution(object):\n    def judgeCircle(self, moves):\n        x = y = 0\n        for move in moves:\n            if move == 'U': y -= 1\n            elif move == 'D': y += 1\n            elif move == 'L': x -= 1\n            elif move == 'R': x += 1\n\n        return x == y == 0\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474627818","body":"```python\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        tasks = [(task[0], i, task[1]) for i, task in enumerate(tasks)]\n        tasks.sort()\n        backlog = []\n        time = 0\n        ans = []\n        pos = 0\n        for _ in tasks:\n            if not backlog:\n                time = max(time, tasks[pos][0])\n            while pos < len(tasks) and tasks[pos][0] <= time:\n                heapq.heappush(backlog, (tasks[pos][2], tasks[pos][1]))\n                pos += 1\n            d, j = heapq.heappop(backlog)\n            time += d\n            ans.append(j)\n        return ans\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475066618","body":"\n\n```python\nclass Solution:\n    def numberOfRounds(self, startTime: str, finishTime: str) -> int:\n        sh, sm = map(int, startTime.split(\":\"))\n        eh, em = map(int, finishTime.split(\":\"))\n        d = 0\n        if sh * 60 + sm > eh * 60 + em: d += 1\n        if 0 < sm <= 15:\n            sm = 15\n        elif 15 < sm <= 30:\n            sm = 30\n        elif 30 < sm <= 45:\n            sm = 45\n        elif 45 < sm <= 60:\n            sm = 0\n            sh += 1\n        if 0 <= em < 15:\n            em = 0\n        elif 15 <= em < 30:\n            em = 15\n        elif 30 <= em < 45:\n            em = 30\n        elif 45 <= em < 60:\n            em = 45\n        st = sh * 60 + sm\n        et = eh * 60 + em\n        if d == 1: et += 24 * 60\n        return max(0, (et - st)) // 15\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475442134","body":"Python3 Code:\n\n```python\nclass Solution:\n    def minCharacters(self, A: str, B: str) -> int:\n        ca = collections.Counter(A)\n        cb = collections.Counter(B)\n        # ca 中严格大于 cb 的最小操作数\n        def greater_cost(ca, cb):\n            ans = float(\"inf\")\n            # 枚举 ca 中的最小值\n            for i in range(1, 26):\n                count = 0\n                # 将 ca 中小于最小值的都进行一次操作\n                for j in range(i):\n                    count += ca[chr(97 + j)]\n                # 将 cb 中大于等于最小值的都进行一次操作（注意这里的等号）\n                for j in range(i, 26):\n                    count += cb[chr(97 + j)]\n                ans = min(ans, count)\n            return ans\n\n        def equal_cost(ca, cb):\n            ans = float(\"inf\")\n            for i in range(26):\n                ans = min(ans, len(A) + len(B) - ca[chr(97 + i)] - cb[chr(97 + i)])\n            return ans\n\n        return min(greater_cost(ca, cb), greater_cost(cb, ca), equal_cost(ca, cb))\n```\n\n**复杂度分析**\n\n令 m, n 分别为数组 A 和数组 B 的长度。\n\n- 时间复杂度：O(m + n)\n- 空间复杂度：O(26)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477093859","body":"\n\n```python\nclass Solution:\n    def max_heapify(self, heap, root, heap_len):\n        p = root\n        while p * 2 + 1 < heap_len:\n            l, r = p * 2 + 1, p * 2 + 2\n            if heap_len <= r or heap[r] < heap[l]:\n                nex = l\n            else:\n                nex = r\n            if heap[p] < heap[nex]:\n                heap[p], heap[nex] = heap[nex], heap[p]\n                p = nex\n            else:\n                break\n        \n    def build_heap(self, heap):\n        for i in range(len(heap) - 1, -1, -1):\n            self.max_heapify(heap, i, len(heap))\n\n    def heap_sort(self, nums):\n        self.build_heap(nums)\n        for i in range(len(nums) - 1, -1, -1):\n            nums[i], nums[0] = nums[0], nums[i]\n            self.max_heapify(nums, 0, i)\n            \n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.heap_sort(nums)\n        return nums\n\n```\n\n时间复杂度:O(nlogn)\n\n空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479811165","body":"代码\n\n```python\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        ans, l, r = 0, 0, x\n        while l <= r:\n            mid = (l + r) // 2\n            if mid ** 2 > x:\n                r = mid - 1\n            if mid ** 2 <= x:\n                ans = mid\n                l = mid + 1\n        return int(ans)\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(log_x)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1481353455","body":"Python3:\n\n```python\nclass Solution:\n    def firstBadVersion(self, n):\n        l, r = 1, n\n        while l <= r:\n            mid = (l + r) // 2\n            if isBadVersion(mid):\n                # 收缩\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(logN)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482989667","body":"\n\n```python\nclass Solution:\n    def reversePairs(self, nums) -> int:\n        self.cnt = 0\n        def merge(nums, start, mid, end, temp):\n            i, j = start, mid + 1\n            while i <= mid and j <= end:\n                if nums[i] <=  nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            # 防住\n            # 这里代码开始\n            ti, tj = start, mid + 1\n            while ti <= mid and tj <= end:\n                if nums[ti] <=  2 * nums[tj]:\n                    ti += 1\n                else:\n                    self.cnt += mid - ti + 1\n                    tj += 1\n            # 这里代码结束\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= end:\n                temp.append(nums[j])\n                j += 1\n            for i in range(len(temp)):\n                nums[start + i] = temp[i]\n            temp.clear()\n\n\n        def mergeSort(nums, start, end, temp):\n            if start >= end: return\n            mid = (start + end) >> 1\n            mergeSort(nums, start, mid, temp)\n            mergeSort(nums, mid + 1, end, temp)\n            merge(nums, start, mid,  end, temp)\n        mergeSort(nums, 0, len(nums) - 1, [])\n        return self.cnt\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483743716","body":"\n\n```python\nclass Solution:\n    def solve(self, nums):\n        nums.sort()\n        N = len(nums)\n        if N <= 3:\n            return 0\n        LIGHTS = 3\n        # 这里使用的是直径，因此最终返回需要除以 2\n        def possible(diameter):\n            start = nums[0]\n            end = start + diameter\n            for i in range(LIGHTS):\n                idx = bisect_right(nums, end)\n                if idx >= N:\n                    return True\n                start = nums[idx]\n                end = start + diameter\n            return False\n\n        l, r = 0, nums[-1] - nums[0]\n        while l <= r:\n            mid = (l + r) // 2\n            if possible(mid):\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l / 2\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：possible 复杂度为 logn，主函数复杂度为 log(MAX-MIN)。其中 MAX 数组为最大值，MIN 为数组最小值。除此之外，还进行了排序， 因此时间复杂度大约是 O(nlogn + logn * log(MAX-MIN))\n- 空间复杂度：取决于排序的空间消耗","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1484109724","body":"\n\n```python\nclass Solution:\n    def solve(self, A, k):\n        A.sort()\n        def count_not_greater(diff):\n            i = ans = 0\n            for j in range(1, len(A)):\n                while A[j] - A[i] > diff:\n                    i += 1\n                ans += j - i\n            return ans\n        l, r = 0, A[-1] - A[0]\n        k += 1 # zero based -> one based\n        while l <= r:\n            mid = (l + r) // 2\n            if count_not_greater(mid) >= k:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：由于进行了排序， 因此时间复杂度大约是 O(nlogn)\n- 空间复杂度：取决于排序的空间消耗","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484254912","body":"\n\n```python\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        l, r = 0, max([max(vec) for vec in grid])\n        seen = set()\n\n        def test(mid, x, y):\n            if x > len(grid) - 1 or x < 0 or y > len(grid[0]) - 1 or y < 0:\n                return False\n            if grid[x][y] > mid:\n                return False\n            if (x, y) == (len(grid) - 1, len(grid[0]) - 1):\n                return True\n            if (x, y) in seen:\n                return False\n            seen.add((x, y))\n            ans = test(mid, x + 1, y) or test(mid, x - 1,\n                                              y) or test(mid, x, y + 1) or test(mid, x, y - 1)\n            return ans\n        while l <= r:\n            mid = (l + r) // 2\n            if test(mid, 0, 0):\n                r = mid - 1\n            else:\n                l = mid + 1\n            seen = set()\n        return l\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(NlogM)，其中 M 为 grid 中的最大值， N 为 grid 的总大小。\n- 空间复杂度：O(N)，其中 N 为 grid 的总大小。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486913408","body":"\n\n```python\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        res = 0\n        temp = 0\n        vowels = set(['a','e','i','o','u'])\n        for i in range(k):\n            res += s[i] in vowels\n        if res==k: return k\n        temp = res\n        for i in range(k,len(s)):\n            temp += (s[i] in vowels) - (s[i-k] in vowels)\n            res = max(temp,res)\n            if res ==k: return k\n        return res\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)，n 为字串长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488742437","body":"\n\n```python\nclass Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        dp = [0] * (K + W)\n        for i in range(K, K + W):\n            if i <= N:\n                dp[i] = 1\n\n        for i in range(K - 1, -1, -1):\n            dp[i] = sum(dp[i + j] for j in range(1, W + 1)) / W\n        return dp[0]\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(KW)\n- 空间复杂度：O(K+W)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1490510065","body":"\n\n```python\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        target = collections.Counter(p)\n        ans = []\n        for i in range(len(s)):\n            if i >= len(p):\n                target[s[i - len(p)]] += 1\n                if target[s[i - len(p)]] == 0:\n                    del target[s[i - len(p)]]\n            target[s[i]] -= 1\n            if target[s[i]] == 0:\n                del target[s[i]]\n            if len(target) == 0:\n                ans.append(i - len(p) + 1)\n        return ans\n```\n**复杂度分析**\n\n令 s 的长度为 n。\n\n- 时间复杂度：O(n)\n- 空间复杂度：虽然我们使用了数组（或者哈希表）存储计数信息，但是大小不会超过 26，因此空间复杂度为 O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491750742","body":"\n```python\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        l, counter, N, ct = 0, Counter(), len(s), Counter(t)\n        k = 0\n        ret, ans = inf, \"\"\n        for r in range(N):\n            counter[s[r]] += 1\n            if s[r] in t and counter[s[r]] == ct[s[r]]:\n                k += 1\n            while k == len(ct):\n                if r - l + 1 < ret:\n                    ans = s[l:r+1]\n                ret = min(r - l + 1, ret)\n                counter[s[l]] -= 1\n                if s[l] in t and counter[s[l]] == ct[s[l]]-1:\n                    k -= 1\n                l += 1\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N + K)，N 为 S 串长度，K 为 T 串长度\n- 空间复杂度：O(S)，其中 S 为 T 字符集元素个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1492977233","body":"```python\nclass Solution:\n    def solve(self, A, target):\n        if not A and not target: return 0\n        target = sum(A) - target\n        ans = len(A) + 1\n        i = t = 0\n\n        for j in range(len(A)):\n            t += A[j]\n            while i <= j and t > target:\n                t -= A[i]\n                i += 1\n            if t == target: ans = min(ans, len(A) - (j - i + 1))\n        return -1 if ans == len(A) + 1 else ans\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n\n- 空间复杂度：1\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493367704","body":"\n\n```python\nclass Solution:\n    def readBinaryWatch(self, num: int) -> List[str]:\n        return [str(a) + \":\" + str(b).rjust(2, '0') for a in range(12) for b in range(60) if (bin(a)+bin(b)).count('1') == num]\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494085359","body":"\n\n```python\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        def backtrack(row: int) -> int:\n            if row == n:\n                return 1\n            else:\n                count = 0\n                for i in range(n):\n                    if i in columns or row - i in diagonal1 or row + i in diagonal2:\n                        continue\n                    columns.add(i)\n                    diagonal1.add(row - i)\n                    diagonal2.add(row + i)\n                    count += backtrack(row + 1)\n                    columns.remove(i)\n                    diagonal1.remove(row - i)\n                    diagonal2.remove(row + i)\n                return count\n                    \n        columns = set()\n        diagonal1 = set()\n        diagonal2 = set()\n        return backtrack(0)\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：由于我们需要枚举所有全排列情况，因此时间复杂度为 O(n!)\n- 空间复杂度：递归调用栈的开销是 n，因此空间复杂度为 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1496226107","body":"```python\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        if m == 0: return 0\n        n = len(grid[0])\n        ans = 0\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n: return 0\n            if grid[i][j] == 0: return 0\n            grid[i][j] = 0\n            top = dfs(i + 1, j)\n            bottom = dfs(i - 1, j)\n            left = dfs(i, j - 1)\n            right = dfs(i, j + 1)\n            return 1 + sum([top, bottom, left, right])\n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, dfs(i, j))\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(m*n)\n- 空间复杂度：O(m*n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1496853163","body":"```Python\nclass Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        steps = -1\n        queue = collections.deque([(i, j) for i in range(n) for j in range(n) if grid[i][j] == 1])\n        if len(queue) == 0 or len(queue) == n ** 2: return steps\n        while len(queue) > 0:\n            for _ in range(len(queue)):\n                x, y = queue.popleft(0)\n                for xi, yj in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n                    if xi >= 0 and xi < n and yj >= 0 and yj < n and grid[xi][yj] == 0:\n                        queue.append((xi, yj))\n                        grid[xi][yj] = -1\n            steps += 1\n\n        return steps\n```\n\n**复杂度分析**\n\n- 时间复杂度：由于 grid 中的每个点最多被处理一次，因此时间复杂度为 O(N^2)\n- 空间复杂度：由于我们使用了队列，而队列的长度最多是 n^2，这种情况其实就是全为 1 的 grid，因此空间复杂度为 O(N^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1499729302","body":"\n\n```python\n def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):\n        boxes = set(initialBoxes)\n        q = [i for i in boxes if status[i]]\n        for i in q:\n            for j in containedBoxes[i]:\n                boxes.add(j)\n                if status[j]:\n                    q.append(j)\n            for j in keys[i]:\n                if status[j] == 0 and j in boxes:\n                    q.append(j)\n                status[j] = 1\n        return sum(candies[i] for i in q)\n```\n\n令 n 为盒子数，k 为钥匙数，由于每个盒子最多会被访问一次，因此队列长度以及循环次数都不超过 n。\n\n由于钥匙和盒子最多被访问一次，因此时间不超过 n + k。\n\n**复杂度分析**\n\n- 时间复杂度：O(n + k)\n- 空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1499730737","body":"​\t\n\n```python\n# class Tree:\n#     def __init__(self, val, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def solve(self, root):\n        q = collections.deque([(root, 0)])\n        d = {}\n        while q:\n            cur, pos = q.popleft()\n            if pos not in d:\n                d[pos] = cur.val\n            if cur.left:\n                q.append((cur.left, pos - 1))\n            if cur.right:\n                q.append((cur.right, pos + 1))\n        return list(map(lambda x:x[1], sorted(d.items(),key=lambda x: x[0])))\n\n\n```\n\n令 n 节点数\n\n**复杂度分析**\n\n- 时间复杂度：我们使用了排序，并且所有节点最多只处理一次，因此时间复杂度为 O(nlogn)\n- 空间复杂度：哈希表最多容纳 n 个元素，因此空间复杂度为 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500912983","body":"```python\nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        dp = [0] * (len(cost)+1)\n        dp[0], dp[1] = cost[0], cost[1]\n        for i in range(2, len(cost)+1):\n            dp[i] = min(dp[i-1], dp[i-2]) + (cost[i] if i != len(cost) else 0)\n        return dp[-1]\n```\n\n**杂度分析**\n\n设：N阶台阶\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501057521","body":"\n\n```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n\n        length = len(nums)\n        if length == 1:\n            return nums[0]\n        else:\n            prev = nums[0]\n            cur = max(prev, nums[1])\n            for i in range(2, length):\n                cur, prev = max(prev + nums[i], cur), cur\n            return cur\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501235526","body":"\n\n```python\nclass Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        # dp[i][0] ->  LIS\n        # dp[i][1] -> NumberOfLIS\n        dp = [[1, 1] for i in range(n)]\n        ans = [1, 1]\n        longest = 1\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[j] > nums[i]:\n                    if dp[i][0] + 1 > dp[j][0]:\n                        dp[j][0] = dp[i][0] + 1\n                        # 下面这行代码容易忘记，导致出错\n                        dp[j][1] = dp[i][1]\n                        longest = max(longest, dp[j][0])\n                    elif dp[i][0] + 1 == dp[j][0]:\n                        dp[j][1] += dp[i][1]\n        return sum(dp[i][1] for i in range(n) if dp[i][0] == longest)\n```\n\n**杂度分析**\n\n令 N 为数组长度。\n\n- 时间复杂度：O(N^2)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1503569073","body":"\n\n```python\nclass Solution:\n    def longestCommonSubsequence(self, A: str, B: str) -> int:\n        m, n = len(A), len(B)\n        ans = 0\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if A[i - 1] == B[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    ans = max(ans, dp[i][j])\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(m * n)，其中 m 和 n 分别为 A 和 B 的 长度。\n- 空间复杂度：O(m * n)，其中 m 和 n 分别为 A 和 B 的 长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1504254942","body":"\n\n```python\nclass Solution:\n\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [1] * n\n        for _ in range(1, m):\n            for j in range(1, n):\n                dp[j] += dp[j - 1]\n        return dp[n - 1]\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(M * N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506100425","body":"```python\nclass Solution:\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n        dp = [[[0] * n for _ in range(n)] for _ in range(k + 1)]\n        for step in range(k + 1):\n            for i in range(n):\n                for j in range(n):\n                    if step == 0:\n                        dp[step][i][j] = 1\n                    else:\n                        for di, dj in ((-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2)):\n                            ni, nj = i + di, j + dj\n                            if 0 <= ni < n and 0 <= nj < n:\n                                dp[step][i][j] += dp[step - 1][ni][nj] / 8\n        return dp[k][row][column]\n\n\n```\n\n时间复杂度:O(k×n*2)\n\n空间复杂度:O(k×n*2)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1508679214","body":"\n\n```python\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        if desiredTotal <= maxChoosableInteger:\n            return True\n        if sum(range(maxChoosableInteger + 1)) < desiredTotal:\n            return False\n\n        @lru_cache(None)\n        def dp(picked, acc):\n            if acc >= desiredTotal:\n                return False\n            if picked == (1 << (maxChoosableInteger + 1)) - 1:\n                return False\n            for n in range(1, maxChoosableInteger + 1):\n                if picked & 1 << n == 0:\n                    if not dp(picked | 1 << n, acc + n):\n                        return True\n            return False\n\n        return dp(0, 0)\n```\n\n## ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509443695","body":"\n\n```python\nclass Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        target = sum(nums) // 2\n        if target + target != sum(nums):\n            return False\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        for i in range(1, len(nums) + 1):\n            for j in range(target, 0, -1):\n                if dp[j] or (j - nums[i - 1] > -1 and dp[j - nums[i - 1]]):\n                    dp[j] = True\n        return dp[-1]\n```\n\n## ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510412997","body":"```python\nclass Solution:\n    def solve(self, nums, target):\n        if (sum(nums) + target) % 2 == 1: return 0\n        t = (sum(nums) + target) // 2\n        dp = [[0] * (len(nums) + 1) for _ in range(t + 1)]\n        dp[0][0] = 1\n        for i in range(t + 1):\n            for j in range(1, len(nums) + 1):\n                dp[i][j] = dp[i][j-1]\n                if i - nums[j-1] >= 0: dp[i][j] += dp[i - nums[j-1]][j-1]\n        return dp[-1][-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1510535449","body":"```python\nclass Solution(object):\n    def coinChange(self, coins, amount):\n        dp = [amount + 1] * (amount+1)\n        dp[0] = 0\n        for i in range(1, amount+1):\n            for coin in coins:\n                if i >= coin:\n                    dp[i] = min(dp[i], dp[i-coin]+1)\n        return -1 if dp[amount] == amount + 1 else dp[amount]\n```\n\n**复杂度分析**\n\n令 N 为物品个数即硬币种类， amount 为总金额也即背包大小。\n\n- 时间复杂度：O(N * amount)\n- 空间复杂度：O(amount)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1513069860","body":"Python Code:\n```python\nclass Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n\n        for j in range(len(coins)):\n            for i in range(1, amount + 1):\n                if i >= coins[j]:\n                    dp[i] += dp[i - coins[j]]\n\n        return dp[-1]\n```\n复杂度分析\n\n令n是coins的数量, m是amount\n\n时间复杂度: O(m*n)\n\n空间复杂度: O(m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1513930524","body":"```python\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        s.sort(reverse=True)\n        g.sort(reverse=True)\n        gi, si = 0, 0\n        count = 0\n        while gi < len(g) and si < len(s):\n            if s[si] >= g[gi]:\n                count += 1\n                si += 1\n            gi += 1\n        return count\n```\n\n**复杂度分析**\n\n令 n 为数组长度\n\n- 时间复杂度：由于使用了排序，因此时间复杂度大约为 O(nlogn)\n- 空间复杂度：取决于具体的排序方法，大概是 O(1) 到 O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516380573","body":"```python\nclass Solution:\n    def lengthOfLIS(self, A: List[int]) -> int:\n        d = []\n        for s, e in A:\n            i = bisect.bisect_left(d, e)\n            if i < len(d):\n                d[i] = e\n            elif not d or d[-1] <= s:\n                d.append(e)\n        return len(d)\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        n = len(intervals)\n        if n == 0: return 0\n        ans = 1\n        intervals.sort(key=lambda a: a[0])\n        return n - self.lengthOfLIS(intervals)\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517070329","body":"\n\n```python\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        \"\"\"思路同上\"\"\"\n        _max = 0\n        _len = len(nums)\n        for i in range(_len-1):\n            if _max < i:\n                return False\n            _max = max(_max, nums[i] + i)\n            # 下面这个判断可有可无，但提交的时候数据会好看点\n            if _max >= _len - 1:\n                return True\n        return _max >= _len - 1\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1519093390","body":"Python3 Code:\n\n```python\nclass Solution:\n    visited = dict()\n\n    def numTrees(self, n: int) -> int:\n        if n in self.visited:\n            return self.visited.get(n)\n        if n <= 1:\n            return 1\n        res = 0\n        for i in range(1, n + 1):\n            res += self.numTrees(i - 1) * self.numTrees(n - i)\n        self.visited[n] = res\n        return res\n```\n\n**复杂度分析**\n\n- 时间复杂度：一层循环是 N，另外递归深度是 N，因此总的时间复杂度是 O(N^2)\n- 空间复杂度：递归的栈深度和 visited 的大小都是 N，因此总的空间复杂度为 O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519093874","body":"\n\n```python\nclass Solution:\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n        n = len(lists)\n\n        # basic cases\n        if lenth == 0: return None\n        if lenth == 1: return lists[0]\n        if lenth == 2: return self.mergeTwoLists(lists[0], lists[1])\n\n        # divide and conqure if not basic cases\n        mid = n // 2\n        return self.mergeTwoLists(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:n]))\n\n\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        res = ListNode(0)\n        c1, c2, c3 = l1, l2, res\n        while c1 or c2:\n            if c1 and c2:\n                if c1.val < c2.val:\n                    c3.next = ListNode(c1.val)\n                    c1 = c1.next\n                else:\n                    c3.next = ListNode(c2.val)\n                    c2 = c2.next\n                c3 = c3.next\n            elif c1:\n                c3.next = c1\n                break\n            else:\n                c3.next = c2\n                break\n\n        return res.next\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(kn*logk)\n- 空间复杂度：O(logk)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1520986328","body":"\n\n```python\nclass Solution:\n    def beautifulArray(self, N: int) -> List[int]:\n        @lru_cache(None)\n        def dp(n):\n            if n == 1:\n                return [1]\n            ans = []\n            # [1,n] 中奇数比偶数多1或一样\n            for a in dp(n - n // 2):\n                ans += [a * 2 - 1]\n            for b in dp(n // 2):\n                ans += [b * 2]\n            return ans\n\n        return dp(N)\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n + logn)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1520988263","body":"\n\n```python\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        xor = a = b = 0\n        right_bit = 1\n        length = len(nums)\n        for i in nums:\n            xor ^= i\n        while right_bit & xor == 0:\n            right_bit <<= 1\n        for i in nums:\n            if right_bit & i:\n                a ^= i\n            else:\n                b ^= i\n        return [a, b]\n```\n\n### 复杂度分析\n\n设：N个数\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1523606917","body":"\n\n```python\nclass Solution:\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res, end = [], 1 << len(nums)\n        for sign in range(end):\n            subset = []\n            for i in range(len(nums)):\n                if ((1 << i) & sign) != 0:\n                    subset.append(nums[i])\n            res.append(subset)\n        return res\n```\n\n**复杂度分析**\n\n令 N 为数组长度\n\n- 时间复杂度：O(N*2^N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1525671369","body":" ```python\n  class TrieNode:\n      def __init__(self):\n          self.count = 0\n          self.preCount = 0\n          self.children = {}\n  \n  class Trie:\n  \n      def __init__(self):\n          \"\"\"\n          Initialize your data structure here.\n          \"\"\"\n          self.root = TrieNode()\n  \n      def insert(self, word):\n          \"\"\"\n          Inserts a word into the trie.\n          :type word: str\n          :rtype: void\n          \"\"\"\n          node = self.root\n          for ch in word:\n              if ch not in node.children:\n                  node.children[ch] = TrieNode()\n              node = node.children[ch]\n              node.preCount += 1\n          node.count += 1\n  \n      def search(self, word):\n          \"\"\"\n          Returns if the word is in the trie.\n          :type word: str\n          :rtype: bool\n          \"\"\"\n          node = self.root\n          for ch in word:\n              if ch not in node.children:\n                  return False\n              node = node.children[ch]\n          return node.count > 0\n  \n      def startsWith(self, prefix):\n          \"\"\"\n          Returns if there is any word in the trie that starts with the given prefix.\n          :type prefix: str\n          :rtype: bool\n          \"\"\"\n          node = self.root\n          for ch in prefix:\n              if ch not in node.children:\n                  return False\n              node = node.children[ch]\n          return node.preCount > 0\n  ```\n\n **复杂度分析**\n\n令 n 为待操作的字符串的长度。\n\n- 时间复杂度：创建 Trie:O(1), 其余操作为 O(n)。\n- 空间复杂度：最坏情况下没有任何前缀，此时空间复杂度为所有操作的单词所占的空间，具体来说就是 O(字符集大小*单词总字符数)O(字符集大小∗单词总字符数)。不过随着前缀相同的单词增多，效率会变好。（也就是说如果字符串中的相同前缀比较多，则性能优化明显）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1528352187","body":"\n\n```python\nclass MapSum:\n\n    def __init__(self):\n        self.m = {}\n    def insert(self, key, val):\n        self.m[key] = val\n\n    def sum(self, prefix):\n        count = 0\n        for key in self.m:\n            if key.startswith(prefix):\n                count += self.m[key]\n        return count\n```\n\n**复杂度分析**\n\n- 空间复杂度：O(N)O(N)，其中 N 是不重复的 key 的个数\n\n  ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528371365","body":"```python\nclass Trie:\n    def __init__(self, words):\n        self.d = {}\n        for word in words:\n            t = self.d\n            for w in word:\n                if w not in t:\n                    t[w] = {}\n                t = t[w]\n            t['end'] = word\n    \n    def search(self, s):\n        t = self.d\n        res = []\n        for w in s:\n            if w not in t:\n                break\n            t = t[w]\n            if 'end' in t:\n                res.append(t['end'])\n        return res\n\nclass Solution:\n    def multiSearch(self, big: str, smalls: List[str]) -> List[List[int]]:\n        trie = Trie(smalls)\n        hit = collections.defaultdict(list)\n\n        for i in range(len(big)):\n            matchs = trie.search(big[i:])\n            for word in matchs:\n                hit[word].append(i)\n        \n        res = []\n        for word in smalls:\n            res.append(hit[word])\n        return res\n\n```\n\n**复杂度分析**\n\n时间复杂度：O(n * m)，n = len(big)， m = len(smalls)\n空间复杂度：O(m * k)，k = max(len(smalls[i])) 即k是smalls中最长字符串的长度\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1528979138","body":"\n\n```python\nclass UF:\n    def __init__(self, n) -> None:\n        self.parent = {i: i for i in range(n)}\n        self.size = n\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def connect(self, i, j):\n        root_i, root_j = self.find(i), self.find(j)\n        if root_i != root_j:\n            self.size -= 1\n            self.parent[root_i] = root_j\n\n\nclass Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        n = len(isConnected)\n        uf = UF(n)\n        for i in range(n):\n            for j in range(n):\n\n                if isConnected[i][j]:\n                    uf.connect(i, j)\n        return uf.size\n```\n\n**复杂度分析**\n\n令 n 为矩阵 M 的大小。\n\n- 时间复杂度：由于仅使用了一种优化（路径压缩）,因此时间复杂度为 O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1530738103","body":"\n\n```python\nclass Solution:\n    def minMalwareSpread(self, graph, initial):\n        def dfs(i):\n            nodes.add(i)\n            for j in range(len(graph[i])):\n                if graph[i][j] and j not in nodes:\n                    dfs(j)\n        rank, initial = collections.defaultdict(list), set(initial)\n        for node in sorted(initial):\n            nodes = set()\n            dfs(node)\n            if nodes & initial == {node}:\n                rank[len(nodes)].append(node)\n        return rank[max(rank)][0] if rank else min(initial)\n```\n\n**复杂度分析**\n\n令 d 为矩阵 M 的大小，e 为 initial 长度。\n\n- 时间复杂度：由于使用了排序，因此排序需要时间为 eloge。而 dfs 部分，由于每个点呗访问最多一次，因此时间为 O(d^2)\n- 空间复杂度：我们使用了 colors 和 counts，因此空间复杂度为 O(d)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1530738987","body":"\n\n```python\nclass Solution:\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        root = [i for i in range(n)]\n\n        def find(p):\n            while p != root[p]:\n                root[p] = root[root[p]]\n                p = root[p]\n\n            return p\n\n        def union(p, q):\n            root[find(p)] = find(q)\n\n        have = 0\n        for connec in connections:\n            a, b = connec\n            if find(a) != find(b):\n                union(a, b)\n            else:\n                have += 1\n\n        diff_root = set()\n        for i in range(n):\n            diff_root.add(find(i))\n\n        return len(diff_root) - 1 if have >= len(diff_root) - 1 else -1\n```\n\n**复杂度分析**\n\n令 v 图的点的个数，也就是计算机的个数。\n\n- 时间复杂度：由于仅仅使用了路径压缩，因此合并与查找时间复杂度为 O(logx)和 O(logy)，x 和 y 分别为合并与查找的次数。\n- 空间复杂度：O(v)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1533042765","body":"\n\n```python\nclass Solution(object):\n    def pruneTree(self, root):\n        def containsOne(node):\n            if not node: return False\n            left = containsOne(node.left)\n            right = containsOne(node.right)\n            if not left: node.left = None\n            if not right: node.right = None\n            return node.val == 1 or left or right\n\n        return root if containsOne(root) else None\n```\n\n**复杂度分析**\n\n- 空间复杂度：没有额外空间使用，因此空间复杂度就是递归栈的最大深度O(H)，其中 H 是树高。\n\n  \n\n- 时间复杂度：最坏情况就是所有节点都剪掉了，因此时间复杂度是O(N)，其中 N 是树节点的个数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1534143854","body":"\n\n```python\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        def backtrack(ans,tempList, candidates, remain, start):\n            if remain < 0: return\n            elif remain == 0: return ans.append(tempList.copy()) # 将部分解空间合并到总体的解空间\n            # 枚举所有以 i 为开始的部分解空间\n            for i in range(start, len(candidates)):\n                tempList.append(candidates[i])\n                backtrack(ans, tempList, candidates, remain - candidates[i], i)#  数字可以重复使用\n                tempList.pop()\n\n        ans = [];\n        backtrack(ans, [], candidates, target, 0);\n        return ans;\n```\n\n\n\n**复杂度分析**\n\n- 时间复杂度：该题不是很好分析，我个人分析是最坏情况，也就是没有任何剪枝时O(N^{target/ min}),其中 N 时候选数组的长度，min 时数组元素最小值，target/min 也就是递归栈的最大深度。\n- 空间复杂度：递归调用栈的长度不大于target/mintarget/min，同时用于记录路径信息的 list 长度也不大于 target/mintarget/min，因此空间复杂度为 O(target/min)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1535629693","body":"\n\n```python\nclass Solution:\n    def combinationSum2(self, candidates, target):\n        lenCan = len(candidates)\n        if lenCan == 0:\n            return []\n        candidates.sort()\n        path = []\n        res = []\n        self.backtrack(candidates, target, lenCan, 0, 0, path, res)\n        return res\n\n    def backtrack(self, curCandidates, target, lenCan, curSum, indBegin, path, res):\n            # 终止条件\n            if curSum == target:\n                res.append(path.copy())\n            for index in range(indBegin, lenCan):\n                nextSum = curSum + curCandidates[index]\n                # 减枝操作\n                if nextSum > target:\n                    break\n                # 通过减枝避免重复解的出现\n                if index > indBegin and curCandidates[index-1] == curCandidates[index]:\n                    continue\n                path.append(curCandidates[index])\n                # 由于元素只能用一次，所以indBegin = index+1\n                self.backtrack(curCandidates, target, lenCan, nextSum, index+1, path, res)\n                path.pop()\n```\n\n\n\n**复杂度分析**\n\n- 时间复杂度：在最坏的情况下，数组中的每个数都不相同，数组中所有数的和不超过 target，那么每个元素有选和不选两种可能，一共就有 2^n种选择，又因为我们每一个选择，**最多**需要 O(n) 的时间 push 到结果中。因此一个粗略的时间复杂度上界为 O(N*2^N)，其中 N 是数组长度。更加严格的复杂度意义不大，不再分析。\n\n- 空间复杂度：递归调用栈的长度不大于target/mintarget/min，同时用于记录路径信息的 list 长度也不大于 target/mintarget/min，因此空间复杂度为 O(target/min)\n\n  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1537165576","body":"\n\n```python\nclass Solution:\n    def backtrack(numbers, pre):\n        nonlocal res\n        if len(numbers) <= 1:\n            res.append(pre + numbers)\n            return\n        for key, value in enumerate(numbers):\n            if value not in numbers[:key]:\n                backtrack(numbers[:key] + numbers[key + 1:], pre+[value])\n\n    res = []\n    if not len(nums): return []\n    backtrack(nums, [])\n    return res\n```\n\n**复杂度分析**\n\n- 时间复杂度：由于由 visit 数组的控制使得每递归一次深度-1，因此递归的时间复杂度是N*(N - 1) * ... * 1N∗(N−1)∗...∗1也就是O(N! * op(res))O(N!∗op(res))，其中 N 是数组长度，op 操作即是昨天说的 res.add 算子的时间复杂度。\n\n- 空间复杂度：O(N * N!)O(N∗N!)，考虑数组 N 个不重复元素，每一个排列占O(N)O(N)，共有 N!个排列。\n\n  ","onTime":true},null,null,null,null,null,null,null,null,null],"texamc2":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429605508","body":"class Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = 0\r\n        for j, n  in enumerate(num) :\r\n            i = 10 * i + n\r\n        res = i + k\r\n        l = []\r\n        for s in str(res):\r\n            l.append(int(s))\r\n        return l","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431330007","body":"``` \r\nfunc shortestToChar(s string, c byte) []int {\r\n    res := make([]int, len(s))\r\n    for i := 0; i < len(s); i++ {\r\n    l, r := i, i\r\n    for ; l >= 0 && s[i] != c; l = l - 1;{\r\n    }\r\n    for ; r < len(s) && s[i] != c; r = r+1; {\r\n    }\r\n    if l < 0 {\r\n        res[i] = r - i;\r\n     } else if r > len(s) {\r\n        res[i] = i - l;\r\n     } else {\r\n         res[i] = min(i-l, r-i)\r\n     }\r\n     }\r\n     return res\r\n  }\r\n  func min(a, b int) int {\r\n      if a > b {\r\n          return b\r\n         }\r\n       return a\r\n   }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433125628","body":"```\r\ntype CustomStack struct {\r\n\tstack   []int\r\n\tmaxSize int\r\n\tmap_1   map[int]int\r\n}\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n\treturn CustomStack{\r\n\t\tstack:   make([]int, 0),\r\n\t\tmaxSize: maxSize,\r\n\t\tmap_1:   make(map[int]int),\r\n\t}\r\n}\r\n\r\nfunc (this *CustomStack) Push(x int) {\r\n\tif len(this.stack) == this.maxSize {\r\n\t\treturn\r\n\t}\r\n\tthis.stack = append(this.stack, x)\r\n}\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n\tif len(this.stack) == 0 {\r\n\t\treturn -1\r\n\t}\r\n\tv := this.stack[len(this.stack)-1]\r\n\tif inc, has := this.map_1[len(this.stack)]; has {\r\n\t\tv += inc\r\n\t\tdelete(this.map_1, len(this.stack))\r\n\t\tthis.map[len(this.stack)-1]+=inc\r\n\t}\r\n\tthis.stack = this.stack[:len(this.stack)-1]\r\n\treturn v\r\n}\r\n\r\nfunc (this *CustomStack) Increment(k int, val int) {\r\n\tif k > len(this.stack) {\r\n\t\tk = len(this.stack)\r\n\t}\r\n\tthis.map_1[k] += val\r\n\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434611223","body":"```\r\nfunc decodeString(s string) string {\r\n\tstk := []string{}\r\n\tptr:=0\r\n\tfor ptr<len(s){\r\n\t\tcur:=s[ptr]\r\n\t\tif cur>='0' && cur <='9'{\r\n\t\t\tdigits:=getDigits(s,&ptr)\r\n\t\t\tstk = append(stk, digits)\r\n\t\t} else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <= 'Z') || cur=='[' {\r\n\t\t\tstk=append(stk,string(cur))\r\n\t\t\tptr++\r\n\t\t}else{\r\n\t\t\tptr++\r\n            sub:=[]string{}\r\n\t\t\tfor stk[len(stk)-1]!=\"[\"{\r\n\t\t\t\tsub=append(sub,stk[len(stk)-1])\r\n\t\t\t\tstk = stk[:len(stk)-1]\r\n\t\t\t}\r\n\t\t\tfor i:=0;i<len(sub)/2;i++{\r\n\t\t\t\tsub[i],sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i]\r\n\t\t\t}\r\n\t\t\tstk = stk[:len(stk)-1]\r\n\t\t\trepTime,_:=strconv.Atoi(stk[len(stk)-1])\r\n\t\t\tstk = stk[:len(stk)-1]\r\n\t\t\tt:= strings.Repeat(getString(sub), repTime)\r\n\t\t\tstk =append(stk,t)\r\n\t\t}\r\n\r\n\r\n\t\t}\r\n\t\treturn getString(stk)\r\n\t}\r\n\r\n\r\nfunc getDigits(s string, ptr *int) string{\r\n\tret := \"\"\r\n\tfor ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++{\r\n\t\tret += string(s[*ptr])\r\n\t}\r\n\treturn ret\r\n}\r\nfunc getString(v []string)string{\r\n\tret :=\"\"\r\n\tfor _,s :=range v{ //for循环只读value\r\n\t\tret+=s\r\n\t}\r\n\treturn ret\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435676069","body":"```\r\ntype MyQueue struct {\r\n    inStack, outStack []int\r\n}\r\n\r\nfunc Constructor() MyQueue {\r\n    return MyQueue{}\r\n}\r\n\r\nfunc (q *MyQueue) Push(x int) {\r\n    q.inStack = append(q.inStack, x)\r\n}\r\n\r\nfunc (q *MyQueue) in2out() {\r\n    for len(q.inStack) > 0 {\r\n        q.outStack = append(q.outStack, q.inStack[len(q.inStack)-1])\r\n        q.inStack = q.inStack[:len(q.inStack)-1]\r\n    }\r\n}\r\n\r\nfunc (q *MyQueue) Pop() int {\r\n    if len(q.outStack) == 0 {\r\n        q.in2out()\r\n    }\r\n    x := q.outStack[len(q.outStack)-1]\r\n    q.outStack = q.outStack[:len(q.outStack)-1]\r\n    return x\r\n}\r\n\r\nfunc (q *MyQueue) Peek() int {\r\n    if len(q.outStack) == 0 {\r\n        q.in2out()\r\n    }\r\n    return q.outStack[len(q.outStack)-1]\r\n}\r\n\r\nfunc (q *MyQueue) Empty() bool {\r\n    return len(q.inStack) == 0 && len(q.outStack) == 0\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436009700","body":"```\r\nfunc maxChunksToSorted(arr []int) (ans int) {\r\n    cnt := map[int]int{}\r\n    b := append([]int{}, arr...)\r\n    sort.Ints(b)\r\n    for i, x := range arr {\r\n        cnt[x]++\r\n        if cnt[x] == 0 {\r\n            delete(cnt, x)\r\n        }\r\n        y := b[i]\r\n        cnt[y]--\r\n        if cnt[y] == 0 {\r\n            delete(cnt, y)\r\n        }\r\n        if len(cnt) == 0 {\r\n            ans++\r\n        }\r\n    }\r\n    return\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436998707","body":"```\r\n// 旋转链表函数\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n    // 如果链表为空或只有一个结点或k为0，直接返回head\r\n    if head == nil || head.Next == nil || k == 0 {\r\n        return head\r\n    }\r\n    // 定义变量n表示链表长度，tail表示尾结点\r\n    n := 1\r\n    tail := head\r\n    // 遍历链表，更新n和tail\r\n    for tail.Next != nil {\r\n        n++\r\n        tail = tail.Next\r\n    }\r\n    // 计算k对n取模，得到实际需要移动的步数m\r\n    m := k % n\r\n    // 如果m为0，说明不需要旋转，直接返回head\r\n    if m == 0 {\r\n        return head\r\n    }\r\n    // 定义变量cur表示当前结点，初始化为head\r\n    cur := head\r\n    // 从head开始向后走n-m-1步，找到新的尾结点newTail和新的头结点newHead \r\n    for i := 0; i < n - m - 1; i++ {\r\n        cur = cur.Next \r\n\t}\r\n\tnewTail := cur \r\n\tnewHead := cur.Next \r\n\t// 将newTail的next指针置空，将tail的next指针指向head，完成旋转 \r\n\tnewTail.Next = nil \r\n\ttail.Next = head \r\n\t// 返回newHead作为结果 \r\n\treturn newHead \r\n}\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438489135","body":"```\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n    if head == nil || head.Next == nil {\r\n        return head\r\n    }\r\n    newHead := head.Next\r\n    head.Next = swapPairs(newHead.Next)\r\n    newHead.Next = head\r\n    return newHead\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440264256","body":"```\r\n\r\nfunc sortedListToBST(head *ListNode) *TreeNode {\r\n    return buildTree(head, nil)\r\n}\r\n\r\nfunc getMedian(left, right *ListNode) *ListNode {\r\n    fast, slow := left, left\r\n    for fast != right && fast.Next != right {\r\n        fast = fast.Next.Next\r\n        slow = slow.Next\r\n    }\r\n    return slow\r\n}\r\n\r\nfunc buildTree(left, right *ListNode) *TreeNode{\r\n    if left == right {\r\n        return nil\r\n    }\r\n    mid := getMedian(left, right)\r\n    root := &TreeNode{mid.Val, nil, nil}\r\n    root.Left = buildTree(left, mid)\r\n    root.Right = buildTree(mid.Next, right)\r\n    return root\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441779823","body":"```\r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n    if headA == nil || headB == nil {\r\n        return nil\r\n    }\r\n    pa, pb := headA, headB\r\n    for pa != pb {\r\n        if pa == nil {\r\n            pa = headB\r\n        } else {\r\n            pa = pa.Next\r\n        }\r\n        if pb == nil {\r\n            pb = headA\r\n        } else {\r\n            pb = pb.Next\r\n        }\r\n    }\r\n    return pa\r\n}\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445138439","body":"```\r\n\r\ntype entry struct { key, value int }\r\ntype LRUCache struct {\r\n    cap   int\r\n    cache map[int]*list.Element\r\n    lst   *list.List\r\n}\r\n\r\nfunc Constructor(capacity int) LRUCache {\r\n    return LRUCache{capacity, map[int]*list.Element{}, list.New()}\r\n}\r\n\r\nfunc (c *LRUCache) Get(key int) int {\r\n    e := c.cache[key]\r\n    if e == nil { return -1 }\r\n    c.lst.MoveToFront(e) // 刷新缓存使用时间\r\n    return e.Value.(entry).value\r\n}\r\n\r\nfunc (c *LRUCache) Put(key, value int) {\r\n    if e := c.cache[key]; e != nil {\r\n        e.Value = entry{key, value}\r\n        c.lst.MoveToFront(e) // 刷新缓存使用时间\r\n        return\r\n    }\r\n    c.cache[key] = c.lst.PushFront(entry{key, value})\r\n    if len(c.cache) > c.cap {\r\n        delete(c.cache, c.lst.Remove(c.lst.Back()).(entry).key)\r\n    }\r\n}\r\n\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450074358","body":"\r\nfunc findBottomLeftValue(root *TreeNode) (curVal int) {\r\n    curHeight := 0\r\n    var dfs func(*TreeNode, int)\r\n    dfs = func(node *TreeNode, height int) {\r\n        if node == nil {\r\n            return\r\n        }\r\n        height++\r\n        dfs(node.Left, height)\r\n        dfs(node.Right, height)\r\n        if height > curHeight {\r\n            curHeight = height\r\n            curVal = node.Val\r\n        }\r\n    }\r\n    dfs(root, 0)\r\n    return\r\n}\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455122322","body":"```\r\nfunc topKFrequent(nums []int, k int) []int {\r\n    occurrences := map[int]int{}\r\n    for _, num := range nums {\r\n        occurrences[num]++\r\n    }\r\n    h := &IHeap{}\r\n    heap.Init(h)\r\n    for key, value := range occurrences {\r\n        heap.Push(h, [2]int{key, value})\r\n        if h.Len() > k {\r\n            heap.Pop(h)\r\n        }\r\n    }\r\n    ret := make([]int, k)\r\n    for i := 0; i < k; i++ {\r\n        ret[k - i - 1] = heap.Pop(h).([2]int)[0]\r\n    }\r\n    return ret\r\n}\r\n\r\ntype IHeap [][2]int\r\n\r\nfunc (h IHeap) Len() int           { return len(h) }\r\nfunc (h IHeap) Less(i, j int) bool { return h[i][1] < h[j][1] }\r\nfunc (h IHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\r\n\r\nfunc (h *IHeap) Push(x interface{}) {\r\n    *h = append(*h, x.([2]int))\r\n}\r\n\r\nfunc (h *IHeap) Pop() interface{} {\r\n    old := *h\r\n    n := len(old)\r\n    x := old[n-1]\r\n    *h = old[0 : n-1]\r\n    return x\r\n} \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455965174","body":"```\r\nfunc numberOfBoomerangs(points [][]int) (ans int) {\r\n    for _, p := range points {\r\n        cnt := map[int]int{}\r\n        for _, q := range points {\r\n            dis := (p[0]-q[0])*(p[0]-q[0]) + (p[1]-q[1])*(p[1]-q[1])\r\n            cnt[dis]++\r\n        }\r\n        for _, m := range cnt {\r\n            ans += m * (m - 1)\r\n        }\r\n    }\r\n    return\r\n}\r\n\r\n\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463761770","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * type ListNode struct {\r\n *     Val int\r\n *     Next *ListNode\r\n * }\r\n */\r\nfunc middleNode(head *ListNode) *ListNode {\r\n    slow,fast := head, head \r\n    for fast != nil && fast.Next != nil {\r\n        fast = fast.Next.Next;\r\n        slow = slow.Next\r\n    }\r\n    return slow\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480711346","body":"```\r\nfunc firstBadVersion(n int) int {\r\n    return sort.Search(n, func(version int) bool { return isBadVersion(version) })\r\n}\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1498444004","body":"```go\r\n\r\ntype Point struct {\r\n    X int\r\n    Y int\r\n}\r\n\r\nfunc maxDistance(grid [][]int) int {\r\n    var queue []*Point\r\n    for i:=0; i < len(grid); i++ {\r\n        for j:=0; j < len(grid[0]); j++ {\r\n            if grid[i][j] == 1 {\r\n                queue = append(queue, &Point{i, j})\r\n            }\r\n        }\r\n    }\r\n    if len(queue) == 0 || len(queue) == len(grid)*len(grid[0]) {\r\n        return -1\r\n    }\r\n\r\n    ans := 0\r\n    d := [4][2]int{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}\r\n    for len(queue) > 0 {\r\n        ans++\r\n        tmpQueu := queue\r\n        queue = nil\r\n        for len(tmpQueu) > 0 {\r\n            p := tmpQueu[0]\r\n            tmpQueu = tmpQueu[1:]\r\n            for i:=0; i < 4; i++ {\r\n                x := p.X + d[i][0]\r\n                y := p.Y + d[i][1]\r\n                if x < 0 || x >= len(grid) || y < 0 || y >= len(grid[0]) || grid[x][y] != 0 {\r\n                    continue\r\n                }\r\n                queue = append(queue, &Point{x, y})\r\n                grid[x][y] = 2 \r\n            }\r\n        }\r\n    }\r\n\r\n    return ans-1\r\n}\r\n```","onTime":false},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1503195655","body":"```go\r\nfunc longestCommonSubsequence(s, t string) int {\r\n    m := len(t)\r\n    f := make([]int, m+1)\r\n    for _, x := range s {\r\n        pre := 0 // f[0]\r\n        for j, y := range t {\r\n            if x == y {\r\n                f[j+1], pre = pre+1, f[j+1]\r\n            } else {\r\n                pre = f[j+1]\r\n                f[j+1] = max(f[j+1], f[j])\r\n            }\r\n        }\r\n    }\r\n    return f[m]\r\n}\r\n\r\nfunc max(a, b int) int { if a < b { return b }; return a }\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joemonkeylee":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429643042","body":"### 思路\n\n- k值转为 int数组 \n- 两数组高位向左相加 注意处理进位 \n- 若索引0为0 数组长度整体右移一位 \n\n 常规想法 不用复杂类型类型 要牺牲时间\n\n### 代码\n\n\n```c#\n\n    public List<int> Main(int[] num, int k)\n    {\n        int kCopy;\n\n        //1.获取k位数 \n        int kLength = 1;\n        kCopy = k;\n        while (kCopy / 10 > 0)\n        {\n            kLength++;\n            kCopy = kCopy / 10;\n        }\n\n        //2.将k转成数组\n        int[] num2 = new int[kLength];\n        int currentIndex = 0;\n        kCopy = k;\n        while (currentIndex < kLength)\n        {\n            num2[kLength - currentIndex - 1] = kCopy % 10;\n            kCopy = (kCopy - kCopy % 10) / 10;\n            currentIndex++;\n        }\n\n        //3.开辟一个数组 长度是两数组长度较大值+1 右对齐求和\n        int maxLength = Math.Max(num.Length, num2.Length);\n        int[] res = new int[maxLength + 1];\n        int carry = 0;\n        int a;\n        int b;\n        for (int index = 0; index < maxLength; index++)\n        {\n            if (num.Length - index > 0)\n            {\n                a = num[num.Length - index - 1];\n            }\n            else\n            {\n                a = 0;\n            }\n\n            if (num2.Length - index > 0)\n            {\n                b = num2[num2.Length - index - 1];\n            }\n            else\n            {\n                b = 0;\n            }\n\n            if (a + b + carry >= 10)\n            {\n                res[maxLength - index] = a + b + carry - 10;\n                carry = 1;\n            }\n            else\n            {\n                res[maxLength - index] = a + b + carry;\n                carry = 0;\n            }\n        }\n\n        if (carry == 1)\n        {\n            res[0] = carry;\n        }\n\n        //4.如果最低位是0 数组长度-1右移\n        int[] result = new int[maxLength];\n        if (res[0] == 0)\n        {\n            for (int i = 0; i < result.Count(); i++)\n            {\n                result[i] = res[i + 1];\n            }\n            return result;\n        }\n        else\n        {\n            return res;\n        }\n    }\n```\n\n**复杂度分析**\n- 时间复杂度：O(max(n,logk))\n- 空间复杂度：O(1)\n- 不太确定对不对","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431214887","body":"### 思路\n\n- 先找char的位置\n- 第二遍算较小长度\n\n### 代码\n\n\n```c#\n\n    public int[] ShortestToChar(string s, char c)\n    {\n        //记录c的位置\n        List<int> targetArray = new List<int>();\n\n        var charArray = s.ToCharArray();\n        for (int i = 0; i < charArray.Length; i++)\n        {\n            if (charArray[i].Equals(c))\n            {\n                targetArray.Add(i);\n            }\n        }\n\n        var res = new int[charArray.Length];\n        int targetArrayIndex = 0;\n        for (int i = 0; i < charArray.Length; i++)\n        {\n            if (targetArrayIndex < targetArray.Count() && i.Equals(targetArray[targetArrayIndex]))\n            {\n                res[i] = 0;\n                targetArrayIndex++;\n            }\n            else\n            {\n                if (i < targetArray[0])\n                {\n                    res[i] = Math.Abs(i - targetArray[targetArrayIndex]);\n                }\n                else if (i > targetArray[targetArray.Count() - 1])\n                {\n                    res[i] = Math.Abs(i - targetArray[targetArrayIndex - 1]);\n                }\n                else\n                {\n                    res[i] = Math.Min(Math.Abs(i - targetArray[targetArrayIndex]), Math.Abs(targetArray[targetArrayIndex - 1] - i));\n                }\n            }\n        }\n        return res;\n    }\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432943455","body":"### 思路\n\nc#中使用 int[]或者List<int>来模拟应该结果是差不多的。\n不能使用Stack 因为stack用index进行索引赋值\n\n### 代码\n\n```c#\n\npublic class CustomStack\n{\n    int[] array;\n    int index = -1;\n    public CustomStack(int maxSize)\n    {\n        array = new int[maxSize];\n    }\n\n    public void Push(int x)\n    {\n        if (index < array.Length - 1)\n        {\n            array[++index] = x;\n        }\n    }\n\n    public int Pop()\n    {\n        return index < 0 ? -1 : array[index--];\n    }\n\n    public void Increment(int k, int val)\n    {\n        for (int i = 0; i < (k > array.Length ? array.Length : k); i++)\n        {\n            array[i] += val;\n        }\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：Increment是O(n)，其他O(1)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434771304","body":"### 思路\n\n没想出来 看了别人的题解\n\n### 代码\n\n```c#\n    public string DecodeString(string s) {\n        Stack<int> countStack = new Stack<int>();\n        Stack<StringBuilder> charStack = new Stack<StringBuilder>();\n        StringBuilder result = new StringBuilder();\n        int count = 0;\n        foreach(char c in s)\n        {\n            if(char.IsDigit(c))\n            {\n                count = count * 10 + c - '0';\n            }\n            else if(char.IsLetter(c))\n            {\n                result.Append(c);\n            }\n            else if(c == '[')\n            {\n                countStack.Push(count);\n                charStack.Push(result);\n                result = new StringBuilder();\n                count = 0;\n            }\n            else if(c == ']')\n            {\n                var chars = charStack.Pop();\n                var repeat = countStack.Pop();\n                for(int i=0;i<repeat;i++)\n                {\n                    chars.Append(result);\n                }\n                result = chars;\n            }\n        }\n        return result.ToString();\n    }   \n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\u0000","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435672258","body":"### 思路\r\n\r\n    in and out stack\r\n\r\n### 代码\r\n\r\n```c#\r\n  public class MyQueue {\r\n    private Stack inStack = new Stack();\r\n    private Stack outStack = new Stack();\r\n    public MyQueue()\r\n    {\r\n\r\n    }\r\n\r\n    public void Push(int x)\r\n    {\r\n        this.inStack.Push(x);\r\n    }\r\n\r\n    public int Pop()\r\n    {\r\n        this.outStack.Clear();\r\n        while (this.inStack.Count>0&&this.inStack.Peek()!=null)\r\n        {\r\n            this.outStack.Push(this.inStack.Pop());\r\n        }\r\n\r\n        int res = Convert.ToInt32(this.outStack.Pop());\r\n\r\n        while (this.outStack.Count>0&&this.outStack.Peek()!=null)\r\n        {\r\n            this.inStack.Push(this.outStack.Pop());\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    public int Peek()\r\n    {\r\n        this.outStack.Clear();\r\n        while (this.inStack.Count > 0 && this.inStack.Peek() != null)\r\n        {\r\n            this.outStack.Push(this.inStack.Pop());\r\n        }\r\n\r\n        int res = Convert.ToInt32(this.outStack.Peek());\r\n\r\n        while (this.outStack.Count > 0 && this.outStack.Peek() != null)\r\n        {\r\n            this.inStack.Push(this.outStack.Pop());\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    public bool Empty()\r\n    {\r\n        return this.inStack.Count==0;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436004786","body":"### 思路\n\n开始没看懂这个题  看懂之后没太做出来。。看了优秀的题解 mark hard 需要再看\n\n### 代码\n\n```c#\n  \n        Stack<int> stack = new Stack<int>();\n        foreach (int num in arr)\n        {\n            if (stack.Count>0 && num < stack.Peek())\n            {\n                int head = stack.Pop();\n                while (stack.Count > 0 && num < stack.Peek()) stack.Pop();\n                stack.Push(head);\n            }\n            else stack.Push(num);\n        }\n        return stack.Count();\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\u0000","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437155843","body":"### 思路\n1、判空直接返回\n2、算总数 算实际需要移动低次数\n3、如果没移动 直接返回\n4、如果移动 将链表转为环 循环赋值 index从1开始少循环一次 多操作一次再循环外给返回赋值\n5、断开环 返回结果\n\n\n### 代码\n\n```c#\n\n     public ListNode RotateRight(ListNode head, int k)\n        {\n            if (head == null)\n            {\n                return head;\n            }\n\n            int n = 1;\n            ListNode end = head;\n            while (end.next != null)\n            {\n                end = end.next;\n                n++;\n            }\n            k %= n;\n            if (k == 0)\n            {\n                return head;\n            }\n\n            end.next = head;//链表变成环\n\n            int newTailIndex = n - k;\n            ListNode ans = head;\n            //少循环一次后面多走一次赋值\n            for (int i = 1; i < newTailIndex; i++)\n            {\n                ans = ans.next;\n            }\n            ListNode newHead = ans.next;\n            ans.next = null;//还原回链表\n            return newHead;\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438706411","body":"### 思路\n\n不能开辟辅助空间 会超时。艹了 递归没写出来。\n\n### 代码\n\n```c#\n  \n   public ListNode SwapPairs(ListNode head)\n    {\n        ListNode pre = new ListNode(0);\n        pre.next = head;\n        ListNode temp = pre;\n        while (temp.next != null && temp.next.next != null)\n        {\n            ListNode start = temp.next;\n            ListNode end = temp.next.next;\n            temp.next = end;\n            start.next = end.next;\n            end.next = start;\n            temp = start;\n        }\n        return pre.next;\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440281976","body":"### 思路\n\n先看110 平衡二叉树 然后看108数组平衡二叉树  最后来看这个题 链表平衡二叉树 【redo】\n\n### 代码\n\n```c#\n\n    public TreeNode SortedListToBST(ListNode head) {\n        return CreateBST(head, null);\n    }\n\n    public TreeNode CreateBST(ListNode start, ListNode end) {\n        if (start == end) {\n            return null;\n        }\n        ListNode slow = start, fast = start.next;\n        while (fast != end && fast.next != end) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return new TreeNode(slow.val, CreateBST(start, slow), CreateBST(slow.next, end));\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1442000564","body":"### 思路\n\n读题困难  看题解顿悟\n\npA:4->1->8->4->null->5->6->1->8->4->null\npB:5->6->1->8->4->null->4->1->8->4->null\n\n### 代码\n\n```c#\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n```\n\n**复杂度分析**\n- 时间复杂度：O(m+n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443833578","body":"### 思路\n\n用开辟空间的写出来了 快慢指针 步长1 2 不等 这个方式没做过 没写出来 记录一种好理解的\n\n### 代码\n\n```c#\n  \n    public ListNode DetectCycle(ListNode head) {\n        if (head == null || head.next == null) return null;\n        ListNode fast = head;\n        ListNode slow = head;\n        ListNode temp = head;\n\n        while (fast != null)\n        {\n            slow = slow.next;\n            if (fast.next == null) return null;//快指针当前节点和next节点都不为null，才可以走两步\n            fast = fast.next.next;\n            if (slow == fast)//有环\n            {\n                while (temp != slow)//找入环节点\n                {\n                    temp = temp.next;\n                    slow = slow.next;\n                }\n                return temp;   \n            }\n        }\n        return null;\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\u0000","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445119551","body":"### 思路\n\n需要一个hash表 和双向链表\n\n### 代码\n\n```c#\n\n        public class LRUCache\n        {\n            Dictionary<int, int> dict;\n            LinkedList<int> nums;\n            int capacity;\n\n            public LRUCache(int capacity)\n            {\n                this.capacity = capacity;\n                dict = new Dictionary<int, int>();\n                nums = new LinkedList<int>();\n            }\n\n            public int Get(int key)\n            {\n                if (dict.ContainsKey(key))\n                {\n                    nums.Remove(key);\n                    nums.AddLast(key);\n                    return dict[key];\n                }\n                return -1;\n            }\n\n            public void Put(int key, int value)\n            {\n                if (dict.ContainsKey(key))\n                {\n                    nums.Remove(key);\n                    nums.AddLast(key);\n                    dict[key] = value;\n                }\n                else\n                {\n                    if (nums.Count == capacity)\n                    {\n                        dict.Remove(nums.First.Value);\n                        nums.RemoveFirst();\n                        nums.AddLast(key);\n                        dict.Add(key, value);\n                    }\n                    else\n                    {\n                        nums.AddLast(key);\n                        dict.Add(key, value);\n                    }\n                }\n            }\n        }\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445368625","body":"### 思路\n\n没有节点是0 向上有深度等于max(left,right)+1\n\n### 代码\n\n```c#\n  \n      public int MaxDepth(TreeNode root)\n        {\n            if (root == null)\n            {\n                return 0;\n            }\n            else\n            {\n                int leftDepth = MaxDepth(root.left);\n                int rightDepth = MaxDepth(root.right);\n                return Math.Max(leftDepth, rightDepth) + 1;\n            }\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n) 节点个数\n- 空间复杂度：O(height) 栈要递归的深度等于树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446381536","body":"### 思路\n\n官方：\n两个二叉树相同，当且仅当两个二叉树的结构完全相同，且所有对应节点的值相同。因此，可以通过搜索的方式判断两个二叉树是否相同。\n如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。\n如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。\n\n\n### 代码\n\n```c#\n    public bool IsSameTree(TreeNode p, TreeNode q)\n    {\n        if (p == null || q == null) return p == q;\n        if (p.val != q.val) return false;\n        return IsSameTree(p.left, q.left) && IsSameTree(p.right, q.right);\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(m,n) m 和 n 分别是两个二叉树的节点数。\n- 空间复杂度：O(m,n) 。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448340282","body":"### 思路\r\n\r\n从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。如果当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历。\r\n\r\n### 代码\r\n\r\n```c#\r\n  \r\n        public int SumNumbers(Models.TreeNode root)\r\n        {\r\n\r\n            return dfs(root, 0);\r\n        }\r\n\r\n        public int dfs(Models.TreeNode root, int prevSum)\r\n        {\r\n            if (root == null)\r\n            {\r\n                return 0;\r\n            }\r\n            int sum = prevSum * 10 + root.val;\r\n            if (root.left == null && root.right == null)\r\n            {\r\n                return sum;\r\n            }\r\n            else\r\n            {\r\n                return dfs(root.left, sum) + dfs(root.right, sum);\r\n            }\r\n        }\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450313561","body":"### 思路\n//先左再右\n//如果进来高度比原来高度高 一定是最左边先进来  那么记录最新高度 val赋新值\n\n### 代码\n\n```c#\n        int val = 0;\n        int height = 0;\n\n        public int FindBottomLeftValue(Models.TreeNode root)\n        {\n            DFS(root, 0);\n            return val;\n        }\n\n        public void DFS(Models.TreeNode root, int height)\n        {\n            if (root == null)\n            {\n                return;\n            }\n            height++;\n            DFS(root.left, height);\n            DFS(root.right, height);\n            if (height > this.height)\n            {\n                this.height = height;\n                val = root.val;\n            }\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1452078199","body":"### 思路\n\nbfs 应该不是最优解 c#中的linklist 可以RemoveFirst\n\n### 代码\n\n```c#\n  \n    public string serialize(TreeNode root)\n    {\n        return serialize_bfs(root, \"\");\n    }\n\n    public string serialize_bfs(TreeNode root, string str)\n    {\n        if (root == null)\n        {\n            str += \"None,\";\n        }\n        else\n        {\n            str += root.val.ToString() + \",\";\n            str = serialize_bfs(root.left, str);\n            str = serialize_bfs(root.right, str);\n        }\n        return str;\n    }\n\n    public TreeNode deserialize(string data)\n    {\n        string[] dataArray = data.Split(\",\");\n        LinkedList<string> dataList = new LinkedList<string>(dataArray.ToList());\n        return deserialize_bfs(dataList);\n    }\n\n\n    public TreeNode deserialize_bfs(LinkedList<string> dataList)\n    {\n        if (dataList.First.Value.Equals(\"None\"))\n        {\n            dataList.RemoveFirst();\n            return null;\n        }\n\n        TreeNode root = new TreeNode(int.Parse(dataList.First.Value));\n        dataList.RemoveFirst();\n        root.left = deserialize_bfs(dataList);\n        root.right = deserialize_bfs(dataList);\n\n        return root;\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453660088","body":"### 思路\n\n没做出来 mark\n\n### 代码\n\n```c#\n\n    public IList<IList<int>> VerticalTraversal(TreeNode root)\n            {\n                List<Tuple<int, int, int>> nodes = new List<Tuple<int, int, int>>();\n                DFS(root, 0, 0, nodes);\n                nodes.Sort((a, b) =>\n                {\n                    if (a.Item1 != b.Item1)\n                    {\n                        return a.Item1 - b.Item1;\n                    }\n                    else if (a.Item2 != b.Item2)\n                    {\n                        return a.Item2 - b.Item2;\n                    }\n                    else\n                    {\n                        return a.Item3 - b.Item3;\n                    }\n                });\n                IList<IList<int>> ans = new List<IList<int>>();\n                int size = 0;\n                int lastcol = int.MinValue;\n                foreach (Tuple<int, int, int> tuple in nodes)\n                {\n                    int col = tuple.Item1, row = tuple.Item2, value = tuple.Item3;\n                    if (col != lastcol)\n                    {\n                        lastcol = col;\n                        ans.Add(new List<int>());\n                        size++;\n                    }\n                    ans[size - 1].Add(value);\n                }\n                return ans;\n            }\n\n            public void DFS(TreeNode node, int row, int col, List<Tuple<int, int, int>> nodes)\n            {\n                if (node == null)\n                {\n                    return;\n                }\n                nodes.Add(new Tuple<int, int, int>(col, row, node.val));\n                DFS(node.left, row + 1, col - 1, nodes);\n                DFS(node.right, row + 1, col + 1, nodes);\n            }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454753995","body":"### 思路\n\ndict存num[i] index\n\n### 代码\n\n```c#\n\n     public int[] TwoSum(int[] nums, int target)\n        {\n            Dictionary<int, int> dict = new Dictionary<int, int>();\n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (dict.ContainsKey(target - nums[i]))\n                {\n                    return new int[2] { dict[target - nums[i]], i };\n                }\n                else\n                {\n                    if (!dict.ContainsKey(nums[i]))\n                    {\n                        dict.Add(nums[i], i);\n                    }\n                }\n            }\n            throw new Exception(\"\");\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455110739","body":"### 思路\n\ndict存num[i] count\n\n### 代码\n\n```c#\n\n        Dictionary<int, int> dict = new Dictionary<int, int>();\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (dict.Keys.Contains(nums[i]))\n            {\n                dict[nums[i]]++;\n            }\n            else\n            {\n                dict[nums[i]] = 1;\n            }\n        }\n        return dict.OrderByDescending(x => x.Value).Take(k).Select(x => x.Key).ToArray();\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456353584","body":"### 思路\n\n最后取res+=的地方没取对 \n\n### 代码\n\n```c#\n\n    public int NumberOfBoomerangs(int[][] points) {\n        int result = 0;\n        int distance = 0;\n        for (int i = 0; i < points.Length; i++)\n        {\n            Dictionary<int, int> dict = new Dictionary<int, int>();\n            for (int j = 0; j < points.Length; j++)\n            {\n                distance = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\n                if (dict.Keys.Contains(distance))\n                {\n                    dict[distance]++;\n                }\n                else\n                {\n                    dict[distance] = 1;\n                }\n            }\n\n            foreach (var val in dict.Values)\n            {\n                result += val * (val - 1);\n            }\n        }\n        return result;\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n*n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1458325986","body":"### 思路\n\n循环存长度 过去用dict 现在用了list 变慢了\n\n### 代码\n\n```c#\n\n    public int LengthOfLongestSubstring(string s) {\n        if (s.Length <= 1)\n        {\n            return s.Length;\n        }\n        var arr = s.ToCharArray();\n        int res = 0;\n        List<char> temp = new List<char>();\n        int current = 0;\n        for (int i = 0; i < arr.Length; i++)\n        {\n            if (!temp.Contains(arr[i]))\n            {\n                temp.Add(arr[i]);\n            }\n            else\n            {\n                res = Math.Max(temp.Count, res);\n                temp.Clear();\n                i = current;\n                current++;\n            }\n        }\n        return Math.Max(temp.Count, res);\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460333868","body":"### 思路\n\n没做出来\n\n### 代码\n\n```c#\n\n     public IList<int> FindSubstring(string s, string[] words)\n        {\n            IList<int> res = new List<int>();\n            int m = words.Length, n = words[0].Length, ls = s.Length;\n            for (int i = 0; i < n; i++)\n            {\n                if (i + m * n > ls)\n                {\n                    break;\n                }\n                Dictionary<string, int> differ = new Dictionary<string, int>();\n                for (int j = 0; j < m; j++)\n                {\n                    string word = s.Substring(i + j * n, n);\n                    if (!differ.ContainsKey(word))\n                    {\n                        differ.Add(word, 0);\n                    }\n                    differ[word]++;\n                }\n                foreach (string word in words)\n                {\n                    if (!differ.ContainsKey(word))\n                    {\n                        differ.Add(word, 0);\n                    }\n                    differ[word]--;\n                    if (differ[word] == 0)\n                    {\n                        differ.Remove(word);\n                    }\n                }\n                for (int start = i; start < ls - m * n + 1; start += n)\n                {\n                    if (start != i)\n                    {\n                        string word = s.Substring(start + (m - 1) * n, n);\n                        if (!differ.ContainsKey(word))\n                        {\n                            differ.Add(word, 0);\n                        }\n                        differ[word]++;\n                        if (differ[word] == 0)\n                        {\n                            differ.Remove(word);\n                        }\n                        word = s.Substring(start - n, n);\n                        if (!differ.ContainsKey(word))\n                        {\n                            differ.Add(word, 0);\n                        }\n                        differ[word]--;\n                        if (differ[word] == 0)\n                        {\n                            differ.Remove(word);\n                        }\n                    }\n                    if (differ.Count == 0)\n                    {\n                        res.Add(start);\n                    }\n                }\n            }\n            return res;\n        }\n\n```\n\n**复杂度分析**\n时间复杂度： O(ls×n)，其中 ls ls 是输入 O s 的长度， On 是  words 中每个单词的长度。需要做 O n 次滑动窗口，每次需要遍历一次 O s。 \n空间复杂度：O(m×n)，其中 Om 是  words 的单词数， On 是  words 中每个单词的长度。每次滑动窗口时，需要用一个哈希表保存单词频次。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462294536","body":"### 思路\n\n自己做的超时了 \n\n前缀和 mark\n\n### 代码\n\n```c#\n\n    public int MinSubarray(int[] nums, int p) {\n        int x = 0;\n        foreach (int num in nums) {\n            x = (x + num) % p;\n        }\n        if (x == 0) {\n            return 0;\n        }\n        IDictionary<int, int> index = new Dictionary<int, int>();\n        int y = 0, res = nums.Length;\n        for (int i = 0; i < nums.Length; i++) {\n            if (!index.ContainsKey(y)) {\n                index.Add(y, i);\n            } else {\n                index[y] = i;\n            }\n            y = (y + nums[i]) % p;\n            if (index.ContainsKey((y - x + p) % p)) {\n                res = Math.Min(res, i - index[(y - x + p) % p] + 1);\n            }\n        }\n        return res == nums.Length ? -1 : res;\n    }\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1462417067","body":"### 思路\n\n转数组 求中间位置上的值\n\n看题解写了快慢指针\n\n\n### 代码\n\n```c#\n\n    public ListNode MiddleNode(ListNode head) {\n        if (head == null) {\n         return null;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464936975","body":"### 思路\n\n双指针\n\n### 代码\n\n```c#\n\n     public int RemoveDuplicates(int[] nums)\n            {\n                if (nums == null || nums.Length == 0) return 0;\n                int p = 0;\n                int q = 1;\n                while (q < nums.Length)\n                {\n                    if (nums[p] != nums[q])\n                    {\n                        nums[p + 1] = nums[q];\n                        p++;\n                    }\n                    q++;\n                }\n                return p + 1;\n            }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465211532","body":"### 思路\n\n二分查找\n\n### 代码\n\n```c#\n\n    public int SearchInsert(int[] nums, int target)\n    {\n        int low = 0, high = nums.Length - 1;\n        int mid = 0;\n        while (low <= high)\n        {\n            mid = (high - low) / 2 + low;\n            if (nums[mid] == target)\n            {\n                return mid;\n            }\n            else if (nums[mid] < target)\n            {\n                low = mid + 1;\n            }\n            else\n            {\n                high = mid - 1;\n            }\n        }\n\n        if (target > nums[mid])\n        {\n            return mid + 1;\n        }\n        else\n        {\n            return mid;\n        }\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(logn)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466336420","body":"### 思路\n\n自己做的超时了 看了题解也没做出来\n\n用linkedlist实现双端队列 使得 队首元素 维持队列最大值\n\n### 代码\n\n```c#\n\n        public int[] MaxSlidingWindow(int[] nums, int k)\n        {\n            int n = nums.Length;\n            int[] res = new int[n - k + 1];\n            LinkedList<int> dq = new LinkedList<int>();\n            for (int i = 0; i < n; i++)\n            {\n                if (dq.Count != 0 && dq.First.Value < (i - k + 1))\n                {\n                    dq.RemoveFirst();\n                }\n                while (dq.Count != 0 && nums[i] >= nums[dq.Last.Value])\n                {\n                    dq.RemoveLast();\n                }\n                dq.AddLast(i);\n                if (i >= k - 1)\n                {\n                    res[i - k + 1] = nums[dq.First.Value];\n                }\n            }\n            return res;\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468247477","body":"### 思路\n\n初始都是0 信任别人-1 被信任+1 所有 除了n-1 其他都是-1\n\n### 代码\n\n```c#\n\n     public int FindJudge(int n, int[][] trust)\n        {\n            int[] other = new int[n + 1];\n\n            for (int i = 0; i < trust.Length; i++)\n            {\n                //前面的人相信后面的人\n                other[trust[i][0]]--;\n                other[trust[i][1]]++;\n            }\n\n            int res = -1;\n            for (int i = 1; i <= n; i++)\n            {\n                if (other[i] == (n - 1)) return i;\n            }\n            return res;\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n+trust.length)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1470288830","body":"### 思路\n\n没思路 没做出来。\n\n### 代码\n\n```c#\n\n      public bool PossibleBipartition(int n, int[][] dislikes)\n        {\n            int[] color = new int[n + 1];\n            IList<int>[] g = new IList<int>[n + 1];\n            for (int i = 0; i <= n; ++i)\n            {\n                g[i] = new List<int>();\n            }\n            foreach (int[] p in dislikes)\n            {\n                g[p[0]].Add(p[1]);\n                g[p[1]].Add(p[0]);\n            }\n            for (int i = 1; i <= n; ++i)\n            {\n                if (color[i] == 0 && !DFS(i, 1, color, g))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public bool DFS(int curnode, int nowcolor, int[] color, IList<int>[] g)\n        {\n            color[curnode] = nowcolor;\n            foreach (int nextnode in g[curnode])\n            {\n                if (color[nextnode] != 0 && color[nextnode] == color[curnode])\n                {\n                    return false;\n                }\n                if (color[nextnode] == 0 && !DFS(nextnode, 3 ^ nowcolor, color, g))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n```\n\n**复杂度分析**\n- 时间复杂度：O(n+m)\n- 空间复杂度：O(n+m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1471800021","body":"### 思路\n\n没。读懂题 。。\n\n### 代码\n\n```c#\n\n   public int[] SortItems(int n, int m, int[] group, IList<IList<int>> beforeItems)\n        {\n            for (int i = 0; i < n; i++)\n            {\n                if (group[i] < 0)\n                {\n                    group[i] = m;\n                    m++;\n                }\n            }\n            IList<int>[] groupItems = new IList<int>[m];\n            for (int i = 0; i < m; i++)\n            {\n                groupItems[i] = new List<int>();\n            }\n            int[] groupIndegrees = new int[m];\n            int[] itemIndegrees = new int[n];\n            IList<int>[] groupNextArr = new IList<int>[m];\n            for (int i = 0; i < m; i++)\n            {\n                groupNextArr[i] = new List<int>();\n            }\n            IList<int>[] itemNextArr = new IList<int>[n];\n            for (int i = 0; i < n; i++)\n            {\n                itemNextArr[i] = new List<int>();\n            }\n            for (int i = 0; i < n; i++)\n            {\n                int currGroup = group[i];\n                groupItems[currGroup].Add(i);\n                IList<int> before = beforeItems[i];\n                foreach (int j in before)\n                {\n                    int prevGroup = group[j];\n                    if (prevGroup == currGroup)\n                    {\n                        itemIndegrees[i]++;\n                        itemNextArr[j].Add(i);\n                    }\n                    else\n                    {\n                        groupIndegrees[currGroup]++;\n                        groupNextArr[prevGroup].Add(currGroup);\n                    }\n                }\n            }\n            IList<int> groupList = new List<int>();\n            for (int i = 0; i < m; i++)\n            {\n                groupList.Add(i);\n            }\n            int[] groupsOrder = TopologicalSort(groupIndegrees, groupNextArr, groupList);\n            if (groupsOrder.Length != groupList.Count)\n            {\n                return new int[0];\n            }\n            int[] itemsOrder = new int[n];\n            int itemIndex = 0;\n            for (int i = 0; i < m; i++)\n            {\n                IList<int> items = groupItems[groupsOrder[i]];\n                int[] groupItemsOrder = TopologicalSort(itemIndegrees, itemNextArr, items);\n                int currCount = groupItemsOrder.Length;\n                if (currCount != items.Count)\n                {\n                    return new int[0];\n                }\n                Array.Copy(groupItemsOrder, 0, itemsOrder, itemIndex, currCount);\n                itemIndex += currCount;\n            }\n            return itemsOrder;\n        }\n\n        public int[] TopologicalSort(int[] indegrees, IList<int>[] nextArr, IList<int> nums)\n        {\n            int count = nums.Count;\n            int[] order = new int[count];\n            int index = 0;\n            Queue<int> queue = new Queue<int>();\n            foreach (int num in nums)\n            {\n                if (indegrees[num] == 0)\n                {\n                    queue.Enqueue(num);\n                }\n            }\n            while (queue.Count > 0)\n            {\n                int curr = queue.Dequeue();\n                order[index] = curr;\n                index++;\n                IList<int> nextList = nextArr[curr];\n                foreach (int next in nextList)\n                {\n                    indegrees[next]--;\n                    if (indegrees[next] == 0)\n                    {\n                        queue.Enqueue(next);\n                    }\n                }\n            }\n            return index == count ? order : new int[0];\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n+m+k)\n- 空间复杂度：O(n+m+k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473861032","body":"### 思路\n\n做两个变量表示xy轴 控制加减\n\n### 代码\n\n```c#\n\n    public bool JudgeCircle(string moves) {\n        int stepX = 0;\n        int stepY = 0;\n\n        foreach (char c in moves.ToCharArray())\n        {\n            if (c == 'L')\n            {\n                stepX--;\n            }\n            else if (c == 'R')\n            {\n                stepX++;\n            }\n            else if (c == 'D')\n            {\n                stepY--;\n            }\n            else if (c == 'U')\n            {\n                stepY++;\n            }\n        }\n        return stepX == 0 && stepY == 0;\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474868704","body":"### 思路\n\n自己尝试写有bug 需要改日重做\n\n### 代码\n\n```javascript#\n\n    /**\n     * @param {number[][]} tasks\n     * @return {number[]}\n     */\n\n    const getOrder = function (tasks) {\n      const queue = new MinPriorityQueue()\n      tasks = tasks.map((task, index) => ({\n        index,\n        start: task[0],\n        time: task[1]\n      }))\n      tasks.sort((a, b) => b.start - a.start)\n      const answer = []\n      let time = 0\n      while (tasks.length > 0 || !queue.isEmpty()) {\n        // 队列为空，且没有任务能加入队列，直接跳过时间\n        if (queue.isEmpty() && tasks[tasks.length - 1].start > time) {\n          time = tasks[tasks.length - 1].start\n        }\n\n        // 向队列中加入可执行任务\n        while (tasks.length > 0) {\n          if (tasks[tasks.length -1].start <= time) {\n            const task = tasks.pop()\n            queue.enqueue(task, task.time * 100000 + task.index)\n          } else {\n            break\n          }\n        }\n\n        // 执行任务\n        const { element: task } = queue.dequeue()\n        time += task.time\n        answer.push(task.index)\n      }\n      return answer\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475124358","body":"### 思路\n\n注意边界的保护 duration不能小于0\n\n### 代码\n\n```C#\n\n         public int NumberOfRounds(string loginTime, string logoutTime)\n        {\n            int t0 = (Convert.ToInt32(loginTime.Split(':')[0])) * 60 + Convert.ToInt32(loginTime.Split(':')[1]);\n            int t1 = Convert.ToInt32(logoutTime.Split(':')[0]) * 60 + Convert.ToInt32(logoutTime.Split(':')[1]);\n\n            if (t0 > t1)\n            {\n                t1 += 24 * 60;\n            }\n\n            t1 = t1 / 15 * 15;\n            return Math.Max(0, t1-t0) / 15;\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476465261","body":"### 思路\n\n理解题意 一顿暴力\n\n### 代码\n\n```c#\n\n    public int MinCharacters(string a, string b)\n    {\n        int n = a.Length, m = b.Length, ans = 0x3f3f3f3f;\n        int[] c1 = new int[26], c2 = new int[26];\n        foreach (char c in a.ToCharArray()) c1[c - 'a']++;\n        foreach (char c in b.ToCharArray()) c2[c - 'a']++;\n        for (int i = 0; i < 26 && ans != 0; i++)\n        {\n            // 3 a 和 b 都 由 同一个 字母组成\n            int ca = n - c1[i], cb = m - c2[i];\n            ans = Math.Min(ans, ca + cb);\n            if (i == 0) continue;\n            int r1 = 0, r2 = 0;\n            // 1 a 中的 每个字母 在字母表中 严格小于 b 中的 每个字母 。\n            for (int j = i; j < 26; j++) r1 += c1[j];\n            for (int j = 0; j < i; j++) r1 += c2[j];\n            // 2 b 中的 每个字母 在字母表中 严格小于 a 中的 每个字母 。\n            for (int j = i; j < 26; j++) r2 += c2[j];\n            for (int j = 0; j < i; j++) r2 += c1[j];\n            ans = Math.Min(ans, Math.Min(r1, r2));\n        }\n        return ans;\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n+m)\n- 空间复杂度：O(c)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1478060392","body":"### 思路\n\n快速排序\n\n### 代码\n\n```C#\n\n        public int[] SortArray(int[] nums)\n        {\n            randomizedQuicksort(nums, 0, nums.Length - 1);\n            return nums;\n        }\n\n        public void randomizedQuicksort(int[] nums, int l, int r)\n        {\n            if (l < r)\n            {\n                int pos = randomizedPartition(nums, l, r);\n                randomizedQuicksort(nums, l, pos - 1);\n                randomizedQuicksort(nums, pos + 1, r);\n            }\n        }\n\n        public int randomizedPartition(int[] nums, int l, int r)\n        {\n            int i = new Random().Next(r - l + 1) + l; \n            swap(nums, r, i);\n            return partition(nums, l, r);\n        }\n\n        public int partition(int[] nums, int l, int r)\n        {\n            int pivot = nums[r];\n            int i = l - 1;\n            for (int j = l; j <= r - 1; ++j)\n            {\n                if (nums[j] <= pivot)\n                {\n                    i = i + 1;\n                    swap(nums, i, j);\n                }\n            }\n            swap(nums, i + 1, r);\n            return i + 1;\n        }\n\n        private void swap(int[] nums, int i, int j)\n        {\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479766787","body":"### 思路\n\n二分查找\n\n### 代码\n\n```C#\n\n\n    public int MySqrt(int x) {\n        int l = 0, r = x, ans = -1;\n        while (l <= r)\n        {\n            int mid = l + (r - l) / 2;\n            if ((long)mid * mid <= x)\n            {\n                ans = mid;\n                l = mid + 1;\n            }\n            else\n            {\n                r = mid - 1;\n            }\n        }\n        return ans;\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(logn)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1481375824","body":"### 思路\n\n二分查找\n\n### 代码\n\n```C#\n\n        public int FirstBadVersion(int n)\n        {\n            int left = 1, right = n;\n            while (left < right)\n            { \n                int mid = left + (right - left) / 2; \n                if (IsBadVersion(mid))\n                {\n                    right = mid; \n                }\n                else\n                {\n                    left = mid + 1; \n                }\n            }\n            return left;\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(logn)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482504509","body":"### 思路\n\n没有做出来\n\n### 代码\n\n```C#\n\n       public int ReversePairs(int[] nums) {\n        if (nums.Length == 0) {\n            return 0;\n        }\n        return reversePairsRecursive(nums, 0, nums.Length - 1);\n    }\n\n    public int reversePairsRecursive(int[] nums, int left, int right) {\n        if (left == right) {\n            return 0;\n        } else {\n            int mid = (left + right) / 2;\n            int n1 = reversePairsRecursive(nums, left, mid);\n            int n2 = reversePairsRecursive(nums, mid + 1, right);\n            int ret = n1 + n2;\n\n            // 首先统计下标对的数量\n            int i = left;\n            int j = mid + 1;\n            while (i <= mid) {\n                while (j <= right && (long) nums[i] > 2 * (long) nums[j]) {\n                    j++;\n                }\n                ret += j - mid - 1;\n                i++;\n            }\n\n            // 随后合并两个排序数组\n            int[] sorted = new int[right - left + 1];\n            int p1 = left, p2 = mid + 1;\n            int p = 0;\n            while (p1 <= mid || p2 <= right) {\n                if (p1 > mid) {\n                    sorted[p++] = nums[p2++];\n                } else if (p2 > right) {\n                    sorted[p++] = nums[p1++];\n                } else {\n                    if (nums[p1] < nums[p2]) {\n                        sorted[p++] = nums[p1++];\n                    } else {\n                        sorted[p++] = nums[p2++];\n                    }\n                }\n            }\n            for (int k = 0; k < sorted.Length; k++) {\n                nums[left + k] = sorted[k];\n            }\n            return ret;\n        }\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483774606","body":"### 思路\n\n可以先将heaters排序之后 循环house进行二分查找 查找到的i 如果小于0或者大于等于heater.length 设置maxvalue 否则取两者差值的最小者 最后的结果取每次递归的较大值\n\n以下是另外一种双指针的方式\n\n### 代码\n\n```C#\n\n    public int FindRadius(int[] houses, int[] heaters)\n    {\n        int ans = 0;\n        int d;\n        Array.Sort(houses);\n        Array.Sort(heaters);\n        int j = 0;\n        for (int i = 0; i < houses.Length; i++)\n        {\n            while (j < heaters.Length && heaters[j] < houses[i])\n            {\n                j++;\n            }\n\n            if (j == 0)\n            {\n                d = heaters[0] - houses[i];\n            }\n            else if (j == heaters.Length)\n            {\n                d = houses[i] - heaters[j - 1];\n            }\n            else\n            {\n                d = Math.Min(heaters[j] - houses[i], houses[i] - heaters[j - 1]);\n            }\n            ans = Math.Max(ans, d);\n        }\n        return ans;\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(mlogm,nlogn)\n- 空间复杂度：O(logm+logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1483989739","body":"### 思路\n\n排序之后 对相减的结果做二分 当前面所有的count不大于k时 right左移 反之 left 右移\n\n### 代码\n\n```C#\n\n     public int SmallestDistancePair(int[] nums, int k)\n    {\n        Array.Sort(nums);\n        int left = 0;\n        int right = nums[nums.Length - 1] - nums[0];\n        while (left <= right)\n        {\n            int mid = left + (right - left) / 2;\n            if (getCount(nums, mid) < k)\n            {\n                left = mid + 1;\n            }\n            else\n            {\n                right = mid - 1;\n            }\n        }\n        return left;\n    }\n\n    private int getCount(int[] nums, int diff)\n    {\n        int count = 0, i = 0;\n        for (int j = 1; j < nums.Length; j++)\n        {\n            while (nums[j] - nums[i] > diff)\n            {\n                i++;\n            }\n            count += j - i;\n        }\n        return count;\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1485237117","body":"### 思路\n\n这个题超出能力范围了。mark\n\n### 代码\n\n```C#\n\n    private int N;\n\n        private int[][] DIR = { new[] { 0, 1 }, new[] { 0, -1 }, new[] { 1, 0 }, new[] { -1, 0 } };\n\n        public int SwimInWater(int[][] grid)\n        {\n            N = grid.Length;\n\n            var left = 0;\n            var right = N * N - 1;\n            while (left < right)\n            {\n                var mid = (left + right) / 2;\n\n                if (grid[0][0] <= mid && bfs(grid, mid))\n                {\n                    right = mid;\n                }\n                else\n                {\n                    left = mid + 1;\n                }\n            }\n\n            return left;\n        }\n\n        private bool bfs(int[][] grid, int threshold)\n        {\n            var queue = new Queue<(int x, int y)>();\n            queue.Enqueue((0, 0));\n            var visited = new bool[N, N];\n            visited[0, 0] = true;\n\n            while (queue.Count != 0)\n            {\n                var (x, y) = queue.Dequeue();\n                foreach (var direction in DIR)\n                {\n                    var newX = x + direction[0];\n                    var newY = y + direction[1];\n                    if (!inArea(newX, newY) || visited[newX, newY] || grid[newX][newY] > threshold) continue;\n                    if (newX == N - 1 && newY == N - 1) return true;\n                    queue.Enqueue((newX, newY));\n                    visited[newX, newY] = true;\n                }\n            }\n\n            return false;\n        }\n\n        private bool inArea(int x, int y)\n        {\n            return x >= 0 && x < N && y >= 0 && y < N;\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n2logn)\n- 空间复杂度：O(n2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1487118016","body":"### 思路\n\n滑动窗口\n\n### 代码\n\n```C#\n\n           public int MaxVowels(string s, int k)\n        {\n            int count = 0;\n            for (int i = 0; i < k; ++i)\n            {\n                count += isYuanYin(s[i]);\n            }\n            int ans = count;\n            for (int i = k; i < s.Length; ++i)\n            {\n                count += isYuanYin(s[i]) - isYuanYin(s[i - k]);\n                ans = Math.Max(ans, count);\n            }\n            return ans;\n        }\n\n        public int isYuanYin(char ch)\n        {\n            return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ? 1 : 0;\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488595341","body":"### 思路\n\n不是很懂dp。。 先抄一个。。一会儿写滑动窗口+二分\n\n### 代码\n\n```C#\n\n     public double New21Game(int n, int k, int maxPts)\n        {\n            if (k == 0)\n            {\n                return 1.0;\n            }\n            double[] dp = new double[k + maxPts];\n            for (int i = k; i <= n && i < k + maxPts; i++)\n            {\n                dp[i] = 1.0;\n            }\n            dp[k - 1] = 1.0 * Math.Min(n - k + 1, maxPts) / maxPts;\n            for (int i = k - 2; i >= 0; i--)\n            {\n                dp[i] = dp[i + 1] - (dp[i + maxPts + 1] - dp[i + 1]) / maxPts;\n            }\n            return dp[0];\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(min(n,k+maxPts))\n- 空间复杂度：O(k+maxPts)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1490519964","body":"### 思路\n\n滑动窗口\n\n### 代码\n\n```C#\n     public IList<int> FindAnagrams(string s, string p) {\n        var res = new List<int>();\n        if (s.Length < p.Length)\n            return res;\n        int[] charCnt = new int[26];\n        for (int i = 0; i < p.Length; i++)\n        {\n            charCnt[s[i] - 'a']++;\n            charCnt[p[i] - 'a']--;\n        }\n        var diff = 0;\n        for (int i = 0; i < 26; i++)\n        {\n            diff += Math.Abs(charCnt[i]);\n        }\n        if (diff == 0)\n        {\n            res.Add(0);\n        }\n        for (int i = p.Length; i < s.Length; i++)\n        {\n            var enCharVal = s[i] - 'a';\n            if (charCnt[enCharVal] < 0)\n            {\n                diff--;\n            }\n            else\n            {\n                diff++;\n            }\n\n            charCnt[enCharVal]++;\n            var deCharVal = s[i - p.Length] - 'a';\n            if (charCnt[deCharVal] > 0)\n            {\n                diff--;\n            }\n            else\n            {\n                diff++;\n            }\n            charCnt[deCharVal]--;\n            if (diff == 0)\n            {\n                res.Add(i - p.Length + 1);\n            }\n        }\n        return res;\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(m+n)\n- 空间复杂度：O(1)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1492914321","body":"### 思路\n\n滑动窗口\n\n### 代码\n\n```C#\n\n\t public int MinOperations(int[] nums, int x)\n        {\n            int total = 0;\n            int length = nums.Length;\n            for (int i = 0; i < length; i++)\n            {\n                total += nums[i];\n            }\n            int remain = total - x;\n            if (remain == 0)\n            {\n                return length;\n            }\n            else if (remain < 0)\n            {\n                return -1;\n            }\n            int maxLength = -1;\n            int sum = 0;\n            int start = 0, end = 0;\n            while (end < length)\n            {\n                sum += nums[end];\n                while (sum > remain)\n                {\n                    sum -= nums[start];\n                    start++;\n                }\n                if (sum == remain)\n                {\n                    maxLength = Math.Max(maxLength, end - start + 1);\n                }\n                end++;\n            }\n            return maxLength < 0 ? -1 : length - maxLength;\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493055729","body":"### 思路\n\n\n\n### 代码\n\n```C#\n\n\t      public IList<string> ReadBinaryWatch(int turnedOn)\n        {\n            var result = new List<string>();\n            for (int hour = 0; hour < 12; hour++)\n            {\n                for (int minute = 0; minute < 60; minute++)\n                {\n                    if (CountBits(hour) + CountBits(minute) == turnedOn)\n                    {\n                        result.Add($\"{hour}:{minute:00}\");\n                    }\n                }\n            }\n            return result;\n        }\n\n        public int CountBits(int n)\n        {\n            int count = 0;\n            while (n > 0)\n            {\n                count += n & 1;\n                n >>= 1;\n            }\n            return count;\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494323652","body":"### 思路\n\n没写出来 mark\n\n### 代码\n\n```C#\n\n  public int TotalNQueens(int n)\n    {\n        HashSet<int> columns = new HashSet<int>();\n        HashSet<int> diagonals1 = new HashSet<int>();\n        HashSet<int> diagonals2 = new HashSet<int>();\n        return backtrack(n, 0, columns, diagonals1, diagonals2);\n    }\n\n    public int backtrack(int n, int row, HashSet<int> columns, HashSet<int> diagonals1, HashSet<int> diagonals2)\n    {\n        if (row == n)\n        {\n            return 1;\n        }\n        else\n        {\n            int count = 0;\n            for (int i = 0; i < n; i++)\n            {\n                if (columns.Contains(i))\n                {\n                    continue;\n                }\n                int diagonal1 = row - i;\n                if (diagonals1.Contains(diagonal1))\n                {\n                    continue;\n                }\n                int diagonal2 = row + i;\n                if (diagonals2.Contains(diagonal2))\n                {\n                    continue;\n                }\n                columns.Add(i);\n                diagonals1.Add(diagonal1);\n                diagonals2.Add(diagonal2);\n                count += backtrack(n, row + 1, columns, diagonals1, diagonals2);\n                columns.Remove(i);\n                diagonals1.Remove(diagonal1);\n                diagonals2.Remove(diagonal2);\n            }\n            return count;\n        }\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n!)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495671459","body":"### 思路\n\ndfs\n\n### 代码\n\n```C#\n\n\t   public int MaxAreaOfIsland(int[][] grid)\n        {\n            int ans = 0;\n            for (int i = 0; i != grid.Length; ++i)\n            {\n                for (int j = 0; j != grid[0].Length; ++j)\n                {\n                    ans = Math.Max(ans, dfs(grid, i, j));\n                }\n            }\n            return ans;\n        }\n\n        public int dfs(int[][] grid, int cur_i, int cur_j)\n        {\n            if (cur_i < 0 || cur_j < 0 || cur_i == grid.Length || cur_j == grid[0].Length || grid[cur_i][cur_j] != 1)\n            {\n                return 0;\n            }\n            grid[cur_i][cur_j] = 0;\n            int[] di = { 0, 0, 1, -1 };\n            int[] dj = { 1, -1, 0, 0 };\n            int ans = 1;\n            for (int index = 0; index != 4; ++index)\n            {\n                int next_i = cur_i + di[index], next_j = cur_j + dj[index];\n                ans += dfs(grid, next_i, next_j);\n            }\n            return ans;\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(m*n)\n- 空间复杂度：O(m*n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497709044","body":"var maxDistance = function(grid) {\n\tlet m = grid.length;\n\tlet n = grid[0].length;\n\n\tlet array = [];\n\tfor (let i = 0; i < m; i++) {\n\t\tfor (let j = 0; j < n; j++) {\n\t\t\tif (grid[i][j] === 1) {\n\t\t\t\tarray.push([i, j]);\n\t\t\t}\n\t\t}\n\t}\n\tif (array.length === 0 || array.length === m * n) return -1;\n\n\tconst col = [-1, 1, 0, 0];\n\tconst row = [0, 0, -1, 1];\n\n\tlet temp = [];\n\twhile (array.length) {\n\t\ttemp = array.pop();\n\t\tconst x = temp[0];\n\t\tconst y = temp[1];\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tconst xx = x + col[i];\n\t\t\tconst yy = y + row[i];\n\t\t\tif (xx < 0 || xx >= m || yy < 0 || yy >= n || grid[xx][yy] !== 0) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tgrid[xx][yy] = grid[x][y] + 1;\n\t\t\t\tarray.unshift([xx, yy]);\n\t\t\t}\n\t\t}\n\t}\n\treturn grid[temp[0]][temp[1]] - 1;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1499034620","body":"public int MaxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {\n        int candiesCount = 0;\n        int n = status.Length;\n        bool[] open = new bool[n];\n        for (int i = 0; i < n; i++) {\n            open[i] = status[i] == 1;\n        }\n        bool[] obtained = new bool[n];\n        bool[] visited = new bool[n];\n        Queue<int> queue = new Queue<int>();\n        foreach (int box in initialBoxes) {\n            obtained[box] = true;\n            if (open[box]) {\n                visited[box] = true;\n                queue.Enqueue(box);\n            }\n        }\n        while (queue.Count > 0) {\n            int box = queue.Dequeue();\n            candiesCount += candies[box];\n            int[] nextKeys = keys[box];\n            foreach (int next in nextKeys) {\n                open[next] = true;\n                if (obtained[next] && !visited[next]) {\n                    visited[next] = true;\n                    queue.Enqueue(next);\n                }\n            }\n            int[] nextBoxes = containedBoxes[box];\n            foreach (int next in nextBoxes) {\n                obtained[next] = true;\n                if (open[next] && !visited[next]) {\n                    visited[next] = true;\n                    queue.Enqueue(next);\n                }\n            }\n        }\n        return candiesCount;\n    }\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1500353228","body":"### 思路\n\nDFS\n\n### 代码\n\n```C#\n\n   class Node\n        {\n            public int data;\n            public Node left;\n            public Node right;\n\n            public Node(int key)\n            {\n                this.data = key;\n                this.left = null;\n                this.right = null;\n            }\n        }\n\n        class Pair\n        {\n            public int hd;\n            public Node node;\n            public Pair(Node node, int hd)\n            {\n                this.node = node;\n                this.hd = hd;\n            }\n        }\n\n        List<int> topView(Node root)\n        {\n            Queue<Pair> q = new Queue<Pair>();\n            Dictionary<int, int> map = new Dictionary<int, int>();\n            List<int> arr = new List<int>();\n\n            if (root == null) return arr;\n            q.Enqueue(new Pair(root, 0));\n\n            int min = 0;\n            int max = 0;\n\n            while (q.Count() != 0)\n            {\n                Pair x = q.Peek();\n                if (!map.Keys.Contains(x.hd))\n                {\n                    map.Add(x.hd, x.node.data);\n                }\n                if (x.node.left != null)\n                {\n                    q.Enqueue(new Pair(x.node.left, x.hd - 1));\n                    min = Math.Min(min, x.hd - 1);\n                }\n                if (x.node.right != null)\n                {\n                    q.Enqueue(new Pair(x.node.right, x.hd + 1));\n                    max = Math.Max(max, x.hd + 1);\n                }\n            }\n\n            for (int i = min; i <= max; i++)\n            {\n                arr.Add(map[i]);\n            }\n            return arr;\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500918837","body":"### 思路\n\ndp\n\n### 代码\n\n```C#\n\n\t    public int MinCostClimbingStairs(int[] cost)\n        {\n            int[] dp = new int[cost.Length + 1];\n            dp[0] = 0;\n            dp[1] = 0;\n            for (int i = 2; i < dp.Length; i++)\n            {\n                dp[i] = Math.Min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1]);\n            }\n            return dp[cost.Length];\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501139175","body":"### 思路\n\ndp\n\n### 代码\n\n```C#\n\n        public int Rob(int[] nums)\n        {\n            if (nums.Length == 0)\n            {\n                return 0;\n            }\n\n            int N = nums.Length;\n            int[] dp = new int[N + 1];\n            dp[0] = 0;\n            dp[1] = nums[0];\n            for (int k = 2; k <= N; k++)\n            {\n                dp[k] = Math.Max(dp[k - 1], nums[k - 1] + dp[k - 2]);\n            }\n            return dp[N];\n        }\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501944605","body":"### 思路\n\n贪心 + 前缀和 + 二分查找 没做出来。mark\n\n### 代码\n\n```C#\n\n     public int FindNumberOfLIS(int[] nums) {\n        IList<IList<int>> d = new List<IList<int>>();\n        IList<IList<int>> cnt = new List<IList<int>>();\n        foreach (int v in nums) {\n            int i = BinarySearch1(d.Count, d, v);\n            int c = 1;\n            if (i > 0) {\n                int k = BinarySearch2(d[i - 1].Count, d[i - 1], v);\n                c = cnt[i - 1][cnt[i - 1].Count - 1] - cnt[i - 1][k];\n            }\n            if (i == d.Count) {\n                IList<int> dIList = new List<int>();\n                dIList.Add(v);\n                d.Add(dIList);\n                IList<int> cntIList = new List<int>();\n                cntIList.Add(0);\n                cntIList.Add(c);\n                cnt.Add(cntIList);\n            } else {\n                d[i].Add(v);\n                int cntSize = cnt[i].Count;\n                cnt[i].Add(cnt[i][cntSize - 1] + c);\n            }\n        }\n\n        int count1 = cnt.Count, count2 = cnt[count1 - 1].Count;\n        return cnt[count1 - 1][count2 - 1];\n    }\n\n    public int BinarySearch1(int n, IList<IList<int>> d, int target) {\n        int l = 0, r = n;\n        while (l < r) {\n            int mid = (l + r) / 2;\n            IList<int> list = d[mid];\n            if (list[list.Count - 1] >= target) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n\n    public int BinarySearch2(int n, IList<int> list, int target) {\n        int l = 0, r = n;\n        while (l < r) {\n            int mid = (l + r) / 2;\n            if (list[mid] < target) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n```\n\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1503623334","body":"### 思路\n\nmark\n\n### 代码\n\n```C#\n\n     public int LongestCommonSubsequence(string text1, string text2)\n        {\n            int m = text1.Length, n = text2.Length;\n            int[,] dp = new int[m, n];\n            dp[0, 0] = text1[0] == text2[0] ? 1 : 0;\n            for (int j = 1; j < n; j++)\n            {\n                dp[0, j] = text1[0] == text2[j] ? 1 : dp[0, j - 1];\n            }\n            for (int i = 1; i < m; i++)\n            {\n                dp[i, 0] = text1[i] == text2[0] ? 1 : dp[i - 1, 0];\n            }\n            for (int i = 1; i < m; i++)\n            {\n                for (int j = 1; j < n; j++)\n                {\n                    if (text1[i] == text2[j])\n                        dp[i, j] = dp[i - 1, j - 1] + 1;\n                    else\n                        dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);\n                }\n            }\n            return dp[m - 1, n - 1];\n        }\n```\n\n**复杂度分析**\n- 时间复杂度：O(mn)\n- 空间复杂度：O(mn)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1505451466","body":"### 思路\n\ndp\n\n### 代码\n\n```C#\n\n      public int UniquePaths(int m, int n)\n        {\n            int[][] dp = new int[m][];\n            for (int i = 0; i < m; i++)\n            {\n                dp[i] = new int[n];\n            }\n            dp[0][0] = 1;\n            for (int j = 1; j < n; j++)\n            {\n                dp[0][j] = 1;\n            }\n            for (int i = 1; i < m; i++)\n            {\n                dp[i][0] = 1;\n            }\n            for (int i = 1; i < m; i++)\n            {\n                for (int j = 1; j < n; j++)\n                {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n            return dp[m - 1][n - 1];\n        }\n```\n\n**复杂度分析**\n- 时间复杂度：O(mn)\n- 空间复杂度：O(mn)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1507152997","body":"### 思路\n\ndp\n\n### 代码\n\n```C#\n\n      public class Solution {\n        static int[][] dirs = {new int[]{-2, -1}, new int[]{-2, 1}, new int[]{2, -1}, new int[]{2, 1}, new int[]{-1, -2}, new int[]{-1, 2}, new int[]{1, -2}, new int[]{1, 2}};\n\n        public double KnightProbability(int n, int k, int row, int column) {\n            double[,,] dp = new double[k + 1, n, n];\n            for (int step = 0; step <= k; step++) {\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < n; j++) {\n                        if (step == 0) {\n                            dp[step, i, j] = 1;\n                        } else {\n                            foreach (int[] dir in dirs) {\n                                int ni = i + dir[0], nj = j + dir[1];\n                                if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                                    dp[step, i, j] += dp[step - 1, ni, nj] / 8;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return dp[k, row, column];\n        }\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(k*n2)\n- 空间复杂度：O(k*n2)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1507848351","body":"### 思路\n\nDFS\n\n### 代码\n\n```C#\n\n    Dictionary<int, bool> memo = new Dictionary<int, bool>();\n\n    public bool CanIWin(int maxChoosableInteger, int desiredTotal) {\n        if ((1 + maxChoosableInteger) * (maxChoosableInteger) / 2 < desiredTotal) {\n            return false;\n        }\n        return DFS(maxChoosableInteger, 0, desiredTotal, 0);\n    }\n\n    public bool DFS(int maxChoosableInteger, int usedNumbers, int desiredTotal, int currentTotal) {\n        if (!memo.ContainsKey(usedNumbers)) {\n            bool res = false;\n            for (int i = 0; i < maxChoosableInteger; i++) {\n                if (((usedNumbers >> i) & 1) == 0) {\n                    if (i + 1 + currentTotal >= desiredTotal) {\n                        res = true;\n                        break;\n                    }\n                    if (!DFS(maxChoosableInteger, usedNumbers | (1 << i), desiredTotal, currentTotal + i + 1)) {\n                        res = true;\n                        break;\n                    }\n                }\n            }\n            memo.Add(usedNumbers, res);\n        }\n        return memo[usedNumbers];\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(2^n*n)\n- 空间复杂度：O(2^n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509878160","body":"### 思路\n\ndp\n\n### 代码\n\n```C#\n\n        public int Rob(int[] nums)\n        {\n            if(nums.Sum() % 2 != 0) return false;\n\n            int sum = nums.Sum()/2;\n            int[] dp = new int[10001];\n            dp[0] = 0;\n\n            for(int i = 0; i < nums.Length; i++){\n                for(int j = sum; j >= nums[i]; j--)\n                    dp[j] = Math.Max(dp[j], dp[j - nums[i]] + nums[i]);\n            }\n            return dp[sum] == sum;\n\n        }\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n*target) target 是整个数组的元素和的一半\n- 空间复杂度：O(target)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510387455","body":"### 思路\n\n对于某一下标i，有且只有两种操作：减去当前下标的数 或 加上当前下标的数。dp[i][sum]表示处理到下标i-1时，得到sum的操作数量\n因此：dp[i][sum + num] += dp[i - 1][sum]         dp[i][sum - num] += dp[i - 1][sum]\n\n\n### 代码\n\n```C#\n\n    public int FindTargetSumWays(int[] nums, int target) {\n        int n = nums.Length;\n        var dp = new List<Dictionary<int, int>>();\n        for (int i = 0; i <= n; i++) {\n            dp.Add(new Dictionary<int, int>());\n        }\n        dp[0][0] = 1;\n        for (int i = 0; i < n; i++) {\n            var num = nums[i];\n            foreach(var item in dp[i]) {\n                if (!dp[i + 1].ContainsKey(item.Key + num)) {\n                    dp[i + 1][item.Key + num] = item.Value;\n                }\n                else {\n                    dp[i + 1][item.Key + num] += item.Value;\n                }\n                if (!dp[i + 1].ContainsKey(item.Key - num)) {\n                    dp[i + 1][item.Key - num] = item.Value;\n                }\n                else {\n                    dp[i + 1][item.Key - num] += item.Value;\n                }\n            }\n        }\n        if (!dp[n].ContainsKey(target)) {\n            return 0;\n        }\n        return dp[n][target];\n    }\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511518173","body":"### 思路\n\ndp\n\n### 代码\n\n```C#\n\n        public int CoinChange(int[] coins, int amount)\n        {\n            int[] dp = new int[amount + 1];\n            int max = Int;\n\n            for (int j = 0; j < dp.Length; j++)\n                dp[j] = max;\n\n            dp[0] = 0;\n\n            for (int i = 0; i < coins.Length; i++)\n            {\n                for (int j = coins[i]; j <= amount; j++)\n                {\n                    if (dp[j - coins[i]] != max)\n                        dp[j] = Math.Min(dp[j], dp[j - coins[i]] + 1);\n                }\n            }\n\n            return dp[amount] == max ? -1 : dp[amount];\n        }\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1513347693","body":"### 思路\n\ndp\n\n### 代码\n\n```C#\n\n       public int change(int amount, int[] coins) {\n             int m = coins.Length, n = amount;\n            int[][] dp = new int[m + 1][];\n            for (int i = 0; i < dp.Length; i++)\n            {\n                dp[i] = new int[n+1];\n            }\n            for (int i = 1; i <= m; i++)\n            {\n                dp[i][0] = 1;\n                for (int j = 1; j <= n; j++)\n                {\n                    dp[i][j] += dp[i - 1][j];\n                    if (j >= coins[i - 1])\n                    {\n                        dp[i][j] += dp[i][j - coins[i - 1]];\n                    }\n                }\n            }\n            return dp[m][n];\n        }\n\n```\n- 时间复杂度：O(amount * n) \n- 空间复杂度：O(amount)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514908378","body":"### 代码\n\n```C#\n\n       public int FindContentChildren(int[] g, int[] s)\n        {\n            int count = 0;\n            Array.Sort(g);\n            Array.Sort(s);\n            int gCount = g.Length;\n            int sCount = s.Length;\n            int gIndex = 0;\n            int sIndex = 0;\n            while (gIndex < gCount && sIndex < sCount)\n            {\n                if (g[gIndex] <= s[sIndex])\n                {\n                    count++;\n                    gIndex++;\n                }\n                sIndex++;\n            }\n            return count;\n        }\n\n```\n- 时间复杂度：O(nlogn+mlogm) \n- 空间复杂度：O(logn+logm) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516527292","body":"### 思路\n\n在剩余区间无重叠的情况下，计算需要移除的最少区间，等价于计算可以保留的最多区间。\n\n### 代码\n\n```C#\n\n    public int EraseOverlapIntervals(int[][] intervals)\n    {\n        Array.Sort(intervals, (a, b) => a[1] - b[1]);\n        int eraseCount = 0;\n        int end = intervals[0][1];\n        int length = intervals.Length;\n        for (int i = 1; i < length; i++)\n        {\n            if (intervals[i][0] >= end)\n            {\n                end = intervals[i][1];\n            }\n            else\n            {\n                eraseCount++;\n            }\n        }\n        return eraseCount;\n    }\n\n```\n- 时间复杂度：O(nlogn) \n- 空间复杂度：O(n) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1516610069","body":"### 思路\n\n如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点\n可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新\n如果可以一直跳到最后，就成功了\n\n### 代码\n\n```C#\n\n     public bool CanJump(int[] nums)\n        {\n            int k = 0;\n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (i > k) return false;\n                k = Math.Max(k, i + nums[i]);\n            }\n            return true;\n        }\n\n```\n- 时间复杂度：O(n) \n- 空间复杂度：O(1) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518663081","body":"### 思路\n\ndp\n\n\n### 代码\n\n```C#\n\n        public int NumTrees(int n)\n        {\n            int[] dp = new int[n + 1];\n            dp[0] = 1;\n            dp[1] = 1;\n\n            for (int i = 2; i < n + 1; i++)\n                for (int j = 1; j < i + 1; j++)\n                    dp[i] += dp[j - 1] * dp[i - j];\n\n            return dp[n];\n        }\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n2)\n- 空间复杂度：O(n)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519072448","body":"\n\n### 代码\n\n```C#\n\n        public ListNode MergeKLists(ListNode[] lists)\n        {\n            if (lists.Length == 0)\n            {\n                return null;\n            }\n            ListNode dummyHead = new ListNode(0);\n            PriorityQueue<ListNode, int> pq = new PriorityQueue<ListNode, int>();\n            foreach (ListNode head in lists)\n            {\n                if (head != null)\n                {\n                    pq.Enqueue(head, head.val);\n                }\n            }\n            ListNode temp = dummyHead;\n            while (pq.Count > 1)\n            {\n                ListNode node = pq.Dequeue();\n                temp.next = node;\n                temp = temp.next;\n                node = node.next;\n                if (node != null)\n                {\n                    pq.Enqueue(node, node.val);\n                }\n            }\n            if (pq.Count > 0)\n            {\n                temp.next = pq.Dequeue();\n            }\n            return dummyHead.next;\n\n        }\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(nlogk)\n- 空间复杂度：O(1)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1520411309","body":"### 思路\n\n没做出来。\n\n### 代码\n\n```C#\n\n        public int[] BeautifulArray(int n)\n        {\n            int[] arr = new int[n];\n            Array.Fill(arr, 1);\n            Recursive(arr, 0, n - 1);\n            return arr;\n        }\n   \n        private void Recursive(int[] arr, int min, int max)\n        {\n            if (max <= min) return;\n            int mid = min + (max - min) / 2;\n            Recursive(arr, min, mid);\n            Recursive(arr, mid + 1, max);\n            for (int i = min; i <= mid; i++)\n            {\n                arr[i] = 2 * arr[i] - 1;\n            }\n            for (int i = mid + 1; i <= max; i++)\n            {\n                arr[i] = 2 * arr[i];\n            }\n            return;\n        }\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1522014404","body":"### 思路\n\n对于那个mask不是很了解。\n\n### 代码\n\n```C#\n\n        public int[] SingleNumber(int[] nums)\n        {\n            int xorsum = 0;\n            foreach (int num in nums)\n            {\n                xorsum ^= num;\n            }\n            // 防止溢出\n            int lsb = (xorsum == int.MinValue ? xorsum : xorsum & (-xorsum));\n            int type1 = 0, type2 = 0;\n            foreach (int num in nums)\n            {\n                if ((num & lsb) != 0)\n                {\n                    type1 ^= num;\n                }\n                else\n                {\n                    type2 ^= num;\n                }\n            }\n            return new int[] { type1, type2 };\n        }\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1523566860","body":"### 思路\n\nBackTrack\n\n### 代码\n\n```C#\n\n      IList<IList<int>> Ilist = new List<IList<int>>();\n    List<int> list = new List<int>();\n\n    public IList<IList<int>> Subsets(int[] nums) {\n        BackTrack(nums, 0);\n        return Ilist;\n    }\n\n    public void BackTrack(int[] nums, int Idx){\n        Ilist.Add(new List<int>(list));\n        if(Idx >= nums.Length)       \n            return;\n\n        for(int i = Idx; i < nums.Length; i++)\n        {\n            list.Add(nums[i]);\n            BackTrack(nums, i + 1);\n            list.RemoveAt(list.Count - 1);\n        }\n    }\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1525825699","body":"\n### 代码\n\n```C#\n  public class Trie\n        {\n            bool isEnd;\n            Trie[] childTries = new Trie[26];\n\n            public void Insert(string word)\n            {\n                Trie current = this;\n                foreach (var c in word)\n                {\n                    current.childTries[c - 'a'] ??= new Trie();\n                    current = current.childTries[c - 'a'];\n                }\n\n                current.isEnd = true;\n            }\n\n            public bool Search(string word)\n            {\n                Trie current = this;\n                foreach (var c in word)\n                {\n                    if (current.childTries[c - 'a'] == null) return false;\n                    current = current.childTries[c - 'a'];\n                }\n\n                return current.isEnd;\n            }\n\n            public bool StartsWith(string prefix)\n            {\n                Trie current = this;\n                foreach (var c in prefix)\n                {\n                    if (current.childTries[c - 'a'] == null) return false;\n                    current = current.childTries[c - 'a'];\n                }\n\n                return true;\n            }\n        }\n\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1527588091","body":"\n### 代码\n\n```C#\n\n    public class MapSum\n    {\n        Dictionary<string, int> dictionary;\n\n        public MapSum()\n        {\n            dictionary = new Dictionary<string, int>();\n        }\n\n        public void Insert(string key, int val)\n        {\n            if (dictionary.ContainsKey(key))\n            {\n                dictionary[key] = val;\n            }\n            else\n            {\n                dictionary.Add(key, val);\n            }\n        }\n\n        public int Sum(string prefix)\n        {\n            int res = 0;\n            foreach (KeyValuePair<string, int> pair in dictionary)\n            {\n                if (pair.Key.StartsWith(prefix))\n                {\n                    res += pair.Value;\n                }\n            }\n            return res;\n        }\n    }\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528801154","body":"\n```C#\n\n        private int[][] res;\n        private string gbig;\n        public int[][] MultiSearch(string big, string[] smalls)\n        {\n            res = new int[smalls.Length][];\n            gbig = big;\n            for (int i = 0; i < smalls.Length; i++)\n            {\n                MultiSeachBuild(i, smalls[i]);\n            }\n            return res;\n        }\n\n        public void MultiSeachBuild(int position, string s)\n        {\n            if (s == \"\" || gbig == \"\")\n            {\n                res[position] = new int[0];\n                return;\n            }\n            int index = 0;\n            List<int> ls = new List<int>();\n            while ((index = gbig.IndexOf(s, index) + 1) != 0) \n            {\n                ls.Add(index - 1);\n            }\n            res[position] = ls.ToArray();\n        }\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1529052641","body":"### 思路\n\ndfs\n\n### 代码\n\n```javascript\n\n      var findCircleNum = function(isConnected) {\n        const cities = isConnected.length;\n        const visited = new Set();\n        let provinces = 0;\n        for (let i = 0; i < cities; i++) {\n            if (!visited.has(i)) {\n                dfs(isConnected, visited, cities, i);\n                provinces++;\n            }\n        }\n        return provinces;\n    };\n\n    const dfs = (isConnected, visited, cities, i) => {\n        for (let j = 0; j < cities; j++) {\n            if (isConnected[i][j] == 1 && !visited.has(j)) {\n                visited.add(j);\n                dfs(isConnected, visited, cities, j);\n            }\n        }\n    };\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n*n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1529823085","body":"### 思路\n\n未做出 记录一种做法\n\n### 代码\n\n```csharp\n\n int[] fa;\n    public int MinMalwareSpread(int[][] graph, int[] initial)\n    {\n        int n = graph.Length;\n        fa = new int[n];\n        for (int i = 0; i < n; i++) fa[i] = i;\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                if(graph[i][j] == 1) fa[Find(i)] = Find(j); //并查集\n            }\n        }\n        int[] nexts = new int[n];\n        for (int i = 0; i < n; i++) nexts[Find(i)]++; //计算每个集合的数量\n        Dictionary<int, int> initFaCnt = new Dictionary<int, int>();\n        for (int i = 0; i < initial.Length; i++)\n        {\n            int v = initial[i];\n            if (!initFaCnt.ContainsKey(Find(v))) initFaCnt[Find(v)] = 0;\n            initFaCnt[Find(v)]++; //统计初始值里属于同一个集合的数量\n        }\n        Array.Sort(initial, (A, B) =>\n        {\n            int cntA = initFaCnt[Find(A)];\n            int cntB = initFaCnt[Find(B)];\n            if(cntA == 1 && cntB > 1) return -1;\n            if(cntA > 1 && cntB == 1) return 1; //查看AB是否是各自集合的唯一元素\n            if(cntA == 1 && cntB == 1)\n            {\n                //只有AB都是各自集合唯一的元素时，才会比较两个集合的size\n                int ret = nexts[Find(B)] - nexts[Find(A)];\n                if(ret != 0) return ret;\n            }\n            return A - B;\n        });\n        return initial[0];\n    }\n\n    private int Find(int x)\n    {\n        return fa[x] == x ? x : (fa[x] = Find(fa[x]));\n    }\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1531691069","body":"### 思路\n\n并查集\n\n### 代码\n\n```typescript\n\n    class UnionFind {\n        private parents: Array<number>\n        private sizes: Array<number>\n        private extraCables: number\n        private numOfSets: number\n\n        constructor(size: number) {\n            this.parents = Array(size)\n                .fill(0)\n                .map((_, i) => i)\n            this.sizes = Array(size).fill(1)\n            this.extraCables = 0\n            this.numOfSets = size\n        }\n\n        size(): number {\n            return this.numOfSets\n        }\n\n        getExtraCables(): number {\n            return this.extraCables\n        }\n\n        findSet(x: number): number {\n            if (x !== this.parents[x]) {\n                this.parents[x] = this.findSet(this.parents[x])\n            }\n            return this.parents[x]\n        }\n\n        unionSet(x: number, y: number): void {\n            const px: number = this.findSet(x)\n            const py: number = this.findSet(y)\n            if (px === py) {\n                this.extraCables++\n                return\n            }\n            if (this.sizes[px] > this.sizes[py]) {\n                this.parents[py] = px\n                this.sizes[px] += this.sizes[py]\n            } else {\n                this.parents[px] = py\n                this.sizes[py] += this.sizes[px]\n            }\n            this.numOfSets--\n        }\n    }\n\n    function makeConnected(n: number, connections: number[][]): number {\n        const uf: UnionFind = new UnionFind(n)\n        for (let c of connections) {\n            uf.unionSet(c[0], c[1])\n        }\n        return uf.getExtraCables() >= uf.size() - 1 ? uf.size() - 1 : -1\n    };\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(m+n)\n- 空间复杂度：O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1532947028","body":"### 思路\n\n递归\n\n### 代码\n\n```javascript\n\n    function pruneTree(root: TreeNode | null): TreeNode | null {\n        if (root == null) return null\n        root.left = pruneTree(root.left)\n        root.right = pruneTree(root.right)\n        if (root.left != null || root.right != null) return root\n        return root.val == 0 ? null : root\n    };\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1535005110","body":"### 思路\n\n回溯\n\n### 代码\n\n```typescript\nfunction combinationSum(candidates: number[], target: number): number[][] {\n  candidates.sort((a, b) => -b + a);\n  const ans: number[][] = [];\n  dfs(candidates, target, [], (path: number[]) => ans.push(path));\n  return ans;\n}\n\nfunction dfs(\n  candidates: number[],\n  target: number,\n  path: number[],\n  output: (path: number[]) => void\n) {\n  if (target === 0) {\n    output(path);\n    return;\n  }\n  for (const [index, can] of candidates.entries()) {\n    if (target >= can) {\n      dfs(\n        index ? candidates.slice(index) : candidates,\n        target - can,\n        [...path, can],\n        output\n      );\n    } else {\n      return;\n    }\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1536382852","body":"### 思路\n\n回溯\n\n### 代码\n\n```typescript\nfunction combinationSum2(candidates: number[], target: number): number[][] {\n  candidates.sort((a, b) => -b + a);\n  const ans: number[][] = [];\n\n  dfs(candidates, target, [], function (path: number[]) {\n    return ans.push(path);\n  });\n  return ans;\n}\n\nfunction dfs(\n  candidates: number[],\n  target: number,\n  path: number[],\n  output: (path: number[]) => void\n) {\n  if (target === 0) {\n    output(path);\n    return;\n  }\n\n  for (const [index, can] of candidates.entries()) {\n    if (target >= can) {\n      if (\n        !(candidates[index - 1] && candidates[index] === candidates[index - 1])\n      ) {\n        dfs(candidates.slice(index + 1), target - can, [...path, can], output);\n      }\n    } else {\n      return;\n    }\n  }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1537154321","body":"function permuteUnique(nums: number[]): number[][] {\n    nums.sort((a, b) => b - a)\n\n    let res: Array<Array<number>> = []\n    let path: number[] = []\n    let used: boolean[] = [] \n\n    backtrack(used)\n    return res\n\n    function backtrack(used: boolean[]): void {\n        if (path.length === nums.length) {\n            res.push([...path])\n            return\n        }\n\n        for (let i = 0; i < nums.length; i++) {\n            let num = nums[i]\n\n            // 这个数使用过了，跳过\n            if (nums[i] === nums[i - 1] && !used[i - 1]) {\n                continue\n            }\n\n            // 这个数没有被使用过\n            if (!used[i]) {\n                used[i] = true\n                path.push(num)\n                backtrack(used)\n                path.pop()\n                used[i] = false\n            }\n        }\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null],"northseacoder":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429682330","body":"## 思路\n- 利用 number 自动进位\n- 每次取数组未运算的最小位置直接加上 k 并取结果最末位 unshift 到结果数组内\n- nums 取完时需要考虑有多余进位\n- 计算时间复杂度时,当 k>num 时,循环次数为 log k(k 每次循环除 10)\n## 代码\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    let index = num.length - 1;\n    let sum = k;\n    while (index >= 0 || sum > 0) {\n        if (index >= 0) {\n            sum += num[index];\n            index--;\n        }\n        res.unshift(sum % 10);\n        sum = Math.floor(sum / 10);\n    }\n    return res;\n};\n```\n### 复杂度\n- 时间复杂度: O(max(n,log k));\n- 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430666807","body":"## 思路\n- 两次遍历\n- j 用来保留上次字符出现的位置\n- 从左往右获取左侧距离\n- 从右往左获取右侧距离\n\n## 代码\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    const n = s.length;\n    const res = new Array(n).fill(Infinity);\n    for (let i = 0, j = -1; i < n; i++) {\n        if (s.at(i) === c) j = i;\n        if (j !== -1) res[i] = i - j;\n    }\n    for (let i = n - 1, j = -1; i >= 0; i--) {\n        if (s.at(i) === c) j = i;\n        if (j !== -1) res[i] = Math.min(res[i], j - i);\n    }\n    return res;\n};\n```\n## 复杂度\n- TC:O(n)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432315252","body":"## 思路\n- 利用js 原生数组模拟栈\n\n## 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = [];\n    this.size = maxSize;\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length < this.size) this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.stack.pop() ?? -1;\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for (let i = 0; i < Math.min(this.stack.length, k); i++) {\n        this.stack[i] += val;\n    }\n};\n```\n## 复杂度\n- SC: O(n)\n- TC: push:O(1),pop:O(1),increment:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434022191","body":"## 思路\n- 双栈分别记录字符串和数字\n- 注意数字的判断\n\n## 代码\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    const repeatStack = [];\n    const resStack = [];\n    let repeat = 0;\n    let res = '';\n    for (let char of s) {\n        if (!Number.isNaN(Number(char))) {\n            //数字\n            repeat = repeat * 10 + Number(char);\n        } else if (char === '[') {\n            //获取新的 repeat 和 res\n            resStack.push(res);\n            res = '';\n            repeatStack.push(repeat);\n            repeat = 0;\n        } else if (char === ']') {\n            //计算当前值\n            const repeatTimes = repeatStack.pop();\n            res = resStack.pop() + res.repeat(repeatTimes);\n        } else {\n            //字符串\n            res += char;\n        }\n    }\n    return res\n};\n\n## 复杂度\n- TC:O(n)\n- SC:O(n)\n```\n\n## 思路(dfs)\n- 核心逻辑一样,只是用递归替换栈\n## 代码\n```js\nvar decodeString = function(s) {\n    const queue = s.split('');\n    const dfs = (q) => {\n        let res = '';\n        let repeat = 0;\n        while (q.length) {\n            const char = q.shift();\n            if (!Number.isNaN(Number(char))) {\n                repeat = repeat * 10 + Number(char);\n            } else if (char === '[') {\n                const tmp = dfs(q);\n                res += tmp.repeat(repeat);\n                repeat = 0;\n            } else if (char === ']') {\n                return res;\n            } else {\n                res += char;\n            }\n        }\n        return res\n    };\n    return dfs(queue);\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435693857","body":"## 思路\n- 将一个栈里面的元素全部弹出，然后压入另一个栈在弹出来就变成了反转后的顺序\n\n## 代码\n```js\nvar MyQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n    return this.outStack.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n    return this.outStack.at(-1);\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.inStack.length && !this.outStack.length;\n};\n\n```\n\n## 复杂度\n- TC:push/empty O(1);peek/pop:O(n);\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435814610","body":"## 思路\n- 将块分别进行排序并使得连接的结果和按升序排序后的原数组相同。需要保证当前块的最大值要小于后面块的任意值;\n- 每一块的最大值必然大于前一块的最大值,有多少个最大值就有多少个块\n- 单调栈\n\n## 代码\n\n```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    const stack = [];\n    arr.forEach((val) => {\n        if (stack.length && val < stack.at(-1)) {\n            const top = stack.pop();\n            while (stack.length && val < stack.at(-1)) stack.pop();\n            stack.push(top);\n        } else {\n            stack.push(val);\n        }\n    });\n    return stack.length;\n};\n\n```\n\n## 复杂度\n- TC:O(n)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436207578","body":"## 代码 (环)\n```js\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (!head || !head.next || k === 0) return head;\n    let point = head;\n    let length = 1;\n    while (point.next) {\n        length++;\n        point = point.next;\n    }\n    if (k % length === 0) return head;\n\n    let n = length - (k % length);\n    //构建环\n    point.next = head;\n    //找到新链表头结点的前驱节点:n+k = length\n    while (n > 0) {\n        point = point.next;\n        n--;\n    }\n    let newHead = point.next;\n    point.next = null;\n    return newHead;\n};\n```\n## 复杂度\n- TC: O(n)\n- SC:O(1)\n\n## 代码(双指针)\n```js\nvar rotateRight = function(head, k) {\n    if (!head || !head.next || k === 0) return head;\n    let point = head;\n    let length = 1;\n    while (point.next) {\n        length++;\n        point = point.next;\n    }\n    if (k % length === 0) return head;\n\n    let n = k % length;\n\n    let fast = head;\n    let slow = head;\n    //先移动 fast\n    while (n > 0) {\n        fast = fast.next;\n        n--;\n    }\n    //同步移动,最终 slow 为新链表头结点前驱节点\n    while (fast.next) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    fast.next = head;\n    head = slow.next;\n    slow.next = null;\n    return head;\n};\n```\n## 复杂度\n- TC: O(n)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437764849","body":"## 代码(递归)\n```js\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    if (!head || !head.next) return head;\n    const next = head.next;\n    //获取交换后的链表\n    head.next = swapPairs(next.next);\n    //交换当前节点\n    next.next = head;\n    return next\n};\n```\n## 复杂度\n- TC:O(n);\n- SC:O(n)\n\n## 代码(迭代)\n```js\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    if (!head || !head.next) return head;\n    //虚拟头结点\n    const newHead = new ListNode(0, head);\n    let point = newHead;\n    while (point.next && point.next.next) {\n        const pre = point.next;\n        const post = point.next.next;\n        //指针指向 post,post 为首位;\n        point.next = post;\n        //pre 指向后续节点,pre 此时为第二位;\n        pre.next = post.next;\n        //post 指向 pre,交换完成\n        post.next = pre;\n        //指针移至 pre 进入下一步迭代\n        point = pre;\n    }\n    return newHead.next;\n};\n```\n## 复杂度\n- TC:O(n);\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439429591","body":"## 双指针\n\n```js\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    //递归结束\n    if (!head) return head;\n    let fast = head;\n    let slow = head;\n    let pre;\n    //找到中间节点做为根节点\n    while (fast && fast.next) {\n        pre = slow;\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    const root = new TreeNode(slow.val);\n    if (pre) {\n        //没有左子树的情况\n        pre.next = null;\n        root.left = sortedListToBST(head);\n    }\n    //右子树为 slow.next\n    root.right = sortedListToBST(slow.next);\n    return root;\n};\n```\n- TC:O(nlogn):递归 logn,每层递归循环一次找中点 n\n-  SC:O(logn)\n\n## 转成有序数组\n```js\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    let point = head;\n    const arr = [];\n    //转成有序数组\n    while (point) {\n        arr.push(point.val);\n        point = point.next;\n    }\n\n    const build = (start, end) => {\n        //递归中止条件\n        if (start > end) return null;\n        //取中间值\n        const midIndex = start + Math.floor((end - start) / 2);\n        const mid = arr[midIndex];\n        const root = new TreeNode(mid);\n        root.left = build(start, midIndex - 1);\n        root.right = build(midIndex + 1, end);\n        return root\n    };\n    return build(0, arr.length - 1);\n};\n```\n- TC:O(n)\n- SC:O(n)\n\n## 优化\n```js\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    let point = head;\n    let len = 0;\n    //计算链表长度\n    while (point) {\n        len++;\n        point = point.next;\n    }\n    let node = head;\n    const build = (start, end) => {\n        //递归中止条件\n        if (start > end) return null;\n        //取中间值\n        const midIndex = start + Math.floor((end - start) / 2);\n        //中序遍历优化\n        const left = build(start, midIndex - 1);\n        \n        const root = new TreeNode(node.val);\n        node = node.next;\n        root.left = left;\n\n        root.right = build(midIndex + 1, end);\n        return root;\n    };\n    return build(0, len - 1);\n};\n\n```\n- TC:O(n) \n- SC:O(logn) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441133283","body":"## 双指针\n``` js\nvar getIntersectionNode = function(headA, headB) {\n    if (headA === null || headB === null) {\n        return null;\n    }\n    let pointA = headA;\n    let pointB = headB;\n    while (pointA !== pointB) {\n        pointA = pointA ? pointA.next : headB;\n        pointB = pointB ? pointB.next : headA;\n    }\n    //如果相交,则此时为相交节点,\n    //如果不相交,则此时为 null\n    return pointA;\n};\n```\n- TC:O(m+n);\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442711471","body":"## 快慢指针\n\n```js\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if (!head || !head.next) return null;\n    //循环时需要 fast 跟 slow 不相等,所以先走一步\n    let fast = head.next.next;\n    let slow = head.next;\n    while (slow != fast && fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    //没有环\n    if (slow != fast) return null;\n    let point = head;\n    //从相遇点到入环点和从 head 到相遇点节点数相同\n    while (point !== slow) {\n        point = point.next;\n        slow = slow.next;\n    }\n    return slow;\n};\n```\n- TC: O(n)\n- SC: O(1)\n\n## 哈希表\n```js\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    //至少 3 个节点才能成环\n    if (!head || !head.next) return null;\n    const set = new Set();\n    let point = head;\n    while (point) {\n        if (set.has(point)) return point;\n        set.add(point);\n        point = point.next;\n    }\n    return null;\n};\n```\n- TC:O(n)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1444979693","body":"## Map\n```js\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.size = capacity;\n    //Map对象能够保留键的插入顺序\n    this.map = new Map();\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    let val = -1;\n    if (this.map.has(key)) {\n        val = this.map.get(key);\n        this.map.delete(key);\n        //重新插入 map,调整顺序\n        this.map.set(key, val);\n    }\n    return val;\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if (this.map.has(key)) {\n        this.map.delete(key);\n    }\n    this.map.set(key, value);\n    if (this.map.size > this.size) {\n        //keys()返回一个迭代器对象,第一次调用 next 返回第一次被插入的数据\n        //此时为最近未使用过的数据\n        this.map.delete(this.map.keys().next().value);\n    }\n};\n```\n## 双向链表\n```js\nclass ListNode {\n    constructor(key, value) {\n        this.value = value;\n        this.key = key;\n        this.pre = null;\n        this.next = null;\n    }\n}\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.max = capacity;\n    //记录key-node\n    this.map = new Map();\n    //虚拟头尾\n    this.head = new ListNode();\n    this.tail = new ListNode();\n    this.head.next = this.tail;\n    this.tail.pre = this.head;\n    this.moveToHead = (node) => {\n        this.removeNode(node);\n        this.appendToHead(node);\n    };\n    this.removeNode = (node) => {\n        const pre = node.pre;\n        const next = node.next;\n        pre.next = next;\n        next.pre = pre;\n    };\n    this.appendToHead = (node) => {\n        node.pre = this.head;\n        node.next = this.head.next;\n        this.head.next.pre = node;\n        this.head.next = node;\n    };\n    this.limit = () => {\n        if (this.map.size > this.max) {\n            const node = this.tail.pre;\n            this.removeNode(node);\n            this.map.delete(node.key);\n        }\n    };\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (this.map.has(key)) {\n        const node = this.map.get(key);\n        this.moveToHead(node);\n        return node.value;\n    }\n    return -1;\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if (this.map.has(key)) {\n        const node = this.map.get(key);\n        node.value = value;\n        this.moveToHead(node);\n    } else {\n        const node = new ListNode(key, value);\n        this.appendToHead(node);\n        this.map.set(key, node);\n        this.limit();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445229926","body":"## dfs\n```js\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if (!root) return 0;\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n};\n```\n- TC:O(n)\n- SC:O(h)\n## bfs\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if (!root) return 0;\n    const queue = [root];\n    let depth = 0;\n    while (queue.length > 0) {\n        let len = queue.length;\n        while (len) {\n            const cur = queue.shift();\n            if(cur.left)queue.push(cur.left)\n            if(cur.right)queue.push(cur.right)\n            len--;\n        }\n        depth++;\n    }\n    return depth\n};\n```\n- TC:O(n)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445523164","body":"## DFS\n```js\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    if (!p && !q) return true;\n    if (!p || !q) return false;\n    if (p.val !== q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};\n```\n- TC:O(min(m,n))\n- SC:O(min(m,n))\n\n## BFS\n```js\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    if (!p && !q) return true;\n    if (!p || !q) return false;\n    const queue = [p, q];\n    while (queue.length) {\n        const curP = queue.shift();\n        const curQ = queue.shift();\n        //不执行下一步但继续循环\n        if (!curP && !curQ) continue;\n        \n        if (!curP || !curQ || curP.val !== curQ.val) return false;\n\n        queue.push(curP.left)\n        queue.push(curQ.left)\n\n        queue.push(curP.right)\n        queue.push(curQ.right)\n    }\n    return true;\n};\n```\n- TC:O(min(m,n))\n- SC:O(min(m,n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447453906","body":"## dfs\r\n```js\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar sumNumbers = function(root) {\r\n    const dfs = (node, sum) => {\r\n        if (!node) return 0;\r\n        sum = sum * 10 + node.val;\r\n        if (!node.left && !node.right) return sum;\r\n        return dfs(node.left, sum) + dfs(node.right, sum);\r\n    };\r\n    return dfs(root, 0);\r\n};\r\n```\r\n- TC:O(n)\r\n- SC: O(h)\r\n## bfs\r\n```js\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar sumNumbers = function(root) {\r\n    if (!root) return 0;\r\n    const queue = [root];\r\n    const valQueue = [root.val];\r\n\r\n    let sum = 0;\r\n    while (queue.length) {\r\n        const node = queue.shift();\r\n        const num = valQueue.shift();\r\n        const {left, right} = node;\r\n        if (!left && !right) {\r\n            sum += num;\r\n        } else {\r\n            if (left) {\r\n                queue.push(left);\r\n                valQueue.push(left.val + num * 10);\r\n            }\r\n            if (right) {\r\n                queue.push(right);\r\n                valQueue.push(right.val + num * 10);\r\n            }\r\n        }\r\n    }\r\n    return sum;\r\n};\r\n```\r\n- TC:O(n)\r\n- SC: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449095073","body":"## BFS\n```js\nvar findBottomLeftValue = function(root) {\n    //层序遍历\n    const queue = [root];\n    let res;\n    while (queue.length) {\n        const cur = queue.shift();\n        //先循环右节点,保证最后的是左节点\n        if (cur.right) queue.push(cur.right);\n        if (cur.left) queue.push(cur.left);\n        res = cur.val;\n    }\n    return res;\n};\n```\n- TC:O(n)\n- SC:O(n)\n## DFS\n```js\nvar findBottomLeftValue = function(root) {\n    let res;\n    let curHeight = -1;\n    const dfs = (node, height) => {\n        if (!node) return node;\n       //先序/中序/后序都可以,只要保证先遍历的是左节点\n        if (height > curHeight) {\n            curHeight = height;\n            res = node.val;\n        }\n        dfs(node.left, height + 1);\n        dfs(node.right, height + 1);\n    };\n\n    dfs(root, 0);\n    return res;\n};\n```\n- TC:O(n)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451040057","body":"## BFS\n\n```js\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    const queue = [root];\n    const res = [];\n    while (queue.length) {\n        const cur = queue.shift();\n        if (!cur) {\n            res.push('#');\n            continue;\n        }\n        res.push(cur.val);\n        queue.push(cur.left);\n        queue.push(cur.right);\n    }\n    return res.join(',');\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    if (data == '#') return null;\n    const arr = data.split(',');\n    const root = new TreeNode(arr[0]);\n    const queue = [root];\n    for (let i = 1; i < arr.length; i += 2) {\n        const node = queue.shift();\n        const leftVal = arr[i];\n        const rightval = arr[i + 1];\n        if (leftVal !== '#') {\n            const left = new TreeNode(leftVal);\n            queue.push(left);\n            node.left = left;\n        }\n        if (rightval !== '#') {\n            const right = new TreeNode(rightval);\n            queue.push(right);\n            node.right = right;\n        }\n    }\n    return root;\n};\n```\n- TC:O(n);\n- SC:O(n)\n\n## DFS\n\n```js\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    if (!root) return '#';\n    return `${root.val},${serialize(root.left)},${serialize(root.right)}`;\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    const list = data.split(',');\n    const dfs = () => {\n        const cur = list.shift();\n        if (cur === '#') return null;\n        const root = new TreeNode(cur);\n        root.left = dfs();\n        root.right = dfs();\n        return root;\n    };\n    return dfs();\n};\n```\n- TC:O(n);\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1452826114","body":"## DFS\n\n```js\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n    //key是列,value 是[row,val]\n    const nodes = {};\n    const dfs = (node, row, col) => {\n        if (node.left) dfs(node.left, row + 1, col - 1);\n        if (!nodes[col]) nodes[col] = [];\n        nodes[col].push([row, node.val]);\n        if (node.right) dfs(node.right, row + 1, col + 1);\n    };\n    dfs(root, 0, 0);\n    return Object.entries(nodes)\n        .sort(([col1], [col2]) => +col1 - col2)\n        .map(([, arr]) => arr.sort(([row1, val1], [row2, val2]) => row1 - row2 || val1 - val2).map(([, val]) => val));\n};\n```\n\n- TC:O(n)\n- O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454727765","body":"## 哈希表\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    //{[target-val]:key}\n    const map = new Map();\n    const res = [];\n    for (let i = 0; i < nums.length; i++) {\n        if (map.has(nums[i])) {\n            res.push(map.get(nums[i]), i);\n            break;\n        }\n        map.set(target - nums[i], i);\n    }\n    return res;\n};\n```\n- TC:O(n);\n- SC: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455019065","body":"## map\n```js\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function(nums, k) {\n    if (nums.length <= k) return nums;\n    const map = {};\n    for (let i = 0; i < nums.length; i++) {\n        if (map[nums[i]]) {\n            map[nums[i]]++;\n        } else {\n            map[nums[i]] = 1;\n        }\n    }\n    return Object.entries(map)\n        .sort(([, val1], [, val2]) => val2 - val1)\n        .map(([key]) => key)\n        .slice(0, k);\n};\n```\n- TC:O(nlogn)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455262673","body":"## map\n```js\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n    if (points.length <= 2) return 0;\n    let res = 0;\n    for (let point of points) {\n        const map = new Map();\n        for (let point2 of points) {\n            //相同点跳过\n            if (point === point2) continue;\n            const dist = getDistance(point, point2);\n            //统计与 point 距离相同的点,每个距离分别有多少个\n            map.set(dist, (map.get(dist) ?? 0) + 1);\n        }\n        for (let [, nums] of map.entries()) {\n            //在 nums 个元素中选出 2 个组成结果\n            //且考虑顺序,所以每种距离为 nums*(nums-1)\n            res += nums * [nums - 1];\n        }\n    }\n    return res;\n};\nconst getDistance = ([x1, y1], [x2, y2]) => {\n    return (x1 - x2) ** 2 + (y1 - y2) ** 2;\n};\n```\n- TC: O(n2)\n- SC: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457272893","body":"## map\n```js\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    let left = 0;\n    let right = 0;\n    let len = 0;\n    const map = new Map();\n    while (right < s.length) {\n        if (map.has(s[right])) {\n            //abba,\n            //第二次包含 right 时,map 内的值为 0\n            //需要选择 left 和 map 中最大的,才能将 left 移动到最右\n            left = Math.max(map.get(s[right]) + 1, left);\n        }\n        len = Math.max(len, right - left + 1);\n        map.set(s[right], right);\n        right++;\n    }\n    return len;\n};\n```\n- TC: O(n)\n- SC: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459088543","body":"```js\n// @lc code=start\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    const wordLen = words[0].length;\n    const len = wordLen * words.length;\n    const res = [];\n    if (s.length < len) return res;\n    const map = new Map();\n    words.forEach((word) => {\n        map.set(word, (map.get(word) || 0) + 1);\n    });\n    //i为串联子串起点,剩余字符数少于串联子串长度时,循环结束\n    for (let i = 0; i <= s.length - len; i++) {\n        const tempMap = new Map([...map]);\n        let count = words.length;\n        //遍历串联子串,\n        for (let j = i; j < i + len; j += wordLen) {\n            const word = s.slice(j, j + wordLen);\n            //当前单词不在 words 中\n            //或者已全部出现过\n            //中止循环\n            if (!tempMap.has(word) || tempMap.get(word) === 0) break;\n            //计算每个单词的出现次数\n            tempMap.set(word, tempMap.get(word) - 1);\n            //计算已遍历的单词数\n            count--;\n        }\n        //如果所有单词都出现过了,记录子串起点\n        if (count === 0) res.push(i);\n    }\n    return res;\n};\n```\n- TC:O((s.length-len)*count)\n- SC:O(count)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462088412","body":"```js\n/**\n * @param {number[]} nums\n * @param {number} p\n * @return {number}\n */\nvar minSubarray = function(nums, p) {\n    const len = nums.length;\n    let res = len;\n    const sum = nums.reduce((acc, cur) => acc + cur, 0);\n    const mod = sum % p;\n    //如果本身就能被整除,不需要移除任何元素\n    if (mod === 0) return 0;\n\n    const map = new Map([[mod, -1]]);\n    let subMod = 0;\n    //需要找到一个子区间sub(sum(i,j)),使得sub%p ==sum %p(即 mod)\n    //sub%p = mod;\n    //sub = sum(1-j)-sum(1-i);\n    //mod = sum(1-j)%p-sum(1-i)%p\n    //mod = targetMod - subMod\n    //targetMod = mod + subMod(两数之和)\n    //真!简单推导\n    for (let i = 0; i < nums.length; i++) {\n        const num = nums[i];\n        //前 i 个数的和的余数\n        subMod = (subMod + num) % p;\n        \n        //此时参考两数之和,map记录目标余数\n        //如果出目标余数,计算二者距离\n        if (map.has(subMod)) {\n            //记录最短的子数组长度\n            res = Math.min(res, i - map.get(subMod));\n            //当结果为1时不需要循环了,必然是 1\n            if (res === 1) return res;\n        }\n        //对 p 取余防止结果超过 p\n        map.set((subMod + mod) % p, i);\n    }\n    if (res === len) return -1;\n    return res;\n};\n```\n- TC :O(n)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463009494","body":"```js\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function(head) {\n    if (!head || !head.next) return head;\n    let slow = head;\n    let fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return slow\n};\n```\n- TC: O(n)\n- SC: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464864250","body":"```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    if (nums.length <= 1) return nums.length;\n    //fast 为查询位,slow 为插入位\n    let slow = 1;\n    let fast = 1;\n    while (fast < nums.length) {\n        if (nums[fast] !== nums[fast - 1]) {\n            //fast 跟前一个值不相同,当前值插入 slow\n            nums[slow] = nums[fast];\n            slow++;\n        }\n        fast++;\n    }\n    return slow;\n};\n```\n- TC: O(n)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465075147","body":"```js\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    //O(logn)基本上就是二分了\n    let left = 0;\n    let right = nums.length - 1;\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return left;\n};\n```\n- TC:O(logn)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465348645","body":"```js\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function(nums, k) {\n    //单调递减队列,保存下标\n    const queue = [];\n    const res = [];\n    for (let i = 0; i < nums.length; i++) {\n        while (queue.length && nums[i] >= nums[queue.at(-1)]) {\n            //保持队列,单调递减\n            //当入队元素大于队尾时,队尾元素出队(pop:移除数组最后一个元素)\n            queue.pop();\n        }\n        //此时队尾元素大于当前待入队元素\n        queue.push(i);\n        //i-k:窗口前端下标\n        //队首元素:当前队列最大值\n        //判断队首元素是否在窗口内\n        while (queue[0] <= i - k) {\n            queue.shift();\n        }\n        //当 i>=k-1 时,i 遍历过 k 个元素\n        //即此时以满足窗口大小\n        if (i >= k - 1) res.push(nums[queue[0]]);\n    }\n    return res;\n};\n```\n- TC: O(n)\n- SC: O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467167490","body":"```js\n/**\n * @param {number} n\n * @param {number[][]} trust\n * @return {number}\n */\nvar findJudge = function(n, trust) {\n    //找到一个有 n-1 个入度,0 个出度的节点\n    //入度\n    const to = new Array(n + 1).fill(0);\n    //出度\n    const from = new Array(n + 1).fill(0);\n    for (let [a, b] of trust) {\n        from[a]++;\n        to[b]++;\n    }\n    for (let i = 1; i <= n; i++) {\n        if ((from[i] === 0 && to[i] === n - 1)) return i;\n    }\n    return -1;\n};\n```\n- TC:O(trust.length+n)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469064793","body":"```js\n/**\n * @param {number} n\n * @param {number[][]} dislikes\n * @return {boolean}\n */\nvar possibleBipartition = function(n, dislikes) {\n    //染色法\n    //构建一个与点数相等的数组 color，\n    //我们人为规定划分到集合 A 的点满足 color[i]=1，\n    //划分到集合 B 的点满足 color[i]=2，起始有 color[i]=0，代表该点尚未被划分。\n    const color = new Array(n + 1).fill(0);\n    //dis 二维数组,dis[i]表示不能和 i 分在一起的人\n    const dis = new Array(n + 1).fill(0).map(() => new Array());\n    for (let g of dislikes) {\n        dis[g[0]].push(g[1]);\n        dis[g[1]].push(g[0]);\n    }\n    const dfs = (i, newColor) => {\n        //给当前值染色\n        color[i] = newColor;\n        for (let p of dis[i]) {\n            //p:不能和 i 分在一起的人\n            //如果 p 已被染色,且与 i 同一个颜色,false\n            if (color[p] !== 0 && color[p] === color[i]) return false;\n            //p 未染色,找他不喜欢的人染色\n            //3^newColor:color 只有 1,2 两个值,3^1=2;3^2=1,简单的交换 1 与 2\n            if (color[p] === 0 && !dfs(p, 3 ^ newColor)) return false;\n        }\n        return true;\n    };\n    for (let i = 1; i <= n; i++) {\n        if (color[i] === 0 && !dfs(i, 1)) return false;\n    }\n    return true;\n};\n```\n- TC: O(n+dislikes.length)\n- SC: O(n+dislikes.length)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1471114098","body":"```js\n//先看懂....\n/**\n * @param {number} n\n * @param {number} m\n * @param {number[]} group\n * @param {number[][]} beforeItems\n * @return {number[]}\n */\nvar sortItems = function(n, m, group, beforeItems) {\n    // 思路，拓扑排序，建立组间依赖和组内依赖\n    // 先排序组间依赖，之后再依照排序好的组间依赖，对每个组排序组内依赖\n    let res = [];\n    //组id的graph\n    const groupGraph = new Map();\n    //对应每个组的组内的graph\n    const itemGraph = new Map();\n    //每个group中的所有item\n    const groupItemMap = new Map();\n    //对于-1的组（不属于任何组），我们要对它们从m开始赋予不同的组，不然-1会被认为是同一个组\n    let maxGroupNum = m;\n    for (let i = 0; i < n; i++) {\n        if (group[i] === -1) {\n            group[i] = maxGroupNum;\n            maxGroupNum++;\n        }\n    }\n    // 建立groupItemMap\n    for (let i = 0; i < n; i++) {\n        if (!groupItemMap.has(group[i])) groupItemMap.set(group[i], []);\n        groupItemMap.get(group[i]).push(i);\n    }\n    //建立依赖图\n    for (let i = 0; i < beforeItems.length; i++) {\n        let afterItemId = i;\n        let beforeItemIds = beforeItems[i];\n        for (let beforeItemId of beforeItemIds) {\n            let beforeGroupId = group[beforeItemId],\n                afterGroupId = group[afterItemId];\n            if (beforeGroupId !== afterGroupId) {\n                // 建立组间依赖\n                if (!groupGraph.has(beforeGroupId)) groupGraph.set(beforeGroupId, []);\n                groupGraph.get(beforeGroupId).push(afterGroupId);\n            } else {\n                // 建立组内依赖\n                if (!itemGraph.has(beforeGroupId)) itemGraph.set(beforeGroupId, new Map());\n                if (!itemGraph.get(beforeGroupId).has(beforeItemId)) itemGraph.get(beforeGroupId).set(beforeItemId, []);\n                itemGraph\n                    .get(beforeGroupId)\n                    .get(beforeItemId)\n                    .push(afterItemId);\n            }\n        }\n    }\n    // 1. 首先对组间依赖进行拓扑排序\n    let groupDegrees = Array(maxGroupNum).fill(0);\n    groupGraph.forEach((values) => values.forEach((value) => groupDegrees[value]++));\n    let sortedGroupList = topoSort(groupDegrees, groupGraph, maxGroupNum);\n\n    // 2. 再根据每个组进行组内的拓扑排序\n    let items, itemDegrees, sortedItemList;\n    for (let groupId of sortedGroupList) {\n        if (!groupItemMap.has(groupId)) continue; // 注意题目，A group can have no item belonging to it\n        items = groupItemMap.get(groupId);\n        if (!itemGraph.has(groupId)) {\n            // 这个group里的item没有依赖关系，则直接加入\n            res = res.concat(items);\n        } else {\n            // 有组内依赖关系，则拓扑排序\n            itemDegrees = Array(n).fill(-1);\n            items.forEach((item) => (itemDegrees[item] = 0)); // 存在的item置为0\n            itemGraph.get(groupId).forEach((values) => values.forEach((value) => itemDegrees[value]++));\n            sortedItemList = topoSort(itemDegrees, itemGraph.get(groupId), items.length);\n            if (sortedItemList.length === 0) return []; // 如果返回一个空数组，则说明不能完成拓扑排序，则是不可能的情况\n            res = res.concat(sortedItemList);\n        }\n    }\n    return res;\n};\nconst topoSort = (degrees, graph, len) => {\n    const res = [],\n        q = [];\n    for (let i = 0; i < degrees.length; i++) {\n        if (degrees[i] === 0) q.push(i);\n    }\n    while (q.length !== 0) {\n        let item = q.shift();\n        res.push(item);\n        if (graph.has(item)) {\n            for (let child of graph.get(item)) {\n                degrees[child]--;\n                if (degrees[child] === 0) q.push(child);\n            }\n        }\n    }\n    return res.length === len ? res : []; // ans的长度不等于传入的长度，则说明不能完成拓扑排序，返回空数组\n};\n```\n- TC:O(n+m)\n- SC:O(n+m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1472945962","body":"```js\n/**\n * @param {string} moves\n * @return {boolean}\n */\nvar judgeCircle = function(moves) {\n    let x = 0;\n    let y = 0;\n    for (let i = 0; i < moves.length; i++) {\n        const cur = moves[i];\n        switch (cur) {\n            case 'U':\n                x++;\n                break;\n            case 'D':\n                x--;\n                break;\n            case 'L':\n                y--;\n                break;\n            case 'R':\n                y++;\n                break;\n        }\n    }\n    return x === 0 && y === 0;\n};\n```\n- TC:O(n)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474851222","body":"```js\n/**\n * @param {number[][]} tasks\n * @return {number[]}\n */\nvar getOrder = function(tasks) {\n    const newTasks = tasks.map(([start, time], index) => ({index, start, time}));\n    //先按照开始时间排序从大到小,pop 比 shift 复杂度低\n    newTasks.sort((a, b) => b.start - a.start);\n    //time 短优先,否则下标靠前优先(小顶堆)\n    const heap = new Heap((a, b) => {\n        if (a.time !== b.time) return a.time < b.time;\n        return a.index < b.index;\n    });\n    const res = [];\n    let time = 0;\n    while (heap.size() || newTasks.length) {\n        // 如果任务队列为空，直接将时间快进到下一项要入列的任务的开始时间\n        if (heap.isEmpty()) time = Math.max(time, newTasks.at(-1).start);\n        //将所有开始时间小于当前时间戳的任务都入列(等待执行的任务)\n        while (newTasks.length && newTasks.at(-1).start <= time) {\n            heap.push(newTasks.pop());\n        }\n        //弹出优先级最高的任务开始执行\n        const task = heap.shift();\n        time += task.time;\n        res.push(task.index);\n    }\n    return res;\n};\nclass Heap {\n    constructor(compare) {\n        this.nodes = [];\n        this.compare = compare;\n    }\n    //返回堆的大小\n    size() {\n        return this.nodes.length;\n    }\n    isEmpty() {\n        return this.size() === 0;\n    }\n    //根据传入的比较函数比较两个节点并返回比较结果,true 符合,false 不符合\n    compareAt(i, j) {\n        return this.compare(this.nodes[i], this.nodes[j]);\n    }\n    //交换节点\n    swap(i, j) {\n        [this.nodes[i], this.nodes[j]] = [this.nodes[j], this.nodes[i]];\n    }\n    shouldSwap(parentIndex, childIndex) {\n        if (parentIndex < 0 || parentIndex >= this.size()) return false;\n        if (childIndex < 0 || childIndex >= this.size()) return false;\n        return !this.compareAt(parentIndex, childIndex);\n    }\n    hasLeftChild(parentIndex) {\n        const left = 2 * parentIndex + 1;\n        return left < this.size();\n    }\n    hasRightChild(parentIndex) {\n        const right = 2 * parentIndex + 2;\n        return right < this.size();\n    }\n    //获取符合条件的子节点,没有则返回-1\n    compareChildOf(parentIndex) {\n        if (!this.hasLeftChild(parentIndex) && !this.hasRightChild(parentIndex)) return -1;\n        const leftChildIndex = 2 * parentIndex + 1;\n        const rightChildIndex = 2 * parentIndex + 2;\n        if (!this.hasLeftChild(parentIndex)) return rightChildIndex;\n        if (!this.hasRightChild(parentIndex)) return leftChildIndex;\n        return this.compareAt(leftChildIndex, rightChildIndex) ? leftChildIndex : rightChildIndex;\n    }\n    heapifyUp(startIndex) {\n        let childIndex = startIndex;\n        let parentIndex = Math.floor((childIndex - 1) / 2);\n        while (this.shouldSwap(parentIndex, childIndex)) {\n            this.swap(parentIndex, childIndex);\n            childIndex = parentIndex;\n            parentIndex = Math.floor((childIndex - 1) / 2);\n        }\n    }\n    heapifyDown(startIndex) {\n        let parentIndex = startIndex;\n        let childIndex = this.compareChildOf(parentIndex);\n        while (this.shouldSwap(parentIndex, childIndex)) {\n            this.swap(parentIndex, childIndex);\n            parentIndex = childIndex;\n            childIndex = this.compareChildOf(parentIndex);\n        }\n    }\n    push(value) {\n        this.nodes.push(value);\n        this.heapifyUp(this.size() - 1);\n\n        return this;\n    }\n    shift() {\n        if (this.isEmpty()) return null;\n        const root = this.nodes[0];\n        //不能直接 pop,当 size==1 时会死循环\n        this.nodes[0] = this.nodes.at(-1);\n        this.nodes.pop();\n        this.heapifyDown(0);\n        return root;\n    }\n}\n```\n- TC:O(nlogn)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475053291","body":"```js\n/**\n * @param {string} loginTime\n * @param {string} logoutTime\n * @return {number}\n */\nvar numberOfRounds = function(loginTime, logoutTime) {\n    let [startHour, startMinute] = loginTime.split(':').map((val) => +val);\n    let [endHour, endMinute] = logoutTime.split(':').map((val) => +val);\n    startMinute += 60 * startHour;\n    endMinute += 60 * endHour;\n    if (endMinute < startMinute) endMinute += 1440;\n    //结束时间前最后一场比赛完成时间\n    endMinute = Math.floor(endMinute / 15) * 15;\n    //前一步可能会导致 endMinute<startMinute\n    return Math.floor(Math.max(0, endMinute - startMinute) / 15);\n};\n```\n- TC:O(1)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475456567","body":"```js\n/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\nvar minCharacters = function(a, b) {\n    const lenA = a.length;\n    const lenB = b.length;\n    //统计每个字符串中各个字符出现的频率\n    const countA = new Array(26).fill(0);\n    const countB = new Array(26).fill(0);\n    for (let i = 0; i < lenA; i++) {\n        countA[a[i].charCodeAt() - 'a'.charCodeAt()]++;\n    }\n    for (let i = 0; i < lenB; i++) {\n        countB[b[i].charCodeAt() - 'a'.charCodeAt()]++;\n    }\n    let res = Infinity;\n    for (let i = 0; i < 26 && res !== 0; i++) {\n        //将 a,b 都变成当前循环字符(条件三)的步数\n        const stepA = lenA - countA[i];\n        const stepB = lenB - countB[i];\n        //总修改字符数\n        res = Math.min(res, stepA + stepB);\n        //无法将 a,b 字符串中字符修改为<a 的字母(不存在)\n        if (i === 0) continue;\n        //a<b(条件1)\n        let res1 = 0;\n        //a 中字符修改为< 当前循环字符的修改数(a中>= i 的字符数)\n        for (let j = i; j < 26; j++) {\n            res1 += countA[j];\n        }\n        //b 中字符修改为>=i 的修改数 (b 中<i 的字符数)\n        for (let j = 0; j < i; j++) {\n            res1 += countB[j];\n        }\n        //b<a(条件 2)\n        let res2 = 0;\n        //b 中字符修改为< 当前循环字符的修改数(b中>= i 的字符数)\n        for (let j = i; j < 26; j++) {\n            res2 += countB[j];\n        }\n        //a 中字符修改为>=i 的修改数 (a 中<i 的字符数)\n        for (let j = 0; j < i; j++) {\n            res2 += countA[j];\n        }\n        res = Math.min(res, Math.min(res1, res2));\n    }\n    return res;\n};\n```\n- TC:O(max(lenA+lenB,26^2))\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477130477","body":"```js\n/**归并\n * @param {number[]} nums\n * @return {number[]}\n */\nvar sortArray = function(nums) {\n    if (nums.length === 1) return nums;\n    const mid = Math.floor(nums.length / 2);\n    //slice不包括 end\n    return merge(sortArray(nums.slice(0, mid)), sortArray(nums.slice(mid)));\n};\nconst merge = (arr1, arr2) => {\n    const res = [];\n    while (arr1.length && arr2.length) {\n        if (arr1[0] < arr2[0]) {\n            res.push(arr1.shift());\n        } else {\n            res.push(arr2.shift());\n        }\n    }\n\n    if (arr1.length) res.push(...arr1);\n    if (arr2.length) res.push(...arr2);\n    return res;\n};\n```\n- TC:O(nlogn)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1478926378","body":"```js\n/**\n * @param {number} x\n * @return {number}\n */\nvar mySqrt = function(x) {\n    if (x <= 1) return x;\n    let start = 0;\n    let end = x;\n    while (start <= end) {\n        const mid = Math.floor((start + end) / 2);\n        const val = mid * mid;\n        if (val === x) return mid;\n        if (val < x) {\n            start = mid + 1;\n        } else {\n            end = mid - 1;\n        }\n    }\n    //循环条件是 end>=start,结束时 end<start\n    return end;\n};\n```\n- TC:O(logn)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1481261804","body":"```js\n/**\n * @param {function} isBadVersion()\n * @return {function}\n */\nvar solution = function(isBadVersion) {\n    /**\n     * @param {integer} n Total versions\n     * @return {integer} The first bad version\n     */\n    return function(n) {\n        let start = 0;\n        let end = n;\n        while (start <= end) {\n            const mid = Math.floor((start + end) / 2);\n            const res = isBadVersion(mid);\n            if (res) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        //end始终是 true 的前一个\n        //start 是 false 的后一个\n        return start;\n    };\n};\n\n```\n- TC:O(logn)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482598219","body":"```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar reversePairs = function(nums) {\n    if (nums.length === 0) return 0;\n    //存储已经扫描过的数字,有序的数组(2*nums[j])\n    const arr = [];\n    let res = 0;\n    for (let i = nums.length - 1; i >= 0; i--) {\n        //查询 arr 中所有小于 nums[i]的值\n        //即翻转对的数量\n        res += binarySearchLeft(arr, nums[i]);\n        const n2 = 2 * nums[i];\n        const index = binarySearchLeft(arr, n2);\n        //插入新的 2*nums[j]\n        arr.splice(index, 0, n2);\n    }\n    return res;\n};\n//在 arr 中查询 num 插入的最左侧位置\n//同时也是 arr 中小于 num 的数量\nconst binarySearchLeft = (arr, num) => {\n    let start = 0;\n    let end = arr.length;\n    while (start <= end) {\n        const mid = Math.floor((start + end) / 2);\n        if (arr[mid] < num) {\n            start = mid + 1;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return start;\n};\n```\n-TC:O(nlogn)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483722117","body":"```js\n/**\n * @param {number[]} houses\n * @param {number[]} heaters\n * @return {number}\n */\nvar findRadius = function(houses, heaters) {\n    let res = 0;\n    //heaters 从大到小排序\n    heaters.sort((a, b) => a - b);\n    for (let house of houses) {\n        //找到距离大于该 house 最小的heater\n        const rightIndex = binarySearchRight(heaters, house);\n        //距离小于 house 的最大 heater\n        const leftIndex = rightIndex - 1;\n        const rightDis = rightIndex >= heaters.length ? Infinity : heaters[rightIndex] - house;\n        const leftDis = leftIndex < 0 ? Infinity : house - heaters[leftIndex];\n        //该 house 距离左右 heater 最近的距离\n        const curDis = Math.min(leftDis, rightDis);\n        //保证res 满足所有条件\n        res = Math.max(res, curDis);\n    }\n    return res;\n};\n//要找最大的符合条件的值\nconst binarySearchRight = (arr, target) => {\n    let start = 0;\n    let end = arr.length;\n    while (start <= end) {\n        const mid = Math.floor((start + end) / 2);\n        const val = arr[mid];\n        if (val <= target) {\n            start = mid + 1;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return start;\n};\n```\n- TC:O((n+m)logn)\n- SC:O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1483981878","body":"```js\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar smallestDistancePair = function(nums, k) {\n    nums.sort((a, b) => a - b);\n    const len = nums.length;\n    let left = 0;\n    let right = nums.at(-1) - nums[0];\n    //计算数组中距离小于或等于 x 的数对数量\n    const check = (x) => {\n        let res = 0;\n        for (let i = 0, j = 1; i < len; i++) {\n            while (j < len && nums[j] - nums[i] <= x) j++;\n            res += j - i - 1;\n        }\n        return res;\n    };\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (check(mid) >= k) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return left;\n};\n```\n- TC:O(nlogm),m为距离数量\n- SC: O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484341118","body":"```js\nvar swimInWater = function (grid) {\n    //t 定义域[grid[n-1][n-1],max(grid)];\n    const n = grid.length;\n    const max = Math.max(...grid.map((arr) => Math.max(...arr)));\n    let left = grid[n - 1][n - 1],\n        right = max;\n    while (left <= right) {\n        const mid = left + ((right - left) >> 1);\n        if (canPass(mid, grid)) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return left;\n};\nconst canPass = (t, grid) => {\n    const n = grid.length;\n    const seen = new Set();\n    const passPoint = (i, j) => {\n        if (i < 0 || j < 0 || i > n - 1 || j > n - 1 || grid[i][j] > t) return false;\n        if (i == n - 1 && j == n - 1) {\n            return true;\n        }\n        let key = `${i}-${j}`;\n        if (seen.has(key)) return false;\n        seen.add(key);\n        return passPoint(i + 1, j) || passPoint(i, j + 1) || passPoint(i - 1, j) || passPoint(i, j - 1);\n    };\n    return passPoint(0, 0);\n};\n```\n\n- TC:O((n^2)*logmax)\n- SC:O(n^2)//seen","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486107726","body":"```js\n/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar maxVowels = function(s, k) {\n    const vowels = 'aeiou';\n    let count = 0;\n    let res = 0;\n    const len = s.length;\n    for (let i = 0; i < Math.min(k, len); i++) {\n        if (vowels.includes(s[i])) res++;\n    }\n    if (k >= len) return res;\n    let left = 0;\n    let right = k;\n    count = res;\n    while (right <= len) {\n        if (vowels.includes(s[right])) count++;\n        if (vowels.includes(s[left])) count--;\n        res = Math.max(res, count);\n        right++;\n        left++;\n    }\n    return res;\n};\n```\n- TC:O(n);\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488392028","body":"```js\n/**\n * @param {number} n\n * @param {number} k\n * @param {number} maxPts\n * @return {number}\n */\nvar new21Game = function(n, k, maxPts) {\n    const dp = new Array(k + maxPts).fill(0);\n    let sum = 0;\n    for (let i = k; i <= n && i < k + maxPts; i++) {\n        dp[i] = 1;\n        sum++;\n    }\n\n    for (let i = k - 1; i >= 0; i--) {\n        dp[i] = sum / maxPts;\n        sum += dp[i] - dp[i + maxPts];\n    }\n\n    return dp[0];\n};\n```\n- TC: O(k*maxPts)\n- SC:O(k+maxPts)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489770584","body":"```js\n/**\n * @param {string} s\n * @param {string} p\n * @return {number[]}\n */\nconst findAnagrams = (s, p) => {\n    // 计算目标串 p 的长度以及记录每个字符出现次数的数组\n    const len = p.length,\n        pArr = new Array(26).fill(0),\n        res = [];\n\n    let count = len;\n\n    // 对 p 中的每个字符在数组中进行计数\n    // 这里我们将字符映射到 a~z 的索引上\n    for (let i = 0; i < len; i++) {\n        pArr[p.charCodeAt(i) - 'a'.charCodeAt()]++;\n    }\n\n    // 遍历字符串 s\n    for (let i = 0; i < s.length; i++) {\n        const char = s[i];\n\n        // 对窗口内的字符进行计数，并更新 count 的值\n        if (--pArr[char.charCodeAt() - 'a'.charCodeAt()] >= 0) {\n            count--;\n        }\n\n        // 将窗口左端点向右移动一位，减少窗口大小\n        // 同时更新 pArr 数组并更新 count 的值\n        if (i >= len && ++pArr[s[i - len].charCodeAt() - 'a'.charCodeAt()] > 0) {\n            count++;\n        }\n\n        // 如果 count 为 0，说明窗口内的字符与 p 中的字符完全匹配\n        // 我们将窗口左端点加入结果集并继续遍历字符串 s\n        if (count === 0) {\n            res.push(i - len + 1);\n        }\n    }\n\n    return res;\n};\n```\n- TC:O(n)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491932151","body":"```js\nvar minWindow = function(s, t) {\n    const map = {};\n    let count = t.length;\n    // 统计字符串 t 中每个字符的出现次数\n    for (const c of t) {\n        map[c] = (map[c] || 0) + 1;\n    }\n    let left = 0,\n        start = -1,\n        len = Infinity;\n    // 用右指针扫描字符串 s\n    for (let right = 0; right < s.length; right++) {\n        const cur = s[right];\n        // 若 map 中存在该字符，则将该字符出现次数减1\n        if (map[cur] !== undefined) {\n            count -= map[cur] > 0 ? 1 : 0;\n            map[cur]--;\n        }\n        // 当所有字符都被包含时，将左指针向右移动\n        while (count === 0) {\n            // 若当前子串长度更小，则更新子串的起始位置和长度\n            if (right - left + 1 < len) {\n                start = left;\n                len = right - left + 1;\n            }\n            // 若 map 中存在该字符，则将该字符出现次数加1\n            const char = s[left];\n            if (map[char] !== undefined) {\n                count += map[char] === 0 ? 1 : 0;\n                map[char]++;\n            }\n            // 将左指针向右移动\n            left++;\n        }\n    }\n    return start === -1 ? '' : s.substring(start, start + len);\n};\n```\n- TC: O(n)\n- SC:O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493214145","body":"```js\n/**\n * @param {number} turnedOn\n * @return {string[]}\n */\nvar readBinaryWatch = function(turnedOn) {\n    const res = [];\n    const time = new Array(10).fill(0); // 初始化表示时间的数组\n    const dfs = (nums, ons) => { \n        if (nums === 0) {   // 如果灯的数量已经全部确定\n            // 计算小时数和分钟数\n            const hour = time[0] + 2 * time[1] + 4 * time[2] + 8 * time[3];\n            const min = time[4] + 2 * time[5] + 4 * time[6] + 8 * time[7] + 16 * time[8] + 32 * time[9];\n            // 判断是否合法，是则将时间字符串推入结果数组\n            if (hour < 12 && min < 60) {\n                res.push(`${hour}:${min < 10 ? '0' + min : min}`);\n            }\n        }\n        // 否则，继续搜索\n        for (let i = ons; i < time.length; i++) {\n            time[i] = 1;    // 将灯的状态置为已量\n            dfs(nums - 1, i + 1);   // 递归搜索剩余灯数，从下一个未量的灯开始\n            time[i] = 0;    // 清空当前灯的状态，回溯到上一层\n        }\n    };\n    dfs(turnedOn, 0);   // 从 0 开始搜索，搜索的灯数为 turnedOn 个\n    return res;\n};\n```\n- TC:O(1)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1493512862","body":"```js\nvar totalNQueens = function(n) {\n    let res = 0;\n    const cols = new Set(), // 列\n        diagDown = new Set(), // -> 右下对角线，行列差相等\n        diagUp = new Set(); // -> 右上对角线，行列和相等\n\n    const setQueen = (row, col) => {\n        const down = col - row;\n        const up = col + row;\n        if (cols.has(col) || diagDown.has(down) || diagUp.has(up)) return false;\n        cols.add(col);\n        diagUp.add(up);\n        diagDown.add(down);\n        return true;\n    };\n\n    const unSetQueen = (row, col) => {\n        const down = col - row;\n        const up = col + row;\n        cols.delete(col);\n        diagUp.delete(up);\n        diagDown.delete(down);\n    };\n\n    const dfs = (row) => {\n        if (row === n) { // 如果已经放置了 n 个皇后，则合法解加 1\n            res++;\n        } else {\n            for (let col = 0; col < n; col++) { // 遍历所有的列\n                if (!setQueen(row, col)) continue; // 如果不能放置皇后，则跳过本次循环\n                dfs(row + 1); // 继续放下一行皇后\n                unSetQueen(row, col); // 回溯，撤销本次放置的皇后\n            }\n        }\n    };\n\n    dfs(0);\n    return res;\n};\n```\n- TC:O(n!)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495258942","body":"```js\nvar maxAreaOfIsland = function(grid) {\n    let maxArea = 0; // 记录最大面积\n    const row = grid.length; // 行数\n    const col = grid[0].length; // 列数\n\n    // 定义 DFS 函数，计算联通块面积\n    const dfs = (i, j) => {\n        if (i < 0 || j < 0 || i >= row || j >= col || grid[i][j] === 0) {\n            return 0;\n        }\n        grid[i][j] = 0; // 将当前位置标记为已访问\n        // 递归计算联通块面积\n        return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1);\n    };\n\n    // 遍历整个矩阵，找到每个联通块的面积\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col; j++) {\n            if (grid[i][j] === 1) {\n                // 如果当前位置为 1，说明是一个联通块的起点\n                maxArea = Math.max(maxArea, dfs(i, j)); // 计算联通块面积，并更新最大面积\n            }\n        }\n    }\n    return maxArea; // 返回最大面积\n};\n```\n- TC: O(mn)\n- SC:O(mn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497432757","body":"```js\nvar maxDistance = function(grid) {\n    var result = -1; //距离\n    var land = []; //存放陆地的队列\n    var n = grid.length; //行数\n    for (var i = 0; i < n; i++) {\n        // 所有陆地入队\n        for (var j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                land.push([i, j]);\n            }\n        }\n    }\n    //全是海洋或者陆地\n    if (land.length == 0 || land.length == n * n) {\n        return -1;\n    }\n    //对每一块陆地进行BFS，对每一块遍历过的海洋标记成陆地\n    while (land.length > 0) {\n        var size = land.length; //记录当前层陆地的个数\n        while (size > 0) {\n            size--;\n            var cur = land.shift(); //第一个入队的陆地\n            //四个方向\n            var directions = [\n                [-1, 0],\n                [0, 1],\n                [1, 0],\n                [0, -1]\n            ];\n            for (var i = 0; i < 4; i++) {\n                var r = cur[0] + directions[i][0];\n                var c = cur[1] + directions[i][1];\n                //越界，跳过此方向\n                if (r < 0 || r > n - 1 || c < 0 || c > n - 1 || grid[r][c] == 1) {\n                    continue;\n                }\n                //如果是海洋，标记为陆地，加入到队列中，距离＋1\n                if (grid[r][c] == 0) {\n                    grid[r][c] = 1;\n                    land.push([r, c]);\n                }\n            }\n        }\n        result++;\n    }\n    return result;\n};\n```\n- TC:O(n^2)\n- SC:O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498409764","body":"```js\nconst maxCandies = (boxStatus, candies, keys, containedBoxes, initialBoxes) => {\n  const needKeys = new Set();\n  let maxCandiesCount = 0;\n  let queue = [...initialBoxes];\n\n  while (queue.length) {\n    const currentBoxIndex = queue.shift();\n\n    // 如果盒子已经打开或者有钥匙可用，就看看里面有没有糖果，并加入到总数中\n    if (boxStatus[currentBoxIndex]) {\n      maxCandiesCount += candies[currentBoxIndex];\n\n      // 把盒子里的还没打开过的盒子加入队列中\n      queue.push(...containedBoxes[currentBoxIndex]);\n\n      // 把盒子里的钥匙标记为可用，并加入队列中\n      for (const keyIndex of keys[currentBoxIndex]) {\n        boxStatus[keyIndex] = 1;\n        if (needKeys.has(keyIndex)) {\n          queue.push(keyIndex);\n          needKeys.delete(keyIndex);\n        }\n      }\n    }\n    // 如果盒子当前是锁着的，增加到等待打开列表中\n    else {\n      needKeys.add(currentBoxIndex);\n    }\n  }\n\n  return maxCandiesCount;\n};\n```\n- TC:O(n)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1499838699","body":"```js\nfunction solve(root) {\n    const q = []; // 创建一个队列来存储当前节点以及它的位置信息\n    q.push([root, 0]);\n    const d = {}; // 创建一个字典来存储每个位置上的节点值\n    while (q.length) {\n        const [cur, pos] = q.shift();\n        if (!(pos in d)) {\n            d[pos] = cur.val;\n        }\n        if (cur.left) {\n            q.push([cur.left, pos - 1]);\n        }\n        if (cur.right) {\n            q.push([cur.right, pos + 1]);\n        }\n    }\n    // 按照位置排序并将节点值放到数组中返回\n    return Object.entries(d)\n        .sort((a, b) => a[0] - b[0])\n        .map((item) => item[1]);\n}\n```\n- TC:O(n)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500771129","body":"```js\n/**\n * @param {number[]} cost\n * @return {number}\n */\nvar minCostClimbingStairs = function(cost) {\n    let n = cost.length;\n    //爬到 n 阶的最小花费\n    const dp = [];\n    dp[0] = cost[0];\n    dp[1] = cost[1];\n    for (let i = 2; i <= n; i++) {\n        dp[i] = Math.min(dp[i - 1], dp[i - 2]) + (cost[i] || 0);\n    }\n    return dp.at(-1);\n};\n```\n- TC:O(n)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501025137","body":"```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar rob = function(nums) {\n    const n = nums.length;\n    if (n < 2) return nums[0];\n    //前 n 个房屋能够偷到的最高金额\n    const dp = [];\n    dp[0] = nums[0];\n    dp[1] = Math.max(nums[0], nums[1]);\n    //dp[i]= Math.max(dp[i-1],dp[i-2]+nums[i]);\n    for (let i = 2; i < n; i++) {\n        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\n    }\n    return dp.at(-1);\n};\n```\n- TC:O(n)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501317803","body":"```js\nvar findNumberOfLIS = function(nums) {\n    const len = new Array(nums.length).fill(1);//len[i]=>nums[i]结尾的最长子序列长度\n    const dp = new Array(nums.length).fill(1);//dp[i]=>nums[i]结尾的最长子序列个数\n    //dp[i] = max(dp[0,i-1 while(num[j]<nums[i-1])])+1\n    for (let i = 1; i < nums.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[j] < nums[i]) {\n                if (len[j] + 1 > len[i]) {\n                    len[i] = len[j] + 1;\n                    dp[i] = dp[j]\n                } else if (len[j] + 1 === len[i]) {\n                    dp[i] += dp[j]\n                }\n            }\n        }\n    }\n    const maxLen = Math.max(...len);\n    let res = 0\n    len.forEach((val, i) => {\n        if (val === maxLen) {\n            res += dp[i]\n        }\n    })\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1502702536","body":"```js\n * @param {string} text1\n * @param {string} text2\n * @return {number}\n */\nvar longestCommonSubsequence = function(text1, text2) {\n    //dp[i][j] 以text1[i-1]结尾的字符串和以 text2[j-1]结尾的字符串的最长公共子序列长度;\n    const lenA = text1.length;\n    const lenB = text2.length;\n    const dp = new Array(lenA + 1).fill().map(() => new Array(lenB + 1).fill(0));\n    //dp[i][j]\n    //text1[i-1]===text2[j-1](有共同元素):dp[i][j] = dp[i-1][j-1]+1;\n    //text1[i-1]===text2[j-1]:max(dp[i][j-1],dp[i-1][j]);\n    let res = 0;\n    for (let i = 1; i <= lenA; i++) {\n        for (let j = 1; j <= lenB; j++) {\n            if (text1[i - 1] === text2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);\n            }\n            res = Math.max(res, dp[i][j]);\n        }\n    }\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1505191720","body":"```js\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function(m, n) {\n    //dp[i][j]到达 点[i,j]的路径数;\n    let dp = new Array(m).fill(1).map(() => new Array(n).fill(1));\n    //dp[i][j] = dp[i-1][j]+dp[i][j-1];\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506553977","body":"```js\n/**\n * @param {number} n\n * @param {number} k\n * @param {number} row\n * @param {number} column\n * @return {number}\n */\nvar knightProbability = function (n, k, r, c) {\n    //在棋盘上\n    const isOnBoard = (row, col) => row < n && row >= 0 && col < n && col >= 0;\n\n    //移动后在棋盘上的位置\n    const move = (row, col, res) => {\n        const steps = [[-1, -2], [-1, 2], [-2, -1], [-2, 1], [1, 2], [1, -2], [2, 1], [2, -1]]\n        for (const step of steps) {\n            const oriRow = row - step[0];\n            const oriCol = col - step[1];\n\n            if (isOnBoard(oriRow, oriCol)) {\n                res[row][col] += dp[oriRow][oriCol] * 0.125\n            }\n        }\n    }\n\n    //dp[i][j]跳到点(i,j)仍留在棋盘上的概率\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[r][c] = 1;\n    for (let i = 0; i < k; i++) {\n        const res = new Array(n).fill(0).map(() => new Array(n).fill(0));\n\n        for (let row = 0; row < n; row++) {\n            for (let col = 0; col < n; col++) {\n                move(row, col, res)\n            }\n        }\n        dp = res\n    };\n    // console.log(dp)\n    return dp.reduce((sum, arr) => sum += arr.reduce((s, c) => s += c, 0), 0)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509436392","body":"```js\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canPartition = function(nums) {\n    const sum = nums.reduce((acc, cur) => acc + cur, 0);\n    if (sum % 2 !== 0) return false;\n    const target = sum / 2;\n    const size = nums.length;\n    const dp = new Array(size + 1).fill().map(() => new Array(target + 1).fill(0));\n    //dp[i][j] 表示[0-i]范围内,容量为 j 的情况下,和的最大值(不能超过 j)\n    //初始化,当 j>=nums[0]时dp[0][j]=nums[0];dp[i][0]=0\n    for (let j = nums[0]; j <= target; j++) {\n        dp[0][j] = nums[0];\n    }\n    for (let i = 1; i < size;i++) {\n        //遍历物品\n        for (let j = 0; j <= target; j++) {\n            //遍历背包\n            if (j < nums[i]) {\n                //不能取nums[i]\n                dp[i][j] = dp[i - 1][j];\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]);\n            }\n        }\n    }\n    return dp[size-1][target] ===target\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511136831","body":"```js\n/**\n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\nvar coinChange = function(coins, amount) {\n    const sum = coins.reduce((acc, cur) => acc + cur, 0);\n    coins.sort((a, b) => a - b);\n    //dp[j]凑成 j 的最小硬币个数\n    const dp = new Array(amount + 1).fill(Infinity);\n    //dp[j] = Math.min(dp[j-coins[i]],dp[j]);\n    dp[0] = 0;\n    for (let i = 0; i < coins.length; i++) {\n        for (let j = coins[i]; j <= amount; j++) {\n            dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);\n        }\n    }\n    return dp[amount] === Infinity ? -1 : dp[amount];\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1513055105","body":"```js\n/**\n * @param {number} amount\n * @param {number[]} coins\n * @return {number}\n */\nvar change = function(amount, coins) {\n    //dp[j]:总金额为 j 有 dp[j]种方式\n    const dp = new Array(amount + 1).fill(0);\n    //金额为 0 时有 1 种方式\n    //dp[j]就是所有的dp[j - coins[i]]（不考虑coins[i]）相加。\n    dp[0] = 1;\n    for(let i = 0;i<coins.length;i++){\n        for(let j = coins[i];j<=amount;j++){\n            dp[j]+=dp[j-coins[i]]\n        }\n    }\n    return dp[amount]\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514004128","body":"```js\n/**\n * @param {number[]} g\n * @param {number[]} s\n * @return {number}\n */\nvar findContentChildren = function(g, s) {\n    let res = 0;\n    g.sort((a, b) => a - b);\n    s.sort((a, b) => a - b);\n    let i = g.length - 1;\n    let j = s.length - 1;\n    while (i >= 0) {\n        if (j >= 0 && g[i] <= s[j]) {\n            j--;\n            res++;\n        }\n        i--;\n    }\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1515570586","body":"```js\n/**\n * @param {number[][]} intervals\n * @return {number}\n */\nvar eraseOverlapIntervals = function(intervals) {\n    let count = 1;\n    intervals.sort((a, b) => a[0] - b[0]);\n    let end = intervals.at(-1)[0];\n    for (let i = intervals.length - 2; i >= 0; i--) {\n        if (intervals[i][1] <= end) {\n            count++;\n            end = intervals[i][0];\n        }\n    }\n    return intervals.length - count;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517136514","body":"```js\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canJump = function(nums) {\n    let cover = 0;\n    if (nums.length === 1) return true;\n    for (let i = 0; i <= cover; i++) {\n        cover = Math.max(i + nums[i], cover);\n        if (cover >= nums.length - 1) return true;\n    }\n    return false;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518640198","body":"```js\n/**\n * @param {number} n\n * @return {number}\n */\nvar numTrees = function(n) {\n    //dp[i]:以 1...i为节点组成的搜索二叉树的数量\n    const dp = new Array(n + 1).fill(0);\n    //dp[i]=dp[j-1]*dp[i-j](j:遍历1-i)\n    dp[1] = 1;\n    dp[0] = 1;\n    for (let i = 2; i <= n; i++) {\n        for (let j = 1; j <= i; j++) {\n            dp[i] += dp[j - 1] * dp[i - j];\n        }\n    }\n    return dp[n]\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519056015","body":"```JS\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nvar mergeKLists = function (lists) {\n    const heap = new minHeap();\n    for (let list of lists) {\n        while (list) {\n            heap.push(list.val);\n            list = list.next\n        }\n    }\n    let val = heap.pop();\n    const root = new ListNode();\n    let cur = root;\n    while (val || val === 0) {\n\n        cur.next = new ListNode(val);\n        cur = cur.next;\n        val = heap.pop();\n    };\n    return root.next\n};\nclass minHeap {\n    constructor() {\n        this.heap = [0]\n    }\n    size() {\n        return this.heap[0]\n    }\n    //小->上\n    shiftUp(i) {\n        while (i >> 1 > 0) {\n            const parentI = i >> 1;\n            const parent = this.heap[parentI];\n            const cur = this.heap[i];\n            if (cur < parent) {\n                [this.heap[parentI], this.heap[i]] = [cur, parent]\n            }\n            i = parentI\n        }\n    }\n    getMinChild(i) {\n        const len = this.heap.length - 1\n        if (2 * i + 1 > len) return 2 * i;\n        if (this.heap[2 * i] > this.heap[2 * i + 1]) return 2 * i + 1;\n        return 2 * i;\n    }\n    //大->下\n    shiftDown(i) {\n        const len = this.heap.length;\n        while (2 * i < len) {\n            const childI = this.getMinChild(i);\n            const child = this.heap[childI];\n            const cur = this.heap[i];\n            if (cur > child) {\n                [this.heap[childI], this.heap[i]] = [cur, child]\n            }\n            i = childI\n        }\n    }\n\n    push(val) {\n        this.heap.push(val);\n        this.heap[0]++;\n        this.shiftUp(this.heap[0])\n    }\n\n    pop() {\n        const last = this.heap.length - 1;\n        if (last === 0) return;\n        const res = this.heap[1];\n        this.heap[1] = this.heap[last]\n        this.heap.pop();\n        this.heap[0]--;\n        this.shiftDown(1)\n        return res\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1519237958","body":"```js\n/**\n * @param {number} n\n * @return {number[]}\n */\nvar beautifulArray = function (n) {\n    const map = new Map();\n    map.set(1, [1])\n    const build = (n) => {\n        if (map.has(n)) return map.get(n);\n        //左奇,右偶\n        const left = build((n + 1) >> 1).map(v => 2 * v - 1)//奇数侧\n        const right = build(n >> 1).map(v => 2 * v)//偶数侧;\n        const res = [...left, ...right];\n        map.set(n, res);\n        return res\n    }\n    return build(n)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521853115","body":"```js\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar singleNumber = function (nums) {\n    const xor = nums.reduce((res, cur) => res ^ cur,0);\n    const mask = xor & (-xor);//取异或值最后一个二进制位为 1 的数字\n    const res = [0, 0];\n    nums.forEach(num => (num & mask) == 0 ? res[0] ^= num : res[1] ^= num)\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1522638304","body":"```js\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function(nums) {\n    const res = [];\n    const path = [];\n    const backtracking = (index) => {\n        res.push([...path]);\n        for (let i = index; i < nums.length; i++) {\n            path.push(nums[i]);\n            backtracking(i + 1);\n            path.pop();\n        }\n    };\n    backtracking(0, []);\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1525535007","body":"```js\n/**\n * Initialize your data structure here.\n */\nvar Trie = function () {\n    this.node = {};\n};\n\n/**\n * Inserts a word into the trie. \n * @param {string} word\n * @return {void}\n */\nTrie.prototype.insert = function (word) {\n    let node = this.node;\n    for (let char of word) {\n        if (!node[char]) {\n            node[char] = {}\n        }\n        node = node[char]\n    }\n    node.isWord = true;\n};\n\n/**\n * Returns if the word is in the trie. \n * @param {string} word\n * @return {boolean}\n */\nTrie.prototype.search = function (word) {\n    let node = this.node;\n    for (let char of word) {\n        if (!node[char]) return false;\n        node = node[char]\n    }\n    return !!node.isWord\n};\n\n/**\n * Returns if there is any word in the trie that starts with the given prefix. \n * @param {string} prefix\n * @return {boolean}\n */\nTrie.prototype.startsWith = function (prefix) {\n    let node = this.node;\n    for (let char of prefix) {\n        if (!node[char]) return false;\n\n        node = node[char]\n    }\n    return true\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * var obj = new Trie()\n * obj.insert(word)\n * var param_2 = obj.search(word)\n * var param_3 = obj.startsWith(prefix)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1526850402","body":"```js\n/**\n * Initialize your data structure here.\n */\nvar MapSum = function () {\n    this.node = {};\n    this.map = new Map()\n};\n\n/** \n * @param {string} key \n * @param {number} val\n * @return {void}\n */\nMapSum.prototype.insert = function (key, val) {\n    let node = this.node;\n    const map = this.map;\n    if (map.has(key)) {\n        const res = map.get(key)\n        const diff = val - res\n        for (let char of key) {\n            node = node[char]\n            node.val += diff;\n        }\n    } else {\n        for (let char of key) {\n            if (!node[char]) node[char] = { val: 0 };\n            node = node[char];\n            node.val += val\n        }\n        node.isWord = true;\n    }\n    map.set(key, val)\n\n};\n/** \n * @param {string} prefix\n * @return {number}\n */\nMapSum.prototype.sum = function (prefix) {\n    let node = this.node;\n    for (let char of prefix) {\n        if (!node[char]) return null;\n        node = node[char]\n    }\n    return node.val\n};\n\n/**\n * Your MapSum object will be instantiated and called as such:\n * var obj = new MapSum()\n * obj.insert(key,val)\n * var param_2 = obj.sum(prefix)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528478643","body":"```js\nvar multiSearch = function (big, smalls) {\n    const res = Array.from(smalls, () => []);\n    const trie = {};\n    smalls.forEach((str, index) => {\n        let node = trie;\n        for (let char of str) {\n            if (!node[char]) node[char] = {};\n            node = node[char];\n        }\n        node.isWord = true;\n        node.index = index;\n    });\n    for (let i in big) {\n        let node = trie;\n        for (let inx = i; inx < big.length; inx++) {\n            let char = big[inx];\n            if (!node[char]) break;\n            node = node[char];\n            const {isWord, index} = node;\n            if (!!isWord) {\n                res[index].push(i);\n            }\n        }\n    }\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1528932516","body":"```js\n/**\n * @param {number[][]} isConnected\n * @return {number}\n */\nvar findCircleNum = function (isConnected) {\n    const uf = {};\n    let count = 0;\n    const add = (city) => {\n        if (!uf[city] && uf[city] !== 0) {\n            uf[city] = city;\n            count++\n        }\n    }\n    const find = (city) => {\n        if (uf[city] !== city) {\n            uf[city] = find(uf[city]);\n            return uf[city]\n        }\n        return city\n    };\n    const connected = (a, b) => {\n        return find(a) === find(b)\n    }\n    const union = (a, b) => {\n        if (!connected(a, b)) {\n            uf[find(a)] = find(b);\n            count--;\n        }\n    }\n    for (let i = 0; i < isConnected.length; i++) {\n        for (let j = 0; j < isConnected[0].length; j++) {\n            if (isConnected[i][j] === 1) {\n                add(i);\n                add(j);\n                union(i, j)\n            }\n        }\n    };\n    return count\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1529772874","body":"```js\n/**\n * @param {number[][]} graph\n * @param {number[]} initial\n * @return {number}\n */\nvar minMalwareSpread = function (graph, initial) {\n    //initial 中移除一个节点使得与 initial连通数最少;=>找到 initial 中联通最多的\n    const uf = new UF()\n    for (let i = 0; i < graph.length; i++) {\n        for (let j = 0; j < graph[0].length; j++) {\n            if (graph[i][j] === 1) {\n                uf.add(i);\n                uf.add(j);\n                uf.union(i, j)\n            }\n        }\n\n    };\n    let counts = graph.reduce((acc, cur, index) => {\n        let root = uf.find(index);\n        if (!acc[root]) {\n            acc[root] = 0;\n        }\n        acc[root]++;\n        return acc;\n    }, {});\n    initial.sort((a, b) => a - b);\n    let res = initial[0], max = -Infinity;\n    initial.map(point => uf.find(point)).forEach((item, index, arr) => {\n        if (arr.indexOf(item) === arr.lastIndexOf(item)) {\n            const nums = uf.findSize(item);\n            if (nums > max) {\n                res = initial[index];\n                max = nums\n            }\n        }\n    })\n    return res\n};\n\nclass UF {\n    constructor() {\n        this.root = {};\n        this.nums = {};//key=>所属集合(root[node]),value:数量\n    };\n\n    add(node) {\n        if (!this.root[node] && this.root[node] !== 0) {\n            this.root[node] = node;\n            this.nums[node] = 1\n        }\n    }\n\n    find(node) {\n        if (this.root[node] === node) return node;\n        return this.root[node] = this.find(this.root[node])\n    }\n\n    contac(a, b) {\n        return this.find(a) === this.find(b)\n    }\n\n    union(a, b) {\n        let parentA = this.find(a);\n        let parentB = this.find(b);\n        if (parentA !== parentB) {\n            this.root[parentA] = parentB;\n            this.nums[parentB] += this.nums[parentA];\n        }\n    }\n\n    findSize(root) {\n        return this.nums[root]\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1532347603","body":"```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar pruneTree = function (root) {\n\n    const dfs = (node) => {\n        if (!node) return null\n        node.left = dfs(node.left)\n        node.right = dfs(node.right)\n        if (!node.left && !node.right && node.val === 0) return null;\n        return node\n    }\n\n    return dfs(root)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1533941667","body":"```js\n/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum = function (candidates, target) {\n    candidates.sort((a, b) => a - b);\n    const res = []; const path = []\n    const backtracking = (startIndex, sum) => {\n        if (sum === target) {\n            res.push([...path]);\n            return\n        }\n        if (sum > target) return\n        for (let i = startIndex; i < candidates.length; i++) {\n\n            path.push(candidates[i])\n            backtracking(i, sum + candidates[i]);\n            path.pop()\n        }\n    }\n    backtracking(0, 0);\n    return res\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null],"dominique9898":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429688396","body":"### 思路\n\n首先计算 k 按十进制下的每一位的值, 然后模拟竖式加法,对每一位进行相加(不存在的位为0),\n并且用carry这个变量存储进位标志符. 因为我们是从前往后遍历,所以最后需要reverse一下结果.\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        if (k == 0) return num;\n\n        reverse(num.begin(), num.end());\n        vector<int> digit_k;\n        while (k) {\n            digit_k.push_back(k % 10);\n            k /= 10;\n        }\n\n        vector<int> ans;\n        int carry = 0, ptr = 0;\n        const int n = num.size(), m = digit_k.size();\n        while (carry || ptr < max(n, m)) {\n            const int d1 = ptr < n ? num[ptr] : 0;\n            const int d2 = ptr < m ? digit_k[ptr] : 0;\n            const int cur = d1 + d2 + carry;\n            carry = cur / 10;\n            ans.push_back(cur % 10);\n            ptr++;\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组 arr 长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431436378","body":"# 思路\n\n首先从左到右遍历一次s，如果s[i] == c就设置为0，否则设置为s[i - 1] + 1\n然后从右到左遍历一次s，如果s[i] == c就设置为0，否则设置为min(s[i], s[i - 1] + 1)\n\n# 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        if (s.empty()) return vector<int>{};\n\n        const int n = s.size();\n        const int MAX = n + 1000;\n        vector<int> ans(n, MAX);\n        ans[0] = (s[0] == c) ? 0 : MAX;\n        for (int i = 1; i < n; i++) {\n            ans[i] = (s[i] == c) ? 0 : ans[i - 1] + 1;\n        }\n\n        ans[n - 1] = (s[n - 1] == c) ? 0 : ans[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            ans[i] = (s[i] == c) ? 0 : min(ans[i], ans[i + 1] + 1);\n        }\n        return ans;\n    }\n};\n```\n\n# 分析\n\n时间复杂度 O(N)\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433254448","body":"# 思路\n\n用 stack 维护栈的原始元素。用stack维护前缀和\n\n# 代码\n\n```cpp\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        mxSize = maxSize;\n        cur = 0;\n    }\n    \n    void push(int x) {\n        if (stk.size() + 1 > mxSize) return;\n        stk.push_back(x);\n        if (!diff.empty()) diff.back() += cur;\n        diff.push_back(0);\n        cur = 0;\n    }\n    \n    int pop() {\n        if (stk.empty()) return -1;\n        const int x = stk.back();\n        stk.pop_back();\n        cur += diff.back();\n        diff.pop_back();\n        return x + cur;\n    }\n    \n    void increment(int k, int val) {\n        if (stk.empty()) return;\n        const int n = stk.size();\n        diff[min(n - 1, k - 1)] += val;\n    }\nprivate:\n    vector<int> stk, diff;\n    int mxSize, cur;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n# 复杂度分析\n\n每一个操作都是 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434909623","body":"class Solution {\npublic:\n\n    bool isDigital(char c) {\n        return (c - '0') >= 0 && (c - '9') <= 9;\n    }\n    string help(string s) {\n        int num = 0;\n        string res = \"\";\n        stack<int> s1;\n        stack<string> s2;\n        for (int i = 0; i < s.length(); i++) {\n            if (isDigital(s[i])) num = num * 10 + (s[i] - '0');\n            else if (s[i] == '[') {\n                s1.push(num);\n                num = 0;\n                s2.push(res); \n                res = \"\";\n            } else if (s[i] == ']') {\n                int times = s1.top();\n                s1.pop();\n                while(times--) s2.top() += res;\n                res = s2.top();\n                s2.pop();\n            } else {\n                res = res + s[i];\n            }\n        }\n        return res;\n    }\n\n    string decodeString(string s) {\n        return help(s);\n    }\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435703586","body":"```c++\r\nclass MyQueue {\r\npublic:\r\n    stack<int> s1;\r\n    stack<int> s2;\r\npublic:\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        int front;\r\n        if (!s2.empty()) {\r\n            front = s2.top();\r\n            s2.pop();\r\n        } else {\r\n            while(!s1.empty()) {\r\n                int top = s1.top();\r\n                s2.push(top);\r\n                s1.pop();\r\n            }\r\n            front = s2.top();\r\n            s2.pop();\r\n        }\r\n        return front;\r\n    }\r\n    \r\n    int peek() {\r\n        int front;\r\n        if (!s2.empty()) {\r\n            front = s2.top();\r\n        } else {\r\n            while(!s1.empty()) {\r\n                int top = s1.top();\r\n                s2.push(top);\r\n                s1.pop();\r\n            }\r\n            front = s2.top();\r\n        }\r\n        return front;\r\n    }\r\n    \r\n    bool empty() {\r\n        return s1.empty() && s2.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```c++```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437213073","body":"第一直觉先写的,感觉方法不唯一. 后续看看题解和优化\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (head == NULL) return NULL;\r\n        if (head->next == NULL) return head;\r\n        ListNode* cur = head;\r\n        int len = 0;\r\n        while(cur != NULL) {\r\n            len++;\r\n            cur = cur->next;\r\n        }\r\n        cout << len << endl;\r\n        k = k % len;\r\n        for (int i = 0; i < k; i++) {\r\n            cur = head;\r\n            ListNode* last = cur->next;\r\n            ListNode* pre_last = cur;\r\n            \r\n            while(last->next != NULL) {\r\n                last = last->next;\r\n                pre_last = pre_last->next;\r\n            }\r\n            pre_last->next = NULL;\r\n            last->next = head;\r\n            head = last;\r\n        }\r\n        return head;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wl678":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429692569","body":"2.14\n\n思路：\n\n​\t拿到题目最初的想法是将num数组转换为十进制的整数，然后直接与k相加，但是看到题目中条件数组的长度最大可以是$10^4$，排除这种做法，因为无论是int还是long long int 都够呛存下来。\n\n​\t因此，因该考虑逐位相加，但是这种方法我感觉又有些麻烦，所以参考了官方题解的另一种思路，并尝试实现。\n\n​\t将整数k与num数组最后一位相加，用temp暂时存下相加的结果，对temp取余得到最终结果的最后一位，然后再对temp整除10，将得到的结果与num数组倒数第二位相加，重复前面的步骤，整体的算法思路就是这样。\n\n​\t但是，要注意一些小问题，比如最终结果需要往前进位怎么办，整数k的长度 > 数组长度怎么办。\n\n​\t可以发现如果出现上面的两种情况，在跳出第一个for之后，temp肯定不为0，所以这时只需要将temp逐位插入到最终的数组中即可。\n\n​\t此外，对于整数k的长度远小于数组长度的测试用例，可以通过检查temp是否为0来提前终止循环，减少运行时间，算是一点小优化。\n\n代码：**C++**\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int nsize = num.size();\n        int temp = k;\n        for (int i = nsize - 1; i >= 0; i--) {\n            //小改进\n            if(temp == 0)\n                break;\n            temp = num[i] + temp;\n            num[i] = temp % 10;\n            temp = temp / 10;\n            //如果最高位出现进位\n            \n        }\n        while( temp != 0) {\n            num.insert(num.begin(), temp % 10);\n            temp = temp / 10;\n        }\n        return num;\n\n    }\n};\n```\n\n复杂度分析：\n\n​\t时间复杂度： 取决于整数k和数组的长度，所以应该是O(max(num.size(),logk));\n\n​\t空间复杂度：由于没有创建新的数组，应该为O(1);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431341658","body":"思路：\n\n​\t既然需要查找距离当前位置最近的目标字符，一共有两种可能，左边最近或者右边最近，那么直观的想法是，每当遍历到一个字符，分别从左到字符串开头和从右到字符串末尾进行查找，最后将两边得到的最近的目标字符的距离进行比较，取最小值即可。当然会出现一些特殊情况，左边或者右边没有字符没有，或者目标字符只出现了一次，并且当前刚好遍历到该字符，此时两边都查找不到。\n\n\n\n代码：**C++**\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        \n        int len = s.size();\n        vector<int> dis(len);\n        for(int i = 0; i < len;i++) {\n            int left = 0;\n            int right = 0;\n            if(s[i] != c){\n                //查找左边\n                for(int j = i; j >= 0; j--){\n                    if(s[j] == c){\n                        left = i - j;\n                        break;\n                    }\n                }\n                if(!left){\n                    left = -1;\n                }\n                //查找右边\n                for(int j = i; j < len; j++){\n                    if(s[j] == c){\n                        right = j - i;\n                        break;\n                    }\n                }\n                 if(!right){\n                    right = -1;\n                }\n                if(left == -1 || right == -1){\n                   dis[i] = max(left,right);\n                } else {\n                    dis[i] = min(left,right);\n                }\n                cout <<\"letf:\"<< left << endl;\n                cout <<\"rigth:\"<< right << endl;\n            } else {\n                dis[i] = 0;\n            }\n            \n        }\n        return dis;\n    }\n};\n```\n\n复杂度分析：\n\n时间复杂度：for循环里面嵌套了两个循环，时间复杂度为O(n\\*(i)+n\\*(n-i))=O($n^2$)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432701934","body":"\n\n思路：\n\n​\t栈作为一种底层容器，可以使用vector、deque、list来实现，遵循“先进后出”原则，可以发现题目要求实现的 push、pop 和 inc 三个功能中，前两个功能就是普通的栈所具有的功能，而最后一个inc功能需要让栈中的元素是可见的。\n\n代码：**C++**\n\n```c++\nclass CustomStack {\npublic:\n    //使用vector来构造栈\n    vector<int> stk;\n    //栈顶元素\n    int top;\n\t//构造函数\n    CustomStack(int maxSize) {\n        stk.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if (top != stk.size() - 1) {\n            ++top;\n            stk[top] = x;\n        }\n    }\n    \n    int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stk[top + 1];\n    }\n    \n    void increment(int k, int val) {\n        int lim = min(k, top + 1);\n        for (int i = 0; i < lim; ++i) {\n            stk[i] += val;\n        }\n    }\n};\n\n```\n\n复杂度分析：\n\n时间复杂度：\n\n​\tpush: O(1)\n\n​\tpop:   O(1)\n\n​\tinc:     O(k)\n\n空间复杂度： O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434347420","body":"思路：\n\n从题目中可以把\"[ \" \"]\"看作是操作符，而前面的数字以及中间的字符则看作是操作数，那么需要给每一个\"[\"匹配到对应的\"]\"才能执行操作。因此，采用栈来解决较为合适。题目中数字和字母代表的含义不相同，需要进行区分。\n\n首先，来说数字，题中给出s中的数字的范围是[1,300]，也就是说可能存在2位或者3位数字组成的数，此时需要将多位数字合并成一个数。\n\n对于字母，需要设计实现读取\"]\"与离它最近的\"[\"之间的所有字符，由于栈是LFIO原则，所以反转字符串是必要的。\n\n获得正确顺序的字串之后，就需要按照指定的次数去重复生成。\n\n\n\n代码：**C++**\n\n```c++\n class Solution {\n public:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n             ret.push_back(s[ptr++]);\n         }\n        return ret;\n     }\n\n     string getString(vector <string> &v) {\n         string ret;\n         //为什么要定义为const auto &？\n         for (const auto &s: v) {\n             ret += s;\n         }\n         return ret;\n     }\n     string decodeString(string s) {\n         //定义一个栈\n         vector <string> stk;\n         //size_t 是一些C/C++标准在stddef.h中定义的，size_t 类型表示C中任何对象所能达到的最大长度，它是无符号整数。\n         size_t ptr = 0;\n\n         while (ptr < s.size()) {\n             char cur = s[ptr];\n             //isdigit(),C 库函数 int isdigit(int c) 检查所传的字符是否是十进制数字字符。\n             if (isdigit(cur)) {\n                 // 获取一个数字并进栈,如有多位数字，例如200，会将\"2\"\"0\"\"0\"合并成一个字符串\n                 string digits = getDigits(s, ptr);\n                cout << digits << endl;\n                 stk.push_back(digits);\n             } else if (isalpha(cur) || cur == '[') {\n                 //isalpha(),C 库函数 void isalpha(int c) 检查所传的字符是否是字母。\n                 // 获取一个字母并进栈\n                 stk.push_back(string(1, s[ptr++])); \n             } else {\n                 //遇到\"]\"的时候，开始执行编码\n                 ++ptr;\n                 //获取子串\n                 vector <string> sub;\n                 while (stk.back() != \"[\") {\n                     //函数back(),vector、string中,返回当前vector容器中末尾元素的引用。\n                     //如果定义int c = a.back()，c并不是一个引用，操作c不会对a中的最后一个元素造成影响。\n                     sub.push_back(stk.back());\n                     //pop_back(),删除最后一个元素\n                     //pop_back()函数并没有真的把原来数组内存里面的数值给删掉，而是仅仅取消了数组最后一个元素的地址映射。\n                     stk.pop_back();\n                 }\n                 reverse(sub.begin(), sub.end());\n                 // 左括号出栈\n                 stk.pop_back();\n                 // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                 //stoi(),作用是将 n 进制的字符串转化为十进制，使用时包含头文件string。\n                 int repTime = stoi(stk.back()); \n                 stk.pop_back();\n                 string t = \"\", o = getString(sub);\n                 // 构造字符串\n                 while (repTime--) t += o; \n                 // 将构造好的字符串入栈\n                 stk.push_back(t);\n             }\n\n         }\n\n         return getString(stk);\n\n\n\n     }\n };\n\n```\n\n复杂度分析：\n\n时间复杂度：\n\n记原来字符串的长度为|s|，解码之后的字符串长度为S，每一小段子字符串在经过解码后，解码之后的字符串又会再入栈，一共有S个字符入栈，而经过遍历，原来的字符串的每个字符都出栈过，所以时间复杂度会是O(S+|s|)。\n\n空间复杂度：记解码后得出的字符串长度为 S，栈的总大小最终与 S*S* 相同，故渐进空间复杂度为 O(S)。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435669195","body":"思路：\n\n栈的特点是\"先进后出\"，而队列的特点是\"先进先出\"；形象点，可以把栈看作只有一个开口的盒子，而队列则是双向开口的盒子，因此，直观的想法是用两个只有一个开口但是开口方向相反的盒子（栈）来模拟双向开口的盒子（队列）。\n\n入栈和入列的操作基本上相同，区别主要在出栈操作上，队列是先进去的元素先出来，所以需要将stkIn已经入栈元素全部出栈，然后依次在另一个栈stkOut中入栈，此时，stkOut中元素的顺序已经反过来（原来在stkIn栈底的元素在stkOut栈顶），然后执行出栈，就完成了先进的元素先出。\n\n\n\n代码：**C++**\n\n```c++\nclass MyQueue {\npublic:\n    stack<int> stkIn;\n    stack<int> stkOut;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        stkIn.push(x);\n    }\n    \n    int pop() {\n        if(stkOut.empty()){\n            while(!stkIn.empty()) {\n            stkOut.push(stkIn.top());\n            stkIn.pop();\n            }\n        }\n        int temp = stkOut.top();\n        stkOut.pop();\n        return temp;\n\n    }\n    \n    int peek() {\n        if(stkOut.empty()){\n                    while(!stkIn.empty()) {\n                    stkOut.push(stkIn.top());\n                    stkIn.pop();\n                    }\n                }\n                int temp = stkOut.top();\n                return temp;\n        //int res = this->pop(); // 直接使用已有的pop函数\n        //stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去\n        //return res;\n    }\n    \n    bool empty() {\n        if(stkOut.empty() && stkIn.empty())\n            return true;\n        else\n            return false;\n        //(stkOut.empty() && stkIn.empty()) ? return true : return false;\n        //return stkOut.empty() && stkIn.empty();\n    }\n};\n```\n\n复杂度分析：\n\n​\t时间复杂度：\n\n​\t\tpush（）：O(1)\n\n​\t\tpop（）：O (4k) ,k为已经进入队列的元素数。\n\n​\t\tpeek（）：O (4k) ,k为已经进入队列的元素数。\n\n​\t\tempty（）：O(1)\n\n​\t空间复杂度：\n\n​\t\t记队列的元素总数为k，O（2k）= O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435995991","body":"思路：单调栈\n\n起初根本没看懂题目意思，参考了题解之后，了解了单调栈这种数据结构，再来回顾题目，有种豁然开朗的感觉，将原有的数组分块，分块之后排序，再合并，要与直接对原数组升序排列相同，问最多可以分成多少块？\n\n要分块，分完块还要排序，排序之后还要在跟原数组比较，听起来就让人觉得头大，感觉十分复杂。\n\n不过，考虑一组已经满足题意分好块并排序的，添加一个新元素，如何求新数组的分块方式，如果新元素比最后一个块的最大值还大或者等于，那么新元素可以自己分为一组，以求块数最多，如果小于最后一个块的最大值，但是比倒数第二格块的最大值大或者等于，那么新元素应该融入最后一个块中，一次类推，直到第一个块，整体得到思路类似演绎的思想，以“栈中存储块的最大值”为核心。\n\n\n\n代码：**C++**\n\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> stk;\n        for(auto &num : arr) {\n            if(stk.empty() || num >= stk.top()){\n                stk.push(num);\n            } else {\n                int mx = stk.top();\n                stk.pop();\n                while(!stk.empty() && stk.top() > num) {\n                    stk.pop();\n                }\n                stk.push(mx);//最后一个块的最大值还是mx，所以这里入栈的是mx而不是num！\n\n            }\n           \n        }\n        return stk.size(); \n    }\n};\n```\n\n复杂度分析：\n\n​\t时间复杂度：num和mx一共入栈n次,最多出栈n-1次，为O(n)。n为数组元数个数。\n\n​\t空间复杂度：O(1)?   O(n)*O*(*n*)。栈的长度最多为 n。 （不太懂，考虑最坏情况？)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437053125","body":"思路：\n\n如果给的是循环链表，那么只需要考虑移动head指针就可以了，但题目中给出的是单链表，所以需要先遍历整个链表，得到链表的长度，同时将链表首尾相连，然后根据输入的k移动head，之后再断掉head前面的连接即可。\n\n整体的思路是这样，但是有两种特殊情况，需要考虑，\n\n​\tk是count的倍数，此时，head不需要挪动，之间返回即可。\n\n​\tk大于count，此时需要对count - k取模，但此时得到的结果是负数，因此还需要加上一个count。\n\n代码：**C++**\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head == nullptr || head->next == nullptr || k == 0)\n            return head;\n        int count = 1;\n        ListNode* temp = head;\n        //得到链表的总长度\n        while(head->next != nullptr) {\n            count++;\n            head = head->next;\n        }\n        if( k % count !=0){\n        //首尾相连\n        head -> next = temp;\n        head = temp;\n        int rotTimes = 0;\n        if(count < k)\n            rotTimes = (count - k) % count + count; //k mod count,取正数\n        else \n            rotTimes = count - k;\n        for(int i = 1; i < rotTimes ; i++){\n            head = head -> next;\n        }\n        ListNode* temp2 = head -> next;\n        head -> next = nullptr;\n        head = temp2;\n        }\n        else{\n            //k为count整数倍，不需要移动\n            head = temp;\n        }\n        return head;\n    }\n};\n```\n\n复杂度分析：\n\n​\t时间复杂度：O(max(n,k))\n\n​\t空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438656886","body":"##### 思路：\n\n递归思路，将两两结点进行交换，输入要交换的两个结点的第一个结点的地址，返回新链表的头结点。\n\n##### 代码：C++\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        ListNode* newHead = head->next;\n        head->next = swapPairs(newHead->next);\n        newHead->next = head;\n        return newHead;\n    }\n};\n```\n\n\n\n##### 复杂度分析：\n\n​\t时间复杂度：O(n)，n为链表结点的数量，对于每个结点的指针都更新了。\n\n​\t空间复杂度：O(n)，创建了新链表，n为链表结点的数量。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440269167","body":"##### 思路：分治\n\n##### 代码：C++\n\n```c++\nclass Solution {\npublic:\n    ListNode* getMedian(ListNode* left, ListNode* right) {\n        ListNode* fast = left;\n        ListNode* slow = left;\n        while (fast != right && fast->next != right) {\n            fast = fast->next;\n            fast = fast->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n\n    TreeNode* buildTree(ListNode* left, ListNode* right) {\n        if (left == right) {\n            return nullptr;\n        }\n        ListNode* mid = getMedian(left, right);\n        TreeNode* root = new TreeNode(mid->val);\n        root->left = buildTree(left, mid);\n        root->right = buildTree(mid->next, right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        return buildTree(head, nullptr);\n    }\n};\n\n```\n\n\n\n##### 复杂度分析：\n\n时间复杂度：O(nlogn)，其中 nn 是链表的长度。\n\n空间复杂度：O(logn)，","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"meisgithub":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429694199","body":"思路：\n加法模拟\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> ans;\n        int carry = 0;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i)\n        {\n            int digit = k % 10;\n            k /= 10;\n            int sum = num[i] + digit + carry;\n            ans.push_back(sum % 10);\n            carry = sum / 10;\n        }\n        while (k)\n        {\n            int digit = k % 10;\n            k /= 10;\n            int sum = digit + carry;\n            ans.push_back(sum % 10);\n            carry = sum / 10;\n        }\n        if (carry > 0)\n        {\n            ans.push_back(1);\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430809021","body":"思路：遍历一次得到左边和右边最接近字符c的下标，最后计算最近距离\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> left(n);\n        vector<int> right(n);\n        left[0] = s[0] == c ? 0 : -10000;\n        right[n - 1] = s[n - 1] == c ? n - 1 : 20000;\n        for (int i = 1; i < n; ++i)\n        {\n            if (s[i] == c)\n            {\n                left[i] = i;\n            }\n            else\n            {\n                left[i] = left[i - 1];\n            }\n            // cout << n - i - 1 << endl;\n            if (s[n - i - 1] == c)\n            {\n                right[n - i - 1] = n - i - 1;\n            }\n            else\n            {\n                right[n - i - 1] = right[n - i];\n            }\n        }\n        vector<int> ans(n);\n        for (int i = 0; i < n; ++i)\n        {\n            ans[i] = min(abs(i - left[i]), abs(right[i] - i));\n        }\n        return ans;\n    }\n};\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432486024","body":"#### 思路\n* 使用数组模拟\n``` cpp\nclass CustomStack {\nprivate:\n    int m_size;\n    int m_maxSize;\n    vector<int> v;\npublic:\n    CustomStack(int maxSize) {\n        m_size = 0;\n        m_maxSize = maxSize;\n        v.clear();\n    }\n    \n    void push(int x) {\n        if (m_size < m_maxSize)\n        {\n            v.push_back(x);\n            m_size++;\n        }\n    }\n    \n    int pop() {\n        if (m_size == 0)\n        {\n            return -1;\n        }\n        int ans = v[m_size - 1];\n        v.pop_back();\n        m_size--;\n        return ans;\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i < k && i < m_size; ++i)\n        {\n            v[i] += val;\n        }\n    }\n};\n```\n\n#### 复杂度\n* 时间复杂度：O(n)\n* 空间复杂度：O(maxSize())","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1433901307","body":"``` cpp\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<char> encoder;\r\n        stack<int> cnt;\r\n        int n = s.size();\r\n        int i = 0;\r\n        int num = 0;\r\n        while (i < n)\r\n        {\r\n            char c = s[i];\r\n            if (isalpha(c))\r\n            {\r\n                encoder.push(c);\r\n            }\r\n            else if (isdigit(c))\r\n            {\r\n                num = num * 10 + (c - '0');;\r\n            }\r\n            else if (c == '[')\r\n            {\r\n                encoder.push(c);\r\n                cnt.push(num);\r\n                num = 0;\r\n            }\r\n            else\r\n            {\r\n                string tmp;\r\n                while (encoder.top() != '[')\r\n                {\r\n                    tmp.push_back(encoder.top());\r\n                    encoder.pop();\r\n                }\r\n                encoder.pop();\r\n                reverse(tmp.begin(), tmp.end());\r\n                int k = cnt.top();\r\n                cnt.pop();\r\n                string s;\r\n                for (int i = 0; i < k; ++i)\r\n                {\r\n                    s += tmp;\r\n                }\r\n                for (int i = 0; i < s.size(); ++i)\r\n                {\r\n                    encoder.push(s[i]);\r\n                }\r\n            }\r\n            ++i;\r\n        }\r\n        string ans;\r\n        while (!encoder.empty())\r\n        {\r\n            ans += encoder.top();\r\n            encoder.pop();\r\n        }\r\n        reverse(ans.begin(), ans.end());\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435455658","body":"用两个栈来模拟\n``` cpp\nclass MyQueue {\nprivate:\n    stack<int> stk1;\n    stack<int> stk2;\n\n    void move()\n    {\n        while (!stk1.empty())\n        {\n            stk2.push(stk1.top());\n            stk1.pop();\n        }\n    }\n\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        stk1.push(x);\n    }\n    \n    int pop() {\n        if (stk2.empty())\n        {\n            move();\n        }\n        int ans = stk2.top();\n        stk2.pop();\n        return ans;\n    }\n    \n    int peek() {\n        if (stk2.empty())\n        {\n            move();\n        }\n        return stk2.top();\n    }\n    \n    bool empty() {\n        return stk1.empty() && stk2.empty();\n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435978703","body":"排序 + 哈希表\n``` cpp\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        vector<int> tmp = arr;\n        sort(tmp.begin(), tmp.end());\n        int n = arr.size();\n        unordered_map<int, int> cnt;\n        int res = 0;\n        for (int i = 0; i < n; ++i)\n        {\n            cnt[arr[i]]++;\n            if (cnt[arr[i]] == 0)\n            {\n                cnt.erase(arr[i]);\n            }\n            cnt[tmp[i]]--;\n            if (cnt[tmp[i]] == 0)\n            {\n                cnt.erase(tmp[i]);\n            }\n            if (cnt.empty())\n            {\n                res++;\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436026242","body":"``` cpp\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        ListNode* p = head;\n        if (p == nullptr)\n        {\n            return nullptr;\n        }\n        int n = 1;\n        while (p->next)\n        {\n            p = p->next;\n            n++;\n        }\n        p->next = head;\n        k = k % n;\n        p = head;\n        int i = 1;\n        while (i < n - k)\n        {\n            p = p->next;\n            i++;\n        }\n        ListNode* newHead = p->next;\n        p->next = nullptr;\n        return newHead;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437247179","body":"``` cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr)\n        {\n            return head;\n        }\n        ListNode* newHead = head->next;\n        ListNode* nextHead = head->next->next;\n        newHead->next = head;\n        head->next = swapPairs(nextHead);\n        return newHead;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439406802","body":"``` cpp\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        return sortedListToBST(head, nullptr);\n    }\n\n    TreeNode* sortedListToBST(ListNode* start, ListNode* end)\n    {\n        if (start == end)\n        {\n            return nullptr;\n        }\n        ListNode* slow = start;\n        ListNode* fast = start;\n        while (fast != end && fast->next != end)\n        {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        TreeNode* root = new TreeNode(slow->val);\n        root->left = sortedListToBST(start, slow);\n        root->right = sortedListToBST(slow->next, end);\n        return root;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441179208","body":"``` cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* pA = headA;\n        ListNode* pB = headB;\n        while (pA && pB)\n        {\n            pA = pA->next;\n            pB = pB->next;\n        }\n        int i = 0;\n        if (pA)\n        {\n            pB = headB;\n            while (pA)\n            {\n                pA = pA->next;\n                ++i;\n            }\n            pA = headA;\n            while (i > 0)\n            {\n                pA = pA->next;\n                --i;\n            }\n        }\n        else if (pB)\n        {\n            pA = headA;\n            while (pB)\n            {\n                pB = pB->next;\n                ++i;\n            }\n            pB = headB;\n            while (i > 0)\n            {\n                pB = pB->next;\n                --i;\n            }\n        }\n        else\n        {\n            pA = headA;\n            pB = headB;\n        }\n        while (pA != pB)\n        {\n            pA = pA->next;\n            pB = pB->next;\n        }\n        return pA;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442783102","body":"``` cpp\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast && fast->next)\n        {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast)\n            {\n                break;\n            }\n        }\n        if (fast == nullptr || fast->next == nullptr)\n        {\n            return nullptr;\n        }\n        slow = head;\n        while (slow != fast)\n        {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return slow;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1444985450","body":"``` cpp\nstruct Node\n{\n    int key;\n    int val;\n    Node* pre;\n    Node* next;\n    Node() : key(-1), val(0), pre(nullptr), next(nullptr) {}\n    Node(int _key, int _val) : key(_key), val(_val), pre(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\nprivate:\n    int size;\n    int m_capacity;\n    unordered_map<int, Node*> hashtable;\n    Node* head = new Node();\n    Node* tail = new Node();\n\nprivate:\n    void moveHead(Node* node)\n    {\n        if (head->next == node)\n        {\n            return;\n        }\n        // cout << node->key << endl;\n        Node* nodePre = node->pre;\n        Node* headNext = head->next;\n        nodePre->next = node->next;\n        node->next->pre = nodePre;\n        head->next = node;\n        node->pre = head;\n        node->next = headNext;\n        headNext->pre = node;\n    }\n\n    void insertHead(Node* node)\n    {\n        Node* headNext = head->next;\n        head->next = node;\n        node->pre = head;\n        node->next = headNext;\n        headNext->pre = node;\n    }\n\n    void removeLast()\n    {\n        Node* del = tail->pre;\n        // cout << del->key << endl;\n        Node* delPre = del->pre;\n        delPre->next = tail;\n        tail->pre = delPre;\n    }\n\n    void print()\n    {\n        Node* p = head;\n        while (p)\n        {\n            cout << p->key << ' ';\n            p = p->next;\n        }\n        cout << endl;\n    }\n\npublic:\n    LRUCache(int capacity) {\n        size = 0;\n        m_capacity = capacity;\n        hashtable.clear();\n        // head\n        head->next = tail;\n        tail->pre = head;\n    }\n    \n    int get(int key) {\n        // cout << key << endl;\n        if (hashtable.count(key))\n        {\n            Node* node = hashtable[key];\n            // cout << node->val << endl;\n            moveHead(node);\n            // cout << \"success\" << endl;\n            // print();\n            return node->val;\n        }\n        // print();\n        return -1;\n    }\n    \n    void put(int key, int value) {\n        // cout << key << endl;\n        if (hashtable.count(key))\n        {\n            Node* node = hashtable[key];\n            node->val = value;\n            moveHead(node);\n        }\n        else\n        {\n            Node* newNode = new Node(key, value);\n            hashtable[key] = newNode;\n            if (size == m_capacity)\n            {\n                int delKey = tail->pre->key;\n                // cout << delKey << endl;\n                hashtable.erase(delKey);\n                removeLast();\n            }\n            else\n            {\n                ++size;\n            }\n            insertHead(newNode);\n        }\n        // print();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445150527","body":"``` cpp\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr)\n        {\n            return 0;\n        }\n        return 1 + max(maxDepth(root->left), maxDepth(root->right));\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445645742","body":"``` cpp\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr)\n        {\n            return true;\n        }\n        if (p == nullptr || q == nullptr)\n        {\n            return false;\n        }\n        if (p->val == q->val)\n        {\n            return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n        }\n        return false;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447516188","body":"``` cpp\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        int num = 0, sum = 0;\n        dfs(root, num, sum);\n        return sum;\n    }\n\n    void dfs(TreeNode* root, int& num, int& sum)\n    {\n        if (root == nullptr)\n        {\n            return;\n        }\n        num = num * 10 + root->val;\n        if (root->left == nullptr && root->right == nullptr)\n        {\n            \n            // num = num * 10 + root->val;\n            // cout << num << endl;\n            sum += num;\n            // num /= 10;\n            // return;\n        }\n        // num = num * 10 + root->val;\n        dfs(root->left,  num, sum);\n        dfs(root->right,  num, sum);\n        // sum += num;\n        // cout << num << endl;\n        num /= 10;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450376565","body":"``` cpp\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        pair<int, int> ans = helper(root, 0);\n        return ans.first;\n    }\n\n    pair<int, int> helper(TreeNode *root, int depth)\n    {\n        if (root == nullptr)\n        {\n            return {-1, -1};\n        }\n        pair<int, int> leftP = helper(root->left, depth + 1);\n        pair<int, int> rightP = helper(root->right, depth + 1);\n        pair<int, int> ans;\n        if (leftP.second >= rightP.second)\n        {\n            ans = leftP;\n        }\n        else\n        {\n            ans = rightP;\n        }\n        if (depth > ans.second)\n        {\n            return {root->val, depth};\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1450407209","body":"``` cpp\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        if (root == nullptr)\n        {\n            return \"#,\";\n        }\n        queue<TreeNode*> q;\n        q.push(root);\n        string ans = to_string(root->val);\n        ans += ',';\n        while (!q.empty())\n        {\n            TreeNode* node = q.front();\n            q.pop();\n            if (node->left)\n            {\n                q.push(node->left);\n                ans += to_string(node->left->val);\n                ans += ',';\n            }\n            else\n            {\n                ans += \"#,\";\n            }\n            if (node->right)\n            {\n                q.push(node->right);\n                ans += to_string(node->right->val);\n                ans += ',';\n            }\n            else\n            {\n                ans += \"#,\";\n            }\n        }\n        return ans;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        // cout << data << endl;\n        if (data == \"#,\")\n        {\n            return nullptr;\n        }\n        int i = 0;\n        int start = 0;\n        int n = data.size();\n        while (i < n && data[i] != ',')\n        {\n            ++i;\n        }\n        int num = stoi(data.substr(start, i - start));\n        TreeNode* root = new TreeNode(num);\n        queue<TreeNode*> q;\n        q.push(root);\n        ++i;\n        while (!q.empty())\n        {\n            // cout << i << ' ';\n            TreeNode* node = q.front();\n            // cout << node->val << endl;\n            q.pop();\n            if (data[i] == '#')\n            {\n                node->left = nullptr;\n                ++i;\n            }\n            else\n            {\n                start = i;\n                while (i < n && data[i] != ',')\n                {\n                    ++i;\n                }\n                num = stoi(data.substr(start, i - start));\n                node->left = new TreeNode(num);\n                q.push(node->left);\n            }\n            ++i;\n            if (data[i] == '#')\n            {\n                node->right = nullptr;\n                ++i;\n            }\n            else\n            {\n                start = i;\n                while (i < n && data[i] != ',')\n                {\n                    ++i;\n                }\n                num = stoi(data.substr(start, i - start));\n                node->right = new TreeNode(num);\n                q.push(node->right);\n            }\n            ++i;\n            num = 0;\n        }\n        return root;\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455006674","body":"``` cpp\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        unordered_map<int, int> cnt;\n        for (const int& num : nums)\n        {\n            ++cnt[num];\n        }\n        auto it = cnt.begin();\n        for (int i = 0; i < k; ++i)\n        {\n            pq.push({it->second, it->first});\n            ++it;\n        }\n        for (; it != cnt.end(); ++it)\n        {\n            if (it->second > pq.top().first)\n            {\n                pq.pop();\n                pq.push({it->second, it->first});\n            }\n        }\n        vector<int> ans;\n        while (!pq.empty())\n        {\n            ans.push_back(pq.top().second);\n            pq.pop();\n        }\n        return ans;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457599572","body":"``` cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n            int ans = 0;\n            int length = 0;\n            unordered_map<char, int> mp;\n            int n = s.size();\n            int start = 0;\n            for (int i = 0; i < n; i++)\n            {\n                    if (!mp.count(s[i]) || mp[s[i]] < start)\n                    {\n                            length += 1;\n                            ans = max(ans, length);\n                    }\n                    else\n                    {\n                            start = mp[s[i]] + 1;\n                            length = i - start + 1;\n                    }\n                    mp[s[i]] = i;\n            }\n            return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459609606","body":"``` cpp\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        int n = s.size(), m = words.size(), len = words[0].size();\n        unordered_map<string, int> wordMap;\n        for (const string &word : words)\n        {\n            ++wordMap[word];\n        }\n        int differCount = wordMap.size();\n        vector<int> res;\n        for (int i = 0; i < len && i <= n - m * len; ++i)\n        {\n            int count = differCount;\n            unordered_map<string, int> mp;\n            for (int j = 0; j < m; ++j)\n            {\n                string tmp = s.substr(i + j * len, len);\n                mp[tmp]++;\n                if (wordMap.count(tmp) && mp[tmp] == wordMap[tmp])\n                {\n                    count--;\n                }\n                else if (wordMap.count(tmp) && mp[tmp] == wordMap[tmp] + 1)\n                {\n                    count++;\n                }\n            }\n            int left = i, right = i + (m - 1) * len;\n            if (count == 0)\n            {\n                res.emplace_back(left);\n            }\n            // cout << count << endl;\n            while (right <= n - 2 * len)\n            {\n                // cout << left << endl;\n                string del = s.substr(left, len);\n                left += len;\n                right += len;\n                string add = s.substr(right, len);\n                mp[del]--;\n                \n                // cout << del << endl;\n                // cout << add << endl;\n                if (wordMap.count(del) && mp[del] == wordMap[del])\n                {\n                    count--;\n                }\n                else if (wordMap.count(del) && mp[del] == wordMap[del] - 1)\n                {\n                    count++;\n                }\n                mp[add]++;\n                if (wordMap.count(add) && mp[add] == wordMap[add])\n                {\n                    count--;\n                }\n                else if (wordMap.count(add) && mp[add] == wordMap[add] + 1)\n                {\n                    count++;\n                }\n                // cout << count << endl;\n                if (count == 0)\n                {\n                    res.emplace_back(left);\n                }\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461234062","body":"``` cpp\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int, int> mp;\n        mp[0] = -1;\n        int n = nums.size();\n        int sum = 0;\n        for (int i = 0; i < n; ++i)\n        {\n            sum += nums[i];\n        }\n        int m = sum % k;\n        sum = 0;\n        int ans = INT_MAX;\n        for (int i = 0; i < n; ++i)\n        {\n            sum += nums[i];\n            int tmp_m = sum % k;\n            mp[tmp_m] = i;\n            if (mp.count(tmp_m - m))\n            {\n                ans = min(ans, i - mp[tmp_m - m]);\n            }\n        }\n        return ans < n ? ans : -1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463206169","body":"``` cpp\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode *slow = head;\n        ListNode *fast = head;\n        while (fast && fast->next)\n        {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464736354","body":"``` cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int n = nums.size();\n        if (n <= 1)\n        {\n            return n;\n        }\n        int left = 0;\n        for (int i = 1; i< n; i++)\n        {\n            if (nums[i] > nums[left])\n            {\n                left++;\n                swap(nums[i], nums[left]);\n            }\n        }\n        return left + 1;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465846425","body":"``` cpp\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        priority_queue<pair<int, int>> pq;\n        for (int i = 0; i < k - 1; ++i)\n        {\n            pq.emplace(nums[i], i);\n        }\n        vector<int>ans;\n        int n = nums.size();\n        for (int i = k - 1; i < n; ++i)\n        {\n            while (!pq.empty() && pq.top().second <= i - k)\n            {\n                pq.pop();\n            }\n            pq.emplace(nums[i], i);\n            ans.push_back(pq.top().first);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467662315","body":"``` cpp\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        if (n == 1)\n        {\n            return 1;\n        }\n        unordered_map<int, pair<int, int>> mp;\n        for (const auto &v : trust)\n        {\n            mp[v[0]].first += 1;\n            mp[v[1]].second += 1;\n        }\n        for (const auto &[key, value] : mp)\n        {\n            if (value.first == 0 && value.second == n - 1)\n            {\n                return key;\n            }\n        }\n        return -1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469452156","body":"``` cpp\nclass Solution {\npublic:\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        if (dislikes.empty())\n        {\n            return true;\n        }\n        vector<vector<int>> edges(n + 1);\n        for (auto dislike : dislikes)\n        {\n            edges[dislike[0]].push_back(dislike[1]);\n            edges[dislike[1]].push_back(dislike[0]);\n        }\n        // vector<unordered_set<int>> sets(2);\n        vector<int> visited(n + 1, 0);\n        vector<int> groups(n + 1, -1);\n        queue<int> q;\n        for (int i = 1; i <= n; ++i)\n        {\n            if (visited[i])\n            {\n                continue;\n            }\n            visited[i] = 1;\n            groups[i] = 0;\n            // sets[0].insert(start);\n            q.push(i);\n            while (!q.empty())\n            {\n                int v = q.front();\n                q.pop();\n                int group = groups[v];\n                if (group == 0)\n                {\n                    for (int next : edges[v])\n                    {\n                        if (groups[next] == 0)\n                        {\n                            return false;\n                        }\n                        if (visited[next])\n                        {\n                            continue;\n                        }\n                        q.push(next);\n                        groups[next] = 1;\n                        visited[next] = 1;\n                    }\n                }\n                else\n                {\n                    for (int next : edges[v])\n                    {\n                        if (groups[next] == 1)\n                        {\n                            return false;\n                        }\n                        if (visited[next])\n                        {\n                            continue;\n                        }\n                        q.push(next);\n                        groups[next] = 0;\n                        visited[next] = 1;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1471719204","body":"``` cpp\nclass Solution {\nprivate:\n    vector<int> topSort(vector<vector<int>>& graph, vector<int>& degree, vector<int>& items)\n    {\n        queue<int> q;\n        for (int item : items)\n        {\n            if (degree[item] == 0)\n            {\n                q.push(item);\n            }\n        }\n        vector<int> res;\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            res.push_back(v);\n            for (int next : graph[v])\n            {\n                degree[next]--;\n                if (degree[next] == 0)\n                {\n                    q.push(next);\n                }\n            }\n        }\n        return res.size() == items.size() ? res : vector<int>();\n    }\npublic:\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        vector<vector<int>> groupToItems(n + m);\n        int nextGroup = m;\n        for (int i = 0; i < n; ++i)\n        {\n            if (group[i] == -1)\n            {\n                group[i] = nextGroup;\n                nextGroup++;\n            }\n            groupToItems[group[i]].push_back(i);\n        }\n\n        vector<vector<int>> itemGraph(n);\n        vector<vector<int>> groupGraph(n + m);\n        vector<int> itemDegree(n, 0);\n        vector<int> groupDegree(n + m);\n        for (int i = 0; i < n; ++i)\n        {\n            int curGroup = group[i];\n            for (int before: beforeItems[i])\n            {\n                int beforeGroup = group[before];\n                if (curGroup == beforeGroup)\n                {\n                    itemGraph[before].push_back(i);\n                    itemDegree[i]++;\n                }\n                else\n                {\n                    groupGraph[beforeGroup].push_back(curGroup);\n                    groupDegree[curGroup]++;\n                }\n            }\n        }\n        \n        vector<int> id(n + m);\n        for (int i = 0; i < n + m; ++i)\n        {\n            id[i] = i;\n        }\n        // vector<int> ans;\n        vector<int> groupSort = topSort(groupGraph, groupDegree, id);\n        if (groupSort.empty())\n        {\n            return vector<int>();\n        }\n        vector<int> ans;\n        for (int groupId : groupSort)\n        {\n            if (groupToItems[groupId].empty())\n            {\n                continue;\n            }\n            vector<int> partSort = topSort(itemGraph, itemDegree, groupToItems[groupId]);\n            if (partSort.empty())\n            {\n                return vector<int>();\n            }\n            for (int item : partSort)\n            {\n                ans.push_back(item);\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473315584","body":"``` cpp\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int x = 0, y = 0;\n        for (char dir : moves)\n        {\n            if (dir == 'U')\n            {\n                y += 1;\n            }\n            else if (dir == 'D')\n            {\n                y -= 1;\n            }\n            else if (dir == 'L')\n            {\n                x -= 1;\n            }\n            else\n            {\n                x += 1;\n            }\n        }\n        // cout << x << ' ' << y << endl;\n        return x == 0 && y == 0;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474673400","body":"``` cpp\nstruct Task\n{\n    int time;\n    int id;\n    Task(int t, int i) : time(t), id(i) { }\n    bool operator<(const Task &b) const\n    {\n        if (time == b.time)\n        {\n            return id > b.id;\n        }\n        return time > b.time;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        int n = tasks.size();\n        for (int i = 0; i < n; ++i)\n        {\n            tasks[i].push_back(i);\n        }\n        sort(tasks.begin(), tasks.end(), [](vector<int> &a, vector<int> & b)\n        {\n            return a[0] < b[0];\n        });\n        priority_queue<Task> pq;\n        int i = 0;\n        int curTime = tasks[i][0];\n        vector<int> ans;\n        while (i < n)\n        {\n            // cout << i << endl;\n            if (pq.empty() && curTime < tasks[i][0])\n            {\n                curTime = tasks[i][0];\n            }\n            while (i < n && tasks[i][0] <= curTime)\n            {\n                pq.emplace(Task(tasks[i][1], tasks[i][2]));\n                ++i;\n            }\n            Task tp = pq.top();\n            pq.pop();\n            ans.push_back(tp.id);\n            curTime += tp.time;\n        }\n        while (!pq.empty())\n        {\n            ans.push_back(pq.top().id);\n            pq.pop();\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475192301","body":"``` cpp\nclass Solution {\npublic:\n    int numberOfRounds(string loginTime, string logoutTime) {\n\n        int startH = stoi(loginTime.substr(0, 2));\n        int startM = stoi(loginTime.substr(3));\n        int endH = stoi(logoutTime.substr(0, 2));\n        int endM = stoi(logoutTime.substr(3));\n\n        int start = startH * 60 + startM;\n        int end = endH * 60 + endM;\n\n        int total = end - start;\n        if (total < 0)\n        {\n            total += 24 * 60;\n        }\n\n        int last = 0;\n\n        if (0 < startM && startM <= 15)\n        {\n            last = 15 - startM;\n        }\n        else if (15 < startM && startM <= 30)\n        {\n            last = 30 - startM;\n        }\n        else if (30 < startM && startM <= 45)\n        {\n            last = 45 - startM;\n        }\n        else if (45 < startM && startM < 60)\n        {\n            last = 60 - startM;\n        }\n\n        // cout << total << ' ' << last << endl;\n\n        return (total - last) / 15;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476386294","body":"``` cpp\nclass Solution {\npublic:\n    int minCharacters(string a, string b) {\n        vector<int> acnt(26, 0);\n        vector<int> bcnt(26, 0);\n        int an = a.size(), bn = b.size();\n        \n        for (char c : a) acnt[c-'a']++;\n        for (char c : b) bcnt[c-'a']++;\n        \n        int ans = INT_MAX, asum = 0, bsum = 0;\n        for (int i = 0; i < 25; i++) {\n            asum += acnt[i];\n            bsum += bcnt[i];\n            ans = min(min(ans, an-acnt[i]+bn-bcnt[i]), min(an-asum+bsum, bn-bsum+asum));\n        }\n        ans = min(ans, an-acnt[25]+bn-bcnt[25]);\n        \n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477252130","body":"``` cpp\nclass Solution {\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        return nums;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1478794795","body":"``` cpp\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        long left = 0, right = x;\n        while (left < right)\n        {\n            long mid = left + (right - left + 1) / 2;\n            if (x >= mid * mid)\n            {\n                left = mid;\n            }\n            else\n            {\n                right = mid - 1;\n            }\n        }\n        return (int) left;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480608365","body":"``` cpp\n// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int left = 1;\n        int right = n;\n        while (left < right)\n        {\n            int mid = left + (right - mid) / 2;\n            if (isBadVersion(mid))\n            {\n                right = mid;\n            }\n            else\n            {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1484134840","body":"``` cpp\nclass Solution {\npublic:\n    int smallestDistancePair(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n        int left = 0, right = nums[n - 1] - nums[0];\n        while (left < right)\n        {\n            int mid = left + (right - mid) / 2;\n            int cnt = 0;\n            for (int j = 0; j < n; ++j)\n            {\n                int i = lower_bound(nums.begin(), nums.end(), nums[j] - mid) - nums.begin();\n                cnt += j - i;\n            }\n            if (cnt >= k)\n            {\n                right = mid;\n            }\n            else\n            {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484617586","body":"``` cpp\nclass Solution {\npublic:\n    int swimInWater(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int left = 0;\n        int right = n * n - 1;\n        while (left < right)\n        {\n            int mid = left + (right - left) / 2;\n            vector<vector<bool>> visited(n, vector<bool>(n, false));\n            visited[0][0] = true;\n            vector<vector<int>> uMap(n, vector<int>(n, -1));\n            if (isArrive(grid, 0, 0, visited, mid, uMap))\n            {\n                right = mid;\n            }\n            else\n            {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n\n    bool isArrive(vector<vector<int>>& grid, int i, int j, vector<vector<bool>>& visited, int t, vector<vector<int>>& uMap)\n    {\n        if (uMap[i][j] != -1)\n        {\n            return uMap[i][j];\n        }\n        if (i == grid.size() - 1 && j == grid.size() - 1)\n        {\n            if (grid[i][j] > t)\n            {\n                uMap[i][j] = 0;\n                return false;\n            }\n            uMap[i][j] = true;\n            return true;\n        }\n        if (i - 1 >= 0 && t >= grid[i - 1][j] && t >= grid[i][j] && !visited[i - 1][j])\n        {\n            visited[i - 1][j] = true;\n            if (isArrive(grid, i - 1, j, visited, t, uMap))\n            {\n                uMap[i][j] = true;\n                return true;\n            }\n            visited[i - 1][j] = false;\n        }\n        if (i + 1 < grid.size() && t >= grid[i + 1][j] && t >= grid[i][j] && !visited[i + 1][j])\n        {\n            visited[i + 1][j] = true;\n            if (isArrive(grid, i + 1, j, visited, t, uMap))\n            {\n                uMap[i][j] = true;\n                return true;\n            }\n            visited[i + 1][j] = false;\n        }\n        if (j - 1 >= 0 && t >= grid[i][j - 1] && t >= grid[i][j] && !visited[i][j - 1])\n        {\n            visited[i][j - 1] = true;\n            if (isArrive(grid, i, j - 1, visited, t, uMap))\n            {\n                uMap[i][j] = true;\n                return true;\n            }\n            visited[i][j - 1] = false;\n        }\n        if (j + 1 < grid.size() && t >= grid[i][j + 1] && t >= grid[i][j] && !visited[i][j + 1])\n        {\n            visited[i][j + 1] = true;\n            if (isArrive(grid, i, j + 1, visited, t, uMap))\n            {\n                uMap[i][j] = true;\n                return true;\n            }\n            visited[i][j + 1] = false;\n        }\n        uMap[i][j] = false;\n        return false;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486897677","body":"``` cpp\nclass Solution {\npublic:\n    int maxVowels(string s, int k) {\n        int cnt = 0;\n        int ans = 0;\n        int n = s.size();\n        for (int i = 0; i < k; ++i)\n        {\n            if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u')\n            {\n                cnt++;\n            }\n        }\n        ans = cnt;\n        for (int i = k; i < n; ++i)\n        {\n            if (s[i - k] == 'a' || s[i - k] == 'e' || s[i - k] == 'i' || s[i - k] == 'o' || s[i - k] == 'u')\n            {\n                cnt--;\n            }\n            if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u')\n            {\n                cnt++;\n            }\n            ans = max(ans, cnt);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488231885","body":"``` cpp\r\nclass Solution {\r\npublic:\r\n    double new21Game(int n, int k, int maxPts) {\r\n        if (k == 0)\r\n        {\r\n            return 1.0;\r\n        }\r\n        vector<double> dp(k + maxPts);\r\n        for (int i = k; i <= n && i < k + maxPts; i++)\r\n        {\r\n            dp[i] = 1.0;\r\n        }\r\n        dp[k - 1] = 1.0 * min(n - k + 1, maxPts) / maxPts;\r\n        for (int i = k - 2; i >= 0; i--)\r\n        {\r\n            dp[i] = dp[i + 1] - (dp[i + maxPts + 1] - dp[i + 1]) / maxPts;\r\n        }\r\n        return dp[0];\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489625366","body":"``` cpp\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        int len = p.size();\n        int n = s.size();\n        if (n < len)\n        {\n            return {};\n        }\n        vector<int> pMap(26, 0);\n        for (const char c : p)\n        {\n            ++pMap[c - 'a'];\n        }\n        vector<int> curMap(26, 0);\n        for (int i = 0; i < len; ++i)\n        {\n            ++curMap[s[i] - 'a'];\n        }\n        vector<int> ans;\n        int start = 0;\n        if (isVal(curMap, pMap))\n        {\n            ans.push_back(start);\n        }\n        for (int i = len; i < n; ++i)\n        {\n            --curMap[s[start] - 'a'];\n            ++curMap[s[i] - 'a'];\n            ++start;\n            if (isVal(curMap, pMap))\n            {\n                ans.push_back(start);\n            }\n        }\n        return ans;\n    }\n\n    bool isVal(const vector<int> &curMap, const vector<int> & pMap)\n    {\n        for (int i = 0; i < 26; ++i)\n        {\n            if (curMap[i] != pMap[i])\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491231743","body":"```cpp\nclass Solution {\npublic:\n    string minWindow(string s, string t) {\n        unordered_map<char, int> tMap;\n        for (const auto &c : t)\n        {\n            tMap[c]++;\n        }\n        unordered_map<char, int> sMap;\n        int n = s.size();\n        int left = 0, right = 0;\n        int minLen = INT_MAX, start = 0;\n        while (right < n)\n        {\n            sMap[s[right]]++;\n            right++;\n            while (check(sMap, tMap) && left < right)\n            {\n                if (right - left < minLen)\n                {\n                    minLen = right - left;\n                    start = left;\n                }\n                sMap[s[left]]--;\n                left++;\n            }\n        }\n        return minLen == INT_MAX ? \"\" : s.substr(start, minLen);\n    }\n\n    bool check(unordered_map<char, int> &sMap, unordered_map<char, int> &tMap)\n    {\n        for (const auto &[key, value] : tMap)\n        {\n            if (sMap[key] < value)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1492818515","body":"``` cpp\nclass Solution {\npublic:\n    int minOperations(vector<int>& nums, int x) {\n        int sum = 0;\n        unordered_map<int, int> mp;\n        mp[0] = -1;\n        int n = nums.size();\n        for (int i = 0; i < n; ++i)\n        {\n            sum += nums[i];\n            mp[sum] = i;\n        }\n        if (sum == x)\n        {\n            return n;\n        }\n        int ans = 0x3f3f3f3f3f;\n        int total = sum;\n        sum = 0;\n        if (mp.count(total - x + sum))\n        {\n            // cout << total - x + sum << endl;\n            ans = min(ans, -1 + n - mp[total - x + sum]);\n        }\n        for (int i = 0; i < n; ++i)\n        {\n            sum += nums[i];\n            if (mp.count(total - x + sum))\n            {\n                // cout << total - x + sum << endl;\n                if (mp[total - x + sum] >= i)\n                {\n                    ans = min(ans, i + n - mp[total - x + sum]);\n                }\n            }\n        }\n        return ans == 0x3f3f3f3f ? -1 : ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493377604","body":"```cpp\nclass Solution {\npublic:\n    vector<string> readBinaryWatch(int turnedOn) {\n        vector<string> ans;\n        for (int h = 0; h < 12; ++h)\n        {\n            for (int m = 0; m < 60; ++m)\n            {\n                if (__builtin_popcount(h) + __builtin_popcount(m) == turnedOn)\n                {\n                    ans.push_back(to_string(h) + \":\" + (m < 10 ? \"0\" : \"\") + to_string(m));\n                }\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1493381569","body":"``` cpp\nclass Solution {\npublic:\n    int totalNQueens(int n) {\n        int count = 0;\n        backtrack(count, n, 0, 0, 0, 0);\n        return count;\n    }\n\n    void backtrack(int &count, int n, int depth, int column, int diag1, int diag2)\n    {\n        if (depth == n)\n        {\n            count++;\n            return;\n        }\n        int avalable = ((1 << n) - 1) & (~(column | diag1 | diag2));\n        while (avalable)\n        {\n            int avalablePos = avalable & (-avalable);\n            backtrack(count, n, depth + 1, column | avalablePos, (diag1 | avalablePos) >> 1, (diag2 | avalablePos) << 1);\n            avalable = avalable & (avalable - 1);\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495422932","body":"``` cpp\nclass Solution {\npublic:\n    int ans = 0;\n    int neighbors[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        vector<vector<int>> visited(m, vector<int>(n, 0));\n        for (int i = 0; i < m; ++i)\n        {\n            for (int j = 0; j < n; ++j)\n            {\n                if (grid[i][j] == 1 && !visited[i][j])\n                {\n                    traverse(grid, i, j, visited);\n                }\n            }\n        }\n        return ans;\n    }\n\n    void traverse(const vector<vector<int>>& grid, int row, int col, vector<vector<int>> &visited)\n    {\n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<int, int>> q;\n        q.emplace(row, col);\n        visited[row][col] = 1;\n        int count = 0;\n        while (!q.empty())\n        {\n            pair<int, int> pos = q.front();\n            q.pop();\n            count++;\n            for (auto &neighbor : neighbors)\n            {\n                int newRow = pos.first + neighbor[0];\n                int newCol = pos.second + neighbor[1];\n                if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol] == 1 && !visited[newRow][newCol])\n                {\n                    q.emplace(newRow, newCol);\n                    visited[newRow][newCol] = 1;\n                }\n            }\n        }\n\n        ans = max(ans, count);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497560551","body":"``` cpp\nclass Solution {\npublic:\n    int neighbors[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    int maxDistance(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int ans = -1;\n        for (int i = 0; i < n; ++i)\n        {\n            for (int j = 0; j < n; ++j)\n            {\n                if (grid[i][j] == 0)\n                {\n                    // cout << i << ' ' << j << ' ' << bfs(grid, i, j) << endl;\n                    ans = max(ans, bfs(grid, i, j));\n                }\n            }\n        }\n        return ans;\n    }\n\n    int bfs(const vector<vector<int>>& grid, int i, int j)\n    {\n        int n = grid.size();\n        vector<vector<int>> visited(n, vector<int>(n, 0));\n        int step = -1;\n        queue<pair<int, int>> q;\n        q.emplace(i, j);\n        visited[i][j] = 1;\n        while (!q.empty())\n        {\n            step++;\n            int sz = q.size();\n            for (int i = 0; i < sz; ++i)\n            {\n                pair<int, int> pos = q.front();\n                q.pop();\n                \n                if (grid[pos.first][pos.second] == 1)\n                {\n                    return step;\n                }\n                for (auto &neighbor : neighbors)\n                {\n                    int newI = pos.first + neighbor[0];\n                    int newJ = pos.second + neighbor[1];\n                    if (newI >= 0 && newI < n && newJ >= 0 && newJ < n && !visited[newI][newJ])\n                    {\n                        q.emplace(newI, newJ);\n                        visited[newI][newJ] = 1;\n                    }\n                }\n            }\n            \n        }\n        return -1;\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500847451","body":"``` cpp\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n = cost.size();\n        vector<int> dp(n + 1, INT_MAX);\n        dp[0] = 0, dp[1] = 0;\n        for (int i = 2; i <= n; ++i)\n        {\n            dp[i] = min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1]);\n        }\n        return dp[n];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1500939444","body":"``` cpp\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> dp(n + 1, 0);\n        dp[1] = nums[0];\n        for (int i = 2; i <= n; ++i)\n        {\n            for (int j = i - 2; j >= 0; --j)\n            {\n                dp[i] = max(nums[i - 1] + dp[j], dp[i]);\n            }\n        }\n        return *max_element(dp.begin(), dp.end());\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501358478","body":"``` cpp\nclass Solution {\npublic:\n    int findNumberOfLIS(vector<int>& nums) {\n        int n = nums.size();\n        vector<vector<int>> dp(n, vector<int>(2, 1));\n        int maxLen = 1;\n        int count = 1;\n        for (int i = 1; i < n; ++i)\n        {\n            for (int j = 0; j < i; ++j)\n            {\n                if (nums[j] < nums[i])\n                {\n                    if (dp[j][0] + 1 == dp[i][0])\n                    {\n                        dp[i][1] += dp[j][1];\n                    }\n                    if (dp[j][0] + 1 > dp[i][0])\n                    {\n                        dp[i][1] = dp[j][1];\n                    }\n                    dp[i][0] = max(dp[i][0], dp[j][0] + 1);\n                }\n            }\n            if (dp[i][0] == maxLen)\n            {\n                count += dp[i][1];\n            }\n            if (dp[i][0] > maxLen)\n            {\n                maxLen = dp[i][0];\n                count = dp[i][1];\n            }\n            \n        }\n\n        return count;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1501997278","body":"``` cpp\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m = text1.size();\n        int n = text2.size();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n        for (int i = 1; i <= m; ++i)\n        {\n            for (int j = 1; j <= n; ++j)\n            {\n                if (text1[i - 1] == text2[j - 1])\n                {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                }\n                else\n                {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1504528862","body":"``` cpp\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        // vector<vector<int>> dp(m, vector<int>(n, 0));\n        // dp[0][0] = 1;\n        // for (int i = 0; i < m; i++)\n        // {\n        //     for (int j = 0; j < n; j++)\n        //     {\n        //         if (i > 0)\n        //         {\n        //             dp[i][j] += dp[i - 1][j];\n        //         }\n        //         if (j > 0)\n        //         {\n        //             dp[i][j] += dp[i][j - 1];\n        //         }\n        //     }\n        // }\n        // return dp[m - 1][n - 1];\n\n        vector<int> dp(n, 0);\n        dp[0] = 1;\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                // int tmp = dp[j];\n                if (j > 0)\n                {\n                    dp[j] += dp[j - 1];\n                }\n            }\n        }\n        return dp[n - 1];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506264751","body":"``` cpp\nclass Solution {\npublic:\n    int neighbors[8][2] = {{-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\n    double knightProbability(int n, int k, int row, int column) {\n        vector<vector<vector<double>>> dp(k + 1, vector<vector<double>>(n, vector<double>(n, 0.0)));\n        dp[0][row][column] = 1;\n        for (int l= 1; l <= k; ++l)\n        {\n            for (int i = 0; i < n; ++i)\n            {\n                for (int j = 0; j < n; ++j)\n                {\n                    for (auto &neighbor : neighbors)\n                    {\n                        int newI = i + neighbor[0];\n                        int newJ = j + neighbor[1];\n                        if (newI >= 0 && newI < n && newJ >= 0 && newJ < n)\n                        {\n                            dp[l][i][j] += dp[l - 1][newI][newJ] * 0.125;\n                        }\n                    }\n                }\n            }\n        }\n        double ans = 0;\n        for (int i = 0; i < n; ++i)\n        {\n            for (int j = 0; j < n; ++j)\n            {\n                ans += dp[k][i][j];\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509481860","body":"``` cpp\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int n = nums.size();\n        int sum = 0;\n        for (const int& num : nums)\n        {\n            sum += num;\n        }\n        if (sum & 1)\n        {\n            return false;\n        }\n        sum /= 2;\n        vector<vector<int>> dp(n + 1, vector<int>(sum + 1, 0));\n        dp[0][0] = 1;\n        for (int i = 1; i <= n; ++i)\n        {\n            for (int j = 0; j <= sum; ++j)\n            {\n                dp[i][j] = dp[i - 1][j];\n                if (j >= nums[i - 1])\n                dp[i][j] |= dp[i - 1][j - nums[i - 1]];\n            }\n        }\n        return dp[n][sum];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510027984","body":"``` cpp\nclass Solution {\npublic:\n    int ans = 0;\n    int findTargetSumWays(vector<int>& nums, int target) {\n        dfs(nums, 0, 0, target);\n        return ans;\n    }\n\n    void dfs(const vector<int> &nums, int i, int sum, int target)\n    {\n        if (i == nums.size())\n        {\n            if (target == sum)\n            {\n                ans++;\n            }\n            return;\n        }\n        dfs(nums, i + 1, sum - nums[i], target);\n        dfs(nums, i + 1, sum + nums[i], target);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1510597819","body":"``` cpp\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        int m = coins.size();\n        vector<vector<int>> dp(m + 1, vector<int>(amount + 1, 10001));\n        dp[0][0] = 0;\n        for (int i = 1; i <= m; ++i)\n        {\n            for (int j = 0; j <= amount; ++j)\n            {\n                if (j >= coins[i - 1])\n                {\n                    dp[i][j] = min(dp[i][j - coins[i - 1]] + 1, dp[i - 1][j]);\n                }\n                else\n                {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return dp[m][amount] == 10001 ? -1 : dp[m][amount];\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1512397012","body":"``` cpp\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        int n = coins.size();\n        vector<vector<int>> dp(n + 1, vector<int>(amount + 1, 0));\n        for (int i = 0; i <= n; ++i)\n        {\n            dp[i][0] = 1;\n        }\n        for (int i = 1; i <= n; ++i)\n        {\n            for (int j = 1; j <= amount; ++j)\n            {\n                // dp[i][j] += dp[i - 1][j];\n                int k = 0;\n                while (j - k * coins[i - 1] >= 0)\n                {\n                    dp[i][j] += dp[i - 1][j - k * coins[i - 1]];\n                    k++;\n                }\n            }\n        }\n        return dp[n][amount];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1513437663","body":"``` cpp\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        int gN = g.size();\n        int sN = s.size();\n        int i = 0, j = 0;\n        int ans = 0;\n        while (i < gN && j < sN)\n        {\n            if (s[j] >= g[i])\n            {\n                ++ans;\n                ++i;\n                ++j;\n            }\n            else\n            {\n                ++j;\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1515670973","body":"``` cpp\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b)\n        {\n            if (a[0] == b[0])\n            {\n                return a[1] < b[1];\n            }\n            return a[0] < b[0];\n        });\n        int ans = 0;\n        int n = intervals.size();\n        int end = intervals[0][1];\n        int i = 1;\n        while (i < n)\n        {\n            if (intervals[i][0] < end)\n            {\n                if (intervals[i][1] <= end)\n                {\n                    end = intervals[i][1];\n                }\n                ++ans;\n            }\n            else\n            {\n                end = intervals[i][1];\n            }\n            ++i;\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517171873","body":"```class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int maxPos = 0;\n        int n = nums.size();\n        int i = 0;\n        while (i < n - 1)\n        {\n            int next = i;\n            for (int j = i; j <= nums[i] + i; j++)\n            {\n                if (j + nums[j] > maxPos)\n                {\n                    maxPos = j + nums[j];\n                    next = j;\n                    if (maxPos >= n - 1)\n                    {\n                        return true;\n                    }\n                }\n            }\n            if (next == i)\n            {\n                return false;\n            }\n            i = next;\n        }\n        return true;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518482401","body":"``` cpp\nclass Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1;\n        for (int i = 1; i <= n; ++i)\n        {\n            for (int j = 0; j < i; ++j)\n            {\n                dp[i] += dp[j] * dp[i - 1 - j];\n            }\n        }\n        return dp[n];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1518914770","body":"``` cpp\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        int n = lists.size();\n        return mergeSort(lists, 0, n - 1);\n    }\n\n    ListNode*  merge(ListNode* list1, ListNode* list2)\n    {\n        ListNode* dummy = new ListNode();\n        ListNode* p = dummy;\n        ListNode* p1 = list1;\n        ListNode* p2 = list2;\n        while (p1 && p2)\n        {\n            if (p1->val <= p2->val)\n            {\n                p->next = p1;\n                p1 = p1->next;\n            }\n            else\n            {\n                p->next = p2;\n                p2 = p2->next;\n            }\n            p = p->next;\n        }\n        p->next = p1 == nullptr ? p2 : p1;\n        return dummy->next;\n    }\n\n    ListNode* mergeSort(vector<ListNode*>& lists, int left, int right)\n    {\n        if (left > right)\n        {\n            return nullptr;\n        }\n        if (left == right)\n        {\n            return lists[left];\n        }\n        int mid = left + (right - left) / 2;\n        ListNode* leftNode = mergeSort(lists, left, mid);\n        ListNode* rightNode = mergeSort(lists, mid + 1, right);\n        ListNode* ret = merge(leftNode, rightNode);\n        return ret;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1519372163","body":"``` cpp\nclass Solution {\npublic:\n    vector<int> beautifulArray(int n) {\n        vector<int> ans;\n        if(n==1){\n            ans.push_back(1);\n            return ans;\n        }\n        int odd=(n+1)/2;\n        int even=n/2;\n        vector<int> left=beautifulArray(odd);\n        vector<int> right=beautifulArray(even);\n        for(auto &val:left){\n            ans.push_back(val*2-1);\n        }\n        for(auto &val:right){\n            ans.push_back(val*2);\n        }\n        return ans;\n    }\n   \n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521084703","body":"``` cpp\nclass Solution {\npublic:\n    vector<int> singleNumber(vector<int>& nums) {\n        long x = 0;\n        for (const int& num : nums)\n        {\n            x ^= num;\n        }\n        x = x & (-x);\n        int ret1 = 0;\n        int ret2 = 0;\n        for (const int& num : nums)\n        {\n            if ((num & x) == 0)\n            {\n                ret1 ^= num;\n            }\n        }\n        for (const int& num : nums)\n        {\n            if (num & x)\n            {\n                ret2 ^= num;\n            }\n        }\n        return {ret1, ret2};\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sye9286":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429697450","body":"### 思路\n\n把数组转换回数字，直接相加计算，再把结果转换成数组\n不过遇到一个问题是，题目给的数字居然超过了 JS 的安全最大值，被迫把所有数字转换成 BigInt 才能计算\n\n今天时间不多先写下这个方案，后续再思考完善一下其他方案，比如 k 直接往数组最后一位加，超过 10 的进一。但还没想好怎么处理最高位进一的问题。\n\n### 代码\n\n\n```js\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let num_digit = BigInt(0);\n    for (let i=0; i<=num.length-1; i++) {\n        num_digit += BigInt(num[i]) * (BigInt(10) ** BigInt(num.length-1-i) )\n    }\n\n    num_digit += BigInt(k)\n\n    return num_digit.toString().split('').map(Number);\n\n};\n\n```\n\n**复杂度分析**\n\n执行用时：5868 ms, 在所有 JavaScript 提交中击败了6.19%的用户\n内存消耗：50.8 MB, 在所有 JavaScript 提交中击败了5.31%的用户\n\n- 时间复杂度：O(n), n 为数组 num 的长度。\n- 空间复杂度：O(n)\n\n从结果上看 BigInt 的处理应该使用了大量内存空间\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431589153","body":"### 思路\r\n正向遍历，不匹配且从未匹配过时为 num[i] = -1，匹配为0，不匹配但曾经匹配过则为 num[i-1] 的值 +1\r\n反向遍历，和num里的值比较，更新为取较小的值。\r\n\r\n时间关系，代码还在测试中，结果有点问题。。\r\n\r\n### 代码\r\n```js\r\nlet s = [\"q\",\"g\",\"g\",\"c\",\"g\",\"e\",\"h\",\"c\"]\r\nlet c = \"c\"\r\nlet number = []\r\nlet number2 = []\r\n\r\n    let found = false;\r\n    \r\n    for(let i = 0; i < s.length; i++) {\r\n        \r\n\r\n        if (s[i] !== c){\r\n            if (!found) {\r\n                number[i] = -1;\r\n            } \r\n            else number[i] = number[i-1] + 1 ;\r\n        }\r\n\r\n\r\n        if (s[i] === c){\r\n            found = true;\r\n            number[i] = 0;\r\n        }\r\n        \r\n        // console.log(number)\r\n\r\n    }\r\n    \r\n    \r\n    found = false;\r\n    \r\n    for(i = s.length-1; i >= 0; i--) {\r\n    \r\n        if (s[i] === c){\r\n            number2[i] = 0;\r\n        }\r\n\r\n        if (s[i] !== c && i != s.length-1){\r\n            \r\n            number2[i] = number2[i+1] + 1 ;\r\n            \r\n            if (number2[i] < number[i] || number[i] === -1 ) number[i] = number2[i]\r\n        }\r\n    \r\n    \r\n        \r\n        // console.log(number2)\r\n\r\n    }\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432911295","body":"### 思路\n就是个数组。\nrealSize 表示容纳的真实元素数量，同时也可以作为下标用，因为每次都只操作最后一个元素\npush 时只要 realSize 小于 maxSize 就允许添加，否则不需要做特殊处理\npop 时如果 realSize 不为0，就返回那个元素（realSize - 1），并且 realSize 数量减少 1。其实理论上并不需要专门把栈里的数字删除，只要标记数量减少了即可。\ninc 先判断 k 是否大于 realSize，取小的值作为数量，然后从头依次相加\n\n\n### 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = new Array(maxSize)\n    this.realSize = 0;\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.realSize < this.maxSize) {\n        this.stack[this.realSize++] = x;        \n    }\n    //console.log(\"push \"+ x)\n    //console.log(\"RS+ \"+this.realSize)\n    //console.log(this.stack)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    //console.log(\"pop RS \" + this.realSize)\n    //console.log(\"before \"+ this.stack)\n    if(this.realSize !== 0){\n        let val_ret = this.stack[--this.realSize]\n        //console.log(\"RS-- \"+this.realSize)\n        //console.log(\"VR \"+val_ret)\n        this.stack[this.realSize] = undefined\n        //console.log(\"after \"+ this.stack)\n        return val_ret\n    }else return -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\n\n function min(a, b) {\n  return a < b ? a : b;\n}\n\nCustomStack.prototype.increment = function(k, val) {\n    //console.log(\"inc k \"+k+\" val \"+val)\n    //console.log(\"before inc \"+ this.stack)\n\n    for(let i=0; i< min(k,this.realSize); i++) {\n        this.stack[i] += val;\n    }\n    //console.log(\"after inc \"+ this.stack)\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n### 复杂度分析\n时间复杂度，inc是O(n)，其他O(1)\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434439100","body":"### 思路\r\n完全想不到，看了题解写出来也是一知半解，还需要再思考一下\r\n\r\n\r\n### 代码\r\n```js\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let sta = []; \r\n    let num = 0;\r\n    let res = \"\";\r\n\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] >= '0' && s[i] <= '9') {\r\n            num *= 10;\r\n            num += parseInt(s[i]);\r\n        }\r\n\r\n        else if (s[i] === '[') {\r\n            sta.push([num, res]);\r\n            num = 0;\r\n            res = \"\";\r\n        }\r\n\r\n        else if (s[i] === ']') {\r\n            let [n, a] = sta.pop();\r\n            for (let j = 0; j < n; j++) {\r\n                a += res;\r\n            }\r\n            res = a;\r\n        }\r\n        \r\n        else {\r\n            res += s[i];\r\n        }\r\n    }\r\n    return res;\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435675132","body":"额 写完了发现好像不允许用数组，只能用栈，怪不得写起来这么简单。。。\r\n我重新思考一下\r\n\r\n### 思路\r\nJS中没有stack，用数组代替。新建队列时，初始化头指针 head 和尾指针 tail 均为 0\r\n\r\n1. push : 添加到尾指针处，然后尾指针 +1\r\n\r\n2. pop : 返回头指针处的元素，然后头指针后移一位，元素仍在数组中不需要删除。\r\n另外题目中说明所有操作保证有效，不会对空队列执行 pop，所以不用验证是否队列为空（head 不应该大于 tail）\r\n\r\n3. peek : 返回头指针处的元素，但不移动头指针位置\r\n\r\n4. empty : 头指针等于尾指针时，表示队列是空的。\r\n\r\n\r\n### 代码\r\n\r\n\r\n```js\r\n\r\nvar MyQueue = function() {\r\n    this.stack = new Array()\r\n    this.head = 0;\r\n    this.tail = 0;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack[this.tail++] = x;\r\n    // console.log(\"aft push tail = \"+this.tail)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    // no need to check if empty operation always valide\r\n    return this.stack[this.head++];\r\n}; \r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[this.head];\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return (this.head === this.tail);\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)，不需要遍历数组\r\n- 空间复杂度：O(1)，没有使用额外空间","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437224697","body":"### 思路\n1. 遍历一遍找到 tail 和 length\n2. 从 tail 开始找到 前 k-1 个节点\n3. 前 k 个节点的作为新 head 返回 \n\n\n### 代码\n\n\n```js\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    // console.log(head.val)\n    // console.log(head.next.val)\n\n    // if nothing in the linked list \n    //  or only one item in the list\n    //  or k = 0\n    // => no need to rotate\n    if (head === null || head.next === null || k === 0 )\n        return head;\n\n    let length = 1;\n    tail = head;\n\n    // to find the tail and the length of the list\n    while (tail.next !== null) {\n        length++;\n        tail = tail.next;\n    }\n\n    // use modulo to count back from the head if k > length\n    k = k % length;\n\n    // if k === 0, means k = length or k is a multiple of length\n    // that means the k-th node from tail is it's head\n    // no need to rotate\n    if (k === 0) return head;\n\n    let newTail = head;\n    for (let i = 0; i< length - k - 1; i++) {\n        newTail = newTail.next;\n    }\n\n    \n    let newHead = newTail.next;\n    newTail.next = null;\n    tail.next = head;\n\n    return newHead;\n\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438183240","body":"### 思路\n如果 head 为空或者只有一个点，则不用交换直接返回，有两个点的，用递归的方式交换两个点。\n\n\n### 代码\n\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    if (head === null || head.next === null)\n        return head;\n\n    let newHead = head.next;\n    head.next = swapPairs(newHead.next)\n    newHead.next = head;\n    \n    return newHead;\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439829021","body":"### 思路\n用双指针遍历有序链表，找到中间点，用递归方式生成左右子树\n\n\n### 代码\n\n\n```js\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n\n    if (head === null) {\n        return head;\n    }\n\n    let fast = head;\n    let slow = head;\n    let preSlow = null;\n\n    while (fast !== null && fast.next !== null) {\n        fast = fast.next.next;\n        preSlow = slow;\n        slow = slow.next;\n    }\n\n    let node = new TreeNode(slow.val);\n\n    if (preSlow !== null) {\n        preSlow.next = null;\n        node.left = sortedListToBST(head);\n    }\n\n    node.right = sortedListToBST(slow.next);\n\n    return node;\n\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N log N)\n- 空间复杂度：O(log N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441906126","body":"### 思路\n只能想到分别遍历，分别计算哈希值，哈希值相等时则表示找到相交点。。\n\n\n### 代码\n\n\n```js\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let hashTable = new Set();\n    let node = headA;\n\n    while (node !== null) {\n        hashTable.add(node);\n        node = node.next;\n    }\n    \n    node = headB;\n    while (node !== null) {\n        if (hashTable.has(node)) {\n            return node;\n        }\n        node = node.next;\n    }\n    return null;\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443488467","body":"### 思路\n试着理解了一下题解的双指针解法。如果链表存在环，则快指针最后肯定会转一圈和慢指针相遇。\n\n\n### 代码\n\n\n```js\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if (head === null) {\n        return null;\n    }\n    let slow = head, fast = head;\n    while (fast !== null) {\n        slow = slow.next;\n        if (fast.next !== null) {\n            fast = fast.next.next;\n        } else {\n            return null;\n        }\n        if (fast === slow) {\n            let ptr = head;\n            while (ptr !== slow) {\n                ptr = ptr.next;\n                slow = slow.next;\n            }\n            return ptr;\n        }\n    }\n    return null;\n};\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445181114","body":"### 思路\n递归遍历左右子树，遇到空节点返回。取返回节点的最大值+1（根）\n\n\n### 代码\n\n\n```js\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\n \n var maxDepth = function(root) {\n  if(root === null) return 0\n  return Math.max(maxDepth(root.left), maxDepth(root.right))+1\n};\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445822619","body":"\n\n### 思路\n当pq都是null时，树是一样的。\n只有一个null或值不相同，则树不同。\n值相同时，递归遍历比较子树。只有左右子树都一样树才一样，否则只要有一个false就返回false\n\n### 代码\n\n\n```js\n\nvar isSameTree = function(p, q) {\n\n    if(p === null && q === null) \n        return true\n    if(p === null || q === null) \n        return false\n    if(p.val !== q.val) \n        return false\n\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n};\n\n\n```\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450250154","body":"### 思路\n遍历整棵树，记录节点高度 h。\n使用深度优先分别搜索左右节点，然后比较高度，返回高度较大的节点值\n\n### 代码\n\n\n```js\nvar findBottomLeftValue = function(root) {\n    let dfs = (root, h) => {\n        if (root === null) \n            return;\n        h++;\n        dfs(root.left, h);\n        dfs(root.right, h);\n        if (h > actH) {\n            actH = h;\n            val = root.val;\n        }\n    }\n\n    let actH = 0;\n    dfs(root, 0);\n    return val;\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451903975","body":"### 思路\n先序遍历，遇到空子树的时候成 None，否则继续递归序列化。\n反序列化从左向右遍历，None 为空树，否则先左再右。\n\n### 代码\n\n\n```js\nvar serialize = function(root) {\n    return rserialize(root, '');\n};\n\nvar deserialize = function(data) {\n    let dataArray = data.split(\",\");\n    return rdeserialize(dataArray);\n};\n\nconst rserialize = (root, str) => {\n    if (root === null) {\n        str += \"None,\";\n    } else {\n        str += root.val + '' + \",\";\n        str = rserialize(root.left, str);\n        str = rserialize(root.right, str);\n    }\n    return str;\n}\n\nconst rdeserialize = (dataList) => {\n    if (dataList[0] === \"None\") {\n        dataList.shift();\n        return null;\n    }\n\n    const root = new TreeNode(parseInt(dataList[0]));\n    dataList.shift();\n    root.left = rdeserialize(dataList);\n    root.right = rdeserialize(dataList);\n\n    return root;\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453742114","body":"### 思路\nDFS遍历节点，记下节点坐标。然后排序后输出。\n\n\n### 代码\n\n\n```js\nvar verticalTraversal = function (root) {\n  let map = new Map()\n  let dfs = (node, row, height) => {\n    if (node === null) {\n      return\n    }\n    if (!map.get(row)) {\n      map.set(row, [])\n    }\n    let target = map.get(row)\n    if (target[height] === null) {\n      target[height] = []\n    }\n    target[height].push(node.val)\n\n    dfs(node.left, row - 1, height + 1)\n    dfs(node.right, row + 1, height + 1)\n  }\n\n  dfs(root, 0, 0)\n\n  let arr = []\n  for (var [index, arrs] of map.entries()) {\n    arr.push(index)\n    arrs.forEach((arr) => {\n      arr.sort((a, b) => a - b)\n    })\n  }\n  arr.sort((a, b) => a - b)\n\n  let result = arr.reduce((pre, index) => {\n    pre.push(\n      map.get(index).reduce((prev, item) => {\n        prev.push(...item)\n        return prev\n      }, [])\n    )\n\n    return pre\n  }, [])\n  return result\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N log N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454588076","body":"### 思路\n这题隐约记得很久前做过。。怀念\n遍历一遍数组，同时检查哈希表中是否存在 target - nums[i]，如果有则取出来返回，没有则存入哈希表\n\n\n### 代码\n\n\n```js\n\nvar twoSum = function(nums, target) {\n    let map = new Map();\n    for(let i = 0 ; i < nums.length ; i++){\n        if(map.has(target - nums[i])) {\n            return [map.get(target - nums[i]), i];\n        } else{\n            map.set(nums[i], i);\n        }\n    }\n    return [];\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462219901","body":"\n### 代码\n\n\n```js\nvar minSubarray = function(nums, p) {\n    let x = 0;\n    for (const num of nums) {\n        x = (x + num) % p;\n    }\n    if (x === 0) {\n        return 0;\n    }\n    const index = new Map();\n    let y = 0, res = nums.length;\n    for (let i = 0; i < nums.length; i++) {\n        index.set(y, i); \n        y = (y + nums[i]) % p;\n        if (index.has((y - x + p) % p)) {\n            res = Math.min(res, i - index.get((y - x + p) % p) + 1);\n        }\n    }\n    return res === nums.length ? -1 : res;\n};\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463929826","body":"### 思路\n快慢指针，快指针比慢指针快一倍，当快指针到达尾部时，慢指针指向中点。\n\n\n### 代码\n\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function(head) {\n    let slow = head;\n    let fast = head;\n\n    while(fast !== null && fast.next !== null) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n\n        return slow;\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464181216","body":"### 思路\n快慢指针遍历。当快指针指向的数字和慢指针不相等时，将快指针处的数字复制到慢指针+1处。\n最后快指针到达尾部时，返回慢指针+1即数组不重复部分的长度。\n\n\n### 代码\n\n\n```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    if (nums.length === 0) {\n        return 0;\n    }\n    \n    let p = 0;\n    let q = 1;\n    \n    while (q <= nums.length - 1) {\n        if (nums[q] !== nums[p]) {\n            p++;\n            nums[p] = nums[q]\n        }\n        q++;\n    }\n    return p + 1;\n\n};\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465230294","body":"### 思路\n二分查找\n\n\n### 代码\n\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\n\nvar searchInsert = function (nums, target) {\n  if (nums.length === 0) return -1;\n\n  let l = 0;\n  let r = nums.length - 1;\n\n  while (l <= r) {\n    let mid = parseInt(l + (r - l) / 2);\n\n    if (nums[mid] > target) {\n      r = mid - 1;\n    }\n\n    if (nums[mid] < target) {\n      l = mid + 1;\n    }\n\n    if (nums[mid] === target) return mid;\n  }\n\n  return l;\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(logN)\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468376818","body":"\r\n### 代码\r\n\r\n\r\n```js\r\n\r\n/**\r\n * @param {number} N\r\n * @param {number[][]} trust\r\n * @return {number}\r\n */\r\nvar findJudge = function(N, trust) {\r\n    let toTrust = Array(N).fill(0) \r\n    let trusted= Array(N).fill(0) \r\n    for(let [a, b] of trust){\r\n        toTrust [a - 1]++\r\n        trusted[b - 1]++\r\n    }\r\n    for(let i = 0; i < N; i++){\r\n        if (toTrust [i] === 0 && trusted[i] === N - 1) {\r\n            return i + 1\r\n        }\r\n    }\r\n    return -1\r\n};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473994579","body":"### 思路\n用两个变量表示 X 和 Y 轴，最后如果 XY 均为 0 则表示回到原点。\n\n\n### 代码\n\n\n```js\n/**\n * @param {string} moves\n * @return {boolean}\n */\nvar judgeCircle = function(moves) {\n    let X = 0, Y = 0;\n    for (let c of moves) {\n        if (c === 'L') X -= 1;\n        if (c === 'R') X += 1;\n        if (c === 'U') Y += 1;\n        if (c === 'D') Y -= 1;\n    }\n    return X === 0 && Y === 0;\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1478004581","body":"### 思路\n计数排序\n\n\n### 代码\n\n\n```js\nvar sortArray = function(nums) {\n  countingSort(nums);\n  return nums;\n};\nfunction countingSort(nums) {\n  const n = nums.length;\n  let min = nums[0];\n  let max = nums[0];\n  for (const num of nums) {\n    if (num < min) {\n      min = num;\n    }\n    if (num > max) {\n      max = num;\n    }\n  }\n  const range = max - min + 1;\n  const counting = new Array(range).fill(0);\n  for (const num of nums) {\n    counting[num - min]++;\n  }\n  counting[0]--;\n  for (let i = 1; i < range; i++) {\n    counting[i] += counting[i - 1];\n  }\n  const ans = new Array(n);\n  for (let i = n - 1; i >= 0; i--) {\n    ans[counting[nums[i] - min]] = nums[i];\n    counting[nums[i] - min]--;\n  }\n  for (let i = 0; i < n; i++) {\n    nums[i] = ans[i];\n  }\n}\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n + k)\n- 空间复杂度：O(n + k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479744289","body":"### 思路\n整数x的平方根范围是1到x，用二分法，取中间数字mid，判断mid的平方是否小于或等于x，是则继续算(mid+1)的平方是否大于x，是则mid为x的平方根，否则x的平方根比mid大，继续搜索从mid+1到x\n如果mid的平方大于x，则x的平方根小于mid，搜索1到mid-1，直到找出结果\n\n\n### 代码\n\n\n```js\n/**\n * @param {number} x\n * @return {number}\n */\nvar mySqrt = function (x) {\n  let left = 1,\n    right = x;\n  while (left <= right) {\n    let mid = left + ((right - left) >> 1);\n    if (mid <= x / mid) {\n      if (mid + 1 > x / (mid + 1)) {\n        return mid;\n      }\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  return 0;\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(logN)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1481256724","body":"### 思路\n二分查找\n\n\n### 代码\n\n\n```js\n/**\n * Definition for isBadVersion()\n * \n * @param {integer} version number\n * @return {boolean} whether the version is bad\n * isBadVersion = function(version) {\n *     ...\n * };\n */\n\n/**\n * @param {function} isBadVersion()\n * @return {function}\n */\n\nvar bs = function(l,r) {\n    return Math.ceil(l + (r - l)/2);\n}\n\nvar solution = function(isBadVersion) {\n    /**\n     * @param {integer} n Total versions\n     * @return {integer} The first bad version\n     */\n    return function(n) {\n        let left = 1, right = n;\n        while (left < right) { \n            const mid = Math.floor(left + (right - left) / 2); \n            if (isBadVersion(mid)) {\n                right = mid; \n            } else {\n                left = mid + 1; \n            }\n        }\n        return left;\n    };\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(logN)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495417745","body":"### 思路\n深度优先遍历网格， 当找到 1 时，将当前单元格置为0防止重复遍历，然后上下左右递归，计算出每个岛屿的大小，最后返回最大岛屿\n\n\n### 代码\n```js\nvar maxAreaOfIsland = function(grid) {\n    let row = grid.length, col = grid[0].length;\n    function dfs (x, y) {\n        if (x < 0 || x >= row || y < 0 || y >= col || grid[x][y] === 0) return 0\n        grid[x][y] = 0\n        let ans = 1, dx = [-1, 1, 0, 0], dy = [0, 0, 1, -1]\n        for (let i = 0; i < dx.length; i++) {\n            ans += dfs(x + dx[i], y + dy[i])\n        }\n        return ans\n    }\n\n    let res = 0;\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col; j++) {\n            res = Math.max(res, dfs(i, j))\n        }\n    }\n    return res\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(m*n)\n- 空间复杂度：O(m*n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497214320","body":"### 代码\n\n\n```js\nvar maxDistance = function(grid) {\n    var result=-1; \n    var land=[];\n    var row = grid.length;\n    var col = grid[0].length;\n    for(var i=0;i<row;i++){ \n        for(var j=0;j<col;j++){\n            if(grid[i][j]==1){\n                land.push([i,j]);\n            }\n        }\n    }\n\n    if(land.length==0 || land.length == row*col){return -1;}\n\n    while(land.length>0){\n        var size=land.length;\n        while(size>0){\n            size--;\n            var cur=land.shift();\n\n            var directions=[[-1,0],[0,1],[1,0],[0,-1]];\n            for(var i=0;i<4;i++){\n                var r = cur[0] + directions[i][0];\n                var c = cur[1] + directions[i][1];\n\n                if(r<0 || r>col-1 || c<0 || c>row-1 || grid[r][c]==1){\n                    continue;\n                }\n\n                if(grid[r][c]==0){\n                    grid[r][c]=1;\n                    land.push([r,c]);\n                }\n            }\n        }\n        result++;\n    }\n    return result;\n};\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N^2)\n- 空间复杂度：O(N^2)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1500099310","body":"### 思路\n\n\n\n### 代码\n\n\n```js\n\nclass Node\n{\n    constructor(data)\n    {\n        this.data=data;\n        this.left = this.right = null;\n        this.head = 0;\n    }\n}\n \n\nfunction topview(root)\n{\n    if(root == null)\n        return;\n    let q = [];\n    let m = new Map();\n    let head = 0;\n    root.head = head;\n    q.push(root);\n     \n    while(q.length!=0)\n    {\n        root = q[0];\n        head = root.head;\n        if(!m.has(head))\n            m.set(head,root.data);\n        if(root.left)\n        {\n            root.left.head = head - 1;\n            q.push(root.left);\n        }\n        if(root.right)\n        {\n            root.right.head = head + 1;\n            q.push(root.right);\n        }\n        q.shift()\n    }\n     \n    let arr = Array.from(m);\n    arr.sort(function(a,b){return a[0]-b[0];})\n     \n    for (let [key, value] of arr.values())\n    {\n        console.log(value+\" \");\n    }\n}\n \n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501436080","body":"### 思路\n\n\n\n### 代码\n\n```js\nvar findNumberOfLIS = function(nums) {\n    let n = nums.length, maxLen = 0, ans = 0;\n    const dp = new Array(n).fill(0);\n    const cnt = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        dp[i] = 1;\n        cnt[i] = 1;\n        for (let j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                if (dp[j] + 1 > dp[i]) {\n                    dp[i] = dp[j] + 1;\n                    cnt[i] = cnt[j]; \n                } else if (dp[j] + 1 === dp[i]) {\n                    cnt[i] += cnt[j];\n                }\n            }\n        }\n        if (dp[i] > maxLen) {\n            maxLen = dp[i];\n            ans = cnt[i]; \n        } else if (dp[i] === maxLen) {\n            ans += cnt[i];\n        }\n    }\n    return ans;\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N^2)\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1505385592","body":"### 代码\n\n\n```js\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function(m, n) {\n    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    for (let i = 0; i < m; i++) {\n        dp[i][0] = 1;\n    }\n    for (let j = 0; j < n; j++) {\n        dp[0][j] = 1;\n    }\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[m - 1][n - 1];\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(mn)\n- 空间复杂度：O(mn)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511361432","body":"### 代码\n\n\n```js\n/**\n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\nvar coinChange = function(coins, amount) {\n  let dp = new Array( amount + 1 ).fill( Infinity );\n  dp[0] = 0;\n  \n  for (let i = 1; i <= amount; i++) {\n    for (let coin of coins) {\n      if (i - coin >= 0) {\n        dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n      }\n    }\n  }\n  \n  return dp[amount] === Infinity ? -1 : dp[amount];\n}\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N * amount) N 为面额数量\n- 空间复杂度：O(amount)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1513391263","body":"### 思路\n动态规划\n\n\n### 代码\n\n\n```js\nvar change = function(amount, coins) {\n\tconst dp = new Array(amount + 1).fill(0);\n\tdp[0] = 1;\n\tfor (const coin of coins) {\n\t\tfor (let i = coin; i <= amount; i++) {\n\t\t\tdp[i] += dp[i - coin];\n\t\t}\n\t}\n\treturn dp[amount];\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(M*N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514319663","body":"### 思路\n先排序，然后用贪心算法，从小到大用最小的饼干满足每个孩子的胃口\n\n\n### 代码\n\n\n```js\nvar findContentChildren = function(g, s) {\n    g.sort((a, b) => a - b);\n    s.sort((a, b) => a - b);\n    let count = 0;\n    for (let i = 0, j = 0; i < g.length && j < s.length; i++, j++) {\n        while (j < s.length && g[i] > s[j]) {\n            j++;\n        }\n        if (j < s.length) {\n            count++;\n        }\n    }\n    return count;\n};\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(m log m + n log n)\n- 空间复杂度：O(log m + log n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517385906","body":"### 代码\n```js\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canJump = function(nums) {\n    let end = nums.length - 1;\n\n    for (let i = nums.length - 2; i >= 0; i--) {\n        if (end - i <= nums[i]) {\n            end = i;\n        }\n    }\n\n    return end == 0;\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1520404254","body":"### 代码\n\n\n```js\nvar beautifulArray = function (n) {\n  const map = new Map();\n  map.set(1, [1]); \n  const recursion = (n) => {\n    if (map.has(n)) return map.get(n);\n    const left = recursion((n + 1) >> 1).map((item) => item * 2 - 1);\n    const right = recursion(n >> 1).map((item) => item * 2);\n    const ret = [...left, ...right]; \n    map.set(n, ret); \n    return ret;\n  };\n  return recursion(n);\n};\n\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521321532","body":"### 思路\n如果不要求常数空间复杂度，边遍历边哈希即可，哈希表中找到重复的元素就删掉。\n常数空间复杂度要用异或，元素出现两次，XOR 后会得到 0，而只出现一次的元素和 0 异或会得到本身。\n最后这步有点复杂：两个不同的数 XOR 以后，取异或和最后一位为 1 的数字作为 mask，1 表示两个数字在这一位上不同。\n重新遍历数组，让每个元素与这个 mask 进行 AND 操作，为 0 的分到一个数组，为 1 的分到另一个数组，分别找出两个不同的数\n\n\n### 代码\n\n\n```js\nvar singleNumber = function(nums) {\n    let xorsomme = 0;\n    \n    for (const num of nums) {\n        xorsomme ^= num;\n    }\n    let type1 = 0, type2 = 0;\n    const mask = xorsomme & (-xorsomme );\n    for (const num of nums) {\n        if (num & mask) {\n            type1 ^= num;\n        } else {\n            type2 ^= num;\n        }\n    }\n    return [type1, type2];\n};\n\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1531050415","body":"### 代码\n\n\n```js\nvar makeConnected = function(n, connections) {\n    if (connections.length < n - 1) {\n        return -1;\n    }\n\n    const edges = new Map();\n    for (const [x, y] of connections) {\n        edges.get(x) ? edges.get(x).push(y) : edges.set(x, [y]);\n        edges.get(y) ? edges.get(y).push(x) : edges.set(y, [x]);\n    }\n\n    const used = new Array(n).fill(0);\n\n    let ans = 0;\n    for (let i = 0; i < n; i++) {\n        if (!used[i]) {\n            dfs(i, used, edges);\n            ans++;\n        }\n    }\n    return ans - 1;\n};\n\nconst dfs = (u, used, edges) => {\n    used[u] = 1;\n    if (edges.get(u)) {\n        for (const v of edges.get(u)) {\n            if (!used[v]) {\n                dfs(v, used, edges);\n            }\n        }\n    }\n}\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(M+N)\n- 空间复杂度：O(M+N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1533003037","body":"### 思路\n用递归，当左右子树都为空且当前节点为 0 时，移除这棵子树\n\n\n### 代码\n```js\nvar pruneTree = function(root) {\n    if (!root) {\n        return null;\n    }\n    root.left = pruneTree(root.left);\n    root.right = pruneTree(root.right);\n    if (!root.left && !root.right&& root.val === 0) {\n        return null;\n    }\n    return root;\n};\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null],"fuku-l":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429707061","body":"### 思路\n1. 从低位开始，每次取两个数字的相应一位a,b。进行求和sum（a+b+carry），取sum的个位放到结果，取sum的十位放到进位carry。对两个数字的指针进行移动，直到两个数字都遍历结束。\n2. 判断是否存在进位，有就将进位放到结果中。\n**模板**\n```\nwhile( A 没完 || B 没完成){\n    a = A 的当前位\n    b = B 的当前位\n    # 求和\n    sum = a+b+进位carry\n    当前位 = sum % 10\n    进位 = sum / 10\n\n    # 移动 A 和B\n    A=A/10\n    B=B/10 \n}\n\nif(进位carry!=0) {\n    将进位加到结果中\n}\n```\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int sum = 0;\n        int carry = 0;\n        int idx = num.length-1;\n        while(idx >=0 || k !=0){\n            int a = idx >= 0 ? num[idx]:0;\n            int b = k!=0 ? k%10:0;\n            sum = a+b+carry;\n            res.add(0,sum%10);\n            carry = sum/10;\n            idx--;\n            k/=10;\n        }\n        if(carry!=0) res.add(0, carry);\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(max(N, logK))，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430858292","body":"### 思路\r\n数组的正序遍历和倒序遍历。需要遍历两次，使用 indexof(ch, index)需要注意字符串不存在的情况，即返回-1。\r\n\r\n### 代码\r\n\r\n```java\r\npublic class Q0821ShortestDistanceToACharacter {\r\n\r\n    public static void main(String[] args) {\r\n        Solution solution = new Q0821ShortestDistanceToACharacter().new Solution();\r\n        int[] test1= solution.shortestToChar(\"loveleetcode\", 'e');\r\n        System.out.println(Arrays.toString(test1));;\r\n    }\r\n\r\n    class Solution {\r\n        public int[] shortestToChar(String s, char c) {\r\n            int[] res = new int[s.length()];\r\n            int ch = c;\r\n\r\n            for (int i = 0; i < s.length(); i++) {\r\n                int a = s.indexOf(ch, i);\r\n                int b = s.lastIndexOf(ch, i);\r\n                if (a == i) {\r\n                    res[i] = 0;\r\n                } else {\r\n                    res[i] = a>0&&b>0?Math.min(Math.abs(a - i), Math.abs(b-i)):a<0? Math.abs(b-i): Math.abs(a-i);\r\n                    //if(a<0){\r\n                    //    res[i] = Math.abs(b-i);\r\n                    //} else if(b<0){\r\n                    //    res[i] = Math.abs(a-i);\r\n                    //} else {\r\n                    //    res[i] = Math.min(Math.abs(a - i), Math.abs(b-i));\r\n                    //}\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432640510","body":"### 思路\r\n因为题目中要求 nc() 方法需要遍历栈底到k的区间，可以使用数组和指针来完成\r\n\r\n### 代码\r\n\r\n```java\r\nclass CustomStack {\r\n    int[] arr = null;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top < arr.length-1){\r\n            arr[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top >= 0){\r\n            return arr[top--];\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int loop = Math.min(k-1, top);\r\n        for(int i = 0; i <= loop; i++){\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：出栈和入栈为O(1)，increment方法为O(N)， N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434398421","body":"### 思路\r\n将数字、字母、左括号、右括号看作独立的str，用栈来维护这些str\r\n1. 如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\r\n2. 如果为字符或左括号，直接进栈\r\n3. 如果为右括号，开始出栈。一直到左括号出栈，出栈序列反转后拼成字符串a，取出栈顶数字num，将a重复num次后进栈\r\n\r\n### 代码\r\n\r\n```java\r\n\r\npublic class Q0394DecodeString {\r\n\r\n    public static void main(String[] args) {\r\n        Solution solution = new Q0394DecodeString().new Solution();\r\n        String s = solution.decodeString(\"3[z]2[2[y]pq4[2[jk]e1[f]]]ef\");\r\n        System.out.println(s);\r\n    }\r\n    class Solution {\r\n        public String decodeString(String s) {\r\n            Deque<String> stack = new ArrayDeque<String>();\r\n            int idx = 0;\r\n            while (idx < s.length()) {\r\n                char ch = s.charAt(idx);\r\n                if (Character.isDigit(ch)) {\r\n                    // 数字\r\n                    int end = s.indexOf('[',idx);\r\n                    stack.push(s.substring(idx, end));\r\n                    idx = end;\r\n                } else if(']' == ch){\r\n                    // 出栈，直到遇到'['\r\n                    String a = \"\";\r\n                    while (!\"[\".equals(stack.peek())){\r\n                        a = stack.pop() + a;\r\n                    }\r\n                    stack.pop();\r\n                    int num = Integer.parseInt(stack.pop());\r\n                    String val = \"\";\r\n                    for (int i = 0; i < num; i++) {\r\n                        val+=a;\r\n                    }\r\n                    stack.push(val);\r\n                    idx++;\r\n                }else {\r\n                    // 字符 或者 [ 直接进栈\r\n                    stack.push(String.valueOf(ch));\r\n                    idx++;\r\n                }\r\n            }\r\n\r\n            StringBuffer res = new StringBuffer();\r\n            Object[] str = stack.toArray();\r\n            for (int i = str.length-1; i >=0; i--) {\r\n                res.append(str[i]);\r\n            }\r\n            return res.toString();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435465707","body":"### 思路\r\n使用ArrayDeque的栈作为数据结构。\r\n设计两个栈，一个栈用来保存push的数据，一个栈用来保存pop的数据。\r\n\r\n**对应方法思考**：\r\n1. 入队：每次入队时直接入队就可以。\r\n2. 出队：每次出队从pop栈中取值，如果pop栈中没有数据，就将push栈中的数据放到pop栈中，再将队头数据出栈。\r\n3. peek()：和出队思路一样，只是将 pop() 操作改为 peek()。\r\n4. 判断为空：需要判断两个栈是否都为空。\r\n\r\n### 代码\r\n\r\n```java\r\nclass MyQueue {\r\n    Deque<Integer> push_stack;\r\n    Deque<Integer> pop_stack;\r\n    public MyQueue() {\r\n        this.push_stack = new ArrayDeque<Integer>();\r\n        this.pop_stack = new ArrayDeque<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        push_stack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(pop_stack.isEmpty() && push_stack.isEmpty()){\r\n            return -1;\r\n        } else if(pop_stack.isEmpty()){\r\n            while(!push_stack.isEmpty()){\r\n                pop_stack.push(push_stack.pop());\r\n            }\r\n        } \r\n        return pop_stack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(pop_stack.isEmpty() && push_stack.isEmpty()){\r\n            return -1;\r\n        } else if(pop_stack.isEmpty()){\r\n            while(!push_stack.isEmpty()){\r\n                pop_stack.push(push_stack.pop());\r\n            }\r\n        } \r\n        return pop_stack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return pop_stack.isEmpty() && push_stack.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push()和empty()：O(1)，pop()，peek()：平均为O(1)。\r\n- 空间复杂度：O(N)，其中 N 为数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435990309","body":"### 思路\r\n单调栈，从左往右遍历数组，如果当前值比栈顶元素小时，需要栈中比当前值大的所有元素都出栈，将最大的一个元素入栈。\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Deque<Integer> stack = new ArrayDeque<Integer>();\r\n        for(int n: arr){\r\n            if(stack.isEmpty() || n >= stack.peek()){\r\n                stack.push(n);\r\n            } else {\r\n                int max = stack.pop();\r\n                while(!stack.isEmpty() && stack.peek() > n){\r\n                    stack.pop();\r\n                }\r\n                stack.push(max);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436414160","body":"### 思路\r\n1. 分析测试案例可知，将链表的每一位都移动k个位置，相当于将链表的后续k个节点连到head。\r\n2. 使用两个指针 p1 和 p2， p2 先走k步（若p2走到尾节点，说明k>size，可以优化k=(k%size)+size，减少循环走次数。）\r\n3. p1 和 p2 一起走，直到p2到达尾节点。将p2.next连到head，将head指向 p1.next 作为新的头，将p1.next置空。\r\n4. 返回head。\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n\r\n        ListNode p1 = head;\r\n        ListNode p2 = head;\r\n        int size = 1;\r\n        for(int i = 0; i < k; i++){\r\n            if(p2.next!=null){\r\n                p2 = p2.next;\r\n                size++;\r\n            } else {\r\n                p2 = head;\r\n                k = (k % size) + size;\r\n            }\r\n        }\r\n\r\n        while(p2.next!=null){\r\n            p2 = p2.next;\r\n            p1 = p1.next;\r\n        }\r\n\r\n        p2.next = head;\r\n        head = p1.next;\r\n        p1.next = null;\r\n\r\n        return head;\r\n    }\r\n}\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437982711","body":"### 思路\r\n1. 新增一个虚拟头节点，以保持交换操作的一致性。\r\n2. 循环条件为 cur.next != null && cur.next.next != null\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n        ListNode pre = new ListNode(0);\r\n        pre.next = head;\r\n        ListNode cur = pre;\r\n        while (cur.next != null && cur.next.next!=null){\r\n            ListNode tmp = cur.next;\r\n            cur.next = tmp.next;\r\n            tmp.next = cur.next.next;\r\n            cur.next.next = tmp;\r\n            cur = tmp;\r\n        }\r\n        return pre.next;\r\n    }\r\n}\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439552974","body":"### 思路\r\n1. 使用递归构造树和树的左右节点。\r\n2. 使用快慢指针查找链表的中间节点。\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return buildTree(head, null);\r\n    }\r\n\r\n    public TreeNode buildTree(ListNode left, ListNode right){\r\n        if(left == right){\r\n            return null;\r\n        }\r\n        ListNode mid = getMedian(left, right);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = buildTree(left, mid);\r\n        root.right = buildTree(mid.next, right);\r\n        return root;\r\n    }\r\n\r\n    public ListNode getMedian(ListNode left, ListNode right){\r\n        ListNode fast = left;\r\n        ListNode slow = left;\r\n        while(fast != right && fast.next != right){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(NlogN)，其中 N 为数组长度。\r\n- 空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441321239","body":"### 思路\r\n两个思路，一种参考题解（更简单高效）。\r\n思路一：一开始想的，使用Set判断和保存遍历时两个节点。空间复杂度 O(N)，时间复杂度 O(N)\r\n思路二：参考题解。如果两个链表相交，那么两个指针一起走到相交节点的路径应该是一致的。（都是经过自身链表+另一条链表相交节点的前半部分)。空间复杂度O(1)，时间复杂度O(N)。\r\n\r\n### 代码\r\n思路一代码：空间复杂度 O(N)，时间复杂度 O(N)，N为两个链表的长度之和。\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        \r\n        Set<ListNode> save = new HashSet<>();\r\n        if (headA != null) save.add(headA);\r\n        if (headB != null){\r\n            if (save.contains(headB)){\r\n                return headB;\r\n            } else {\r\n                save.add(headB);\r\n            }\r\n        }\r\n\r\n        while (headA.next!=null || headB.next!=null){\r\n            if (headA.next != null){\r\n                headA = headA.next;\r\n                if (save.contains(headA)){\r\n                   return headA;\r\n                } else {\r\n                    save.add(headA);\r\n                }\r\n            }\r\n            if (headB.next!=null){\r\n                headB=headB.next;\r\n                if (save.contains(headB)) {\r\n                   return headB;\r\n                } else {\r\n                    save.add(headB);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n思路二代码：（更简单高效）空间复杂度O(1)，时间复杂度O(N)。\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) return null;\r\n        ListNode p1 = headA;\r\n        ListNode p2 = headB;\r\n        while (p1 != p2) {\r\n            p1 = p1 == null ? headB : p1.next;\r\n            p2 = p2 == null ? headA : p2.next;\r\n        }\r\n        return p1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442896555","body":"### 思路\r\n快慢指针\r\n1. 每次 p1 走一步，p2 走两步。如果存在环，那么 p2 走了n圈之后会和p1在环中的某个节点相遇。\r\n2. 把 p1 环中，p2 指向头节点。p1 和 p2 每次都走一步，最终p1和p2会在环的入口相遇。\r\n\r\n### 代码\r\n以下代码包括测试验证。\r\n```java\r\npublic class Q0142LinkedListCycleIi {\r\n    public static void main(String[] args) {\r\n        Solution solution = new Q0142LinkedListCycleIi().new Solution();\r\n        int[] arr = new int[]{-21, 10, 17, 8, 4, 26, 5, 35, 33, -7, -16, 27, -12, 6, 29, -12, 5, 9, 20, 14, 14, 2, 13, -24, 21, 23, -21, 5};\r\n        int cy = 24;\r\n        ListNode head = new Q0142LinkedListCycleIi().new ListNode(arr[0]);\r\n        ListNode cur = head;\r\n        ListNode temp = null;\r\n        for (int i = 1; i < arr.length; i++) {\r\n            cur.next = new Q0142LinkedListCycleIi().new ListNode(arr[i]);\r\n            if (i == cy - 1) {\r\n                temp = cur;\r\n            }\r\n            cur = cur.next;\r\n        }\r\n        cur.next = temp;\r\n\r\n        ListNode res = solution.detectCycle(head);\r\n        System.out.println(res.toString() + \"---\" + temp.toString());\r\n        System.out.println(res.equals(temp));\r\n    }\r\n\r\n    class ListNode {\r\n        int val;\r\n        ListNode next;\r\n\r\n        ListNode(int x) {\r\n            val = x;\r\n            next = null;\r\n        }\r\n    }\r\n\r\n    public class Solution {\r\n        public ListNode detectCycle(ListNode head) {\r\n            ListNode p1 = head, p2 = head;\r\n            while (true) {\r\n                if (p2 == null || p2.next == null) {\r\n                    return null;\r\n                }\r\n                p1 = p1.next;\r\n                p2 = p2.next.next;\r\n                if (p1 == p2) {\r\n                    break;\r\n                }\r\n            }\r\n            p2 = head;\r\n            while (p1 != p2) {\r\n                p1 = p1.next;\r\n                p2 = p2.next;\r\n            }\r\n            return p1;\r\n        }\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445147287","body":"### 思路\r\n应用JavaAPI中的哈希链表（LinkedHashMap）\r\n\r\n### 代码\r\n```java\r\nclass LRUCache {\r\n    int cap;\r\n    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();\r\n    public LRUCache(int capacity) {\r\n        this.cap = capacity;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if(!cache.containsKey(key)){\r\n            return -1;\r\n        }\r\n        // 将 key 变为最近使用\r\n        makeRecently(key);\r\n        return cache.get(key);\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if(cache.containsKey(key)){\r\n            cache.put(key,value);\r\n            makeRecently(key);\r\n            return;\r\n        }\r\n        if(cache.size() >= this.cap){\r\n            // 移除最久未使用的key--链表头部\r\n            int oldKey = cache.keySet().iterator().next();\r\n            cache.remove(oldKey);\r\n        }\r\n        cache.put(key,value);\r\n    }\r\n\r\n    private void makeRecently(int key){\r\n        int value = cache.get(key);\r\n        cache.remove(key);\r\n        cache.put(key,value);\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445378144","body":"### 思路\r\n使用深度优先遍历的方法计算二叉树的最大深度。使用递归的方式计算其左子树和右子树的最大深度。递归在访问到空节点的时候结束。\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null){\r\n            return 0;\r\n        } else {\r\n            int leftHeight = maxDepth(root.left);\r\n            int rightHeight = maxDepth(root.right);\r\n            return Math.max(leftHeight, rightHeight) + 1;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445778017","body":"### 思路\r\n使用DFS或者BFS遍历二叉树，如果节点val相同，则继续遍历树的左子树或右子树。\r\n\r\n### 代码\r\n1. DFS遍历，使用递归方式，不断比较根节点的左子树和右子树的情况，如果其中一个节点非空，返回二者比较情况，如果两个节点非空，比较其值情况。空间复杂度低。\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null || q == null) return p == q;\r\n        if(p.val != q.val) return false;\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```\r\n\r\n2. BFS遍历。使用一个队列（LinkedList）同时保存两个树当前的节点，循环队列直到队列为空，每次比较使，取出两个节点进行比较。\r\n```java\r\n/**\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        // BFS 先进先出 -- 使用队列\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        queue.add(p);\r\n        queue.add(q);\r\n        while (!queue.isEmpty()) {\r\n            p = queue.poll();\r\n            q = queue.poll();\r\n            if (p == null && q == null){\r\n                continue;\r\n            }\r\n\r\n            if ((p == null || q == null) || p.val != q.val) {\r\n                return false;\r\n            }\r\n            queue.add(p.left);\r\n            queue.add(q.left);\r\n            queue.add(p.right);\r\n            queue.add(q.right);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为一棵树的节点数。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447494978","body":"### 代码\r\n1. DFS：深度优先遍历，每次递归时，需要把当前计算的值传到下一个节点。\r\n```java\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        return dfs(root, 0);\r\n    }\r\n    public int dfs(TreeNode root, int preNum){\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n        int sum = root.val + preNum * 10;\r\n        if(root.left == null && root.right == null){\r\n            // 根节点\r\n            return sum;\r\n        } else {\r\n            return dfs(root.right, sum) + dfs(root.left, sum);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n2. BFS：广度优先遍历，需要使用两个队列记录待遍历的节点以及遍历值的情况。如果当前节点的左子树和右子树为空，那么将当前值加到求和中，如果某个子树不为空，需要将该节点入队，并将当前值*10+节点值入队。\r\n```java\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n        Queue<TreeNode> nodeQ = new LinkedList<>();\r\n        Queue<Integer> numQ = new LinkedList<>();\r\n        nodeQ.offer(root);\r\n        numQ.offer(root.val);\r\n        int sum = 0;\r\n        while(!nodeQ.isEmpty()){\r\n            TreeNode cur = nodeQ.poll();\r\n            int num = numQ.poll();\r\n            TreeNode left = cur.left;\r\n            TreeNode right = cur.right;\r\n            if(left == null && right == null){\r\n                sum += num;\r\n            } else{\r\n                if(left != null){\r\n                    nodeQ.offer(left);\r\n                    numQ.offer(left.val + num * 10);\r\n                }\r\n                if(right != null){\r\n                    nodeQ.offer(right);\r\n                    numQ.offer(right.val + num * 10);\r\n                }\r\n            }\r\n        }\r\n        return sum;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450112493","body":"### 思路\r\n广度优先遍历，使用队列存储待遍历的节点，先存储根的右子树，再存左子树。保证最后遍历的节点为最底层 最左边 节点的值。\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        Queue<TreeNode> bfs = new LinkedList<>();\r\n        bfs.offer(root);\r\n        int res = -1;\r\n        while(!bfs.isEmpty()){\r\n            TreeNode cur = bfs.poll();\r\n            res = cur.val;\r\n            if(cur.right != null){\r\n                bfs.offer(cur.right);\r\n            }\r\n            if(cur.left != null){\r\n                bfs.offer(cur.left);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为树的节点数。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1452080270","body":"### 思路\r\n使用递归序列化和反序列化树。\r\n### 代码\r\n```java\r\npublic class Codec {\r\n\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        return serialize(root, \"\");\r\n    }\r\n    \r\n    private String serialize(TreeNode root,String str) {\r\n        if(root == null){\r\n            str += \"None,\";\r\n        } else {\r\n            str += str.valueOf(root.val) + \",\";\r\n            str = serialize(root.left, str);\r\n            str = serialize(root.right, str);\r\n        }\r\n        return str;\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        List<String> nodes =  new LinkedList<String>(Arrays.asList(data.split(\",\")));\r\n        return deserialize(nodes);\r\n    }\r\n    private TreeNode deserialize(List<String> nodes){\r\n        if(\"None\".equals(nodes.get(0))){\r\n            nodes.remove(0);\r\n            return null;\r\n        }\r\n        System.out.println(nodes.get(0));\r\n        TreeNode root = new TreeNode(Integer.valueOf(nodes.get(0)));\r\n        nodes.remove(0);\r\n        root.left = deserialize(nodes);\r\n        root.right = deserialize(nodes);\r\n\r\n        return root;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453721124","body":"### 思路\r\n1. dfs遍历二叉树，并用数组列表记录遍历结点的行、列、值。\r\n2. 将数组列表中的元素按照行、列、值依次排列。\r\n3. 最后将同一列的所有结点放入同个数组中。并在遍历过程中记录上个结点的列号，如果当前遍历的列号和上个结点的列号相同，则将该节点放入上个结点相同的数组中，否则放入不同的数组中。\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        List<int[]> nodes = new ArrayList<int[]>();\r\n        dfs(root, 0, 0, nodes);\r\n        Collections.sort(nodes, new Comparator<int[]>() {\r\n            public int compare(int[] tuple1, int[] tuple2) {\r\n                if (tuple1[0] != tuple2[0]) {\r\n                    return tuple1[0] - tuple2[0];\r\n                } else if (tuple1[1] != tuple2[1]) {\r\n                    return tuple1[1] - tuple2[1];\r\n                } else {\r\n                    return tuple1[2] - tuple2[2];\r\n                }\r\n            }\r\n        });\r\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\r\n        int size = 0;\r\n        int lastcol = Integer.MIN_VALUE;\r\n        for (int[] tuple : nodes) {\r\n            int col = tuple[0], row = tuple[1], value = tuple[2];\r\n            if (col != lastcol) {\r\n                lastcol = col;\r\n                ans.add(new ArrayList<Integer>());\r\n                size++;\r\n            }\r\n            ans.get(size - 1).add(value);\r\n        }\r\n        return ans;\r\n    }\r\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes){\r\n        if(node == null){\r\n            return;\r\n        }\r\n        nodes.add(new int[]{col, row, node.val});\r\n        dfs(node.left, row+1, col-1, nodes);\r\n        dfs(node.right, row+1, col+1, nodes);\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(nlogn)，其中 N 为树中的结点个数。\r\n- 空间复杂度：O(n)，dfs遍历需要O(n)的栈空间，存储行列值的数组列表也需要O(n)的空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454783207","body":"```java\r\n    class Solution {\r\n        public int[] twoSum(int[] nums, int target) {\r\n            Map<Integer, Integer> map = new HashMap<>();\r\n            for (int i = 0; i < nums.length; i++) {\r\n                int sec = target - nums[i];\r\n                if (map.containsKey(sec)){\r\n                    return new int[]{map.get(sec), i};\r\n                }\r\n                map.put(nums[i], i);\r\n            }\r\n            return new int[]{};\r\n        }\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455123222","body":"### 思路\r\n哈希表+固定小顶堆\r\n1. 遍历数组，使用哈希表统计数组元素以及出现次数。\r\n2. 遍历哈希表，构建k个元素的小顶堆。（如果当堆个数=k时，比较当前值的出现次数与当前堆顶元素的出现次数，大于则替换。）\r\n3. 遍历堆，构造返回数组。\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        Map<Integer, Integer> coutMap = new HashMap<Integer,Integer>();\r\n        for(int n : nums){\r\n            coutMap.put(n, coutMap.getOrDefault(n, 0)+1);\r\n        }\r\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>(){\r\n            public int compare(int[] m, int[] n){\r\n                return m[1] - n[1];\r\n            }\r\n        });\r\n        for(Map.Entry<Integer, Integer> entry: coutMap.entrySet()){\r\n            int num = entry.getKey();\r\n            int count = entry.getValue();\r\n            if(queue.size() == k){\r\n                if(queue.peek()[1] < count){\r\n                    queue.poll();\r\n                    queue.offer(new int[]{num, count});\r\n                }\r\n            } else {\r\n                queue.offer(new int[]{num, count});\r\n            }\r\n        }\r\n        int[] res = new int[k];\r\n        for(int i = 0; i<k; i++){\r\n            res[i] = queue.poll()[0];\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(Nlogk)，其中 N 为数组长度，遍历原数组需要O(N)时间，遍历哈希表进行堆操作需要O(logk)，二者之和为O(Nlogk)。\r\n- 空间复杂度：O(N)，哈希表的大小为O(N)，而堆的大小为O(k)，共计为O(N)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455709387","body":"```java\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n            int ans = 0;\r\n            Map<Integer, Integer> cnt = new HashMap<>();\r\n            for (int[] p : points) {\r\n                cnt.clear();\r\n                for (int[] q : points) {\r\n                    int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\r\n                    int m = cnt.getOrDefault(dis, 0);\r\n                    ans += m*2;\r\n                    cnt.put(dis, m+1);\r\n                }\r\n            }\r\n            return ans;\r\n\r\n        }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457824593","body":"### 思路\r\n快慢指针+int[]数组记录字符的最大位置下标。\r\n快指针依次向后遍历  慢指针判断快指针指向的字符是否存在 存在则指向上一次出现的字符的下标 不存在则不动\r\n长度为遍历过程中快慢指针的差值的最大值\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        int[] m = new int[128];\r\n        int ans = 0;\r\n        for (int low = 0, fast = 0; fast < s.length();) {\r\n            low = Math.max(m[s.charAt(fast)], low);\r\n            ans = Math.max(ans, fast - low + 1);\r\n            m[s.charAt(fast++)] = fast;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462184197","body":"### 思路\r\n1. 前缀和表示一个序列中，从 i~j 的和等于其序列和对应坐标元素相减。\r\n    举例：\r\n```\r\nnums = {1,2,3,4,5,6,7}\r\npres = {1,3,6,10,15,21,28}\r\n对坐标 i,j 的nums求和，等价于 pres[j] - pres[i-1]\r\n````\r\n 2. 同余定理：对于两个数字 x 和 y，对 k 取余后结果相同，说明 x , y 对 m 的模相同，这时称，x 和 y 同余。那么  a-b对m取余一定为0。举例：\r\n ```\r\n如果 x % k = a, y % k = a\r\n那么 (x-y) % k = 0\r\n```\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int minSubarray(int[] nums, int p) {\r\n        // (sum - sub) % p = 0  等价于 sum % p = sub % p\r\n        int x = 0;\r\n        for(int num: nums){\r\n            x = (x+num)%p;\r\n        }\r\n        if(x == 0){\r\n            return 0;\r\n        }\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        int y = 0, res = nums.length;\r\n        for(int i = 0; i<nums.length; i++){\r\n            map.put(y, i);\r\n            y = (y + nums[i]) % p;\r\n            if(map.containsKey((y - x + p) % p)) {\r\n                res = Math.min(res, i - map.get((y - x + p) % p) + 1);\r\n            }\r\n        }\r\n        return res == nums.length ? -1 : res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)，保存哈希表需要N个空间长度。\r\n\r\n[参考题解](https://leetcode.cn/problems/make-sum-divisible-by-p/solutions/809758/shu-zu-zheng-chu-wen-ti-hui-zong-qian-zh-xzjc/)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463087771","body":"### 思路\r\n快慢指针，两个指针同时从头节点出发，当快指针不为空且存在下个节点时，慢指针走一步，快指针走两步。直到快指针走到尾节点。此时，慢指针走到中间节点。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n        if(head == null){\r\n            return head;\r\n        }\r\n        ListNode s = head, f = head;\r\n        while(f!=null && f.next !=null){\r\n            s = s.next;\r\n            f = f.next.next;\r\n        }\r\n        return s;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为链表长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464925709","body":"### 思路\r\n双指针, i 指向无重复的数组, j 指向重复数据的后一位.\r\n如果 nums[i] == nums[j] 时,只移动 j 指针.\r\n当 nums[i] != nums[j] 时, 先移动 i 指针,并将 nums[j] 的值赋到nums[i] 中, 再移动 j 指针.\r\n最后返回 i+1.\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int i = 0,j = 1;\r\n        for(; j < nums.length;){\r\n            if(nums[i] == nums[j]){\r\n                j++;\r\n            } else {\r\n                nums[++i] = nums[j++];\r\n            }\r\n        }\r\n        return i+1;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465224185","body":"### 思路\r\n遍历数组，当 nums[i] == 目标值target  或者 nums[i] > target 时，直接将下标 i 返回。\r\n否则返回 nums.length。\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int searchInsert(int[] nums, int target) {\r\n        for(int i = 0; i < nums.length; i++){\r\n            if(nums[i] == target || nums[i] > target) {\r\n                return i;\r\n            }\r\n        }\r\n        return nums.length;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465713557","body":"### 思路\r\n优先队列\r\n使用优先队列做大顶堆，在加入一个元素的之后，需要将窗口最左侧的值出队。\r\n因此队列需要使用 int[] 作为类型，保存遍历的下标和值。具体步骤在代码中。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        // 1. 将 nums 的前k个元素放入优先队列中\r\n        int n = nums.length;\r\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>(){\r\n            public int compare(int[] pair1, int[] pair2){\r\n                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair2[1];\r\n            }\r\n        });\r\n        for(int i = 0; i<k; i++){\r\n            queue.offer(new int[]{nums[i], i});\r\n        }\r\n        int[] ans = new int[n - k + 1];\r\n        ans[0] = queue.peek()[0];\r\n        // 2. 向右移动时，将一个元素入队，此时堆顶为最大值\r\n        for(int i = k; i<nums.length; i++){\r\n            queue.offer(new int[]{nums[i], i});\r\n            // 3. 将最左侧的值出队\r\n            while(queue.peek()[1] <= i - k){\r\n                queue.poll();\r\n            }\r\n            // 将堆顶保存\r\n            ans[i - k + 1] = queue.peek()[0];\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467414809","body":"### 思路\r\nn为图的节点，trust[i] 为图的有向边。\r\n依题意，需要找到出度为0，入度为 n-1 的节点。\r\n1. 遍历trust数组，使用两个一维数组 in 和 out 统计节点的入度和出度。\r\n2. 遍历 n，找到符合题意的节点下标返回，否则返回 -1.\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int findJudge(int n, int[][] trust) {\r\n        int[] in = new int[n];\r\n        int[] out = new int[n];\r\n        for (int[] node : trust) {\r\n            out[node[0]-1]++;\r\n            in[node[1]-1]++;\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            if (out[i] == 0 && in[i] == (n-1)){\r\n                return i+1;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N+M)，其中,N 为小镇人数， M 为trust数组长度。\r\n- 空间复杂度：O(N)，需要用两个 N 空间统计出度和入度。","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473261488","body":"### 思路\r\n遍历给定的字符串，如果是 R或L，则修改rl，如果是 U或D，则修改ud。\r\n最后判断 rl==0 && ud == 0。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public boolean judgeCircle(String moves) {\r\n        int rl = 0;\r\n        int ud = 0;\r\n        for(char ch: moves.toCharArray()){\r\n            if('R' == ch){\r\n                rl--;\r\n            } else if('L' == ch){\r\n                rl++;\r\n            } else if('U' == ch){\r\n                ud--;\r\n            } else if('D' == ch){\r\n                ud++;\r\n            }\r\n        }\r\n        return rl==0 && ud == 0;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474883113","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int[] getOrder(int[][] ts) {\r\n        int n = ts.length;\r\n        // 将 ts 转存成 nts，保留任务编号\r\n        int[][] nts = new int[n][3];\r\n        for (int i = 0; i < n; i++) nts[i] = new int[]{ts[i][0], ts[i][1], i};\r\n        // 根据任务入队时间进行排序\r\n        Arrays.sort(nts, (a,b)->a[0]-b[0]);\r\n        // 根据题意，先按照「持续时间」排序，再根据「任务编号」排序\r\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->{\r\n            if (a[1] != b[1]) return a[1] - b[1];\r\n            return a[2] - b[2];\r\n        });\r\n        int[] ans = new int[n];\r\n        for (int time = 1, j = 0, idx = 0; idx < n; ) {\r\n        \t// 如果当前任务可以添加到「队列」中（满足入队时间）则进行入队\r\n            while (j < n && nts[j][0] <= time) q.add(nts[j++]);\r\n            if (q.isEmpty()) {\r\n\t            // 如果当前「队列」没有任务，直接跳到下个任务的入队时间\r\n                time = nts[j][0];\r\n            } else {\r\n            \t// 如果有可执行任务的话，根据优先级将任务出队（记录下标），并跳到该任务完成时间点\r\n                int[] cur = q.poll();\r\n                ans[idx++] = cur[2];\r\n                time += cur[1];\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(NlogN)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475217590","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int numberOfRounds(String loginTime, String logoutTime) {\r\n        int in = 60 * Integer.parseInt(loginTime.substring(0,2)) + Integer.parseInt(loginTime.substring(3,5));\r\n        int out = 60 * Integer.parseInt(logoutTime.substring(0,2)) + Integer.parseInt(logoutTime.substring(3,5));\r\n        if(out < in) {\r\n            // outTime 为第二天\r\n            out += 1440;\r\n        }\r\n        out = out / 15 * 15;\r\n        return Math.max(0, (out - in)) / 15;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475879937","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int minCharacters(String a, String b) {\r\n         int n = a.length(), m = b.length(), ans = 0x3f3f3f3f;\r\n        int[] c1 = new int[26], c2 = new int[26];\r\n        for (char c : a.toCharArray()) c1[c - 'a']++;\r\n        for (char c : b.toCharArray()) c2[c - 'a']++;\r\n        for (int i = 0; i < 26 && ans != 0; i++) {\r\n            // 3\r\n            int ca = n - c1[i], cb = m - c2[i];\r\n            ans = Math.min(ans, ca + cb);\r\n            if (i == 0) continue;\r\n            int r1 = 0, r2 = 0;\r\n            // 1\r\n            for (int j = i; j < 26; j++) r1 += c1[j];\r\n            for (int j = 0; j < i; j++) r1 += c2[j];\r\n            // 2\r\n            for (int j = i; j < 26; j++) r2 += c2[j];\r\n            for (int j = 0; j < i; j++) r2 += c1[j];\r\n            ans = Math.min(ans, Math.min(r1, r2));\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N^2)，其中 N 为26个字母的长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1478011701","body":"### 思路\r\n堆排序\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int[] sortArray(int[] nums) {\r\n        heapSort(nums);\r\n        return nums;\r\n    }\r\n\r\n    public void heapSort(int[] nums) {\r\n        int len = nums.length - 1;\r\n        buildMaxHeap(nums, len);\r\n        for (int i = len; i >= 1; --i) {\r\n            swap(nums, i, 0);\r\n            len -= 1;\r\n            maxHeapify(nums, 0, len);\r\n        }\r\n    }\r\n\r\n    public void buildMaxHeap(int[] nums, int len) {\r\n        for (int i = len / 2; i >= 0; --i) {\r\n            maxHeapify(nums, i, len);\r\n        }\r\n    }\r\n\r\n    public void maxHeapify(int[] nums, int i, int len) {\r\n        for (; (i << 1) + 1 <= len;) {\r\n            int lson = (i << 1) + 1;\r\n            int rson = (i << 1) + 2;\r\n            int large;\r\n            if (lson <= len && nums[lson] > nums[i]) {\r\n                large = lson;\r\n            } else {\r\n                large = i;\r\n            }\r\n            if (rson <= len && nums[rson] > nums[large]) {\r\n                large = rson;\r\n            }\r\n            if (large != i) {\r\n                swap(nums, i, large);\r\n                i = large;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void swap(int[] nums, int i, int j) {\r\n        int temp = nums[i];\r\n        nums[i] = nums[j];\r\n        nums[j] = temp;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(nlogn)，其中 n 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479620930","body":"### 解法\r\n1. 袖珍计算器算法：对根号x进行换底等变换，得到等价式子：e^(0.5*lnx)\r\n使用Math.exp() 以及 Math.log() 函数进行计算如下。\r\n```java\r\nclass Solution {\r\n    public int mySqrt(int x) {\r\n        if(x == 0){\r\n            return 0;\r\n        }\r\n        int ans = (int) Math.exp(0.5 * Math.log(x));\r\n        return (long) (ans + 1) * (ans + 1) <= x ? ans+1 : ans;\r\n    }\r\n}\r\n\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(1)\r\n\r\n2. 二分法\r\n求x的开方，可以转换为 k^2 <= x（k 为整数）。\r\n定义 left = 0, right = x, ans = -1，进行while 循环计算 mid，判断 (long)mid*mid 是否小于等于 x，直到 left > right 退出循环。\r\n```java\r\nclass Solution {\r\n    public int mySqrt(int x) {\r\n        int l = 0, r = x, ans = -1;\r\n        while(l <= r){\r\n            int mid = l + (r - l) / 2;\r\n            if((long) mid * mid <= x){\r\n                ans = mid;\r\n                l = mid + 1;\r\n            } else {\r\n                r = mid - 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(logx)\r\n- 空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1481403859","body":"### 思路\r\n二分法查找第一个为true的下标。\r\n### 代码\r\n\r\n```java\r\npublic class Solution extends VersionControl {\r\n    public int firstBadVersion(int n) {\r\n        int l = 0, r = n, ans = -1;\r\n        while(l <= r){\r\n            int mid = l + (r-l)/2;\r\n            if(isBadVersion(mid)) {\r\n                ans = mid;\r\n                r = mid - 1;\r\n            } else {\r\n                l = mid + 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(logN)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482950394","body":"#### 代码\r\n```java\r\nclass Solution {\r\n    public int reversePairs(int[] nums) {\r\n        if(nums.length == 0) return 0;\r\n        return reversePairsRecursive(nums, 0, nums.length - 1);\r\n    }\r\n    public int reversePairsRecursive(int[] nums, int l, int r){\r\n        if(l == r){\r\n            return 0;\r\n        } else {\r\n            int mid = (l + r) /2;\r\n            int n1 = reversePairsRecursive(nums, l, mid);\r\n            int n2 = reversePairsRecursive(nums, mid+1, r);\r\n            int res = n1 + n2;\r\n            // 统计下标对数量\r\n            int i = l;\r\n            int j = mid + 1;\r\n            while(i <= mid){\r\n                while(j <= r && (long) nums[i] > 2 *(long)nums[j]){\r\n                    j ++;\r\n                }\r\n                res += j - mid - 1;\r\n                i++;\r\n            }\r\n\r\n\r\n            // 合并两个排序数组\r\n            int[] sort = new int[r - l + 1];\r\n            int p1 = l, p2 = mid + 1;\r\n            int p = 0;\r\n            while(p1 <= mid || p2 <= r){\r\n                if(p1 > mid){\r\n                    sort[p++] = nums[p2++];\r\n                } else if(p2 > r) {\r\n                    sort[p++] = nums[p1++];\r\n                } else{\r\n                    if(nums[p1] < nums[p2]){\r\n                        sort[p++] = nums[p1++];\r\n                    } else{\r\n                        sort[p++] = nums[p2++];\r\n                    }\r\n                }\r\n            }\r\n            for(int k = 0; k < sort.length; k++){\r\n                nums[l + k] = sort[k];\r\n            }\r\n            return res;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483750778","body":"### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int findRadius(int[] houses, int[] heaters) {\r\n        int ans = 0;\r\n        Arrays.sort(heaters);\r\n        for(int house:houses){\r\n            int i = binarySearch(heaters, house);\r\n            int j = i +1;\r\n            int leftDistance = i < 0? Integer.MAX_VALUE : house - heaters[i];\r\n            int rightDistance = j >= heaters.length ? Integer.MAX_VALUE : heaters[j] - house;\r\n            ans = Math.max(ans, leftDistance < rightDistance ? leftDistance : rightDistance);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public int binarySearch(int[] nums, int target){\r\n        int left = 0, right = nums.length - 1;\r\n        if(nums[left] > target){\r\n            return -1;\r\n        }\r\n        while(left < right){\r\n            int mid = left + (right - left + 1) / 2;\r\n            if (nums[mid] > target){\r\n                right = mid - 1;\r\n            } else {\r\n                left = mid;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O((n+m)logn)，其中 m 为houses数组的长度，n为heaters数组的长度。\r\n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1484127804","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int smallestDistancePair(int[] nums, int k) {\r\n        Arrays.sort(nums);\r\n        int n = nums.length, left = 0, right = nums[n - 1] - nums[0];\r\n        while(left <= right){\r\n            int mid = (left + right) / 2;\r\n            int cnt = 0;\r\n            for(int j = 0; j< n; j ++){\r\n                int i = binarySearch(nums, j, nums[j] - mid);\r\n                cnt += j - i;\r\n            }\r\n            if(cnt >= k){\r\n                right = mid -1;\r\n            } else {\r\n                left = mid +1;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n    public int binarySearch(int[] nums, int end, int target){\r\n        int left = 0, right = end;\r\n        while(left < right){\r\n            int mid = (left + right) / 2;\r\n            if(nums[mid] < target){\r\n                left = mid + 1;\r\n            } else{\r\n                right = mid;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(nlogn * logD)\r\n- 空间复杂度：O(logn)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486139976","body":"### 代码\r\n```java\r\npublic class Q1456MaximumNumberOfVowelsInASubstringOfGivenLength {\r\n    public static void main(String[] args) {\r\n        Solution solution = new Q1456MaximumNumberOfVowelsInASubstringOfGivenLength().new Solution();\r\n        System.out.println(solution.maxVowels(\"weallloveyou\", 7));\r\n    }\r\n\r\n    class Solution {\r\n        public int maxVowels(String s, int k) {\r\n           String vowels = \"aeiou\";\r\n           int n = s.length();\r\n            int l = 0, r = (l + k) < n ? l + k : n;\r\n            int cnt = 0;\r\n            for (int i = l; i < r; i++) {\r\n                if (vowels.indexOf(s.charAt(i)) >= 0){\r\n                    cnt ++;\r\n                }\r\n            }\r\n            int ans = cnt;\r\n            for(int i = r; i < n; i++){\r\n                if (vowels.indexOf(s.charAt(i - k)) >= 0){\r\n                    cnt--;\r\n                }\r\n                if (vowels.indexOf(s.charAt(i)) >= 0){\r\n                    cnt++;\r\n                }\r\n                ans = ans > cnt ? ans : cnt;\r\n            }\r\n            return ans;\r\n        }\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(|n|)，其中 n 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488741599","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public double new21Game(int n, int k, int maxPts) {\r\n            if (k == 0) {\r\n                return 1.0;\r\n            }\r\n            double[] dp = new double[k + maxPts];\r\n            for (int i = k; i <= n && i < k + maxPts; i++) {\r\n                dp[i] = 1.0;\r\n            }\r\n            dp[k - 1] = 1.0 * Math.min(n-k+1, maxPts) / maxPts;\r\n            for (int i = k - 2; i >= 0; i--) {\r\n                dp[i] = dp[i + 1] - (dp[i+maxPts+1] - dp[i + 1]) / maxPts;\r\n            }\r\n            return dp[0];\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(min(n, k+ maxPts))\r\n- 空间复杂度：O(k+maxPts)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489885679","body":"### 思路\r\n滑动窗口。\r\n1.处理特殊情况，如果 s 的长度小于 p 的长度可以直接返回。\r\n2.使用两个数组分别统计s和滑动窗口中各个字母出现数目。\r\n3. 第一次需要遍历s的长度，第二次循环从 0 到 s.length() - p.length() 即可。\r\n\r\n### 代码\r\n```java\r\npublic class Q0438FindAllAnagramsInAString {\r\n    public static void main(String[] args) {\r\n        Solution solution = new Q0438FindAllAnagramsInAString().new Solution();\r\n        List<Integer> anagrams = solution.findAnagrams(\"cbaebabacd\", \"abc\");\r\n        System.out.println(Arrays.toString(anagrams.toArray()));\r\n    }\r\n    class Solution {\r\n        public List<Integer> findAnagrams(String s, String p) {\r\n            List<Integer> res = new ArrayList<>();\r\n            if (s.length() < p.length()) {\r\n                return res;\r\n            }\r\n            int pLen = p.length();\r\n            int sLen = s.length();\r\n            // 使用数组存储字符串 p 和 滑动窗口中每种字母得数量\r\n            int[] pCnt = new int[26];\r\n            int[] sCnt = new int[26];\r\n\r\n            for (int i = 0; i < pLen; i++) {\r\n                pCnt[p.charAt(i) - 'a']++;\r\n                sCnt[s.charAt(i) - 'a']++;\r\n            }\r\n            if (Arrays.equals(pCnt, sCnt)) {\r\n                res.add(0);\r\n            }\r\n\r\n            for (int i = 0; i < sLen - pLen; i++) {\r\n                sCnt[s.charAt(i) - 'a']--;\r\n                sCnt[s.charAt(i + pLen) - 'a']++;\r\n                if (Arrays.equals(pCnt, sCnt)) {\r\n                    res.add(i + 1);\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1492051953","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public String minWindow(String s, String t) {\r\n        if(s == null || s == \"\" || t == null || t == \"\" || s.length() < t.length()){\r\n            return \"\";\r\n        }\r\n        int[] tCnt = new int[128];\r\n        int[] sCnt = new int[128];\r\n        // 统计目标字符串中的字符数量\r\n        int tLen = t.length();\r\n        int sLen = s.length();\r\n        for(int i = 0; i< tLen; i++){\r\n            tCnt[t.charAt(i)]++;\r\n        }\r\n        int left = 0, right = 0, min = sLen + 1;\r\n        int count = 0, start = 0;\r\n        while(right < sLen){\r\n            char ch = s.charAt(right);\r\n            if(tCnt[ch] == 0){\r\n                right++;\r\n                continue;\r\n            }\r\n            if(sCnt[ch] < tCnt[ch]){\r\n                count++;\r\n            }\r\n            sCnt[ch]++;\r\n            right++;\r\n            while(count == tLen){\r\n                if(right - left < min){\r\n                    min = right - left;\r\n                    start = left;\r\n                }\r\n                char l = s.charAt(left);\r\n                if(tCnt[l] == 0){\r\n                    left++;\r\n                    continue;\r\n                }\r\n                if(sCnt[l] == tCnt[l]){\r\n                    count--;\r\n                }\r\n                sCnt[l]--;\r\n                left++;\r\n            }\r\n        }\r\n        if(min == sLen + 1){\r\n            return \"\";\r\n        }\r\n        return s.substring(start, start+min);\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1492895832","body":"### 代码\n```java\nclass Solution {\n    public int maxScore(int[] cardPoints, int k) {\n        int n = cardPoints.length;\n        int windowSize = n - k;\n        int sum = 0;\n        for(int i = 0; i< windowSize; i++){\n            sum += cardPoints[i];\n        }\n        int minSum = sum;\n        for(int i = windowSize; i<n; i++){\n            sum += cardPoints[i] - cardPoints[i - windowSize];\n            minSum = minSum < sum ? minSum : sum; \n        }\n        return Arrays.stream(cardPoints).sum() - minSum;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493378822","body":"### 代码\n```java\nclass Solution {\n    public List<String> readBinaryWatch(int turnedOn) {\n        List<String> ans = new ArrayList<String>();\n        for (int h = 0; h < 12; ++h) {\n            for (int m = 0; m < 60; ++m) {\n                if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) {\n                    ans.add(h + \":\" + (m < 10 ? \"0\" : \"\") + m);\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494426055","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int totalNQueens(int n) {\r\n      return backtrack(n, 0, 0, 0, 0);\r\n    }\r\n    public int backtrack(int n, int row, int col, int d1, int d2){\r\n        if(row == n){\r\n            return 1;\r\n        } else {\r\n            int count = 0;\r\n            int availablePosition = ((1<<n) - 1) & (~(col | d1 | d2));\r\n            while(availablePosition != 0){\r\n                int position = availablePosition & (-availablePosition);\r\n                availablePosition = availablePosition & (availablePosition - 1);\r\n                count += backtrack(n, row+1, col|position, (d1|position)<<1, (d2|position)>>1);\r\n            }\r\n            return count;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N!)，其中 N 为皇后数量。\r\n- 空间复杂度：O(N)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1496229608","body":"### 代码\n\n```java\nclass Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        int ans = 0;\n        for (int i = 0; i != grid.length; ++i) {\n            for (int j = 0; j != grid[0].length; ++j) {\n                ans = Math.max(ans, dfs(grid, i, j));\n            }\n        }\n        return ans;\n    }\n\n    public int dfs(int[][] grid, int cur_i, int cur_j) {\n        if (cur_i < 0 || cur_j < 0 || cur_i == grid.length || cur_j == grid[0].length || grid[cur_i][cur_j] != 1) {\n            return 0;\n        }\n        grid[cur_i][cur_j] = 0;\n        int[] di = {0, 0, 1, -1};\n        int[] dj = {1, -1, 0, 0};\n        int ans = 1;\n        for (int index = 0; index != 4; ++index) {\n            int next_i = cur_i + di[index], next_j = cur_j + dj[index];\n            ans += dfs(grid, next_i, next_j);\n        }\n        return ans;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(MxN)\n- 空间复杂度：O(MxN)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497527301","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int maxDistance(int[][] grid) {\r\n        final int INF = 1000000;\r\n        int[] dx = {-1, 0, 1, 0};\r\n        int[] dy = {0, 1, 0, -1};\r\n        int n = grid.length;\r\n        int[][] d = new int[n][n];\r\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>(){\r\n            public int compare(int[] s1, int[] s2){\r\n                return s1[0] - s2[0];\r\n            }\r\n        });\r\n        for(int i = 0; i< n; i++){\r\n            for(int j = 0; j<n; j++){\r\n                d[i][j] = INF;\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i< n; i++){\r\n            for(int j = 0; j<n; j++){\r\n                if(grid[i][j] == 1){\r\n                    d[i][j] = 0;\r\n                    queue.offer(new int[]{0, i, j});\r\n                }\r\n            }\r\n        }\r\n\r\n        while(!queue.isEmpty()){\r\n            int[] f = queue.poll();\r\n            for(int i = 0; i<4; i++){\r\n                int nx = f[1] + dx[i], ny = f[2]+dy[i];\r\n                if(!(nx >= 0 && nx < n && ny >= 0 && ny < n)){\r\n                    continue;\r\n                }\r\n                if(f[0] + 1 < d[nx][ny]){\r\n                    d[nx][ny] = f[0] + 1;\r\n                    queue.offer(new int[]{d[nx][ny], nx, ny});\r\n                }\r\n            }\r\n        }\r\n\r\n        int ans = -1;\r\n        for(int i = 0; i< n; i++){\r\n            for(int j = 0; j<n; j++){\r\n                if(grid[i][j] == 0){\r\n                    ans = ans > d[i][j] ? ans : d[i][j];\r\n                }\r\n            }\r\n        }\r\n        return ans == INF ? -1 : ans;\r\n        \r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N^2)，其中 N 为二维数组长度。\r\n- 空间复杂度：O(N^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1499268736","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {\r\n        int len = status.length;\r\n        boolean[] visited = new boolean[len];\r\n        Set<Integer> haveBox = new HashSet<>();\r\n        Set<Integer> haveKey = new HashSet<>();\r\n        Queue<Integer> q = new LinkedList<>();\r\n        for(int i = 0; i< initialBoxes.length; i++){\r\n            int idx = initialBoxes[i];\r\n            haveBox.add(idx);\r\n            if(status[idx] == 1){\r\n                q.offer(idx);\r\n                visited[idx] = true;\r\n            }\r\n        }\r\n\r\n        int ans = 0;\r\n        while(!q.isEmpty()){\r\n            Integer cur = q.poll();\r\n            ans+= candies[cur];\r\n            int[] curKey = keys[cur];\r\n            int[] curBox = containedBoxes[cur];\r\n            for(int key:curKey){\r\n                haveKey.add(key);\r\n                if(!visited[key] && haveBox.contains(key)){\r\n                    q.offer(key);\r\n                    visited[key] = true;\r\n                }\r\n            }\r\n            for(int box: curBox){\r\n                haveBox.add(box);\r\n                if(!visited[box] && (haveKey.contains(box) || status[box] == 1)){\r\n                    q.offer(box);\r\n                    visited[box] = true;\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500881843","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int minCostClimbingStairs(int[] cost) {\r\n        int n = cost.length;\r\n        int[] dp = new int[n+1];\r\n        dp[0] = dp[1] = 0;\r\n        for(int i = 2; i<=n; i++){\r\n            dp[i] = Math.min(dp[i-1]+cost[i-1], dp[i-2] + cost[i-2]);\r\n        }\r\n        return dp[n];\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501130471","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int rob(int[] nums) {\r\n        if(nums.length == 0){\r\n            return 0;\r\n        }\r\n        int N = nums.length;\r\n        int[] dp = new int[N+1];\r\n        dp[0] = 0;\r\n        dp[1] = nums[0];\r\n        for(int k = 2; k <= N; k++){\r\n            dp[k] = Math.max(dp[k-1], nums[k-1]+dp[k-2]);\r\n        }\r\n        return dp[N];\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501904664","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int findNumberOfLIS(int[] nums) {\r\n        int n = nums.length, maxLen = 0, ans = 0;\r\n        int[] dp = new int[n];\r\n        int[] cnt = new int[n];\r\n        for(int i = 0; i<n; i++){\r\n            dp[i] = 1;\r\n            cnt[i] = 1;\r\n            for(int j = 0; j<i; j++){\r\n                if(nums[i] > nums[j]){\r\n                    if(dp[j] + 1 > dp[i]){\r\n                        dp[i] = dp[j] + 1;\r\n                        cnt[i] = cnt[j]; // 重置计数\r\n                    } else if(dp[j] + 1 == dp[i]){\r\n                        cnt[i] += cnt[j];\r\n                    }\r\n                }\r\n            }\r\n            if(dp[i] > maxLen){\r\n                maxLen = dp[i];\r\n                ans = cnt[i];\r\n            } else if(dp[i] == maxLen){\r\n                ans += cnt[i];\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N^2)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1502995522","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int longestCommonSubsequence(String text1, String text2) {\r\n        int[][] dp = new int[text1.length()+1][text2.length()+1];\r\n        for(int i = 1; i<=text1.length(); i++){\r\n            char a = text1.charAt(i-1);\r\n            for(int j = 1; j <= text2.length(); j++){\r\n                char b =text2.charAt(j-1);\r\n                if(a == b){\r\n                    dp[i][j] = dp[i-1][j-1]+1;\r\n                } else{\r\n                    dp[i][j] = dp[i-1][j] > dp[i][j-1] ? dp[i-1][j] : dp[i][j-1];\r\n                }\r\n            }\r\n        }\r\n        return dp[text1.length()][text2.length()];\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N*M)，其中 N,M分别为两个字符串的长度。\r\n- 空间复杂度：O(N*M)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1505532822","body":"### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int uniquePaths(int m, int n) {\r\n        int[] cur = new int[n];\r\n        Arrays.fill(cur,1);\r\n        for (int i = 1; i < m;i++){\r\n            for (int j = 1; j < n; j++){\r\n                cur[j] += cur[j-1] ;\r\n            }\r\n        }\r\n        return cur[n-1];\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N*M)。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1507199465","body":"### 代码\r\n```java\r\nclass Solution {\r\n    static int[][] dirs = {{-2,-1}, {-2,1},{2,-1},{2,1},{-1,-2},{-1,2},{1,-2},{1,2}};\r\n\r\n    public double knightProbability(int n, int k, int row, int column) {\r\n        double[][][] dp = new double[k+1][n][n];\r\n        for(int step = 0; step <= k; step++){\r\n            for(int i = 0; i<n; i++){\r\n                for(int j = 0; j<n; j++){\r\n                    if(step == 0){\r\n                        dp[step][i][j] = 1;\r\n                    } else {\r\n                        for(int[] dir:dirs){\r\n                            int ni = i+dir[0], nj = j + dir[1];\r\n                            if(ni >= 0 && ni < n && nj >=0 && nj < n) {\r\n                                dp[step][i][j] += dp[step - 1][ni][nj] / 8;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return dp[k][row][column];\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(k*N^2)，其中 N 为数组长度。\r\n- 空间复杂度：O(k*N^2)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509873253","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public boolean canPartition(int[] nums) {\r\n        int n = nums.length;\r\n        if(n < 2){\r\n            return false;\r\n        }\r\n        int sum = 0, maxNum = 0;\r\n        for(int num: nums){\r\n            sum += num;\r\n            maxNum = Math.max(maxNum, num);\r\n        }\r\n        if(sum % 2 != 0){\r\n            return false;\r\n        }\r\n        int target = sum / 2;\r\n        if(maxNum > target){\r\n            return false;\r\n        }\r\n        boolean[] dp = new boolean[target+1];\r\n        dp[0] = true;\r\n        for(int i = 0; i<n; i++){\r\n            int num = nums[i];\r\n            for(int j= target; j >= num; j--){\r\n                dp[j] |= dp[j-num];\r\n            }\r\n        }\r\n        return dp[target];\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N*target)，其中 N 为数组长度。\r\n- 空间复杂度：O(target)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1509940148","body":"### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int findTargetSumWays(int[] nums, int target) {\r\n        int sum = 0;\r\n        for(int num:nums){\r\n            sum += num;\r\n        }\r\n        int diff = sum - target;\r\n        if(diff < 0 || diff % 2 != 0){\r\n            return 0;\r\n        }\r\n        int n = nums.length, neg = diff / 2;\r\n        int[][] dp = new int[n+1][neg+1];\r\n        dp[0][0] = 1;\r\n        for(int i = 1; i <= n; i++){\r\n            int num = nums[i - 1];\r\n            for(int j = 0; j <= neg; j++){\r\n                dp[i][j] = dp[i-1][j];\r\n                if(j >= num){\r\n                    dp[i][j] += dp[i-1][j-num];\r\n                }\r\n            }\r\n        }\r\n        return dp[n][neg];\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N(sum-target))\r\n- 空间复杂度：O(sum-target)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511622279","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int coinChange(int[] coins, int amount) {\r\n        if(amount < 1){\r\n            return 0;\r\n        }\r\n        return coinChange(coins, amount, new int[amount]);\r\n    }\r\n    private int coinChange(int[] coins, int rem, int[] count){\r\n        if(rem < 0){\r\n            return -1;\r\n        }\r\n        if(rem == 0){\r\n            return 0;\r\n        }\r\n        if(count[rem - 1] != 0){\r\n            return count[rem - 1];\r\n        }\r\n        int min = Integer.MAX_VALUE;\r\n        for(int coin:coins){\r\n            int res = coinChange(coins, rem - coin, count);\r\n            if(res >= 0 && res < min){\r\n                min = 1 + res;\r\n            }\r\n        }\r\n        count[rem - 1] = (min == Integer.MAX_VALUE) ? -1 : min;\r\n        return count[rem - 1];\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(Sn)，其中 S 是金额，n是面额数。\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1513378386","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int change(int amount, int[] coins) {\r\n        int[] dp = new int[amount+1];\r\n        dp[0] = 1;\r\n        for(int coin: coins){\r\n            for(int i = coin; i<=amount; i++){\r\n                dp[i] += dp[i - coin];\r\n            }\r\n        }\r\n        return dp[amount];\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(amount*n)，其中amount为总金额， n为数组coins的长度。\r\n- 空间复杂度：O(amount)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514983886","body":"### 代码\n```java\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int m = g.length, n = s.length;\n        int count = 0;\n        for (int i = 0, j = 0; i < m && j < n; i++, j++) {\n            while (j < n && g[i] > s[j]) {\n                j++;\n            }\n            if (j < n) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516549229","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int eraseOverlapIntervals(int[][] intervals) {\r\n        if(intervals.length == 0){\r\n            return 0;\r\n        }\r\n\r\n        Arrays.sort(intervals, new Comparator<int[]>(){\r\n            public int compare(int[] interval1, int[] interval2){\r\n                return interval1[1] - interval2[1];\r\n            }\r\n        });\r\n\r\n        int n = intervals.length;\r\n        int right = intervals[0][1];\r\n        int ans = 1;\r\n        for(int i = 1; i<n; i++){\r\n            if(intervals[i][0] >= right){\r\n                ans++;\r\n                right = intervals[i][1];\r\n            }\r\n        }\r\n        return n - ans;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(nlogn)，其中 N 为数组长度。\r\n- 空间复杂度：O(logn)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518690096","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int numTrees(int n) {\r\n        int[] G = new int[n + 1];\r\n        G[0] = 1;\r\n        G[1] = 1;\r\n        for(int i = 2; i<=n; i++){\r\n            for(int j = 1; j<=i; j++){\r\n                G[i] += G[j - 1] * G[i - j];\r\n            }\r\n        }\r\n        return G[n];\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N^2)，其中 N 为二叉搜索树的节点个数。\r\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1520237301","body":"### 代码\r\n```java\r\nclass Solution {\r\n    Map<Integer, int[]> memo;\r\n    public int[] beautifulArray(int n) {\r\n        memo = new HashMap();\r\n        return f(n);\r\n    }\r\n    public int[] f(int n){\r\n        if(memo.containsKey(n)){\r\n            return memo.get(n);\r\n        }\r\n\r\n        int[] ans = new int[n];\r\n        if(n == 1){\r\n            ans[0] = 1;\r\n        } else {\r\n            int t = 0;\r\n            for(int x: f((n+1)/2)){\r\n                ans[t++] = 2*x-1;\r\n            } \r\n            for(int x:f(n/2)){\r\n                ans[t++] = 2*x;\r\n            }\r\n        }\r\n        memo.put(n, ans);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(nlogn)，f(n)调用logn次，每次时间消耗O(n)。\r\n- 空间复杂度：O(nlogn)，f(n)调用logn次，形成大小为logn的递归栈，每次需要存储长度为n的数组空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521938094","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int[] singleNumber(int[] nums) {\r\n        int xorsum = 0;\r\n        for(int num:nums){\r\n            xorsum ^= num;\r\n        }\r\n        int lsb = (xorsum == Integer.MIN_VALUE ? xorsum : xorsum & (-xorsum));\r\n        int t1 = 0, t2 = 0;\r\n        for(int num : nums){\r\n            if((num & lsb) != 0){\r\n                t1 ^= num;\r\n            } else{\r\n                t2 ^= num;\r\n            }\r\n        }\r\n        return new int[]{t1, t2};\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1523601154","body":"### 代码\n```java\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> res = new LinkedList<>();\n        int start = 0, end = 1 << nums.length;\n        for(int sign = start; sign < end; sign++){\n            List<Integer> list = new LinkedList<>();\n            for(int i = 0; i<nums.length; i++){\n                if(((1<<i) & sign) != 0){\n                    list.add(nums[i]);\n                }\n            }\n                res.add(list);\n        }\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N*2^N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1525939340","body":"### 代码\r\n```java\r\nclass Trie {\r\n    TrieNode root;\r\n    public Trie() {\r\n         root = new TrieNode();\r\n    }\r\n    \r\n    public void insert(String word) {\r\n         TrieNode node = root;\r\n\r\n        for (int i = 0; i < word.length(); i++) {\r\n\r\n            if (node.children[word.charAt(i) - 'a'] == null)\r\n                node.children[word.charAt(i) - 'a'] = new TrieNode();\r\n\r\n            node = node.children[word.charAt(i) - 'a'];\r\n            node.preCount++;\r\n        }\r\n\r\n        node.count++;\r\n    }\r\n    \r\n    public boolean search(String word) {\r\n        \r\n        TrieNode node = root;\r\n\r\n        for (int i = 0; i < word.length(); i++) {\r\n\r\n            if (node.children[word.charAt(i) - 'a'] == null)\r\n                return false;\r\n\r\n            node = node.children[word.charAt(i) - 'a'];\r\n        }\r\n\r\n        return node.count > 0;\r\n    }\r\n    \r\n    public boolean startsWith(String prefix) {\r\n        \r\n        TrieNode node = root;\r\n\r\n        for (int i = 0; i < prefix.length(); i++) {\r\n\r\n            if (node.children[prefix.charAt(i) - 'a'] == null)\r\n                return false;\r\n            node = node.children[prefix.charAt(i) - 'a'];\r\n        }\r\n\r\n        return node.preCount > 0;\r\n    }\r\n     private class TrieNode {\r\n\r\n        int count; //表示以该处节点构成的串的个数\r\n        int preCount; //表示以该处节点构成的前缀的字串的个数\r\n        TrieNode[] children;\r\n\r\n        TrieNode() {\r\n\r\n            children = new TrieNode[26];\r\n            count = 0;\r\n            preCount = 0;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1525985718","body":"### 代码\r\n```java\r\nclass MapSum {\r\n    Map<String, Integer> map;\r\n    Map<String, Integer> prefixmap;\r\n    public MapSum() {\r\n        map = new HashMap<>();\r\n        prefixmap = new HashMap<>();\r\n    }\r\n    \r\n    public void insert(String key, int val) {\r\n        int detal = val - map.getOrDefault(key, 0);\r\n        map.put(key, val);\r\n        for(int i = 1; i<=key.length(); i++){\r\n            String cur = key.substring(0,i);\r\n            prefixmap.put(cur, prefixmap.getOrDefault(cur, 0) +detal);\r\n        }\r\n    }\r\n    \r\n    public int sum(String prefix) {\r\n        return prefixmap.getOrDefault(prefix, 0);\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：insert: O(N^2)，sum: O(1)其中 N 为数组长度。\r\n- 空间复杂度：O(MN)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1531310279","body":"### 代码\r\n```java\r\nclass Solution {\r\n    List<Integer>[] edges;\r\n    boolean[] used;\r\n    public int makeConnected(int n, int[][] connections) {\r\n        if(connections.length < n - 1){\r\n            return -1;\r\n        }\r\n        edges = new List[n];\r\n        for(int i = 0; i<n; i++){\r\n            edges[i] = new ArrayList<Integer>();\r\n        }\r\n        for(int[] conn: connections){\r\n            edges[conn[0]].add(conn[1]);\r\n            edges[conn[1]].add(conn[0]);\r\n        }\r\n        used = new boolean[n];\r\n        int ans = 0;\r\n        for(int i = 0; i<n; i++){\r\n            if(!used[i]){\r\n                dfs(i);\r\n                ans++;\r\n            }\r\n        }\r\n        return ans - 1;\r\n    }\r\n    private void dfs(int u){\r\n        used[u] = true;\r\n        for(int v : edges[u]){\r\n            if(!used[v]){\r\n                dfs(v);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N+M)，其中 M 为数组connections长度。\r\n- 空间复杂度：O(N+M)，其中 O(M) 为存储所有边需要的空间，O(N)为dfs中使用栈空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1533167894","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public TreeNode pruneTree(TreeNode root) {\r\n        if(root == null){\r\n            return null;\r\n        }\r\n        root.left = pruneTree(root.left);\r\n        root.right = pruneTree(root.right);\r\n        if(root.left == null && root.right == null && root.val == 0){\r\n            return null;\r\n        }\r\n        return root;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为二叉树节点的个数。\r\n- 空间复杂度：O(N)，其中 N 为二叉树节点的个数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1534951488","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\r\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\r\n        List<Integer> combine = new ArrayList<Integer>();\r\n        dfs(candidates, target, ans, combine, 0);\r\n        return ans;\r\n    }\r\n    private void dfs(int[] candidates, int target, List<List<Integer>> ans, List<Integer> combine, int idx){\r\n        if(idx == candidates.length){\r\n            return;\r\n        }\r\n        if(target == 0){\r\n            ans.add(new ArrayList<Integer>(combine));\r\n            return;\r\n        }\r\n        // 跳过\r\n        dfs(candidates, target, ans, combine, idx+1);\r\n        // 选择当前数\r\n        if(target - candidates[idx] >= 0){\r\n            combine.add(candidates[idx]);\r\n            dfs(candidates, target - candidates[idx], ans, combine, idx);\r\n            combine.remove(combine.size() - 1);\r\n        }\r\n    }\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/89#issuecomment-1537193669","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int strStr(String ss, String pp) {\r\n        int n = ss.length(), m = pp.length();\r\n        char[] s = ss.toCharArray(), p = pp.toCharArray();\r\n        // 枚举原串的「发起点」\r\n        for (int i = 0; i <= n - m; i++) {\r\n            // 从原串的「发起点」和匹配串的「首位」开始，尝试匹配\r\n            int a = i, b = 0;\r\n            while (b < m && s[a] == p[b]) {\r\n                a++;\r\n                b++;\r\n            }\r\n            // 如果能够完全匹配，返回原串的「发起点」下标\r\n            if (b == m) return i;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O((n-m)*m)，其中 n 为原串长度，m 为匹配串长度。\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null],"kangliqi1":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429723823","body":"public List<Integer> addToArrayForm(int[] num,int k) {\n               //把k拆分成数组\n\t\tString kStr = String.valueOf(k);\n\t\tList<Integer> kArr= new ArrayList<>();\n\t\tString[] kStrs = kStr.split(\"\");\n\t\t//取较大值为遍历总次数，遍历相加，大于10则前一位多加1\n\t\tint a= num.length;\n\t\tint b = kStrs.length;\n\t\tint max = a;\n\t\tif (b>a){\n\t\t\tmax = b;\n\t\t}\n\t\tList <Integer> res = new ArrayList<>();\n\t\tint next = 0;\n\t\tfor (int j = 1;j<=max;j++) {\n\t\t\tint num1 = 0;\n\t\t\tint num2 = 0;\n\t\t\tif (a - j >=0) {\n\t\t\t\tnum1 = num[a-j];\n\t\t\t}\n\t\t\tif (b- j >= 0) {\n\t\t\t\tnum2 = Integer.valueOf(kStrs[b-j]);\n\t\t\t}\n\t\t\tint cur = num1+num2+next;\n\t\t\tif (cur>=10) {\n\t\t\t\tres.add(cur%10);\n\t\t\t\tnext = 1;\n\t\t\t} else {\n\t\t\t\tres.add(cur);\n\t\t\t\tnext = 0;\n\t\t\t}\n\t\t}\n\t\treturn Collections.reverse(res);\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431236149","body":"        public static int[] shortestToChar(String s, char c) {\n\t// 字符串长度\n        int len = s.length();\n        //创建一个和字符串长度一样长的数组存储结果值\n        int[] r = new int[len];\n \t//从左遍历\n        int pos = -10000;\n \tfor (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                pos = i;\n            }\n            r[i] = i - pos;\n        }\n \t//从右遍历\n        pos = 10000;\n        for (int i = len - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                pos = i;\n            }\n            r[i] = Math.min(r[i], pos - i);\n        }\n        return r;\n    }\n\n时间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433044884","body":"class CustomStack {  \r\n\t\r\n\tList<Integer> stack = new ArrayList();\r\n\tint maxSize = 0;\r\n\r\n   public CustomStack(int num) {\r\n      maxSize = num;\r\n    }\r\n\t\r\n\tpublic void push(int i) {\r\n\t\tif (stack.size() < maxSize) {\r\n\t\t\tstack.add(i);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic int pop() {\r\n\t\tif (stack.size == 0) {\r\n\t\t\treturn -1;\r\n\t\t} else {\r\n\t\t\tint res = stack.get(stack.size() - 1);\r\n\t\t\tstack.removeLast();\r\n\t\t\treturn res;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic void inc(int k, int val) {\r\n\t\tint i = k < stack.size() ? k : stack.size();\r\n\t\tfor (int j = 0;j < i;j++) {\r\n\t\t\tstack.get(j) += val;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n时间复杂度 stack.inc(int k, int val)   O(n)\r\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434656386","body":"public String decodeString(String str) {\n\t\tStringBuffer res = new StringBuffer();\n\t\tString [] strs = str.split(\"]\");\n\t\tfor (int i = 0;i < strs.length;i++) {\n\t\t\tString curStr = strs[i];\n\t\t\tint index = 0;\n\t\t\t// 循环判断字符串直接放入结果中\n\t\t\tfor (int j = 0;j<curStr.length();j++) {\n\t\t\t\tif (curStr.charAt(j) < 48 || curStr.charAt(j) > 57) {\n\t\t\t\t\tres.append(curStr.charAt(j));\n\t\t\t\t\tindex ++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//数字部分\n\t\t\tint time = Integer.valueOf(curStr.substring(index,curStr.indexOf(\"[\")));\n\t\t\t//重复字符串部分\n\t\t\tString realStr = curStr.substring(curStr.indexOf(\"[\")+1);\n\t\t\tint k = 0;\n\t\t\twhile (k<time) {\n\t\t\t\tres.append(realStr);\n\t\t\t}\n\t\t}\n\t\treturn res.toString();\n\t}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435688387","body":"class MyQueue {\n    Deque<Integer> s1;\n    Deque<Integer> s2;\n    public MyQueue() {\n        this.s1 = new LinkedList<Integer>();\n        this.s2 = new LinkedList<Integer>();\n    }\n    \n    public void push(int x) {\n        s1.push(x);\n    }\n    \n    public int pop() {\n        if(s2.isEmpty() && s1.isEmpty()){\n            return -1;\n        } else if(s2.isEmpty()){\n            while(!s1.isEmpty()){\n                s2.push(s1.pop());\n            }\n        } \n        return s2.pop();\n    }\n    \n    public int peek() {\n        if(s2.isEmpty() && s1.isEmpty()){\n            return -1;\n        } else if(s2.isEmpty()){\n            while(!s1.isEmpty()){\n                s2.push(s1.pop());\n            }\n        } \n        return s2.peek();\n    }\n    \n    public boolean empty() {\n        return s2.isEmpty() && s1.isEmpty();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436003937","body":"public int maxChunksToSorted(int[] arr) {\nLinkedList<Integer> stack = new LinkedList<Integer>();\n for(int num : arr) {\nif(!stack.isEmpty() && num < stack.getLast()) {\nint head = stack.removeLast();\nwhile(!stack.isEmpty() && num < stack.getLast()) {\nstack.removeLast();\n } \n stack.addLast(head);\n}\nelse stack.addLast(num);\n }\n return stack.size();\n }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436877643","body":"public ListNode rotateRight(ListNode head, int k) {\r\nif (k == 0 || head == null || head.next == null) {\r\nreturn head;\r\n}\r\nint n = 1;\r\nListNode iter = head;\r\nwhile (iter.next != null) {\r\niter = iter.next;\r\nn++;\r\n}\r\nint add = n - k % n;\r\nif (add == n) {\r\nreturn head;\r\n}\r\niter.next = head;\r\nwhile (add-- > 0) {\r\niter = iter.next;\r\n}\r\nListNode ret = iter.next;\r\niter.next = null;\r\nreturn ret;\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438529945","body":"public ListNode swapPairs(ListNode head) {\nListNode temp = new ListNode(0,head);\nListNode ans = temp;\nwhile(head!=null&&head.next!=null){\ntemp.next = temp.next.next;\nhead.next = head.next.next;\ntemp.next.next = head;\nhead = head.next;\ntemp = temp.next.next;\n}\nreturn ans.next;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439950124","body":"class Solution {\n  public TreeNode sortedListToBST(ListNode head) {\n      if(head == null) return null;\n      return dfs(head,null);\n  }\n  private TreeNode dfs(ListNode head, ListNode tail){\n      if(head == tail) return null;\n      ListNode fast = head, slow = head;\n      while(fast != tail && fast.next != tail){\n          fast = fast.next.next;\n          slow = slow.next;\n      }\n      TreeNode root = new TreeNode(slow.val);\n      root.left = dfs(head, slow);\n      root.right = dfs(slow.next, tail);\n      return root;\n  }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441698374","body":"public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while (p1 != p2) {\n            p1 = p1 == null ? headB : p1.next;\n            p2 = p2 == null ? headA : p2.next;\n        }\n        return p1;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443697355","body":"public ListNode detectCycle(ListNode head) {\n    if(head == null) return null;\n    ListNode slow = head, fast = head;\n    while(true){\n        if(fast == null || fast.next == null){\n            return null;\n        }\n        fast = fast.next.next;\n        slow = slow.next;\n\n        if(fast == slow)break;\n    }   \n\n    fast = head;\n    while(fast != slow){\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return slow;\n} ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445123841","body":"class LRUCache {\n\n    private HashMap<Integer, Integer> map;\n    private ArrayList<Integer> list;\n    private int max;\n\n    public LRUCache(int capacity) {\n        max = capacity;\n        map = new HashMap<>();\n        list = new ArrayList<>();\n    }\n    \n    public int get(int key) {\n        if (map.containsKey(key)) {\n            for (int i = 0; i < list.size(); i++) {\n                if (list.get(i) == key) {\n                    list.remove(i);\n                    list.add(key);\n                    break;\n                }\n            }\n            return map.get(key);\n        }\n        else return -1;\n    }\n    \n    public void put(int key, int value) {\n        if (this.get(key) == -1) {\n            if (list.size() == max) {\n                int rm = list.get(0);\n                list.remove(0);\n                map.remove(rm);\n            }\n            list.add(key);\n        }\n        \n        map.put(key, value);\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445365109","body":"class Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftMax = maxDepth(root.left);\n        int rightMax = maxDepth(root.right);\n        return 1 + Math.max(leftMax, rightMax);\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446331704","body":"class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null || q == null) {\n             return p == q;\n        }\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448200756","body":"class Solution {\n    public int sumNumbers(TreeNode root) {\n        if (root.left == null && root.right == null) {\n            return root.val;\n        }\n        int ret = 0;\n        if (root.left != null) {\n            root.left.val += root.val * 10;\n            ret += sumNumbers(root.left);\n        }\n        if (root.right != null) {\n            root.right.val += root.val * 10;\n            ret += sumNumbers(root.right);\n        }\n        return ret;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450112247","body":"class Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int val = root.val;\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (node.right != null) {\n                queue.offer(node.right);\n            }\n            if (node.left != null) {\n                queue.offer(node.left);\n            }\n            val = node.val;\n        }\n        return val;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451793478","body":"public class Codec {\n\nprivate static final String spliter = \",\";\nprivate static final String NN = \"X\";\n\npublic String serialize(TreeNode root) {\n    StringBuilder sb = new StringBuilder();\n    buildString(root, sb);\n    return sb.toString();\n}\nprivate void buildString(TreeNode node, StringBuilder sb) {\n    if (node == null) {\n        sb.append(NN).append(spliter);\n    } else {\n        sb.append(node.val).append(spliter);\n        buildString(node.left, sb);\n        buildString(node.right,sb);\n    }\n}.\npublic TreeNode deserialize(String data) {\n    Deque<String> nodes = new LinkedList<>();\n    nodes.addAll(Arrays.asList(data.split(spliter)));\n    return buildTree(nodes);\n}\n\nprivate TreeNode buildTree(Deque<String> nodes) {\n    String val = nodes.remove();\n    if (val.equals(NN)) return null;\n    else {\n        TreeNode node = new TreeNode(Integer.valueOf(val));\n        node.left = buildTree(nodes);\n        node.right = buildTree(nodes);\n        return node;\n    }\n}\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1454757310","body":"class Solution {\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        Map<Integer, List<Integer>> map = new HashMap<> ();\r\n        Deque<Integer> colQueue = new ArrayDeque<> ();\r\n        Deque<TreeNode> queue = new ArrayDeque<> ();\r\n        queue.offer(root);\r\n        colQueue.offer(0);\r\n        while (!queue.isEmpty()) {\r\n            int size = queue.size();\r\n            Map<Integer, List<Integer>> tmpMap = new HashMap<> ();\r\n            while (size-- > 0) {\r\n                TreeNode node = queue.poll();\r\n                int index = colQueue.poll();\r\n                tmpMap.putIfAbsent(index, new ArrayList<> ());\r\n                tmpMap.get(index).add(node.val);\r\n                if (node.left != null) {\r\n                    queue.offer(node.left);\r\n                    colQueue.offer(index - 1);\r\n                }\r\n                if (node.right != null) {\r\n                    queue.offer(node.right);\r\n                    colQueue.offer(index + 1);\r\n                }\r\n            }\r\n\r\n            for (int key : tmpMap.keySet()) {\r\n                tmpMap.get(key).sort((a, b) -> a - b);\r\n                map.putIfAbsent(key, new ArrayList<> ());\r\n                map.get(key).addAll(tmpMap.get(key));\r\n            }\r\n        }\r\n\r\n        List<Integer> keys = new ArrayList<> (map.keySet());\r\n        keys.sort((a,b) -> a - b);\r\n        List<List<Integer>> ans = new ArrayList<> ();\r\n        for (int key : keys) {\r\n            ans.add(map.get(key));\r\n        }\r\n        return ans;\r\n    }\r\n}","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454755725","body":"public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(target - nums[i]))\n                return new int[] {map.get(target - nums[i]), i};\n            map.put(nums[i], i);\n        }\n        return new int[0];\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455007745","body":"class Solution3 {\n    public int[] topKFrequent(int[] nums, int k) {\n        int N = nums.length;\n        // Map valToFreq\n        Map<Integer, Integer> valToFreq = new HashMap<>();\n        for (int v : nums) {\n            valToFreq.put(v, valToFreq.getOrDefault(v, 0) + 1);\n        }\n        // List freqToVals\n        List<Integer>[] freqToVals = new ArrayList[N + 1];\n        for (Map.Entry<Integer, Integer> entry : valToFreq.entrySet()) {\n            int val = entry.getKey(), freq = entry.getValue();\n            if (freqToVals[freq] == null)\n                freqToVals[freq] = new ArrayList<>();\n            freqToVals[freq].add(val);\n        }\n        int[] res = new int[k];\n        int p = 0;\n        for (int i = N; i > 0; i--) {\n            List<Integer> cur = freqToVals[i];\n            if (cur == null) continue;\n            for (int j = 0; j < cur.size(); j++) {\n                res[p++] = cur.get(j);\n                if (p == k) return res;\n            }\n        }\n        return null;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456058172","body":"class Solution {\n    public int numberOfBoomerangs(int[][] points) {\n            int ans = 0;\n            Map<Integer, Integer> cnt = new HashMap<>();\n            for (int[] p : points) {\n                cnt.clear();\n                for (int[] q : points) {\n                    int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n                    int m = cnt.getOrDefault(dis, 0);\n                    ans += m*2;\n                    cnt.put(dis, m+1);\n                }\n            }\n            return ans;\n        }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1458204738","body":"class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int[] m = new int[128];\n        int ans = 0;\n        for (int low = 0, fast = 0; fast < s.length();) {\n            low = Math.max(m[s.charAt(fast)], low);\n            ans = Math.max(ans, fast - low + 1);\n            m[s.charAt(fast++)] = fast;\n        }\n        return ans;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460160514","body":"public List<Integer> findSubstring(String s, String[] words) {\n        int sLen = s.length();\n        int n = words.length;\n        int wLen = words[0].length();\n        \n        if (sLen < n * wLen) return List.of();\n        \n        Map<String, Integer> counts = new HashMap<>();\n        for (String word : words)\n            counts.merge(word, 1, Integer::sum);\n\n        List<Integer> ans = new ArrayList<>();\n\n        Map<String, Integer> seen = new HashMap<>();\n        for (int i = 0; i <= sLen - n * wLen; i++) {\n            String sub = s.substring(i, i + n * wLen);\n\n            int j;\n            for (j = 0; j < sub.length(); j += wLen) {\n                String sWord = sub.substring(j, j + wLen);\n                if (!counts.containsKey(sWord)) break;\n\n                int cnt = seen.merge(sWord, 1, Integer::sum);\n\n                if (cnt > counts.get(sWord)) break;\n            }\n\n            seen.clear();\n            if (j == sub.length()) ans.add(i);\n        }\n\n        return ans;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462028870","body":"class Solution {\r\n    public int minSubarray(int[] nums, int p) {\r\n            int sum = 0, ans = nums.length, mode = 0;\r\n            for (int num : nums) {\r\n                mode = (num + mode) % p;\r\n            }\r\n            if (mode == 0) {\r\n                return 0;\r\n            }\r\n            Map<Integer, Integer> map = new HashMap<>();\r\n            for (int i = 0; i < nums.length; i++) {\r\n                map.put(sum, i);\r\n                sum = (nums[i] + sum) % p;\r\n                int k = (sum + p - mode) % p;\r\n                if (map.containsKey(k)) {\r\n                    ans = Math.min(ans, i - map.get(k)+1);\r\n                }\r\n            }\r\n            return ans == nums.length ? -1 : ans;\r\n        }\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463747104","body":"public ListNode middleNode(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464911179","body":"public int removeDuplicates(int[] nums) {\n        int slow = 0;\n        int fast = 1;\n        while (fast < nums.length) {\n            if (nums[slow] != nums[fast]) {\n                slow++;\n                nums[slow] = nums[fast];\n            }\n            fast++;\n        }\n\n        return slow + 1;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465190476","body":"public int searchInsert(int[] nums, int target) {\n        int l = 0, r = nums.length - 1;\n        while(l <= r) {\n            int mid = l + (r - l) / 2;\n            if(nums[mid] == target ) {\n                return mid;\n            } else if(nums[mid] < target) {\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return l;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466116255","body":"public int[] maxSlidingWindow(int[] nums, int k) {\n    int[] res = new int[nums.length-k+1];\n    Deque<Integer> deque = new ArrayDeque<>();\n\n    for(int i=0; i < nums.length; i++){\n        if(!deque.isEmpty() && deque.peekFirst() + k<= i){\n            deque.pollFirst();\n        }\n        while(!deque.isEmpty() && deque.peekLast() <= nums[i]){\n            deque.pollLast();\n        }\n        deque.offerLast(i);\n        if(i-k+1 >= 0){\n            res[i-k+1] = nums[deque.peekFirst()];\n        }\n    }\n    return res;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468024045","body":"public int findJudge(int n, int[][] trust) {\n        int[] in = new int[n];\n        int[] out = new int[n];\n        for (int[] node : trust) {\n            out[node[0]-1]++;\n            in[node[1]-1]++;\n        }\n        for (int i = 0; i < n; i++) {\n            if (out[i] == 0 && in[i] == (n-1)){\n                return i+1;\n            }\n        }\n        return -1;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469918064","body":"class Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        int[] color = new int[n + 1];\n        List<Integer>[] g= new List[n + 1];\n        for (int i = 0; i <= n; i++) {\n            g[i] = new ArrayList<Integer>();\n        }\n        for (int[] p : dislikes) {\n            g[p[0]].add(p[1]);\n            g[p[1]].add(p[0]);\n        }\n        for (int i = 1; i <= n; i++) {\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean dfs(int curnode, int nowcolor, int[] color, List<Integer>[] g) {\n        color[curnode] = nowcolor;\n        for (int nextnode : g[curnode]) {\n            if (color[nextnode] != 0 && color[nextnode] == color[curnode]) {\n                return false;\n            }\n            if (color[nextnode] == 0 && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1472023821","body":"public int[] SortItems(int n, int m, int[] group, IList<IList<int>> beforeItems)\n        {\n            for (int i = 0; i < n; i++)\n            {\n                if (group[i] < 0)\n                {\n                    group[i] = m;\n                    m++;\n                }\n            }\n            IList<int>[] groupItems = new IList<int>[m];\n            for (int i = 0; i < m; i++)\n            {\n                groupItems[i] = new List<int>();\n            }\n            int[] groupIndegrees = new int[m];\n            int[] itemIndegrees = new int[n];\n            IList<int>[] groupNextArr = new IList<int>[m];\n            for (int i = 0; i < m; i++)\n            {\n                groupNextArr[i] = new List<int>();\n            }\n            IList<int>[] itemNextArr = new IList<int>[n];\n            for (int i = 0; i < n; i++)\n            {\n                itemNextArr[i] = new List<int>();\n            }\n            for (int i = 0; i < n; i++)\n            {\n                int currGroup = group[i];\n                groupItems[currGroup].Add(i);\n                IList<int> before = beforeItems[i];\n                foreach (int j in before)\n                {\n                    int prevGroup = group[j];\n                    if (prevGroup == currGroup)\n                    {\n                        itemIndegrees[i]++;\n                        itemNextArr[j].Add(i);\n                    }\n                    else\n                    {\n                        groupIndegrees[currGroup]++;\n                        groupNextArr[prevGroup].Add(currGroup);\n                    }\n                }\n            }\n            IList<int> groupList = new List<int>();\n            for (int i = 0; i < m; i++)\n            {\n                groupList.Add(i);\n            }\n            int[] groupsOrder = TopologicalSort(groupIndegrees, groupNextArr, groupList);\n            if (groupsOrder.Length != groupList.Count)\n            {\n                return new int[0];\n            }\n            int[] itemsOrder = new int[n];\n            int itemIndex = 0;\n            for (int i = 0; i < m; i++)\n            {\n                IList<int> items = groupItems[groupsOrder[i]];\n                int[] groupItemsOrder = TopologicalSort(itemIndegrees, itemNextArr, items);\n                int currCount = groupItemsOrder.Length;\n                if (currCount != items.Count)\n                {\n                    return new int[0];\n                }\n                Array.Copy(groupItemsOrder, 0, itemsOrder, itemIndex, currCount);\n                itemIndex += currCount;\n            }\n            return itemsOrder;\n        }\n\n        public int[] TopologicalSort(int[] indegrees, IList<int>[] nextArr, IList<int> nums)\n        {\n            int count = nums.Count;\n            int[] order = new int[count];\n            int index = 0;\n            Queue<int> queue = new Queue<int>();\n            foreach (int num in nums)\n            {\n                if (indegrees[num] == 0)\n                {\n                    queue.Enqueue(num);\n                }\n            }\n            while (queue.Count > 0)\n            {\n                int curr = queue.Dequeue();\n                order[index] = curr;\n                index++;\n                IList<int> nextList = nextArr[curr];\n                foreach (int next in nextList)\n                {\n                    indegrees[next]--;\n                    if (indegrees[next] == 0)\n                    {\n                        queue.Enqueue(next);\n                    }\n                }\n            }\n            return index == count ? order : new int[0];\n        }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473875811","body":"public boolean judgeCircle(String moves) {\n    int x = 0, y = 0;\n    for(char move: moves.toCharArray()) {\n        if(move == 'R') {\n            x++;\n        } else if(move == 'L') {\n            x--;\n        } else if(move == 'U') {\n            y++;\n        } else if(move == 'D') {\n            y--;\n        }\n    }\n    return x == 0 && y == 0;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474851271","body":"public int[] getOrder(int[][] tasks) {\n    int n = tasks.length;\n    int[] ans = new int[n];\n    int[][] extTasks = new int[n][3];\n    for(int i = 0; i < n; i++) {\n        extTasks[i][0] = i;\n        extTasks[i][1] = tasks[i][0];\n        extTasks[i][2] = tasks[i][1];\n    }\n    Arrays.sort(extTasks, (a,b)->a[1] - b[1]);\n    PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[2] == b[2] ? a[0] - b[0] : a[2] - b[2]);\n    int time = 0;\n    int ai = 0;\n    int ti = 0;\n    while(ai < n) {\n        while(ti < n && extTasks[ti][1] <= time) {\n            pq.offer(extTasks[ti++]);\n\n        }\n        if(pq.isEmpty()) {\n            time = extTasks[ti][1];\n            continue;\n        }\n        int[] bestFit = pq.poll();\n        ans[ai++] = bestFit[0];\n        time += bestFit[2];\n    }\n    return ans;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475272711","body":"public int numberOfRounds(String loginTime, String logoutTime) {\n        String[] loginArr = loginTime.split(\":\");\n        String[] logoutArr = logoutTime.split(\":\");\n        int loginHour = Integer.valueOf(loginArr[0]), loginMinute = Integer.valueOf(loginArr[1]);\n        int logoutHour = Integer.valueOf(logoutArr[0]), logoutMinute = Integer.valueOf(logoutArr[1]);\n        boolean moreThanOneDay = (loginHour > logoutHour) || (loginHour == logoutHour && loginMinute > logoutMinute);\n\n        int t1 = loginHour * 60 + loginMinute, t2 = logoutHour * 60 + logoutMinute;\n        if (t1 > t2) {\n            t2 += 1440;\n        }\n        t2 = t2 / 15 * 15;\n        return Math.max(0, (t2 - t1) / 15);\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476259568","body":"public int minCharacters(String a, String b) {\n        int[] countA = new int[26];\n        int[] countB = new int[26];\n        for(int i = 0; i < a.length(); i++) {\n            countA[a.charAt(i) - 'a'] += 1;\n        }\n        for(int i = 0; i < b.length(); i++) {\n            countB[b.charAt(i) - 'a'] += 1;\n        }\n        int ans = Math.max(a.length(), b.length());\n        for(int i = 0; i < 26; i++) {\n            ans = Math.min(a.length() - countA[i] + b.length() - countB[i], ans);\n            int n = 0, m = 0;\n            if (i == 0) {\n                continue;\n            }\n            for (int j = i; j < 26; j++) {\n                n += countA[j];\n                m += countB[j];\n            }\n            for (int j = 0; j < i; j++) {\n                n += countB[j];\n                m += countA[j];\n            }\n            ans = Math.min(Math.min(m, n), ans);\n        }\n        return ans;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477827397","body":"class Solution {\n    public int[] sortArray(int[] nums) {\n        sort(nums, 0, nums.length - 1);\n        return nums;\n    }\n\n    public void sort(int[] arr, int l, int r) {\n        if(l >= r) {\n            return;\n        }\n        int a = arr[r];\n        int i = l-1, j = r, k = l;\n        while(k < j) {\n            if(arr[k] < a) {\n                swap(arr, i+1, k);\n                i++;\n                k++;\n            }else if(arr[k] == a) {\n                k++;\n            }else if(arr[k] > a) {\n                swap(arr, k, j-1);\n                j--;\n            }\n        }\n        swap(arr, j, r);\n        sort(arr, l, i);\n        sort(arr, j, r);\n    }\n\n    public void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479556264","body":"public int mySqrt(int x) {\n        if(x==1)\n            return 1;\n        int left=0;\n        int right=46340;\n        while(left<=right){\n            int mid=left+(right-left)/2;\n            if(mid*mid>x){\n                right=mid-1;\n            }else if(mid*mid<x){\n                left=mid+1;\n            }else{\n                return mid;\n            }\n        }\n        return right;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1481141392","body":"public class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left = 1, right = n;\n        while (left < right) { \n            int mid = left + (right - left) / 2;\n            if (isBadVersion(mid)) {\n                right = mid; \n            } else {\n                left = mid + 1; \n            }\n        }\n        return left;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482896040","body":"class Solution {\n    public int reversePairs(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        return reversePairsRecursive(nums, 0, nums.length - 1);\n    }\n\n    public int reversePairsRecursive(int[] nums, int left, int right) {\n        if (left == right) {\n            return 0;\n        } else {\n            int mid = (left + right) / 2;\n            int n1 = reversePairsRecursive(nums, left, mid);\n            int n2 = reversePairsRecursive(nums, mid + 1, right);\n            int ret = n1 + n2;\n\n            // 首先统计下标对的数量\n            int i = left;\n            int j = mid + 1;\n            while (i <= mid) {\n                while (j <= right && (long) nums[i] > 2 * (long) nums[j]) {\n                    j++;\n                }\n                ret += j - mid - 1;\n                i++;\n            }\n\n            // 随后合并两个排序数组\n            int[] sorted = new int[right - left + 1];\n            int p1 = left, p2 = mid + 1;\n            int p = 0;\n            while (p1 <= mid || p2 <= right) {\n                if (p1 > mid) {\n                    sorted[p++] = nums[p2++];\n                } else if (p2 > right) {\n                    sorted[p++] = nums[p1++];\n                } else {\n                    if (nums[p1] < nums[p2]) {\n                        sorted[p++] = nums[p1++];\n                    } else {\n                        sorted[p++] = nums[p2++];\n                    }\n                }\n            }\n            for (int k = 0; k < sorted.length; k++) {\n                nums[left + k] = sorted[k];\n            }\n            return ret;\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483821037","body":"class Solution {\n    public int findRadius(int[] houses, int[] heaters) {\n        int ans = 0;\n        Arrays.sort(heaters);\n        for(int house:houses){\n            int i = binarySearch(heaters, house);\n            int j = i +1;\n            int leftDistance = i < 0? Integer.MAX_VALUE : house - heaters[i];\n            int rightDistance = j >= heaters.length ? Integer.MAX_VALUE : heaters[j] - house;\n            ans = Math.max(ans, leftDistance < rightDistance ? leftDistance : rightDistance);\n        }\n        return ans;\n    }\n\n    public int binarySearch(int[] nums, int target){\n        int left = 0, right = nums.length - 1;\n        if(nums[left] > target){\n            return -1;\n        }\n        while(left < right){\n            int mid = left + (right - left + 1) / 2;\n            if (nums[mid] > target){\n                right = mid - 1;\n            } else {\n                left = mid;\n            }\n        }\n        return left;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1484027861","body":"class Solution {\n    int[] nums;\n\n    public int smallestDistancePair(int[] _nums, int k) {\n        nums = _nums;\n        Arrays.sort(nums);\n        int left = 0, right = nums[nums.length - 1] - nums[0];\n        while (left <= right) {\n            int mid = (left + right) >>> 1;\n            System.out.println(mid);\n            if (countNotGreater(mid) < k)\n                left = mid + 1;\n            else\n                right = mid - 1;\n\n        }\n        return left;\n\n    }\n\n    private int countNotGreater(int diff) {\n        int count = 0, i = 0;\n        for (int j = 1; j < nums.length; j++) {\n            while (nums[j] - nums[i] > diff) {\n                i++;\n            }\n            count += j - i;\n        }\n        System.out.println(\"count:\" + count);\n        return count;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1485058004","body":"public class Solution {\n\n    private int N;\n\n    public static final int[][] DIRECTIONS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    public int swimInWater(int[][] grid) {\n        this.N = grid.length;\n\n        int len = N * N;\n        // 下标：方格的高度，值：对应在方格中的坐标\n        int[] index = new int[len];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                index[grid[i][j]] = getIndex(i, j);\n            }\n        }\n\n        UnionFind unionFind = new UnionFind(len);\n        for (int i = 0; i < len; i++) {\n            int x = index[i] / N;\n            int y = index[i] % N;\n\n            for (int[] direction : DIRECTIONS) {\n                int newX = x + direction[0];\n                int newY = y + direction[1];\n                if (inArea(newX, newY) && grid[newX][newY] <= i) {\n                    unionFind.union(index[i], getIndex(newX, newY));\n                }\n\n                if (unionFind.isConnected(0, len - 1)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    private int getIndex(int x, int y) {\n        return x * N + y;\n    }\n\n    private boolean inArea(int x, int y) {\n        return x >= 0 && x < N && y >= 0 && y < N;\n    }\n\n    private class UnionFind {\n\n        private int[] parent;\n\n        public UnionFind(int n) {\n            this.parent = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n\n        public int root(int x) {\n            while (x != parent[x]) {\n                parent[x] = parent[parent[x]];\n                x = parent[x];\n            }\n            return x;\n        }\n\n        public boolean isConnected(int x, int y) {\n            return root(x) == root(y);\n        }\n\n        public void union(int p, int q) {\n            if (isConnected(p, q)) {\n                return;\n            }\n            parent[root(p)] = root(q);\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486919333","body":"class Solution {\n    public int maxVowels(String s, int k) {\n        int n = s.length();\n        int vowel_count = 0;\n        for (int i = 0; i < k; ++i) {\n            vowel_count += isVowel(s.charAt(i));\n        }\n        int ans = vowel_count;\n        for (int i = k; i < n; ++i) {\n            vowel_count += isVowel(s.charAt(i)) - isVowel(s.charAt(i - k));\n            ans = Math.max(ans, vowel_count);\n        }\n        return ans;\n    }\n\n    public int isVowel(char ch) {\n        return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ? 1 : 0;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488640835","body":"public double new21Game(int n, int k, int maxPts) {\n    if(k==0) return 1.00;\n    if(k==1 && maxPts<=n) return 1.00;\n    double dp[] = new double[n+1];\n    dp[0] = 1.00;\n    double prev=0.00;\n    for(int i=1; i<=n; i++){\n        if((i-maxPts-1)>=0){\n            prev-=dp[i-1-maxPts];\n        }\n        if((i-1)<k){\n            prev+=dp[i-1];\n        }\n        dp[i]=prev/maxPts;            \n    }\n\n    double res = 0.00;\n    for(int i=k; i<=n; i++){\n        res+=dp[i];\n    }\n    return res;        \n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1490300302","body":"public List<Integer> findAnagrams(String s, String p) {\n    int sl = s.length(), pl = p.length();\n    if(sl < pl){\n        return new ArrayList();\n    }\n    \n    int[] pCount = new int[26];\n    int[] sCount = new int[26];\n    \n    for(char c : p.toCharArray()){\n        pCount[(int) (c - 'a')] ++;\n    }\n    \n    List<Integer> result = new ArrayList();\n    \n    for(int i = 0; i < sl; i++){\n        sCount[(int) (s.charAt(i) - 'a')]++;\n        if(i >= pl){\n            sCount[(int)(s.charAt(i - pl) - 'a')] -- ; \n        }\n        \n        if(Arrays.equals(pCount, sCount)){\n            result.add(i - pl + 1);\n        }\n    }\n    return result;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491991430","body":"class Solution {\n    public String minWindow(String s, String t) {\n        if (s.length() < t.length()) {\n            return \"\";\n        }\n        boolean[] exists = new boolean[128];\n        int[] arr = new int[128];\n        for (char c : t.toCharArray()) {\n            exists[c] = true;\n            arr[c]++;\n        }\n\n        int cnt = 0, left = 0, right = 0, minLen = s.length() + 1, minIndex = 0;\n        for (; right < s.length(); right++) {\n            if (exists[s.charAt(right)]) {\n                arr[s.charAt(right)]--;\n                if (arr[s.charAt(right)] >= 0) {\n                    cnt++;\n                }\n\n                while (cnt == t.length()) {\n                    if (minLen > right - left + 1) {\n                        minLen = right - left + 1;\n                        minIndex = left;\n                    }\n                    if (exists[s.charAt(left)]) {\n                        arr[s.charAt(left)]++;\n                        if (arr[s.charAt(left)] > 0) {\n                            cnt--;\n                        }\n                    }\n                    left++;\n                }\n            }\n        }\n        return minLen > s.length() ? \"\" : s.substring(minIndex, minIndex + minLen);\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1492941347","body":"public int maxScore(int[] cardPoints, int k) {\n\n    int blockSize = cardPoints.length - k;\n    int sum = 0;\n    for(int i = 0; i< blockSize; i++){\n        sum += cardPoints[i];\n    }\n\n    int minSum = sum;\n    for(int i = blockSize; i < n; i++){\n        sum += cardPoints[i] - cardPoints[i - blockSize];\n        minSum = minSum < sum ? minSum : sum; \n    }\n\n    return Arrays.stream(cardPoints).sum() - minSum;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493249799","body":"class Solution:\n    def readBinaryWatch(self, num: int) -> List[str]:\n        return [str(a) + \":\" + str(b).rjust(2, '0') for a in range(12) for b in range(60) if (bin(a)+bin(b)).count('1') == num]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494221541","body":"class Solution {\npublic int totalNQueens(int n) {\nSet columns = new HashSet();\nSet diagonals1 = new HashSet();\nSet diagonals2 = new HashSet();\nreturn backtrack(n, 0, columns, diagonals1, diagonals2);\n}\npublic int backtrack(int n, int row, Set<Integer> columns, Set<Integer> diagonals1, Set<Integer> diagonals2) {\n    if (row == n) {\n        return 1;\n    } else {\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (columns.contains(i)) {\n                continue;\n            }\n            int diagonal1 = row - i;\n            if (diagonals1.contains(diagonal1)) {\n                continue;\n            }\n            int diagonal2 = row + i;\n            if (diagonals2.contains(diagonal2)) {\n                continue;\n            }\n            columns.add(i);\n            diagonals1.add(diagonal1);\n            diagonals2.add(diagonal2);\n            count += backtrack(n, row + 1, columns, diagonals1, diagonals2);\n            columns.remove(i);\n            diagonals1.remove(diagonal1);\n            diagonals2.remove(diagonal2);\n        }\n        return count;\n    }\n}\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1496049484","body":"class Solution {\npublic int maxAreaOfIsland(int[][] grid) {\n    boolean[][] seen = new boolean[grid.length][grid[0].length];\n    int[] dr = new int[]{1, -1, 0, 0};\n    int[] dc = new int[]{0, 0, 1, -1};\n\n    int ans = 0;\n    for (int r0 = 0; r0 < grid.length; r0++) {\n        for (int c0 = 0; c0 < grid[0].length; c0++) {\n            if (grid[r0][c0] == 1 && !seen[r0][c0]) {\n                int shape = 0;\n                Stack<int[]> stack = new Stack();\n                stack.push(new int[]{r0, c0});\n                seen[r0][c0] = true;\n                while (!stack.empty()) {\n                    int[] node = stack.pop();\n                    int r = node[0], c = node[1];\n                    shape++;\n                    for (int k = 0; k < 4; k++) {\n                        int nr = r + dr[k];\n                        int nc = c + dc[k];\n                        if (0 <= nr && nr < grid.length &&\n                                0 <= nc && nc < grid[0].length &&\n                                grid[nr][nc] == 1 && !seen[nr][nc]) {\n                            stack.push(new int[]{nr, nc});\n                            seen[nr][nc] = true;\n                        }\n                    }\n                }\n                ans = Math.max(ans, shape);\n            }\n        }\n    }\n    return ans;\n}\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497457230","body":"class Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        steps = -1\n        queue = collections.deque([(i, j) for i in range(n) for j in range(n) if grid[i][j] == 1])\n        if len(queue) == 0 or len(queue) == n ** 2: return steps\n        while len(queue) > 0:\n            for _ in range(len(queue)):\n                x, y = queue.popleft(0)\n                for xi, yj in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n                    if xi >= 0 and xi < n and yj >= 0 and yj < n and grid[xi][yj] == 0:\n                        queue.append((xi, yj))\n                        grid[xi][yj] = -1\n            steps += 1\n\n        return steps","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1499017809","body":"public int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {\n        int res = 0;\n        Queue<Integer> q = new LinkedList<>();\n        for (int i : initialBoxes)\n            if ((status[i] += 5000) > 5000)\n                q.add(i);\n        while (q.size() > 0) {\n            int b = q.remove();\n            res += candies[b];\n            for (int i : keys[b])\n                if ((status[i] += 5) == 5005)\n                    q.add(i);\n            for (int i : containedBoxes[b])\n                if ((status[i] += 5000) > 5000)\n                    q.add(i);\n        }\n        return res;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1500202340","body":"class Solution:\n    def solve(self, root):\n        q = collections.deque([(root, 0)])\n        d = {}\n        while q:\n            cur, pos = q.popleft()\n            if pos not in d:\n                d[pos] = cur.val\n            if cur.left:\n                q.append((cur.left, pos - 1))\n            if cur.right:\n                q.append((cur.right, pos + 1))\n        return list(map(lambda x:x[1], sorted(d.items(),key=lambda x: x[0])))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500904869","body":"class Solution {\n    public int minCostClimbingStairs(int[] cost) {\n\n        if (cost == null || cost.length == 0)\n            return 0;\n\n        int[] dp = new int[cost.length + 1];\n        dp[0] = cost[0];\n        dp[1] = cost[1];\n\n        for(int i = 2; i <= cost.length; i++)\n            dp[i] = Math.min(dp[i - 1], dp[i - 2]) + (i == cost.length ? 0 : cost[i]);\n\n        return dp[cost.length];\n    }\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501111161","body":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n\n        length = len(nums)\n        if length == 1:\n            return nums[0]\n        else:\n            prev = nums[0]\n            cur = max(prev, nums[1])\n            for i in range(2, length):\n                cur, prev = max(prev + nums[i], cur), cur\n            return cur","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501783411","body":"class Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        # dp[i][0] ->  LIS\n        # dp[i][1] -> NumberOfLIS\n        dp = [[1, 1] for i in range(n)]\n        ans = [1, 1]\n        longest = 1\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[j] > nums[i]:\n                    if dp[i][0] + 1 > dp[j][0]:\n                        dp[j][0] = dp[i][0] + 1\n                        # 下面这行代码容易忘记，导致出错\n                        dp[j][1] = dp[i][1]\n                        longest = max(longest, dp[j][0])\n                    elif dp[i][0] + 1 == dp[j][0]:\n                        dp[j][1] += dp[i][1]\n        return sum(dp[i][1] for i in range(n) if dp[i][0] == longest)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1503358098","body":"class Solution:\n    def longestCommonSubsequence(self, A: str, B: str) -> int:\n        m, n = len(A), len(B)\n        ans = 0\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if A[i - 1] == B[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    ans = max(ans, dp[i][j])\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1505067656","body":"class Solution:\n\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [1] * n\n        for _ in range(1, m):\n            for j in range(1, n):\n                dp[j] += dp[j - 1]\n        return dp[n - 1]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1507100727","body":"class Solution {\n\n    private int[][] dir = {{-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}};\n\n    public double knightProbability(int N, int K, int r, int c) {\n\n        double[][] dp = new double[N][N];\n        dp[r][c] = 1;\n\n        for (int step = 1; step <= K; step++) {\n\n            double[][] dpTemp = new double[N][N];\n\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                    for (int[] direction : dir) {\n\n                        int lastR = i - direction[0];\n                        int lastC = j - direction[1];\n                        if (lastR >= 0 && lastR < N && lastC >= 0 && lastC < N)\n                            dpTemp[i][j] += dp[lastR][lastC] * 0.125;\n                    }\n\n            dp = dpTemp;\n        }\n\n        double res = 0;\n\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                res += dp[i][j];\n\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1508489781","body":"public class Solution {\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n\n        if (maxChoosableInteger >= desiredTotal) return true;\n        if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) return false;\n\n        Boolean[] dp = new Boolean[(1 << maxChoosableInteger) - 1];\n        return dfs(maxChoosableInteger, desiredTotal, 0, dp);\n    }\n\n    private boolean dfs(int maxChoosableInteger, int desiredTotal, int state, Boolean[] dp) {\n        if (dp[state] != null)\n            return dp[state];\n        for (int i = 1; i <= maxChoosableInteger; i++){\n            int tmp = (1 << (i - 1));\n            if ((tmp & state) == 0){\n                if (desiredTotal - i <= 0 || !dfs(maxChoosableInteger, desiredTotal - i, tmp|state, dp)) {\n                    dp[state] = true;\n                    return true;\n                }\n            }\n        }\n        dp[state] = false;\n        return false;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509843870","body":"class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        target = sum(nums) // 2\n        if target + target != sum(nums):\n            return False\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        for i in range(1, len(nums) + 1):\n            for j in range(target, 0, -1):\n                if dp[j] or (j - nums[i - 1] > -1 and dp[j - nums[i - 1]]):\n                    dp[j] = True\n        return dp[-1]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510400271","body":"public int findTargetSumWays(int[] nums, int target) {\n\n    int sum = 0;\n    for (int num : nums)\n        sum += num;\n\n    if (sum < Math.abs(target))\n        return 0;\n\n    if (((sum + target) & 1) == 1)\n        return 0;\n\n    sum = (sum + target) / 2;\n    int[] dp = new int[sum + 1];\n    dp[0] = 1;\n\n    for (int i = 0; i < nums.length; i++)\n        for (int j = sum; j >= nums[i]; j--)\n            dp[j] = dp[j] + dp[j - nums[i]];\n\n    return dp[sum];\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511481346","body":"public int coinChange(int[] coins, int amount) {\n\n    if (coins == null || coins.length == 0 || amount <= 0)\n        return 0;\n\n    int[] dp = new int[amount + 1];\n\n\n    Arrays.fill(dp, amount + 1);\n    dp[0] = 0;\n\n    for (int coin : coins) {\n\n        for (int i = coin; i <= amount; i++) {\n\n            dp[i] = Math.min(dp[i], 1 + dp[i - coin]);\n        }\n    }\n\n    return dp[amount] == amount + 1 ? -1 : dp[amount];\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1513186734","body":"class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n\n        for j in range(len(coins)):\n            for i in range(1, amount + 1):\n                if i >= coins[j]:\n                    dp[i] += dp[i - coins[j]]\n\n        return dp[-1]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514787879","body":"class Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        int res = 0;\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int i = 0, j = 0;\n        while (i < g.length && j < s.length) {\n            if (g[i] <= s[j]) {\n                res++;\n                i++;\n                j++;\n            } else if (g[i] > s[j]) {\n                j++;\n            }\n        }\n        return res;\n\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516360672","body":"class Solution:\n    def lengthOfLIS(self, A: List[int]) -> int:\n        d = []\n        for s, e in A:\n            i = bisect.bisect_left(d, e)\n            if i < len(d):\n                d[i] = e\n            elif not d or d[-1] <= s:\n                d.append(e)\n        return len(d)\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        n = len(intervals)\n        if n == 0: return 0\n        ans = 1\n        intervals.sort(key=lambda a: a[0])\n        return n - self.lengthOfLIS(intervals)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517894577","body":"class Solution {\n    public boolean canJump(int[] nums) {\n        int n=nums.length;\n        int k=0;\n        for(int i=0;i<n;i++)\n        {\n            if(i>k){\n                return false;\n            }\n            // 能跳到最后一个位置\n            if(k>=n-1){\n                return true;\n            }\n            // 从当前位置能跳的最远的位置\n            k = Math.max(k, i+nums[i]);\n        }\n        return k >= n-1;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518567805","body":"class Solution:\n    visited = dict()\n\n    def numTrees(self, n: int) -> int:\n        if n in self.visited:\n            return self.visited.get(n)\n        if n <= 1:\n            return 1\n        res = 0\n        for i in range(1, n + 1):\n            res += self.numTrees(i - 1) * self.numTrees(n - i)\n        self.visited[n] = res\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519070977","body":"class Solution {\n\npublic ListNode mergeKLists(ListNode[] lists) {\n    \n    if(lists == null){\n        return null;\n    }\n    \n    int len = lists.length;\n    int interval = 1; \n    while(interval < len){\n        for(int i = 0; i + interval < len; i = i + 2 * interval){\n            lists[i] = merge(lists[i], lists[i+interval]);\n        }\n        interval = interval * 2;\n    }\n    return len != 0 ? lists[0] : null;\n}\n\npublic ListNode merge(ListNode l1, ListNode l2){\n    ListNode result = new ListNode(0);\n    ListNode tail = result;\n    \n    while(l1 != null && l2 != null){\n        if(l1.val < l2.val){\n            tail.next = l1;\n            l1 = l1.next;\n        }\n        else{\n            tail.next = l2;\n            l2 = l2.next;\n        }\n        tail = tail.next;\n    }\n    \n    if(l1 != null){\n        tail.next = l1;\n    }\n    else{\n        tail.next = l2;\n    }\n    return result.next;\n}\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1520081503","body":"class Solution {\n    Map<Integer, int[]> memo = new HashMap();\n    public int[] beautifulArray(int n) {\n        memo.put(1, new int[]{1});\n        return dp(n);\n    }\n    private int[] dp(int n) {\n        if (memo.get(n) != null) {\n            return memo.get(n);\n        }\n        int[] res = new int[n];\n        int i = 0;\n        for (int x : dp((n + 1) / 2)) {\n            res[i++] = 2 * x - 1;\n        }\n        for (int x : dp(n / 2)) {\n            res[i++] = 2 * x;\n        }\n        memo.put(n, res);\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521808388","body":"class Solution {\n    public int[] singleNumber(int[] nums) {\n\n        int xor = 0;\n        for (int i : nums)\n            xor ^= i;\n\n        int mask = 1;\n        while ((mask & xor) == 0)\n            mask <<= 1;\n\n        int[] res = new int[2];\n        for (int i : nums) {\n\n            if ((i & mask) == 0)\n                res[0] ^= i;\n            else\n                res[1] ^= i;\n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1525707084","body":"class Solution {\r\n    List<List<Integer>> res = new ArrayList<>();\r\n    List<Integer> path = new ArrayList<>();\r\n    int[] nums;\r\n\r\n    public List<List<Integer>> subsets(int[] nums) {\r\n        this.nums = nums;\r\n        backtracking(0);\r\n        return res;\r\n    }\r\n\r\n    private void backtracking(int startIndex) {\r\n        res.add(new ArrayList<>(path));\r\n        for (int i = startIndex; i < nums.length; i++) {\r\n            path.add(nums[i]);\r\n            backtracking(i + 1);\r\n            path.remove(path.size() - 1);\r\n        }\r\n    }\r\n}","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1525703634","body":"class TrieNode:\n    def __init__(self):\n        self.count = 0\n        self.preCount = 0\n        self.children = {}\n\nclass Trie:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.root = TrieNode()\n\n    def insert(self, word):\n        \"\"\"\n        Inserts a word into the trie.\n        :type word: str\n        :rtype: void\n        \"\"\"\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.preCount += 1\n        node.count += 1\n\n    def search(self, word):\n        \"\"\"\n        Returns if the word is in the trie.\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.count > 0\n\n    def startsWith(self, prefix):\n        \"\"\"\n        Returns if there is any word in the trie that starts with the given prefix.\n        :type prefix: str\n        :rtype: bool\n        \"\"\"\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.preCount > 0","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1527667252","body":"class MapSum {\n\n    TrieNode root;\n\n    public MapSum() {\n\n        root = new TrieNode();\n    }\n\n    public void insert(String key, int val) {\n\n        TrieNode temp = root;\n        for (int i = 0; i < key.length(); i++) {\n\n            if (temp.children[key.charAt(i) - 'a'] == null)\n                temp.children[key.charAt(i) - 'a'] = new TrieNode();\n\n            temp = temp.children[key.charAt(i) - 'a'];\n\n        }\n        temp.count = val;\n    }\n\n    public int sum(String prefix) {\n\n        TrieNode temp = root;\n\n        for (int i = 0; i < prefix.length(); i++) {\n\n            if (temp.children[prefix.charAt(i) - 'a'] == null)\n                return 0;\n\n            temp = temp.children[prefix.charAt(i) - 'a'];\n        }\n\n        return dfs(temp);\n    }\n\n    public int dfs(TrieNode node) {\n\n        int sum = 0;\n\n        for (TrieNode t : node.children)\n            if (t != null)\n                sum += dfs(t);\n\n        return sum + node.count;\n    }\n\n    private class TrieNode {\n\n        int count; //表示以该处节点构成的串为前缀的个数\n        TrieNode[] children;\n\n        TrieNode() {\n\n            count = 0;\n            children = new TrieNode[26];\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528808867","body":"public int[][] multiSearch(String big, String[] smalls) {\n\n    int[][] res = new int[smalls.length][];\n\n    List<Integer> cur = new ArrayList<>();\n\n    for (int i = 0; i < smalls.length; i++) {\n\n        String small = smalls[i];\n\n        if (small.length() == 0) {\n\n            res[i] = new int[]{};\n            continue;\n        }\n\n        int startIdx = 0;\n        while (true) {\n\n            int idx = big.indexOf(small, startIdx);\n            if (idx == -1)\n                break;\n\n            cur.add(idx);\n            startIdx = idx + 1;\n        }\n\n        res[i] = new int[cur.size()];\n        for (int j = 0; j < res[i].length; j++)\n            res[i][j] = cur.get(j);\n\n        cur.clear();\n    }\n\n    return res;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1529038305","body":"class Solution {\n    public int findCircleNum(int[][] isConnected) {\n        //城市数量\n        int n = isConnected.length;\n        //表示哪些城市被访问过\n        boolean[] visited = new boolean[n];\n        int count = 0;\n        //遍历所有的城市\n        for(int i = 0; i < n; i++){\n        //如果当前城市没有被访问过，说明是一个新的省份，\n        //count要加1，并且和这个城市相连的都标记为已访问过，\n        //也就是同一省份的\n            if(!visited[i]){\n                dfs(isConnected, visited, i);\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public void dfs(int[][] isConnected, boolean[] visited, int i){\n        for(int j = 0; j < isConnected.length; j++){\n            if(isConnected[i][j] == 1 && !visited[j]){\n                //如果第i和第j个城市相连，说明他们是同一个省份的，把它标记为已访问过\n                visited[j] = true;\n                //然后继续查找和第j个城市相连的城市\n                dfs(isConnected, visited, j);\n            }\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1529779734","body":"class Solution {\n    \n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int n = graph.length;\n        UF uf = new UF(n);\n        for(int i=0;i<n;i++) {\n            for(int j=i+1;j<n;j++) {\n                if(graph[i][j]==1) {\n                    uf.union(i,j);\n                }\n            }\n        }\n        int[] count = new int[n];\n        for(int node: initial) {\n            count[uf.find(node)]++;\n        }\n        int ans=-1, ansSize=-1;\n        for(int node: initial) {\n            int root = uf.find(node);\n            if(count[root]==1) {\n                int currSize = uf.getSize(root);\n                if(currSize>ansSize) {\n                    ansSize=currSize;\n                    ans=node;\n                }\n                else if(currSize == ansSize && node < ans) {\n                    ans=node;\n                }\n            }\n        }\n        if(ans==-1) {\n            ans=n+1;\n            for(int node: initial) {\n                ans = Math.min(node,ans);\n            }\n        }\n        return ans;\n        \n    }\n    class UF {\n        int[] parent;\n        int[] size;\n        \n        public UF(int n) {\n            parent = new int[n];\n            size = new int[n];\n            for(int i=0;i<n;i++) {\n                parent[i]=i;\n                size[i]=1;\n            }\n        }\n        public int find(int x) {\n            while(parent[x]!=x) {\n                parent[x]=parent[parent[x]];\n                x=parent[x];\n            }\n            return parent[x];\n        }\n        public int getSize(int x) {\n            return size[find(x)];\n        }\n        public void union(int x, int y) {\n            int xroot = find(x);\n            int yroot = find(y);\n            if(xroot!=yroot) {\n                if(size[xroot]>size[yroot]) {\n                    parent[yroot]=xroot;\n                    size[xroot]+=size[yroot];\n                }\n                else {\n                    parent[xroot]=yroot;\n                    size[yroot]+=size[xroot];\n                }\n            }\n            \n        }\n        \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1530870969","body":"class Solution {\n    public int makeConnected(int n, int[][] connections) {\n        if (n - 1 > connections.length) {\n            return -1;\n        }\n        UnionFind unionFind = new UnionFind(n);\n        for (int[] connection : connections) {\n            unionFind.union(connection[0], connection[1]);\n        }\n        return unionFind.cnt - 1;\n    }\n\n    class UnionFind {\n        public int cnt;\n        public int[] parents;\n\n        public UnionFind(int n) {\n            this.cnt = n;\n            this.parents = new int[n];\n            for (int i = 0; i < n; i++) {\n                parents[i] = i;\n            }\n        }\n\n        public void union(int x, int y) {\n            int x_root = find(x);\n            int y_root = find(y);\n            if (x_root != y_root) {\n                cnt--;\n            }\n            parents[x_root] = y_root;\n        }\n\n        public int find(int x) {\n            if (x == parents[x]) {\n                return x;\n            }\n            parents[x] = find(parents[x]);\n            return parents[x];\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1533030685","body":"public TreeNode pruneTree(TreeNode root) {\n\n    if (root == null)\n        return null;\n\n    root.left = pruneTree(root.left);\n    root.right = pruneTree(root.right);\n\n    return root.val == 0 && root.left == null && root.right == null ? null : root;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1534904301","body":"public List<List<Integer>> combinationSum(int[] candidates, int target) {\n\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> list = new LinkedList<>();\n    backtrack(res, list, candidates, target, 0);\n    return res;\n}\n\npublic void backtrack(List<List<Integer>> res, List<Integer> list, int[] candidates, int cur, int pos) {\n\n    if (cur < 0)\n        return;\n\n    if (cur == 0) {\n\n        res.add(new LinkedList<>(list));\n        return;\n    }\n\n    for (int i = pos; i < candidates.length; i++) {\n\n        list.add(candidates[i]);\n        backtrack(res, list, candidates, cur - candidates[i], i);\n        list.remove(list.size() - 1);\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1536221027","body":"public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n\n    Arrays.sort(candidates);\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> list = new LinkedList<>();\n    helper(res, list, target, candidates, 0);\n    return res;\n}\n\npublic void helper(List<List<Integer>> res, List<Integer> list, int target, int[] candidates, int start) {\n\n    if (target == 0) {\n        res.add(new LinkedList<>(list));\n        return;\n    }\n\n    for (int i = start; i < candidates.length; i++) {\n\n        if (target - candidates[i] >= 0) {\n\n            if (i > start && candidates[i] == candidates[i - 1])\n                continue;\n\n            list.add(candidates[i]);\n            helper(res, list, target - candidates[i], candidates, i + 1);\n            list.remove(list.size() - 1);\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1537157783","body":"public List<List<Integer>> permuteUnique(int[] nums) {\n\n    List<List<Integer>> res = new ArrayList<>();\n\n    if (nums == null || nums.length == 0)\n        return res;\n\n    boolean[] visited = new boolean[nums.length];\n    Arrays.sort(nums);\n    dfs(nums, res, new ArrayList<Integer>(), visited);\n\n    return res;\n}\n\npublic void dfs(int[] nums, List<List<Integer>> res, List<Integer> tmp, boolean[] visited) {\n\n    if (tmp.size() == nums.length) {\n\n        res.add(new ArrayList(tmp));\n        return;\n    }\n\n    for (int i = 0; i < nums.length; i++) {\n\n        if (i > 0 && nums[i] == nums[i - 1] && visited[i - 1])\n            continue;\n\n        //backtracking\n        if (!visited[i]) {\n\n            visited[i] = true;\n            tmp.add(nums[i]);\n            dfs(nums, res, tmp, visited);\n            visited[i] = false;\n            tmp.remove(tmp.size() - 1);\n        }\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null],"richardtaok":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429734899","body":"# 思路\n将k转成数组，从数组最后一个两两相加，在加上上一对相加后的除数\n将余数赋值给较长数组的当前值\n更新当前的除数，直到其中一个走到头了\n长的一个数组继续上面的步骤。直到temp为0.\n返回最长的数组\n# 代码\n```\nvar addToArrayForm = function(num, k) {\n    const data = String(k).split('').map(i=>Number(i))\n    const addList = (num,data)=>{\n        let i = data.length-1;\n        let j = num.length-1;\n        let temp = 0\n        while(i>=0 && j>=0){\n            let sum = data[i] + num[j] + temp;\n            num[j] = sum%10\n            temp = parseInt(sum/10)\n            i--;\n            j--;\n            console.log(num)\n        }\n        while(j>=0){\n            let sum = num[j] + temp;;\n            num[j]=sum%10\n            temp = parseInt(sum/10)\n            j--;\n        }\n        console.log(num)\n        if(temp){\n            num.unshift(1)\n        }\n        return num;\n    }\n    if(num.length>=data.length){\n        return addList(num,data)\n    }else{\n        return addList(data,num)\n    }\n    \n    \n};\n```\n# 复杂度\n时间复杂度： O(n)\n空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431546994","body":"# 代码\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    const res = new Array(s.length).fill(0);\r\n    const n = s.length;\r\n    // idx是记录下最近一次左边c出现的位置\r\n    for(let i=0,idx=-n;i<n;i++){\r\n        if(s[i]===c){\r\n            idx = i\r\n        }\r\n        res[i] = i-idx;\r\n    }\r\n    // 记录下最近一次右边c出现的位置\r\n    for(let i=n-1,idx=2*n;i>=0;i--){\r\n        if(s[i]===c){\r\n            idx = i\r\n        }\r\n        res[i] = Math.min(res[i],idx-i)\r\n    }\r\n    return res\r\n};\r\n```\r\n# 复杂度分析\r\nT(n)=O(n)\r\nS(n)=O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433315696","body":"# 代码\n```\nvar CustomStack = function(maxSize) {\n    this.length = 0\n    this.maxSize = maxSize;\n    this.values = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.length<this.maxSize){\n        this.values.push(x)\n        this.length +=1;\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.length>0){\n        this.length-=1\n        return this.values.pop()\n    }\n    return -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    console.log(this.length,k)\n    const len = this.length<k ? this.length : k\n    for(let i = 0;i<len;i++){\n        this.values[i] += val\n    }\n    \n};\n```\n# increment复杂度\nT(n)= O(k)\nS(n)=O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434825772","body":"# 思路\n1. 因为我们需要重复数字次数的字符串，而字数数字存在于字符串前面，所以适合借助栈来使用。\n2. 一个栈放数字，因为可能会遇到连续好几次的[，所以我们需要一个栈来存放【 之前的字符串。\n3. 开始循环\n    - 如果遇到数字，放到数字栈中，但是由于可能存在好几个数字，所以需要一个repeat来记录多个数字\n    - 如果遇到【  将repeat入数字栈，将攒的str入字符栈 ，str重新记录，repeat置为0，为了防止遇到3[a4[c]]这种\n    - 如果遇到普通字符，那就就攒字符\n   - 如果遇到 】，数字栈出栈，字符str重复数字次数。res = 字符栈出栈一个值，连接上str\n4. 最终的str就是我们想要的str\n# 代码分析\n```\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    const repeatStack = []\n    const resStack = []\n    let res=\"\"\n    let repeat = 0\n    for(let i=0;i<s.length;i++){\n        const str = s[i];\n        if(str>='0' && str<='9'){\n            repeat =repeat*10+ (str - '0')\n        }else if(str === '['){\n            repeatStack.push(repeat);\n            resStack.push(res);\n            res=''\n            repeat = 0\n        }else if(str === ']'){\n            let num = repeatStack.pop()\n            let s = ''\n            while(num>0){\n                s+=res;\n                num-=1\n            }\n            res = resStack.pop()+s;\n        }else{\n            res+=str\n        }\n    }\n    return res;\n};\n```\n# 复杂度分析\nT(n) = O(n)\nS(n) = O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435688248","body":"# 思路\n这个题目上说的是用两个栈实现队列，但是在js中栈也是数组模拟的。所以当我们直接用一个数组也就能模拟出队列\npush：就是入，放到数组最后\npop：返回就是数组第一个值，然后删除数组第一个值。\npeek：就是数组第一个\n# 代码\n```javascript\nvar MyQueue = function() {\n    this.stack = []\n    this.head = 0;\n    this.tail = 0\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stack.push(x);\n    this.tail+=1\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    return this.stack[this.head++]\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.stack[this.head]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.head === this.tail\n};\n```\n# 复杂度分析\nT(n)=O(1)\nS(n)=O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436018787","body":"# 算法思路\n看了大佬的解题思路，才知道这个是非递减的就需要分块。所以使用递增栈来做一个分块临界，导致每次都能将最大的保留下来。直到遇到更大的没法合并的\n# 代码\n```javascript\nvar maxChunksToSorted = function(arr) {\n    let stack = []\n    for(let i=0;i<arr.length;i++){\n\n        if(stack.length &&  stack[stack.length-1]> arr[i]){\n            const topStack = stack[stack.length-1]\n            while(stack && stack[stack.length-1]>arr[i]){\n                stack.pop()\n            }\n            stack.push(topStack)\n        }else{\n            stack.push(arr[i])\n        }\n    }\n    return stack.length\n};\n```\n# 复杂度分析\nO(n)\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437222578","body":"# 代码\n```javascript\nif (!head || !head.next) return head;\n    let count = 0,now = head;\n    while (now) {\n        now = now.next;\n        count++;\n    }\n    let new_k = k % count;\n    let slow = (fast = head);\n    while(fast.next){\n        if(new_k-- <= 0){\n            slow = slow.next\n        }\n        fast = fast.next\n    }\n    const cur = slow.next;\n    slow.next = null;\n    fast.next = head;\n    return cur\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1440277827","body":"# 算法思路\n1. 链表的交换\n2. 递归\n# 代码\n```javascript\nvar swapPairs = function(head) {\n    if(!head || !head.next){\n        return head\n    }\n    const pre = head;\n    const cur = head.next;\n    const next = cur.next;\n    cur.next = pre;\n    pre.next = swapPairs(next);\n    return cur;\n};\n```\n# 复杂度分析\nT(n) = O(n)\nS(n) = O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440293693","body":"# 思路\n以当前节点为根，左边的为左子树，右边的为右子树。\n快慢指针，来选中间节点。快指针走两步，慢指针走一步，直到快指针到达尾部，慢指针真好为中间节点。\n# 代码\n```javascript\nvar sortedListToBST = function(head) {\n    function dfs(head, tail) {\n        if (head == tail) return null;\n        let fast = head;\n        let slow = head;\n        while (fast != tail && fast.next != tail) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        let root = new TreeNode(slow.val);\n        root.left = dfs(head, slow);\n        root.right = dfs(slow.next, tail);\n        return root;\n    }   \n    if (!head) return null;\n    return dfs(head, null);\n};\n```\n# 复杂度分析\nT(n)=O(nlogn)\nS(n) = O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1445392574","body":"# 思路\n设相交部分为C，那么链表则表示成A= a+C，B= b+C。总会以C结尾。那么A+B = a+C+b+C；B+A = b+C+a+C;到一定部分都会以C开头。那时相等就是我们想要的部分\n# 代码\n```javascript\nvar getIntersectionNode = function(headA, headB) {\n    let pre = headA;\n    let after = headB;\n    while(pre!==after){\n        pre = pre===null? headB : pre.next;\n        after = after===null? headA : after.next;\n    }\n    return pre\n};\n```\n# 复杂度\nT(n)=O(m+n),m,n分别代表A和B的长度；\nS(n) = O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1445401866","body":"```javascript\nvar detectCycle = function(head) {\n    // 快指针先走两步，慢指针走一步，然后两人相遇。慢指针走了L+C，快指针走了2（L+C） = L+n(C+D) \n    // =》L=D+(n-1)(C+D)\n    // 所以如果从开头开始算，那么就是D（剩下的一点到开始的距离） + (n-1)圈 的C+D\n    // 此时快指针从头开始。直到两人再次相遇。  所以快指针走的L真好可以在起始点，两人相遇\n    let fast = head;\n    let slow = head;\n    do {\n        if (fast != null && fast.next != null) {\n            fast = fast.next.next;\n        } else {\n            fast = null;\n        }\n        if(slow){\n            slow = slow.next;\n        }\n        \n    } while (fast != slow);\n    if(fast===null){return null}\n    fast = head;\n    while(fast!==slow){\n        slow = slow.next;\n        fast = fast.next;\n    }\n    return fast;\n};\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445387613","body":"/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function (root) {\n    if (root === null) return 0\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))\n\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448324551","body":"# 算法思路\n解决二叉树的思路就是看一棵树，只有左右节点和没有节点的情况。所以就是根节点*10+左节点值+根节点*10+右节点值\n# 算法代码\n```javascript\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root1) {\n    const dfs = (root, path)=>{\n        if(root===null) return 0;\n        path = path*10+root.val;\n        if(root.left === null && root.right === null) return path;\n        return dfs(root.left, path) + dfs(root.right, path);\n    }\n    return dfs(root1, 0)\n};\n```\n# 复杂度\nT(n) = O(n)\nS(n) = O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450408817","body":"# 算法思路\n方法一：使用队列，先进先出。但是我们要的是最后一层的最左边。所以我们要右子树先入队，然后一层一层进队，队列的最后一个就是我们需要的内容\n方法二：递归思想。计算当前层，每往下一层都记录一下当前层的高度，同事更新一下当前的res，因为我们从左子树开始，所以当前的res一定是最左边。因为一旦层高发生变化那么res就会更新。\n# 算法\n```javascript\nvar findBottomLeftValue = function(root1) {\n    let curDepth = 0;\n    let res = root1.val;\n    const dfs = (root, depth)=>{\n        if(!root) return ;\n        depth +=1;\n        dfs(root.left, depth);\n        dfs(root.right, depth);\n        if(curDepth<depth){\n            curDepth = depth;\n            res = root.val;\n        }\n    }\n    dfs(root1, 0)\n    return res\n};\n```\n# 复杂度\n`T(n)=O(n)`\n`S(n)=O(n)`","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1456313086","body":"# 算法思路\n层序遍历，用字符串相拼接，null用#代替。反序列化时候，也用队列，不等于#的时候，赋予当前值左子树和右子树\n# 代码\n```javascript\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    const queue= [root]\n    let res = []\n    // 层序遍历\n    while(queue.length){\n        // 队首出队\n        const cur = queue.shift()\n        if(cur){\n            res.push(cur.val)\n            queue.push(cur.left);\n            queue.push(cur.right);\n        }else{\n            res.push('#')\n        }\n    }\n    return res.join(',')\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    // 去除空\n    if(data==='#') return null;\n    // 先用，分割开\n    let list = data.split(',');\n    const root = new TreeNode(list[0]);\n    const queue = [root];\n    let cur = 1\n    while(cur<list.length){\n        const node = queue.shift();\n        const left = list[cur];\n        const right = list[cur+1];\n        if(left!=='#'){\n            const leftNode =new TreeNode(left);\n            node.left = leftNode\n            queue.push(leftNode);\n\n        }\n        if(right !=='#'){\n            const rightNode = new TreeNode(right);\n            node.right = rightNode;\n            queue.push(rightNode);\n        }\n        cur=cur+ 2\n    }\n    return root\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1456373381","body":"# 算法\n这个坐标算法和原题有点不一样，但是都可以通过哈希桶来算出\n# 代码\n```javascript\nvar verticalTraversal = function(root) {\n    if(!root) return [];\n    const pos = {}\n    const getColRow = (root,row,col)=>{\n        if(!root) return ;\n        if(!(row in pos)){\n            pos[row] = []\n        }\n        pos[row].push([col, root.val])\n        getColRow(root.left, row-1, col-1);\n        getColRow(root.right, row+1, col-1)\n    }\n    // 得到所有树对应的坐标\n    getColRow(root, 0,0)\n    let sorted = Object.keys(pos)\n    .sort((a, b) => +a - +b)\n    .map((key) => pos[key]);\n    sorted = sorted.map((g) => {\n        g.sort((a, b) => {\n        // y 坐标相同的，按节点值升序排\n        if (a[0] === b[0]) return a[1] - b[1];\n        // 否则，按 y 坐标降序排\n        else return b[0] - a[0];\n        });\n        // 把 y 坐标去掉，返回节点值\n        return g.map((el) => el[1]);\n    });\n    // [ [ [ 0, 3 ] ], [ [ -1, 9 ], [ 1, 20 ] ], [ [ 0, 15 ], [ 2, 7 ] ] ]\n    console.log(sorted)\n    return sorted\n\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1460254502","body":"```javascript\r\nvar twoSum = function(nums, target) {\r\n    const res = new Map();\r\n    for(let i=0;i<nums.length;i++){\r\n        const remain = target - nums[i]\r\n        if(!res.has(remain)){\r\n            res.set(nums[i],i)\r\n        }else{\r\n            return [res.get(remain),i]\r\n        }\r\n    }\r\n    return []\r\n};\r\n```\r\n# 复杂度分析\r\nT(n) = O(n)\r\nS(n) = O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1460285961","body":"```javascript\r\nvar topKFrequent = function(nums, k) {\r\n    const res = []\r\n    const map = new Map()\r\n    for(let i=0;i<nums.length;i++){\r\n        if(!map.has(nums[i])){\r\n            map.set(nums[i],1)\r\n        }else{\r\n            map.set(nums[i],map.get(nums[i])+1)\r\n        }\r\n    }\r\n    // 对频次进行排序\r\n    let values = [...map.values()].sort((a, b) => b - a);\r\n    let keys =  [...map.keys()]\r\n    console.log(map, keys, values);\r\n    for(let i = 0; i < k; i++) {\r\n        let key = keys.find(key => map.get(key) === values[i])\r\n        res.push(key)\r\n        map.delete(key)\r\n    }\r\n    return res\r\n};\r\n```\r\n# 复杂度\r\nT(n) = O(n)\r\nS(n) = O(n)","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chocolate-emperor":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429752834","body":"```c++\n// 大数加法，从最低位计算，一直加到两数均取完，最后再把多出的进位数也加上\nclass Solution {\npublic:\n\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(),num.end());\n        vector<int>res;\n        int bit_res = 0,curr=0;\n        while(k!=0 || curr<num.size()){\n            if(curr<num.size()) bit_res+=num[curr];\n            if(k!=0)    bit_res += k%10;\n            res.push_back(bit_res%10);\n\n            bit_res = bit_res/10;\n            k=k/10;\n            curr+=1;\n        }\n        while(bit_res!=0){\n            res.push_back(bit_res%10);\n            bit_res/=10;\n        }\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431312919","body":"```c++\nclass Solution {\npublic:\n//每个字符的结果来自离它右侧和左侧最近的字符c中的较小值\n//扫描两遍，第一遍更新所有c字符右侧字符的距离，第二遍更新所有c字符的左侧字符距离\n    vector<int> shortestToChar(string s, char c) {\n        int l = s.length();\n        int dis = 0, i=0, j=l-1;\n        vector<int>res(l,l);\n        while(s[i]!=c && i<l)  i+=1;\n        while(i <= l-1){\n            if(s[i]==c) dis=i;\n            res[i] = min(res[i],i-dis);\n\n            i+=1;\n        }\n\n        while(s[j]!=c && j>=0)   j-=1;\n        while(j>=0){\n            if(s[j]==c) dis=j;\n            res[j] = min(res[j],dis - j);\n\n            j-=1;\n        }   \n\n        return res;  \n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433167584","body":"```c++\nclass CustomStack {\npublic:\n    int stk[1000+5];\n    int max_sz;\n    int cnt;    //（最后一个元素）栈顶元素序号\n    CustomStack(int maxSize) {\n        max_sz = maxSize;\n        cnt = -1;\n    }\n    \n    void push(int x) {\n        if(cnt+1<max_sz)   stk[++cnt] = x;\n\n    }\n    \n    int pop() {\n        if(cnt>-1)    return stk[cnt--];   \n        else return -1;\n    }\n    \n    void increment(int k, int val) {\n        for(int i=0;i<min(k,cnt+1);i++){\n            stk[i]+=val;\n        }\n    }\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1447687995","body":"```c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head ==nullptr || head->next == nullptr) return head;\n        ListNode * sentry = new ListNode(0,head);\n        ListNode * cnt = sentry;\n        int l = 0;\n        while(cnt->next!=nullptr){\n            cnt = cnt->next;\n            l +=1;\n        }\n         k = k % l;\n        if(k == 0)  return head;\n        ListNode *fast = sentry, *slow = sentry;\n        for(int i = 0; i<k;i++){\n            fast = fast->next;\n        }\n\n        while(fast->next!=nullptr){\n            fast = fast->next;\n            slow = slow->next;\n        }\n        ListNode *headNew = slow->next;\n        slow->next =nullptr;\n        fast->next = sentry->next;\n\n        delete sentry;\n        sentry = nullptr;\n        return headNew;\n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1445078585","body":"```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head==nullptr || head->next == nullptr)  return head;\n\n        ListNode* sentry = new ListNode(0,head);\n        ListNode* l = sentry, *r = head->next;\n        while(r!=nullptr){\n            l->next->next=r->next;\n            r->next = l->next;\n            l->next = r;\n\n            l = l->next->next;\n            r = l->next;\n            if(r!=nullptr)  r=r->next;\n        }\n        \n        ListNode *res = sentry->next;\n        delete sentry;\n        sentry = nullptr;\n        return res;\n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439946214","body":"```c++\nclass Solution {\npublic:\n//递归:结束条件，走一步+之前递归的结果\n//从链表中点断开，分成中点，左，右，三个子链表，左右子链转换成左右子树，形成以链表中点为根的BST\n    TreeNode* sortedListToBST(ListNode* head) {\n         if(head==nullptr){\n            return nullptr;\n        }else if(head->next==nullptr){\n            return new TreeNode(head->val,nullptr,nullptr);\n        }\n        else{\n            ListNode*sentry = new ListNode(0,head);\n            ListNode*l=sentry,*r=sentry,*lend=sentry;\n\n            while(r->next!=nullptr){\n                lend = l;\n                l=l->next;\n                r=r->next;\n                if(r->next)     r=r->next;\n            }\n\n            lend->next =nullptr;\n            TreeNode *res = new TreeNode(l->val,\n            sortedListToBST(sentry->next),sortedListToBST(l->next));\n            return res;\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441664738","body":"```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* a = headA, *b = headB;\n        while(a!=b){\n            a = a->next;\n            b = b->next;\n            if(a==nullptr && b)  a = headB;\n            if(b==nullptr && a)  b = headA;\n        }\n        return a;\n    }\n};\n//时间复杂度：O(m+n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1445064679","body":"```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(head == nullptr || head->next == nullptr) return nullptr;\n\n        ListNode * sentry =  new ListNode(0);\n        sentry->next =head;\n\n        ListNode *fast = sentry, *slow = sentry;\n\n        while(fast->next != nullptr){\n            fast = fast->next;\n            if(fast->next)  fast = fast->next;\n            slow = slow->next;\n            if(fast == slow)    break;\n        }\n        if(fast->next ==nullptr)    return nullptr;\n         // 找到环口\n        ListNode *entrance = sentry;\n        while(entrance != fast){\n            entrance = entrance->next;\n            fast = fast->next;\n        }\n        return entrance;\n    }\n};\n\n// 2(x+n)  = x + k*(n+m)+n\n// x + n = k* (n+m)\n// x = m\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1447644393","body":"``` c++\nclass Solution {\npublic:\n    queue<TreeNode*>q;\n    int maxDepth(TreeNode* root) {\n        if(root==nullptr)   return 0;\n        else    q.push(root);\n        int cnt = 0;\n        while(!q.empty()){\n            cnt +=1;\n            int l = q.size();\n            for(int i=0;i<l;i++){\n                TreeNode* tmp = q.front();\n                q.pop();\n\n                if(tmp->left)   q.push(tmp->left);\n                if(tmp->right)  q.push(tmp->right);\n            }\n        }\n        return cnt;\n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445782509","body":"```c++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        //\n        if(p == nullptr && q ==nullptr)   return true;\n        else if(p == nullptr || q == nullptr) return false;\n        else if(p->val != q->val)   return false;\n        else{\n            return (isSameTree(p->left,q->left) && \n                    isSameTree(p->right,q->right));\n        }\n        //\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447684421","body":"```c++\nclass Solution {\npublic:\n    int dfs(TreeNode*curr, int num){\n        if(curr->left==nullptr && curr->right==nullptr) {\n            return  num*10+ curr->val;\n        }\n        int res = 0;\n        if(curr->left)  res+=dfs(curr->left,num*10+curr->val);\n        if(curr->right) res+=dfs(curr->right,num*10+curr->val);\n        return res;\n    }\n    int sumNumbers(TreeNode* root) {\n        return dfs(root,0);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449460505","body":"```c++\nclass Solution {\npublic:\n    //bfs 层次遍历，每层从右往左入队列，队列里最后一个节点即位 最后一层最左节点\n    int findBottomLeftValue(TreeNode* root) {\n        if(!root->left && !root->right) return root->val;\n        TreeNode* last;\n        queue<TreeNode*>q;\n        q.push(root);\n        while(!q.empty()){\n            int l = q.size();\n            for(int i = 0; i<l;i++){\n                TreeNode* tmp = q.front();\n                q.pop();\n                last = tmp;\n                if(tmp->right)   q.push(tmp->right);\n                if(tmp->left)   q.push(tmp->left);\n            }\n        }\n        return last->val;\n    }\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1463840027","body":"```c++\nclass Solution {\npublic:\n    int distance(vector<int>&a, vector<int>&b){\n        return ((a[0]-b[0])*(a[0]-b[0]) + \n        (a[1]-b[1])*(a[1]-b[1]));\n    }\n    \n    int numberOfBoomerangs(vector<vector<int>>& points) {\n       int l = points.size(), res = 0;\n       for(int i=0;i<l;i++){\n           // i 作为中心点\n           map<int,int>dis2num;\n           for(int j=0;j<l;j++){\n               if(j==i) continue;\n               dis2num[distance(points[i],points[j])] += 1;\n           }\n\n           for(int j=0;j<l;j++){\n               if(j==i) continue;\n                res += dis2num[distance(points[i],points[j])] - 1;\n           }\n       }\n    \n        return res;\n    }\n};\n```","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464867270","body":"```c++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int k = -1;\n        int l = nums.size();\n        if(nums.size()==1)  return 1;\n\n        for(int i=0;i<l;i++){\n            if(i+1==l)  nums[++k] = nums[i];\n            else if(nums[i] != nums[i+1]) nums[++k] = nums[i];\n\n        }\n        cout<<k<<endl;\n        return k+1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465142426","body":"```c++\nclass Solution {\npublic:\n\n    int searchInsert(vector<int>& nums, int target) {\n        int l = 0, r = nums.size()-1;\n\n        while(l<r){\n            int mid = l + (r-l)/2;\n            \n            if(target>nums[mid]){\n                l = mid+1;\n            }else if(target<=nums[mid]){\n                r = mid;\n            }\n        }\n\n        if(target>nums[r])  return r+1;\n        else return r;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465735697","body":"```c++\n考察单调队列+滑动窗口。\n维护一个单调递减的队列，每次新元素入队，都要从队尾去除比该元素小的值。队首保持最大值。\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        if(k==1 || nums.size()==1)  return vector<int>(nums);\n        int l = nums.size();\n        //\n        vector<int> res;\n        deque<int>window;\n\n        int start = 0, end = 0;\n        while(end<l){\n            //  收缩\n            if(end-start+1>k)   {\n                if(nums[start]==window.front())     window.pop_front();\n                start+=1;\n            }\n            //扩张\n            while(!window.empty() \n                && window.back()<nums[end])   {window.pop_back();}\n            window.push_back(nums[end]);\n            //结算  \n            if(end-start+1 == k)    res.emplace_back(window.front());\n            end+=1;\n        }\n        return res;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467565470","body":"```c++\n//求入度为n-1，出度位0的点，题目中已知没有重边，可以变成求 入度 + 出度之和为n-1的点。入度是正，出度是负。\nclass Solution {\npublic:\n    int trusted[1000+5];\n    int findJudge(int n, vector<vector<int>>& trust) {\n        \n        for(int i = 1; i <= n; i++){\n            trusted[i] = 0;\n        }\n        \n        for(auto person:trust){\n            trusted[person[0]] -= 1;\n            trusted[person[1]] += 1;\n        }\n\n        int town_judge = -1;\n        for(int i = 1; i <= n; i++){\n            if(trusted[i] == n-1)     town_judge = i;\n        }\n        return town_judge;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469489654","body":"```c++\n//二分图的判定问题，要注意 题目中的条件可能不构成一张图\nclass Solution {\npublic:\n    int color[2000+4];\n    vector<int> adj[2000+4];\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        int l = dislikes.size();\n        if(n == 1 || l == 0)    return true;\n\n        for(int i = 1;i<=n;i++)     color[i] = -1;\n        for(auto dislike:dislikes){\n            int from = dislike[0], to = dislike[1];\n            adj[from].emplace_back(to);\n            adj[to].emplace_back(from);\n        }\n\n        for(int i = 1; i <= n;i++){\n            queue<int>bfs;\n            if(color[i] == -1)  {\n                color[i] = 0;\n                bfs.push(i);\n            }\n            while(!bfs.empty()){\n                int l = bfs.size();\n                int curr = bfs.front();\n                bfs.pop();\n                for(auto ne:adj[curr]){\n                    if(color[ne]==-1)  {\n                        color[ne] = 1 ^ color[curr];\n                        bfs.push(ne);\n                    }\n                    else if(color[ne]==color[curr])     return false;\n            }\n        }    \n        }\n        \n        return true;\n    }\n};\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473249924","body":"```c++\nclass Solution {\npublic:\n    \n    bool judgeCircle(string moves) {\n        int x = 0, y = 0;\n        int l = moves.length();\n        for(int i = 0; i<l ; i++){\n            if(moves[i]=='U'){\n                y+=1;\n            }else if(moves[i]=='D'){\n                y-=1;\n            }else if(moves[i]=='R'){\n                x+=1;\n            }else{\n                x-=1;\n            }\n        }    \n        return (x==0 && y==0);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474867083","body":"```c++\n// bool compare(vector<int>&a,vector<int>&b){\n//     return a[0] < b[0];\n// }\nclass Solution {\n    private:\n    using  LL = long long;\npublic:\n\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        int l = tasks.size();\n        vector<int> res;\n        for(int i = 0; i < l;i++){\n            tasks[i].emplace_back(i);\n        }\n        sort(tasks.begin(),tasks.end(),[](vector<int> &a,vector<int>&b){\n            return a[0] < b[0];\n        });\n\n        auto cmp = [](pair<LL,int>&a,pair<LL,int>&b){\n            if(a.first!=b.first){\n                return a.first >b.first;\n            }else{\n                return a.second>b.second;\n            }\n        };\n\n        priority_queue<pair<LL,int>,vector<pair<LL,int>>,decltype(cmp)> pq(cmp);\n\n        LL time = 0;\n        int index = 0;\n        for(int i = 0; i < l;i++){//输出n个任务的执行顺序\n\n            if(pq.empty()){\n                time = max(time,(LL)tasks[index][0]);\n            }\n\n            //  时间满足条件的任务入队\n            while(index<l && tasks[index][0]<=time) {\n                pq.push(make_pair(tasks[index][1],tasks[index][2]));\n                index+=1;\n            }\n\n            // 队首出队，更新时间\n            auto tmp  = pq.top();\n            pq.pop();\n            res.emplace_back(tmp.second);\n            time += tmp.first;\n        }\n\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475247923","body":"```c++\nclass Solution {\npublic:\n    int Time2HourMinute(string time){\n        int hour = time[0]-'0';\n        hour = hour*10 + (time[1]-'0');\n        int minute = time[3] - '0';\n        minute = minute*10 + (time[4]-'0');\n        return hour*60 + minute;\n    }\n    int numberOfRounds(string loginTime, string logoutTime) {\n\n        int start = Time2HourMinute(loginTime);\n        int end = Time2HourMinute(logoutTime);\n\n        if(end<start){\n            end += 24*60;\n        }\n\n        return max(0,(int)floor(end*1.0/15) - (int)ceil(start*1.0/15));\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476319710","body":"```c++\nclass Solution {\npublic:\n    //  因为字母表有限26个，所以可以枚举字母i,使得两个字符串，按照字母i，以三种方式变化。\n    //  时间复杂度O(M+N)\n    int alphaA[26],alphaB[26];    \n    int minCharacters(string a, string b) {\n        vector<int>alphaA(26,0);\n        vector<int>alphaB(26,0);\n\n        for(auto i:a)   alphaA[i-'a'] +=1;\n        for(auto i:b)   alphaB[i-'a'] +=1;\n\n        int len_a = a.length(), len_b = b.length();\n        int res = len_a + len_b;\n\n        for(int i = 0; i<26; i++){\n            res = min(res, len_a + len_b - alphaA[i] -alphaB[i]);   \n            if(i>0) {\n                alphaA[i] = alphaA[i] + alphaA[i-1];\n                alphaB[i] = alphaB[i] + alphaB[i-1];\n                res = min (res, len_a - alphaA[i-1] + alphaB[i-1]);\n                res = min (res, alphaA[i-1] + len_b - alphaB[i-1]);\n            }\n\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1478083541","body":"```c++\nclass Solution {\npublic:\n    void fastSort(vector<int>&nums,int l, int r){\n        if(l>=r)    return;\n        int bar = nums[(l+r)>>1];\n\n        int left = l-1 ,right = r+1;\n        while(left<right){\n            do(left++); while(nums[left]<bar);\n            do(right--); while(nums[right]>bar);\n\n            if(left<right)  swap(nums[left],nums[right]);\n        }\n        fastSort(nums,l,left);\n        fastSort(nums,left+1,r);\n    }\n    vector<int> sortArray(vector<int>& nums) {\n        int l = 0 , r = nums.size()-1;\n        fastSort(nums,l,r);\n        return nums;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1481260050","body":"```c++\n// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\n\nclass Solution {\npublic:\n    \n    int firstBadVersion(int n) {\n        int l = 1, r = n;\n        while(l<r){\n            int mid = l + (r-l)/2;\n            printf(\"%d\",mid);\n            if(!isBadVersion(mid)){\n                l = mid+1;\n            }else{\n                r = mid;\n            }\n        }\n        return r;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482399388","body":"```c++\n归并排序求变种的逆序对。\n需要注意的是，排序条件仍然是nums[i]>nums[j]，然后变种逆序对需要单独遍历循环求解，判断条件是nums[i]*0.5>nums[j]（防止大数溢出）\nclass Solution {\npublic:\n    int res = 0;\n    typedef long long LL;\n    void mergeSort(vector<int>&nums,int l, int r){\n        if(l>=r)    return;\n\n        int mid = l+(r-l)/2;\n        mergeSort(nums,l,mid);\n        mergeSort(nums,mid+1,r);\n        //合并两段 l ... r\n\n        vector<int>tmp;\n        int i = l, j = mid+1;\n        while(i<=mid && j <=r ){\n            if(nums[i]>nums[j]){\n                tmp.emplace_back(nums[j++]);\n            }\n            else    tmp.emplace_back(nums[i++]);\n        }\n\n        while(i<=mid)  tmp.emplace_back(nums[i++]);\n        while(j<=r)    tmp.emplace_back(nums[j++]);\n\n        i = l,j = mid+1;\n        while(i<=mid && j<=r){\n            if(nums[i]*0.5>nums[j]){\n                res+= mid - i + 1;\n                j+=1;\n            }\n            else    i+=1;\n        }\n\n        for(int i = 0; i<tmp.size() ; i++){\n            nums[l+i] = tmp[i];\n        }\n        //swap_ranges(tmp.begin(),tmp.end(),nums.begin()+l);\n        return;\n    }\n    int reversePairs(vector<int>& nums) {\n        mergeSort(nums,0,nums.size()-1);\n        return res;\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1489739005","body":"```c++\nclass Solution {\npublic:\n\n// \n// 枚举t，判断f(t)是否满足条件。 t [0,max_val]\n// 对t二分搜索，找到满足 f(t) 到达 (n-1,n-1)条件的t最小值,t越大，越能满足\n\n    \n    bool judge(int t,vector<vector<int>>& maps,vector<vector<bool>>&vis,int x,int y){\n        if(t<maps[x][y])    return false;\n    \n        int l = maps.size();\n        if(x == l-1 && y == l-1)    return true;\n\n        int dy[] = {0,0,-1,1};\n        int dx[] = {1,-1,0,0};\n       \n        bool flag = false;\n        for(int i =0; i<4; i++){\n            int ne_x = x +dx[i], ne_y = y + dy[i];\n            if(ne_x >= 0 && ne_x <l && ne_y >= 0 && ne_y<l){\n                if(vis[ne_x][ne_y]==false && t >=maps[ne_x][ne_y]){\n                    vis[ne_x][ne_y] = true;\n                    flag = flag || judge(t,maps,vis,ne_x,ne_y);\n                }\n            }\n        }\n        return flag;\n    }\n    int swimInWater(vector<vector<int>>& grid) {\n        vector<vector<bool>>vis(grid.size());\n        int r = -1;\n        for(int i = 0; i<grid.size();i++){\n            vector<bool>tmp;\n            for(int j= 0; j<grid.size();j++){\n                r = max(grid[i][j],r);\n                tmp.push_back(false);\n            }\n            vis[i] = tmp;\n        }\n\n        int l = 0;\n        while(l<r){\n            int mid  = (l+r)/2;\n            for(int i = 0;i<grid.size();i++){\n                vector<bool>tmp(grid.size(),false);\n                vis[i] = tmp;\n            }\n            if(judge(mid,grid,vis,0,0)==false){\n                l = mid+1;\n            }else{\n                r = mid;\n            }\n        }\n        return l;\n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486398814","body":"```c++\nclass Solution {\npublic:\n    bool isVowel(char x){\n        return (x=='a'|| x == 'e' || x == 'i' || x =='o' || x=='u');\n    }\n    int maxVowels(string s, int k) {\n        int len = s.length();\n        int l = 0, cnt = 0,MaxVowel = 0;\n\n        for(int r = 0; r<len;r++){\n            if(isVowel(s[r]))  cnt+=1;\n            //if (r-l+1<k)     continue;\n\n            if (r-l+1>k){\n                if(isVowel(s[l]))  cnt-=1;\n                l+=1;\n            }\n\n            MaxVowel = max(MaxVowel,cnt);\n        }\n        return MaxVowel;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489772405","body":"```c++\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        int len_p = p.length(),len_s = s.length();\n        int letters_p[26]={0};\n        int letters_s[26]={0};\n        for(auto i:p){\n            letters_p[i-'a'] +=1;\n        }\n        int l = 0;\n        vector<int>res;\n        for(int r = 0;r<len_s;r++){\n            letters_s[s[r]-'a'] +=1;\n\n            if(r-l+1>len_p){\n                letters_s[s[l]-'a'] -=1;\n                l+=1;\n            }\n\n            int flag = true;\n            for(int i = 0; i<26;i++){\n                if(letters_p[i] != letters_s[i])    flag = false;\n            }\n            if(flag)    res.emplace_back(l);\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1492805137","body":"```c++\nclass Solution {\npublic:\n    string minWindow(string s, string t) {\n        int len_s = s.length(), len_t = t.length();\n        int letter_s[128]={0},letter_t[128] = {0};\n        for(auto i:t){\n            letter_t[i] +=1;\n        }\n        if(len_t>len_s) return \"\";\n        \n        int l = 0;\n        string res = \"\";\n      \n        for(int r = 0; r < len_s; r++){\n            //扩展窗口，记录字母数\n            letter_s[s[r]] +=1;\n\n            //满足条件的情况下，收缩窗口大小\n            while(r - l + 1 > len_t && letter_s[s[l]] > letter_t[s[l]]) {\n                letter_s[s[l]] -= 1;\n                l+=1;\n            }\n\n            //结算是否是substring\n            bool flag = true;\n            for(int i = 0;i<128;i++){\n                if(letter_s[i]<letter_t[i])    flag =false;\n            }\n\n            //注意最初res为\"\"\n            if(flag && res.length()==0)  res = s.substr(l,r-l+1);\n            else if(flag && r-l+1<res.length()) res = s.substr(l,r-l+1);\n            //printf(\"%%d %d\\n\",l,r);\n        }\n        return res;\n    }\n};\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493334131","body":"```c++\nclass Solution {\npublic:\n    vector<string>res;\n    int led[10]={1,2,4,8,1,2,4,8,16,32};//10个中拿turendOn个，求组合数\n    void recursion(int hour,int minute,int index,int turnedOn){\n        if(turnedOn==0){\n            string m = to_string(minute);\n            if(m.length()==1)  m = \"0\" + m;\n            res.emplace_back(to_string(hour) +\":\"+m);\n            //printf(\"%d %d \\n\",hour,minute);\n            return;\n        }\n        //index之后才是可选择的范围，之前是已选择的范围\n        for(int i=index;i<10;i++){\n            if(i<4){\n                if(hour+led[i]<=11){\n                    hour+=led[i];\n                    recursion(hour,minute,i+1,turnedOn-1);\n                    hour-=led[i];\n                }\n            }else{\n                if(minute+led[i]<=59){\n                    minute+=led[i];\n                    recursion(hour,minute,i+1,turnedOn-1);\n                    minute-=led[i];\n                }\n            }\n            \n        }\n    }\n    vector<string> readBinaryWatch(int turnedOn) {\n        if(turnedOn<9) {\n            bool vis[10] ={false};\n            recursion(0,0,0,turnedOn);\n        }\n\n        return res;\n    }\n};\n``","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494292478","body":"```c++\nclass Solution {\npublic:\n    int col[10];\n    int dia[20];\n    int backdia[20];\n    int res = 0;\n\n    bool judge(int x, int y,int n){\n        return (col[y]==0 && backdia[x+y]==0 && dia[n+y-x]==0);\n    }\n\n    void dfs(int curr,int n){\n        if(curr == n)   {\n            res+=1;\n        }\n\n        for(int j=0; j<n; j++){\n            if(judge(curr,j,n)){\n                col[j] = 1;\n                backdia[curr+j]=1;\n                dia[n+j-curr]=1;\n\n                dfs(curr+1,n);\n                \n                col[j] = 0;\n                backdia[curr+j]=0;\n                dia[n+j-curr]=0;\n            }\n        }\n    }\n\n    int totalNQueens(int n) {\n        if(n==1)    return 1;\n        for(int i=0 ; i<n ; i++){\n            col[i] = 0;\n            dia[i] = 0;\n            backdia[i] = 0;\n        }\n        dfs(0,n);\n        return res;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497659976","body":"```c++\nclass Solution {\npublic:\n    \n    int dx[4]={0,0,1,-1};\n    int dy[4]={1,-1,0,0};\n   \n   //求每个water最近的land的距离，找距离集合中的最大值\n   //因为每一个步长是相等的，所以可以用bfs搜索，距离为1，2，3，4，最先搜到的一定是最近的\n   //最近距离 = bfs的层数 -》最大的最近距离，bfs的最大层数\n    int maxDistance(vector<vector<int>>& grid) {\n        int len = grid.size();    \n        int mem[104][104]={0};\n        \n        queue<pair<int,int>>q;\n        for(int i=0;i<len;i++){\n            for(int j=0;j<len;j++){\n                if(grid[i][j]==1)   {\n                    q.push(make_pair(i,j));\n                    mem[i][j] = 1;\n                }\n            }\n        }\n\n        if(q.empty()||q.size()==len*len)    return -1;\n        \n        int dis = -1;\n        while(!q.empty()){\n            int l = q.size();\n            for(int i=0;i<l;i++){\n                pair<int,int> tmp = q.front();\n                q.pop();\n                int x = tmp.first, y = tmp.second;\n                for(int j=0;j<4;j++){\n                    int ne_x = x+dx[j], ne_y = y+dy[j];\n                    if(ne_x>=0 && ne_x<len && ne_y>=0 && ne_y<len && 0==mem[ne_x][ne_y]){\n                        mem[ne_x][ne_y]=1;\n                        q.push(make_pair(ne_x,ne_y));\n                    }\n                }\n                \n            }\n            dis+=1;\n        }\n        return dis;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498941503","body":"```C++\nclass Solution {\npublic:\n// 思路：bfs去搜索，要注意的是，拿到的箱子可以是 打开 或 关闭，只入队打开的箱子；\n// 关闭的箱子标记一下已持有，bfs每一层遍历结束时将原本关系但是现在能打开的箱子入队。\n// 为简化操作，拿到钥匙后，立马修改箱子状态\n// 箱子状态： 已持有-》持有未打开-》持能能打开-》持有并开完，队列中放入 持有能打开的箱子\n\n    int maxCandies(vector<int>& status, vector<int>& candies, vector<vector<int>>& keys, vector<vector<int>>& containedBoxes, vector<int>& initialBoxes) {\n        int n =status.size();\n        vector<int>taken(n,0);\n        vector<int>keep(n,0);\n        queue<int>q;\n        int res = 0;\n\n        for(auto i:initialBoxes){\n            if(status[i])   q.push(i);\n            else  keep[i] = 1;\n        }\n        \n        while(!q.empty()){\n            int l = q.size();\n            \n            for(int i = 0; i<l; i++){\n                int curr = q.front();\n                q.pop();\n\n                res += candies[curr];\n                taken[curr]=1;\n                for(auto j:keys[curr])  status[j]=1;\n                for(auto j:containedBoxes[curr]){\n                    if(taken[j]) continue;\n                    else if(status[j]==0)     keep[j] = 1;\n                    else  q.push(j);\n                }\n            }\n            for(int i=0; i<n; i++){\n                if(taken[i]==0 && status[i]==1 && keep[i]==1){\n                    q.push(i);\n                    keep[i]=0;\n                }\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501130920","body":"```c++\nclass Solution {\npublic:\n    //所有可能方案集合中的和最大值\n    // 划分标准：最后一个元素为i， dp[0,1...n-1] 其中的最大值\n    // dp[i] = dp[0...i-2] + nums[i]\n    // strart:dp[0] = nums[0]   dp[1] = nums[1]\n    // i belongs to [2,n-1]\n    // max(dp[0..n-1])\nint dp[100+4]={0};    \n    int rob(vector<int>& nums) {\n        int l = nums.size();\n        if(l<=1)    return nums[0];\n        \n        dp[0] = nums[0];\n        dp[1] = nums[1];\n        for(int i = 2; i<l;i++){\n            for(int j = 0; j<=i-2;j++){\n                dp[i] = max(dp[i],dp[j] + nums[i]);\n            }\n        }\n        int res = 0;\n        for(int i=0; i<l; i++){\n            res = max(res,dp[i]);\n        }\n        return res;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1503269471","body":"```c++\nclass Solution {\npublic:\n//   两个字符串的所有公共子序列集合中的最长值\n//   划分标准：字符串最后一元素是否包含在子序列中(相等、不相等)  dp[i][j]代表到前i个和前j个为止的结果\n//   dp[i][j]  = dp[i-1][j-1] + 1 都包含的前提是相等\n//    i 0 j 0 , i 1 j 0 , i 0 j 1 , i 1 j 1\n//   dp[i][j] = dp[i-1][j-1] , dp[i][j-1], dp[i-1][j]\n//   from dp[1][1]  to  dp[m][n]\n// \n    int dp[1004][1004];\n    int longestCommonSubsequence(string text1, string text2) {\n        int m = text1.length(), n = text2.length();\n        if(m==0 || n == 0)  return 0;\n\n        dp[0][0] = dp[0][1] = dp[1][0] = dp[1][1] = 0;\n        //if(text1[0] == text2[0])    dp[1][1] = 1;\n        for(int i = 1; i<=m;i++){\n            for(int j= 1; j<=n;j++){\n                dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\n                if(text1[i-1] == text2[j-1])    dp[i][j] = max(dp[i-1][j-1]+1,dp[i][j]);\n            }\n        }\n        return dp[m][n];\n        \n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506568743","body":"```c++\nclass Solution {\npublic:\n\n// row column, k, \n// 00 n-1,n-1\n// 求k次move后留在棋盘上的方案集合的数量  dp[i][] a/b = prob\n// \n// 划分标准:最后一次move的起始位置,dp[i][x][y] i次move到达棋盘x，y的方案数量\n// 我为人人， dp[i][x][y] 去更新dp[i+1][nex][ney]的数量\n// res = dp[k][0...n-1][0..n-1]\n    double dp[104][25][25];\n    double knightProbability(int n, int k, int row, int column) {\n        memset(dp, 0, sizeof(dp));\n        dp[0][row][column] = 1;\n        int dx[] = {2,2,1,-1,-2,-2,-1,1};\n        int dy[] = {1,-1,2,2,1,-1,-2,-2};\n        \n        for(int i = 0; i<=k; i++){ \n            for(int x = 0; x<n; x++){\n                for(int y = 0; y<n; y++){\n                    if(i!=0)  dp[i][x][y] = dp[i][x][y]/8;\n\n                    for(int j= 0; j<8; j++){\n                        int ne_x = x+dx[j], ne_y = y+dy[j];\n                        if(ne_x<0 || ne_x >=n || ne_y<0 || ne_y >=n)    continue;\n                        dp[i+1][ne_x][ne_y] += dp[i][x][y];\n                    }\n                }\n            }\n            \n        }\n        double res = 0;\n        for(int x = 0; x<n;x++){\n            for(int y = 0; y<n;y++){\n                res += dp[k][x][y];\n                //cout<<res<<\" \"<<dp[k][x][y]<<endl;\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510364231","body":"```c++\nclass Solution {\npublic:\n\n    int mem[24][2004];\n    //从长度为len的nums中选择，和等于target的方案数量\n    int backtracking(vector<int>&nums,int len, int currSum, int target){\n        if(len==0){\n            if(currSum==target) return 1;\n            return 0;\n        }else if(mem[len][currSum+1000]!=-1){\n            return mem[len][currSum+1000];\n        }\n\n        int add = backtracking(nums,len-1,currSum+nums[len-1],target);\n        int sub = backtracking(nums,len-1,currSum-nums[len-1],target);\n        mem[len][currSum+1000]  = add + sub;\n        return mem[len][currSum+1000];\n    }\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int l = nums.size();\n        memset(mem,-1,sizeof(mem));\n        return backtracking(nums,l,0,target);\n       \n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514333882","body":"```c++\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        sort(g.begin(),g.end());\n        sort(s.begin(),s.end());\n        int m = g.size(), n = s.size();\n        int i = 0,j = 0;\n        int cnt = 0;\n        while(i<m && j<n){\n            if(g[i]<=s[j])  {\n                cnt+=1;\n                i++;\n                j++;\n            }else{\n                j+=1;\n            }\n        }\n        return cnt;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517653024","body":"```c++\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int l = nums.size();\n        int i = 0;\n        if(nums.size()<=1)  return true;\n\n        while(i<l){\n            int maxStep = 0,curr = i;\n            if(nums[i]==0)  return false;\n\n            for(int j = i+1;j<=nums[i]+i && j < l;j++){\n                if(j+nums[j]<=maxStep)  continue;\n                maxStep = j+nums[j];\n                curr = j;\n            }\n\n            if(maxStep>=l-1)  break;\n            i = curr;\n        }\n        return true;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519057451","body":"```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n \n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        ListNode* sentry = new ListNode();\n        ListNode* curr = sentry;\n        if(lists.size()==0) return nullptr;\n        else if(lists.size()==1)    return lists[0];\n        auto cmp = [](const ListNode* a, const ListNode* b){\n            return a->val > b->val;\n        };\n        priority_queue<ListNode*,vector<ListNode*>,decltype(cmp)>pq(cmp);\n        //在入队列时保证非空\n        int l = lists.size();\n        for(int i = 0; i < l; i++){\n            if(lists[i])    pq.push(lists[i]);\n        }\n\n        while(!pq.empty()){\n            ListNode* tmp = pq.top();\n            pq.pop();\n            curr->next= tmp;\n            curr = curr->next;\n            if(tmp->next)    pq.push(tmp->next);\n        }\n        ListNode* head = sentry->next;\n        delete sentry;\n        sentry = nullptr;\n        return head;\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1522694036","body":"```c++\nclass Solution {\npublic:\n    //dfs回溯，f(n-1)所有的子集+ 第n号元素选 或 不选\n    vector<vector<int>>res;\n    void dfs(vector<int>&nums,int index,unordered_map<int,int>&isExist){\n        if(index == nums.size()){\n            vector<int>tmp;\n            for(auto i:nums){\n                if(isExist[i]==1)  tmp.emplace_back(i);\n            }\n            res.emplace_back(tmp);\n            return;\n        }\n        \n        isExist[nums[index]] = 1;\n        dfs(nums,index+1,isExist);\n        isExist[nums[index]] = 0;\n        dfs(nums,index+1,isExist);\n        //dfs(nums,i+1,tmp);\n    }\n    vector<vector<int>> subsets(vector<int>& nums) {\n        unordered_map<int,int>isExist;\n        dfs(nums,0,isExist);\n        return res;\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528704495","body":"```c++\nclass Solution {\npublic:\n    struct Node{\n        int cnt;\n        int precnt;\n        Node* ne[26]; //序号对应字符\n        Node():cnt(0),precnt(0),ne(){}\n    };\n    vector<vector<int>> multiSearch(string big, vector<string>& smalls) {\n        vector<vector<int>> res;\n        unordered_map<string,int>word2index;\n\n        if(smalls.size()<1)   return res;\n        for(int i = 0; i< smalls.size();i++){\n            vector<int>tmp;\n            res.emplace_back(tmp);\n       }\n        if(big.size()<1)    return res;\n        \n        \n        //非空情况下，采用trie树解决\n        Node* root = new Node();\n        int index = 0;\n        for(string i:smalls){\n\n            //trie上插入一个单词,按序遍历字母\n            word2index[i] = index++;\n            Node* curr = root;\n            for(char j:i){\n                int index = j-'a';\n                if(curr->ne[index]==nullptr){\n                    curr->ne[index] = new Node();\n                }\n                curr = curr->ne[index];\n                curr->precnt +=1;\n            }\n            curr->cnt+=1;\n        }\n\n        //判断各字符为首的字符串前缀能否匹配到trie上的词\n        int l = big.size();\n        for(int i=0;i<l;i++){\n\n            Node* curr = root;\n            string word = \"\";\n            for(int j = i; j<l;j++){\n                int num = big[j] - 'a';\n                if(curr->ne[num]==nullptr)  break;\n\n                word += big[j];\n                curr = curr->ne[num];\n                if(curr->cnt>0) {\n                    res[word2index[word]].emplace_back(i);\n                }\n            }    \n\n        }\n\n        return res;\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1531322035","body":"```c++\nclass Solution {\npublic:\n    int pa[100000+4];\n    int findparent(int x){\n        if(pa[x]==x)    return pa[x];\n        int root = findparent(pa[x]);\n        pa[x] = root;\n        return pa[x];\n    }\n    void SetUnion(int x,int y){\n        int roota = findparent(x);\n        int rootb = findparent(y);\n        if(roota!=rootb){\n            pa[rootb] = roota;\n        }\n    }\n    int makeConnected(int n, vector<vector<int>>& connections) {\n        for(int i = 0; i<n;i++){\n            pa[i] = i;\n        }\n\n        int remains = 0;\n        for(auto edge: connections){\n            if(findparent(edge[0])==findparent(edge[1])) {\n                remains+=1;\n                continue;\n            }else{\n                SetUnion(edge[0],edge[1]);\n            }\n        }\n        int cnt_center=0;\n        unordered_set<int>roots;\n        for(int i = 0; i<n;i++){\n            roots.insert(findparent(i));\n        }\n        if(remains< roots.size()-1) return -1;\n        return roots.size()-1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1532618868","body":"```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* pruneTree(TreeNode* root) {\n        if(root==nullptr)   return root;\n\n        root->left  = pruneTree(root->left);\n        root->right = pruneTree(root->right);\n        \n        if(root->val == 0 ){\n            if(root->left ==nullptr&&root->right==nullptr)  return nullptr;\n        }\n\n\n        \n        return root;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1535795091","body":"```c++\nclass Solution {\npublic:\n    //因为要输出方案，所以需要用搜索\n    // 1 1 2 5  1 1 5  2 5\n    vector<vector<int>> res;\n    vector<int>nums;\n    void backtrack(vector<int>&curr,int target,int currSum,int index){\n        if(currSum>target)  return;\n        else if(currSum == target){\n            res.emplace_back(curr);\n        }\n        \n        int  l = nums.size();\n        if(index==l)  return;\n\n        for(int i = index; i<l ;i++){\n            if(i>index && nums[i]==nums[i-1])   continue;\n            curr.emplace_back(nums[i]);\n            backtrack(curr,target,currSum+nums[i],i+1);\n            curr.pop_back();\n        }\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(),candidates.end());\n        nums = vector<int>(candidates.begin(),candidates.end());\n        vector<int>tmp;\n        backtrack(tmp,target,0,0);\n        return res;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null],"lydia61":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429759312","body":"# 989. 数组形式的整数加法\n\n## 思路\n\n - 将 num 和 k 逐位进行求和，并将求和结果的个位逐个保存\n- 直到 num 全部遍历， 且 k 为 0 \n\n## 代码\n \n``` c++\nclass Solution\n{\npublic:\n    vector<int> addToArrayForm(vector<int> &num, int k)\n    {\n        // 用来保存结果值\n        vector<int> v_res;\n        \n        // 将 num 和 k 逐位进行求和，并将求和结果的个位逐个保存\n        // 直到 num 全部遍历， 且 k 为 0 \n        while (!num.empty() || k) {\n            if (!num.empty()) { \n                k += num.back();\n                num.pop_back();\n            }\n            v_res.push_back(k % 10);\n            k /= 10;\n        }\n\n        // 反转成从高位到低位\n        reverse(v_res.begin(), v_res.end());\n        \n        // 返回结果\n        return v_res;\n    }\n};\n```\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431497927","body":"# 821. 字符的最短距离\n\n## 思路\n\n正反遍历字符串，分别算出距离目标字符的前后距离。\n\n## 代码\n\n``` c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        // 获取字符串长度\n        int length = s.length();\n        // 初始化结果向量\n        vector<int> v_res(length, 0);\n\n        // 保存 目标位置，初始值为最远处\n        int point_target = -length;\n\n        // 正向遍历\n        for(int index = 0; index < length; index++) {\n            if(s[index] == c) \n                point_target = index;\n            v_res[index] = index - point_target;\n        }\n\n        // 反向遍历\n        point_target = length << 1;\n        for(int index = length - 1; index >= 0; index--) {\n            if(s[index] == c) \n                point_target = index;\n            if (point_target - index < v_res[index])\n                v_res[index] = point_target - index;\n        }\n\n        // 返回结果\n        return v_res;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433244234","body":"# 1381. 设计一个支持增量操作的栈\n\n## 思路\n\n利用定长数组模拟栈\n\n## 代码\n\n``` C++\nclass CustomStack {\nprivate:\n    int * stack;\n    short length;\n    short MAX_SIZE;\n\npublic:\n    CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        length = 0;\n        MAX_SIZE = maxSize;\n    }\n    \n    void push(int x) {\n        if(length < MAX_SIZE)\n            stack[length++] = x;\n    }\n    \n    int pop() {\n        if(length)\n            return stack[--length];\n        else\n            return -1;\n    }\n    \n    void increment(int k, int val) {\n        if (k > length)\n            k = length;\n        while (k)\n            stack[--k] += val;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434840869","body":"# 394. 字符串解码\n\n## 思路\n\n用栈数据结构录入编码的字符串\n\n## 代码\n\n``` C++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res = \"\";\n        string encoded_string;\n        int k, index;\n\n        for(char c : s) {\n            if (c != ']')\n                res += c;\n            else {\n                encoded_string = \"\";\n                k = 0;\n                while(res.back() != '[') {\n                    encoded_string = res.back() + encoded_string;\n                    res.pop_back();\n                }\n                res.pop_back();\n                \n                index = 0;\n                while(!res.empty() && res.back() <= '9' && res.back() >= '0') {\n                    k += (res.back() - '0') * pow(10, index++);\n                    res.pop_back();\n                    cout << k << endl;\n                }\n\n                while(k--)\n                    res += encoded_string;\n            }\n        }\n        return res;\n    }\n};\n``` \n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435693645","body":"# 232. 用栈实现队列\r\n\r\n## 思路\r\n\r\n用输入栈和输出栈两个栈模拟列表。当输出栈有内容时候，输出栈栈顶即为出队数据；若输出栈为空，则从输入栈逐个拿去数据之后再做出栈处理。\r\n\r\n## 代码\r\n\r\n``` C++ \r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n\r\npublic:\r\n    MyQueue() {}\r\n\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    int pop() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n\r\n    int peek() {\r\n        if (outStack.empty()) {\r\n            while (!inStack.empty()) {\r\n                outStack.push(inStack.top());\r\n                inStack.pop();\r\n            }\r\n        }\r\n        return outStack.top();\r\n    }\r\n\r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：O(1)\r\n- 空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436012724","body":"import collections\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        count = collections.defaultdict(int)\n        ans, nonzero = 0, 0\n\n        for x, y in zip(arr, sorted(arr)):\n            count[x] += 1\n            if count[x] == 0:\n                nonzero -= 1\n            if count[x] == 1:\n                nonzero += 1\n\n            count[y] -= 1\n            if count[y] == -1:\n                nonzero += 1\n            if count[y] == 0:\n                nonzero -= 1\n\n            if nonzero == 0:\n                ans += 1\n\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437189745","body":"# 61.旋转链表\n\n## 思路\n\n链表遍历\n\n## 代码 \n\n``` python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        length = 1\n\n        p_node = head\n        while p_node.next:\n            length += 1\n            p_node = p_node.next\n        \n        p_node.next = head\n        k %= length\n        for _ in range(length - k):\n            p_node = p_node.next\n        res = p_node.next\n        p_node.next = None\n        return res\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438610499","body":"# 24. 两两交换链表中的节点\n\n## 思路\n\n使用递归，每次交换两个节点\n\n## 代码\n\n``` C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(!head || !head->next) \n            return head;\n        ListNode * new_head = head->next;\n        head->next = swapPairs(new_head->next);\n        new_head->next = head;\n        return new_head;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440178672","body":"# 109. 有序链表转换二叉搜索树\n\n## 思路\n\n利用快慢指针找出链表中点，然后将左右分别进行递归操作，构成搜索二叉树。\n\n## 代码\n\n``` C++ \nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(!head)\n            return NULL;\n        if(!head->next)\n            return new TreeNode(head->val);\n        \n        ListNode *pre, *slow, *fast;\n        slow = head;\n        fast = head;\n\n        while(fast && fast->next) {\n            pre = slow;\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        TreeNode * root = new TreeNode(slow->val);\n\n        if(pre) {\n            pre->next = NULL;\n            root->left = sortedListToBST(head);\n        }\n        root->right = sortedListToBST(slow->next);\n\n        return root;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441938016","body":"# 160. 相交链表\r\n\r\n## 思路\r\n\r\n双指针分别从两个头部开始遍历，到达末尾后从另一个头部开始，则两个指针相等时为交点，若无交点则同时为`NULL`\r\n\r\n## 代码\r\n\r\n``` C++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        ListNode *p1, *p2;\r\n        p1 = headA;\r\n        p2 = headB;\r\n\r\n        while(p1 != p2) {\r\n            if(p1)\r\n                p1 = p1->next;\r\n            else\r\n                p1 = headB;\r\n            if(p2)\r\n                p2 = p2->next;\r\n            else\r\n                p2 = headA;\r\n        }\r\n        return p1;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443882890","body":"# 142. 环形链表 Ⅱ\r\n\r\n## 思路\r\n\r\n快慢双指针，数学计算\r\n\r\n## 代码\r\n\r\n``` C++ \r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode *fast, *slow;\r\n        fast = head;\r\n        slow = head;\r\n\r\n        while(fast && fast->next) {\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n            if(fast == slow)\r\n                break;\r\n        }\r\n\r\n        if(!fast || !fast->next)\r\n            return NULL;\r\n        \r\n        fast = head;\r\n        while(fast != slow) {\r\n            slow = slow->next;\r\n            fast = fast->next;\r\n        }\r\n\r\n        return slow;\r\n    }\r\n};\r\n``` \r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445122500","body":"# 146. LRU\r\n\r\n## 思路\r\n\r\n经典LRU算法\r\n\r\n## 代码\r\n\r\n``` python\r\nclass LRUCache(object):\r\n\r\n    def __init__(self, capacity):\r\n        \"\"\"\r\n        :type capacity: int\r\n        \"\"\"\r\n        LRUCache.capacity = capacity\r\n        LRUCache.length = 0\r\n        LRUCache.dict = collections.OrderedDict()\r\n\r\n    def get(self, key):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        try:\r\n            value = LRUCache.dict[key]\r\n            del LRUCache.dict[key]\r\n            LRUCache.dict[key] = value\r\n            return value\r\n        except:\r\n            return -1\r\n\r\n    def put(self, key, value):\r\n        \"\"\"\r\n        :type key: int\r\n        :type value: int\r\n        :rtype: nothing\r\n        \"\"\"\r\n        try:\r\n            del LRUCache.dict[key]\r\n            LRUCache.dict[key] = value\r\n        except:\r\n            if LRUCache.length == LRUCache.capacity:\r\n                LRUCache.dict.popitem(last = False)\r\n                LRUCache.length -= 1\r\n            LRUCache.dict[key] = value\r\n            LRUCache.length += 1\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445360859","body":"# 104. 二叉树的最大深度\r\n\r\n## 思路\r\n\r\n左右子树的最大深度 + 1，递归求子树深度。\r\n\r\n## 代码\r\n\r\n``` C++\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if(root) {\r\n            return max(maxDepth(root->left), maxDepth(root->right)) + 1;\r\n        }\r\n        else\r\n            return 0;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：0","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446178600","body":"# 100. 相同的树\r\n\r\n## 思路\r\n\r\n使用**递归**的思想：当前节点的值相同，且左右子树为相同的树则为相同的树。如果遇到值不同的节点，或者树深度不一致则返回否。\r\n\r\n## 代码\r\n\r\n``` C++\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if(!p and !q)\r\n            return true;\r\n        if(!p or !q)\r\n            return false;\r\n        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448295730","body":"# 129. 求根到叶子节点数字之和\r\n\r\n## 思路\r\n\r\n 使用前序遍历，并将当前的遍历结果乘以10累加。\r\n\r\n## 代码\r\n\r\n``` C++\r\nclass Solution {\r\npublic:\r\n    int sumNumbers(TreeNode* root, long long res = 0) {\r\n        if(!root)\r\n            return 0;\r\n        res = res * 10 + root->val;\r\n        if(!root->left && ! root->right)\r\n            return res;\r\n        else\r\n            return sumNumbers(root->left, res) + sumNumbers(root->right, res);\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450237433","body":"# 513. 找树左下角的值\r\n\r\n## 思路\r\n\r\n使用队列存储每一层树的节点，每层取队列的第一个节点，并逐步遍历当前队列内的子树。\r\n\r\n## 代码\r\n\r\n``` C++ \r\nclass Solution {\r\npublic:\r\n    int findBottomLeftValue(TreeNode* root) {\r\n        queue<TreeNode*>  my_queue;\r\n        TreeNode * temp;\r\n        int res, cur_len;\r\n\r\n        my_queue.push(root);\r\n        while(!my_queue.empty()) {\r\n            res = my_queue.front()->val;\r\n            cur_len = my_queue.size();\r\n            for(int i = 0; i < cur_len; i++) {\r\n                temp = my_queue.front();\r\n                my_queue.pop();\r\n                if(temp->left)\r\n                    my_queue.push(temp->left);\r\n                if(temp->right)\r\n                    my_queue.push(temp->right);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度： O(n)\r\n- 空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451994904","body":"# 297. 二叉树的序列化与反序列化\r\n\r\n## 思路\r\n\r\nDFS\r\n\r\n## 代码\r\n\r\n```python\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if not root:\r\n            return 'None'\r\n        return str(root.val) + ',' + str(self.serialize(root.left)) + ',' + str(self.serialize(root.right))\r\n        \r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        def dfs(dataList):\r\n            val = dataList.pop(0)\r\n            if val == 'None':\r\n                return None\r\n            root = TreeNode(int(val))\r\n            root.left = dfs(dataList)\r\n            root.right = dfs(dataList)\r\n            return root\r\n        print(data)\r\n        dataList = data.split(',')\r\n        return dfs(dataList)\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453664420","body":"# 987. 二叉树的垂序遍历\n\n## 思路\n\n以列作为`key`值，将二叉树的遍历结果保存到哈希表重，最终从哈希表中按照`key`值逐步读取。\n\n## 代码\n\n``` python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def verticalTraversal(self, root):\n        memo = defaultdict(list)  # 带默认值为list的无序字典\n        def dfs(cur, row, col):\n            nonlocal memo\n            if None == cur:\n                return None\n            memo[col].append((row, cur.val)) # 以列col为键值，行和val组成元组作为list的元素插入\n            dfs(cur.left, row+1, col-1)       # 递归左子树\n            dfs(cur.right, row+1, col+1)      # 递归右子树\n        dfs(root, 0, 0)\n        items=sorted(memo.items(), key=lambda a:a[0])   # 以（键值，列表）提取字典的所有元素并按键值（也就是col）排序\n        return [list(map(lambda a:a[1], sorted(v))) for k, v in items]\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454779651","body":"# 1.两数之和\n\n## 思路\n\n将遍历的 `数值: 位置` 保存在 `hashtable` 中，如果 `target` 与当前值的差存在 `hashtable` 中，则找到求解目标。\n\n## 代码\n\n``` C++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> hashtable;\n        for (int i = 0; i < nums.size(); ++i) {\n            auto it = hashtable.find(target - nums[i]);\n            if (it != hashtable.end()) {\n                return {it->second, i};\n            }\n            hashtable[nums[i]] = i;\n        }\n        return {};\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455125978","body":"347. 前 K 个高频元素\n\n## 思路\n\n使用哈希表报错数组元素出现次数\n\n## 代码\n\n``` python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        def sift_down(arr, root, k):\n            val = arr[root] \n            while root<<1 < k:\n                child = root << 1\n                if child|1 < k and arr[child|1][1] < arr[child][1]:\n                    child |= 1\n                if arr[child][1] < val[1]:\n                    arr[root] = arr[child]\n                    root = child\n                else:\n                    break\n            arr[root] = val\n\n        def sift_up(arr, child):\n            \"\"\"上浮log(k),如果新加入的节点<父节点就一直上浮\"\"\"\n            val = arr[child]\n            while child>>1 > 0 and val[1] < arr[child>>1][1]:\n                arr[child] = arr[child>>1]\n                child >>= 1\n            arr[child] = val\n\n        stat = collections.Counter(nums)\n        stat = list(stat.items())\n        heap = [(0,0)]\n        for i in range(k):\n            heap.append(stat[i])\n            sift_up(heap, len(heap)-1) \n        for i in range(k, len(stat)):\n            if stat[i][1] > heap[1][1]:\n                heap[1] = stat[i]\n                sift_down(heap, 1, k+1) \n        return [item[0] for item in heap[1:]]\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(nlogk)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456389011","body":"# 447. 回旋镖的数量\n\n## 思路\n\n暴力算法\n\n## 代码\n\n``` python \nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n < 3:\n            return 0 \n        def mydis(p1, p2):\n            return (p1[0] - p2[0])*(p1[0] - p2[0]) + (p1[1] - p2[1])*(p1[1] - p2[1])\n        ans = 0\n        for i in range(n):\n            cnt = collections.Counter() \n            for j in range(n):\n                dis = mydis(points[i], points[j])\n                cnt[dis] += 1\n            for x in cnt.values():\n                ans += math.perm(x,2)\n        return ans\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N^2)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1458349127","body":"# 3. 无重复字符的最长子串\n\n## 思路\n\n使用双指针定位子串的起始位置，快指针的遍历结果保存到哈希表中，进行重复判断。\n\n## 代码\n\n``` python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        occ = set()\n        n = len(s)\n        rk, ans = -1, 0\n        for i in range(n):\n            if i != 0:\n                occ.remove(s[i - 1])\n            while rk + 1 < n and s[rk + 1] not in occ:\n                occ.add(s[rk + 1])\n                rk += 1\n            ans = max(ans, rk - i + 1)\n        return ans\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460190092","body":"# 30. 串联所有单词的字串\n\n## 思路\n\n将`s`字符串拆解成与`words`中等宽的单词，并使用双指针逐渐滑动字符串起始位置，对子串内的词频进行统计，若与`words`一致，则当前窗口起点为其中一个目标值。\n\n## 代码\n\n``` python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        allWords = collections.Counter(words)\n        wordNum = len(words)\n        wordLen = len(words[0])\n        res = []\n        for i in range(len(s) - wordNum * wordLen + 1):\n            subWords = collections.defaultdict(int)\n            index = i\n            while index < i + wordNum * wordLen:\n                curWord = s[index: index + wordLen]\n                if curWord not in allWords or subWords[curWord] == allWords[curWord]:\n                    break\n                subWords[curWord] += 1\n                index += wordLen\n            if index == i + wordNum * wordLen:\n                res.append(i)\n        return res\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(L * N)\n- 空间复杂度：O(M * N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462217016","body":"# 1590. 使数组和能被 P 整除\n\n## 思路\n\n参考官方 `前缀法`\n\n## 代码\n\n``` c++ \nclass Solution {\npublic:\n    int minSubarray(vector<int>& nums, int p) {\n        int x = 0;\n        for (auto num : nums) {\n            x = (x + num) % p;\n        }\n        if (x == 0) {\n            return 0;\n        }\n        unordered_map<int, int> index;\n        int y = 0, res = nums.size();\n        for (int i = 0; i < nums.size(); i++) {\n            index[y] = i; // f[i] mod p = y，因此哈希表记录 y 对应的下标为 i\n            y = (y + nums[i]) % p;\n            if (index.count((y - x + p) % p) > 0) {\n                res = min(res, i - index[(y - x + p) % p] + 1);\n            }\n        }\n        return res == nums.size() ? -1 : res;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463965164","body":"# 876. 链表的中间结点\n\n## 思路\n\n经典快慢双指针\n\n## 代码\n\n``` python \n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        if head is None:\n            return None\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464923454","body":"# 26. 删除排序数组中的排序项\n\n## 思路\n\n双指针，一个用来保存遍历进度，一个用来保存删除重复元素数组后的长度。\n\n## 代码\n\n``` C++ \nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0) return 0;\n        int j = 0;\n        for(int i = 0; i < n; i++){\n            if(nums[j] != nums[i]){\n                nums[++j] = nums[i];\n            }\n        }\n        return j + 1;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465219876","body":"# 35. 搜搜插入位置\n\n## 思路\n\n二分法\n\n## 代码\n\n``` C++ \nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int n = nums.size();\n        int left = 0, right = n - 1, ans = n;\n        while (left <= right) {\n            int mid = ((right - left) >> 1) + left;\n            if (target <= nums[mid]) {\n                ans = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466192694","body":"# 239. 滑动窗口最大值\n\n## 思路\n\n优先队列\n\n## 代码\n\n``` C++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size();\n        deque<int> q;\n        for (int i = 0; i < k; ++i) {\n            while (!q.empty() && nums[i] >= nums[q.back()]) {\n                q.pop_back();\n            }\n            q.push_back(i);\n        }\n\n        vector<int> ans = {nums[q.front()]};\n        for (int i = k; i < n; ++i) {\n            while (!q.empty() && nums[i] >= nums[q.back()]) {\n                q.pop_back();\n            }\n            q.push_back(i);\n            while (q.front() <= i - k) {\n                q.pop_front();\n            }\n            ans.push_back(nums[q.front()]);\n        }\n        return ans;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468227918","body":"# 997. 找到小镇的法官\n\n## 思路\n\n利用图的出入度，只有法官是入度 `n-1` 出度 `0`\n\n## 代码\n\n``` c++\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        vector<int> inDegrees(n + 1);\n        vector<int> outDegrees(n + 1);\n        for (auto& edge : trust) {\n            int x = edge[0], y = edge[1];\n            ++inDegrees[y];\n            ++outDegrees[x];\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(m+n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1470207273","body":"# 886. 可能的二分法\n\n## 思路\n\n广度优先搜索\n\n## 代码\n\n``` C++ \nclass Solution {\npublic:\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<int> color(n + 1, 0);\n        vector<vector<int>> g(n + 1);\n        for (auto& p : dislikes) {\n            g[p[0]].push_back(p[1]);\n            g[p[1]].push_back(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (color[i] == 0) {\n                queue<int> q;\n                q.push(i);\n                color[i] = 1;\n                while (!q.empty()) {\n                    auto t = q.front();\n                    q.pop();\n                    for (auto& next : g[t]) {\n                        if (color[next] > 0 && color[next] == color[t]) {\n                            return false;\n                        }\n                        if (color[next] == 0) {\n                            color[next] = 3 ^ color[t];\n                            q.push(next);\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(n+m)\n- 空间复杂度：O(n+m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1471969860","body":"# 1203. 项目管理\n\n## 思路\n\n官方拓扑排序\n\n## 代码\n\n```C++\nclass Solution {\npublic:\n    vector<int> topSort(vector<int>& deg, vector<vector<int>>& graph, vector<int>& items) {\n        queue<int> Q;\n        for (auto& item: items) {\n            if (deg[item] == 0) {\n                Q.push(item);\n            }\n        }\n        vector<int> res;\n        while (!Q.empty()) {\n            int u = Q.front(); \n            Q.pop();\n            res.emplace_back(u);\n            for (auto& v: graph[u]) {\n                if (--deg[v] == 0) {\n                    Q.push(v);\n                }\n            }\n        }\n        return res.size() == items.size() ? res : vector<int>{};\n    }\n\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        vector<vector<int>> groupItem(n + m);\n\n        // 组间和组内依赖图\n        vector<vector<int>> groupGraph(n + m);\n        vector<vector<int>> itemGraph(n);\n\n        // 组间和组内入度数组\n        vector<int> groupDegree(n + m, 0);\n        vector<int> itemDegree(n, 0);\n        \n        vector<int> id;\n        for (int i = 0; i < n + m; ++i) {\n            id.emplace_back(i);\n        }\n\n        int leftId = m;\n        // 给未分配的 item 分配一个 groupId\n        for (int i = 0; i < n; ++i) {\n            if (group[i] == -1) {\n                group[i] = leftId;\n                leftId += 1;\n            }\n            groupItem[group[i]].emplace_back(i);\n        }\n        // 依赖关系建图\n        for (int i = 0; i < n; ++i) {\n            int curGroupId = group[i];\n            for (auto& item: beforeItems[i]) {\n                int beforeGroupId = group[item];\n                if (beforeGroupId == curGroupId) {\n                    itemDegree[i] += 1;\n                    itemGraph[item].emplace_back(i);   \n                } else {\n                    groupDegree[curGroupId] += 1;\n                    groupGraph[beforeGroupId].emplace_back(curGroupId);\n                }\n            }\n        }\n\n        // 组间拓扑关系排序\n        vector<int> groupTopSort = topSort(groupDegree, groupGraph, id); \n        if (groupTopSort.size() == 0) {\n            return vector<int>{};\n        } \n        vector<int> ans;\n        // 组内拓扑关系排序\n        for (auto& curGroupId: groupTopSort) {\n            int size = groupItem[curGroupId].size();\n            if (size == 0) {\n                continue;\n            }\n            vector<int> res = topSort(itemDegree, itemGraph, groupItem[curGroupId]);\n            if (res.size() == 0) {\n                return vector<int>{};\n            }\n            for (auto& item: res) {\n                ans.emplace_back(item);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(m+n)\n- 空间复杂度：O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473919184","body":"# 657.机器人能否回到原点\n\n## 思路\n\n位图\n\n## 代码\n\n``` python\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        position = 0+0j\n        move_map = {\n            'L': -1,\n            'R': 1,\n            'U': 1j,\n            'D': -1j\n        }\n\n        for m in moves:\n            position += move_map[m]\n        \n        return not position\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474878149","body":"# 1834. 单线程CPU\n\n## 思路\n\n优先序列\n\n## 代码\n\n```C++\nclass Solution {\nprivate:\n    using PII = pair<int, int>;\n    using LL = long long;\n\npublic:\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        int n = tasks.size();\n        vector<int> indices(n);\n        iota(indices.begin(), indices.end(), 0);\n        sort(indices.begin(), indices.end(), [&](int i, int j) {\n            return tasks[i][0] < tasks[j][0];\n        });\n\n        vector<int> ans;\n        // 优先队列\n        priority_queue<PII, vector<PII>, greater<PII>> q;\n        // 时间戳\n        LL timestamp = 0;\n        // 数组上遍历的指针\n        int ptr = 0;\n        \n        for (int i = 0; i < n; ++i) {\n            // 如果没有可以执行的任务，直接快进\n            if (q.empty()) {\n                timestamp = max(timestamp, (LL)tasks[indices[ptr]][0]);\n            }\n            // 将所有小于等于时间戳的任务放入优先队列\n            while (ptr < n && tasks[indices[ptr]][0] <= timestamp) {\n                q.emplace(tasks[indices[ptr]][1], indices[ptr]);\n                ++ptr;\n            }\n            // 选择处理时间最小的任务\n            auto&& [process, index] = q.top();\n            timestamp += process;\n            ans.push_back(index);\n            q.pop();\n        }\n        \n        return ans;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475270733","body":"# 1904. 你完成的完整对局数\n\n## 思路\n\n转化为分钟\n\n## 代码\n\n```C++\nclass Solution {\npublic:\n    int numberOfRounds(string startTime, string finishTime) {\n        // 转化为分钟\n        int t0 = 60 * stoi(startTime.substr(0, 2)) + stoi(startTime.substr(3, 5));\n        int t1 = 60 * stoi(finishTime.substr(0, 2)) + stoi(finishTime.substr(3, 5));\n        if (t1 < t0){\n            // 此时 finishTime 为第二天\n            t1 += 1440;\n        }\n        // 第一个小于等于 finishTime 的完整对局的结束时间\n        t1 = t1 / 15 * 15;\n        return max(0, (t1 - t0)) / 15;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476373462","body":"# 1737. 满足三条件之一需改变的最少字符数\n\n## 思路\n\n枚举前缀和\n\n## 代码\n\n```C++\nclass Solution {\npublic:\n    int minCharacters(string a, string b) {\n        vector<int> acnt(26, 0);\n        vector<int> bcnt(26, 0);\n        int an = a.size(), bn = b.size();\n        \n        for (char c : a) acnt[c-'a']++;\n        for (char c : b) bcnt[c-'a']++;\n        \n        int ans = INT_MAX, asum = 0, bsum = 0;\n        for (int i = 0; i < 25; i++) {\n            asum += acnt[i];\n            bsum += bcnt[i];\n            ans = min(min(ans, an-acnt[i]+bn-bcnt[i]), min(an-asum+bsum, bn-bsum+asum));\n        }\n        ans = min(ans, an-acnt[25]+bn-bcnt[25]);\n        \n        return ans;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477860820","body":"# 912. 排序数组\n\n## 思路\n\n归并排序\n\n## 代码\n\n``` C++\nclass Solution {\n    vector<int> tmp;\n    void mergeSort(vector<int>& nums, int l, int r) {\n        if (l >= r) return;\n        int mid = (l + r) >> 1;\n        mergeSort(nums, l, mid);\n        mergeSort(nums, mid + 1, r);\n        int i = l, j = mid + 1;\n        int cnt = 0;\n        while (i <= mid && j <= r) {\n            if (nums[i] <= nums[j]) {\n                tmp[cnt++] = nums[i++];\n            }\n            else {\n                tmp[cnt++] = nums[j++];\n            }\n        }\n        while (i <= mid) {\n            tmp[cnt++] = nums[i++];\n        }\n        while (j <= r) {\n            tmp[cnt++] = nums[j++];\n        }\n        for (int i = 0; i < r - l + 1; ++i) {\n            nums[i + l] = tmp[i];\n        }\n    }\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        tmp.resize((int)nums.size(), 0);\n        mergeSort(nums, 0, (int)nums.size() - 1);\n        return nums;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479747734","body":"# 69. x 的平方根\n\n## 思路\n\n数学公式法\n\n## 代码\n\n```C++\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x == 0) {\n            return 0;\n        }\n        int ans = exp(0.5 * log(x));\n        return ((long long)(ans + 1) * (ans + 1) <= x ? ans + 1 : ans);\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1481433098","body":"# 178. 第一个错误的版本\n\n## 思路\n\n二分法\n\n## 代码\n\n```python \n# The isBadVersion API is already defined for you.\n# @param version, an integer\n# @return an integer\n# def isBadVersion(version):\n\nclass Solution:\n    def firstBadVersion(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        start = 1\n        end = n\n        mid = 0\n        while start < end:\n            mid = start + ((end - start) >> 1)\n            if isBadVersion(mid):\n                end = mid\n            else:\n                start = mid + 1;      \n        return start\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(logn)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482925145","body":"# 493. 翻转对\n\n## 思路\n\n模拟归并排序，分而治之\n\n## 代码 \n\n``` C++\nclass Solution {\npublic:\n    int find_reversed_pairs(vector<int>& nums,int& left,int& right){\n        int res = 0,mid = left + (right-left)/2;\n        int i = left,j = mid+1;\n        for(;i <= mid;i++){\n            while(j <= right && (long)nums[i] > 2*(long)nums[j]) {\n                res += mid - i + 1;\n                j++;\n            }\n        }\n        return res;\n    }\n    \n    int merge_sort(vector<int>& nums,int nums_sorted[],int left,int right){\n        if(left >= right) return 0;\n        int mid = left + (right-left) / 2;\n        \n        int res = merge_sort(nums,nums_sorted,left,mid) + \n                  merge_sort(nums,nums_sorted,mid+1,right) + \n                  find_reversed_pairs(nums,left,right);\n        \n        int i = left,j = mid+1,ind = left;\n        \n        while(i <= mid && j <= right){\n            if(nums[i] <= nums[j]) nums_sorted[ind++] = nums[i++];\n            else nums_sorted[ind++] = nums[j++];\n        }\n        while(i <= mid) nums_sorted[ind++] = nums[i++];\n        while(j <= right) nums_sorted[ind++] = nums[j++];\n        \n        for(int ind = left;ind <= right;ind++) nums[ind] = nums_sorted[ind];\n    \n        return res;\n    }\n    \n    int reversePairs(vector<int>& nums) {\n        if(nums.empty()) return 0;\n        int nums_sorted[nums.size()];\n        memset(nums_sorted,0,sizeof(nums_sorted));\n        return merge_sort(nums,nums_sorted,0,nums.size()-1);\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483856866","body":"# 475. 供暖器\r\n\r\n## 思路 \r\n\r\n二分法\r\n\r\n## 代码\r\n\r\n``` C++\r\nclass Solution {\r\n    // 找到房子左边最近的供暖器下标left\r\n    // 转化为：有序数组中找到最后一个小于等于target的元素 二分\r\n    // 则右边最近的供暖器就是left+1\r\n    int helper(vector<int>& heaters, int target){\r\n        // 处理边界\r\n        if(target > *(heaters.end()-1)){\r\n            return heaters.size()-1;\r\n        }\r\n        if(target < *(heaters.begin())){\r\n            return -1;\r\n        }\r\n        int left=0, right=heaters.size()-1;\r\n        while(left<right){\r\n            int mid=left+(right-left+1)/2;\r\n            if(heaters[mid]>target){\r\n                right=mid-1;\r\n            }else{\r\n                left=mid;\r\n            }\r\n        }\r\n        return right;\r\n    }\r\npublic:\r\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\r\n        // 排序\r\n        sort(heaters.begin(), heaters.end());\r\n        int ans=0;\r\n        for(auto& h: houses){\r\n            int left=helper(heaters, h);\r\n            int leftDistance=left==-1?INT_MAX:h-heaters[left];      // 根据是否在边界进行距离判断\r\n            int right=left+1;\r\n            int rightDistance=right==heaters.size()?INT_MAX:heaters[right]-h;       // 根据是否在边界进行距离判断\r\n            ans=max(ans, min(leftDistance, rightDistance));\r\n        }\r\n        return ans;\r\n\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：O(NlogM)\r\n- 空间复杂度：O(NlogN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1484130634","body":"## 思路\r\n\r\n双指针配合二分法\r\n\r\n## 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\r\n        nums.sort()\r\n        l, R = 0, nums[-1]-nums[0]\r\n\r\n        def counts(diff):\r\n            cnt = 0\r\n            j = 0\r\n            for i in range(1, len(nums)):\r\n                while nums[i] - nums[j] > diff:\r\n                    j += 1  \r\n                cnt += i - j\r\n                if cnt >= k:\r\n                    return True\r\n\r\n            return False\r\n\r\n        while l <= R:\r\n            mid = (l + R)//2\r\n            if counts(mid):\r\n                R = mid - 1\r\n            else:\r\n                l = mid + 1\r\n\r\n        return l\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1485389364","body":"# 778. 水位上升的泳池中游泳\n\n## 思路\n\n官方二分法\n\n## 代码\n\n``` C++\nclass Solution {\npublic:\n    bool check(vector<vector<int>>& grid, int threshold) {\n        if (grid[0][0] > threshold) {\n            return false;\n        }\n        int n = grid.size();\n        vector<vector<int>> visited(n, vector<int>(n, 0));\n        visited[0][0] = 1;\n        queue<pair<int, int>> q;\n        q.push(make_pair(0, 0));\n\n        vector<pair<int, int>> directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        while (!q.empty()) {\n            auto [i, j] = q.front();\n            q.pop();\n\n            for (const auto [di, dj]: directions) {\n                int ni = i + di, nj = j + dj;\n                if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                    if (visited[ni][nj] == 0 && grid[ni][nj] <= threshold) {\n                        q.push(make_pair(ni, nj));\n                        visited[ni][nj] = 1;\n                    }\n                }\n            }\n        }\n        return visited[n - 1][n - 1] == 1;\n    }\n\n    int swimInWater(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int left = 0, right = n * n - 1;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (check(grid, mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        } \n        return left;\n    }\n};\n```\n\n## 复杂度分析：\n\n- 时间复杂度：O(n^2logn)\n- 空间复杂度：O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1487014470","body":"# 1456. 定长字串中元音的最大数目\n\n## 思路\n\n滑动窗口\n\n## 代码\n\n``` C++\nclass Solution {\npublic:\n    // 判断是否为元音\n    bool isVowel(char ch) {\n        return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u'; \n    }\n    \n    int maxVowels(string s, int k) {\n        int n = s.size();\n        int vowel_count = 0;\n        \n        // 计算前第一个窗口的元音数量\n        for (int i = 0; i < k; ++i) {\n            vowel_count += isVowel(s[i]);\n        }\n\n        int ans = vowel_count;\n        \n        // 滑动窗口\n        for (int i = k; i < n; ++i) {\n            vowel_count += isVowel(s[i]) - isVowel(s[i - k]);\n            ans = max(ans, vowel_count);\n        }\n        return ans;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488793355","body":"# 837. 新21点\r\n\r\n## 思路\r\n\r\n滑动窗口、动态规划\r\n\r\n## 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\r\n        if k == 0:\r\n            return 1.0\r\n        dp = [0.0] * (k + maxPts)\r\n        for i in range(k, min(n, k + maxPts - 1) + 1):\r\n            dp[i] = 1.0\r\n        dp[k - 1] = float(min(n - k + 1, maxPts)) / maxPts\r\n        for i in range(k - 2, -1, -1):\r\n            dp[i] = dp[i + 1] - (dp[i + maxPts + 1] - dp[i + 1]) / maxPts\r\n        return dp[0]\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：O(min(n, MaxPts))\r\n- 空间复杂度：O(min(k, MaxPts))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1490478799","body":"# 438.找到字符串中所有字母异位词\n\n## 思路\n\n滑动窗口\n\n## 代码\n\n``` python\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        n, m, res = len(s), len(p), []\n        if n < m: return res\n        p_cnt = [0] * 26\n        s_cnt = [0] * 26\n\n        for i in range(m):\n            p_cnt[ord(p[i]) - ord('a')] += 1\n        \n        left = 0\n        for right in range(n):\n            cur_right = ord(s[right]) - ord('a')\n            s_cnt[cur_right] += 1\n            while s_cnt[cur_right] > p_cnt[cur_right]:\n                cur_left = ord(s[left]) - ord('a')\n                s_cnt[cur_left] -= 1\n                left += 1\n            if right - left + 1 == m:\n                res.append(left)\n        return res\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(m+n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1492076479","body":"# 76. 最小覆盖字串\n\n## 思路\n\n参考官方滑动窗口法\n\n## 代码\n\n``` C++\nclass Solution {\npublic:\n    unordered_map <char, int> ori, cnt;\n\n    bool check() {\n        for (const auto &p: ori) {\n            if (cnt[p.first] < p.second) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    string minWindow(string s, string t) {\n        for (const auto &c: t) {\n            ++ori[c];\n        }\n\n        int l = 0, r = -1;\n        int len = INT_MAX, ansL = -1, ansR = -1;\n\n        while (r < int(s.size())) {\n            if (ori.find(s[++r]) != ori.end()) {\n                ++cnt[s[r]];\n            }\n            while (check() && l <= r) {\n                if (r - l + 1 < len) {\n                    len = r - l + 1;\n                    ansL = l;\n                }\n                if (ori.find(s[l]) != ori.end()) {\n                    --cnt[s[l]];\n                }\n                ++l;\n            }\n        }\n\n        return ansL == -1 ? string() : s.substr(ansL, len);\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(C⋅∣s∣+∣t∣)\n- 空间复杂度：O(C)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1492984286","body":"# Number of Operation to Decrement Target to Zero\n\n## 思路\n\n1、蠢方法：动态规划\n2、好方法：滑动窗口\n\n## 代码\n\n``` C++ \nint solve(vector<int>& nums, int target) {\n    int N = nums.size();\n    int newTarget = accumulate(nums.begin(), nums.end(), 0) - target;\n    if (newTarget == 0) return N;\n    int curSum = 0;\n    int maxLen = 0;\n    int left = 0; \n    for (int i = 0; i < N; i++)\n    {\n        curSum += nums[i];\n        while (curSum >= newTarget && i >= left)\n        {\n            if (curSum == newTarget) \n                maxLen = max(maxLen, i - left + 1);\n\n            curSum -= nums[left]; \n            left++;\n        }\n    }\n    return maxLen == 0 ? -1 : N - maxLen;\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493299168","body":"# 401. 二进制手表\n\n## 思路\n\n暴力搜索\n\n## 代码\n\n``` python\nclass Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        ans = list()\n        for h in range(12):\n            for m in range(60):\n                if bin(h).count(\"1\") + bin(m).count(\"1\") == turnedOn:\n                    ans.append(f\"{h}:{m:02d}\")\n        return ans\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(1) 60 * 24\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494548547","body":"```python \n# queen\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        cols = set()\n        dia1 = set()\n        dia2 = set()\n\n        def backtrack(row):\n            if row == n:\n                return 1\n            \n            count = 0\n            for i in range(n):\n                if i in cols or row - i in dia1 or row + i in dia2:\n                    continue\n                cols.add(i)\n                dia1.add(row - i)\n                dia2.add(row + i)\n                count += backtrack(row + 1)\n\n                cols.remove(i)\n                dia1.remove(row - i)\n                dia2.remove(row + i)\n            return count\n        \n        return backtrack(0)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1496221413","body":"# 695. 岛屿的最大面积\n\n## 思路 \n\nDFS\n\n## 代码\n\n``` python\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        if m == 0: return 0\n        n = len(grid[0])\n        ans = 0\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n: return 0\n            if grid[i][j] == 0: return 0\n            grid[i][j] = 0\n            top = dfs(i + 1, j)\n            bottom = dfs(i - 1, j)\n            left = dfs(i, j - 1)\n            right = dfs(i, j + 1)\n            return 1 + sum([top, bottom, left, right])\n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, dfs(i, j))\n        return ans\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497399228","body":"# 1162. 地图分析\n\n## 思路\n\n深度优先遍历\n\n## 代码\n\n``` python\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        ans = -1\n        n = len(grid)\n        queue = collections.deque()\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    queue.append((i,j))\n        \n        if  len(queue) == n**2:\n            return -1\n\n        while queue:\n            ans += 1\n            queue_copy = queue.copy()\n            queue = collections.deque()\n            for x,y in queue_copy:\n                if x + 1 < n and not grid[x + 1][y]:\n                    grid[x+1][y] = grid[x][y] + 1\n                    queue.append((x+1,y))\n                if y + 1 < n and not grid[x ][y + 1]:\n                    grid[x][y + 1] = grid[x][y] + 1\n                    queue.append((x,y+1))\n                if x - 1 >= 0 and not grid[x - 1][y]:\n                    grid[x-1][y] = grid[x][y] + 1\n                    queue.append((x-1,y))\n                if y - 1 >=0 and not grid[x ][y - 1]:\n                    grid[x][y - 1] = grid[x][y] + 1\n                    queue.append((x,y - 1))\n        return  ans\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N^2)\n- 空间复杂度：O(N^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1499090244","body":"# 1298. 你能从盒子里拿到的最大糖果数\n\n## 思路\n\n``` C++\nclass Solution {\npublic:\n    int maxCandies(vector<int> &status, vector<int> &candies, vector<vector<int>> &keys,\n                   vector<vector<int>> &containedBoxes, vector<int> &initialBoxes) {\n        int ans = 0;\n        queue<tuple<int, int, int, vector<int>, vector<int>>> queue;\n        set<int> unlock;\n        map<int, tuple<int, int, int, vector<int>, vector<int>>> map;\n\n        for (int v: initialBoxes) {\n            auto t = make_tuple(v, status[v], candies[v], keys[v], containedBoxes[v]);\n            queue.push(t);\n        }\n\n        while (!queue.empty()) {\n            int size = queue.size();\n            while (size-- > 0) {\n                auto [id, statue, candy, key, box] = queue.front();\n                queue.pop();\n\n                if (!statue && !unlock.count(id)) {\n                    map[id] = make_tuple(id, statue, candy, key, box);\n                } else {\n                    ans += candy;\n                    for (int k: key) {\n                        unlock.insert(k);\n                        if (map.count(k)) {\n                            queue.push(map[k]);\n                            map.erase(k);\n                        }\n                    }\n                    for (int v: box) {\n                        auto t = make_tuple(v, status[v], candies[v], keys[v], containedBoxes[v]);\n                        queue.push(t);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N\n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1500270211","body":"# To-View-of-a-Tree\n\n## 代码\n\n``` python\nclass Solution:\n    def solve(self, root):\n        q = collections.deque([(root, 0)])\n        d = {}\n        while q:\n            cur, pos = q.popleft()\n            if pos not in d:\n                d[pos] = cur.val\n            if cur.left:\n                q.append((cur.left, pos - 1))\n            if cur.right:\n                q.append((cur.right, pos + 1))\n        return list(map(lambda x:x[1], sorted(d.items(), key=lambda x: x[0])))\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500914444","body":"# 746. 使用最小花费爬楼梯\n\n## 代码\n\n``` python \nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        n = len(cost)\n        minCost = [0] * n\n        minCost[1] = min(cost[0], cost[1])\n        for i in range(2, n):\n            minCost[i] = min(minCost[i - 1] + cost[i], minCost[i - 2] + cost[i - 1])\n        return minCost[-1]\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501124953","body":"# 198. 打家劫舍\n\n## 思路\n\n动态规划，`max(curr, prev + i)`\n\n## 代码\n\n```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        prev = 0\n        curr = 0\n        for i in nums:\n            prev, curr = curr, max(curr, prev + i)\n        return curr\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501880731","body":"# 673. 最长递增子序列的个数\n\n## 思路\n\n动态规划\n\n## 代码\n\n``` python\nclass Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n, max_len, ans = len(nums), 0, 0\n        dp = [0] * n\n        cnt = [0] * n\n        for i, x in enumerate(nums):\n            dp[i] = 1\n            cnt[i] = 1\n            for j in range(i):\n                if x > nums[j]:\n                    if dp[j] + 1 > dp[i]:\n                        dp[i] = dp[j] + 1\n                        cnt[i] = cnt[j]  \n                    elif dp[j] + 1 == dp[i]:\n                        cnt[i] += cnt[j]\n            if dp[i] > max_len:\n                max_len = dp[i]\n                ans = cnt[i]  \n            elif dp[i] == max_len:\n                ans += cnt[i]\n        return ans\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N^2)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1503368196","body":"# 1143. 最长公共子序列\n\n## 思路\n\n动态规划、二维数组\n\n## 代码\n\n``` python\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        m, n = len(text1), len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        \n        return dp[m][n]\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(M*N)\n- 空间复杂度：O(M*N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1505176118","body":"# 62. 不同的路径\n\n## 思路\n\n数学方法，排列组合\n\n## 代码\n\n``` python\nfrom math import factorial as f\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        return f(m + n - 2) // f(m - 1) // f(n - 1)\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(m-n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1507104709","body":"# 688. “马”在棋盘上的概率\n\n## 思路\n\n马尔科夫链，动态规划\n\n## 代码\n\n```C++\nclass Solution:\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n        dp = [[[0] * n for _ in range(n)] for _ in range(k + 1)]\n        for step in range(k + 1):\n            for i in range(n):\n                for j in range(n):\n                    if step == 0:\n                        dp[step][i][j] = 1\n                    else:\n                        for di, dj in ((-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2)):\n                            ni, nj = i + di, j + dj\n                            if 0 <= ni < n and 0 <= nj < n:\n                                dp[step][i][j] += dp[step - 1][ni][nj] / 8\n        return dp[k][row][column]\n\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(k * n^2)\n- 空间复杂度：O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1508840055","body":"# 464. 我能赢么\n\n## 思路\n\n动态规划\n\n## 代码\n\n``` python\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        if maxChoosableInteger >= desiredTotal: return True\n        if (1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal: return False\n\n        def dfs(state, desiredTotal, dp):\n            if dp[state] != None:\n                return dp[state]\n            for i in range(1, maxChoosableInteger + 1):\n                cur = 1 << (i - 1)\n                if cur & state != 0:\n                    continue\n                \n                if i >= desiredTotal or not dfs(cur | state, desiredTotal - i, dp):\n                    dp[state] = True\n                    return True\n            dp[state] = False\n            return False\n        \n        return dfs(0, desiredTotal, [None] * (1 << maxChoosableInteger))\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(m*2^m)\n- 空间复杂度：O(2^m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509875623","body":"# 416. 分割等和子集\n\n## 思路\n\n0-1背包问题\n\n## 代码\n\n``` python\nclass Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        n = len(nums)\n        if n < 2:\n            return False\n        \n        total = sum(nums)\n        if total % 2 != 0:\n            return False\n        \n        target = total // 2\n        dp = [True] + [False] * target\n        for i, num in enumerate(nums):\n            for j in range(target, num - 1, -1):\n                dp[j] |= dp[j - num]\n        \n        return dp[target]\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(mn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510402495","body":"# 494.  目标和\n\n## 思路\n\n动态规划，背包问题\n\n## 代码\n\n```C++\nclass Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int& num : nums) {\n            sum += num;\n        }\n        int diff = sum - target;\n        if (diff < 0 || diff % 2 != 0) {\n            return 0;\n        }\n        int neg = diff / 2;\n        vector<int> dp(neg + 1);\n        dp[0] = 1;\n        for (int& num : nums) {\n            for (int j = neg; j >= num; j--) {\n                dp[j] += dp[j - num];\n            }\n        }\n        return dp[neg];\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(m*(sum-target))\n- 空间复杂度：O(sum-target)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511421370","body":"# 322. 零钱兑换\n\n## 思路\n\n动态规划，完全背包\n\n## 代码\n\n``` python \nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n        \n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] = min(dp[x], dp[x - coin] + 1)\n        return dp[amount] if dp[amount] != float('inf') else -1 \n```\n\n## 复杂度分析\n\n- 时间复杂度：O(target * n)\n- 空间复杂度：O(target)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1513256999","body":"# 518. 零钱兑换\n\n## 代码\n\n ``` python\nclass Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n\n        for j in range(len(coins)):\n            for i in range(1, amount + 1):\n                if i >= coins[j]:\n                    dp[i] += dp[i - coins[j]]\n\n        return dp[-1]\n```\n## 复杂度分析\n\n- 时间复杂度: O(coins * amount)\n\n- 空间复杂度: O(amount)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514717694","body":"# 455. 分发饼干\n\n## 思路\n\n排序、双指针\n\n## 代码\n\n``` C++ \nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        int m = g.size(), n = s.size();\n        int count = 0;\n        for (int i = 0, j = 0; i < m && j < n; i++, j++) {\n            while (j < n && g[i] > s[j]) {\n                j++;\n            }\n            if (j < n) {\n                count++;\n            }\n        }\n        return count;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(nlogn + nlogm)\n- 空间复杂度：O(logn + logm)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516370836","body":"# 435. 无重叠区间\n\n## 思路\n\n贪心算法\n\n## 代码\n\n```C++ \nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        if (intervals.empty()) {\n            return 0;\n        }\n        \n        sort(intervals.begin(), intervals.end(), [](const auto& u, const auto& v) {\n            return u[1] < v[1];\n        });\n\n        int n = intervals.size();\n        int right = intervals[0][1];\n        int ans = 1;\n        for (int i = 1; i < n; ++i) {\n            if (intervals[i][0] >= right) {\n                ++ans;\n                right = intervals[i][1];\n            }\n        }\n        return n - ans;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517964616","body":"# 55. 跳跃游戏\n\n## 代码\n\n```Python\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int n = nums.size();\n        int rightmost = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i <= rightmost) {\n                rightmost = max(rightmost, i + nums[i]);\n                if (rightmost >= n - 1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518656467","body":"# 96. 不同的二叉搜索树\n\n## 思路\n\n数学方法\n\n## 代码\n\n```Python\nclass Solution {\npublic:\n    int numTrees(int n) {\n        long long C = 1;\n        for (int i = 0; i < n; ++i) {\n            C = C * 2 * (2 * i + 1) / (i + 2);\n        }\n        return (int)C;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519070412","body":"# 23. 合并K个排序链表\n\n## 思路\n\n顺序合并\n\n## 代码\n\n``` C++\nListNode* mergeTwoLists(ListNode *a, ListNode *b) {\n    if ((!a) || (!b)) return a ? a : b;\n    ListNode head, *tail = &head, *aPtr = a, *bPtr = b;\n    while (aPtr && bPtr) {\n        if (aPtr->val < bPtr->val) {\n            tail->next = aPtr; aPtr = aPtr->next;\n        } else {\n            tail->next = bPtr; bPtr = bPtr->next;\n        }\n        tail = tail->next;\n    }\n    tail->next = (aPtr ? aPtr : bPtr);\n    return head.next;\n}\n···\n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1520273469","body":"# 932. 漂亮数组\n\n## 思路\n\n哈希表\n\n## 代码\n\n``` C++\nclass Solution {\npublic:\n    unordered_map<int,vector<int>> mp;\n    vector<int> beautifulArray(int n) {\n        vector<int> ans;\n        if(n==1){\n            ans.push_back(1);\n            return ans;\n        }\n        if(mp.count(n)){\n            return mp[n];\n        }\n        int odd_num=(n+1)/2;\n        int even_num=n/2;\n        vector<int> left_arry=beautifulArray(odd_num);\n        vector<int> right_arry=beautifulArray(even_num);\n        //将左侧数组映射为奇数\n        for(auto &val:left_arry){\n            ans.push_back(val*2-1);\n        }\n        //将右侧数组映射为偶数\n        for(auto &val:right_arry){\n            ans.push_back(val*2);\n        }\n        mp[n]=ans;\n        return ans;\n    }\n   \n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1522012199","body":"# 260. 只出现一次的数字 Ⅲ\n\n## 思路\n\n哈希表\n\n## 代码\n\n``` Python\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        freq = Counter(nums)\n        return [num for num, occ in freq.items() if occ == 1]\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1523654067","body":"# 78. 子集\n\n## 思路\n\npython 库函数\n\n## 代码\n\n```python\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        for i in range(len(nums)+1):\n            for tmp in itertools.combinations(nums, i):\n                res.append(tmp)\n        return res\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(n*2^n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1525880721","body":"# 实现前缀树\n\n## 思路\n\n前缀树，套路\n\n## 代码\n\n``` C++\nclass Trie {\nprivate:\n    vector<Trie*> children;\n    bool isEnd;\n\n    Trie* searchPrefix(string prefix) {\n        Trie* node = this;\n        for (char ch : prefix) {\n            ch -= 'a';\n            if (node->children[ch] == nullptr) {\n                return nullptr;\n            }\n            node = node->children[ch];\n        }\n        return node;\n    }\n\npublic:\n    Trie() : children(26), isEnd(false) {}\n\n    void insert(string word) {\n        Trie* node = this;\n        for (char ch : word) {\n            ch -= 'a';\n            if (node->children[ch] == nullptr) {\n                node->children[ch] = new Trie();\n            }\n            node = node->children[ch];\n        }\n        node->isEnd = true;\n    }\n\n    bool search(string word) {\n        Trie* node = this->searchPrefix(word);\n        return node != nullptr && node->isEnd;\n    }\n\n    bool startsWith(string prefix) {\n        return this->searchPrefix(prefix) != nullptr;\n    }\n};\n``` \n## 复杂度分析\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(26)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1527618459","body":"# 677. 简直映射\n\n## 思路\n\n哈希表\n\n## 代码\n\n```Python\nclass MapSum:\n    def __init__(self):\n        self.map = {}\n\n    def insert(self, key: str, val: int) -> None:\n        self.map[key] = val\n\n    def sum(self, prefix: str) -> int:\n        res = 0\n        for key,val in self.map.items():\n            if key.startswith(prefix):\n                res += val\n        return res\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528784223","body":"# 17. 多次搜索\n\n## 思路\n\n前缀哈希\n\n## 代码\n\n``` C++\nclass Solution {\npublic:\n    vector<vector<int>> multiSearch(string big, vector<string>& smalls) {\n        //给定一个字符串数组，查找这些字符串在原串上出现的位置\n        unordered_map<string,vector<int>>map;\n        int n=big.size();\n        for(int i=0;i<n;i++){\n            string t=big.substr(i);\n            for(int j=1;j<=t.size();j++){\n                //substr函数是左开右闭，所以一直循环到=t.size()\n\n                //说明t.substr(0,j)出现在以big[i]开头的字符串的前缀上\n                map[t.substr(0,j)].emplace_back(i);\n            }\n        }\n        vector<vector<int>> res;\n\n        for(string word:smalls){\n            res.emplace_back(map[word]);\n        }\n\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1529029675","body":"# 547. 省份数量\n\n## 思路\n\n深度优先\n\n## 代码\n\n``` C++\nclass Solution {\npublic:\n    void dfs(vector<vector<int>>& isConnected, vector<int>& visited, int cities, int i) {\n        for (int j = 0; j < cities; j++) {\n            if (isConnected[i][j] == 1 && !visited[j]) {\n                visited[j] = 1;\n                dfs(isConnected, visited, cities, j);\n            }\n        }\n    }\n\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        int cities = isConnected.size();\n        vector<int> visited(cities);\n        int provinces = 0;\n        for (int i = 0; i < cities; i++) {\n            if (!visited[i]) {\n                dfs(isConnected, visited, cities, i);\n                provinces++;\n            }\n        }\n        return provinces;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1529769833","body":"# 924. 尽量减少恶意软件的传播\n\n## 思路\n\n图解\n\n## 代码 \n\n``` python\nclass Solution:\n    def minMalwareSpread(self, graph: list[list[int]], initial: list[int]) -> int:\n        n = len(graph)\n        p = list(range(n))\n        s = [1] * n\n        m = [0] * n\n        o = [0] * n\n\n        def find(index: int) -> int:\n            if p[index] != index:\n                p[index] = find(p[index])\n            return p[index]\n\n        for i, row in enumerate(graph):\n            for j, val in enumerate(row):\n                if val:\n                    pi, pj = find(i), find(j)\n                    if pi == pj:\n                        continue\n                    p[pi] = pj\n                    s[pj] += s[pi]\n\n        mi = 300\n        for v in initial:\n            pv = find(v)\n            m[pv] += 1\n            o[pv] = v\n            mi = min(mi, v)\n\n        ans = -1\n        size = 0\n        for i, v in enumerate(m):\n            if v == 1:\n                if s[i] > size:\n                    ans = o[i]\n                    size = s[i]\n                elif s[i] == size and o[i] < ans:\n                    ans = o[i]\n\n        if ans == -1:\n            return mi\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1531694311","body":"#1319. 联通网络的操作次数\n\n## 思路\n\n查并集 \n\n## 代码\n\n``` python\nclass Solution {\n    vector<int> ps; // 保存并查集的每个i的根\n    //并查集的查操作\n    int find(int x) {\n        if (x != ps[x]) ps[x] = find(ps[x]); //压缩路径的写法\n        return ps[x];\n    }\n    //并查集的并操作\n    void connect(int a, int b) {\n        int pa = find(a);\n        int pb = find(b);\n        ps[pa] = pb;\n    }\npublic:\n    int makeConnected(int n, vector<vector<int>>& connections) {\n        int m = connections.size();\n        if (n > m + 1) return -1; //如果要连通n个点 至少要n - 1条边\n        ps.resize(n);\n        //iota 初始化查并集\n        iota(ps.begin(), ps.end(), 0);\n        for (auto &e: connections) {\n            int a = e[0], b = e[1];\n            if (find(a) != find(b)) {\n                connect(a, b);\n                --n;   // 每做一次并操作, 图的连通分量减1\n            }\n        }\n        //从当前的n个连通分量到1个连通分量要至少改n - 1条边\n        return n - 1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1533216594","body":"# 814. 二叉树剪枝\n\n## 思路\n\n递归，二叉树剪枝\n\n## 代码\n\n``` C++\nclass Solution {\npublic:\n    TreeNode* pruneTree(TreeNode* root) {\n        if(!root){\n            return nullptr;\n        }\n        root->right = pruneTree(root->right);\n        root->left = pruneTree(root->left);\n        if(!root->val && !root->right && !root->left){\n            return nullptr;\n        }\n        return root;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1534934010","body":"# 39. 组合总和\n\n## 思路\n\n生成树\n\n## 代码\n\n```Python\nclass Solution:\n    def combinationSum(self, candidates, target) :\n\n        def dfs(candidates, begin, size, path, res, target):\n            if target == 0:\n                res.append(path)\n                return\n\n            for index in range(begin, size):\n                residue = target - candidates[index]\n                if residue < 0:\n                    break\n\n                dfs(candidates, index, size, path + [candidates[index]], res, residue)\n\n        size = len(candidates)\n        if size == 0:\n            return []\n        candidates.sort()\n        path = []\n        res = []\n        dfs(candidates, 0, size, path, res, target)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1536306792","body":"# 40. 组合总数 Ⅱ\n\n## 思路\n\n生成树，剪枝\n\n## 代码\n\n```python\nclass Solution:\n    def combinationSum2(self, candidates, target) :\n        def dfs(begin, path, residue):\n            if residue == 0:\n                res.append(path[:])\n                return\n\n            for index in range(begin, size):\n                if candidates[index] > residue:\n                    break\n\n                if index > begin and candidates[index - 1] == candidates[index]:\n                    continue\n\n                path.append(candidates[index])\n                dfs(index + 1, path, residue - candidates[index])\n                path.pop()\n\n        size = len(candidates)\n        if size == 0:\n            return []\n\n        candidates.sort()\n        res = []\n        dfs(0, [], target)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1537170254","body":"# 全排列 2⃣️\n\n``` C++\nclass Solution {\npublic:\n    vector<bool> st;\n    vector<int> path;\n    vector<vector<int>> ans;\n\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        st = vector<bool>(nums.size(), false);\n        path = vector<int>(nums.size());\n        dfs(nums, 0, 0);\n        return ans;\n    }\n\n    void dfs(vector<int>& nums, int u, int start)\n    {\n        if (u == nums.size())\n        {\n            ans.push_back(path);\n            return;\n        }\n\n        for (int i = start; i < nums.size(); i ++ )\n            if (!st[i])\n            {\n                st[i] = true;\n                path[i] = nums[u];\n                if (u + 1 < nums.size() && nums[u + 1] != nums[u])\n                    dfs(nums, u + 1, 0);\n                else\n                    dfs(nums, u + 1, i + 1);\n                st[i] = false;\n            }\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null],"zhangjiahuan17":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429777424","body":"# 思路\r\n将输入list转化为int型后与k相加，再转化为list\r\n\r\n# 代码\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_str = \"\"\r\n        if len(num)>0:\r\n            for i in num:\r\n                num_str += str(i)\r\n            result_int = int(num_str) + k\r\n            result = [int(j) for j in str(result_int)]\r\n        return result\r\n \r\n# 复杂度\r\nO(n)?       \r\n       ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431465290","body":"# 思路\r\n正向遍历，记录s中字符与c的正向距离，反向遍历，记录s中字符与c的反向距离，取二者中最小值\r\n\r\n# 代码\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        sl = len(s)\r\n        result = [0 for i in range(sl)]\r\n\r\n        idx = -sl\r\n        for i, si in enumerate(s):\r\n            if si == c:\r\n                idx = i\r\n            result[i] = i - idx\r\n        \r\n        idx = 2 * sl\r\n        for i in range(sl-1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            result[i] = min(result[i], idx-i)\r\n        \r\n        return result\r\n# 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433203473","body":"# 代码\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.st = []\r\n        self.cnt = 0\r\n        self.size = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.size:\r\n            self.st.append(x)\r\n            self.cnt += 1\r\n\r\n    def pop(self) -> int:\r\n        if len(self.st) == 0:\r\n            return -1\r\n        self.cnt -= 1\r\n        return self.st.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, self.cnt)):\r\n            self.st[i] += val\r\n\r\n# 复杂度\r\n时间复杂度：O(k)\r\n空间复杂度：O(maxsize)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1438500230","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in s:\n            if i == ']':\n                encoded_string = ''\n                k = ''\n                while stack and stack[-1] != '[':\n                    encoded_string = stack.pop() + encoded_string\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    k = stack.pop() + k\n                stack.append(encoded_string * int(k))\n            else:\n                stack.append(i)\n        return \"\".join(stack)\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1438518363","body":"class MyQueue:\r\n\r\n    def __init__(self):\r\n        self.instack = []\r\n        self.outstack = []\r\n    \r\n    def in_to_out(self):\r\n        while self.instack:\r\n            self.outstack.append(self.instack.pop())\r\n\r\n    def push(self, x: int) -> None:\r\n        self.instack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.outstack:\r\n            while self.instack:\r\n                self.outstack.append(self.instack.pop())\r\n        return self.outstack.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.outstack:\r\n            self.in_to_out()\r\n        return self.outstack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        if not self.instack and not self.outstack:\r\n            return True\r\n        else:\r\n            return False\r\n","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438542168","body":"class Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        newhead = head.next\r\n        head.next = self.swapPairs(newhead.next)\r\n        newhead.next = head\r\n        return newhead\r\n        \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1441828726","body":"class Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return head\r\n        \r\n        pre, slow, fast = None, head, head\r\n\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        \r\n        if pre:\r\n            pre.next = None\r\n        \r\n        node = TreeNode(slow.val)\r\n        if slow == fast:\r\n            return node\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n        return node","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441801063","body":"\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        A, B = headA, headB\r\n        while A != B:\r\n            A = A.next if A else headB\r\n            B = B.next if B else headA\r\n        return A","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443645653","body":"class Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast, slow1, slow2 = head, head, head\n\n        while True:\n            if not (fast and fast.next): \n                return None\n            fast = fast.next.next\n            slow1 = slow1.next\n            \n            if fast == slow1:\n                break\n        while slow1 != slow2:\n            slow2 = slow2.next\n            slow1 = slow1.next\n        return slow2","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446365713","body":"if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450213187","body":"class Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        curlevel = collections.deque()\n        curlevel.append(root)\n        while curlevel:\n            length = len(curlevel)\n            res = curlevel[0].val\n            for _ in range(length):\n                cur = curlevel.popleft()\n                if cur.left:\n                    curlevel.append(cur.left)\n                if cur.right:\n                    curlevel.append(cur.right)\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451932868","body":"class Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        ans = ''\n        queue = [root]\n        while queue:\n            node = queue.pop(0)\n            if node:\n                ans += str(node.val) + ','\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                ans += '#,'\n        print(ans[:-1])\n        return ans[:-1]\n        \n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if data == '#': return None\n        nodes = data.split(',')\n        if not nodes: return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n\n        i = 1\n        while i < len(nodes) -1:\n            node = queue.pop(0)\n            lv = nodes[i]\n            rv = nodes[i+1]\n\n            i+=2\n            if lv != '#':\n                l = TreeNode(lv)\n                node.left = l\n                queue.append(l)\n\n            if rv != '#':\n                r = TreeNode(rv)\n                node.right = r\n                queue.append(r)\n        \n        return root","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462147795","body":"class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        x = sum(nums)%p\n        if x == 0:\n            return 0\n        y = 0\n        index = {0:-1}\n        ans = len(nums)\n        for ind, val in enumerate(nums):\n            y = (val + y) % p\n            if (y - x)%p in index:\n                ans = min(ans, ind - index[(y - x) % p])\n            index[y] = ind\n        return ans if ans < len(nums) else -1","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"seanutf":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429780721","body":"```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10) {\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456057813","body":"```kotlin\nclass Solution {\n    fun numberOfBoomerangs(points: Array<IntArray>): Int {\n        var ans = 0\n        for(p in points) {\n            val cnt = HashMap<Int, Int>()\n            for(q in points){\n                val dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\n                cnt[dis] = cnt.getOrDefault(dis, 0) + 1\n            }\n\n            cnt.forEach {\n                ans += it.value * (it.value - 1)\n            }\n        }\n        return ans\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465213174","body":"```java\npublic int searchInsert(int[] nums, int target) {\n    for(int i = 0; i < nums.length;i++){\n        if(nums[i] >= target){\n            return i;\n        }\n    }\n    return nums.length;\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyong-hub":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429806182","body":"```c\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& A, int K) {\n        vector<int> res;\n        int n = A.size();\n        for(int i =n-1;i>=0;i--){\n            int sum = A[i] + K%10;\n            K /=10;\n            if(sum>=10){\n                K++;\n                sum -=10;\n\n            }\n            res.push_back(sum);\n        }\n        for(;K>0;K/=10){\n            res.push_back(K%10);\n        }\n        reverse(res.begin(),res.end());\n        return res;\n\n    }\n};\n```\n# 时间复杂度 O(N)\n# 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431343471","body":"思路：\n1、把c出现的位置记录；\n2、s[i]循环求最小距离\n时间复杂度（O(n*k)）\n空间复杂度O(N)\n```c\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int>num_i;\n        vector<int>res(s.length(),s.size());\n        for(int i=0;i<s.length();i++)\n        {\n            if(s[i]==c)\n                num_i.push_back(i);\n            else\n                continue;\n        }\n\n        for(int i=0;i<s.length();i++)\n        {\n            int dist=s.length();\n            if(s[i]==c)\n            {\n                res[i]=0;\n                continue;\n            } \n            else\n            {\n                for(int j=0;j<num_i.size();j++)\n                {\n                    dist = abs(i-num_i[j]);\n                    if(dist<res[i])\n                        res[i]=dist;\n                }\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433031130","body":"#思路\n使用数组模拟栈\n```c\nclass CustomStack {\nprivate:\n    int size;\n    int top;//栈顶\n    int *stack;//数组模拟栈\npublic:\n    CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        size  = maxSize;\n        top = 0;\n    }  \n    void push(int x) {\n        if(top >=size)\n            return;\n        if(top <size)\n            stack[top++]=x;\n    }\n    \n    int pop() {\n        if(top>0)\n            return stack[--top];\n        else\n            return -1;\n\n    }\n    \n    void increment(int k, int val) {\n            if(top <k){\n                for(int i=0;i<top;i++)\n                        stack[i] +=val;\n            }else{\n                for(int i=0;i<k;i++)\n                        stack[i] +=val;\n\n            }\n    }\n};\n\n\n```\n# 时间复杂度分析\npop push (O(1))\ninc (O(K))\n#空间复杂度\nO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434651099","body":"# 思路\n使用递归\n```c\nclass Solution {\npublic:\n    string helper(string s,int &index){\n        string temp=\"\";\n        string res=\"\";\n        int nums=0;\n        while(index < s.length())\n        {\n          \n            if(s[index]>='0' && s[index]<='9')\n            {\n                nums = nums*10 + (s[index]-'0');\n            }else if(s[index]=='[')\n            {\n                temp = helper(s,++index);\n                while(nums>0){\n                    res+=temp;\n                    nums--;\n                }\n            }else if(s[index]==']'){\n                break;\n            }else{\n                res += s[index];\n            }\n            index++;\n        }\n        return res;\n    }\n    string decodeString(string s) {\n        int index=0;\n        return helper(s,index);\n\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1438495554","body":"# 思路\n用栈有序的最大值，最后返回栈的大小\n```c\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        if(arr.size()==1 || arr[0]==arr.size())\n            return 1;\n        if(arr.size()==0)\n            return 0;\n        stack<int>stk;\n        stk.push(arr[0]);\n        int topmax=stk.top();\n        for(int i=1;i<arr.size();i++){\n            if(stk.top()<=arr[i])\n                stk.push(arr[i]);\n            else{\n                topmax = stk.top();\n                while(stk.size()!=0 &&stk.top()>arr[i]){ \n                    stk.pop();\n                }\n                stk.push(topmax>arr[i]?topmax:arr[i]);  \n            }       \n        }\n        return stk.size();\n\n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436946585","body":"#思路\n采用递归，先把链表形成环，记录头结点\n```c\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || head->next==nullptr || k==0)\n            return head;\n        temphead=head;\n        return helper(head,k);    \n    }\n        ListNode *temphead;//记录头结点 \n        int L = 0;//反转几次\n        int nums =0;//记录长短\n    ListNode* helper(ListNode* head, int k){\n        if(head==nullptr)\n            return head;\n        nums++;\n        if(helper(head->next,k)==nullptr){\n            L= k%nums;\n            head->next = temphead;//形成环\n        }\n        if(L==0){\n            temphead = head->next;\n            head->next = nullptr;\n        }\n        L--;\n        return temphead;\n\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438483714","body":"# 思路\n递归，注意终止条件\n```c\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(!head || !head->next)\n            return head;\n        ListNode *newhead = head->next;\n        head->next = swapPairs(newhead->next);\n        newhead->next = head;\n        return newhead;\n        \n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erquaner":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429815149","body":"```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let arrK = String(k).split('')\r\n    let i = num.length-1, j = arrK.length-1\r\n    let list = [], c = 0\r\n    while(i >=0||j>=0) {\r\n        const add1 = i >= 0 ? num[i] : 0;\r\n        const add2 = j >= 0 ? +arrK[j] : 0;\r\n        const sum = add1 + add2 + c;\r\n        c = Math.floor(sum / 10);\r\n        list.unshift(sum % 10);\r\n        i--;\r\n        j--;\r\n      \r\n    }\r\n     if(c != 0){\r\n        list.unshift(c);\r\n       }\r\n\r\n    return list;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1433066985","body":"```js\r\n//双指针\r\nvar shortestToChar = (S, C) => {\r\n    let res = [] \r\n    for ( let i = 0 ; i < S.length ; i ++){\r\n        let left = i , right = i\r\n        while(1){\r\n            if ( S[left] === C || S[right] === C) {\r\n                res.push(right-i)\r\n                break\r\n            }\r\n            left--;\r\n            right++\r\n        }\r\n    }\r\n    return res\r\n}\r\n// 数组 \r\nvar shortestToChar = (S, C) => {\r\n    let arr = [] , res = [] ,index = 0\r\n    for( let i = 0 ; i < S.length ; i ++){\r\n        if (S[i] === C ) arr.push(i)\r\n    }\r\n    for( let i = 0 ; i < S.length ; i ++){\r\n        for( let j = index ; j < arr.length ; j ++) {\r\n            if ( i <= arr[j] ){\r\n                index = j ; \r\n                res.push(Math.min(arr[j]-i,(i-arr[j-1] || Infinity)))\r\n                break\r\n            }\r\n            j === arr.length -1 && res.push(i-arr[j])\r\n        }\r\n    }\r\n    return res\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433065609","body":"```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.stack = new Array();   // [empty, ...]\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  // 最大长度限制\r\n  if(this.stack.length<this.maxSize){\r\n    this.stack.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  // 栈顶为空的 =》 -1\r\n  if(this.stack.length===0){\r\n    return -1;\r\n  }\r\n  let val = this.stack.pop();\r\n  return val;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let n = Math.min(k,this.stack.length);  //取交集，前n个元素+val\r\n  for(let i=0;i<n;i++){\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiujingxukong":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429824008","body":"# 思路\r\n在leetcode看题解，看到如下思路：\r\n```\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n顺着这个思路写。\r\n# 代码\r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  let res = [];\r\n  let carry = 0;\r\n\r\n  while (num.length !== 0 || k !== 0) {\r\n    let a = num.length !== 0 ? num.pop() : 0;\r\n    let b = k % 10;\r\n\r\n    let sum = a + b + curry;\r\n    let current = sum % 10;\r\n    carry = Math.floor(sum / 10);\r\n\r\n    res.push(current);\r\n\r\n    k = Math.floor(k / 10);\r\n  }\r\n  if (curry === 1) res.push(1);\r\n  return res.reverse();\r\n};\r\n```\r\n# 复杂度分析\r\n1. 时间复杂度\r\nO(max(a,b)) a为给定数组长度，b为给定整数的位数\r\n2. 空间复杂度\r\ncurry是函数范围的变量\r\na,b,sum,current,k都是循环范围的变量\r\n整体空间复杂度为O（1）\r\n\r\n# 个人代码习惯勘误\r\n1. array.push()返回值不是数组，不能res=res.push(current)\r\n2. 返回值需要return值,不然就会看到返回值是undefined\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431476925","body":"# 解题思路\n看Lucifer的官方题解2  \n先将字符c出现在字符串s中的下标位置存入数组cIndices中  \n再遍历字符串s的每个字符，再在cIndices中寻找距离当前字符最近的下标\n# 代码\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let cIndices=[]\n    for(i=0;i<s.length;i++){\n        if(s[i]===c){\n            cIndices.push(i)\n        }\n    }\n\n    let res=Array(s.length).fill(Infinity)\n\n    for(i=0;i<s.length;i++){\n\n        if(s[i]===c){\n            res[i]=0\n            continue\n        }\n\n        for(let cIndex of cIndices){\n            let distance=Math.abs(i-cIndex)\n\n            if(res[i]<distance)break\n\n            res[i]=distance\n        }\n    }\n    return res\n\n};\n```\n# 复杂度分析\n1. 时间复杂度。O（N*K）N为字符串s的长度，K为c字符出现在字符串s中的次数，K<=N。一层循环内套一层小的循环。O（N+N*K）≈O（N*K）\n2. 空间复杂度。O（K）。开辟了新的数组cIndices。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433211649","body":"# 解题思路\r\n第二种解题思路没看懂，第一次看到这种解法，所以按照第一种写代码   \r\n需要一个 cnt 变量记录栈的当前长度，一个 size 变量记录最大容量，并在 pop 和 push 的时候更新 cnt   \r\npush 的时候要判断是否满了   \r\npop 的时候要判断是否空了\r\n从栈底往上的K个元素增加都val，要遍历栈内元素，当增加到K个元素时，便跳出循环。\r\n# 解题代码\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.max=maxSize\r\n    this.stack=[]\r\n\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.stack.length<this.max){\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    const res=this.stack.pop()\r\n   return res==null?-1:res\r\n\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(i=0;i<this.stack.length;i++){\r\n        if(i<k){\r\n            this.stack[i]=this.stack[i]+val\r\n        }\r\n       if(i=k)break\r\n    }\r\n};\r\n```\r\n# 复杂度分析\r\n1. 时间复杂度   \r\npush和pop都是O（1）   \r\nincrement操作是O（min(k,l)）l是stack的长度   \r\n2. 空间复杂度O（1）\r\n# 代码习惯\r\n1. 当js中数组长度为0，此时pop，会返回结果undefined,所以判断原本数组中是否为空的条件，需要是res==null，而不能是res===null\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434672700","body":"# 解题思路\r\n递归方法看了一下应该短时间内看不懂，于是只会用栈的思路解题   \r\n刚开始思路跑偏，输入的字符串的前面和后面的字母无法拼接到最终结果上（JS的数组没有类似Python的append方法），于是看了评论区里的其他人用JS写的解法。   \r\n   \r\n遍历这个字符串 s，判断每一个字符的类型：\r\n如果是字母 --> 添加到 stack 当中\r\n如果是数字 --> 先不着急添加到 stack 中 --> 因为有可能有多位\r\n如果是 [ --> 说明重复字符串开始 --> 将数字和当前的结果字符串入栈 --> 并且将数字零，结果字符串清空\r\n如果是 ] --> 说明重复字符串结束 --> 拼接出重复字符，拼接到结果字符串上   \r\n# JS代码\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n 数据结构用栈\r\n */\r\nvar decodeString = function (s) {\r\n  res = \"\";\r\n  temp = [];\r\n  count = 0;\r\n  for (let i of s) {\r\n    if (i === \"]\") {\r\n      const [str, num] = temp.pop();\r\n      res = str + res.repeat(num);\r\n      continue;\r\n    } else if (Number.isInteger(Number(i))) {\r\n      count = Number(count + i);\r\n      continue;\r\n    } else if (i === \"[\") {\r\n      temp.push([res, count]);\r\n      res = \"\";\r\n      count = 0;\r\n      continue;\r\n    } else {\r\n      res = res + i;\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```\r\n# 复杂度分析\r\n1. 时间复杂度O（n）n为s的长度，遍历了一遍s。\r\n2. 空间复杂度O（k）k为s中右括号或者说左括号的个数\r\n# 代码习惯\r\n1. 第一次知道字符串实例的方法 repeat\r\n2. 使用typeof判断字符串的字符时，好像都会判断为string，所以遍历s时，条件为字符类型是string的要放在最后。\r\n3. Number.isInteger(Number(i))用于判断i的类型\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435665081","body":"# 解题思路\r\n此题结合实际——使用两个栈来替代一个队列的实现是为了在多进程中分开对同一个队列对读写操作——来看确实经典，而且解法上官方题解更趋近于现实情况，即分为读栈和写栈。  \r\n下面这段话还怎么理解。 \r\n>实际上现实中也有使用两个栈来实现队列的情况，那么为什么我们要用两个 stack 来实现 一个 queue？   \r\n其实使用两个栈来替代一个队列的实现是为了在多进程中分开对同一个队列对读写操作。一 个栈是用来读的，另一个是用来写的。当且仅当读栈满时或者写栈为空时，读写操作才会发 生冲突。   \r\n当只有一个线程对栈进行读写操作的时候，总有一个栈是空的。在多线程应用中，如果我们 只有一个队列，为了线程安全，我们在读或者写队列的时候都需要锁住整个队列。而在两个 栈的实现中，只要写入栈不为空，那么push操作的锁就不会影响到pop。\r\n# 解题代码\r\n1. 我自己的实现\r\n```javascript\r\nvar MyQueue = function() {\r\n    this.stack1=[]\r\n    this.stack2=[]\r\n\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack1.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    const length=this.stack1.length\r\n    if(length!==0){\r\n        for(let i=0;i<length;i++){\r\n            this.stack2.push(this.stack1.pop())\r\n        }\r\n        const del=this.stack2.pop()\r\n        for(let i=0;i<length-1;i++){\r\n            this.stack1.push(this.stack2.pop())\r\n        }\r\n        return del\r\n        }\r\n   \r\n    };\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    \r\n        const length=this.stack1.length\r\n        if(length!==0){\r\n        for(let i=0;i<length;i++){\r\n            this.stack2.push(this.stack1.pop())\r\n        }\r\n        top=this.stack2.pop()\r\n        this.stack1.push(top)\r\n        for(let i=0;i<length-1;i++){\r\n            this.stack1.push(this.stack2.pop())\r\n        }\r\n    \r\n    return top\r\n    }\r\n\r\n\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack1.length===0?true:false\r\n\r\n};\r\n```\r\n2. 官方题解（更好更贴近现实情况）\r\n```javascript\r\nvar MyQueue = function () {\r\n  this.inStack = [];\r\n  this.outStack = [];\r\n};\r\n\r\nMyQueue.prototype.push = function (x) {\r\n  this.inStack.push(x);\r\n};\r\n\r\nMyQueue.prototype.pop = function () {\r\n  if (!this.outStack.length) {\r\n    this.in2out();\r\n  }\r\n  return this.outStack.pop();\r\n};\r\n\r\nMyQueue.prototype.peek = function () {\r\n  if (!this.outStack.length) {\r\n    this.in2out();\r\n  }\r\n  return this.outStack[this.outStack.length - 1];\r\n};\r\n\r\nMyQueue.prototype.empty = function () {\r\n  return this.outStack.length === 0 && this.inStack.length === 0;\r\n};\r\n\r\nMyQueue.prototype.in2out = function () {\r\n  while (this.inStack.length) {\r\n    this.outStack.push(this.inStack.pop());\r\n  }\r\n};\r\n```\r\n# 复杂度分析（只分析官方思路代码）\r\n1. 时间复杂度\r\npush和empty操作都是O（1）\r\npeek和pop操作都是O（N），其中 N 为 栈中元素个数。\r\n2. 空间复杂度\r\n空间复杂度：O(N)，其中 N 为 栈中元素个数，多使用了一个辅助栈，这 个辅助栈的大小和原栈的大小一样。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436010591","body":"# 解题思路\r\n这道题本来题目都没看明白，看了Lucifer的题解才明白了。   \r\n由于只有分的块内部可以排序，块与块之间的相对位置是不能变的。因此直观上我们的核心其实找到从左到右开始不减少（增加或者不变）的地方并分块。   \r\n只要后面有较小值，那么前面大于它的都应该在一个块里面，有没有注意到我们一直在找下一个比当前小的元素？这就是一个信号，使用单调递增栈即可以空间换时间的方式解决。   \r\n思路逆转，不是分割区块，而是融合区块。比如 [2,1,3,4,4]，遍历到 1 的时候会发现 1 比 2 小，因此 2， 1 需要在一块，我们可以将 2 和 1 融合，并重新压回栈。那么融合成 1 还是 2 呢？答案是 2，因为 2 是瓶颈，这提示我们可以用一个递增栈来完成。   \r\n# 代码\r\n```javascript\r\nvar maxChunksToSorted = function (arr) {\r\n  const stack = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    a = arr[i];\r\n    if (stack.length > 0 && stack[stack.length - 1] > a) {\r\n      const cur = stack[stack.length - 1];\r\n      while (stack && stack[stack.length - 1] > a) stack.pop();\r\n      stack.push(cur);\r\n    } else {\r\n      stack.push(a);\r\n    }\r\n  }\r\n  return stack.length;\r\n};\r\n```\r\n# 复杂度分析\r\n1. 时间复杂度：O(N)，其中 N 为数组长度。\r\n2. 空间复杂度：O(N)，其中 N 为数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437202390","body":"# 解题思路\r\n第一步：找到链表倒数第 k 个节点。   \r\n算法描述：\r\n\r\n1. 采用快慢指针；\r\n2. 快指针与慢指针都以每步一个节点的速度向后遍历；\r\n3. 快指针比慢指针先走 k 步；\r\n4. 当快指针到达终点时，慢指针正好是倒数第 k+1 个节点\r\n\r\n第二步：旋转链表。   \r\n算法描述：\r\n   \r\n1. 获取单链表的倒数第 k 与倒数第 k + 1 个节点；\r\n2. 将倒数第 k + 1 个节点的 next 指向 null；\r\n3. 将尾节点 next 指向 head（拼起来）；\r\n4. 返回倒数第 k 个节点\r\n\r\n# 解题代码\r\n```javascript\r\nvar rotateRight = function (head, k) {\r\n  if (!head || !head.next) return head;\r\n  let count = 0,\r\n    now = head;\r\n  while (now) {\r\n    now = now.next;\r\n    count++;\r\n  }\r\n  k = k % count;\r\n  let slow = (fast = head);\r\n  while (fast.next) {\r\n    if (k-- <= 0) {\r\n      slow = slow.next;\r\n    }\r\n    fast = fast.next;\r\n  }\r\n  fast.next = head;\r\n  let res = slow.next;\r\n  slow.next = null;\r\n  return res;\r\n};\r\n```\r\n# 复杂度分析\r\n1. 时间复杂度O（n），节点最多只遍历两遍。\r\n2. 空间复杂度O(1)，未使用额外的空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438716824","body":"# 解题思路\r\n考察点：   \r\n\r\n1. 怎么改变链表节点指针转向；\r\n2. 链表的递归性；\r\n3. 创建一个空节点 preHead，让其 next 指针指向 A(充当 preA 的角色)，这样是我们专注于算法逻辑，避免判断边界条件。这涉及到链表指针修改的时候头节点可能发生变化的时候非常常用。\r\n\r\n# 解题代码\r\n```javascript\r\nvar swapPairs = function (head) {\r\n  if (!head || !head.next) return head;\r\n  let res = head.next;\r\n  let now = head;\r\n  let preNode = new ListNode();\r\n  preNode.next = head;\r\n  while (now && now.next) {\r\n    let nextNode = now.next;\r\n    let nnNode = nextNode.next;\r\n    now.next = nnNode;\r\n    nextNode.next = now;\r\n    preNode.next = nextNode;\r\n    preNode = now;\r\n    now = nnNode;\r\n  }\r\n  return res;\r\n};\r\n```\r\n# 复杂度分析\r\n1. 时间复杂度O（N）\r\n2. 空间复杂度O（1）\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440292363","body":"# 解题思路\r\n二叉搜索树：左子树的值比根节点小，右子树的值比根节点大。   \r\n算法：   \r\n\r\n1. 获取链表中点\r\n2. 以链表中点为根\r\n3. 中点左边的值都小于它,可以构造左子树；\r\n4. 同理构造右子树；\r\n5. 循环第一步\r\n# 解题代码\r\n第一种获取链表中点的方法：使用快慢指针，定义一个快指针每步前进两个节点，一个慢指针每步前进一个节点，当快指针到达尾部的时候，正好慢指针所到的点为中点。\r\n```javascript\r\nvar sortedListToBST = function (head) {\r\n  if (!head) return null;\r\n  return dfs(head, null);\r\n};\r\n\r\nfunction dfs(head, tail) {\r\n  if (head == tail) return null;\r\n  let fast = head;\r\n  let slow = head;\r\n  while (fast != tail && fast.next != tail) {\r\n    fast = fast.next.next;\r\n    slow = slow.next;\r\n  }\r\n  let root = new TreeNode(slow.val);\r\n  root.left = dfs(head, slow);\r\n  root.right = dfs(slow.next, tail);\r\n  return root;\r\n}\r\n```\r\n第二种获取链表中点的方法，使用数组将链表的值存储,以空间换时间。\r\n```javascript\r\nvar sortedListToBST = function (head) {\r\n  let res = [];\r\n  while (head) {\r\n    res.push(head.val);\r\n    head = head.next;\r\n  }\r\n  return dfs(res, 0, res.length - 1);\r\n};\r\n\r\nfunction dfs(res, l, r) {\r\n  if (l > r) return null;\r\n  let mid = parseInt((l - r) / 2 + r);\r\n  let root = new TreeNode(res[mid]);\r\n  root.left = dfs(res, l, mid - 1);\r\n  root.right = dfs(res, mid + 1, r);\r\n  return root;\r\n}\r\n```\r\n# 复杂度分析\r\n## 第一种方法\r\n时间复杂度：递归树的深度为 logn，每一层的基本操作数为 n，因此总的时间复杂度为O(nlogn)\r\n空间复杂度：O（logn）,递归树的深度为 logn\r\n## 第二种方法\r\n时间复杂度：递归树每个节点的时间复杂度为 O(1)，每次处理一个节点，因此总的节点数就是 n， 也就是说总的时间复杂度为O(n)。\r\n空间复杂度：使用了数组对链表的值进行缓存，空间复杂度为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441870512","body":"# day10 解题思路\r\n讲义中的题目，但我当时看了就不会，趁着每日一题想明白了。\r\n## 思路一：哈希表法。   \r\n链表相交，说明存储了同一个地址的数据。   \r\n\r\n1. 有 A, B 两条链表, 先遍历其中一个，比如 A 链表，并将 A 中的所有节点存入哈希表。\r\n2. 接着遍历 B 链表，检查每个节点是否在哈希表中, 存在于哈希表中的那个节点就是 A 链表和 B 链表的相交节点。\r\n\r\n## 思路二：双指针法。    \r\n\r\n1. 使用两个指针如指针 a, b 分别指向 A, B 这两条链表的头节点, 两个指针以相同的速度向后移动。\r\n2. 当 a 到达链表 A 的尾部时，将它重定位到链表 B 的头节点；\r\n3. 当 b 到达链表 B 的尾部时，将它重定位到链表 A 的头节点；\r\n4. 若在此过程中 a, b 指针相遇，则相遇节点为两链表相交的起始节点，否则说明两个链表不存在相交点。\r\n\r\n为什么 a, b 指针相遇的点一定是相交的起始节点?我们证明一下：\r\n\r\n- 将两条链表按相交的起始节点继续截断，链表 1 为: A + C，链表 2 为: B + C；\r\n- 当 a 指针将链表 1 遍历完后，重定位到链表 2 的头节点，然后继续遍历直至相交点，此时 a 指针遍历的距离为 A + C + B；\r\n- 同理 b 指针遍历的距离为 B + C + A；\r\n\r\n# 解题代码\r\n## 方法一：哈希表法代码\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function (headA, headB) {\r\n  let data = new Set();\r\n  while (headA !== null) {\r\n    data.add(headA);\r\n    headA = headA.next;\r\n  }\r\n  while (headB !== null) {\r\n    if (data.has(headB)) return headB;\r\n    headB = headB.next;\r\n  }\r\n  return null;\r\n};\r\n```\r\n## 方法二 双指针法\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function (headA, headB) {\r\n  let a = headA;\r\n  let b = headB;\r\n  while (a !== b) {\r\n    a = a === null ? headB : a.next;\r\n    b = b === null ? headA : b.next;\r\n  }\r\n  // 跳出来循环时a=b了，要么是相交的点，要么都等于null(都等于null的例子可用两个孤立的点当作链表A和链表B)\r\n  return a;\r\n};\r\n```\r\n# 复杂度分析\r\n## 哈希表法\r\n\r\n- 时间复杂度 O（n）\r\n- 空间复杂度 O（n）\r\n\r\n## 双指针法\r\n\r\n- 时间复杂度 O（n）\r\n-  空间复杂度 O（1）\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443833501","body":"# 解题思路\r\n## 方法一 哈希表法\r\n将遍历链表节点，存入哈希表中。如果正在遍历的节点已经存在于哈希表中，那么就存在环，且第一次满足条件的节点就是链表开始入环的第一个节点。\r\n## 方法二 双指针法\r\n具体算法：\r\n\r\n1. 定义一个 fast 指针,每次前进两步,一个 slow 指针,每次前进一步\r\n2. 当两个指针相遇时，将 fast 指针重定位到链表头部,同时 fast 指针每次只前进一步\r\n3. slow 指针继续前进,每次前进一步\r\n4. 当两个指针再次相遇时,当前节点就是环的入口\r\n\r\n证明：\r\n以下节点数称为距离\r\n\r\n- x 表示第一次相遇点\r\n- L 是起点到环的入口点的距离\r\n- C 是环的入口点到第一次相遇点的距离\r\n- D 是环的周长减去 C\r\n\r\n第一次快慢指针相遇时，慢指针走过的距离为L+m*(C+D)+C，快指针走过的距离为L+n(C+D)+C。\r\n又因为快指针总共走过的距离是慢指针总共走过的距离的两倍。所以快指针增加一倍的L+C距离\r\n所以在两者第一次相遇后将快指针放回开头，两个指针都每次移动一步直到相遇，快指针两次总共走过的距离为2L+p*(C+D)+2C，慢指针总共走过的距离为L+q*(C+D)+C。\r\n（直觉中这么解释是对的，但是数学不好真不行）\r\n\r\n# 解题代码\r\n## 方法一 哈希表法\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    let data = new Set();\r\n  while (head) {\r\n    if (!data.has(head)) {\r\n      data.add(head);\r\n      head = head.next;\r\n    } else {\r\n      return head;\r\n    }\r\n  }\r\n  return null;\r\n    \r\n};\r\n```\r\n## 方法二 双指针法\r\n```javascript\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function (head) {\r\n  if (!head || !head.next) return null;\r\n  let fast = (slow = head);\r\n  do {\r\n//因为fast和fast.next可能在变化过程中变成null,所以要用if判断，确保fast !== null && fast.next !== null才执行里面的代码\r\n    if (fast !== null && fast.next !== null) {\r\n      fast = fast.next.next;\r\n    } else {\r\n      fast = null;\r\n    }\r\n    slow = slow.next;\r\n  } while (fast !== slow);\r\n  if (fast === null) return null;\r\n  fast = head;\r\n  while (fast !== slow) {\r\n    fast = fast.next.next;\r\n    slow = slow.next;\r\n  }\r\n  return fast;\r\n};\r\n```\r\n# 复杂度分析\r\n## 方法一 哈希表法\r\n时间复杂度：O（N）遍历链表一遍\r\n空间复杂度：O（N）增加存储节点的哈希表\r\n## 方法二 双指针法\r\n时间复杂度：O（N）一直在循环链表\r\n空间复杂度：O（1）\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445119627","body":"# 解题思路\r\n这个题目太好了。   \r\n\r\n1. 增删改查（get是查，put包含增删改查）要求时间复杂度是O（1）\r\n考虑增删操作时间复杂度是O（1），所以用链表（链表和数组中选择）。   \r\n考虑查改操作时间复杂度是O（1），所以用哈希表来辅助，以空间换时间。\r\n2. LRU 缓存机制要求逐出最久未使用的关键字，恰好符合链表插入和删除节点有序的特点。\r\n3. node节点和node.value是不同的，node节点指node在内存中的物理存储。\r\n4. 移除链表节点后还需要把该节点前后的两个节点连起来，因此我们需要的是双向链表而不是单向链表。\r\n\r\n算法思路\r\n```python\r\n// put\r\n\r\nif key 存在:\r\n    更新节点值\r\n    把节点移到链表头部\r\n\r\nelse:\r\n    if 缓存满了:\r\n        移除最后一个节点\r\n        删除它在哈希表中的映射\r\n\r\n    新建一个节点\r\n    把节点加到链表头部\r\n    在哈希表中增加映射\r\n\r\n\r\n// get\r\n\r\nif key 存在:\r\n    返回节点值\r\n    把节点移到链表头部\r\nelse:\r\n    返回 -1\r\n```\r\n# 代码(答案里的代码，我写的不知道哪里错了)\r\n```javascript\r\nclass DoubleLinkedListNode {\r\n    constructor(key, value) {\r\n        this.key = key\r\n        this.value = value\r\n        this.prev = null\r\n        this.next = null\r\n    }\r\n}\r\n\r\nclass LRUCache {\r\n    constructor(capacity) {\r\n        this.capacity = capacity\r\n        this.usedSpace = 0\r\n        // Mappings of key->node.\r\n        this.hashmap = {}\r\n        this.dummyHead = new DoubleLinkedListNode(null, null)\r\n        this.dummyTail = new DoubleLinkedListNode(null, null)\r\n        this.dummyHead.next = this.dummyTail\r\n        this.dummyTail.prev = this.dummyHead\r\n    }\r\n\r\n    _isFull() {\r\n        return this.usedSpace === this.capacity\r\n    }\r\n\r\n    _removeNode(node) {\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n        node.prev = null\r\n        node.next = null\r\n        return node\r\n    }\r\n\r\n    _addToHead(node) {\r\n        const head = this.dummyHead.next\r\n        node.next = head\r\n        head.prev = node\r\n        node.prev = this.dummyHead\r\n        this.dummyHead.next = node\r\n    }\r\n\r\n    get(key) {\r\n        if (key in this.hashmap) {\r\n            const node = this.hashmap[key]\r\n            this._addToHead(this._removeNode(node))\r\n            return node.value\r\n        }\r\n        else {\r\n            return -1\r\n        }\r\n    }\r\n\r\n    put(key, value) {\r\n        if (key in this.hashmap) {\r\n            // If key exists, update the corresponding node and move it to the head.\r\n            const node = this.hashmap[key]\r\n            node.value = value\r\n            this._addToHead(this._removeNode(node))\r\n        }\r\n        else {\r\n        // If it's a new key.\r\n            if (this._isFull()) {\r\n                // If the cache is full, remove the tail node.\r\n                const node = this.dummyTail.prev\r\n                delete this.hashmap[node.key]\r\n                this._removeNode(node)\r\n                this.usedSpace--\r\n            }\r\n            // Create a new node and add it to the head.\r\n            const node = new DoubleLinkedListNode(key, value)\r\n            this.hashmap[key] = node\r\n            this._addToHead(node)\r\n            this.usedSpace++\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n```\r\n# 复杂度分析\r\n\r\n- 时间复杂度：各种操作平均都是 O(1)。\r\n- 空间复杂度：链表占用空间 O(N)，哈希表占用空间也是 O(N)，因此总的空间复杂度为 O(N)，其中 N 为容量大小，也就是题目中的 capacity。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445392701","body":"# 解题思路\r\n\r\n1. 树这种逻辑结构适合递归的算法思想，因为树是一种递归的逻辑结构。   \r\n2. 写递归的小方法 产品经理法\r\n\r\n- 定义函数功能，不用管其具体实现。从高层次的角度来定义函数功能。 你可以把自己想象成产品经理。只需要知道要做什么事情就行了，而怎么实现我不管，那是码农的事情。具体来说，我需要的功能是给定一个二叉树的节点，返回以这个节点为根节点的子树的最大深度。假设这个函数为 f。那么问题转化为 f(root)。\r\n- 确定大问题和小问题的关系。要解决 f(root) 这个问题。可以先解决 f(root.right) 和 f(root.left)，当然我们仍然不关心 f 怎么实现。f(root) 与 f(root.right) 和 f(root.left) 有什么关系呢？ 不难看出 1 + max(f(root.right), f(root.left))。到这里我们还不知道 f 怎么实现的，但是我们已经完成了产品经理的需求。实际上我们知道了，因为树递归的性质。\r\n- 补充递归终止条件。如果递归到叶子节点的时候，返回 0 即可。\r\n\r\n# 代码\r\n```javascript\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function (root) {\r\n  if (root === null) {\r\n    return 0;\r\n  }\r\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n};\r\n```\r\n# 复杂度分析\r\n\r\n- 时间复杂度：O（N）递归函数调用n次，函数内操作数为O(1),二者相乘。\r\n- 空间复杂度：O（h）其中 h 为树的深度，最坏的情况 h 等于 N，其中 N 为节点数，此时树退化到链表。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446406798","body":"#  解题思路\r\n比较两棵树是否相等，那么就需要\r\n\r\n1. 方法一：遍历到每一个节点并且两两比较节点值。可以采用深度优先遍历（可采用递归法）或者广度优先遍历（也叫层序遍历,使用队列实现）\r\n2. 方法二：由于中序序列和前、后，层次序列任意组合唯一确定一颗二叉树（前提是遍历是基于引用的或者二叉树的值都不相同）。所以可以中序序列和前、后，层次序列任意组合两次遍历的结果（而不用每遍历一次就比较一次）看是否两棵树的两种遍历都相等。\r\n\r\n## 方法一：递归法（深度优先遍历）\r\n树结构既有递归性,树的题目可以用来练习问题分解   \r\n**递归三要素**\r\n\r\n1. 递归出口，问题最简单的情况\r\n2. 递归调用总是去尝试解决更小的问题，这样问题才会被收敛到最简单的情况\r\n3. 递归调用的父问题和子问题没有交集\r\n\r\n**尝试用递归去解决相同的树**\r\n\r\n1. 分解为子问题，相同的树分解为左子是否相同，右子是否相同\r\n2. 递归出口: 当树高度为 1 时，判断递归出口\r\n\r\n\r\n# 解题代码\r\n## 方法一：递归法\r\n```javascript\r\nvar isSameTree = function (p, q) {\r\n//p\\q中至少有一个为空\r\n  if (!p || !q) {\r\n    return !p && !q;\r\n  }\r\n  return (\r\n    p.val === q.val &&\r\n    isSameTree(p.left, q.left) &&\r\n    isSameTree(p.right, q.right)\r\n  );\r\n};\r\n```\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448259847","body":"# 解题思路\r\n考察树的路径，可用深度优先遍历和广度优先遍历。这道题让我练习了这两种遍历。\r\n# 代码\r\n## 方法一 深度优先遍历（递归）\r\n```javascript\r\nfunction sumNumbers(root) {\r\n    let sum=0\r\n    function dfs(node,curSum){\r\n        if(!node)return\r\n        curSum=curSum*10+node.val\r\n        if(!node.left&&!node.right){\r\n            sum=sum+curSum\r\n        }\r\n        dfs(node.left,curSum)\r\n        dfs(node.right,curSum)\r\n    }\r\n    dfs(root,0)\r\n    return sum\r\n}\r\n```\r\n## 方法二 广度优先遍历BFS（用栈）\r\n```javascript\r\nfunction sumNumbers(root) {\r\n  let sum = 0;\r\n  let curLevel = [];\r\n  if (root) {\r\n    curLevel.push(root);\r\n  }\r\n  while (curLevel.length) {\r\n    let nextLevel = [];\r\n    for (let i = 0; i < curLevel.length; i++) {\r\n      let cur = curLevel[i];\r\n      if (cur.left) {\r\n        cur.left.val = cur.left.val + cur.val * 10;\r\n        nextLevel.push(cur.left);\r\n      }\r\n      if (cur.right) {\r\n        cur.right.val = cur.right.val + cur.val * 10;\r\n        nextLevel.push(cur.right);\r\n      }\r\n      if (!cur.left && !cur.right) {\r\n        sum = sum + cur.val;\r\n      }\r\n    }\r\n    curLevel = nextLevel;\r\n  }\r\n  return sum;\r\n}\r\n\r\n```\r\n# 复杂度分析\r\n## 方法一 DFS\r\n时间复杂度：O（N），N为节点数\r\n空间复杂度：O（h），h为树的高度\r\n## 方法二 BFS\r\n时间复杂度：O（N），N为节点数\r\n空间复杂度：O（q）,q 为队列长度。最坏的情况是满二叉树，此时和 n 同阶。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449328081","body":"# 解题思路\r\n树的搜索。根据题目描述，找到最后一行的最左边的节点值。根据leetcode的题目也可以看出来，findBottomLeftValue。   \r\n最直接的方法是用BFS，还可以用DFS。\r\n# 代码\r\n## 方法一 BFS\r\n```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nfunction findBottomLeftValue(root) {\r\n  let curLevel = [root];\r\n  while (curLevel.length) {\r\n    let nextLevel = [];\r\n    for (let i = 0; i < curLevel.length; i++) {\r\n      let node = curLevel[i];\r\n      node.left && nextLevel.push(node.left);\r\n      node.right && nextLevel.push(node.right);\r\n    }\r\n    if (!nextLevel.length) {\r\n      return curLevel[0].val;\r\n    }\r\n    curLevel = nextLevel;\r\n  }\r\n\r\n  return curLevel[0].val;\r\n}\r\n```\r\n## 方法二 DFS\r\n先序遍历 root，维护一个最大深度的变量，记录每个节点的深度，**如果当前节点深度比最大深度要大，则更新最大深度和结果项。**要记录和更新最大深度和结果项。   \r\n树的最后一行找到最左边的值，转化一下就是找第一个出现的深度最大的节点，这里用先序遍历去做，其实中序遍历也可以，只需要保证左节点在右节点前被处理即可。 \r\n```javascript\r\nfunction findBottomLeftValue(root) {\r\n  let maxDepth = 0;\r\n  let res = root.val;\r\n  dfs(root.left, 0);\r\n  dfs(root.right, 0);\r\n  return res;\r\n\r\n  function dfs(cur, depth) {\r\n    if (!cur) return;\r\n    let curDepth = depth + 1;\r\n    if (curDepth > maxDepth) {\r\n      maxDepth = curDepth;\r\n      res = cur.val;\r\n    }\r\n    dfs(cur.left, curDepth);\r\n    dfs(cur.right, curDepth);\r\n  }\r\n}\r\n```\r\n# 复杂度分析\r\n## 方法一 BFS\r\n时间复杂度：O（N）,其中 N 为树的节点总数。\r\n空间复杂度：O（Q）,其中 Q 为队列长度，最坏的情况是满二叉树，此时和 N 同阶，其中 N 为树的节点总数。\r\n## 方法二 DFS\r\n时间复杂度：O（N）,其中 N 为树的节点总数。\r\n空间复杂度：O（h）,其中 其中 h 为树的高度。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451748272","body":"# 思路（只看了BFS）\r\n给完全二叉树编号，这样父子之间就可以通过编号轻松求出。比如我给所有节点从左到右从上到下依次**_从 1 开始编号_**。那么已知一个节点的编号是 i，那么其左子节点就是 2 * i，右子节点就是 2 * i + 1，父节点就是 i / 2。\r\n思路：\r\n\r\n1. 用三个指针分别指向数组第一项，第二项和第三项（如果存在的话），这里用 p1，p2，p3 来标记，分别表示当前处理的节点，当前处理的节点的左子节点和当前处理的节点的右子节点。\r\n2. p1 每次移动一位，p2 和 p3 每次移动两位。\r\n3. p1.left = p2; p1.right = p3。\r\n4. 持续上面的步骤直到 p2 移动到最后。\r\n\r\n#代码\r\n```javascript\r\nfunction TreeNode(val) {\r\n  this.val = val;\r\n  this.left = null;\r\n  this.right = null;\r\n}\r\n\r\n/**\r\n * Encodes a tree to a single string.\r\n *\r\n * @param {TreeNode} root\r\n * @return {string}\r\n */\r\nconst serialize = (root) => {\r\n  const queue = [root];\r\n  let res = [];\r\n  while (queue.length) {\r\n    let node = queue.shift();\r\n    if (node) {\r\n      res.push(node.val);\r\n      queue.push(node.left);\r\n      queue.push(node.right);\r\n    } else {\r\n      res.push(\"#\");\r\n    }\r\n  }\r\n  return res.join(\",\");\r\n};\r\n\r\n/**\r\n * Decodes your encoded data to tree.\r\n *\r\n * @param {string} data\r\n * @return {TreeNode}\r\n */\r\nconst deserialize = (data) => {\r\n  if (data === \"#\") return null;\r\n  const list = data.split(\",\");\r\n  const root = new TreeNode(list[0]);\r\n  // queue这里的作用是排列顺序。\r\n  const queue = [root];\r\n  let cursor = 1;\r\n\r\n  while (cursor < list.length) {\r\n    const node = queue.shift();\r\n    const leftVal = list[cursor];\r\n    const rightVal = list[cursor + 1];\r\n    if (leftVal !== \"#\") {\r\n      const leftNode = new TreeNode(leftVal);\r\n      node.left = leftNode;\r\n      queue.push(leftNode);\r\n    }\r\n    if (rightVal !== \"#\") {\r\n      const rightNode = new TreeNode(rightVal);\r\n      node.right = rightNode;\r\n      queue.push(rightNode);\r\n    }\r\n    cursor += 2;\r\n  }\r\n\r\n  return root;\r\n};\r\n\r\n/**\r\n * Your functions will be called as such:\r\n * deserialize(serialize(root));\r\n */\r\n```\r\n# 复杂度分析\r\n\r\n- 时间复杂度：O（N），其中 N 为树的节点数。\r\n- 空间复杂度：O（Q），其中 Q 为队列长度，最坏的情况是满二叉树，此时和 N 同阶，其中 N 为树的节点总数。\r\n- ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453723308","body":"# 解题思路\r\n\r\n1. 题目中的坐标不符合直觉和视觉，所以另外选择坐标系——左右子树向y轴负方向延展，root为（0，0）。\r\n2. 用DFS遍历所有节点，记录下所有节点的坐标。\r\n3. 以x轴为key,[y,val]为value将所有结点的坐标记录成哈希表（这里用javascript里的Object来表示哈希表）\r\n4. 先按照key将哈希表里的值升序排列，再在哈希表内的每一个item内部，按照y值将item内的每一个记录降序排列。\r\n5. 最后输出排列好的val二维数组\r\n6. 这道题让我更理解了深度优先遍历，需要随着左右子树的不同变化的参数，需要放在dfs函数的参数中，在函数中递归调用时直接把参数传入。判断左右节点是否不存在，放在dfs函数中的首行if(!node)return\r\n\r\n# 解题代码\r\n```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number[][]}\r\n */\r\nvar verticalTraversal = function (root) {\r\n  if (!root) return [];\r\n\r\n  // 坐标集合以 x 坐标分组\r\n  const pos = {};\r\n  // dfs 遍历节点并记录每个节点的坐标\r\n  dfs(root, 0, 0);\r\n\r\n  // 得到所有节点坐标后，先按 x 坐标升序排序\r\n//js中的object的key只能是string或者Symbol类型的，所以进行数学运算前要用+将a&b变为number类型\r\n  let sorted = Object.keys(pos)\r\n    .sort((a, b) => +a - +b)\r\n    .map((key) => pos[key]);\r\n\r\n  // 再给 x 坐标相同的每组节点坐标分别排序\r\n  sorted = sorted.map((g) => {\r\n    g.sort((a, b) => {\r\n      // y 坐标相同的，按节点值升序排\r\n      if (a[0] === b[0]) return a[1] - b[1];\r\n      // 否则，按 y 坐标降序排\r\n      else return b[0] - a[0];\r\n    });\r\n    // 把 y 坐标去掉，返回节点值\r\n    return g.map((el) => el[1]);\r\n  });\r\n\r\n  return sorted;\r\n\r\n  // *********************************\r\n  function dfs(root, x, y) {\r\n    if (!root) return;\r\n\r\n    x in pos || (pos[x] = []);\r\n    // 保存坐标数据，格式是: [y, val]\r\n    pos[x].push([y, root.val]);\r\n\r\n    dfs(root.left, x - 1, y - 1);\r\n    dfs(root.right, x + 1, y - 1);\r\n  }\r\n};\r\n```\r\n# 复杂度分析\r\n分析：\r\n\r\n- 哈希表最外层的 key 总个数是最大是树的宽度。\r\n- 哈希表第二层的 key 总个数是树的高度。\r\n- 哈希表值的总长度是树的节点数。\r\n\r\n也就是说哈希表的总容量和树的总的节点数是同阶的。因此空间复杂度为 O(N)， 排序的复杂度大致为 NlogN，其中 N 为树的节点总数。\r\n时间复杂度：O（N*log(N)），其中 N 为树的节点总数。\r\n空间复杂度：O（N），其中 N 为树的节点总数，用哈希表存储了所有节点的坐标值和节点值。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454749056","body":"# 解题思路\r\n最直接的思路暴力法，两次内嵌循环。   \r\n或者可以使用哈希表存储已经遍历过的值和值所对应的下标，哈希表查询的时间复杂度为O（1），以空间换时间。判断 target - num 是否出现时，直接查表即可。\r\n# 解题代码\r\n```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number[]}\r\n */\r\nvar twoSum = function (nums, target) {\r\n  let hashtable = new Map();\r\n\r\n  for (let i = 0; i < nums.length; i++) {\r\n    if (hashtable.has(target - nums[i])) {\r\n      return [hashtable.get(target - nums[i]), i];\r\n    }\r\n    hashtable.set(nums[i], i);\r\n  }\r\n};\r\n```\r\n# 复杂度分析\r\n时间复杂度：O(N)，N为数组长度。\r\n空间复杂度：O(N)，N为数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455080893","body":"# 解题思路\r\n考点两个：\r\n\r\n1. 用哈希表记录元素和对应的频率\r\n2. 对频率进行排序，取出前K个（但我没看懂快速排序，就直接粘贴代码了，提醒我排序这块我还要再学习一下。）\r\n\r\n# 解题代码\r\n```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar topKFrequent = function (nums, k) {\r\n  const counts = {};\r\n  for (let num of nums) {\r\n    counts[num] = (counts[num] || 0) + 1;\r\n  }\r\n  let pairs = Object.keys(counts).map((key) => [counts[key], key]);\r\n\r\n  select(0, pairs.length - 1, k);\r\n  return pairs.slice(0, k).map((item) => item[1]);\r\n\r\n  // 快速选择\r\n  function select(left, right, offset) {\r\n    if (left >= right) {\r\n      return;\r\n    }\r\n    const pivotIndex = partition(left, right);\r\n    console.log({ pairs, pivotIndex });\r\n    if (pivotIndex === offset) {\r\n      return;\r\n    }\r\n\r\n    if (pivotIndex <= offset) {\r\n      select(pivotIndex + 1, right, offset);\r\n    } else {\r\n      select(left, pivotIndex - 1);\r\n    }\r\n  }\r\n\r\n  // 拆分数组为两个part\r\n  function partition(left, right) {\r\n    const [pivot] = pairs[right];\r\n    let cur = left;\r\n    let leftPartIndex = left;\r\n    while (cur < right) {\r\n      if (pairs[cur][0] > pivot) {\r\n        swap(leftPartIndex++, cur);\r\n      }\r\n      cur++;\r\n    }\r\n    swap(right, leftPartIndex);\r\n    return leftPartIndex;\r\n  }\r\n\r\n  function swap(x, y) {\r\n    const term = pairs[x];\r\n    pairs[x] = pairs[y];\r\n    pairs[y] = term;\r\n  }\r\n};\r\n```\r\n# 复杂度分析\r\n时间复杂度：O（N），最坏到N……2\r\n空间复杂度：O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455549244","body":"# 解题思路\r\n\r\n1. 看了讲解后思路很清晰。   \r\n2. 最直接的解法，三层循环。   \r\n3. 优化：使用哈希表以空间换时间的话，内两层循环可以用哈希表来优化成一层。   \r\n4. 全排列的数学知识点：n 个数取两个数的全排列种类是 n*(n-1)。比如找到了 n 个距离为 3 的点，那么我们选择第二个点有 n 种方案，选择第三个点有(n - 1)个方案。那么固定点 A 且距离为 3 的所有可能就是 n∗(n−1) 种。\r\n5. JS中的Map在取key时，用实例对象方法[Map.prototype.keys()]，它返回的是一个可迭代的对象，由于可迭代，所以遍历返回的对象时，要用for of\r\n\r\n# 解题代码\r\n```javascript\r\n/**\r\n * @param {number[][]} points\r\n * @return {number}\r\n */\r\nvar numberOfBoomerangs = function (points) {\r\n  let res = 0;\r\n  if (points.length < 3) return res;\r\n  for (let ele of points) {\r\n    let hashTable = new Map();\r\n    for (let item of points) {\r\n      if (item === ele) continue;\r\n      let distance = getDistance(ele, item);\r\n      if (hashTable.has(distance)) {\r\n        hashTable.get(distance).push(item);\r\n      } else {\r\n        hashTable.set(distance, [item]);\r\n      }\r\n    }\r\n    const table = hashTable.keys();\r\n    console.log(table);\r\n    for (let i of table) {\r\n      const n = hashTable.get(i).length;\r\n      if (n >= 2) {\r\n        res += n * (n - 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  return res;\r\n\r\n  function getDistance(i, j) {\r\n    return Math.sqrt(\r\n      (i[0] - j[0]) * (i[0] - j[0]) + (i[1] - j[1]) * (i[1] - j[1])\r\n    );\r\n  }\r\n};\r\n```\r\n# 复杂度分析\r\n时间复杂度：O（N^2），两层for循环。\r\n空间复杂度：O（N）用了哈希表。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457993757","body":"# 解题思路\r\n双指针中的滑动窗口应用，一左一右两个指针，右指针一步一步向前移动；   \r\n判断右边指针对应的字母是否在左右指针中间的字串里，可以用哈希表（Map或者Object）记录字母和对应字母最近出现位置的下标,查找起来是O（1）时间复杂度。\r\n# 解题代码\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar lengthOfLongestSubstring = function (s) {\r\n    const map = {};\r\n    let l = 0,\r\n        r = 0,\r\n        max = 0;\r\n\r\n    while (r < s.length) {\r\n        const pos = map[s[r]];\r\n        // 如果 s[r] 曾在 [l, r] 滑动窗口中出现\r\n        // 就收缩滑动窗口左侧，把 l 指针移动到 s[r] 上次出现的位置 + 1\r\n        if (pos >= l && pos <= r) l = pos + 1;\r\n\r\n        // 更新 s[r] 出现的位置\r\n        map[s[r]] = r;\r\n        // 计算滑动窗口大小\r\n        max = Math.max(max, r - l + 1);\r\n        // 滑动窗口继续右移扩张\r\n        r++;\r\n    }\r\n    return max;\r\n};\r\n```\r\n# 复杂度分析\r\n1. 时间复杂度：O（N），N为s的长度。\r\n2. 空间复杂度：O（s），s为字符集元素个数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459898797","body":"# 解题思路（复制一下题解上的）\r\n还是从题意暴力入手。大体上会有两个想法：\r\n\r\n1. 从 words 入手，words 所有单词排列生成字符串 X, 通过字符串匹配查看 X 在 s 中的出现位置\r\n2. 从 s 串入手，遍历 s 串中所有长度为 (words[0].length * words.length) 的子串 Y，查看 Y 是否可以由 words 数组构造生成\r\n\r\n先看第一种思路: 构造 X 的时间开销是 (words.length)! / (words 中单词重复次数相乘), 时间复杂度为 O(m!), m 为 words 长度。阶乘的时间复杂度基本不可能通过。（阶乘的时间复杂度曲线比O（N^3）还要陡峭）\r\n下面看第二种思路: 仅考虑遍历过程， 遍历 s 串的时间复杂度为 O(n−m+1), 其中 n 为 s 字符串长度, m 为 words[0].length * words.length，也就是 words 的字符总数。问题关键在于如何判断 s 的子串 Y 是否可以由 words 数组的构成，由于 words 中单词长度固定，我们可以将 Y 拆分成对应 words[0]长度的一个个子串 parts, 只需要判断 words 和 parts 中的单词是否一一匹配即可，这里用两个哈希表表比对出现次数即可。一旦一个对应不上，意味着此种分割方法不正确，继续尝试下一种即可。\r\n# 解题代码\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {string[]} words\r\n * @return {number[]}\r\n */\r\nvar findSubstring = function (s, words) {\r\n  let res = [];\r\n  let hashTable = new Map();\r\n  let sLength = s.length;\r\n  let wordLength = words[0].length;\r\n  let count = words.length;\r\n\r\n  if (words === null || words.length === 0 || sLength < count * wordLength)\r\n    return res;\r\n\r\n  for (let i of words) {\r\n    if (hashTable.has(i)) {\r\n      hashTable.set(i, hashTable.get(i) + 1);\r\n    } else {\r\n      hashTable.set(i, 1);\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < sLength - wordLength * count + 1; i++) {\r\n    let cur = s.slice(i, i + wordLength * count);\r\n    let temp = new Map();\r\n    let j = 0;\r\n    for (; j < cur.length; j += wordLength) {\r\n      let word = cur.slice(j, j + wordLength);\r\n      if (!hashTable.has(word)) break;\r\n      if (temp.has(word)) {\r\n        temp.set(word, temp.get(word) + 1);\r\n      } else {\r\n        temp.set(word, 1);\r\n      }\r\n      if (temp.get(word) > hashTable.get(word)) break;\r\n    }\r\n    if (j == cur.length) res.push(i);\r\n  }\r\n  return res;\r\n};\r\n```\r\n# 复杂度分析\r\n令 n 为字符串 S 长度, m 为 words 数组元素个数, k 为单个 word 字串长度。\r\n时间复杂度：O（m*n*k）难道哈希表查找多个字符的字符串是否相等需要字符长度的时间复杂度，所以需要乘以k?\r\n空间复杂度：O（m）,hashTable长度是不大于m（单个字串可能有重复的）,temp在下一次循环会覆盖上一次的 temp，因此 temp 的空间在任意时刻都不大于O（m），总的空间复杂度是O（m）。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462284013","body":"# 解题代码\r\n## 说明，今天先提交，明天细细补充\r\n```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} p\r\n * @return {number}\r\n */\r\nfunction floorMod (a, b) {\r\n  return ((a % b) + b) % b;\r\n};\r\n\r\nfunction minSubarray(nums, k) {\r\n    var map = new Map();\r\n    map.set(0, -1);\r\n    var res = nums.length;\r\n    var target = 0;\r\n    var currSum = 0;\r\n    for (let i = 0; i < nums.length; i++) {\r\n      target += nums[i];\r\n    }\r\n    target = target % k;\r\n    for (let i = 0; i < nums.length; i++) {\r\n      currSum = (nums[i] + currSum) % k;\r\n      map.set(currSum, i);\r\n      var prevSum = floorMod(currSum - target, k);\r\n      if (map.has(prevSum)) {\r\n        res = Math.min(res, i - map.get(prevSum));\r\n      }\r\n    }\r\n    return res === nums.length ? -1 : res;\r\n  }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463709713","body":"# 解题思路\r\n找链表中点用双指针，用两个指针记为快指针和慢指针, 快指针每次走 2 步，慢指针每次走 1 步，当快指针走到末尾的时候，慢指针刚好到达链表中点。\r\n值得注意的点是判断是否继续循环的条件是slow && fast && fast.next\r\n# 解题代码\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar middleNode = function (head) {\r\n  let fast = head;\r\n  let slow = head;\r\n  while (slow && fast && fast.next) {\r\n    fast = fast.next.next;\r\n    slow = slow.next;\r\n  }\r\n  return slow;\r\n};\r\n\r\n```\r\n# 复杂度分析\r\n时间复杂度：O（n）,n为链表节点数。\r\n空间复杂度：O（1）\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464805471","body":"# 解题思路\r\n\r\n1. 用一个读指针，一个写指针遍历数组。\r\n2. 遇到重复的元素 读指针 就继续前移。\r\n3. 遇到不同的元素 写指针 写入读指针的元素，同时读指针、写指针都前进一步。\r\n4. 读指针读完数组元素时停止，并返回写指针+1也即数组长度。\r\n\r\n# 解题代码\r\n```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\n function removeDuplicates  (nums) {\r\n  let p1 = 0;\r\n  let p2 = 0;\r\n  while (p2 < nums.length) {\r\n    if (nums[p1] !== nums[p2]) {\r\n      p1++;\r\n      nums[p1] = nums[p2];\r\n    }\r\n    p2++;\r\n  }\r\n  return p1 + 1;\r\n};\r\n```\r\n# 复杂度分析\r\n时间复杂度：O（N），N为数组长度。\r\n空间复杂度：O（1）。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465191148","body":"# 解题思路\r\n二分法，用双指针\r\n# 解题代码\r\n```javascript\r\nfunction searchInsert(nums, target) {\r\n  let left = 0;\r\n  let right = nums.length - 1;\r\n  while (left <= right) {\r\n    const middle = (left + right) >> 1;\r\n    const middleValue = nums[middle];\r\n    if (middleValue === target) {\r\n      return middle;\r\n    } else if (middleValue > target) {\r\n      right = middle - 1;\r\n    } else {\r\n      left = middle + 1;\r\n    }\r\n  }\r\n  return left;\r\n}\r\n```\r\n# 复杂度分析\r\n时间复杂度：O（logN）,N为数组长度\r\n空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465813384","body":"# 解题思路\r\n问题其实就是维护一个滑动窗口，每次获取滑动窗口最大值即可。\r\n## 暴力解法\r\n获取固定长度为k的窗口中最大的值时，线性枚举 i 到 i + k 的值找出最大的\r\n## 单调队列\r\n我们没必须存储窗口内的所有元素。 如果新进入的元素比前面的大，那么前面的元素就不再有利用价值，可以直接移除。这提示我们使用一个单调递增栈来完成。但由于窗口每次向右移动的时候，位于窗口最左侧的元素是需要被擦除的，而栈只能在一端进行操作。而如果你使用普通的数组实现，就是可以在另一端操作了，但是时间复杂度仍然是 O(k)(实际使用普通的数组实现算法用时比暴力解法少，因为时间复杂度算的是最坏情况)，和上面的暴力算法时间复杂度一样。因此，我们考虑使用链表来实现，维护两个指针分别指向头部和尾部即可，这样做的时间复杂度是 O(1)，这就是双端队列（dequeue）。   \r\n因此思路就是**用一个双端队列来保存接下来的滑动窗口可能成为最大值的数。**\r\n具体做法：\r\n\r\n1. 入队列\r\n2. 移除失效元素，失效元素有两种\r\n\r\n一种是已经超出窗口范围了，比如我遍历到第 4 个元素，k = 3，那么 i = 0 的元素就不应该出现在双端队列中了。具体就是索引大于 i - k + 1的元素都应该被清除\r\n小于当前元素都没有利用价值了，具体就是从后往前遍历（双端队列是一个递减队列）双端队列，如果小于当前元素就出队列 \r\n  \r\n经过上面的分析，不难知道双端队列其实是一个递减的一个队列，因此队首的元素一定是最大的。\r\n# 解题代码\r\n## 暴力法（时间超出限制）\r\n```javascript\r\nvar maxSlidingWindow = function (nums, k) {\r\n  const res = [];\r\n  for (let i = 0; i <= nums.length - k; i++) {\r\n    let cur = maxInSlidingWindow(nums, i, i + k);\r\n    res.push(cur);\r\n  }\r\n  return res;\r\n};\r\n\r\nfunction maxInSlidingWindow(nums, start, end) {\r\n  let max = -Infinity;\r\n  for (let i = start; i < end; i++) {\r\n    max = Math.max(nums[i], max);\r\n  }\r\n  return max;\r\n}\r\n```\r\n## 单调队列\r\n```javascript\r\nvar maxSlidingWindow = function (nums, k) {\r\n  const res = [];\r\n  const dequeue = new Dequeue([]);\r\n  // 前 k - 1 个数入队\r\n  for (let i = 0; i < k - 1; i++) {\r\n    dequeue.push(nums[i]);\r\n  }\r\n\r\n  // 滑动窗口\r\n  for (let i = k - 1; i < nums.length; i++) {\r\n    dequeue.push(nums[i]);\r\n    res.push(dequeue.max());\r\n    dequeue.shift(nums[i - k + 1]);\r\n  }\r\n  return res;\r\n};\r\n\r\nclass Dequeue {\r\n  constructor(nums) {\r\n    this.list = nums;\r\n  }\r\n\r\n  push(val) {\r\n    const nums = this.list;\r\n    // 保证数据从队头到队尾递减\r\n    while (nums[nums.length - 1] < val) {\r\n      nums.pop();\r\n    }\r\n    nums.push(val);\r\n  }\r\n\r\n  // 队头出队\r\n  shift(val) {\r\n    let nums = this.list;\r\n    if (nums[0] === val) {\r\n      // 这里的js实现shift()理论上复杂度应该是O(k), 就不去真实实现一个O(1)出队的队列了，意思到位即可\r\n      nums.shift();\r\n    }\r\n  }\r\n\r\n  max() {\r\n    return this.list[0];\r\n  }\r\n}\r\n```\r\n# 复杂度分析\r\nn为数组nums长度，k为滑动窗口长度\r\n时间复杂度：O（n*k），由于这里双向队列是用数组实现的，所以还是乘以k\r\n空间复杂度：O（k）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467447880","body":"# 解题思路\r\n原来这个是图的题。我们可以将小镇中的人们之间的信任关系抽象为图的边，那么图中的点自然就是小镇中的人。这样问题就转化为求图中入度（或出度）为 n - 1 并且出度（或入度）为 0的点。   \r\n**算法：**\r\n\r\n1. 初始化长度为 n 的两个数组 in_degree 和 out_degree，分别表示入度和出度信息，比如 in_degree[i] 表示顶点 i 的入度为 in_degress[i]。其中 n 为人数，也就是图中的顶点数。\r\n2. 接下来根据题目给的 trust 关系建图。由于我们定义图的方式为a 信任 b 表示图中有一条从顶点 a 到顶点 b 的有向边。因此如果 a 信任 b，那么 a 的出度 + 1，b 的入度 +1 。\r\n3. 最后遍历 in_degree 和 out_degree 找到满足 in_degree[i] 为 n - 1，并且 out_degress[i] 为 0 的点，返回即可。如果没有这样的点返回 -1。\r\n\r\n# 解题代码\r\n```javascript\r\n/**\r\n * @param {number} n\r\n * @param {number[][]} trust\r\n * @return {number}\r\n */\r\nvar findJudge = function (n, trust) {\r\n  const count = new Array(n + 1).fill(0);\r\n  for (const edge of trust) {\r\n    const x = edge[0];\r\n    const y = edge[1];\r\n    count[y]++;\r\n    count[x]--;\r\n  }\r\n  for (let i = 1; i < n + 1; i++) {\r\n    if (count[i] === n - 1) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n```\r\n# 复杂度分析\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473641474","body":"# 解题思路\r\n图问题：UD是y轴的上下移动，LR是x轴的左右移动，看最终x，y坐标是否都是0\r\n# 解题代码\r\n```javascript\r\n/**\r\n * @param {string} moves\r\n * @return {boolean}\r\n */\r\nvar judgeCircle = function (moves) {\r\n  let pos = [0, 0];\r\n  for (let i of moves) {\r\n    switch (i) {\r\n      case \"U\":\r\n        pos[1] += 1;\r\n        break;\r\n      case \"D\":\r\n        pos[1] -= 1;\r\n        break;\r\n      case \"L\":\r\n        pos[0] -= 1;\r\n        break;\r\n      case \"R\":\r\n        pos[0] += 1;\r\n    }\r\n  }\r\n  return pos[0] === 0 && pos[1] === 0;\r\n};\r\n```\r\n# 复杂度分析\r\nTC：O（n）,n为字符串长度。\r\nSC：O（1）。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474859656","body":"# 有点不想写,没仔细推代码\r\n# 解题思路\r\n模拟就是直接按照题目描述写代码就行。简单模拟题直接模拟就行， 中等模拟题则通常需要结合其他知识点。对于这道题来说， 就需要大家结合 堆 来完成。   \r\n算法：\r\n\r\n1. 如果任务队列没有任务，那么直接将 time 快进到下一个任务的开始时间 ，这样可以减少时间复杂度。\r\n2. 将 time 之前开始的任务全部加入到任务队列中，表示这些任务都可以被处理了。\r\n3. 从任务队列中取出一个时间最短的进行处理。\r\n4. 重复 1 - 3 直到 n 个任务都被处理完毕。\r\n\r\n# 解题代码\r\n```javascript\r\n/**\r\n * @param {number[][]} tasks\r\n * @return {number[]}\r\n */\r\nconst getOrder = function (tasks) {\r\n  const queue = new MinPriorityQueue();\r\n  tasks = tasks.map((task, index) => ({\r\n    index,\r\n    start: task[0],\r\n    time: task[1],\r\n  }));\r\n  tasks.sort((a, b) => b.start - a.start);\r\n  const answer = [];\r\n  let time = 0;\r\n  while (tasks.length > 0 || !queue.isEmpty()) {\r\n    // 队列为空，且没有任务能加入队列，直接跳过时间\r\n    if (queue.isEmpty() && tasks[tasks.length - 1].start > time) {\r\n      time = tasks[tasks.length - 1].start;\r\n    }\r\n\r\n    // 向队列中加入可执行任务\r\n    while (tasks.length > 0) {\r\n      if (tasks[tasks.length - 1].start <= time) {\r\n        const task = tasks.pop();\r\n        queue.enqueue(task, task.time * 100000 + task.index);\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // 执行任务\r\n    const { element: task } = queue.dequeue();\r\n    time += task.time;\r\n    answer.push(task.index);\r\n  }\r\n\r\n  return answer;\r\n};\r\n```\r\n# 复杂度分析\r\nTC:O（n*logn）\r\nSC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475140756","body":"# 解题思路\r\n题目理解起来不难，但要注意边界条件。\r\n将开始时间和结束时间规范到标准时间。\r\n具体来说，我们可以对开始时间的分数进行如下处理：\r\n\r\n- 如果开始时间的分数在 (0,15) 之间，那么可以等价于在 15 分开始，因此可以将开始时间直接置为 15 而不会影响答案。\r\n- 类似地开始时间在 (15,30)可以置为 30。\r\n- ...\r\n- 需要注意的是对于 (45, 60) 置为 0 的过程，需要将小时进位。\r\n\r\n边界条件见代码\r\n# js代码\r\n```javascript\r\n/**\r\n * @param {string} loginTime\r\n * @param {string} logoutTime\r\n * @return {number}\r\n */\r\nvar numberOfRounds = function (loginTime, logoutTime) {\r\n  let [sh, sm] = loginTime.split(\":\");\r\n  // 注意将字符串转换成数字格式\r\n  sh = +sh;\r\n  sm = +sm;\r\n  let [eh, em] = logoutTime.split(\":\");\r\n  eh = +eh;\r\n  em = +em;\r\n  let d = 0;\r\n  let st = sh * 60 + sm;\r\n  let et = eh * 60 + em;\r\n  if (st > et) {\r\n    d += 1;\r\n  }\r\n  if (sm > 0 && sm <= 15) {\r\n    sm = 15;\r\n  } else if (sm > 15 && sm <= 30) {\r\n    sm = 30;\r\n  } else if (sm > 30 && sm <= 45) {\r\n    sm = 45;\r\n  } else if (sm > 45 && sm < 60) {\r\n    sm = 0;\r\n    sh += 1;\r\n  } else if (sm === 0) {\r\n    // sm为0时需要单独判断\r\n    sm = 0;\r\n  }\r\n\r\n  if (em >= 0 && em < 15) {\r\n    em = 0;\r\n  } else if (em >= 15 && em < 30) {\r\n    em = 15;\r\n  } else if (em >= 30 && em < 45) {\r\n    em = 30;\r\n  } else if (em >= 45 && em < 60) {\r\n    em = 45;\r\n  }\r\n\r\n  st = sh * 60 + sm;\r\n  et = eh * 60 + em;\r\n  if (d === 1) et += 24 * 60;\r\n  // (sm > 45 && sm < 60) {sm = 0;sh += 1;}由于这时会sh加一,所以会出现et-st<0的情况，如\"00:47\", \"00:57\"\r\n  return Math.max(0, (et - st) / 15);\r\n};\r\n\r\n```\r\n# 复杂度分析\r\n\r\n- TC:O(1)\r\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476033925","body":"# 解题思路\r\n不要怕难，跟着写慢慢就明白了。枚举题目。   \r\n算法：\r\n\r\n- 使用 c1 和 c2 对字符串 a 和 b 分别进行词频统计，记字符串 a 和 b 的长度为 nnn 和 mmm。\r\n\r\n- 然后枚举字符 iii，分别对三种情况的修改次数进行统计：\r\n\r\n1. 对应条件 1：目的是要将字符串 a 中所有的字符变得「严格小于」字符 iii，将字符串 b 中的所有字符变成「不小于/大于等于」字符 i。 这可以分别统计 a 中大小满足「大于等于」字符 iii 的字符数量，以及 b 中大小满足「小于」字符 iii 数量，两者之和即是满足该条件的最小修改次数。 注意，当 i=0（含义为枚举到小写字母 a）时，需要跳过，因为不存在值大小「严格小于」字母 a 的字符，即无法做到将某个字符串替换成所有字符都「严格小于」字母 a；\r\n2. 对应条件 2：与条件 1 同理；\r\n3. 对应条件 3：如果要将两字符的所有字符都变成 iii，其中字符串 a 要修改的字符数为 ca=n−c1[i]，字符串 b 要修改的字符数为 cb=m−c2[i]，总修改次数为 ca+cb。\r\n4. 枚举完所有的字符 i 后，统计到的所有修改次数的最小值即是答案。\r\n\r\n# 代码\r\n```javascript\r\n/**\r\n * @param {string} a\r\n * @param {string} b\r\n * @return {number}\r\n */\r\nvar minCharacters = function (a, b) {\r\n  const lenA = a.length;\r\n  const lenB = b.length;\r\n  const countA = new Array(26).fill(0);\r\n  const countB = new Array(26).fill(0);\r\n  for (let i = 0; i < lenA; i++) {\r\n    countA[a[i].charCodeAt() - \"a\".charCodeAt()]++;\r\n  }\r\n  for (let i = 0; i < lenB; i++) {\r\n    countB[b[i].charCodeAt() - \"a\".charCodeAt()]++;\r\n  }\r\n  let res = Infinity;\r\n\r\n  for (let i = 0; i < 26; i++) {\r\n    let res3 = 0;\r\n    const stepA = lenA - countA[i];\r\n    const stepB = lenB - countB[i];\r\n    res3 = stepA + stepB;\r\n    res = Math.min(res, res3);\r\n\r\n    if (i === 0) continue;\r\n\r\n    let res1 = 0;\r\n    for (let j = i; j < 26; j++) {\r\n      res1 += countA[j];\r\n    }\r\n    for (let j = 0; j < i; j++) {\r\n      res1 += countB[j];\r\n    }\r\n\r\n    let res2 = 0;\r\n    for (let j = 0; j < i; j++) {\r\n      res2 += countA[j];\r\n    }\r\n    for (let j = i; j < 26; j++) {\r\n      res2 += countB[j];\r\n    }\r\n\r\n    res = Math.min(res2, res1, res);\r\n  }\r\n  return res;\r\n};\r\n```\r\n下面贴一下我参考的js代码,致谢这位同学\r\n```javascript\r\n/**\r\n * @param {string} a\r\n * @param {string} b\r\n * @return {number}\r\n */\r\nvar minCharacters = function(a, b) {\r\n    const lenA = a.length;\r\n    const lenB = b.length;\r\n    //统计每个字符串中各个字符出现的频率\r\n    const countA = new Array(26).fill(0);\r\n    const countB = new Array(26).fill(0);\r\n    for (let i = 0; i < lenA; i++) {\r\n        countA[a[i].charCodeAt() - 'a'.charCodeAt()]++;\r\n    }\r\n    for (let i = 0; i < lenB; i++) {\r\n        countB[b[i].charCodeAt() - 'a'.charCodeAt()]++;\r\n    }\r\n    let res = Infinity;\r\n    for (let i = 0; i < 26 && res !== 0; i++) {\r\n        //将 a,b 都变成当前循环字符(条件三)的步数\r\n        const stepA = lenA - countA[i];\r\n        const stepB = lenB - countB[i];\r\n        //总修改字符数\r\n        res = Math.min(res, stepA + stepB);\r\n        //无法将 a,b 字符串中字符修改为<a 的字母(不存在)\r\n        if (i === 0) continue;\r\n        //a<b(条件1)\r\n        let res1 = 0;\r\n        //a 中字符修改为< 当前循环字符的修改数(a中>= i 的字符数)\r\n        for (let j = i; j < 26; j++) {\r\n            res1 += countA[j];\r\n        }\r\n        //b 中字符修改为>=i 的修改数 (b 中<i 的字符数)\r\n        for (let j = 0; j < i; j++) {\r\n            res1 += countB[j];\r\n        }\r\n        //b<a(条件 2)\r\n        let res2 = 0;\r\n        //b 中字符修改为< 当前循环字符的修改数(b中>= i 的字符数)\r\n        for (let j = i; j < 26; j++) {\r\n            res2 += countB[j];\r\n        }\r\n        //a 中字符修改为>=i 的修改数 (a 中<i 的字符数)\r\n        for (let j = 0; j < i; j++) {\r\n            res2 += countA[j];\r\n        }\r\n        res = Math.min(res, Math.min(res1, res2));\r\n    }\r\n    return res;\r\n};\r\n```\r\n# 复杂度分析\r\n令 m, n 分别为数组 A 和数组 B 的长度。\r\nTC:O(m+n)\r\nSC:O(26)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477629870","body":"# 解题思路\r\n这道题则简单粗暴，直接让你排序。 并且这道题目的难度是Medium，题目的限制条件是有两个，第一是元素个数不超过 10k，这个不算大。 另外一个是数组中的每一项范围都是-50k到50k（包含左右区间）。 看到这里，基本排除了时间复杂度为 O(n^2)的算法。剩下的就是基于比较的nlogn算法，以及基于特定条件的 O(n)算法。由于平时很少用到计数排序等 O(n)的排序算法，一方面是空间复杂度不是常量，另一方面是其要求数据范围不是很大才行，不然会浪费很多空间。\r\n##计数排序\r\n\r\n1. 时间复杂度 O(n)空间复杂度 O(m) m 为数组中值的取值范围，在这道题就是50000 * 2 + 1。\r\n2. 我们只需要准备一个数组取值范围的数字，然后遍历一遍，将每一个元素放到这个数组对应位置就好了， 放的规则是索引为数字的值，value为出现的次数。\r\n3. 这样一次遍历，我们统计出了所有的数字出现的位置和次数。 我们再来一次遍历，将其输出到即可。\r\n\r\n## 快速排序\r\n\r\n1. 快速排序和归并排序都是分支思想来进行排序的算法， 并且二者都非常流行。 快速排序的核心点在于选择轴元素。\r\n2. 每次我们将数组分成两部分，一部分是比 pivot（轴元素）大的，另一部分是不比 pivot 大的。 我们不断重复这个过程， 直到问题的规模缩小的寻常（即只有一个元素的情况）。\r\n\r\n快排的核心点在于如何选择轴元素，一般而言，选择轴元素有四种策略：\r\n\r\n- 数组最左边的元素\r\n- 数组最右边的元素\r\n- 数组中间的元素（我采用的是这种，大家可以尝试下别的）\r\n- 数组随机一项元素\r\n\r\n# 代码\r\n## 计数排序\r\n```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @return {number[]}\r\n */\r\nvar sortArray = function (nums) {\r\n  const counts = Array(50000 * 2 + 1).fill(0);\r\n  const res = [];\r\n  for (const num of nums) counts[50000 + num] += 1;\r\n  for (let i in counts) {\r\n    while (counts[i]--) {\r\n      res.push(i - 50000);\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```\r\n## 快速排序\r\n```javascript\r\n//快速排序是在原数组上交换两项数字大小\r\nfunction swap(nums, a, b) {\r\n  const temp = nums[a];\r\n  nums[a] = nums[b];\r\n  nums[b] = temp;\r\n}\r\n\r\nfunction helper(nums, start, end) {\r\n // while循环中，j可能会减到比start更小，再递归helper，就会start>end，如排序[0,1]\r\n  if (start >= end) return;\r\n  const pivotIndex = start + ((end - start) >>> 1);\r\n  const pivot = nums[pivotIndex];\r\n  let i = start;\r\n  let j = end;\r\n  while (i <= j) {\r\n    while (nums[i] < pivot) i++;\r\n    while (nums[j] > pivot) j--;\r\n    if (i <= j) {\r\n      swap(nums, i, j);\r\n      i++;\r\n      j--;\r\n    }\r\n  }\r\n  helper(nums, start, j);\r\n  helper(nums, i, end);\r\n}\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {number[]}\r\n */\r\nvar sortArray = function (nums) {\r\n  helper(nums, 0, nums.length - 1);\r\n  return nums;\r\n};\r\n```\r\n# 复杂度分析\r\nn为数组长度\r\n## 计数排序\r\nTC：O（n）\r\nSC：O（m）m为数据范围长度\r\n## 快速排序\r\nTC：O（nlogn）\r\nSC: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1478945499","body":"# 思路\r\n二分查找的变种。   \r\n以 8 为例， 我们想要在 1,2,3,4,5... （注意我这里不考虑小数了）找满足条件的 ans，使得 ans ^ 2 刚好小于等于 8，也就是找所有满足 ans ^ 2 <= 8 的最大值，也就是 找最右边的满足条件的值 ，这里的条件就是 <= 8。\r\n我们可以找所有满足 ans ^ 2 >= 8 的最小值，也就是 找最左边的满足条件的值，这里的条件就是 >= 8 么？很明显不可以。这样算的话，答案就是 3 了。（如果题目让我们向上取整就可以用啦 ^_^ ）   \r\n\r\n`Math.pow(3,2)，相当于3**3，相当于3^2`\r\n# 代码\r\n```javascript\r\n/**\r\n * @param {number} x\r\n * @return {number}\r\n */\r\nvar mySqrt = function (x) {\r\n  if (x === 1) return 1;\r\n  let l = 1;\r\n  let r = x >> 1;\r\n  while (l <= r) {\r\n    let mid = (l + r) >> 1;\r\n    if (Math.pow(mid, 2) === x) {\r\n      return mid;\r\n    } else if (Math.pow(mid, 2) < x) {\r\n      l = mid + 1;\r\n    } else {\r\n      right = mid - 1;\r\n    }\r\n  }\r\n  // 没有恰好符合的数时，最后一轮循环是l=r,之前一轮是确定(l-1)**2小于x,最后一轮mid**2必定大于x,执行right = mid - 1;所以返回r.找个例子如8跟着算一下就好了。\r\n  return r;\r\n};\r\n```\r\n# 复杂度分析\r\nTC:O(logx)\r\nSC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480640716","body":"# 解题思路\r\n典型的二分寻找最左边的满足条件的值， 一句话概括就是：寻找最左边和寻找指定值的差别就是碰到等于号的处理情况。 如果是寻找最左边那么碰到等于继续收缩右边界（寻找最右边就是收缩左边界），查找指定值则是直接返回。\r\n# 代码\r\n```javascript\r\n/**\r\n * Definition for isBadVersion()\r\n *\r\n * @param {integer} version number\r\n * @return {boolean} whether the version is bad\r\n * isBadVersion = function(version) {\r\n *     ...\r\n * };\r\n */\r\n\r\n/**\r\n * @param {function} isBadVersion()\r\n * @return {function}\r\n */\r\nvar solution = function (isBadVersion) {\r\n  /**\r\n   * @param {integer} n Total versions\r\n   * @return {integer} The first bad version\r\n   */\r\n  return function (n) {\r\n    let l = 1;\r\n    let r = n;\r\n    while (l <= r) {\r\n      let mid = Math.floor((l + r) / 2);\r\n      if (isBadVersion(mid)) {\r\n        r = mid - 1;\r\n      } else {\r\n        l = mid + 1;\r\n      }\r\n    }\r\n    return l;\r\n  };\r\n};\r\n```\r\n# 复杂度分析\r\nTC:O(logn),n为最终版本号。\r\nSC:O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483849506","body":"# 思路\r\n写的力扣475的题目，二分思路。遍历每一个房屋，利用二分法找出每个房屋所处位置，找出左右最近加热器距离房屋距离。\r\n# 代码\r\n```javascript\r\nvar findRadius = function(houses, heaters) {\r\n    let ans = 0;\r\n    heaters.sort((a, b) => a - b);\r\n    for (const house of houses) {\r\n        const i = binarySearch(heaters, house);\r\n        const j = i + 1;\r\n        const leftDistance = i < 0 ? Number.MAX_VALUE : house - heaters[i];\r\n        const rightDistance = j >= heaters.length ? Number.MAX_VALUE : heaters[j] - house;\r\n        const curDistance = Math.min(leftDistance, rightDistance);\r\n        ans = Math.max(ans, curDistance);\r\n    }\r\n    return ans;\r\n};\r\n\r\nconst binarySearch = (nums, target) => {\r\n    let left = 0, right = nums.length - 1;\r\n    if (nums[left] > target) {\r\n        return -1;\r\n    }\r\n    while (left < right) {\r\n        const mid = Math.floor((right - left + 1) / 2) + left;\r\n        if (nums[mid] > target) {\r\n            right = mid - 1;\r\n        } else {\r\n            left = mid;\r\n        }\r\n    }\r\n    return left;\r\n}\r\n# 复杂度分析\r\nTC:O((n+m)logn)，其中 m 是数组 houses的长度，n 是数组 heaters 的长度。 对数组 heaters 排序需要 O(nlog⁡n)的时间。 使用二分查找对每个房屋寻找距离最近的供暖器，每次二分查找需要 O(log⁡n)的时间，有 m房屋，因此需要 O(mlog⁡n)的时间。 总时间复杂度是 O((n+m)log⁡n)。\r\nSC:O(logn)，其中 n 是数组 heaters的长度。空间复杂度主要取决于排序所需要的空间。","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1487000813","body":"# 思路\r\n可以有以下几个思路\r\n\r\n- 思路一暴力：题目要求我们找出所有 k 长度子串中可能包含的最大元音字母数，那我们遍历一边所有长度为 k 的子串不就知道啦。超时。\r\n- 思路二：利用前缀和，只不过我们前缀和数组元素 i 存的是子串 0..i 的元音字母个数，这样再遍历一遍前缀和数组就可以求出结果 → 前缀和方案\r\n- 思路三：维护一个窗口大小为 k 的滑窗即可，每移动一次可以归纳为：\r\n\r\n1. 窗口左端弹出一个字符（删除步）\r\n2. 若删除了元音则计数器-1（更新步）\r\n3. 窗口右端加进来一个字符（添加步）\r\n4. 若添加的字符是元音则计数器+1（更新步）\r\n\r\n# 思路三代码\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar maxVowels = function (s, k) {\r\n  const dict = new Set([\"a\", \"e\", \"i\", \"o\", \"u\"]);\r\n  let count = 0;\r\n  for (let i = 0; i < k; i++) {\r\n    if (dict.has(s[i])) count++;\r\n  } \r\n  let temp = count;\r\n  for (let i = k, j = 0; j < s.length; i++, j++) {\r\n    if (dict.has(s[i])) temp++;\r\n\r\n    if (dict.has(s[j])) temp--;\r\n\r\n    count = Math.max(count, temp);\r\n  }\r\n  return count;\r\n};\r\n```\r\n# 复杂度分析\r\nTC:O(N).N为字符串长度\r\nSC:O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1490373668","body":"# 思路就是滑动窗口。\r\n## 题目分析\r\n首先题中说找到 s 中所有是 p 的字母异位词的字串，就这句话，就包含了如下两个重要信息：\r\n找到符合要求的子串长度都是 p-->滑动窗口思路就出来了\r\n何为字母异位词？也就是我们不关心 p 这个串的顺序，只关心字母是否出现以及出现的次数，这种问题解决方案一般有两种，一种是利用排序强制顺序，另一种就是用哈希表的方法。\r\n针对如何存储 p 串这个问题，我们可以考虑用桶来装，这个桶既可以用 26 个元素的数组（作用其实也是哈希表）也可以用哈希表\r\n## 错的地方\r\n但我是个大憨批，该hashTable时用window,该window时用hashTable。还有滑动时left应该++，我写成--\r\n\r\n# JS代码\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {string} p\r\n * @return {number[]}\r\n */\r\nvar findAnagrams = function (s, p) {\r\n  const hashTable = new Map();\r\n  const window = new Map();\r\n  for (const i of p) {\r\n    hashTable.set(i, (hashTable.get(i) || 0) + 1);\r\n  }\r\n\r\n  let left = 0,\r\n    right = 0;\r\n  const res = [];\r\n  let valid = 0;\r\n\r\n  while (right < s.length) {\r\n    let i = s[right];\r\n    right++;\r\n    if (hashTable.has(i)) {\r\n      window.set(i, (window.get(i) || 0) + 1);\r\n      if (window.get(i) === hashTable.get(i)) {\r\n        valid++;\r\n      }\r\n    }\r\n\r\n    if (right - left >= p.length) {\r\n      if (valid === hashTable.size) {\r\n        res.push(left);\r\n      }\r\n      const d = s[left];\r\n      left++;\r\n      if (hashTable.has(d)) {\r\n        if (hashTable.get(d) === window.get(d)) {\r\n          valid--;\r\n        }\r\n        window.set(d, window.get(d) - 1);\r\n      }\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```\r\n# 复杂度分析\r\nTC：O（n）,n为s字符串长度\r\nSC：O（m）,m为p字符串长度\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491904572","body":"# 思路\r\n我本来没看出跟昨天的滑动窗口的题目有什么不同，为什么是hard题。   \r\n直接复制讲义：读完该题，是否发现和前一天的题目有些类似呢，前一天的那个说法叫异位词，今天这个直接说包含 T 的所有字符，意思其实是一样的，那不一样的在哪呢？\r\n\r\n- 这次的窗口长度并不固定为 T 的长度，实际窗口大小是 ≥T.length 的\r\n- 这次输出的是最小子串，也就是长度最小的子串，因此我们要维护一个 min，代表当前符合要求的子串长度，遇到更短的，则进行更新。\r\n\r\n要注意字符串实例substr的用法。\r\n# js代码\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {string} t\r\n * @return {string}\r\n */\r\nvar minWindow = function (s, t) {\r\n  const hashTable = new Map();\r\n  const window = new Map();\r\n  for (let i of t) {\r\n    hashTable.set(i, (hashTable.get(i) || 0) + 1);\r\n  }\r\n  let left = 0;\r\n  let right = 0;\r\n  let valid = 0;\r\n  let start = 0;\r\n  let len = Infinity;\r\n  while (right < s.length) {\r\n    let c = s[right];\r\n    right++;\r\n    if (hashTable.has(c)) {\r\n      window.set(c, (window.get(c) || 0) + 1);\r\n      if (window.get(c) === hashTable.get(c)) {\r\n        valid++;\r\n      }\r\n    }\r\n\r\n    while (valid === hashTable.size) {\r\n      if (right - left < len) {\r\n        start = left;\r\n        len = right - left;\r\n      }\r\n      let d = s[left];\r\n      left++;\r\n      if (hashTable.has(d)) {\r\n        if (window.get(d) === hashTable.get(d)) {\r\n          valid--;\r\n        }\r\n        window.set(d, window.get(d) - 1);\r\n      }\r\n    }\r\n  }\r\n  return len === Infinity ? \"\" : s.substr(start, len);\r\n};\r\n```\r\n# 复杂度分析\r\nm是s长度，n是t长度。\r\n\r\n1. TC：O（m+n）\r\n2. SC：O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511339366","body":"# 思路\r\n动态规划。\r\n\r\n1. base case:amount===0时，返回0\r\n2. amount的变化可以分解成子问题\r\n3. amount的变化是由不同的硬币组成而来的\r\n4. dp 函数/数组的定义：输入一个目标金额 n，返回凑出目标金额 n 的最少硬币数量。\r\n\r\n此外，要注意剪枝（按照树的结构想象需要的运算），这就需要新建一个数组来存放从0到越来越大的amount需要的结果数。\r\n\r\n# js代码\r\n```javascript\r\n/**\r\n * @param {number[]} coins\r\n * @param {number} amount\r\n * @return {number}\r\n */\r\nvar coinChange = function (coins, amount) {\r\n  let memo = new Array(amount + 1).fill(-2);\r\n  return dp(coins, amount);\r\n\r\n  function dp(coins, amount) {\r\n    if (amount === 0) return 0;\r\n    if (amount < 0) return -1;\r\n    if (memo[amount] !== -2) {\r\n      return memo[amount];\r\n    }\r\n\r\n    let res = Number.MAX_SAFE_INTEGER;\r\n    for (let coin of coins) {\r\n      let subProblem = dp(coins, amount - coin);\r\n      if (subProblem === -1) continue;\r\n      res = Math.min(res, subProblem + 1);\r\n    }\r\n    memo[amount] = res === Number.MAX_SAFE_INTEGER ? -1 : res;\r\n    return memo[amount];\r\n  }\r\n};\r\n```\r\n# 复杂度\r\n令 N 为物品个数即硬币种类， amount 为总金额也即背包大小。\r\n\r\n- TC:O（N*amount）\r\n- SC:O(amount)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514370672","body":"# 思路\r\n贪心。排序。两个指针。一个饼干不能满足胃口，就换更大的饼干。\r\n# 代码\r\n```javascript\r\n/**\r\n * @param {number[]} g\r\n * @param {number[]} s\r\n * @return {number}\r\n */\r\nvar findContentChildren = function (g, s) {\r\n  //这里的排序函数不能写花括号，就像s.sort((a, b) => {\r\n    a - b;\r\n  });这样，是不对的，箭头函数无返回值，就无法排序。\r\n  g.sort((a, b) => a - b);\r\n  s.sort((a, b) => a - b);\r\n  let gm = 0;\r\n  let sn = 0;\r\n  let res = 0;\r\n  while (gm < g.length && sn < s.length) {\r\n    if (s[sn] >= g[gm]) {\r\n      res += 1;\r\n      gm++;\r\n    }\r\n    sn++;\r\n  }\r\n  return res;\r\n};\r\n```\r\n# 复杂度分析\r\n\r\n- 时间复杂度：由于使用了排序，因此时间复杂度大约为 O(nlogn)\r\n- 空间复杂度：取决于具体的排序方法，大概是 O(1) 到 O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516227848","body":"# 思路\r\n子问题的最优解也是原问题的最优解，符合贪心算法特点。是动态规划的特例——贪心算法。\r\n# js code\r\n```javascript\r\n/**\r\n * @param {number[][]} intervals\r\n * @return {number}\r\n */\r\nvar eraseOverlapIntervals = function (intervals) {\r\n  const l = intervals.length;\r\n  return l - intervalSchedule(intervals);\r\n\r\n  function intervalSchedule(intervals) {\r\n    if (intervals.length === 0) {\r\n      return 0;\r\n    }\r\n    intervals.sort((a, b) => a[1] - b[1]);\r\n    let count = 1;\r\n    let endTime = intervals[0][1];\r\n    for (let i = 1; i < intervals.length; i++) {\r\n      let startTime = intervals[i][0];\r\n      if (startTime >= endTime) {\r\n        count++;\r\n        endTime = intervals[i][1];\r\n      }\r\n    }\r\n    return count;\r\n  }\r\n};\r\n```\r\n# 复杂度分析\r\nTC：有排序，有循环一次intervals数组。时间复杂度取决于排序算法如何实现，应该是O（nlogn）,n是intervals数组长度。\r\nSC：取决于排序算法，O（1）或者O（logn）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"x1aox1a":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429825256","body":"# **0989. 数组形式的整数加法**\n\n# 题目\n\n```bash\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\n\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\n\n示例 1：\n\n输入：num = [1,2,0,0], k = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n示例 2：\n\n输入：num = [2,7,4], k = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n示例 3：\n\n输入：num = [2,1,5], k = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n```\n\n# 思路\n\n1. 将列表转数字\n2. 数字相加\n3. 数字和转列表\n4. 返回列表\n\n# 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        def list_to_num(num: List[int]) -> int:\n            # O(N)\n            res = 0\n            Len = len(num)\n            for i in range(Len):\n                res += num[i] * 10**(Len-i-1)\n            return res\n\n        def num_to_list(k: int) -> List[int]:\n            # O(N)\n            return list(map(int, str(k)))\n\n        return num_to_list(list_to_num(num) + k)\n```\n\n- 时间复杂度：O(N) + O(N) = O(N)\n- 空间复杂度：O(1)，除了返回结果，只使用了常数空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431475727","body":"# 0**821. 字符的最短距离**\r\n\r\n# 题目\r\n\r\n```python\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n```\r\n\r\n# 思路：双向遍历\r\n\r\n- 第一次：左到右，计算最短距离\r\n- 第二次：右到左，再次计算并且更新最短距离\r\n\r\n# 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n\r\n        L = len(s)\r\n        res = [L] * L\r\n        \r\n        # left to right\r\n        c_idx = None\r\n        for i, char in enumerate(s):\r\n            if char==c:\r\n                c_idx, res[c_idx] = i, 0\r\n            elif c_idx is not None:\r\n                res[i] = i-c_idx\r\n\r\n        # right to left        \r\n        c_idx = None  \r\n        for i, char in enumerate(s[::-1]):\r\n            i = L-i-1\r\n            if char==c: \r\n                c_idx = i\r\n            elif c_idx is not None:\r\n                res[i] = min(res[i], c_idx-i)\r\n        \r\n        return res\r\n```\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433300555","body":"# **1381. 设计一个支持增量操作的栈**\r\n\r\n# 题目\r\n\r\n```python\r\n请你设计一个支持对其元素进行增量操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack stk = new CustomStack(3); // 栈是空的 []\r\nstk.push(1);                          // 栈变为 [1]\r\nstk.push(2);                          // 栈变为 [1, 2]\r\nstk.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\nstk.push(2);                          // 栈变为 [1, 2]\r\nstk.push(3);                          // 栈变为 [1, 2, 3]\r\nstk.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\nstk.increment(5, 100);                // 栈变为 [101, 102, 103]\r\nstk.increment(2, 100);                // 栈变为 [201, 202, 103]\r\nstk.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\nstk.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\nstk.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\nstk.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n```\r\n\r\n# 思路\r\n\r\n# 代码\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max_size = maxSize\r\n        self.size = 0\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size == self.max_size: return None\r\n        self.stack.append(x)\r\n        self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.size == 0: \r\n            return -1\r\n        else:\r\n            self.size -= 1\r\n            return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, self.size)):\r\n            if i==self.max_size:\r\n                return None\r\n            self.stack[i] += val\r\n            \r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n\r\n- 时间复杂度：\r\n    - push: O(1)\r\n    - pop: O(1)\r\n    - increment: O(min(k, size)), size is the current size\r\n- 空间复杂度：都是 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434842539","body":"# **394. 字符串解码**\r\n\r\n# 题目\r\n\r\n```python\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n示例 3：\r\n\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n示例 4：\r\n\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n```\r\n\r\n# 思路：stack\r\n\r\n- 在 “]” 之前，入栈\r\n- 遇到  “]” ，即出栈\r\n- 注意点：\r\n    - 需要 pop 掉 “[”\r\n    - 次数有可能不是个位数\r\n\r\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1332ae90-07bb-4f2f-bcbd-05637c76c434/Untitled.png)\r\n\r\n# 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for char in s:\r\n            if char == \"]\":\r\n                repeat_str = \"\"\r\n                repeat_count = \"\"\r\n                # 1. repeat_str\r\n                while stack[-1] != \"[\":\r\n                    repeat_str = stack.pop() + repeat_str\r\n                # 2. pop out \"[\"\r\n                stack.pop() \r\n                # 3. repeat_count\r\n                while stack and stack[-1].isnumeric():\r\n                    repeat_count = stack.pop() + repeat_count\r\n                # 4. repeat_count * repeat_str\r\n                stack.append(int(repeat_count)*repeat_str)\r\n            else:\r\n                stack.append(char)\r\n\r\n        return \"\".join(stack)\r\n```\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n- 时间 40 ms 击败 36.67%\r\n- 内存 15 MB 击败 32.21%","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435694047","body":"# **0232. 用栈实现队列**\r\n\r\n# 题目\r\n\r\n```python\r\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\r\n\r\n实现 MyQueue 类：\r\n\r\nvoid push(int x) 将元素 x 推到队列的末尾\r\nint pop() 从队列的开头移除并返回元素\r\nint peek() 返回队列开头的元素\r\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\r\n说明：\r\n\r\n你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n \r\n\r\n示例 1：\r\n\r\n输入：\r\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\r\n[[], [1], [2], [], [], []]\r\n输出：\r\n[null, null, null, 1, 1, false]\r\n\r\n解释：\r\nMyQueue myQueue = new MyQueue();\r\nmyQueue.push(1); // queue is: [1]\r\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\nmyQueue.peek(); // return 1\r\nmyQueue.pop(); // return 1, queue is [2]\r\nmyQueue.empty(); // return false\r\n```\r\n\r\n# 思路\r\n\r\n- 两个栈：\r\n    - self.stack 用于数据保存\r\n    - tmp_stack 用于在 pop 和 peek 时拷贝 self.stack 并获取 tmp_stack 底部数据\r\n- 注意点：\r\n    - 进行 pop 操作时，需要将 self.len - 1\r\n\r\n# 代码\r\n\r\n```python\r\nfrom copy import deepcopy as copy\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack = []\r\n        self.len = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        # O(1)\r\n        self.stack.append(x)\r\n        self.len += 1\r\n\r\n    def pop(self) -> int:\r\n        # O(N) 将 stack 清空直至剩下最后一个，即 queue pop\r\n        # 需要将 len-1，代表 pop\r\n        tmp_stack = copy(self.stack)\r\n        tmp_len = self.len\r\n        while tmp_len > 1:\r\n            tmp_stack.pop()\r\n            tmp_len -= 1\r\n        self.len -= 1 # reduse len when pop\r\n        return tmp_stack.pop()\r\n\r\n    def peek(self) -> int:\r\n        # O(N) 将 stack 清空直至剩下最后一个，即 queue peek\r\n        tmp_stack = copy(self.stack)\r\n        tmp_len = self.len\r\n        while tmp_len > 1:\r\n            tmp_stack.pop()\r\n            tmp_len -= 1\r\n        return tmp_stack.pop()\r\n\r\n    def empty(self) -> bool:\r\n        # O(1)\r\n        return self.len == 0\r\n```\r\n\r\n- 时间复杂度：\r\n    - push: O(1)\r\n    - pop: O(N)，while 操作，N 为之前 push 的次数\r\n    - peek: O(N)，while 操作，N 为之前 push 的次数\r\n    - empty: O(1)\r\n- 空间复杂度：\r\n    - push: O(1)\r\n    - pop: O(N)，copy 操作，N 为之前 push 的次数\r\n    - peek: O(N)，copy 操作，N 为之前 push 的次数\r\n    - empty: O(1)\r\n- 时间 32 ms 击败 87.77%\r\n- 内存 15.3 MB 击败 5.26%","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436023145","body":"# **0768. 最多能完成排序的块 II**\r\n\r\n# 题目\r\n\r\n```python\r\n给你一个整数数组 arr 。\r\n\r\n将 arr 分割成若干 块 ，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\r\n\r\n返回能将数组分成的最多块数？\r\n\r\n \r\n示例 1：\r\n\r\n输入：arr = [5,4,3,2,1]\r\n输出：1\r\n解释：\r\n将数组分成2块或者更多块，都无法得到所需的结果。 \r\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \r\n示例 2：\r\n\r\n输入：arr = [2,1,3,4,4]\r\n输出：4\r\n解释：\r\n可以把它分成两块，例如 [2, 1], [3, 4, 4]。 \r\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。\r\n```\r\n\r\n# 思路\r\n\r\n- 对于每一个分隔点，其左边所有元素需小于等于右侧所有元素\r\n- 可以通过在末尾插入一个 inf 来简化代码\r\n\r\n# 代码\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        count = 0\r\n        arr.append(float('inf'))\r\n        for i in range(1, len(arr)):\r\n            if max(arr[:i]) <= min(arr[i:]):\r\n                count += 1\r\n\r\n        return count\r\n```\r\n\r\n- 时间复杂度：O(N^2)\r\n- 空间复杂度：O(1)\r\n- 时间 764 ms 击败 5.26%\r\n- 内存 15.2 MB 击败 63.16%","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437009800","body":"# **0061. 旋转链表**\r\n\r\n# 题目\r\n\r\n```python\r\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\r\n\r\n示例 1：\r\n输入：head = [1,2,3,4,5], k = 2\r\n输出：[4,5,1,2,3]\r\n\r\n示例 2：\r\n输入：head = [0,1,2], k = 4\r\n输出：[2,0,1]\r\n```\r\n\r\n# 思路\r\n\r\n- 通过计算链表长度，可以将缩小 k\r\n1. 将 old tail node 的 next 设置为 old head\r\n2. 读取目标两个节点【只有两个节点，因此不必使用 queue】\r\n    1. 第一个节点的 next 设置为 None，即为 new tail node\r\n    2. 第二个节点为 new head\r\n\r\n![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302202103122.png](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302202103122.png)\r\n\r\n# 代码\r\n\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if k==0 or not head:\r\n            return head\r\n\r\n        # 0. Calculate len and reduce k\r\n        Len, cur = 0, head\r\n        while cur:\r\n            Len += 1\r\n            prev, cur = cur, cur.next            \r\n        k %= Len\r\n            \r\n        # 1. Link old tail node to head\r\n        prev.next = head\r\n                \r\n        # 2. Find target nodes      \r\n        new_tail, new_head = None, None\r\n        cur_idx, cur = 0, head\r\n        while cur_idx <= Len-k:\r\n            new_tail, new_head = new_head, cur            \r\n            cur_idx, cur = cur_idx+1, cur.next\r\n        # 2.1 Link new tail node to None\r\n        new_tail.next = None\r\n        # 3.2 Return new head\r\n        return new_head\r\n```\r\n\r\n- 时间复杂度：O(N)，N 为链表长度\r\n- 空间复杂度：O(1)\r\n- 时间 36 ms 击败 86.77%\r\n- 内存 14.8 MB 击败 95.47%","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438015489","body":"# ****0024. 两两交换链表中的节点****\r\n\r\n# 题目\r\n\r\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\r\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\r\n\r\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8196ab83-ec41-43d3-b270-f2598e1238b9/Untitled.png)\r\n\r\n```python\r\n示例 1：\r\n输入：head = [1,2,3,4]\r\n输出：[2,1,4,3]\r\n\r\n示例 2：\r\n输入：head = []\r\n输出：[]\r\n\r\n示例 3：\r\n输入：head = [1]\r\n输出：[1]\r\n\r\n提示：\r\n链表中节点的数目在范围 [0, 100] 内\r\n0 <= Node.val <= 100\r\n```\r\n\r\n# 思路1\r\n\r\n- 观察规律，如图所示\r\n- 首先排除没有任何 node 或者只有一个 node 的链表\r\n- 对于起码有两个 node 的链表，轮流记录 first node 和 second node，反复进行 step 1～2 操作\r\n- 直到没有 new_first（偶数链表）或者没有 new_first.next（奇数链表），进行 step 3 操作\r\n\r\n![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302211600438.jpeg](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302211600438.jpeg)\r\n\r\n# 代码1\r\n\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        \"\"\"\r\n        用递归实现链表相邻互换：\r\n        第一个节点的 next 是第三、第四个节点交换的结果，第二个节点的 next 是第一个节点；\r\n        第三个节点的 next 是第五、第六个节点交换的结果，第四个节点的 next 是第三个节点；\r\n        以此类推\r\n        :param ListNode head\r\n        :return ListNode\r\n        \"\"\"\r\n        if not head or not head.next:\r\n            return head\r\n                \r\n        first = head\r\n        second = head.next\r\n        new_head = second\r\n        \r\n        while True:\r\n            new_first = second.next\r\n            # step 1. link `sencod` to `first`\r\n            second.next = first\r\n            # step 3, return `new_head` when come to the end\r\n            if not new_first or not new_first.next:\r\n                first.next = new_first\r\n                return new_head\r\n            # step 2. link `first` to `new_second`\r\n            else:                \r\n                first.next = new_first.next                \r\n            # move forward, repeat step 1~2 until step 3\r\n            first = new_first\r\n            second = new_first.next\r\n```\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n\r\n# 思路2：递归\r\n\r\n- 用递归实现链表相邻互换：\r\n    - 第一个节点的 next 是第三、第四个节点交换的结果，\r\n        - 第二个节点的 next 是第一个节点；\r\n    - 第三个节点的 next 是第五、第六个节点交换的结果，\r\n        - 第四个节点的 next 是第三个节点；\r\n- 以此类推\r\n\r\n# 代码2\r\n\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        \"\"\"\r\n        用递归实现链表相邻互换：\r\n        第一个节点的 next 是第三、第四个节点交换的结果，第二个节点的 next 是第一个节点；\r\n        第三个节点的 next 是第五、第六个节点交换的结果，第四个节点的 next 是第三个节点；\r\n        以此类推\r\n        :param ListNode head\r\n        :return ListNode\r\n        \"\"\"\r\n        # 如果为 None 或 next 为 None，则直接返回\r\n        if not head or not head.next:\r\n            return head\r\n\r\n        _next = head.next                      # 第二个节点\r\n        head.next = self.swapPairs(_next.next) # 第一个节点的 next 是：第三、第四个节点交换的结果\r\n        _next.next = head                      # 第二个节点的 next 是：第一个节点\r\n        return _next\r\n```\r\n\r\n- 时间复杂度：O(N)，所有节点只遍历一遍\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440038295","body":"# **0109. 有序链表转换二叉搜索树**\r\n\r\n# 题目\r\n\r\n```python\r\n给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。\r\n\r\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。\r\n\r\n示例 1:\r\n输入: head = [-10,-3,0,5,9]\r\n输出: [0,-3,9,-10,null,5]\r\n解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。\r\n示例 2:\r\n\r\n输入: head = []\r\n输出: []\r\n```\r\n\r\n# 思路1：链表→数组→BST\r\n\r\n- 首先链表转数组，将问题转换为有序数组到BST的问题\r\n- 再根据左右索引，递归建立 BST\r\n\r\n![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302221730672.jpeg](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302221730672.jpeg)\r\n\r\n# 代码\r\n\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head: return None\r\n\r\n        # linklist to list\r\n        node = head\r\n        n = 0\r\n        nums = []\r\n        while node:\r\n            nums.append(node.val)\r\n            n += 1\r\n            node = node.next\r\n        \r\n        def list_to_BST(L, center_idx, R):\r\n            # L: close, R: close\r\n            left_idx = (L+center_idx-1) // 2  \r\n            right_idx = (R+center_idx+1) // 2\r\n\r\n            center = TreeNode(val=nums[center_idx])\r\n            if left_idx!=center_idx and left_idx>=L:\r\n                center.left = list_to_BST(L, left_idx, center_idx-1)\r\n            if right_idx!=center_idx and right_idx<=R:\r\n                center.right = list_to_BST(center_idx+1, right_idx, R)\r\n            return center\r\n\r\n        return list_to_BST(0, n//2, n-1)\r\n```\r\n\r\n- 时间复杂度：O(n)，每个数字都得经历一次\r\n- 空间复杂度：O(n)，转换为数组所占用的空间，n为节点数量\r\n- 时间 64 ms 击败 81%\r\n- 内存 21.5 MB 击败 5.18%","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1440489330","body":"# ****0160. 相交链表****\r\n\r\n# 题目\r\n\r\n![Screen Shot 2022-06-28 at 21.12.22.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c5797b21-f982-419f-80d4-4b70548ce765/Screen_Shot_2022-06-28_at_21.12.22.png)\r\n\r\n# 思路1：正向遍历 + 逆向遍历\r\n\r\n- 分别遍历 A、B，储存为 list\r\n- 逆向遍历 list，直到相等\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        A, B = [], []\r\n        while headA:\r\n            A.append(headA)\r\n            headA = headA.next\r\n        while headB:\r\n            B.append(headB)\r\n            headB = headB.next\r\n        \r\n        ans = None\r\n        for i in range(-1, -min(len(A)+1, len(B)+1), -1):\r\n            if A[i]==B[i]:\r\n                ans = A[i]        \r\n        return ans\r\n```\r\n\r\n- 时间复杂度：O(m+n)\r\n- 空间复杂度：O(m+n)\r\n\r\n# 思路2：哈希化\r\n\r\n有 A, B 这两条链表, 先遍历其中一个，比如 A 链表, 并将 A 中的所有节点存入哈希表。\r\n遍历 B 链表,检查节点是否在哈希表中, 第一个存在的就是相交节点\r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        A = set()\r\n        while headA:\r\n            A.add(headA)\r\n            headA = headA.next\r\n                \r\n        while headB:\r\n            if headB in A:\r\n                return headB\r\n            headB = headB.next\r\n\r\n        return None\r\n```\r\n\r\n- 时间复杂度：O(m+n)\r\n- 空间复杂度：O(m)\r\n\r\n# 思路3：双指针 （A+C+B = B+C+A）\r\n\r\n例如使用 a, b 两个指针分别指向 A, B 这两条链表, 两个指针相同的速度向后移动,\r\n\r\n- 当 a 到达链表的尾部时,重定位到链表 B 的头结点\r\n- 当 b 到达链表的尾部时,重定位到链表 A 的头结点。\r\n- a, b 指针相遇的点为相交的起始节点，否则没有相交点\r\n\r\n![https://tva1.sinaimg.cn/large/007S8ZIlly1gfig7vsvwhj30bs05z3yl.jpg](https://tva1.sinaimg.cn/large/007S8ZIlly1gfig7vsvwhj30bs05z3yl.jpg)\r\n\r\n为什么 a, b 指针相遇的点一定是相交的起始节点? 我们证明一下：\r\n\r\n> 1. 将两条链表按相交的起始节点继续截断，链表 1 为: A + C，链表 2 为: B + C\r\n2. 当 a 指针将链表 1 遍历完后,重定位到链表 B 的头结点,然后继续遍历直至相交点(a 指针遍历的距离为 A + C + B)\r\n3. 同理 b 指针遍历的距离为 B + C + A\r\n> \r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a, b = headA, headB\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA\r\n        return a\r\n```\r\n\r\n- 时间复杂度：O(m+n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443878608","body":"# 0**142. 环形链表 II**\r\n\r\n# 题目\r\n\r\n```python\r\n给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\r\n\r\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\r\n\r\n不允许修改 链表\r\n```\r\n\r\n```python\r\n示例 1：\r\n输入：head = [3,2,0,-4], pos = 1\r\n输出：返回索引为 1 的链表节点\r\n解释：链表中有一个环，其尾部连接到第二个节点。\r\n```\r\n\r\n![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302242227952.png](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302242227952.png)\r\n\r\n```python\r\n示例 2：\r\n输入：head = [1,2], pos = 0\r\n输出：返回索引为 0 的链表节点\r\n解释：链表中有一个环，其尾部连接到第一个节点。\r\n```\r\n\r\n![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302242228606.png](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302242228606.png)\r\n\r\n```python\r\n示例 3：\r\n输入：head = [1], pos = -1\r\n输出：返回 null\r\n解释：链表中没有环。\r\n```\r\n\r\n![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302242229835.png](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302242229835.png)\r\n\r\n# 思路1: 哈希表\r\n\r\n- 遍历链表，并存入哈希表\r\n- 当节点重复出现时，即为答案\r\n\r\n# 代码1\r\n\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return None\r\n        nodes = set()\r\n        node = head\r\n        while node:\r\n            if node in nodes:\r\n                return node\r\n            nodes.add(node)\r\n            node = node.next\r\n```\r\n\r\n- 时间复杂度：O(N)，遍历所有节点\r\n- 空间复杂度：O(N)，储存所有节点\r\n- 时间 52 ms 击败 78.83%\r\n- 内存 19.1 MB 击败 7.20%","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1444248163","body":"# 题目\r\n\r\n```python\r\n请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。\r\n实现 LRUCache 类：\r\nLRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存\r\nint get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\r\nvoid put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。\r\n**函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。**\r\n\r\n示例：\r\n\r\n输入\r\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\r\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\r\n输出\r\n[null, null, null, 1, null, -1, null, -1, 3, 4]\r\n\r\n解释\r\nLRUCache lRUCache = new LRUCache(2);\r\nlRUCache.put(1, 1); // 缓存是 {1=1}\r\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\r\nlRUCache.get(1);    // 返回 1\r\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\r\nlRUCache.get(2);    // 返回 -1 (未找到)\r\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\r\nlRUCache.get(1);    // 返回 -1 (未找到)\r\nlRUCache.get(3);    // 返回 3\r\nlRUCache.get(4);    // 返回 4\r\n```\r\n\r\n# 关键点：**函数 get 和 put 必须以 O(1) 的平均时间复杂度运行**\r\n\r\n# 思路：双向链表+哈希表\r\n\r\n- 双向链表：tail.prev 为 latest node，当full时删除 head.next\r\n- 哈希表：用于储存 node，避免链表查询的线性复杂度\r\n\r\n# 代码\r\n\r\n```python\r\nclass Node:\r\n    def __init__(self, key, val):\r\n        self.key = key\r\n        self.val = val\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):        \r\n        self.nums = 0\r\n        self.capacity = capacity        \r\n        # lookup table, {key: key, value: node}\r\n        self.lookup = dict()  \r\n        # doubly linkedlist, [head<->old_node<->new_node<->tail]\r\n        self.head = Node(None, None)\r\n        self.tail = Node(None, None)\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.lookup:\r\n            return -1\r\n        # 1. get the node\r\n        node = self.lookup[key]\r\n        # 2. remove node\r\n        self.remove(node)\r\n        # 3. add node to the tail\r\n        self.add_to_tail(node)\r\n        return node.val\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        # 1. remove the old node, if exist\r\n        if key in self.lookup:\r\n            self.remove(self.lookup[key])\r\n            self.nums -= 1\r\n        # 2. remove oldest node if full\r\n        if self.nums == self.capacity:\r\n            self.remove(self.head.next)\r\n            self.nums -= 1\r\n        # 3. add the node to the tail\r\n        self.add_to_tail(Node(key, value))\r\n        self.nums += 1\r\n\r\n    def remove(self, node):\r\n        # remove node from lookup and doubly linkedlist\r\n        del self.lookup[node.key]\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def add_to_tail(self, node):\r\n        # add node to lookup and the tail (before tail)\r\n        self.lookup[node.key] = node\r\n        pre_tail = self.tail.prev\r\n        node.next = self.tail\r\n        self.tail.prev = node\r\n        pre_tail.next = node\r\n        node.prev = pre_tail\r\n```\r\n\r\n- 时间复杂度：都是 O(1)\r\n- 空间复杂度：O(N), N 为 capacity\r\n- 时间 604 ms 击败 63.9%\r\n- 内存 75.7 MB 击败 5.1%","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445145563","body":"# ****0104. 二叉树的最大深度****\r\n\r\n# 题目\r\n\r\n```python\r\n给定一个二叉树，找出其最大深度。\r\n\r\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\r\n\r\n说明: 叶子节点是指没有子节点的节点。\r\n\r\n示例：\r\n给定二叉树 [3,9,20,null,null,15,7]，\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n返回它的最大深度 3 。\r\n```\r\n\r\n# DFS\r\n\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        def DFS(root, depth):\r\n            if root is not None:\r\n                depth+=1\r\n                L = DFS(root.left, depth)\r\n                R = DFS(root.right, depth)\r\n                return max(L, R)\r\n            else:\r\n                return depth\r\n        return DFS(root, 0)\r\n```\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(height)\r\n\r\n# BFS\r\n\r\n```python\r\nfrom queue import Queue\r\nclass Solution(object):\r\n    def maxDepth(self, root):\r\n        if not root: return 0\r\n        queue = Queue()\r\n        queue.put(root)\r\n        height = 0\r\n\r\n        while not queue.empty():\r\n            currentSize = queue.qsize()\r\n            for i in range(currentSize):\r\n                node = queue.get()\r\n                if node.left: queue.put(node.left)\r\n                if node.right: queue.put(node.right)\r\n            height += 1\r\n            \r\n        return height\r\n```\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446035536","body":"# **0100. 相同的树**\r\n\r\n# 题目\r\n\r\n```python\r\n给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。\r\n\r\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\r\n```\r\n\r\n# 思路\r\n\r\n- 同时对两棵树进行 DFS，并比较节点值，若不相同则 False，相同则继续 DFS\r\n\r\n# 代码\r\n\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n\r\n        # DFS \r\n        def is_same_node(node1, node2):\r\n            # 1. 都为 None，返回 True\r\n            if not node1 and not node2:\r\n                return True\r\n            # 2. 都不为 None\r\n            elif node1 and node2:\r\n                # 2.1 值不相同，返回 Flase\r\n                if node1.val != node2.val:\r\n                    return False\r\n                # 2.2 值相同，继续 DFS\r\n                else:\r\n                    if not is_same_node(node1.left, node2.left) or not is_same_node(node1.right, node2.right):\r\n                        return False\r\n                    else:\r\n                        return True\r\n            # 3. 一个为 None 一个不为 None，返回 False\r\n            else:\r\n                return False\r\n\r\n        return is_same_node(p, q)\r\n```\r\n\r\n- 时间复杂度：O(N)，其中 N 为树的节点数\r\n- 空间复杂度：O(N)，其中 N 为树的节点数，当二叉树中每个节点只有一个孩子节点时，递归的层数为 N，此时空间复杂度为 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447682482","body":"# **0129. 求根节点到叶节点数字之和**\r\n\r\n# 题目\r\n\r\n```python\r\n给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。\r\n每条从根节点到叶节点的路径都代表一个数字：\r\n\r\n例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。\r\n计算从根节点到叶节点生成的 所有数字之和 。\r\n\r\n叶节点 是指没有子节点的节点。\r\n```\r\n\r\n![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302281459112.png](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302281459112.png)\r\n\r\n```python\r\n输入：root = [1,2,3]\r\n输出：25\r\n解释：\r\n从根到叶子节点路径 1->2 代表数字 12\r\n从根到叶子节点路径 1->3 代表数字 13\r\n因此，数字总和 = 12 + 13 = 25\r\n```\r\n\r\n# 思路：DFS\r\n\r\n- 使用字符串 num 储存向下过程中的 数字\r\n- 但触及底部时，将数字 num 加入sum，并删去最后一位 num[:-1]，回溯\r\n\r\n# 代码\r\n\r\n```python\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n\r\n        def dfs(node, num, Sum):\r\n            if not node: return Sum\r\n            if not node.left and not node.right: \r\n                num += str(node.val)\r\n                Sum += int(num)\r\n                num = num[:-1]\r\n            else:\r\n                num += str(node.val)          \r\n                Sum = dfs(node.left, num, Sum)\r\n                Sum = dfs(node.right, num, Sum)\r\n            return Sum  \r\n            \r\n        return dfs(root, \"\", 0)\r\n```\r\n\r\n- 时间复杂度：O(n)，遍历所有点\r\n- 空间复杂度：O(h)，递归过程中的stack，h 为树的高度\r\n- 时间 24 ms 击败 99.64%\r\n- 内存 14.9 MB 击败 63.95%","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449578843","body":"# **0513. 找树左下角的值**\r\n\r\n# 题目\r\n\r\n```python\r\n给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。\r\n\r\n假设二叉树中至少有一个节点。\r\n```\r\n\r\n![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202303011638795.png](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202303011638795.png)\r\n\r\n```python\r\n输入: [1,2,3,4,null,5,6,null,null,7]\r\n输出: 7\r\n```\r\n\r\n# 思路：BFS\r\n\r\n- BFS 遍历每一层，保留每一层最左侧的值\r\n- **tips: 通过每次对 queue 求 len，可以得到当前遍历层的节点个数**\r\n\r\n# 代码\r\n\r\n```python\r\nfrom collections import deque\r\nclass Solution:\r\n    def findBottomLeftValue(self, root):\r\n        queue = deque()\r\n        queue.append(root)\r\n        while queue:\r\n            length = len(queue)\r\n            res = queue[0].val\r\n            for _ in range(length):\r\n                cur = queue.popleft()\r\n                if cur.left:  queue.append(cur.left)\r\n                if cur.right: queue.append(cur.right)\r\n        return res\r\n```\r\n\r\n- 时间复杂度：O(n)，n 为节点个数\r\n- 空间复杂度：O(n)，n 为节点个数，当二叉树为平衡二叉树时，最后一层将会有 2/n+1 个节点，此时空间复杂度为 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451577105","body":"# 题目\r\n\r\n```python\r\n序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\r\n\r\n请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\r\n```\r\n\r\n**示例 1：**\r\n\r\n![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202303021655826.png](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202303021655826.png)\r\n\r\n```python\r\n输入：root = [1,2,3,null,null,4,5]\r\n\r\nser = Codec()\r\ndeser = Codec()\r\nprint(ser.serialize(root))\r\n# \"1,2,3,null,null,4,5\"\r\n\r\nans = deser.deserialize(ser.serialize(root))\r\n# [1,2,3,null,null,4,5]\r\n```\r\n\r\n# 思路\r\n\r\n## 序列化\r\n\r\n- 与 BFS 相同，但对于 null 节点依然需要记录，用于后续恢复原有 tree\r\n\r\n## 反序列化\r\n\r\n- 一开始的想法为使用数组表示二叉树，并用下标寻找节点对应的 left 和 right node，如【即 node 走一步、则 left 和 right 走两步】\r\n    - node = A[i]\r\n    - node.left = A[i*2]\r\n    - node.right = A[i*2+1]\r\n- 其存在问题是，这个下标规则是基于**完全二叉树**的，而这里是**普通二叉树**\r\n\r\n![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202303021721777.png](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202303021721777.png)\r\n\r\n- 因此需要修改为当 parent 为非 None 时，left 和 right 才走\r\n\r\n```python\r\ncurr_idx = 0\r\nleft_idx = 1\r\nright_idx = 2\r\n\r\nwhile curr_idx < len(data):\r\n    if nodes[curr_idx]:\r\n        # 当 curr 不为 None 时，链接 left ，同时 left 前进两步\r\n        if left_idx < len(data): \r\n            nodes[curr_idx].left = nodes[left_idx]\r\n            left_idx += 2\r\n        # 当 curr 不为 None 时，链接 right ，同时 right 前进两步\r\n        if right_idx < len(data): \r\n            nodes[curr_idx].right = nodes[right_idx]\r\n            right_idx += 2\r\n    # curr 永远向前走一步\r\n    curr_idx += 1\r\n```\r\n\r\n# 代码\r\n\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nfrom collections import deque\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        queue = deque([root])\r\n        result = \"\"\r\n        while queue:\r\n            node = queue.popleft()\r\n            if node:\r\n                result += str(node.val)+\",\"\r\n                queue.append(node.left)\r\n                queue.append(node.right)\r\n            else:\r\n                # 除了这里不一样，其他和普通的不记录层的 BFS 没区别\r\n                result += \"null,\"\r\n        # 删除末尾多余的 null\r\n        while result[-5:]==\"null,\":\r\n            result = result[:-5]\r\n        # 末尾会多一个逗号，我们去掉它。\r\n        return result[:-1]\r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if data == \"\": return None\r\n        data = data.split(',')\r\n        nodes = {}\r\n        for i, val in enumerate(data):\r\n            nodes[i] = TreeNode(int(val)) if val!=\"null\" else None\r\n        curr_idx, left_idx, right_idx = 0, 1, 2\r\n        while curr_idx < len(data):\r\n            if nodes[curr_idx]:\r\n                # 当 curr 不为 None 时，链接 left ，同时 left 前进两步\r\n                if left_idx < len(data): \r\n                    nodes[curr_idx].left = nodes[left_idx]\r\n                    left_idx += 2\r\n                # 当 curr 不为 None 时，链接 right ，同时 right 前进两步\r\n                if right_idx < len(data): \r\n                    nodes[curr_idx].right = nodes[right_idx]\r\n                    right_idx += 2\r\n            # curr 永远向前走一步\r\n            curr_idx += 1\r\n        \r\n        return nodes[0]\r\n        \r\n\r\n# Your Codec object will be instantiated and called as such:\r\n# ser = Codec()\r\n# deser = Codec()\r\n# ans = deser.deserialize(ser.serialize(root))\r\n```\r\n\r\n- 时间复杂度：\r\n    - serialize：O(n)，n 为节点数量\r\n    - deserialize：O(n)，n 为节点数量\r\n- 空间复杂度：\r\n    - serialize：O(h)，h 为树高度，最坏情况为链表，此时复杂度为 O(n)\r\n    - deserialize：O(n)，dict 大小，n 为节点数量","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453076144","body":"# **0987. 二叉树的垂序遍历**\r\n\r\n# 题目\r\n\r\n```python\r\n给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。\r\n\r\n对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。\r\n\r\n二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。\r\n\r\n返回二叉树的 垂序遍历 序列。\r\n```\r\n\r\n![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202303031455867.png](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202303031455867.png)\r\n\r\n```python\r\n输入：root = [1,2,3,4,5,6,7]\r\n输出：[[4],[2],[1,5,6],[3],[7]]\r\n解释：\r\n列 -2 ：只有结点 4 在此列中。\r\n列 -1 ：只有结点 2 在此列中。\r\n列  0 ：结点 1 、5 和 6 都在此列中。\r\n          1 在上面，所以它出现在前面。\r\n          5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。\r\n列  1 ：只有结点 3 在此列中。\r\n列  2 ：只有结点 7 在此列中。\r\n```\r\n\r\n# 思路\r\n\r\n- 首先 DFS 遍历全部点，并按照 [col][row] 保存值\r\n- 再根据 col、row 对值进行排序输出\r\n\r\n![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202303031500190.png](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202303031500190.png)\r\n\r\n# 代码\r\n\r\n```python\r\nfrom collections import defaultdict\r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n\r\n        hashmap = defaultdict(lambda: defaultdict(lambda:[]))\r\n\r\n        def dfs(node, row, col):\r\n            if not node: return\r\n            # print(node.val, row, col)\r\n            hashmap[col][row].append(node.val)            \r\n            dfs(node.left, row+1, col-1)\r\n            dfs(node.right, row+1, col+1)            \r\n\r\n        dfs(root, 0, 0)\r\n        result = []\r\n        for col in sorted(hashmap):\r\n            temp = []\r\n            for row in sorted(hashmap[col]):\r\n                temp += sorted(hashmap[col][row])\r\n            result.append(temp)\r\n        return result\r\n```\r\n\r\n- 时间复杂度：O(NlogN)，排序复杂度，N为节点数量\r\n    - 虽然有三次排序，但是并不是每次循环都将所有的节点遍历一次，因此复杂度不需要三次方\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454754391","body":"# 0001. 两数之和\n\n# 题目\n\n```python\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n示例:\n\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n```\n\n# 代码\n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        gap = {}\n        for idx, num in enumerate(nums):\n            if target-num in gap:\n                return [gap[target-num], idx]\n            else:\n                gap[num] = idx\n```\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455022444","body":"# **0347. 前 K 个高频元素**\n\n# 题目\n\n```python\n给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\n\n示例 1:\n输入: nums = [1,1,1,2,2,3], k = 2\n输出: [1,2]\n\n示例 2:\n输入: nums = [1], k = 1\n输出: [1]\n```\n\n# 思路\n\n- 使用哈希表遍历记录频次\n- 排序选出 top k\n\n# 代码\n\n```python\nfrom collections import defaultdict\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        freq = defaultdict(lambda: 0)              \n        for num in nums:\n            freq[num] += 1\n        freq = sorted(freq.items(), key=lambda t:t[1], reverse=True)\n        return [freq[i][0] for i in range(k)]\n```\n\n- 时间复杂度：O(NlogN)，排序复杂度，N 为数组长度\n- 空间复杂度：O(N)，哈希表占用空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456292245","body":"# **0447. 回旋镖的数量**\r\n\r\n# 题目\r\n\r\n```python\r\n给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的欧式距离相等（需要考虑元组的顺序）。\r\n\r\n返回平面上所有回旋镖的数量。\r\n\r\n \r\n示例 1：\r\n输入：points = [[0,0],[1,0],[2,0]]\r\n输出：2\r\n解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]\r\n\r\n示例 2：\r\n输入：points = [[1,1],[2,2],[3,3]]\r\n输出：2\r\n\r\n示例 3：\r\n输入：points = [[1,1]]\r\n输出：0\r\n```\r\n\r\n# 思路\r\n\r\n- 回旋镖 [a, b, c]， 即以 a 为中心， len(a, b) == len(a, c)，且需要考虑顺序（排列数）\r\n- 寻找与某一个点距离相同的点的排列组合个数，以下图 2 为中心点为例\r\n    - 距离为 2 的点有：1, 3, 4，则其回旋镖数量为 A_3^2=6\r\n    - 距离为 sqrt(8) 的点有：5, 6，则其旋镖数量为 A_4^2=12\r\n- 因此只需要遍历每一行，并计算相同数量以及对应排列数即可\r\n\r\n![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202303062250482.png](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202303062250482.png)\r\n\r\n# 代码\r\n\r\n```python\r\nfrom collections import Counter\r\nfrom math import factorial\r\n\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        if len(points)<3: return 0\r\n        \r\n        def cal_distance(p1: List[int], p2: List[int]):\r\n            return ((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)**(1/2)\r\n\r\n        def permutation(n, m=2):\r\n            return factorial(n)//factorial(n-m) if n>=2 else 0\r\n        \r\n        result = 0\r\n        for p1 in points:\r\n            distances = []\r\n            for p2 in points:\r\n                distances.append(cal_distance(p1, p2))\r\n            counter = Counter(distances) # hashmap\r\n            for n in counter.values():\r\n                result += permutation(n)\r\n        return result\r\n```\r\n\r\n- 时间复杂度：O(N^2)，N 为points长度\r\n- 空间复杂度：O(N)，临时数组的占用空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457673591","body":"# ****0003. 无重复字符的最长子串****\n\n# 题目\n\n```python\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n示例 1:\n\n输入: \"abcabcbb\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n示例 2:\n\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n示例 3:\n\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n# 思路\n\n- 通过观察一下结果可以发现\n    \n    ![Screen Shot 2022-04-14 at 19.43.12.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/64db0782-9c4e-40d0-8076-826d099982cd/Screen_Shot_2022-04-14_at_19.43.12.png)\n    \n    随着左起点的递增，最长字符串的右节点是非减的，因此可以用滑动窗口\n    \n    ![https://tva1.sinaimg.cn/large/007S8ZIlly1ghlubou8hhg30no0dbjvw.gif](https://tva1.sinaimg.cn/large/007S8ZIlly1ghlubou8hhg30no0dbjvw.gif)\n    \n    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/47847b79-dff8-4894-a07e-e73e70992893/Untitled.png)\n    \n\n# 关键点\n\n- 维护一个**滑动窗口**，窗口内的都是没有重复的字符，去尽可能的扩大窗口的大小，窗口不停的向右滑动。\n- 使用**哈希表**来储存窗口，方面查找元素是否在窗口中出现\n\n# 代码\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        n = len(s)\n        R, ans = 0, 0\n        window = set() # hashmap\n        for L in range(n):\n            if L!=0: window.remove(s[L-1])  # delete previous left element in window\n            while R<n and s[R] not in window:   # if right element not in window\n                window.add(s[R])                # add it into the window\n                R+=1                            # move right arrow to next\n            ans = max(ans, R-L)                 # notice that R already +1\n        return ans\n```\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460338468","body":"# **0030. 串联所有单词的子串**\n\n# 题目\n\n```python\n给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。\n\n s 中的 串联子串 是指一个包含  words 中所有字符串以任意顺序排列连接起来的子串。\n\n例如，如果 words = [\"ab\",\"cd\",\"ef\"]， 那么 \"abcdef\"， \"abefcd\"，\"cdabef\"， \"cdefab\"，\"efabcd\"， 和 \"efcdab\" 都是串联子串。 \"acdbef\" 不是串联子串，因为他不是任何 words 排列的连接。\n返回所有串联字串在 s 中的开始索引。你可以以 任意顺序 返回答案。\n\n \n\n示例 1：\n输入：s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n输出：[0,9]\n解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。\n子串 \"barfoo\" 开始位置是 0。它是 words 中以 [\"bar\",\"foo\"] 顺序排列的连接。\n子串 \"foobar\" 开始位置是 9。它是 words 中以 [\"foo\",\"bar\"] 顺序排列的连接。\n输出顺序无关紧要。返回 [9,0] 也是可以的。\n\n示例 2：\n输入：s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n输出：[]\n解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。\ns 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。\n所以我们返回一个空数组。\n\n示例 3：\n输入：s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n输出：[6,9,12]\n解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。\n子串 \"foobarthe\" 开始位置是 6。它是 words 中以 [\"foo\",\"bar\",\"the\"] 顺序排列的连接。\n子串 \"barthefoo\" 开始位置是 9。它是 words 中以 [\"bar\",\"the\",\"foo\"] 顺序排列的连接。\n子串 \"thefoobar\" 开始位置是 12。它是 words 中以 [\"the\",\"foo\",\"bar\"] 顺序排列的连接。\n```\n\n# 关键点\n\n- words 中每个单词长度相同\n- words 中元素可能重复，因此不能直接比较\n- s 中可能包含其他 words 中没有的元素（因此不能跳跃，需要一个一个遍历）\n\n![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202303082317211.png](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202303082317211.png)\n\n# 思路\n\n- 每次前进一步，维护一个长度为与 words 中单词总长度（total_len）相同的窗口\n- 判断窗口中的单词与目标words是否包含相同元素，以及对应的数量是否相同\n\n# 代码\n\n```python\nfrom collections import Counter\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        word_len = len(words[0])\n        total_len = word_len * len(words)       # 所有词的长度相同\n        if len(s) < total_len: return []\n        words_set = set(words)              # 用于快速判断是否包含相同元素\n        words_counter = Counter(words)      # 用于对比两者所含元素数量是否相同\n        result = []\n        for L in range(len(s)-total_len+1):\n            curr_str = s[L: L+total_len]\n            curr_words = [curr_str[i:i+word_len] for i in range(0, total_len, word_len)]\n            # 如果包含有相同元素且数量相同，则加入 result\n            if set(curr_words) == words_set and Counter(curr_words) == words_counter:\n                result.append(L)\n        return result\n```\n\n- 时间复杂度：O(total_len*word_len)，两次循环\n- 空间复杂度：O(len(words))，单词个数，哈希表占用空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462301187","body":"```\r\nclass Solution:\r\n    def minSubarray(self, nums: List[int], p: int) -> int:\r\n        x = sum(nums) % p\r\n        if x == 0:\r\n            return 0\r\n        y = 0\r\n        index = {0: -1}\r\n        ans = len(nums)\r\n        for i, v in enumerate(nums):\r\n            y = (y + v) % p\r\n            if (y - x) % p in index:\r\n                ans = min(ans, i - index[(y - x) % p])\r\n            index[y] = i\r\n        return ans if ans < len(nums) else -1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463961901","body":"# 0**876. 链表的中间结点**\n\n# 题目\n\n给你单链表的头结点 `head` ，请你找出并返回链表的中间结点。\n\n如果有两个中间结点，则返回第二个中间结点。\n\n**示例 1：**\n\n![https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg](https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg)\n\n```\n输入：head = [1,2,3,4,5]\n输出：[3,4,5]\n解释：链表只有一个中间结点，值为 3 。\n\n```\n\n**示例 2：**\n\n![https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg](https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg)\n\n```\n输入：head = [1,2,3,4,5,6]\n输出：[4,5,6]\n解释：该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。\n\n```\n\n# 思路：快慢指针\n\n1. 定义一个快指针每步前进两个节点，一个慢指针每步前进一个节点\n2. 当快指针到达尾部的时候，正好慢指针所到的点为中点\n\n# 代码\n\n```python\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast = slow = head\n        while fast.next and fast.next.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow.next if fast.next else slow\n```\n\n- 时间复杂度：O(N)，N 为节点数量\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464862660","body":"# 代码\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        n = Len = len(nums)\n        read = write = 0\n        while write<n:\n            if nums[read]!=nums[write]:\n                read += 1\n                nums[read] = nums[write]\n            write += 1\n        return read+1\n```\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465107027","body":"# 00**35. 搜索插入位置**\n\n# 题目\n\n```python\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n请必须使用时间复杂度为 O(log n) 的算法。\n\n \n\n示例 1:\n输入: nums = [1,3,5,6], target = 5\n输出: 2\n\n示例 2:\n输入: nums = [1,3,5,6], target = 2\n输出: 1\n\n示例 3:\n输入: nums = [1,3,5,6], target = 7\n输出: 4\n```\n\n# 思路：二分搜索\n\n# 代码\n\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        L, R = 0, len(nums)-1 # both closed\n        while L<R:\n            M = (L+R) // 2\n            if nums[M] == target:\n                return M\n            elif nums[M] > target:\n                R = M-1\n            else:\n                L = M+1\n        \n        return L+1 if nums[L] < target else L\n```\n\n- 时间复杂度：O(logN)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466209571","body":"# 0**239. 滑动窗口最大值**\n\n# 题目\n\n```python\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n\n返回 滑动窗口中的最大值 。\n\n \n\n示例 1：\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n输出：[3,3,5,5,6,7]\n解释：\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n\n示例 2：\n输入：nums = [1], k = 1\n输出：[1]\n```\n\n# 思路\n\n- 使用 MaxHeap 来维护窗口内的元素\n- 当窗口移动时添加滑动窗口后一个数\n    - 在 push 的时候加入 index 信息（(nums[i], i)），用于筛选窗口内的最大值\n- 在返回栈顶元素（最大值）之前，删除不在窗口内的栈顶元素\n\n# 注意点\n\n- python 中的 heapq 为 MinHeap，因此在入栈以及出栈时需要加符号，以变为 MaxHeap\n- 在入栈时增加 index 信息（(nums[i], i)），用于筛选窗口内的最大值\n\n# 代码\n\n```python\nimport heapq\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        max_heap=[]\n        ans=[]\n\n        # heapq 默认为 min heap，因此需要取负号变为 max heap\n        for i in range(k):\n            heapq.heappush(max_heap,(-nums[i],i))\n        # 栈顶（max_heap[0]）为最大元素\n        ans.append(-max_heap[0][0])\n\n        for i in range(k,len(nums)):\n            # 删除out date的数据，保证栈顶元素落入窗口内\n            while max_heap and max_heap[0][1]<i-k+1:\n                heapq.heappop(max_heap)\n            # 加入新元素\n            heapq.heappush(max_heap,(-nums[i],i))\n            # 栈顶（max_heap[0]）为最大元素\n            ans.append((-max_heap[0][0]))\n        return ans\n```\n\n- 时间复杂度：O(n*logK)：insert 复杂度 O(logK)\n- 空间复杂度：O(K)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467517383","body":"# 0**997. 找到小镇的法官**\n\n# 题目\n\n```python\n小镇里有 n 个人，按从 1 到 n 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。\n\n如果小镇法官真的存在，那么：\n\n小镇法官不会信任任何人。\n每个人（除了小镇法官）都信任这位小镇法官。\n只有一个人同时满足属性 1 和属性 2 。\n给你一个数组 trust ，其中 trust[i] = [ai, bi] 表示编号为 ai 的人信任编号为 bi 的人。\n\n如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 -1 。\n\n示例 1：\n输入：n = 2, trust = [[1,2]]\n输出：2\n\n示例 2：\n输入：n = 3, trust = [[1,3],[2,3]]\n输出：3\n\n示例 3：\n输入：n = 3, trust = [[1,3],[2,3],[3,1]]\n输出：-1\n```\n\n# 思路1：哈希表\n\n![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202303141516838.png](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202303141516838.png)\n\n- 从题目可知，`judge: 被所有人信任但不信任任何人`\n- 因此可以用哈希表保存潜在的 judge，\n    - 若其相信其他人，则不是 judge\n    - 最终如果被其他所有人信任，则是 judge\n\n# 代码1\n\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        # judge: 被所有人信任，但不信任任何人\n        judges = {}\n        for i in range(1, n+1):\n            judges[i] = set()\n        for [Out, In] in trust:\n            # 小镇法官不会信任任何人\n            if Out in judges: del judges[Out]\n            if In in judges: judges[In].add(Out)\n        if not judges: return -1\n        # 只有一个人同时满足属性 1 和属性 2 \n        judge = list(judges.keys())[0]\n        supporters = list(judges.values())[0]        \n        # 每个人（除了小镇法官）都信任这位小镇法官\n        if supporters == set(range(1, n+1))-set([judge]): return judge\n        else: return -1\n```\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n# 思路2：图\n\n- 将小镇的人抽象为图的点，信任关系抽象为边\n- 法官：被其他所有人信任，即入度为 n-1\n\n# 代码2\n\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        count = [0]*n\n        for [Out, In] in trust:\n            count[Out-1] -= 1\n            count[In-1] += 1\n        for i in range(n):\n            if count[i]==n-1: return i+1\n        return -1\n```\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1470257312","body":"```\nfrom typing import List\nclass Solution:\n    def dfs(self, graph, colors, i, color, N):\n        # 根据colors和graph为i分配组，true表示可以分，false表示不可以\n        # 尝试将 i 分到 color(1) 组\n        colors[i] = color\n        # 遍历i讨厌的人\n        for j in range(N):\n            if graph[i][j] == 1:\n                # 若i和j已在同一组，则返回 false\n                # 此时不能将j分到另一组，因为另一组中已有j讨厌的人，所以j才来这一组\n                if colors[j] == color:\n                    return False\n                # 若j未分组，则尝试将j分到另一组\n                if colors[j] == 0 and not self.dfs(graph, colors, j, -1 * color, N):\n                    return False\n        return True\n\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = [[0] * N for i in range(N)]\n        colors = [0] * N\n        for a, b in dislikes:\n            graph[a - 1][b - 1] = 1\n            graph[b - 1][a - 1] = 1\n        for i in range(N):\n            # i未分组，尝试将i分到1组\n            if colors[i] == 0 and not self.dfs(graph, colors, i, 1, N):\n                return False\n        return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1472240310","body":"```python\r\nclass Solution:\r\n    # 拓扑排序\r\n    def tp_sort(self, items, indegree, neighbors):\r\n        q = collections.deque([])\r\n        ans = []\r\n        for item in items:\r\n            if not indegree[item]:\r\n                q.append(item)\r\n        while q:\r\n            cur = q.popleft()\r\n            ans.append(cur)\r\n\r\n            for neighbor in neighbors[cur]:\r\n                indegree[neighbor] -= 1\r\n                if not indegree[neighbor]:\r\n                    q.append(neighbor)\r\n\r\n        return ans\r\n\r\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\r\n        max_group_id = m\r\n        for project in range(n):\r\n            if group[project] == -1:\r\n                group[project] = max_group_id\r\n                max_group_id += 1\r\n\r\n        project_indegree = collections.defaultdict(int)\r\n        group_indegree = collections.defaultdict(int)\r\n        project_neighbors = collections.defaultdict(list)\r\n        group_neighbors = collections.defaultdict(list)\r\n        group_projects = collections.defaultdict(list)\r\n\r\n        for project in range(n):\r\n            group_projects[group[project]].append(project)\r\n\r\n            for pre in pres[project]:\r\n                if group[pre] != group[project]:\r\n                    # 小组关系图\r\n                    group_indegree[group[project]] += 1\r\n                    group_neighbors[group[pre]].append(group[project])\r\n                else:\r\n                    # 项目关系图\r\n                    project_indegree[project] += 1\r\n                    project_neighbors[pre].append(project)\r\n\r\n        ans = []\r\n        # 先对组进行拓扑排序\r\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\r\n\r\n        if len(group_queue) != max_group_id:\r\n            return []\r\n\r\n        for group_id in group_queue:\r\n            # 对小组中的项目进行拓扑排序\r\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\r\n\r\n            if len(project_queue) != len(group_projects[group_id]):\r\n                return []\r\n            ans += project_queue\r\n\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473072518","body":"```python\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        x_move = {\"U\": 0, \"D\": 0, \"L\": -1, \"R\": 1}\n        y_move = {\"U\": 1, \"D\": -1, \"L\": 0, \"R\": 0}\n        x_axis = 0\n        y_axis = 0\n        for move in moves:\n            x_axis += x_move[move]\n            y_axis += y_move[move]\n        return x_axis==0 and y_axis==0\n```\n\n- 时间复杂度：O(N)，N = len(moves)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474791474","body":"```\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        tasks = [(euqueue_time, i, process_time) for \n                i, [euqueue_time, process_time] in enumerate(tasks)]        \n        tasks.sort()    # 按照 euqueue_time 对 tasks 进行排序\n        min_heap = []   # 用于记录排队中的 task 与用时最短的 task\n        curr_time = 0   # 用于记录当前时刻\n        pos = 0         # 用于记录当前遍历到的位置\n        ans = []\n        for _ in tasks:\n            # 0. 如果队列没有 task，直接将 time 快进到下一个任务的开始时间\n            # 这样可以减少时间复杂度\n            if not min_heap:\n                curr_time = max(curr_time, tasks[pos][0])\n            # 1. 遍历后续满足时间要求的 tasks\n            while pos < len(tasks) and tasks[pos][0] <= curr_time:\n                # 将task放入heap (process_time, idx)\n                heapq.heappush(min_heap, (tasks[pos][2], tasks[pos][1]))\n                pos += 1\n            # 2. 获取队列中用时最短的 task\n            process_time, idx = heapq.heappop(min_heap)\n            curr_time += process_time\n            ans.append(idx)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475137208","body":"# **1904. 你完成的完整对局数**\n\n# 题目\n\n```python\n一款新的在线电子游戏在近期发布，在该电子游戏中，以 刻钟 为周期规划若干时长为 15 分钟 的游戏对局。这意味着，在 HH:00、HH:15、HH:30 和 HH:45 ，将会开始一个新的对局，其中 HH 用一个从 00 到 23 的整数表示。游戏中使用 24 小时制的时钟 ，所以一天中最早的时间是 00:00 ，最晚的时间是 23:59 。\n\n给你两个字符串 startTime 和 finishTime ，均符合 \"HH:MM\" 格式，分别表示你 进入 和 退出 游戏的确切时间，请计算在整个游戏会话期间，你完成的 完整对局的对局数 。\n\n例如，如果 startTime = \"05:20\" 且 finishTime = \"05:59\" ，这意味着你仅仅完成从 05:30 到 05:45 这一个完整对局。而你没有完成从 05:15 到 05:30 的完整对局，因为你是在对局开始后进入的游戏；同时，你也没有完成从 05:45 到 06:00 的完整对局，因为你是在对局结束前退出的游戏。\n如果 finishTime 早于 startTime ，这表示你玩了个通宵（也就是从 startTime 到午夜，再从午夜到 finishTime）。\n\n假设你是从 startTime 进入游戏，并在 finishTime 退出游戏，请计算并返回你完成的 完整对局的对局数 。\n\n \n\n示例 1：\n输入：startTime = \"12:01\", finishTime = \"12:44\"\n输出：1\n解释：你完成了从 12:15 到 12:30 的一个完整对局。\n你没有完成从 12:00 到 12:15 的完整对局，因为你是在对局开始后的 12:01 进入的游戏。\n你没有完成从 12:30 到 12:45 的完整对局，因为你是在对局结束前的 12:44 退出的游戏。\n\n示例 2：\n输入：startTime = \"20:00\", finishTime = \"06:00\"\n输出：40\n解释：你完成了从 20:00 到 00:00 的 16 个完整的对局，以及从 00:00 到 06:00 的 24 个完整的对局。\n16 + 24 = 40\n\n示例 3：\n输入：startTime = \"00:00\", finishTime = \"23:59\"\n输出：95\n解释：除最后一个小时你只完成了 3 个完整对局外，其余每个小时均完成了 4 场完整对局。\n```\n\n# 思路\n\n- 如果结束时间 < 开始时间，结束时间+=24h\n- 对开始时间按照 15 分钟向上取整，e.g.: 00:46 ->01:00\n- 对结束时间按照 15 分钟向下取整，e.g.: 02:01 ->02:00\n- (结束时间 - 开始时间) // 15 即为答案\n\n# 代码\n\n```python\nclass Solution:\n    def ceil(self, hour, min):\n        min = (min//15)*15 + (1 if min%15!=0 else 0)*15\n        if min==60: hour, min = hour+1, 0\n        return hour, min\n\n    def floor(self, hour, min):\n        min = (min//15)*15\n        return hour, min\n\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        in_hour, in_min = int(loginTime[:2]), int(loginTime[-2:])\n        out_hour, out_min = int(logoutTime[:2]), int(logoutTime[-2:])\n        if out_hour*60+out_min < in_hour*60+in_min: out_hour+=24\n        in_hour, in_min = self.ceil(in_hour, in_min)            # 00:46 ->01:00\n        out_hour, out_min = self.floor(out_hour, out_min)       # 02:01 ->02:00\n        ans = (out_hour-in_hour)*4 + (out_min-in_min) // 15        \n        return ans if ans>0 else 0\n```\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476494934","body":"```\nfrom collections import Counter\nclass Solution:\n    def minCharacters(self, A: str, B: str) -> int:\n        counter_a = Counter(A)\n        counter_b = Counter(B)\n\n        def greater_cost(counter_a, counter_b):\n            ans = float(\"inf\")\n            for i in range(1, 26):\n                count = 0\n                # 将 counter_a 中小于最小值的都进行一次操作\n                # j=[0, i), char(97+j) = ['a', 'xx')\n                for j in range(i): \n                    count += counter_a[chr(97 + j)]\n                # 将 counter_b 中大于等于最小值的都进行一次操作\n                # j=[i, 26), char(97+j) = ['xx', 'z']\n                for j in range(i, 26):\n                    count += counter_b[chr(97 + j)]\n                ans = min(ans, count)\n            return ans\n\n        def equal_cost(counter_a, counter_b):\n            cost_a = len(A) - max(counter_a.values())\n            cost_b = len(B) - max(counter_b.values())\n            return cost_a + cost_b\n\n        ans_1 = greater_cost(counter_a, counter_b)\n        ans_2 = greater_cost(counter_b, counter_a)\n        ans_3 = equal_cost(counter_a, counter_b)\n                \n        return min(ans_1, ans_2, ans_3)\n```\n\n- 时间复杂度：O(m+n)\n- 空间复杂度：O(26)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477347735","body":"```python\nfrom math import floor, ceil\n\nclass Solution:\n\n    def Merge(self, L, R, nums):\n        p, q = len(L), len(R)\n        i, j, k = 0, 0, 0\n        while (i<p) and (j<q):\n            if L[i]<=R[j]:\n                nums[k] = L[i]\n                i+=1\n            else:\n                nums[k] = R[j]\n                j+=1\n            k+=1\n\n        nums[k:p+q] = R[j:q] if i==p else L[i:p]\n        return nums\n\n    def sortArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        if len(nums)>1:\n            L = nums[:ceil(n/2)]\n            R = nums[ceil(n/2):]\n            L = self.sortArray(L)\n            R = self.sortArray(R)\n            nums = self.Merge(L, R, nums)\n        return nums\n```\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1478237377","body":"# 00**69. x 的平方根**\r\n\r\n# 题目\r\n\r\n```python\r\n给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\r\n\r\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\r\n\r\n注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\r\n\r\n \r\n\r\n示例 1：\r\n输入：x = 4\r\n输出：2\r\n\r\n示例 2：\r\n输入：x = 8\r\n输出：2\r\n解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\r\n```\r\n\r\n# 思路：二分搜索\r\n\r\n# 代码\r\n\r\n```python\r\nclass Solution:\r\n    def binary_search(self, l, r, x):\r\n        if r-l<=1: return l if x-l*l>=0 else r\r\n        center = (l+r)//2\r\n        if center*center > x:\r\n            return self.binary_search(l, center, x)\r\n        else:\r\n            return self.binary_search(center, r, x)\r\n\r\n    def mySqrt(self, x: int) -> int:\r\n        if x==0: return 0\r\n        return self.binary_search(1, x, x)\r\n```\r\n\r\n- 时间复杂度：O(logn)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480831323","body":"# 0**278. 第一个错误的版本**\n\n# 题目\n\n```python\n你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n\n假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。\n\n你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\n\n \n示例 1：\n\n输入：n = 5, bad = 4\n输出：4\n解释：\n调用 isBadVersion(3) -> false \n调用 isBadVersion(5) -> true \n调用 isBadVersion(4) -> true\n所以，4 是第一个错误的版本。\n示例 2：\n\n输入：n = 1, bad = 1\n输出：1\n```\n\n# 思路：二分搜索\n\n# 代码\n\n```python\n# The isBadVersion API is already defined for you.\n# def isBadVersion(version: int) -> bool:\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        if n==1: return 1\n\n        def binary_search(l, r):\n            if r-l<=1: return l if isBadVersion(l) else r\n            mid = (l+r) // 2\n            if isBadVersion(mid): \n                return binary_search(l, mid)\n            else:\n                return binary_search(mid, r)\n    \n        return binary_search(1, n)\n```\n\n- 时间复杂度：O(logn)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482932868","body":"# 0**493. 翻转对**\n\n# 题目\n\n```python\n给定一个数组 nums ，如果 i < j 且 nums[i] > 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。\n\n你需要返回给定数组中的重要翻转对的数量。\n\n示例 1:\n输入: [1,3,2,3,1]\n输出: 2\n\n示例 2:\n输入: [2,4,3,5,1]\n输出: 3\n```\n\n# 思路1：暴力法（超时）\n\n```python\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            for j in range(n):\n                if i<j and nums[i] > 2*nums[j]:\n                    ans += 1\n        return ans\n```\n\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(1)\n\n# 思路2：二分法\n\n- 这道题我们也可以反向思考，即：**对于 nums 中的每一项 num，我们找前面出现过的大于 num * 2 的数**\n\n思路\n\n- 一边遍历数组，一边构造有序数组（SortedList in Python）\n    - 如果使用 array 的话，插入的时间复杂度将会是 O(n^2)\n    - 因此需要使用有序数组\n- 判断前面出现过的大于 num * 2 的数量\n\n代码\n\n```python\nfrom sortedcontainers import SortedList\nclass Solution:\n    def reversePairs(self, A):\n        s = SortedList()\n        ans = 0\n\n        for a in A:\n            # 获取当前 s 中大于 a*2 的 index\n            i = s.bisect_right(a * 2)\n            # 计算当前 s 中大于 a*2 的个数\n            ans += len(s) - i\n            # 将 a 加入到有序列表，O(nlogn)\n            s.add(a)\n        return ans\n```\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483767788","body":"# 0**475. 供暖器**\n\n# 题目\n\n```python\n冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。\n\n在加热器的加热半径范围内的每个房屋都可以获得供暖。\n\n现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。\n\n说明：所有供暖器都遵循你的半径标准，加热的半径也一样。\n\n示例 1:\n输入: houses = [1,2,3], heaters = [2]\n输出: 1\n解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。\n\n示例 2:\n输入: houses = [1,2,3,4], heaters = [1,4]\n输出: 1\n解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。\n\n示例 3：\n输入：houses = [1,5], heaters = [2]\n输出：3\n```\n\n# 思路：二分法\n\n- 使用 sorted list 保存 heaters\n- 对于每一个 house，获取其最接近的左右 heaters，计算最短距离\n- 返回最长半径\n\n# 代码\n\n```python\nfrom sortedcontainers import SortedList\n\nclass Solution:\n    def get_distance(self, house, heater_idx, heaters, n):\n        if heater_idx in [-1, n]: \n            return float(\"inf\")        \n        else:\n            return abs(house - heaters[heater_idx])\n\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\n        ans = 0\n        n = len(heaters)\n        # sorted array, O(NlogN)\n        heaters = SortedList(heaters)\n        for house in houses:                # O(M)\n            # get the left and right heaters, O(logN)\n            right_heater_idx = heaters.bisect_left(house)\n            left_heater_idx = right_heater_idx-1\n            # get the min distance of left and right heaters, O(1)\n            distance = min(\n                self.get_distance(house, left_heater_idx, heaters, n),\n                self.get_distance(house, right_heater_idx, heaters, n)\n            )                                \n            ans = max(ans, distance)\n        return ans\n```\n\n- 时间复杂度：max(O(NlogN), O(MlogN))，创建 SortedArray，N 为heaters数量，M为house数量\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1484137688","body":"```python\nclass Solution:\n    def count_not_greater(self, diff, nums):\n        i = ans = 0\n        for j in range(1, len(nums)):\n            while nums[j] - nums[i] > diff:\n                i += 1\n            ans += j - i\n        return ans\n\n    def smallestDistancePair(self, nums, k):\n        nums.sort()\n        l, r = 0, nums[-1] - nums[0]\n        while l <= r:\n            mid = (l + r) // 2\n            if self.count_not_greater(mid, nums) >= k:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1485264354","body":"```python\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:        \n        seen = set()\n        def dfs(mid, x, y):\n            # (x, y) 超过边界\n            if x > len(grid) - 1 or x < 0 or y > len(grid[0]) - 1 or y < 0:\n                return False\n            # grid>mid, 返回 false，向右查找\n            if grid[x][y] > mid:\n                return False\n            # 已走过，返回 false，避免重复\n            if (x, y) in seen:\n                return False\n            # 到达右下角，返回 true\n            if (x, y) == (len(grid) - 1, len(grid[0]) - 1):\n                return True                \n            seen.add((x, y))\n            # 遍历四个方向\n            ans = dfs(mid, x + 1, y) or \\\n                  dfs(mid, x - 1, y) or \\\n                  dfs(mid, x, y + 1) or \\\n                  dfs(mid, x, y - 1)\n            return ans\n\n        # 计数二分\n        l, r = 0, max([max(vec) for vec in grid])\n        while l <= r:\n            mid = (l + r) // 2\n            if dfs(mid, 0, 0):\n                r = mid - 1\n            else:\n                l = mid + 1\n            seen = set()\n        return l\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486491009","body":"# **1456. 定长子串中元音的最大数目**\n\n# 题目\n\n```python\n给你字符串 s 和整数 k 。\n\n请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。\n\n英文中的 元音字母 为（a, e, i, o, u）。\n\n示例 1：\n输入：s = \"abciiidef\", k = 3\n输出：3\n解释：子字符串 \"iii\" 包含 3 个元音字母。\n\n示例 2：\n输入：s = \"aeiou\", k = 2\n输出：2\n解释：任意长度为 2 的子字符串都包含 2 个元音字母。\n\n示例 3：\n输入：s = \"leetcode\", k = 3\n输出：2\n解释：\"lee\"、\"eet\" 和 \"ode\" 都包含 2 个元音字母。\n\n示例 4：\n输入：s = \"rhythms\", k = 4\n输出：0\n解释：字符串 s 中不含任何元音字母。\n\n示例 5：\n输入：s = \"tryhard\", k = 4\n输出：1\n```\n\n# 思路：滑动窗口\n\n- 维护一个 Out 和 In 指针，对窗口内的值进行更新\n    \n    ![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202303281708277.png](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202303281708277.png)\n    \n\n# 代码\n\n```python\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if k>len(s): k = len(s)\n        vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"}\n        # init\n        cur = 0\n        for i in range(k):\n            if s[i] in vowels: cur += 1\n        ans = cur\n        for Out in range(0, len(s)-k):\n            In = Out+k\n            if s[Out] in vowels: cur -= 1\n            if s[In] in vowels: cur += 1\n            ans = max(ans, cur)\n            # 达到上限，提前终止\n            if ans==k: return k\n        return ans\n```\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488882494","body":"蒙特卡洛模拟（超时，图一乐）\n\n```python\nimport random\n\nclass Solution:\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\n        # get random bonus between [1, maxPts]\n        def get_random_bonus(maxPts, sample_size):            \n            return [random.randint(1, maxPts) for _ in range(sample_size)]\n        \n        # 获得 k 分 或更多分时，停止抽取数字\n        def get_indicator(points, k):\n            return [point<k for point in points]\n\n        def Monte_Carlo(points, maxPts, k, epochs, sample_size):\n            for _ in range(epochs):\n                bonus = get_random_bonus(maxPts, sample_size)\n                indicators = get_indicator(points, k)\n                if sum(indicators)==0: return points\n                points = [b*i+p for (b, i, p) in zip(bonus, indicators, points)]\n            return points\n\n        epochs = 100000\n        sample_size = 100000\n        points = [0]*sample_size # init points\n        points = Monte_Carlo(points, maxPts, k, epochs, sample_size)\n\n        # 分数不超过 n 的概率\n        return sum([point<=n for point in points]) / sample_size\n```\n\n- 时间复杂度：O(epochs*sample_size)\n- 空间复杂度：O(sample_size)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1490548637","body":"```python\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        target = collections.Counter(p)\n        ans = []\n        for i in range(len(s)):\n            if i >= len(p):\n                target[s[i - len(p)]] += 1\n                if target[s[i - len(p)]] == 0:\n                    del target[s[i - len(p)]]\n            target[s[i]] -= 1\n            if target[s[i]] == 0:\n                del target[s[i]]\n            if len(target) == 0:\n                ans.append(i - len(p) + 1)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1492086444","body":"```python\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        l, counter, N, ct = 0, Counter(), len(s), Counter(t)\n        k = 0\n        ret, ans = inf, \"\"\n        for r in range(N):\n            counter[s[r]] += 1\n            if s[r] in t and counter[s[r]] == ct[s[r]]:\n                k += 1\n            while k == len(ct):\n                if r - l + 1 < ret:\n                    ans = s[l:r+1]\n                ret = min(r - l + 1, ret)\n                counter[s[l]] -= 1\n                if s[l] in t and counter[s[l]] == ct[s[l]]-1:\n                    k -= 1\n                l += 1\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1493016452","body":"```python\nclass Solution:\n    def solve(self, A, target):\n        if not A and not target: return 0\n        target = sum(A) - target\n        ans = len(A) + 1\n        i = t = 0\n\n        for j in range(len(A)):\n            t += A[j]\n            while i <= j and t > target:\n                t -= A[i]\n                i += 1\n            if t == target: ans = min(ans, len(A) - (j - i + 1))\n        return -1 if ans == len(A) + 1 else ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493352307","body":"```python\nclass Solution:\n    def readBinaryWatch(self, num: int) -> List[str]:\n        return [str(a) + \":\" + str(b).rjust(2, '0')   \\\n        for a in range(12) for b in range(60) \\\n        if (bin(a)+bin(b)).count('1') == num]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494484596","body":"```python\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n\n        def dfs(pre, i):\n            nonlocal queen\n            if i == n:\n                queen += 1\n                return\n            for j in range(n):\n                if j in col:\n                    if i - j in right and i + j in left:\n                        col.discard(j)\n                        right.discard(i - j)\n                        left.discard(i + j)\n                        dfs(pre + [j], i + 1)\n                        col.add(j)\n                        right.add(i - j)\n                        left.add(i + j)\n            return\n\n        col = set(list(range(n)))\n        right = set(list(range(1 - n, n, 1)))\n        left = set(list(range(2 * n)))\n        queen = 0\n        dfs([], 0)\n        return queen\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1496200214","body":"```python\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        if m == 0: return 0\n        n = len(grid[0])\n        ans = 0\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n: return 0\n            if grid[i][j] == 0: return 0\n            grid[i][j] = 0\n            top = dfs(i + 1, j)\n            bottom = dfs(i - 1, j)\n            left = dfs(i, j - 1)\n            right = dfs(i, j + 1)\n            return 1 + sum([top, bottom, left, right])\n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, dfs(i, j))\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497686429","body":"```python\nclass Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        steps = -1\n        queue = collections.deque([(i, j) for i in range(n) for j in range(n) if grid[i][j] == 1])\n        if len(queue) == 0 or len(queue) == n ** 2: return steps\n        while len(queue) > 0:\n            for _ in range(len(queue)):\n                x, y = queue.popleft(0)\n                for xi, yj in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n                    if xi >= 0 and xi < n and yj >= 0 and yj < n and grid[xi][yj] == 0:\n                        queue.append((xi, yj))\n                        grid[xi][yj] = -1\n            steps += 1\n\n        return steps\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1499223262","body":"```python\n    def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):\n        boxes = set(initialBoxes)\n        q = [i for i in boxes if status[i]]\n        for i in q:\n            for j in containedBoxes[i]:\n                boxes.add(j)\n                if status[j]:\n                    q.append(j)\n            for j in keys[i]:\n                if status[j] == 0 and j in boxes:\n                    q.append(j)\n                status[j] = 1\n        return sum(candies[i] for i in q)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1500405247","body":"```python\nclass Solution:\n    def solve(self, root):\n        q = collections.deque([(root, 0)])\n        d = {}\n        while q:\n            cur, pos = q.popleft()\n            if pos not in d:\n                d[pos] = cur.val\n            if cur.left:\n                q.append((cur.left, pos - 1))\n            if cur.right:\n                q.append((cur.right, pos + 1))\n        return list(map(lambda x:x[1], sorted(d.items(),key=lambda x: x[0])))\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501146414","body":"```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n\n        length = len(nums)\n        if length == 1:\n            return nums[0]\n        else:\n            prev = nums[0]\n            cur = max(prev, nums[1])\n            for i in range(2, length):\n                cur = max(prev + nums[i], cur)\n\t\tprev = cur\n            return cur\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501892851","body":"```python\nclass Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        # dp[i][0] ->  LIS\n        # dp[i][1] -> NumberOfLIS\n        dp = [[1, 1] for i in range(n)]\n        ans = [1, 1]\n        longest = 1\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[j] > nums[i]:\n                    if dp[i][0] + 1 > dp[j][0]:\n                        dp[j][0] = dp[i][0] + 1\n                        # 下面这行代码容易忘记，导致出错\n                        dp[j][1] = dp[i][1]\n                        longest = max(longest, dp[j][0])\n                    elif dp[i][0] + 1 == dp[j][0]:\n                        dp[j][1] += dp[i][1]\n        return sum(dp[i][1] for i in range(n) if dp[i][0] == longest)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1503669471","body":"```python\nclass Solution:\n    def longestCommonSubsequence(self, A: str, B: str) -> int:\n        m, n = len(A), len(B)\n        ans = 0\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if A[i - 1] == B[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    ans = max(ans, dp[i][j])\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1505346165","body":"```python\nclass Solution:\n\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [1] * n\n        for _ in range(1, m):\n            for j in range(1, n):\n                dp[j] += dp[j - 1]\n        return dp[n - 1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1507179637","body":"```java\nclass Solution {\n\n    private int[][] dir = {{-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}};\n\n    public double knightProbability(int N, int K, int r, int c) {\n\n        double[][] dp = new double[N][N];\n        dp[r][c] = 1;\n\n        for (int step = 1; step <= K; step++) {\n\n            double[][] dpTemp = new double[N][N];\n\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                    for (int[] direction : dir) {\n\n                        int lastR = i - direction[0];\n                        int lastC = j - direction[1];\n                        if (lastR >= 0 && lastR < N && lastC >= 0 && lastC < N)\n                            dpTemp[i][j] += dp[lastR][lastC] * 0.125;\n                    }\n\n            dp = dpTemp;\n        }\n\n        double res = 0;\n\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                res += dp[i][j];\n\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1508880939","body":"```python\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        if desiredTotal <= maxChoosableInteger:\n            return True\n        if sum(range(maxChoosableInteger + 1)) < desiredTotal:\n            return False\n\n        @lru_cache(None)\n        def dp(picked, acc):\n            if acc >= desiredTotal:\n                return False\n            if picked == (1 << (maxChoosableInteger + 1)) - 1:\n                return False\n            for n in range(1, maxChoosableInteger + 1):\n                if picked & 1 << n == 0:\n                    if not dp(picked | 1 << n, acc + n):\n                        return True\n            return False\n\n        return dp(0, 0)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509867704","body":"```python\nclass Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        target = sum(nums) // 2\n        if target + target != sum(nums):\n            return False\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        for i in range(1, len(nums) + 1):\n            for j in range(target, 0, -1):\n                if dp[j] or (j - nums[i - 1] > -1 and dp[j - nums[i - 1]]):\n                    dp[j] = True\n        return dp[-1]\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511308291","body":"```python\nclass Solution(object):\n    def coinChange(self, coins, amount):\n        dp = [amount + 1] * (amount+1)\n        dp[0] = 0\n        for i in range(1, amount+1):\n            for coin in coins:\n                if i >= coin:\n                    dp[i] = min(dp[i], dp[i-coin]+1)\n        return -1 if dp[amount] == amount + 1 else dp[amount]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1513388160","body":"```python\nclass Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n\n        for j in range(len(coins)):\n            for i in range(1, amount + 1):\n                if i >= coins[j]:\n                    dp[i] += dp[i - coins[j]]\n\n        return dp[-1]\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516569230","body":"```python\nclass Solution:\n    def lengthOfLIS(self, A: List[int]) -> int:\n        d = []\n        for s, e in A:\n            i = bisect.bisect_left(d, e)\n            if i < len(d):\n                d[i] = e\n            elif not d or d[-1] <= s:\n                d.append(e)\n        return len(d)\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        n = len(intervals)\n        if n == 0: return 0\n        ans = 1\n        intervals.sort(key=lambda a: a[0])\n        return n - self.lengthOfLIS(intervals)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517883408","body":"```python\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        \"\"\"思路同上\"\"\"\n        _max = 0\n        _len = len(nums)\n        for i in range(_len-1):\n            if _max < i:\n                return False\n            _max = max(_max, nums[i] + i)\n            # 下面这个判断可有可无，但提交的时候数据会好看点\n            if _max >= _len - 1:\n                return True\n        return _max >= _len - 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518662159","body":"```python\nclass Solution:\n    visited = dict()\n\n    def numTrees(self, n: int) -> int:\n        if n in self.visited:\n            return self.visited.get(n)\n        if n <= 1:\n            return 1\n        res = 0\n        for i in range(1, n + 1):\n            res += self.numTrees(i - 1) * self.numTrees(n - i)\n        self.visited[n] = res\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519098402","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n        n = len(lists)\n\n        # basic cases\n        if lenth == 0: return None\n        if lenth == 1: return lists[0]\n        if lenth == 2: return self.mergeTwoLists(lists[0], lists[1])\n\n        # divide and conqure if not basic cases\n        mid = n // 2\n        return self.mergeTwoLists(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:n]))\n\n\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        res = ListNode(0)\n        c1, c2, c3 = l1, l2, res\n        while c1 or c2:\n            if c1 and c2:\n                if c1.val < c2.val:\n                    c3.next = ListNode(c1.val)\n                    c1 = c1.next\n                else:\n                    c3.next = ListNode(c2.val)\n                    c2 = c2.next\n                c3 = c3.next\n            elif c1:\n                c3.next = c1\n                break\n            else:\n                c3.next = c2\n                break\n\n        return res.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1520160627","body":"```python\nclass Solution:\n    def beautifulArray(self, N: int) -> List[int]:\n        @lru_cache(None)\n        def dp(n):\n            if n == 1:\n                return [1]\n            ans = []\n            # [1,n] 中奇数比偶数多1或一样\n            for a in dp(n - n // 2):\n                ans += [a * 2 - 1]\n            for b in dp(n // 2):\n                ans += [b * 2]\n            return ans\n\n        return dp(N)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521911502","body":"```python\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        xor = a = b = 0\n        right_bit = 1\n        length = len(nums)\n        for i in nums:\n            xor ^= i\n        while right_bit & xor == 0:\n            right_bit <<= 1\n        for i in nums:\n            if right_bit & i:\n                a ^= i\n            else:\n                b ^= i\n        return [a, b]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1523614452","body":"```python\nclass Solution:\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res, end = [], 1 << len(nums)\n        for sign in range(end):\n            subset = []\n            for i in range(len(nums)):\n                if ((1 << i) & sign) != 0:\n                    subset.append(nums[i])\n            res.append(subset)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1525782138","body":"```python\nclass TrieNode:\n    def __init__(self):\n        self.count = 0\n        self.preCount = 0\n        self.children = {}\n\nclass Trie:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.root = TrieNode()\n\n    def insert(self, word):\n        \"\"\"\n        Inserts a word into the trie.\n        :type word: str\n        :rtype: void\n        \"\"\"\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.preCount += 1\n        node.count += 1\n\n    def search(self, word):\n        \"\"\"\n        Returns if the word is in the trie.\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.count > 0\n\n    def startsWith(self, prefix):\n        \"\"\"\n        Returns if there is any word in the trie that starts with the given prefix.\n        :type prefix: str\n        :rtype: bool\n        \"\"\"\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.preCount > 0\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528810603","body":"\nclass Solution {\n    public int[][] multiSearch(String big, String[] smalls) {\n        if(smalls==null || smalls.length==0) return new int[][]{};\n        int N = smalls.length;\n        int[][] res = new int[N][];\n        <!-- 遍历所有子串 -->\n        for(int i = 0 ; i < N ; ++i){\n            int index = 0, j=0;\n            <!-- 特殊情况：字串是\"\",此时用indexOf的化会直接匹配到首个元素的位置，\n                 所以拿出来特殊处理一下 -->\n            if(\"\".equals(smalls[i])){\n                res[i] = new int[]{};\n                continue;\n            }\n            <!-- list存放当前子串出现的所有位置 -->\n            ArrayList<Integer> list = new ArrayList<>();\n            while(big.indexOf(smalls[i],index)!=-1){\n                list.add(big.indexOf(smalls[i],index));\n                <!-- 从当前匹配到的位置的下一个位置开始匹配 -->\n                index = big.indexOf(smalls[i],index) + 1;\n            }\n            <!-- 根据子串出现次数，为当前数组初始化 -->\n            res[i] = new int[list.size()];\n            <!-- 赋值 -->\n            for(int k : list){\n                res[i][j++] = k;\n            }\n        }\n        return res;\n    }\n}\n\n作者：管永升\n链接：https://leetcode.cn/problems/multi-search-lcci/solutions/2218726/cai-niao-jie-fa-shi-jian-615-ms-ji-bai-1-i7tn/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1528958566","body":"class Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        \n        def dfs(i):\n            visited.add(i)\n            for j in range(len(isConnected[i])):\n                if j not in visited and isConnected[i][j]==1:\n                    dfs(j)\n                    \n        visited = set()\n        provinces = 0\n        for i in range(len(isConnected)):\n            if i not in visited:\n                dfs(i)\n                provinces +=1\n            \n        return provinces","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1529870563","body":"class UnionFind:\n    def __init__(self):\n        self.father = {}\n        self.size = {}\n\n    def find(self, x):\n        self.father.setdefault(x, x)\n        if x != self.father[x]:\n            self.father[x] = self.find(self.father[x])\n        return self.father[x]\n\n    def union(self, x, y):\n        fx, fy = self.find(x), self.find(y)\n        if self.size.setdefault(fx, 1) < self.size.setdefault(fy, 1):\n            self.father[fx] = fy\n            self.size[fy] += self.size[fx]\n        elif fx != fy:\n            self.father[fy] = fx\n            self.size[fx] += self.size[fy]\n\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        uf = UnionFind()\n\n        for i in range(len(graph)):\n            for j in range(i, len(graph)):\n                if graph[i][j]:\n                    uf.union(i, j)\n\n        initial.sort()\n        max_size, index, fi = 0, -1, []\n        cnt = collections.defaultdict(int)\n        for init in initial:\n            fi.append(uf.find(init))\n            cnt[fi[-1]] += 1\n        for i in range(len(initial)):\n            if cnt[fi[i]] > 1:\n                continue\n            if uf.size[fi[i]] > max_size:\n                max_size = uf.size[fi[i]]\n                index = initial[i]\n\n        return index if index != -1 else initial[0]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1531465341","body":"class Solution:\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        root = [i for i in range(n)]\n\n        def find(p):\n            while p != root[p]:\n                root[p] = root[root[p]]\n                p = root[p]\n\n            return p\n\n        def union(p, q):\n            root[find(p)] = find(q)\n\n        have = 0\n        for connec in connections:\n            a, b = connec\n            if find(a) != find(b):\n                union(a, b)\n            else:\n                have += 1\n\n        diff_root = set()\n        for i in range(n):\n            diff_root.add(find(i))\n\n        return len(diff_root) - 1 if have >= len(diff_root) - 1 else -1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1533062012","body":"class Solution(object):\n    def pruneTree(self, root):\n        def containsOne(node):\n            if not node: return False\n            left = containsOne(node.left)\n            right = containsOne(node.right)\n            if not left: node.left = None\n            if not right: node.right = None\n            return node.val == 1 or left or right\n\n        return root if containsOne(root) else None","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1536227833","body":"class Solution:\n    def combinationSum2(self, candidates, target):\n        lenCan = len(candidates)\n        if lenCan == 0:\n            return []\n        candidates.sort()\n        path = []\n        res = []\n        self.backtrack(candidates, target, lenCan, 0, 0, path, res)\n        return res\n\n    def backtrack(self, curCandidates, target, lenCan, curSum, indBegin, path, res):\n            # 终止条件\n            if curSum == target:\n                res.append(path.copy())\n            for index in range(indBegin, lenCan):\n                nextSum = curSum + curCandidates[index]\n                # 减枝操作\n                if nextSum > target:\n                    break\n                # 通过减枝避免重复解的出现\n                if index > indBegin and curCandidates[index-1] == curCandidates[index]:\n                    continue\n                path.append(curCandidates[index])\n                # 由于元素只能用一次，所以indBegin = index+1\n                self.backtrack(curCandidates, target, lenCan, nextSum, index+1, path, res)\n                path.pop()\n","onTime":true},null,null,null,null,null,null,null,null,null,null],"drinkmorekaik":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429842914","body":"## 思路\n##### 遍历数组num然后往数字k累加，省去进位的考虑，使用~~运算符避免undefined相加为NaN的情况，返回数组先使push最终再reserve比每一次unshift性能更好\n```\nconst addToArrayForm = function(num, k) {\n    const res = [];\n    let len = num.length - 1\n    while(len >= 0 || k) {\n        k += ~~num[len]\n        res.push(k % 10)\n        k = parseInt(k / 10)\n        len--\n    }\n    return res.reverse()\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431458364","body":"## 思路\r\n## 双指针记录当前正在遍历字符串的最近的左右字符c的index\r\n## 然后计算距离它的最小值\r\n```javascript\r\nvar shortestToChar = function(s, c) {\r\n  const res = []\r\n  let leftIndex = -1,\r\n      rightIndex = s.indexOf(c)\r\n  for (let i = 0; i < s.length; i++) {\r\n      if (leftIndex === -1 && i < rightIndex) {\r\n          res[i] = rightIndex - i\r\n          continue\r\n      }\r\n      if (i === rightIndex) {\r\n          res[i] = 0\r\n          leftIndex = rightIndex\r\n          rightIndex = s.indexOf(c, leftIndex + 1)\r\n          continue\r\n      }\r\n      // i-leftIndex 一定为正数， rightIndex-i 使用 Math.abs 的原因是 rightIndex 值可能为 -1，-1减去i的绝对值一定大于 i-leftIndex\r\n      res[i] = Math.min(i - leftIndex, Math.abs(rightIndex - i))\r\n  }\r\n  return res\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433180933","body":"##API 搬运工\n```javascript\nclass CustomStack {\n  constructor(maxSize) {\n    this.maxSize = maxSize\n    this.stack = []\n  }\n  push(x) {\n    if (this.stack.length < this.maxSize) this.stack.push(x)\n  }\n  pop() {\n    return this.stack.pop() || -1\n  }\n  increment(k, val) {\n    const count = Math.min(k, this.stack.length)\n    for (let i = 0; i < count; i++) {\n      this.stack[i] += val\n    }\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434820374","body":"var decodeString = function(s) {\n    let numStack = [];              // 倍数 num 的等待栈\n    let strStack = [];              // 待拼接 str 的等待栈\n\n    let num = 0, result = '';\n\n    for(let i = 0; i < s.length; i++) {\n        const item = s[i];\n\n        if(!isNaN(item)) {              // 判断是数字时\n            num = num * 10 + parseInt(item);\n        } else if(item === '[') {\n            strStack.push(result);\n            result = '';\n            numStack.push(num);\n            num = 0;\n        } else if(item === ']') {\n            const repeatTimes = numStack.pop();         // 从栈中获取次数\n            result = strStack.pop() + result.repeat(repeatTimes);\n        } else {\n            result += item;\n        }\n    }\n    return result;\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435674626","body":"```javascript\nclass MyQueue {\n    constructor() {\n        this.stackPush = []\n        this.stackPop = []\n    }\n    push(val) {\n        this.stackPush.push(val)\n    }\n    pop() {\n        if (this.stackPop.length) return this.stackPop.pop()\n        while(this.stackPush.length) {\n            this.stackPop.push(this.stackPush.pop())\n        }\n        return this.stackPop.pop()\n    }\n    peek() {\n        return this.stackPop.length ? this.stackPop.at(-1) : this.stackPush.at(0)\n    }\n    empty() {\n        return !this.stackPop.length && !this.stackPush.length\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435996628","body":"## 没想出来，看了题解思路写的\r\n```javascript\r\nvar maxChunksToSorted = function (arr) {\r\n  let maxStack = [arr[0]]\r\n  for (let i = 1; i < arr.length; i++) {\r\n    if (arr[i] >= maxStack.at(-1)) {\r\n      maxStack.push(arr[i])\r\n    } else {\r\n      let maxValue = -Infinity\r\n      while (maxStack.at(-1) > arr[i]) {\r\n        maxValue = Math.max(maxValue, maxStack.pop())\r\n      }\r\n      maxStack.push(maxValue)\r\n    }\r\n  }\r\n  return maxStack.length\r\n}\r\n```\r\n<img width=\"692\" alt=\"iShot_2023-02-19_21 57 29\" src=\"https://user-images.githubusercontent.com/51078581/219952900-89d7c5a9-7f8e-4ecf-90ce-b420300c95f1.png\">","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437258377","body":"## 快慢指针\r\n```javascript\r\nvar rotateRight = function(head, k) {\r\n    if (!head) return null\r\n    let slow = head, fast = head\r\n    while (k--) {\r\n        fast = fast.next || head\r\n    }\r\n    if (fast === slow) return head\r\n    while (fast.next) {\r\n        slow = slow.next\r\n        fast = fast.next \r\n    }\r\n    const res = slow.next || head\r\n    slow.next = null\r\n    fast.next = head\r\n    return res\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438762349","body":"## 递归\r\n```javascript\r\nfunction ListNode(val) {\r\n    this.val = val;\r\n    this.next = null;\r\n}\r\n\r\nvar swapPairs = function (head) {\r\n    if (!head || !head.next) {\r\n        return head;\r\n    }\r\n    let next = head.next;\r\n    head.next = swapPairs(next.next);\r\n    next.next = head;\r\n    return next;\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440218278","body":"## 链表值入栈，再通过递归构建二叉树\n```javascript\n\nfunction ListNode(val, next) {\n    this.val = (val===undefined ? 0 : val)\n    this.next = (next===undefined ? null : next)\n}\n\nfunction TreeNode(val, left, right) {\n    this.val = (val===undefined ? 0 : val)\n    this.left = (left===undefined ? null : left)\n    this.right = (right===undefined ? null : right)\n}\n\nvar sortedListToBST = function(head) {\n    if (!head) return null\n    const arr = []\n    while(head) {\n        arr.push(head.val)\n        head = head.next\n    }\n    const dfs = (arr) => {\n        if (!arr.length) return null\n        const middle = parseInt(arr.length / 2),\n              leftArr = arr.slice(0, middle),\n              rightArr = arr.slice(middle + 1)\n        const treeNode = new TreeNode(arr[middle])\n        treeNode.left = dfs(leftArr)\n        treeNode.right = dfs(rightArr)\n        return treeNode\n    }\n    return dfs(arr)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441987874","body":"```javascript\nvar getIntersectionNode = function(headA, headB) {\n    let flag1 = headA, flag2 = headB\n    while (flag1 !== flag2) {\n        flag1 = flag1 ? flag1.next : headB\n        flag2 = flag2 ? flag2.next : headA\n    }\n    return flag1\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443863958","body":"## 快慢指针\n```javascript\nvar detectCycle = function (head) {\n    let slow = head, fast = head\n    while (fast && fast.next) {\n        fast = fast.next.next\n        slow = slow.next\n        if (fast === slow) {\n            fast = head\n            while (fast !== slow) {\n                fast = fast.next\n                slow = slow.next\n            }\n            return fast\n        }\n    }\n    return null\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445141853","body":"## 使用Map实现，每次get和put时需要删除原有值再设置，以保证map是按修改的顺序依次排序的\n```javascript\n\nclass LRUCache {\n    constructor (opacity) {\n        this.size = opacity\n        this._storage = new Map()\n    }\n    get (key) {\n        if (this._storage.has(key)) {\n            const value = this._storage.get(key)\n            this._storage.delete(key)\n            this._storage.set(key, value)\n            return value\n        } else {\n            return -1\n        }\n    }\n    put (key, value) {\n        this._storage.delete(key)\n        this._storage.set(key, value)\n        if (this._storage.size > this.size) {\n            this._storage.delete(this._storage.keys().next().value)\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445390654","body":"## 深度遍历\n```javascript\nvar maxDepth = function(root) {\n    const dfs = (node) => {\n        if (!node) return 0\n        const leftDepth = dfs(node.left),\n              rightDepth = dfs(node.right)\n        return Math.max(leftDepth, rightDepth) + 1\n    }\n    return dfs(root)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446596865","body":"## 深度优先遍历\n```javascript\nvar isSameTree = function(p, q) {\n    const dfs = (node1, node2) => {\n        if (!node1 && !node2) return true\n        if (!node1 || !node2) return false\n        if (node1.val !== node2.val) return false\n        return dfs(node1.left, node2.left) && dfs(node1.right, node2.right)\n    }\n    return dfs(p, q)\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448376449","body":"```javascript\nvar sumNumbers = function (root) {\n  const help = (node, count = 0) => {\n    count = count * 10 + node.val\n    if (!node.left && !node.right) return count\n    let leftCount = 0, rightCount = 0\n    if (node.left) {\n      leftCount = help(node.left, count)\n    }\n    if (node.right) {\n      rightCount = help(node.right, count)\n    }\n    return leftCount + rightCount\n  }\n  return help(root)\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450371629","body":"## 使用队列层序遍历，因为需要取出最底部最左边的叶子结点，且队列先进先出的原则，所以右子树优先左子树入列\n```javascript\nvar findBottomLeftValue = function(root) {\n    if (!root) return\n    let queue = [root]\n    let res\n    while(queue.length) {\n        let len = queue.length\n        while (len--) {\n            const node = queue.shift()\n            res = node.val\n            node.right && queue.push(node.right)\n            node.left && queue.push(node.left)\n        }\n    }\n    return res\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451956532","body":"## 偷懒吧\n```javascript\nvar serialize = function(root) {\n    return JSON.stringify(root)\n};\n\nvar deserialize = function(data) {\n    return JSON.parse(data)\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453742762","body":"```javascript\r\nvar verticalTraversal = function (root) {\r\n  if (!root) return []\r\n  const map = new Map()\r\n  const dfs = (node, row = 0, col = 0) => {\r\n    if (map.has([row, col] + '')) {\r\n      map.set([row, col] + '', [...map.get([row, col] + ''), node.val].sort((a, b) => a - b))\r\n    } else {\r\n      map.set([row, col] + '', [node.val])\r\n    }\r\n    node.left && dfs(node.left, row + 1, col - 1)\r\n    node.right && dfs(node.right, row + 1, col + 1)\r\n  }\r\n  dfs(root)\r\n  const sortArr = [...map].map(([key, val]) => ([key.split(',').map(i => parseInt(i)), val])).sort(([[row1, col1]], [[row2, col2]]) => {\r\n    if (col1 !== col2) return col1 - col2\r\n    else return row1 -row2\r\n  })\r\n  const res = []\r\n  sortArr.reduce(\r\n    (p, c) => {\r\n      if (p[0][1] === c[0][1]) {\r\n        res[res.length - 1].push(...c[1])\r\n      } else {\r\n        res.push(c[1])\r\n      }\r\n      return c\r\n    },\r\n    [[], []]\r\n  )\r\n  return res\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454776829","body":"```javascript\nvar twoSum = function(nums, target) {\n    const map = new Map()\n    for(let i = 0; i < nums.length; i++) {\n        if (map.has(nums[i])) {\n            return [map.get(nums[i]), i]\n        } else {\n            map.set(target - nums[i], i)\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455126604","body":"### leetcode运行时间结果显示任何快排/二分治都没有比让浏览器用sort选择的排序来的快\n```javascript\nvar topKFrequent = function(nums, k) {\n  const freq = new Map()\n  nums.forEach(i => {\n    if (freq.has(i)) freq.set(i, freq.get(i) + 1)\n    else freq.set(i, 1)\n  })\n  return [...freq].sort((a, b) => b[1] - a[1]).slice(0, k).map(i => i[0])\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456399727","body":"#### 不看题解都不知道这题要考什么\n```javascript\nvar numberOfBoomerangs = function(points) {\n    let ans = 0;\n    for (const p of points) {\n        const cnt = new Map();\n        for (const q of points) {\n            if (p !== q) {\n                const dis = (p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2;\n                cnt.set(dis, (cnt.get(dis) || 0) + 1);\n            }\n        }\n        for (const [_, m] of cnt.entries()) {\n            ans += m * (m - 1);\n        }\n    }\n    return ans;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1458373442","body":"```javascript\nvar lengthOfLongestSubstring = function(s) {\n    const len = s.length\n    if (len < 2) return len\n    const map = new Map()\n    let res = 0\n    for (let i = 0, j = 0; j < len; j++) {\n        if (map.has(s[j])) {\n            i = Math.max(i, map.get(s[j]) + 1)\n        }\n        res = Math.max(res, j - i + 1)\n        map.set(s[j], j)\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460425764","body":"```javascript\r\nvar findSubstring = function (s, words) {\r\n    if (!s || !words || !words.length) return [];\r\n    let windows = {},\r\n        needs = {},\r\n        oneWordLen = words[0].length;\r\n    for (let w of words) {\r\n        needs[w] ? needs[w]++ : needs[w] = 1;\r\n    }\r\n    let l = 0,\r\n        r = 0,\r\n        count = 0,\r\n        needsKeyLen = Object.keys(needs).length,\r\n        ans = [];\r\n    for (let i = 0; i < oneWordLen; i++) {\r\n        windows = {};\r\n        r = l = i;\r\n        count = 0;\r\n        while (r <= s.length - oneWordLen) {\r\n            let w1 = s.slice(r, r + oneWordLen);\r\n            r += oneWordLen;\r\n            if (!needs[w1]) {\r\n                windows = {};\r\n                l = r;\r\n                count = 0;\r\n                continue;\r\n            }\r\n            windows[w1] ? windows[w1]++ : windows[w1] = 1;\r\n            if (windows[w1] === needs[w1]) count++;\r\n            while (count === needsKeyLen) {\r\n                if (r - l === oneWordLen * words.length) ans.push(l);\r\n                let w2 = s.slice(l, l + oneWordLen);\r\n                l += oneWordLen;\r\n                if (needs[w2]) {\r\n                    windows[w2]--;\r\n                    if (windows[w2] < needs[w2]) count--;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return ans;\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462284644","body":"```javascript\r\nvar minSubarray = function(nums, p) {\r\n    let x = 0;\r\n    for (const num of nums) {\r\n        x = (x + num) % p;\r\n    }\r\n    if (x === 0) {\r\n        return 0;\r\n    }\r\n    const index = new Map();\r\n    let y = 0, res = nums.length;\r\n    for (let i = 0; i < nums.length; i++) {\r\n        index.set(y, i); // f[i] mod p = y，因此哈希表记录 y 对应的下标为 i\r\n        y = (y + nums[i]) % p;\r\n        if (index.has((y - x + p) % p)) {\r\n            res = Math.min(res, i - index.get((y - x + p) % p) + 1);\r\n        }\r\n    }\r\n    return res === nums.length ? -1 : res;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463984755","body":"```javascript\nvar middleNode = function(head) {\n    let fast = head, slow = head\n    while (fast && fast.next) {\n        fast = fast.next.next\n        slow = slow.next\n    }\n    return slow\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464933349","body":"```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar removeDuplicates = function(nums) {\r\n    if (nums.length <= 1) return nums.length\r\n    for (let i = 1; i < nums.length; i++) {\r\n        if (nums[i] !== nums[i - 1]) continue\r\n        nums.splice(i, 1)\r\n        --i\r\n    }\r\n    return nums.length\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465230811","body":"```javascript\nvar searchInsert = function(nums, target) {\n    if (target < nums[0]) return 0\n    if (target > nums.at(-1)) return nums.length\n    const help = (left, right, target) => {\n        let mid = Math.round((left + right) / 2)\n        while (left <= right) {\n            if (target === nums[mid]) return mid\n            if (target > nums[mid]) return help(mid + 1, right, target)\n            else return help(left, mid - 1, target)\n        }\n        return mid\n    }\n    return help(0, nums.length, target)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466703556","body":"```javascript\r\nconst maxSlidingWindow = function(nums, k) {\r\n    const sw = [], max = []\r\n    for (let i = 0; i < nums.length; i++) {\r\n        if (i >= k && sw[0] <= i-k) {\r\n            sw.shift(); // 队列移动k个\r\n        }\r\n    \r\n        while(sw.length && nums[sw.at(-1)] < nums[i]) {\r\n            sw.pop();\r\n        }\r\n        sw.push(i);\r\n        if (i >= k-1) {\r\n            max.push(nums[sw[0]]);\r\n        }\r\n    }\r\n    return max;\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468439973","body":"```javascript\r\nvar findJudge = function(n, trust) {\r\n    if (n === 1) return 1\r\n    let maybe = [], repeatMaxCount = 0, repeatMaxNum\r\n    const obviate = []\r\n    trust.reduce((p, [a, b]) => {\r\n      p[b] = (p[b] || 0) + 1\r\n      if (p[b] > repeatMaxCount) {\r\n        repeatMaxCount = p[b]\r\n        repeatMaxNum = b\r\n      }\r\n      maybe.push(b)\r\n      obviate.push(a)\r\n      return p\r\n    }, {})\r\n\r\n    maybe = maybe.filter(i => !obviate.includes(i) && i === repeatMaxNum)\r\n    return maybe.length === n - 1 ? maybe[0] : -1\r\n  };\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1470331006","body":"```javascript\nvar possibleBipartition = function(n, dislikes) {\n    const dfs = (curnode, nowcolor, color, g) => {\n        color[curnode] = nowcolor;\n        for (const nextnode of g[curnode]) {\n            if (color[nextnode] !== 0 && color[nextnode] === color[curnode]) {\n                return false;\n            }\n            if (color[nextnode] === 0 && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    const color = new Array(n + 1).fill(0);\n    const g = new Array(n + 1).fill(0);\n    for (let i = 0; i <= n; ++i) {\n        g[i] = [];\n    }\n    for (const p of dislikes) {\n        g[p[0]].push(p[1]);\n        g[p[1]].push(p[0]);\n    }\n    for (let i = 1; i <= n; ++i) {\n        if (color[i] === 0 && !dfs(i, 1, color, g)) {\n            return false;\n        }\n    }\n    return true;\n};\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473975575","body":"```javascript\nconst judgeCircle => moves => {\n  const map = {\n    U: [0, 1],\n    D: [0, -1],\n    R: [1, 1],\n    L: [1, -1]\n  }\n  const recodeArr = [0, 0]\n  for (const i of moves) {\n    recodeArr[map[i][0]] += map[i][1]\n  }\n  return recodeArr[0] === 0 && recodeArr[1] === 0\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475321211","body":"```javascript\r\nvar numberOfRounds = function(startTime, finishTime) {\r\n    const start = startTime.split(\":\").map(Number);\r\n    const finish = finishTime.split(\":\").map(Number);\r\n    // 转化成分钟\r\n    const startMin = start[0] * 60 + start[1];\r\n    let finishMin = finish[0] * 60 + finish[1];\r\n    if(finishMin < startMin) {\r\n        finishMin += 24 * 60;\r\n    }\r\n    return Math.max(0, Math.floor(finishMin / 15) - Math.ceil(startMin / 15));\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476467424","body":"### 属于是看了题解也看不懂的了\n```javascript\nfunction minCharacters(a, b) {\n    const fA = new Array(26).fill(0);\n    const fB = new Array(26).fill(0);\n\n    for (const i of a) {\n        fA[i.charCodeAt(0) - 97]++;\n    }\n    for (const i of b) {\n        fB[i.charCodeAt(0) - 97]++;\n    }\n\n    const fC = fA.map((v, i) => v + fB[i])\n    const count = arr => arr.reduce((p, c) => p + c, 0)\n    let ans = count(fC) - Math.max(...fC);\n    for (let i = 1; i < 26; i++) {\n        ans = Math.min(ans, count(fA.slice(0, i)) + count(fB.slice(i)))\n        ans = Math.min(ans, count(fB.slice(0, i)) + count(fA.slice(i)))\n    }\n    return ans;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1478061017","body":"```javascript\nconst sortArray = function(nums, start = 0, end = nums.length - 1) {\n  const len = nums.length\n  if (len <= 1) return nums\n  const index = device(nums, start, end)\n  if (start < index - 1) sortArray(nums, start, index - 1)\n  if (end > index) sortArray(nums, index, end)\n  return nums\n};\n\nconst device = (nums, start, end) => {\n  let left = start,\n      right = end;\n  const provide = nums[parseInt((left + right) / 2)]\n  while(left <= right) {\n    while(nums[left] < provide) left++\n    while(nums[right] > provide) right--\n    if (left <= right) {\n      [nums[left], nums[right]] = [nums[right], nums[left]]\n      left++\n      right--\n    }\n  }\n  return left\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479702205","body":"```javascript\nvar mySqrt = function(x) {\n  let left = 1, right = Math.ceil(x / 2)\n  while (left <= right) {\n    const mid = ((left + right) / 2) | 0\n    if (mid ** 2 < x) left = mid + 1\n    else if (mid ** 2 > x) right = mid - 1\n    else return mid\n  }\n  return right\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1481349737","body":"```javascript\nvar solution = function(isBadVersion) {\n  return function(n) {\n    let left = 1, right = n\n    while(left <= right) {\n      const mid = ((left + right) / 2) | 0\n      if(isBadVersion(mid)) {\n        right = mid - 1\n      } else {\n        left = mid + 1\n      }\n    }\n    return left\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1483134440","body":"```javascript\r\nvar reversePairs = function (nums) {\r\n    let count = 0\r\n    let mergeArr = (left, right) => {\r\n        let i = 0, j = 0\r\n        while (i < left.length && j < right.length) {\r\n            if (left[i] > 2 * right[j]) {\r\n                count += left.length - i\r\n                j++\r\n            } else {\r\n                i++\r\n            }\r\n        }\r\n        return [...left, ...right].sort((a, b) => a - b)\r\n    }\r\n\r\n    let divide = (arr) => {\r\n        if (arr.length <= 1) {\r\n            return arr\r\n        }\r\n        let mid = (arr.length / 2) | 0\r\n        let left = arr.slice(0, mid)\r\n        let right = arr.slice(mid)\r\n        return mergeArr(divide(left), divide(right))\r\n    }\r\n\r\n    divide(nums)\r\n    return count\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483866879","body":"### 力扣475\n```javascript\nvar findRadius = function(houses, heaters) {\n  houses.sort((a, b) => a - b)\n  heaters.sort((a, b) => a - b)\n  let radius = 0\n  for (let i = 0; i < houses.length; i++) {\n    let left = 0, right = heaters.length - 1;\n    while (left < right - 1) {\n      const mid = (left + right) / 2 | 0\n      if (houses[i] > heaters[mid]) left = mid\n      else if (houses[i] < heaters[mid]) right = mid\n      else left = right = mid\n    }\n    const currentRadius = Math.min(Math.abs(houses[i] - heaters[left]), Math.abs(houses[i] - heaters[right])) \n    radius = Math.max(currentRadius, radius)\n  }\n  return radius\n};\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484158241","body":"```javascript\nconst swimInWater = function (grid) {\n    let left = 0,right = Math.max(...grid.flat())\n    const len = grid.length\n    while (left <= right) {\n        const mid = ((right - left) >> 1) + left\n        const set = new Set()\n        if (test(mid, 0, 0, set)) {\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n    return left\n\n    function test(mid, x, y, set) {\n        if (x < 0 || x > len - 1 || y < 0 || y > len - 1) return false\n        if (grid[x][y] > mid) return false\n        if (x === len - 1 && y === len - 1) return true\n        if (set.has(`${x}-${y}`)) return false\n        set.add(`${x}-${y}`) // 记录已走过的路\n        return test(mid, x - 1, y, set) || test(mid, x + 1, y, set) || test(mid, x, y - 1, set) || test(mid, x, y + 1, set)\n    }\n\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1485492230","body":"```javascript\r\nvar maxVowels = function(s, k) {\r\n  const letters = ['a', 'o', 'e', 'i', 'u']\r\n  let count = 0\r\n  for(let i = 0; i < k; i++) {\r\n    letters.includes(s[i]) && count++\r\n  }\r\n  let current = count\r\n  for (let j = k; j < s.length; j++) {\r\n    letters.includes(s[j]) && current++\r\n    letters.includes(s[j - k]) && current--\r\n    count = Math.max(count, current)\r\n  }\r\n  return count\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488881434","body":"```javascript\nvar new21Game = function (n, k, w) {\n    const dp = new Array(k + w).fill(0)\n    for (let i = k; i <= Math.min(n, k - 1 + w); i++) {\n        dp[i] = 1\n    }\n    for (let i = k - 1; i >= 0; i--) {\n        sum = 0\n        for (let j = 1; j <= w; j++) {\n            sum += dp[i + j]\n        }\n        dp[i] = sum / w\n    }\n\n    return dp[0]\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1490601484","body":"```javascript\r\nvar findAnagrams = function(s, p) {\r\n  const len1 = s.length, len2 = p.length\r\n  if (len1 < len2) return []\r\n\r\n  const res = []\r\n  const pMap = new Map()\r\n  const sMap = new Map()\r\n  let equal = 0\r\n  \r\n  for (const char of p) {\r\n    pMap.set(char, (pMap.get(char) || 0) + 1)\r\n  }\r\n\r\n  let left = right = 0\r\n\r\n  while (right < len1) {\r\n    let strRight = s[right++]\r\n    if (pMap.has(strRight)) {\r\n      const count = (sMap.get(strRight) || 0) + 1\r\n      sMap.set(strRight, count)\r\n      count === pMap.get(strRight) && equal++\r\n    }\r\n    if (right - left === len2) {\r\n      equal === pMap.size && res.push(left)\r\n      \r\n      let strLeft = s[left++]\r\n\r\n      if (pMap.has(strLeft)) {\r\n        let count = sMap.get(strLeft)\r\n        if (pMap.get(strLeft) === count) equal--\r\n        sMap.set(strLeft, --count)\r\n      }\r\n    }\r\n  }\r\n  return res\r\n};\r\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dinjufen":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429850830","body":"思路：令t = k，从num的末位开始累加，边加边将t的末位放入列表，以免t太大超出限制。加完后再依次添加num剩余的数，最后得到结果\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int t = k;\n        int i = 0;\n        vector<int> res;\n        while (t) {\n            if (i < num.size()) {\n                t += num[num.size() - i - 1];\n                i++;\n            }\n            res.push_back(t % 10);\n            t /= 10;\n        }\n        while (i < num.size()) {\n            res.push_back(num[num.size() - i - 1]);\n            i++;\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437706920","body":"思路：先将链表连接成环，再根据需要的距离进行断开，返回新的头节点即可\n\n代码：\n```C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (k == 0 || !head || !head->next) return head;\n        int length = 1;\n        ListNode* tmp = head;\n        while (tmp->next) {\n            length++;\n            tmp = tmp->next;\n        }\n        int add = length - k % length;\n        if (add == length) return head;\n        tmp->next = head;\n        while (add--) {\n            tmp = tmp->next;\n        }\n        ListNode* next = tmp->next;\n        tmp->next = nullptr;\n        return next;\n    }\n};\n```\n时间复杂度： O(n)\n空间复杂度: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437698328","body":"思路：递归，递归首先要知道最小步骤是什么，在这里最小步骤是两两交换节点，然后交换后的第二个节点指向下一次递归的返回值\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (head == nullptr || head->next == nullptr) {\r\n            return head;\r\n        }\r\n        ListNode* next = head->next;\r\n        head->next = swapPairs(next->next);\r\n        next->next = head;\r\n        return next;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1441032678","body":"思路：从链表中间开始作为root，分为左右子树，再递归将左右子树依次从中间分开，那最后得到的二叉树就是一个高度平衡的二叉搜索树\n\n代码：\n```C++\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        vector<ListNode*> list;\n        while (head) {\n            list.push_back(head);\n            head = head->next;\n        }\n        return buildBST(list, 0, list.size() - 1);\n    }\n\n    TreeNode* buildBST(const vector<ListNode*>& list, int start, int end) {\n        if (start > end) return nullptr;\n        int mid = (start + end) / 2;\n        TreeNode* pRoot = new TreeNode(list[mid]->val);\n        pRoot->left = buildBST(list, start, mid - 1);\n        pRoot->right = buildBST(list, mid + 1, end);\n        return pRoot;\n    }\n};\n```\n\n时间复杂度：\n遍历了两遍链表，O(n)\n\n空间复杂度：\nO(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441052202","body":"思路：先通过一次遍历找出A和B的长度差，第二次遍历，长的链表先走完差值，再一起走，第一次相遇时即为交叉点\n\n代码：\n```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* moveA = headA, *moveB = headB;\n        \n        while (moveA && moveB) {\n                moveA = moveA->next;\n                moveB = moveB->next;\n        }\n        int minusAB = 0, minusBA = 0;\n        while (moveA) {\n            moveA = moveA->next;\n            minusAB++;\n        }\n        while (moveB) {\n            moveB = moveB->next;\n            minusBA++;\n        }\n        moveA = headA;\n        moveB = headB;\n        while(minusAB--) {\n            moveA = moveA->next;\n        }\n        while (minusBA--) {\n            moveB = moveB->next;\n        }\n        while (moveA && moveB && moveA != moveB) {\n            moveA = moveA->next;\n            moveB = moveB->next;\n        }\n        return moveA;\n    }\n};\n```\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzmt":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429857608","body":"### 思路\n从低位相加，每次将所得之和的个位数push进arr数组, 再将和除以10之后取整，与数组的倒数第二位再相加，以此循环\n### 代码\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const arr = [];\n    let _k = k;\n    let i = num.length - 1;\n    while (i >= 0 || _k > 0) {\n        if (i >= 0) {\n            _k += num[i];\n            i--;\n        }\n        arr.push(_k % 10);\n        _k = parseInt(_k / 10);\n    }\n    return arr.reverse();\n};\n```\n### 复杂度分析\n- 时间复杂度O(n)\n- 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431399034","body":"### 思路\n拿到每一个字符到目标字符的距离，然后再取出最短距离\n### 代码\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    var len = s.length;\n    var res = [];\n    for (var i = 0; i < len; i++) {\n        var distance = [];\n        for (var n = 0; n < len; n++) {\n            if (s[n] === c) {\n                distance.push(Math.abs(i - n));\n            }\n        }\n        res.push(Math.min(...distance))\n    }\n    return res;\n};\n```\n### 复杂度\n- 时间复杂度 O(n^2)\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433164917","body":"### 思路\n- 构造函数主要就是初始化两个值；\n- push在数组最后添加一个元素；\n- pop把数组最后一个元素删除，并返回删除的值即可；\n- increment确定好循环次数\n### 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = [];\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack?.length < this.maxSize) {\n        this.stack = [...this.stack, x]\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    const len = this.stack.length;\n    const lastVal = this.stack[len - 1];\n    this.stack.splice(len - 1, 1)\n    return lastVal || -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const len = this.stack.length > k ? k : this.stack.length;\n    for(let i = 0; i < len; i++) {\n        this.stack[i] += val;\n    }\n};\n```\n### 复杂度\n- 时间复杂度\n  - 初始化, push, pop为O(1)\n  - increment 为O(k)\n- 空间复杂度 O(maxSize)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438467968","body":"### 思路\n使用递归，注意留口子结束递归\n### 代码\n```js\nvar swapPairs = function(head) {\n    if(!head || !head.next){\n        return head\n    }\n\n    const curHead = head.next;\n    head.next = swapPairs(curHead.next);\n    curHead.next = head;\n    return curHead;\n};\n```\n### 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448027449","body":"### 思路\n深度优先搜索\n### 代码\n```js\nconst dfs = (root, prevSum) => {\n    if (root === null) {\n        return 0;\n    }\n    const sum = prevSum * 10 + root.val;\n    if (root.left == null && root.right == null) {\n        return sum;\n    } else {\n        return dfs(root.left, sum) + dfs(root.right, sum);\n    }\n}\nvar sumNumbers = function(root) {\n    return dfs(root, 0);\n};\n```\n### 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456107657","body":"### 思路\n在points里的每一个点都可以作为一个枢纽i，连接两个点j和k。\n双重循环出每一个i与j k之间的距离，如果距离相同的数组个数大于1肯定是回旋镖数组\n### 代码\n```js\nvar map = new Map(),\n    dis,\n    res = 0\n  for (var i = 0; i < points.length; i++) {\n    for (var j = 0; j < points.length; j++) {\n      if (i != j) {\n        dis = distance(points[i], points[j])\n        if (map.has(dis)) {\n          map.set(dis, map.get(dis) + 1)\n        } else {\n          map.set(dis, 1)\n        }\n      }\n    }\n    for (let count of map.values()) {\n      if (count > 1) {\n        res += count * (count - 1)\n      }\n    }\n    map.clear()\n  }\n  return res\n\n  function distance(a, b) {\n    return Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2)\n  }\n```\n### 复杂度\n- 时间复杂度 O(n^2)\n- 空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"munmust":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429862730","body":"### 思路\n1,将k也转化为数组\n2，将两个数组从最后开始相加\n3，通过和得出carry（是否进位），和当前位数的值\n4，最后判断是否有carry，在添加到结果数组里\n5，反转数组得到结果\n\n### 代码\n\n``` javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n    const result = [];\n    let i = num.length - 1;\n    const kArr = `${k}`.split('').map(v => Number(v));\n    let j = kArr.length - 1;\n    let carry = 0;\n    while (i >= 0 || j >= 0) {\n        const sumVal = (num?.[i] || 0) + (kArr?.[j] || 0) + carry;\n        const val = Math.floor(sumVal % 10);\n        carry = Math.floor(sumVal / 10);\n        result.push(val);\n        i--;\n        j--;\n    }\n    if (!!carry) {\n        result.push(carry)\n    }\n    return result.reverse();\n};\n```\n\n### 复杂度\n空间复杂度 O(n)\n时间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431439401","body":"### 思路\n1，得到各个指定字符的位置\n2，遍历字符串，遍历得到的位置的数组\n3，进行两个位置的相减，取最小正整数返回\n### 代码\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n    const sArr = s.split('');\n    const cResult = [];\n\n    sArr.forEach((sItem, index) => {\n        if (sItem === c) {\n            cResult.push(index);\n        }\n    })\n    const result = sArr.map((v, index) => {\n        let min = s.length;\n        cResult.forEach(value => {\n            const nowMin = Math.abs(value - index)\n            min = min < nowMin ? min : nowMin\n        })\n        return min\n    })\n    return result\n};\n\n### 时间复杂度 O(n^2)\n### 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433348222","body":"``` javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n    this.stack = [];\r\n    this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n    if (this.stack.length < this.maxSize) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n    if (this.stack.length === 0) {\r\n        return -1;\r\n    }\r\n    return this.stack.pop();\r\n\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n    let len = Math.min(k, this.stack.length);  //取交集，前n个元素+val\r\n    for (let i = 0; i < len; i++) {\r\n        this.stack[i] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434864272","body":"``` javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s) {\r\n    let numStack = [];\r\n    let strStack = [];\r\n    let num = 0;\r\n    let result = '';\r\n    for (const char of s) {\r\n        if (!isNaN(char)) {\r\n            num = num * 10 + Number(char);\r\n        } else if (char == '[') {\r\n            strStack.push(result);\r\n            result = '';\r\n            numStack.push(num);\r\n            num = 0;\r\n        } else if (char == ']') {\r\n            let repeatTimes = numStack.pop();\r\n            result = strStack.pop() + result.repeat(repeatTimes);\r\n        } else {\r\n            result += char;\r\n        }\r\n    }\r\n    return result;\r\n\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435705721","body":"```jabascript\r\n// 使用两个数组的栈方法（push, pop） 实现队列\r\n/**\r\n* Initialize your data structure here.\r\n*/\r\nvar MyQueue = function() {\r\n   this.stackIn = [];\r\n   this.stackOut = [];\r\n};\r\n\r\n/**\r\n* Push element x to the back of queue. \r\n* @param {number} x\r\n* @return {void}\r\n*/\r\nMyQueue.prototype.push = function(x) {\r\n   this.stackIn.push(x);\r\n};\r\n\r\n/**\r\n* Removes the element from in front of queue and returns that element.\r\n* @return {number}\r\n*/\r\nMyQueue.prototype.pop = function() {\r\n   const size = this.stackOut.length;\r\n   if(size) {\r\n       return this.stackOut.pop();\r\n   }\r\n   while(this.stackIn.length) {\r\n       this.stackOut.push(this.stackIn.pop());\r\n   }\r\n   return this.stackOut.pop();\r\n};\r\n\r\n/**\r\n* Get the front element.\r\n* @return {number}\r\n*/\r\nMyQueue.prototype.peek = function() {\r\n   const x = this.pop();\r\n   this.stackOut.push(x);\r\n   return x;\r\n};\r\n\r\n/**\r\n* Returns whether the queue is empty.\r\n* @return {boolean}\r\n*/\r\nMyQueue.prototype.empty = function() {\r\n   return !this.stackIn.length && !this.stackOut.length\r\n};\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436022969","body":"``` javascript\n  const stack = [];\n  for (let i = 0; i < arr.length; i++) {\n    a = arr[i];\n    if (stack.length > 0 && stack[stack.length - 1] > a) {\n      const cVal = stack[stack.length - 1];\n      while (stack && stack[stack.length - 1] > a) {\n          stack.pop();\n     }\n      stack.push(cVal);\n    } else {\n      stack.push(a);\n    }\n  }\n  return stack.length;\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437091313","body":"```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n    if (head == null || k == 0) return head;\n    let n = 0;\n    let tail = null;\n    for (let p = head; p != null; p = p.next) {\n        tail = p;\n        n++;\n    }\n    k %= n;\n    let p = head;\n    for (let i = 0; i < n - k - 1; i++) p = p.next;\n    tail.next = head;\n    head = p.next;\n    p.next = null;\n    return head;\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438681127","body":"```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function (head) {\n    if (head == null || head.next == null) {\n        return head;\n    }\n    let stack = [];\n    let p = new ListNode(-1);\n    let cur = head;\n    head = p;\n    while (cur != null && cur.next != null) {\n        stack.push(cur);\n        stack.push(cur.next);\n        cur = cur.next.next;\n        p.next = stack.pop();\n        p = p.next;\n        p.next = stack.pop();\n        p = p.next;\n    }\n    if (cur != null) {\n        p.next = cur;\n    } else {\n        p.next = null;\n    }\n    return head.next;\n\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440236978","body":"```jaavascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nconst sortedListToBST = (head) => {\n    if (head == null) return null;\n    let slow = head;\n    let fast = head;\n    let preSlow;\n\n    while (fast && fast.next) {\n        preSlow = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    const root = new TreeNode(slow.val);\n\n    if (preSlow != null) {\n        preSlow.next = null;\n        root.left = sortedListToBST(head);\n    }\n    root.right = sortedListToBST(slow.next);\n    return root;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441879389","body":"```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\n// 磨平长度，两个指针相遇时走过的路程是相同的，但当都走到null的时候表示都到了链表的尾，无相交部分\nvar getIntersectionNode = function (headA, headB) {\n    if (headA == null || headB == null) return null;\n    let APoint = headA;\n    let BPoint = headB;\n    while (APoint != BPoint) {\n        APoint = APoint == null ? headB : APoint.next;\n        BPoint = BPoint == null ? headA : BPoint.next;\n    }\n    return APoint;\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443872690","body":"```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function (head) {\n    let fast = head; let slow = head;\n    while (true) {\n        if (fast == null || fast.next == null) return null;\n        fast = fast.next.next;\n        slow = slow.next;\n        if (fast == slow) break;\n    }\n    fast = head;\n    while (slow != fast) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n    return fast;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445378606","body":"``` javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function (root) {\n    if (root === null) return 0\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446398843","body":"```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function (p, q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val === q.val) {\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n    } else {\n        return false\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451947498","body":"```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function (root) {\n    if (root == null) {\n        return 'X';\n    }\n    const left = serialize(root.left);\n    const right = serialize(root.right);\n    return root.val + ',' + left + ',' + right;\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function (data) {\n    const list = data.split(',');\n\n    const buildTree = (list) => {\n        const rootVal = list.shift();\n        if (rootVal == \"X\") {\n            return null;\n        }\n        const root = new TreeNode(rootVal);\n        root.left = buildTree(list);\n        root.right = buildTree(list);\n        return root;\n    };\n\n    return buildTree(list);\n\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453790734","body":"```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number[][]}\r\n */\r\nvar verticalTraversal = function (root) {\r\n    const resArr = [[]], tempArr = []\r\n    const list = [[root, 0, 0]]\r\n    while (list.length) {\r\n        const tempNode = list.shift()\r\n        tempArr.push([tempNode[0].val, tempNode[1], tempNode[2]])\r\n        if (tempNode[0].left) list.push([tempNode[0].left, tempNode[1] - 1, tempNode[2] + 1])\r\n        if (tempNode[0].right) list.push([tempNode[0].right, tempNode[1] + 1, tempNode[2] + 1])\r\n    }\r\n    tempArr.sort((a, b) => a[1] === b[1] && a[2] === b[2] ? a[0] - b[0] : a[1] - b[1])\r\n    let tempCol = tempArr[0][1]\r\n    for (let z of tempArr) {\r\n        if (z[1] !== tempCol) {\r\n            resArr.push([])\r\n            tempCol = z[1]\r\n        }\r\n        resArr[resArr.length - 1].push(z[0])\r\n    }\r\n\r\n    return resArr\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454798699","body":"```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number[]}\r\n */\r\nvar twoSum = function(nums, target) {\r\nconst map = new Map();\r\n    for(let i = 0; i < nums.length; i++) {\r\n        const remain = target - nums[i];\r\n        if(!map.has(remain)) {\r\n            map.set(nums[i], i)\r\n        } else {\r\n            return [map.get(remain), i]\r\n        }\r\n    }\r\n    return [];\r\n};\r\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456316820","body":"```javascript\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function (points) {\n    let ans = 0;\n    for (const p of points) {\n        const m = new Map();\n        for (const q of points) {\n            const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n            m.set(dis, (m.get(dis) || 0) + 1);\n        }\n        for (const [_, item] of m.entries()) {\n            ans += item * (item - 1);\n        }\n    }\n    return ans;\n\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yan-jie":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429866566","body":"```javascript\nvar addToArrayForm = function(num, k) {\n\n    let result = [];\n    const numberLen = num.length;\n    let reducedK = k;\n    let carry = 0;\n\n    for(let i = numberLen - 1; ; i--){\n        if(num[i] === undefined && reducedK === 0 && carry === 0){\n            break;\n        }\n        const lastInNum = num[i] === undefined ? 0 : num[i];\n        const lastInK = reducedK === 0 ? 0 : reducedK % 10;\n        reducedK = Math.floor(reducedK / 10);\n        const sum = lastInNum + lastInK + carry;\n        const validSum = sum >= 10 ? sum - 10 : sum;\n        carry = sum >= 10 ? 1 : 0\n        result.unshift(validSum);\n    }\n\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431456161","body":"```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    const result = [];\n    const len = s.length;\n    let lastPosition = -1;\n    for(let i = 0; i < len; i++){\n        if(s[i] === c){\n            if(lastPosition === -1){\n                lastPosition = i;\n            }\n            for(let j = 0; j <= i; j++){\n                const oldDistance = result[j];\n\n                const d1 = Math.abs(lastPosition - j);\n                const d2 = Math.abs(i - j)\n                const minDistance = Math.min(d1, d2)\n\n                if(oldDistance === undefined){\n                    result[j] = minDistance\n                }else{\n                    result[j] = Math.min(oldDistance, minDistance)\n                }\n            }\n            lastPosition = i;\n        }\n    }\n\n    // 补充\n    if(lastPosition < len - 1){\n        for(let i = lastPosition; i < len; i++){\n            result[i] = Math.abs(lastPosition - i)\n        }\n    }\n\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432866073","body":"```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.data = new Array(maxSize).fill(null);\n    this.index = -1;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.index < this.maxSize - 1){\n        this.data[this.index + 1] = x;\n        this.index++;\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.index === -1){\n        return -1\n    }\n    const res = this.data[this.index];\n    this.data[this.index] = null;\n    this.index = this.index - 1;\n    return res;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(this.index === -1) return;\n    const loopNumber = Math.min(k, this.index + 1)\n    for(let i = 0; i < loopNumber; i++){\n        this.data[i] = this.data[i] + val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434712099","body":"```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    \n    const resultStack = new Array;\n    for(let i = 0; i < s.length; i++){\n        let tmp = s[i];\n        if(tmp !== ']'){\n            resultStack.push(tmp)\n        } else {\n            let chars = ''\n            while(true){\n                const poped = resultStack.pop();\n                if(poped === '['){\n                    break;\n                } else if(/[a-z]/.test(poped)){\n                    chars = poped + chars;\n                }\n            }\n\n            let repeatNumStr = ''\n            while(true){\n                let popedNum = resultStack.pop();\n                if(/\\d/.test(popedNum)){\n                    repeatNumStr = popedNum + repeatNumStr;\n                }else{\n                    resultStack.push(popedNum);\n                    break;\n                }\n            }\n\n            const repeatNum = Number(repeatNumStr);\n            for(let j = 0; j < repeatNum; j++){\n                for(let c of chars){\n                    resultStack.push(c);\n                }\n            }\n        }\n    }\n\n    return resultStack.join('')\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435699161","body":"```javascript\nvar MyQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\n\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x);\n};\n\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack.pop();\n};\n\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack[this.outStack.length - 1];\n};\n\nMyQueue.prototype.empty = function() {\n    return this.outStack.length === 0 && this.inStack.length === 0;\n};\n\nMyQueue.prototype.in2out = function() {\n    while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop());\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437867577","body":"```javascript\nvar swapPairs = function(head) {\n    if(head === null || head.next === null){\n        return head;\n    }\n    const newHead = head.next;\n    head.next = swapPairs(head.next.next);\n    newHead.next = head;\n    return newHead;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hktangshuo":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429871860","body":"有bug\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length - 1;\n        LinkedList<Integer> res = new LinkedList<>();\n\n        int c = k;\n        while (n >= 0) {\n            int tmp = num[n]+c;\n\n            res.addFirst(tmp%10);\n            c=tmp/10;\n\n            n--;\n        };\n        while (c!=0){\n            res.addFirst(c);\n\n            c=c/10;\n\n        }\n\n        return res;\n    }\n\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpbc007":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429891929","body":"# 思路\n- k % 10 得到当前位的数值\n- Math.floor(k / 10 ) 得到向上一位的值\n- 将 k 直接加到数组最后一位，并不断向上进位，直到数组遍历完毕 & k 为0\n\n# 代码\nfunction addToArrayForm(num: number[], k: number): number[] {\n    const result: number[] = []\n    \n    for (let index = num.length - 1; index >= 0 || k > 0;index--, k = Math.floor(k / 10)) {\n        if (index >= 0) {\n            k += num[index]\n        }\n        \n        result.unshift(k%10)\n    }\n    \n    return result\n};\n\n# 复杂度分析\n时间复杂度：O（Max(num.length,k))\n空间复杂度：O（num.length)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431481273","body":"# 思路\n正序遍历数组，得到距离左侧节点的距离，逆序遍历数组，得到距离右侧节点的距离\n\n# 代码\n```ts\nfunction shortestToChar(s: string, c: string): number[] {\n    const result: number[] = []\n\n    let lastIndex = -1\n    for (let index = 0; index < s.length ; index++) {\n        const char = s[index]\n\n        if (char === c) {\n            lastIndex = index\n        }\n\n        result[index] = lastIndex === -1 ? s.length : index - lastIndex\n    }\n\n    lastIndex = -1\n    for (let index = s.length - 1; index >= 0; index--) {\n        const char = s[index]\n\n        if (char === c) {\n            lastIndex = index\n        }\n\n        result[index] = lastIndex === -1 ? result[index] : (result[index] < lastIndex - index ? result[index] : lastIndex - index)\n    }\n    return result\n};\n```\n\n# 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433298451","body":"# 思路\n一个 stack 维护原始数据，一个 stack 维护后续每个元素增加的值。在 pop 的时候再把值加上\n\n# 代码\nclass CustomStack {\n    // 存放数据\n    private dataArr: number[] = []\n\n    // 存放每次增加的值\n    private incrementVal: number[] = []\n\n    // 栈顶指针\n    private topIndex = -1\n\n    constructor(private maxSize: number) {}\n\n    push(x: number): void {\n        if (this.topIndex < this.maxSize - 1) {\n            this.dataArr[++this.topIndex] = x\n        }\n    }\n\n    pop(): number {\n        if (this.topIndex === -1) {\n            return -1\n        }\n\n        const result = this.dataArr[this.topIndex] + (this.incrementVal[this.topIndex] ? this.incrementVal[this.topIndex] : 0)\n        this.dataArr[this.topIndex] = 0\n        this.incrementVal[this.topIndex] = 0\n        this.topIndex--\n\n        return result\n    }\n\n    increment(k: number, val: number): void {\n        const maxIndex = Math.min(k, this.topIndex + 1)\n\n        for (let i = 0; i < maxIndex; i++) {\n            this.incrementVal[i] = this.incrementVal[i] ? this.incrementVal[i] + val : val\n        }\n    }\n}\n\n# 复杂度\n时间复杂度：\n- pop O(1)\n- increment O(1)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434700825","body":"# 思路\r\n遇到非 ']' 都入栈，遇到 ']' 出栈。出栈的时候向前解析数字\r\n\r\n# 代码\r\n```ts\r\nexport function decodeString(s: string): string {\r\n    const stack: string[] = []\r\n\r\n    for (let c of s) {\r\n        if (c !== ']') {\r\n            stack.push(c)\r\n        } else {\r\n            let tmpStr = ''\r\n            while(true) {\r\n                const stackChar = stack.pop()\r\n                \r\n                if (stackChar !== '[') {\r\n                    tmpStr = stackChar + tmpStr\r\n                } else {\r\n                    let stackNumStr = ''\r\n\r\n                    while(true) {\r\n                        const stackNumChar = stack.pop()\r\n                        const stackNum = Number(stackNumChar)\r\n\r\n                        // 取出的是数字，添加到数字字符串中\r\n                        if (!Number.isNaN(stackNum)) {\r\n                            stackNumStr = stackNumChar + stackNumStr\r\n                        } else { // 不是数字，说明数字到头了，把多取出来的再放回去\r\n                            stack.push(stackNumChar!)\r\n                            stack.push(tmpStr.repeat(Number(stackNumStr)))\r\n\r\n                            break\r\n                        }\r\n\r\n                        // stack 已经空了，开始计算\r\n                        if (stack.length === 0) {\r\n                            stack.push(tmpStr.repeat(Number(stackNumStr)))\r\n\r\n                            break\r\n                        }\r\n                    }\r\n\r\n                    break\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    return stack.join('')\r\n};\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(N) 原数组所有字母入栈，再出栈一次\r\n空间复杂度：O(N) 使用栈存储原有字符串","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435520184","body":"## 思路\r\n\r\n队列：先入先出\r\n栈：先入后出\r\n为了能快速的从栈中读取栈底的值，可以使用两个栈：\r\n- 一个栈用于插入数据\r\n- 一个栈用于读取数据\r\n当读取数据栈为空时，从插入数据栈中把所有数据再导入到读取数据栈，这样原始数据经过两次 `先入后出` 就变成了 `先入先出`\r\n\r\n## 代码\r\n\r\n```ts\r\n// push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\nclass MyStack<T> {\r\n    private valueContainer: T[] = []\r\n\r\n    push(val: T) {\r\n        this.valueContainer.push(val)\r\n    }\r\n\r\n    pop(): T | undefined {\r\n        return this.valueContainer.pop()\r\n    }\r\n\r\n    peek(): T | undefined {\r\n        return this.valueContainer[this.valueContainer.length - 1]\r\n    }\r\n\r\n    size(): number {\r\n        return this.valueContainer.length\r\n    }\r\n\r\n    isEmpty(): boolean {\r\n        return this.valueContainer.length === 0\r\n    }\r\n}\r\n\r\nexport class MyQueue {\r\n    // 插入数据\r\n    private insertStack = new MyStack<number>()\r\n    // 读取数据\r\n    private readStack = new MyStack<number>()\r\n\r\n    constructor() {}\r\n\r\n    push(x: number): void {\r\n        this.insertStack.push(x)\r\n    }\r\n\r\n    pop(): number {\r\n        if (!this.readStack.isEmpty()) {\r\n            return this.readStack.pop()!\r\n        }\r\n\r\n        if (!this.insertStack.isEmpty()) {\r\n            this.insert2Read()\r\n\r\n            return this.readStack.pop()!\r\n        }\r\n\r\n        return -1\r\n    }\r\n\r\n    peek(): number {\r\n        if (!this.readStack.isEmpty()) {\r\n            return this.readStack.peek()!\r\n        }\r\n\r\n        if (!this.insertStack.isEmpty()) {\r\n            this.insert2Read()\r\n\r\n            return this.readStack.peek()!\r\n        }\r\n\r\n        return -1\r\n    }\r\n\r\n    empty(): boolean {\r\n        return this.readStack.isEmpty() && this.insertStack.isEmpty()\r\n    }\r\n\r\n    private insert2Read() {\r\n        while(!this.insertStack.isEmpty()) {\r\n            this.readStack.push(this.insertStack.pop()!)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n### 时间复杂度\r\n- push、empty: O(1)\r\n- pop、peek: O(1) （每个元素只会在两个栈中各出现一次）\r\n\r\n### 空间复杂度\r\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436006081","body":"# 解法1\r\n## 思路\r\n观察排序后的数组，和被分隔后的数组。每块被分隔后的数组中各个数字出现的频次，和排序后的数组一定是一致的。\r\n因此再排序数组中，每个数字出现其频次 `+1`，在原始数组中每个数字出现其频次 `-1`，如果出现各个数字的频次都为 0 时，则说明此时可以进行一次分割\r\n\r\n## 代码\r\n```ts \r\nfunction maxChunksToSorted(arr: number[]): number {\r\n    // 排序后的数组\r\n    const sortedArr = [...arr].sort((a, b) => a - b)\r\n    const map = new Map<number, number>()\r\n    let result = 0\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        const sortedNum = sortedArr[i]\r\n        const num = arr[i]\r\n\r\n        // 在排序数组中出现，频次 +1\r\n        map.set(sortedNum, (map.get(sortedNum) || 0) + 1)\r\n        if (map.get(sortedNum) === 0) {\r\n            map.delete(sortedNum)\r\n        } \r\n\r\n        // 在原始数组中出现，频次 -1\r\n        map.set(num, (map.get(num) || 0) - 1)\r\n        if (map.get(num) === 0) {\r\n            map.delete(num)\r\n        }\r\n\r\n        // 频次相等，可以分隔\r\n        if (map.size === 0) {\r\n            result++\r\n        }\r\n    }\r\n\r\n    return result\r\n};\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：数组的排序 O(NlogN)\r\n空间复杂度：多了一个排序数组 O(N)\r\n\r\n# 解法2\r\n## 思路\r\n假设当前已经有了几个块，当加入新的数字后，可能会出现以下情况\r\n- 新增数字大于最后一个块的最大值，则最后加入的数字自己可以成为新的区块\r\n- 新增数字小于最后一个块的最大值，则需要将后面的区块融合，直到加入的数字大于前一个区块的最大值，或者只剩最后一个区块了\r\n\r\n## 代码\r\n```ts\r\nclass MyStack {\r\n    private val: number[] = []\r\n\r\n    isEmpty() {\r\n        return this.val.length === 0\r\n    }\r\n\r\n    peek() {\r\n        return this.isEmpty() ? 0 : this.val[this.val.length - 1]\r\n    }\r\n\r\n    pop() {\r\n        return this.isEmpty() ? 0 : this.val.pop()!\r\n    }\r\n\r\n    push(val: number) {\r\n        this.val.push(val)\r\n    }\r\n\r\n    size() {\r\n        return this.val.length\r\n    }\r\n}\r\n\r\nfunction maxChunksToSorted(arr: number[]): number {\r\n    return arr.reduce((stack, item) => {\r\n        if (!stack.isEmpty() && item < stack.peek()) {\r\n            const max = stack.pop()\r\n            while(!stack.isEmpty() && item < stack.peek()) {\r\n                stack.pop()\r\n            }\r\n\r\n            stack.push(max)\r\n        } else {\r\n            stack.push(item)\r\n        }\r\n\r\n        return stack\r\n    }, new MyStack()).size()\r\n}\r\n```\r\n## 复杂度\r\n时间复杂度：数组遍历一次 O(N)\r\n空间复杂度：多了一个栈存储最大值 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437047730","body":"# 思路\n快慢指针，先让头指针移动 K 次，然后头尾指针同时移动，直到头指针移动到链表尾部。\n此时让头节点指向链表的头，尾结点的下个节点作为新链表的头结点，并将尾结点清空。\n\n# 代码\n```ts\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n    if (!head || head.next == null) {\n        return head\n    }\n\n    let first: ListNode | null = head\n    let last: ListNode | null = head\n    let step = 0\n\n    // 第一个指针先移动 K \n    let index = 0\n    while (index < k) {\n        first = move2Next({cur: first, head})\n\n        index++\n    }\n\n\n    while (first.next !== null) {\n        first = move2Next({cur: first, head})\n        last = move2Next({cur: last, head})\n        \n        step++\n    }\n\n    first.next = head\n    const newHead = last!.next\n    last!.next = null\n\n    return newHead\n};\n\n/**\n * 考虑循环移动的场景\n */\nfunction move2Next({ cur, head }: { cur: ListNode, head: ListNode }) {\n    if (cur.next) {\n        return cur.next\n    }\n\n    return head\n}\n```\n# 复杂度分析\n- 时间复杂度：整个链表遍历一次 O(N)\n- 空间复杂度：无额外开销 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437761954","body":"# 解法 1\n\n递归\n\n## 思路\n\n第一个节点 -> 第二个节点\n\n1. 用临时变量存储第二个节点\n2. 让第一个节点指向交换后的第二个节点的下一个节点（递归）\n3. 第二个节点指向第一个节点\n\n## 代码\n\n```ts\nfunction swapPairs(head: ListNode | null): ListNode | null {\n    // 头结点不存在 | 只有一个节点\n    if (!head || !head.next) {\n        return head\n    }\n\n    let tmp: ListNode | null = null\n\n    tmp = head.next\n    head.next = swapPairs(head.next.next)\n    tmp.next = head\n\n    return tmp\n}\n```\n\n## 复杂度\n\n-   空间复杂度：O(1)\n-   时间复杂度：O(N) 整个链表遍历一遍\n\n# 解法 2\n\n循环\n\n## 思路\n\n1. pre 存储当前头结点的上一个节点\n2. 正常交换节点\n3. 如果有 pre 更新下 pre 的指向\n4. 头节点移动到下个位置\n\n## 代码\n\n```ts\nfunction swapPairs(head: ListNode | null): ListNode | null {\n    if (!head || !head.next) {\n        return head\n    }\n    let tmp: ListNode | null = null\n    let newHead: ListNode | null = null\n    let pre: ListNode | null = null\n\n    while (head && head.next) {\n        // 两两交换\n        tmp = head.next\n        head.next = head.next.next\n        tmp.next = head\n\n        if (pre) {\n            pre.next = tmp\n        }\n        // 移动到下个位置\n        head = tmp.next.next\n        pre = tmp.next\n        if (!newHead) {\n            newHead = tmp\n        }\n    }\n\n    return newHead\n}\n```\n\n## 复杂度\n\n-   空间复杂度：O(1)\n-   时间复杂度：O(N) 整个链表遍历一遍\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440253529","body":"## 思路\n\n链表的顺序，与中序遍历的输出顺序是一致的。基于此按照中序遍历创建一棵树，并不断填值，就能得到想要的结果了\n\n## 代码\n```ts\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    if (!head) {\n        return null\n    }\n\n    const len = getListLen(head)\n\n    function buildBSTFromList(start: number, end: number): TreeNode | null {\n        if (end <= start) {\n            return null\n        }\n\n        const mid = (start + end) >>> 1\n        const leftNode = buildBSTFromList(start, mid)\n        const root = new TreeNode(head!.val)\n        head = head!.next\n        const rightNode = buildBSTFromList(mid + 1, end)\n\n        root.left = leftNode\n        root.right = rightNode\n\n        return root\n    }\n\n    return buildBSTFromList(0, len)\n}\n\n/** 获取链表长度 */\nfunction getListLen(head: ListNode | null) {\n    let len = 0\n\n    while (head) {\n        len++\n        head = head.next\n    }\n\n    return len\n}\n\n```\n\n## 复杂度分析\n- 时间复杂度: O(N)\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441710152","body":"## 思路\nA 不相交长度 = m, B 不相交长度 = n, 相交部分长度 c\n1. 相交\n 1.1 lengthA === lengthB\n     两个指针同时走到相交节点\n 1.2 lengthA !== lengthB\n     pointA 移动：m + c + n\n     pointB 移动: n + c + m\n     同时移动到相交节点\n2. 不相交\n 2.1 lengthA === lengthB\n     两个指针同时走到尾结点 Null\n 2.2 lengthA !== lengthB\n     pointA 移动: m + c + n + c\n     pointB 移动: n + c + m + c\n\n## 代码\n```ts\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n    if (!headA || !headB) {\n        return null\n    }\n\n    let pointA: ListNode | null = headA\n    let pointB: ListNode | null = headB\n\n    while (pointA !== pointB) {\n        pointA = pointA === null ? headB : pointA.next\n        pointB = pointB === null ? headA : pointB.next\n    }\n\n    return pointA\n}\n```\n\n## 复杂度\n- 时间复杂度: O(m + n)\n- 空间复杂度: O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443795403","body":"## 思路\r\n- slow 指针移动 S，fast 指针移动 F，则有 F = 2S (快节点移动的距离是慢节点的2倍)\r\n- 非环长度为 a，环长度为 b，二者相遇时，F - S = n*b (套圈了) \r\n- 因此 2S - S = n * b => S = n * b (慢节点移动的总距离是环的长度的 n 倍)\r\n- 入口节点位置：a + nb \r\n- 只要 slow 指针再移动 a 即可到达入口\r\n\r\n## 代码\r\n```ts\r\nfunction detectCycle(head: ListNode | null): ListNode | null {\r\n    if (!head) {\r\n        return null\r\n    }    \r\n\r\n    let slow: ListNode | null = head\r\n    let fast:  ListNode | null = head\r\n\r\n    while(fast !== null) {\r\n        slow = slow?.next  || null\r\n        fast = fast?.next?.next || null\r\n\r\n        /**\r\n         * 快慢节点相遇\r\n         */\r\n        if (slow === fast && fast !== null) {\r\n            fast = head\r\n            while (slow !== fast) {\r\n                fast = fast!.next\r\n                slow = slow!.next\r\n            }\r\n\r\n            return slow\r\n        }\r\n    }\r\n\r\n    return null\r\n};\r\n```\r\n## 复杂度\r\n- 空间复杂度 O(1)\r\n- 时间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445145756","body":"## 思路\r\n使用 map 存储节点信息，使用链表存储节点访问情况\r\n\r\n## 代码\r\n```ts\r\nimport { ListNode } from \"@utils/list-node\"\r\n\r\nexport class LRUCache {\r\n    private dataNodeMap = new Map<number, ListNode<{key: number, val: number}>>()\r\n    private outdateLink = new ListNode<{key: number, val: number}>()\r\n\r\n    constructor(private readonly capacity: number) {}\r\n\r\n    get(key: number): number {\r\n        if (!this.dataNodeMap.has(key)) {\r\n            return -1\r\n        }\r\n        const node = this.dataNodeMap.get(key)!\r\n        this.updateNode(node)\r\n\r\n        return node.val.val\r\n    }\r\n\r\n    put(key: number, value: number): void {\r\n        // 更新逻辑\r\n        if (this.dataNodeMap.has(key)) {\r\n            const node = this.dataNodeMap.get(key)!\r\n            node.val.val = value\r\n            this.updateNode(node)\r\n        } else { // 插入逻辑\r\n            const node = new ListNode<{key: number, val: number}>({key, val: value})\r\n            this.dataNodeMap.set(key, node)\r\n            node.next = this.outdateLink.next\r\n            this.outdateLink.next = node\r\n\r\n            this.removeTailNode()\r\n        }\r\n    }\r\n\r\n    // 删除过期的尾节点\r\n    private removeTailNode() {\r\n        let index = 0\r\n        let cur = this.outdateLink\r\n        while (cur) {\r\n            if (index > this.capacity) {\r\n                this.dataNodeMap.delete(cur.val.key)\r\n                cur.next = null\r\n            }\r\n            cur = cur.next!\r\n            index++\r\n        }\r\n    }\r\n\r\n    private updateNode(node: ListNode<{key: number, val: number}>) {\r\n        let pre: ListNode<{key: number, val: number}> = this.outdateLink    \r\n        let cur: ListNode<{key: number, val: number}> = this.outdateLink.next!\r\n\r\n        while (cur !== node) {\r\n            pre = cur\r\n            cur = cur.next!\r\n        }\r\n\r\n        pre.next = cur.next\r\n        cur.next = this.outdateLink.next\r\n        this.outdateLink.next = cur\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n- get: O(N) \r\n- put: O(N)\r\n\r\n## 备注\r\n目前是使用单向链表实现的，导致 get put 复杂度都不是 O(1)，使用双向链表即可进行优化","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445359062","body":"# 思路\r\n当前节点最大深度为 左右两侧节点最大深度 + 1\r\n\r\n# 代码\r\n``` ts\r\n\r\nfunction maxDepth(root: TreeNode | null): number {\r\n    if(!root) {\r\n        return 0\r\n    }\r\n    \r\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1\r\n};\r\n```\r\n\r\n# 复杂度\r\n时间复杂度 O(N)\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446451689","body":"# 思路\n两颗树相等，满足以下条件\n- 当前节点值相等\n- 左侧树相等\n- 右侧树相等\n\n# 代码\n```ts\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n    if (p === null || q === null) {\n        return p === q\n    }\n\n    if (p.val !== q.val) {\n        return false\n    }\n\n    return (\n        isSameTree(p.left || null, q.left || null) && isSameTree(p.right || null, q.right || null)\n    )\n}\n```\n\n# 复杂度分析\n- 时间复杂度 O(N)\n- 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448375434","body":"# 思路\n\n深度优先遍历，父节点 `sum * 10` + 当前节点值得到新的 sum。\n\n# 代码\n\n```ts\nfunction sumNumbers(root: TreeNode | null): number {\n    return dfs(root, 0)\n}\n\nfunction dfs(root: TreeNode | null, sum: number): number {\n    // 空节点不进位\n    if (!root) {\n        return 0\n    }\n\n    // sum * 10 相当于之前的节点进位了\n    const currentSum = sum * 10 + root.val\n    // 叶子节点\n    if (!root.left && !root.right) {\n        return currentSum\n    }\n\n    return dfs(root.left, currentSum) + dfs(root.right, currentSum)\n}\n```\n# 复杂度分析\n\n-   空间复杂度 O(N) 调用栈高度\n-   时间内复杂度 O(N) 每个节点遍历一遍\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1451956252","body":"# 思路 1\r\n\r\n使用 DFS，如果当前节点深度大于结果的深度，则更新结果\r\n\r\n# 代码\r\n\r\n```ts\r\nfunction findBottomLeftValue(root: TreeNode | null): number {\r\n    let resultLevel = -1\r\n    let result = 0\r\n    const dfs = (node: TreeNode | null, level: number) => {\r\n        if (!node) {\r\n            return\r\n        }\r\n\r\n        if (level > resultLevel) {\r\n            result = node.val\r\n            resultLevel = level\r\n        }\r\n\r\n        dfs(node.left, level + 1)\r\n        dfs(node.right, level + 1)\r\n    }\r\n\r\n    dfs(root, 0)\r\n\r\n    return result\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n\r\n-   时间复杂度：O(N) 所有节点过一遍\r\n-   空间复杂度：O(N) 递归栈深度\r\n\r\n# 思路 2\r\n\r\n是用 BFS，每一层从右向左遍历，每个节点都去更新结果，最后更新的一定是最深 & 最左边的\r\n\r\n# 代码\r\n\r\n```ts\r\nfunction findBottomLeftValue(root: TreeNode | null): number {\r\n    const queue = [root]\r\n    let result = 0\r\n\r\n    while (queue.length) {\r\n        const node = queue.shift()\r\n        if (node?.right) {\r\n            queue.push(node.right)\r\n        }\r\n\r\n        if (node?.left) {\r\n            queue.push(node.left)\r\n        }\r\n\r\n        if (node) {\r\n            result = node.val\r\n        }\r\n    }\r\n\r\n    return result\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n\r\n- 时间复杂度：O(N) 所有节点过一遍\r\n- 空间复杂度：O(N) 队列节点最多 `N / 2`(最后一层)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1452103049","body":"# 思路\n\n## 序列化\n使用 DFS 序列化，使用 `,` 分隔\n\n## 反序列化\n使用 `,` 转为数组后，从头遍历，构建当前节点以及左右子树\n\n# 代码\n```ts\n function serialize(root: TreeNode | null): string {\n    const dfs = (node: TreeNode | null, str: string): string => {\n        if (!node) {\n            return str ? `${str},null` : 'null'\n        }\n\n        str = str ? `${str},${node.val}` : `${node.val}`\n        str = dfs(node.left, str)\n        str = dfs(node.right, str)\n\n        return str\n    }\n\n    return dfs(root, '')\n}\n function deserialize(data: string): TreeNode | null {\n    if (!data) {\n        return null\n    }\n\n    const buildNode = (valueArr: string[]): TreeNode | null => {\n        const nodeValue = valueArr.shift()\n        if (nodeValue === 'null') {\n            return null\n        }\n\n        const node = new TreeNode(Number(nodeValue))\n        node.left = buildNode(valueArr)\n        node.right = buildNode(valueArr)\n\n        return node\n    }\n\n    return buildNode(data.split(','))\n}\n\n```\n\n# 复杂度\n## 序列化\n- 时间复杂度：O(N) 所有节点遍历一遍\n- 空间复杂度：O(N) 递归\n\n## 反序列化\n- 时间复杂度：O(N)所有节点构建一遍\n- 空间复杂度：O(N)递归","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453643229","body":"# 思路\n\n使用先序遍历，将节点放入 map 中，map 的 key 为 col, value 为每一行的节点值。\n需要注意的是需要对 map 的 key 做一次排序\n\n# 代码\n\n```ts\nfunction verticalTraversal(root: TreeNode | null): number[][] {\n    if (!root) {\n        return []\n    }\n\n    const result: Map<number, number[][]> = new Map()\n\n    const dfs = (node: TreeNode | null, { row, col }: { row: number; col: number }) => {\n        if (!node) {\n            return\n        }\n\n        if (!result.has(col)) {\n            result.set(col, [])\n        }\n\n        const colData = result.get(col)!\n        if (!colData[row]) {\n            colData[row] = []\n        }\n\n        colData[row].push(node.val)\n        dfs(node.left, { row: row + 1, col: col - 1 })\n        dfs(node.right, { row: row + 1, col: col + 1 })\n    }\n\n    dfs(root, { row: 0, col: 0 })\n\n    return (\n        Array.from(result.keys())\n            // 保证顺序\n            .sort((a, b) => a - b)\n            .map((col) => {\n                const rowData = result.get(col)!\n\n                return rowData\n                    .map((rowItem) => {\n                        if (rowItem.length === 1) {\n                            return rowItem[0]\n                        }\n\n                        return rowItem.sort()\n                    })\n                    .flat()\n            })\n    )\n}\n```\n\n# 复杂度分析\n\n- 时间复杂度: O(NLogN) 每行的节点排序\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454350714","body":"# 思路\n\n遍历数组，在遍历过程中构建 map。map 的 key 为数组元素的值，value 为值对应的 index。\n如果在 map 中存在 target - currentValue 的元素，就找到了结果\n\n# 代码\n\n```ts\nfunction twoSum(nums: number[], target: number): number[] {\n    return nums.reduce<{ done: boolean; numIndexMap: Map<number, number>; result: number[] }>(\n        (acc, num, index) => {\n            if (acc.done) {\n                return acc\n            }\n\n            if (acc.numIndexMap.has(target - num)) {\n                return {\n                    ...acc,\n                    done: true,\n                    result: [index, acc.numIndexMap.get(target - num)!],\n                }\n            }\n\n            acc.numIndexMap.set(num, index)\n            return acc\n        },\n        {\n            done: false,\n            numIndexMap: new Map(),\n            result: [],\n        },\n    ).result\n}\n```\n\n# 复杂度\n\n-   时间复杂度：O(N) 数组的遍历\n-   空间复杂度：O(N) 构建了一个 map\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1454968495","body":"# 思路\n\n遍历数组，将数字出现的频次存储在 map 中。依照出现频次，对 map 的 key 排序，取出前 k 个\n\n# 优化\n\n对 key 的排序的复杂度为 N(logN)，由于我们只需要前 K 个，可以构造一个最小堆，\n\n-   如果 `heap.size() < K` 直接将当前 key 加入堆中，\n-   如果 `heap.size() >= K` & 堆顶 key 对应的频次小于当前 key 对应的频次，将对顶推出，当前 key 加入堆\n\n# 代码\n\n```ts\nfunction topKFrequent(nums: number[], k: number): number[] {\n    const frequentMap = nums.reduce((frequentMap, num) => {\n        frequentMap.set(num, (frequentMap.get(num) || 0) + 1)\n\n        return frequentMap\n    }, new Map<number, number>())\n\n    const minHeap = Array.from(frequentMap.keys()).reduce((minHeap, num) => {\n        const frequent = frequentMap.get(num)!\n        if (minHeap.size() < k) {\n            minHeap.add({\n                num,\n                frequent,\n            })\n        } else {\n            const head = minHeap.peek()!\n            if (frequent > head.frequent) {\n                minHeap.poll()\n                minHeap.add({\n                    num,\n                    frequent,\n                })\n            }\n        }\n        return minHeap\n    }, new MinHeap<{ num: number; frequent: number }>((a, b) => a.frequent - b.frequent))\n\n    const result: number[] = []\n    while (minHeap.size()) {\n        result.unshift(minHeap.poll()!.num)\n    }\n\n    return result\n}\n```\n\n# 复杂度\n\n- 时间复杂度：O(NlogK)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455575913","body":"# 思路\n\n-   使用 `(x1-x2)^2 + (y1-y2)^2` 计算节点距离（为了性能没有开根号，且用不到真实的距离）\n-   如果有 `M` 个节点离节点 A 距离相同，共有：`A(M, 2) = M! / (M - 2)! = M * (M - 1)` 个可能性\n-   遍历节点，计算所有节点与当前节点的距离，并记录节点数量\n\n# 代码\n\n```ts\nfunction numberOfBoomerangs(points: number[][]): number {\n    let result = 0\n    for (let point1 of points) {\n        const distanceMap = new Map<number, number>()\n\n        // 同一个点也会被 set 进去，但 size === 1，不影响结果\n        for (let point2 of points) {\n            const distance = Math.pow(point1[0] - point2[0], 2) + Math.pow(point1[1] - point2[1], 2)\n            distanceMap.set(distance, (distanceMap.get(distance) || 0) + 1)\n        }\n\n        for (const [_, size] of distanceMap) {\n            result += size * (size - 1)\n        }\n    }\n\n    return result\n}\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(N^2)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457576497","body":"# 思路\n\n双指针，一个指向当前遍历位置，一个指向当前不重复子串的起点。遍历过程中，不断更新各个字符所处的最后 index，存储在 map 中。\n- 当 map 中存在当前 char 的位置时，更新 start 位置（为了避免删除 map 中的数据，需要使用 `Math.max(start, currentCharPreIndex + 1)` 更新 star）\n- 当前不重复子串的长度为 `end - start + 1`\n\n# 代码\n\n```ts\nexport function lengthOfLongestSubstring(s: string): number {\n    const len = s.length\n    let result = 0\n    const charIndexMap = new Map<string, number>()\n\n    for (let start = 0, end = 0; end < len; end++) {\n        const currentChar = s[end]\n        // 需要考虑 index 为 0 的情况\n        const currentCharPreIndex =\n            charIndexMap.get(currentChar) === undefined ? -1 : charIndexMap.get(currentChar)!\n        charIndexMap.set(currentChar, end)\n\n        // 有重复的字符，重置起点\n        if (currentCharPreIndex !== -1) {\n            start = Math.max(start, currentCharPreIndex + 1)\n        }\n\n        result = Math.max(end - start + 1, result)\n    }\n\n    return result\n}\n```\n\n# 复杂度\n\n-   时间复杂度: O(N) 两个指针各遍历字符串一次\n-   空间复杂度: O(N) 存储 index\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459864236","body":"# 思路\n\n- 检查 `s` 中每一个长度为 `words[0].length * words.length` 的字符串是否满足条件\n- 构建 map 存储单词频次，每个在 `words` 中出现的词，频次 `+ 1`\n- 对待检查的子串 `s1`，按 `words[0].length` 进行分割后，每个 `s1` 中出现的单词：\n    - 在 map 中不存在，当前子串不满足条件\n    - 在 map 中存在，频次 `- 1`，如果频次为 0，则在 map 中删除\n- `map.size === 0` 则子串 `s1` 满足条件，否则不满足\n\n# 代码\n\n```ts\nexport function findSubstring(s: string, words: string[]): number[] {\n    if (!words.length) {\n        return []\n    }\n\n    const { check, wordStrLen } = isWordString(words)\n\n    let result: number[] = []\n    for (let start = 0; start < s.length - wordStrLen + 1; start++) {\n        // 需要被检查的字符串\n        const currentStr = s.slice(start, start + wordStrLen)\n\n        // 满足条件\n        if (check(currentStr)) {\n            result.push(start)\n        }\n    }\n\n    return result\n}\n\nconst isWordString = (words: string[]) => {\n    const wordItemLen = words[0].length\n    const wordStrLen = wordItemLen * words.length\n\n    return {\n        wordStrLen,\n        check: (str: string) => {\n            // 长度不够\n            if (str.length < wordStrLen) {\n                return false\n            }\n            \n            const wordMap = words.reduce((map, word) => {\n                map.set(word, (map.get(word) || 0) + 1)\n                return map\n            }, new Map<string, number>())\n            const strWords = splitStringByLen(str, wordItemLen)\n\n            for (const word of strWords) {\n                // 不存在的词\n                if (!wordMap.has(word)) {\n                    return false\n                }\n\n                // 剩余次数\n                const num = wordMap.get(word)!\n\n                // 次数归零，直接删除\n                if (num - 1 === 0) {\n                    wordMap.delete(word)\n                } else {\n                    wordMap.set(word, num - 1)\n                }\n            }\n\n            // map 里不应该再有剩余\n            return wordMap.size === 0\n        },\n    }\n}\n\nconst splitStringByLen = (str: string, len: number) => {\n    const result: string[] = []\n\n    for (let i = 0; i < str.length; i = i + len) {\n        result.push(str.slice(i, i + len))\n    }\n\n    return result\n}\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(ls * m) ls 为 s 长度，m 为单词数\n- 空间复杂度: O(m * n) m 为 words 的单词数，n 为 words 中的单词长度（使用 map 存储频次）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461713093","body":"# 思路\n\n-   `sum(nums) % p === x`, 则需要找到子数组 sub 使得 `sum(sub) % p === x`\n-   构造前缀和数组，并遍历。\n    -   当前值为 a，且 `a % p === y`，如果有以 a 为终点的子数组，则 a 之前一定有 b 使得 `b % p === y - x`\n    -   将 `a % p` 的值存入 map 中，key 为模的值，value 为下标\n    -   如果在 map 中找到了对应的 b，则更新 result\n-   将 map 的初始值设为`0: -1`（模为 0 的 index 为 -1，为了满足子数组是原始数组开头的场景）\n\n# 代码\n\n```ts\nexport function minSubarray(nums: number[], p: number): number {\n    const { preSum, total } = nums.reduce<{\n        preSum: number[]\n        total: number\n    }>(\n        (acc, item) => {\n            acc.total = acc.total + item\n            acc.preSum.push(acc.total)\n\n            return acc\n        },\n        {\n            preSum: [],\n            total: 0,\n        },\n    )\n\n    const mod = total % p\n    if (mod === 0) {\n        return 0\n    }\n\n    let result = nums.length\n    const modMap = new Map<number, number>()\n    // 如果数组前部分为答案，需要找到 mod 为 0 的 index\n    modMap.set(0, -1)\n\n    preSum.forEach((num, index) => {\n        const currentMod = num % p\n        // 为了避免是负数这里加了个 p\n        const targetMod = (currentMod - mod + p) % p\n\n        if (modMap.has(targetMod)) {\n            const targetIndex = modMap.get(targetMod)!\n            result = Math.min(result, index - targetIndex)\n        }\n\n        modMap.set(currentMod, index)\n    })\n\n    return result === nums.length ? -1 : result\n}\n```\n\n# 复杂度分析\n\n-   时间复杂度：O(N) 两次遍历\n-   空间复杂度：O(N) map 存储\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463351913","body":"# 思路\n\n快慢指针，快指针指向 null 节点时，慢节点指向中点\n\n# 代码\n\n```ts\nfunction middleNode(head: ListNode | null): ListNode | null {\n    let slow = head\n    let fast = head\n\n    while (fast && fast.next) {\n        slow = slow!.next\n\n        fast = fast.next.next\n    }\n\n    return slow\n}\n```\n\n# 复杂度\n\n-   时间复杂度：O(N)\n-   空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464904803","body":"# 思路\n\n双指针，指针 slow 指向不重复的最后一个元素，指针 fast 指向遍历中的当前元素。如果两指针指向的元素\n\n-   相同，这时有重复的，slow 不动\n-   不同，slow 自增，并替换为 fast 指向的值\n\nfast 始终自增\n\n# 代码\n\n```ts\nexport function removeDuplicates(nums: number[]): number {\n    const len = nums.length\n    if (len === 0 || len === 1) {\n        return len\n    }\n    let fast = 1\n    let slow = 0\n\n    while (fast < len) {\n        const current = nums[fast]\n\n        // 不重复\n        if (current !== nums[slow]) {\n            nums[++slow] = nums[fast]\n        }\n\n        fast++\n    }\n\n    return slow + 1\n}\n```\n# 复杂度\n\n-   时间复杂度：O(N) 遍历一遍\n-   空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465225787","body":"# 思路\n\n二分法找到元素位置\n\n# 代码\n\n```ts\nexport function searchInsert(nums: number[], target: number): number {\n    let left = 0\n    let right = nums.length - 1\n\n    while (left <= right) {\n        const middle = left + ((right - left) >> 1)\n\n        if (target <= nums[middle]) {\n            right = middle - 1\n        } else {\n            left = middle + 1\n        }\n    }\n\n    return left\n}\n```\n\n# 复杂度\n\n-   时间复杂度：O(N)\n-   空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465740299","body":"# 思路\n\n用队列维护当前窗口中的最大值\n**初始化**：遍历前 k 个元素，如果当前元素比队尾元素大，则删除队尾元素，直至队列为空或者当前元素小于等于队尾元素\n**移动窗口**: 从 k 开始遍历数组：\n\n1. 如果当前元素比队尾元素大，则删除队尾元素，直至队列为空或者当前元素小于等于队尾元素\n2. 当前 index 添加到队列中\n3. 如果队首 `p[] <= index -k`，则删除队首，直至不满足条件\n4. 当前窗口最大值为队首对应的值\n\n# 代码\n\n```ts\nfunction maxSlidingWindow(nums: number[], k: number): number[] {\n    const queue: number[] = []\n\n    // 初始化窗口\n    for (let i = 0; i < k; i++) {\n        while (queue.length && nums[i] > nums[queue[queue.length - 1]]) {\n            queue.pop()\n        }\n\n        queue.push(i)\n    }\n\n    const ans: number[] = [nums[queue[0]]]\n\n    for (let i = k; i < nums.length; i++) {\n        while (queue.length && nums[i] > nums[queue[queue.length - 1]]) {\n            queue.pop()\n        }\n\n        queue.push(i)\n\n        // 窗口的左边界在 i - k - 1，右边界在 i\n        while (queue[0] <= i - k) {\n            queue.shift()\n        }\n\n        ans.push(nums[queue[0]])\n    }\n\n    return ans\n}\n```\n# 复杂度\n\n- 时间复杂度：O(N) 每个元素被添加到队列一次，最多移出一次\n- 空间复杂度：O(K) 最多保存窗口 K 个元素","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467249765","body":"# 思路\n\n被人相信 `value + 1`，相信别人 `value - 1`，法官的 value 一定是 `n - 1`\n**注意**, 编号从 1 开始\n\n# 代码\n\n```ts\nexport function findJudge(n: number, trust: number[][]): number {\n    // 编号从 1 开始\n    const trustValue: number[] = new Array(n + 1).fill(0)\n\n    for (const [a, b] of trust) {\n        // 相信了别人\n        trustValue[a]--\n        // 被别人相信\n        trustValue[b]++\n    }\n\n    return trustValue.findIndex((value, index) => index !== 0 && value === n - 1)\n}\n```\n# 复杂度\n\n-   时间复杂度：O(n + m) m 为 trust 长度，trust 和 trustValue 都需要遍历一遍\n-   空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469987790","body":"# 思路\n\n构建图，遍历节点尝试对节点染色：\n\n-   节点未染过色，设置为蓝色，dfs 递归与他相连的节点\n    -   相连节点未染过色，设置为相反的颜色（红色），继续 dfs 递归与他相连的节点\n    -   相连节点已经染色，颜色与节点颜色相同，此时已经不满足条件 `return false`\n    -   所有节点都能染色成功则 `return true`，否则 `return false`\n\n# 代码\n\n```ts\nenum Color {\n    Initial,\n    Red,\n    Blue,\n}\n\nexport function possibleBipartition(n: number, dislikes: number[][]): boolean {\n    // 存储各个节点的颜色\n    const color = new Array<Color>(n + 1).fill(Color.Initial)\n    // 图存储节点关系，index 为人的编号 value 为他不喜欢的人\n    const graph: number[][] = new Array(n + 1).fill(0).map(() => [])\n\n    const dfs = (currentNode: number, currentColor: Color) => {\n        color[currentNode] = currentColor\n        const reverseColor = currentColor === Color.Blue ? Color.Red : Color.Blue\n\n        for (const node of graph[currentNode]) {\n            // 节点已经染色 & 与当前节点颜色一致\n            if (color[node] !== Color.Initial && color[node] === currentColor) {\n                return false\n            }\n\n            // 节点未染色 & 不能成功染色其他节点\n            if (color[node] === Color.Initial && !dfs(node, reverseColor)) {\n                return false\n            }\n        }\n\n        return true\n    }\n\n    // 初始化图\n    for (const [person1, person2] of dislikes) {\n        graph[person1].push(person2)\n        graph[person2].push(person1)\n    }\n\n    for (let i = 1; i <= n; i++) {\n        // 当前节点未染色 & 不能成功染色其他节点\n        if (color[i] === Color.Initial && !dfs(i, Color.Blue)) {\n            return false\n        }\n    }\n\n    return true\n}\n```\n\n# 复杂度\n\n- 时间复杂度：O(n + m), m 为 dislike 数组大小（dislike 要遍历一遍 + 所有节点染色）\n- 空间复杂度：O(n + m), m 为 dislike 数组大小 (graph + color)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1472245199","body":"# 思路\n\n-   通过 item 之间的依赖关系推导出 group 之间的依赖关系\n-   计算 item、group 的拓扑排序结果\n-   建立 group 与 item 的多对一关系\n-   按 item 的拓扑顺序设置 group 的值\n-   按 group 的拓扑顺序输出结果\n\n# 代码\n\n```ts\nfunction sortItems(\n    n: number,\n    m: number,\n    group: number[],\n    beforeItems: number[][],\n): number[] {\n    // 把 groupId 为 -1 的项目，标记为不同的 group\n    group.forEach((groupId, index) => {\n        if (groupId === -1) {\n            group[index] = m++\n        }\n    })\n\n    // 初始化 group 和 item 的图\n    const groupGraph: number[][] = []\n    for (let i = 0; i < m; i++) {\n        groupGraph[i] = []\n    }\n\n    const itemGraph: number[][] = []\n    for (let i = 0; i < n; i++) {\n        itemGraph[i] = []\n    }\n\n    // 建图 & 计算入度\n    const groupsIndegree: number[] = new Array(m).fill(0)\n    const itemsIndegree: number[] = new Array(n).fill(0)\n    for (let i = 0; i < group.length; i++) {\n        const currentGroup = group[i]\n\n        for (const beforeItem of beforeItems[i]) {\n            const beforeGroup = group[beforeItem]\n\n            if (beforeGroup !== currentGroup) {\n                groupGraph[beforeGroup].push(currentGroup)\n                groupsIndegree[currentGroup]++\n            }\n        }\n    }\n\n    beforeItems.forEach((beforeItem, i) => {\n        beforeItem.forEach((item) => {\n            itemGraph[item].push(i)\n            itemsIndegree[i]++\n        })\n    })\n\n    const groupList = topologicalSort(groupGraph, groupsIndegree)\n    if (!groupList) {\n        return []\n    }\n\n    const itemList = topologicalSort(itemGraph, itemsIndegree)\n    if (!itemList) {\n        return []\n    }\n\n    // 建立 group 与 item 的关系\n    const group2Item = new Map<number, number[]>()\n    // 每个 group 的 item 列表都满足拓扑排序\n    itemList.forEach((itemId) => {\n        const groupId = group[itemId]\n        if (!group2Item.has(groupId)) {\n            group2Item.set(groupId, [])\n        }\n        group2Item.get(groupId)!.push(itemId)\n    })\n\n    // 按 group 的拓扑排序输出结果\n    return groupList.reduce<number[]>((result, groupId) => {\n        return result.concat(group2Item.get(groupId) || [])\n    }, [])\n}\n\nfunction topologicalSort(graph: number[][], indegree: number[]): null | number[] {\n    const queue: number[] = []\n    const result: number[] = []\n\n    // 入度为 0 的节点放入队列\n    for (let i = 0; i < indegree.length; i++) {\n        if (indegree[i] === 0) {\n            queue.push(i)\n        }\n    }\n\n    while (queue.length) {\n        const node = queue.shift()!\n        result.push(node)\n\n        for (let nextNode of graph[node]) {\n            indegree[nextNode]--\n            if (indegree[nextNode] === 0) {\n                queue.push(nextNode)\n            }\n        }\n    }\n\n    if (result.length !== indegree.length) {\n        return null\n    }\n\n    return result\n}\n```\n# 复杂度\n\n- 时间复杂度：O(m + n^2)\n- 空间复杂度：O(m + n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473064121","body":"# 思路\n\n回到原点，x、y 都为 0\n\n# 代码\n\n```ts\nfunction judgeCircle(moves: string): boolean {\n    const { x, y } = moves.split('').reduce<{ x: number; y: number }>(\n        (position, action) => {\n            if (action === 'U') {\n                position.y++\n            }\n            if (action === 'D') {\n                position.y--\n            }\n            if (action === 'R') {\n                position.x++\n            }\n            if (action === 'L') {\n                position.x--\n            }\n\n            return position\n        },\n        { x: 0, y: 0 },\n    )\n\n    return x === 0 && y === 0\n}\n```\n# 复杂度\n\n-   时间复杂度：O(N)\n-   空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474828552","body":"class Solution {\n    public int[] getOrder(int[][] ts) {\n        int n = ts.length;\n        // 将 ts 转存成 nts，保留任务编号\n        int[][] nts = new int[n][3];\n        for (int i = 0; i < n; i++) nts[i] = new int[]{ts[i][0], ts[i][1], i};\n        // 根据任务入队时间进行排序\n        Arrays.sort(nts, (a,b)->a[0]-b[0]);\n        // 根据题意，先按照「持续时间」排序，再根据「任务编号」排序\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->{\n            if (a[1] != b[1]) return a[1] - b[1];\n            return a[2] - b[2];\n        });\n        int[] ans = new int[n];\n        for (int time = 1, j = 0, idx = 0; idx < n; ) {\n        \t// 如果当前任务可以添加到「队列」中（满足入队时间）则进行入队\n            while (j < n && nts[j][0] <= time) q.add(nts[j++]);\n            if (q.isEmpty()) {\n\t            // 如果当前「队列」没有任务，直接跳到下个任务的入队时间\n                time = nts[j][0];\n            } else {\n            \t// 如果有可执行任务的话，根据优先级将任务出队（记录下标），并跳到该任务完成时间点\n                int[] cur = q.poll();\n                ans[idx++] = cur[2];\n                time += cur[1];\n            }\n        }\n        return ans;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475276725","body":"# 思路\n\n-   统一转成分钟计算\n-   如果超过一天需要加上一天的分钟\n-   使用 `Math.floor(logoutTotalMinute / 15) * 15` 获得最后的时间\n-   由于上面的操作可能导致出现负数，因此加一个 `Math.max`\n\n# 代码\n\n```ts\nfunction numberOfRounds(loginTime: string, logoutTime: string): number {\n    const { hour: loginHour, minute: loginMinute } = parseTime(loginTime)\n    const { hour: logoutHour, minute: logoutMinute } = parseTime(logoutTime)\n\n    const loginTotalMinute = loginHour * 60 + loginMinute\n    let logoutTotalMinute = logoutHour * 60 + logoutMinute\n    if (logoutTotalMinute < loginTotalMinute) {\n        logoutTotalMinute += 24 * 60\n    }\n\n    logoutTotalMinute = Math.floor(logoutTotalMinute / 15) * 15\n\n    return Math.max(0, Math.floor((logoutTotalMinute - loginTotalMinute) / 15))\n}\n\nfunction parseTime(timeStr: string) {\n    const [hour, minute] = timeStr.split(':')\n\n    return {\n        hour: Number(hour),\n        minute: Number(minute),\n    }\n}\n\n```\n# 复杂度\n\n-   时间复杂度: O(1)\n-   空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476339857","body":"```c\r\nclass Solution {\r\npublic:\r\n    int minCharacters(string a, string b) {\r\n        vector<int> acnt(26, 0);\r\n        vector<int> bcnt(26, 0);\r\n        int an = a.size(), bn = b.size();\r\n        \r\n        for (char c : a) acnt[c-'a']++;\r\n        for (char c : b) bcnt[c-'a']++;\r\n        \r\n        int ans = INT_MAX, asum = 0, bsum = 0;\r\n        for (int i = 0; i < 25; i++) {\r\n            asum += acnt[i];\r\n            bsum += bcnt[i];\r\n            ans = min(min(ans, an-acnt[i]+bn-bcnt[i]), min(an-asum+bsum, bn-bsum+asum));\r\n        }\r\n        ans = min(ans, an-acnt[25]+bn-bcnt[25]);\r\n        \r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477850521","body":"```java\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        randomizedQuicksort(nums, 0, nums.length - 1);\n        return nums;\n    }\n\n    public void randomizedQuicksort(int[] nums, int l, int r) {\n        if (l < r) {\n            int pos = randomizedPartition(nums, l, r);\n            randomizedQuicksort(nums, l, pos - 1);\n            randomizedQuicksort(nums, pos + 1, r);\n        }\n    }\n\n    public int randomizedPartition(int[] nums, int l, int r) {\n        int i = new Random().nextInt(r - l + 1) + l; // 随机选一个作为我们的主元\n        swap(nums, r, i);\n        return partition(nums, l, r);\n    }\n\n    public int partition(int[] nums, int l, int r) {\n        int pivot = nums[r];\n        int i = l - 1;\n        for (int j = l; j <= r - 1; ++j) {\n            if (nums[j] <= pivot) {\n                i = i + 1;\n                swap(nums, i, j);\n            }\n        }\n        swap(nums, i + 1, r);\n        return i + 1;\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479562991","body":"```java\nclass Solution {\n    public int mySqrt(int x) {\n        if (x == 0) {\n            return 0;\n        }\n\n        double C = x, x0 = x;\n        while (true) {\n            double xi = 0.5 * (x0 + C / x0);\n            if (Math.abs(x0 - xi) < 1e-7) {\n                break;\n            }\n            x0 = xi;\n        }\n        return (int) x0;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1481267495","body":"```js\nvar solution = function(isBadVersion) {\n    return function(n) {\n        let left = 1, right = n;\n        while (left < right) { // 循环直至区间左右端点相同\n            const mid = Math.floor(left + (right - left) / 2); // 防止计算时溢出\n            if (isBadVersion(mid)) {\n                right = mid; // 答案在区间 [left, mid] 中\n            } else {\n                left = mid + 1; // 答案在区间 [mid+1, right] 中\n            }\n        }\n        // 此时有 left == right，区间缩为一个点，即为答案\n        return left;\n    };\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1484105580","body":"```js\r\nvar reversePairs = function(nums) {\r\n    if (nums.length === 0) {\r\n        return 0;\r\n    }\r\n    return reversePairsRecursive(nums, 0, nums.length - 1);\r\n};\r\n\r\nconst reversePairsRecursive = (nums, left, right) => {\r\n    if (left === right) {\r\n        return 0;\r\n    } else {\r\n        const mid = Math.floor((left + right) / 2);\r\n        const n1 = reversePairsRecursive(nums, left, mid);\r\n        const n2 = reversePairsRecursive(nums, mid + 1, right);\r\n        let ret = n1 + n2;\r\n\r\n        let i = left;\r\n        let j = mid + 1;\r\n        while (i <= mid) {\r\n            while (j <= right && nums[i] > 2 * nums[j]) {\r\n                j++;\r\n            }\r\n            ret += j - mid - 1;\r\n            i++;\r\n        }\r\n\r\n        const sorted = new Array(right - left + 1);\r\n        let p1 = left, p2 = mid + 1;\r\n        let p = 0;\r\n        while (p1 <= mid || p2 <= right) {\r\n            if (p1 > mid) {\r\n                sorted[p++] = nums[p2++];\r\n            } else if (p2 > right) {\r\n                sorted[p++] = nums[p1++];\r\n            } else {\r\n                if (nums[p1] < nums[p2]) {\r\n                    sorted[p++] = nums[p1++];\r\n                } else {\r\n                    sorted[p++] = nums[p2++];\r\n                }\r\n            }\r\n        }\r\n        for (let k = 0; k < sorted.length; k++) {\r\n            nums[left + k] = sorted[k];\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1484106369","body":"```js\r\nvar findRadius = function(houses, heaters) {\r\n    let ans = 0;\r\n    heaters.sort((a, b) => a - b);\r\n    for (const house of houses) {\r\n        const i = binarySearch(heaters, house);\r\n        const j = i + 1;\r\n        const leftDistance = i < 0 ? Number.MAX_VALUE : house - heaters[i];\r\n        const rightDistance = j >= heaters.length ? Number.MAX_VALUE : heaters[j] - house;\r\n        const curDistance = Math.min(leftDistance, rightDistance);\r\n        ans = Math.max(ans, curDistance);\r\n    }\r\n    return ans;\r\n};\r\n\r\nconst binarySearch = (nums, target) => {\r\n    let left = 0, right = nums.length - 1;\r\n    if (nums[left] > target) {\r\n        return -1;\r\n    }\r\n    while (left < right) {\r\n        const mid = Math.floor((right - left + 1) / 2) + left;\r\n        if (nums[mid] > target) {\r\n            right = mid - 1;\r\n        } else {\r\n            left = mid;\r\n        }\r\n    }\r\n    return left;\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1484106673","body":"```js\r\nvar smallestDistancePair = function(nums, k) {\r\n    nums.sort((a, b) => a - b);\r\n    let n = nums.length, left = 0, right = nums[n - 1] - nums[0];\r\n    while (left <= right) {\r\n        const mid = Math.floor((left + right) / 2);\r\n        let cnt = 0;\r\n        for (let j = 0; j < n; j++) {\r\n            const i = binarySearch(nums, j, nums[j] - mid);\r\n            cnt += j - i;\r\n        }\r\n        if (cnt >= k) {\r\n            right = mid - 1;\r\n        } else {\r\n            left = mid + 1;\r\n        }\r\n    }\r\n    return left;\r\n};\r\n\r\nconst binarySearch = (nums, end, target) => {\r\n    let left = 0, right = end;\r\n    while (left < right) {\r\n        const mid = Math.floor((left + right) / 2);\r\n        if (nums[mid] < target) {\r\n            left = mid + 1;\r\n        } else {\r\n            right = mid;\r\n        }\r\n    }\r\n    return left;\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linlizzz":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429896683","body":"### 思路\n1.将K转换成数组形式\n\n2.将数组A和K的元素依次倒叙相加，顺序记入新数组，大于9的结果记1，加入下一次计算\n\n3.将得到的数组进行元素倒序排序，得到最终结果\n\n### 代码\n```python\nimport numpy as np\n\ndef add(A, K):\n    K_list = []\n    while(K//10 != 0):\n        K_list.append(K%10)\n        K = K//10\n    K_list.append(K%10) # 将K倒序存成列表\n    print(K_list)\n    res = []\n    up = 0\n    diff = abs(A.shape[0] - len(K_list))\n    for i in range(min(len(K_list), A.shape[0])):\n        res.append((K_list[i] + A[-1-i])%10 + up)\n        print(res)\n        if (K_list[i] + A[-1-i])//10 == 1:\n            up = 1\n        else:\n            up = 0\n    if A.shape[0] > len(K_list):\n        for j in range(diff):\n            res.append(A[-2-i-j] + up)\n            if (A[-2-i-j] + up)//10 == 1:\n                up = 1\n            else:\n                up = 0\n            print(res)\n    elif A.shape[0] < len(K_list):\n        for j in range(diff):\n            res.append(K_list[i+j+1] + up)\n            if (K_list[i+j+1] + up)//10 == 1:\n                up = 1\n            else:\n                up = 0\n            print(res)\n    res.reverse()\n    res = np.array(res)\n    return res\n```\n### 时间复杂度\nT(n)=O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431529057","body":"### 思路\n1.取出字符c在字符串s中出现的所有下标值，存于列表pos\n\n2.比较每个位置下标值与pos中所有值的差绝对值，取最小数，作为该位置的最短距离值，存于输出结果列表的相应位置\n\n### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pos = []\n        res = []\n        for i in range(len(s)):\n            if c == s[i]:\n                pos.append(i)\n\n        for j in range(len(s)):\n            t = len(s)\n            for i in pos:\n                t = min(abs(j-i), t)\n            res.append(t)\n        \n        return res\n```\n### 复杂度分析\nT(n) = n^2\n\nS(n) = n\n\nn=len(s)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433291470","body":"### 思路\n\n1.利用列表构建栈，列表长度为maxSize，设计指针变量指向栈顶之后一个元素。\n\n2.push时，先判断列表是否已满，未满则加入指针变量指向元素位置，指针变量上移。\n\n3.pop时，先判断列表是否为空，非空则指针变量下移，取出该元素值，并将该元素清空。\n\n4.increment时，取k和指针变量较小者，遍历加入val值。\n\n### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = [None]*maxSize\n        self.size = maxSize\n        self.point = 0\n\n    def push(self, x: int) -> None:\n        if self.point == self.size:\n            pass\n        else:\n            self.stack[self.point] = x\n            self.point += 1\n\n    def pop(self) -> int:\n        if self.point == 0:\n            res = -1\n        else:\n            self.point -= 1\n            res = self.stack[self.point]\n            self.stack[self.point] = None\n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i < self.point:\n                self.stack[i] += val\n            else:\n                break\n```\n### 复杂度分析\nincrement时，T(n)=O(n),n为栈的maxSize\n其余T(n)=O(1)\nS(n)=O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434822171","body":"Day 4 17/02/2023\n\n### 思路\n\n1.构建栈，遇到左括号存入之前的数字n以及之前的字符str\n\n2.遇到右括号，弹出栈顶元素，str=str+n\\*两括号之间的字符\n\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = ''\n        n = 0\n        for i in range(len(s)):\n            if s[i].isdigit():\n                n = n*10 + int(s[i])\n                print(n)\n            elif s[i] == '[':\n                stack.append((n, res))\n                print(stack)\n                res = ''\n                n = 0\n            elif s[i] == ']':\n                print(stack)\n                pre = stack.pop()\n                print(pre)\n                res = pre[1] + pre[0]*res\n            else:\n                res += s[i]\n                print(res)\n        print(res)\n        return res\n```\n### 复杂度分析\nT(n)=O(n) n为输入str长度\n\nS(n)=O(k) k为输出str长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435674473","body":"### 思路\n\n1. 初始化一个列表作为栈\n\n2.push直接append；pop时另新建一个列表，倒序存放原列表元素，.pop()出后再重新倒序放入原列表；peek取第一个元素，empty查看列表是否为空\n\n### 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n\n\n    def pop(self) -> int:\n        self.stack_inv = []\n        for i in self.stack[::-1]:\n            self.stack_inv.append(i)\n        res = self.stack_inv.pop()\n        self.stack = []\n        for j in self.stack_inv[::-1]:\n            self.stack.append(j)\n        return res\n\n\n    def peek(self) -> int:\n        res = self.stack[0]\n        return res\n\n\n    def empty(self) -> bool:\n        if self.stack:\n            return False\n        else:\n            return True\n```\n### 复杂度分析\n\nT(n)=O(n) n为栈的大小\n\nS(n)=O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435983034","body":"### 思路\n\n从前往后遍历数组中元素，若前面元素子集中最大值小于等于后面元素子集中最小值，则分块。\n\n### 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        res = 0\n        j = 0\n        for i in range(1, len(arr)):\n            if max(arr[j:i]) <= min(arr[i:]):\n                res += 1\n                j =i\n        res += 1\n        return res\n```\n### 复杂度分析\nT(n)=O(n) n为输入数组长度\n\nS(n)=O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437279024","body":"### 思路\n\n先把链表首尾相连，再找到位置断开循环\n\n### 代码\n```python\nclass Solution(object):\n    def rotateRight(self, head, k):\n        if head is None or head.next is None: return head\n        start, end, len = head, None, 0\n        while head:\n            end = head\n            head = head.next\n            len += 1\n        end.next = start\n        pos = len - k % len\n        while pos > 1:\n            start = start.next\n            pos -= 1\n        ret = start.next\n        start.next = None\n        return ret\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440268104","body":"###思路\n\n1.当head==None或者head.next==None时直接输出相应的res\n\n2.设置三个指针，point_2每次循环走两步，point_1每次循环走一步，point_pre每次循环指向point_1的前一个\n\n3.当point_2走到底或剩一个时，point_1正好走到链表中间作为当前树的根节点，用point_pre把原链表断开，以point_1为界，分为前后两个子链表作为当前树的根节点的左右子节点，分别返回2递归循环该函数\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        res = TreeNode()\n        if head == None:\n            res = None\n        elif head.next == None:\n            res.val = head.val\n        else:\n            point_pre = head\n            point_1 = head\n            point_2 = head\n            while point_2 and point_2.next:\n                point_pre = point_1\n                point_1 = point_1.next\n                point_2 = point_2.next.next\n            point_pre.next = None # split the link list\n            res.val = point_1.val\n            res.left = self.sortedListToBST(head)\n            res.right = self.sortedListToBST(point_1.next)\n        return res\n```\n\n### 复杂度分析\n\nT(n) = O(n)\n\nS(n) = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441368752","body":"### 思路\n\n1. 取point_a和point_b分别指向headA和headB的头，依次向后移动\n\n2. 若两指针分别走完各自的链表，则重定向到对方链表的头，继续依次向后移动\n\n3. 相等时退出循环返回该节点，存在或两个链表一起走完时等于None，则不存在相同节点\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        point_a = headA\n        point_b = headB\n        while point_a != point_b:\n            point_a = point_a.next if point_a else headB\n            point_b = point_b.next if point_b else headA\n        return point_a\n```\n\n### 复杂度分析\n\nT(n) = O(m+n), m和n分别为headA和headB的长度\n\nS(n) = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443854141","body":"### 思路\n\n1. 设定point_1和point_2分别每次走1步和2步，若相遇则有循环，若走到None则无循环\n\n2.相遇后，再走到相遇的步数则为环的长度\n\n3.重新从头开始point_2每次走1步，走掉环的长度后，point_1从头和point_2继续同时开始走每次走1步，走到相遇则为环的起点。\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        point_1 = head\n        point_2 = head\n        l = 0\n        while point_2 and point_2.next:\n            point_1 = point_1.next\n            point_2 = point_2.next.next\n            if point_1 == point_2:\n                break\n        if not point_2 or not point_2.next:\n            return None\n        while True:\n            point_1 = point_1.next\n            point_2 = point_2.next.next\n            l += 1\n            if point_1 == point_2:\n                break\n        point_1 = head\n        point_2 = head\n        for i in range(l):\n            point_2 = point_2.next\n        while point_1 != point_2:\n            point_1 = point_1.next\n            point_2 = point_2.next\n        return point_1\n```\n\n### 复杂度分析\n\nT(n) = O(n)\n\nS(n) = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445139710","body":"### 思路\n\n1.利用collections库中已有的记住数据添加顺序的字典子类OrderedDic()来储存\n\n2.每操作一次键值对，就pop一次再录入一次\n\n3.函数popitem(last=)当参数last=True时是栈LIFO，last=False时是队列FIFO，此处‘最近最少使用’是队列FIFO特征，则用last=False\n\n### 代码\n```python\nimport collections\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = collections.OrderedDict()\n        self.size = capacity\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            res = self.cache.pop(key)\n            self.cache[key] = res\n        else:\n            res = -1\n        return res\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n            self.cache[key] = value\n        elif len(self.cache) == self.size:\n            self.cache.popitem(last=False)\n        self.cache[key] = value\n```\n\n### 复杂度分析\n\nT(n) = O(1)\n\nS(n) = O(n)，n为capacity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445313074","body":"### 思路\n\n利用递归，每次把子节点变成父节点计算深度，再依次返回\n\n### 代码\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        i = depthl = depthr = 0\n        if root:\n            i = 1\n            if root.left:\n                depthl = self.maxDepth(root.left)\n            if root.right:\n                depthr = self.maxDepth(root.right)\n        depth = i + max(depthl, depthr)\n        return depth\n```\n\n### 复杂度分析\n\nT(n) = O(n)\n\nS(n) = O(n), n为深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446118049","body":"### 思路\n\n用递归算法：\n\n1. 若两个都不为None，且两个的val相同，则将两者的左节点和右节点分别相对应继续作为两个子节点调用该函数，返回两者的and结果\n\n2. 当两个节点都为None时则返回True\n\n3. 其余情况（其中一个为None一个不为None，或两个都不为None，但两个的val不同）则返回False\n\n### 代码\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p and q and p.val == q.val:\n            return (True and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right))\n        elif p == None and q == None:\n            return True\n        else:\n            return False\n```\n\n###复杂度分析\n\nT(n) = O(min(m,n)), m,n分别为两个树的节点数\n\nS(n) = O(min(m,n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447544148","body":"### 思路\n\n每下一层，前面的数字扩大10倍\n\n### 代码\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(root, pre):\n            if root == None:\n                return 0\n            total = pre*10 + root.val\n            if root.left == None and root.right == None:\n                return total\n            else:\n                return dfs(root.left, total) + dfs(root.right, total)\n        return dfs(root, 0)\n```\n\n### 复杂度分析\n\nT(n) = O(n), n为节点数\n\nS(n) = O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450072794","body":"### 思路\n\nBFS，每一层从右往左遍历，更新值\n\n### 代码\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport collections\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        nodes = collections.deque()\n        nodes.append(root)\n        while nodes:\n            node = nodes.popleft()\n            val = node.val\n            if node.right:\n                nodes.append(node.right)\n            if node.left:\n                nodes.append(node.left)\n        return val\n```\n\n### 复杂度分析\n\nT(n) = O(n), n为树的结点数\n\nS(n) = O(h), h为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451964791","body":"### 思路\n\n层序遍历\n\n### 代码\n```python\ndef serialize(self, root):\n\n        s = \"\"\n        queue = []\n        queue.append(root)\n        while queue:\n            root = queue.pop(0)\n            if root:\n                s += str(root.val)\n                queue.append(root.left)\n                queue.append(root.right)\n            else:\n                s += \"n\"\n            s += \" \"        \n        return s\n\n    def deserialize(self, data):\n \n        tree = data.split()\n        print(tree)\n        if tree[0] == \"n\":\n            return None\n        queue = []\n        root = TreeNode(int(tree[0]))\n        queue.append(root)\n        i = 1\n        while queue:\n            cur = queue.pop(0)\n            if cur == None:\n                continue\n            cur.left = TreeNode(int(tree[i])) if tree[i] != \"n\" else None\n            cur.right = TreeNode(int(tree[i + 1])) if tree[i + 1] != \"n\" else None\n            i += 2\n            queue.append(cur.left)\n            queue.append(cur.right)\n        return root\n```\n\n### 复杂度分析\n\n今天没做出来，参考的力扣的评论，还要花时间再想几遍...","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453038546","body":"```python\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        dic = collections.defaultdict(list)\n\n        queue = [(0, 0, root)]\n        while queue:\n            n_q = len(queue)\n            for _ in range(n_q):\n                i, j, node = queue.pop(0)\n                dic[j].append((i, node.val))\n                if node.left:\n                    queue.append((i + 1, j - 1, node.left))\n                if node.right:\n                    queue.append((i + 1, j + 1, node.right))\n            \n        res = []\n        arr = sorted(dic.keys())\n        for k in arr:\n            tmp = sorted(dic[k])\n            res.append([v[1] for v in tmp])\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454782754","body":"```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        records = dict()\n\n        for idx, val in enumerate(nums):\n            if target - val not in records:\n                records[val] = idx\n            else:\n                return [records[target - val], idx]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455040919","body":"```cpp\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        vector<int> ret;\n        unordered_map<int, int> mp;\n        priority_queue<pair<int, int>> pq;\n        for (auto i : nums) mp[i]++;\n        for (auto p : mp) {\n            pq.push(pair<int, int>(-p.second, p.first));\n            if (pq.size() > k) pq.pop();\n        }\n        while (k--) {\n            ret.push_back(pq.top().second);\n            pq.pop();\n        }\n        return ret;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455493174","body":"### 思路\n\n1. 计算每个点到其他点的距离\n\n2. 当与其距离相等的点个数i大于等于2时，计算A_i^(i-1)\n\n3.所有结果求和\n\n### 代码\n\n```python\nimport numpy as np\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        nums = 0\n        l = len(points)\n        dis = np.zeros((l, l))\n        for i in range(l):\n            for j in range(l):\n                if j != i:\n                    dis[i][j] = (points[j][1]-points[i][1])**2 + (points[j][0]-points[i][0])**2\n        for i in range(l):\n            dic = {}\n            for j in range(l):\n                if dis[i][j] in dic:\n                    dic[dis[i][j]] += 1\n                else:\n                    dic[dis[i][j]] = 1\n            for value in dic.values():\n                if value > 1:\n                    num = value * (value-1)\n                    nums += num\n        return nums\n```\n### 复杂度分析\n\nT(n) = O(n^2), n为点的个数\n\nS(n) = O(n^2)\n\n(需要优化..","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457541001","body":"### 思路\n\n1. 挨个字母遍历，记录已遍历长度\n\n2. 若遇到重复字母，首位更新到被重复字母的后一位，更新目前最长长度\n\n### 代码\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        l = []\n        maxlen = 0\n        for i in range(len(s)):\n            if s[i] in l:\n                maxlen = max(maxlen, len(l))\n                index = [j for j, v in enumerate(l) if v is s[i]]\n                l = l[index[-1]+1:]\n            l.append(s[i])\n        return max(maxlen, len(l))\n```\n\n### 复杂度分析\n\nT(n) = O(n)\n\nS(n) = O(n), n为字符串长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459521518","body":"### 思路\n\n1. 先判断字符串长度是否大于单词组合总长\n\n2. 字符串上从头i遍历取出单词组合总长的子字符串，每个子字符串从头j检查单个单词长度的子子字符串是否在copy_words中，是则删去该单词，挑至子字符串的下一个位置（j+单个单词长度），循环检查，否则直接挑至下一个i+1子字符串\n\n### 代码\n\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        len_substring = len(words)*len(words[0])\n        if len_substring > len(s):\n            return []\n        else:\n            res = []\n            for i in range(len(s)-len_substring+1):\n                copy_words = words.copy()\n                substring = s[i:i+len_substring]\n                for j in range(len(words)):\n                    if substring[j*len(words[0]):(j+1)*len(words[0])] in copy_words:\n                        copy_words.remove(substring[j*len(words[0]):(j+1)*len(words[0])])\n                    else:\n                        break\n                if len(copy_words) == 0:\n                    res.append(i)\n            return res\n```\n\n### 复杂度分析\n\nT(n) = O(m*n), n为字符串长度，m为单词数\n\nS(n) = O(m*p), m为单词数，p为单个单词长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461532342","body":"### 思路\n\n1. 同余定理：若两个数除以k所得余数相同，则两者相差k的倍数\n\n2. sum(L[i:j]) = sum(L[0:j] - L[0:i])\n\n### 代码\n\n```python\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        need = sum(nums) % p\n        dp = {0: -1}\n        cur = 0\n        res = n = len(nums)\n        for i, a in enumerate(nums):\n            cur = (cur + a) % p\n            dp[cur] = i\n            if (cur - need) % p in dp:\n                res = min(res, i - dp[(cur - need) % p])\n        return res if res < n else -1\n```\n\n### 复杂度分析\n\nT(n) = O(n), n为nums中元素个数\n\nS(n) = O(min(n, p))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463129434","body":"### 思路\n\n运用快慢指针，point1每次走一步，point2每次走两步，point2走到底时，point1在中间\n\n（这里的头指针是首元结点的意思？\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        point1 = head\n        point2 = head\n        while point2 and point2.next:\n            point1 = point1.next\n            point2 = point2.next.next\n        return point1\n```\n\n### 复杂度分析\n\nT(n) = O(n), n为结点个数\n\nS(n) = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464865300","body":"### 思路\n\n1. 取一个指针指向不重复的元素列表最后一位\n\n2. 遍历列表元素，若与前面元素不同，则更新指针以及指针所指位置的元素值\n\n### 代码\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        point = 0\n        for i in range(1, len(nums)):\n            if nums[i] != nums[point]:\n                point += 1\n                nums[point] = nums[i]\n        return point+1\n```\n\n### 复杂度分析\n\nT(n) = O(n), n为数组长度\n\nS(n) = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465223267","body":"### 思路\n\n用了遍历，其实应该用二分和双指针\n\n### 代码\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        for i in range(len(nums)):\n            if nums[i] < target:\n                continue\n            else:\n                return i\n        if True:\n            return len(nums)\n```\n\n示例：\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left,right = 0,len(nums)\n        while left < right:\n            mid = (left+right)//2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < target:\n                left = mid +1\n            else:\n                right = mid\n        return left\n```\n\n### 复杂度分析\n\nT(n) = O(n)\n\nS(n) = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465415756","body":"### 思路\n\n只会用暴力算法，没通过，看了答案和官方题解的解析，知道了要用双指针加队列维持一个单调递减队列，保证移动过程中超过长度k的前序元素移除，并且小于新进元素的失效元素移除\n\n### 代码\n\n示例代码\n\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        q = collections.deque() # 本质就是单调队列\n        ans = []\n        for i in range(len(nums)):\n            while q and nums[q[-1]] <= nums[i]: q.pop() # 维持单调性\n            while q and i - q[0] >= k: q.popleft() # 移除失效元素\n            q.append(i)\n            if i >= k - 1: ans.append(nums[q[0]])\n        return ans\n```\n\n### 复杂度分析\n\nT(n) = O(n)\n\nS(n) = O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467260822","body":"### 思路\n\n1. 初始化一个长度为n的列表\n\n2. 遍历trust，出现在trust[i][0]位置上对应的列表位置-1的元素置-1（信任别人），出现在trust[i][1]位置上对应的列表位置-1的元素若不为-1（信任过别人）则置+1（被别人信任）\n\n3. 查找列表中是否有元素值为n-1，若有返回其下标（存在法官），否则返回-1（不存在法官）\n\n### 代码\n\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        judge = [0]*n\n        for i, j in trust:\n            judge[i-1] = -1\n            if judge[j-1] != -1:\n                judge[j-1] += 1\n        if n-1 in judge:\n            return judge.index(n-1)+1\n        else:\n            return -1\n```\n\n### 复杂度分析\n\nT(n) = O(len(trust))\n\nS(n) = O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469515797","body":"### 思路\n\n1. 先记录图中每个节点的邻居（不喜欢的人）\n\n2. 按序对没有访问过的节点进行DFS迭代遍历，若已经标记过则判断是否为一组，一组则输出False，否则标记为不同组并继续对未访问的节点进行DFS\n\n### 代码\n\n```python\nclass Solution:\n    def dfs(self, i):\n        self.visited[i] = True\n        for j in self.graph[i]:\n            if not self.visited[j]:\n                self.color[j] = not self.color[i]\n                if not self.dfs(j):\n                    return False\n            else:\n                if self.color[j] == self.color[i]:\n                    return False\n        return True\n\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        self.graph = [[] for _ in range(n)]\n        self.color = [True]*n\n        self.visited = [False]*n\n        for i, j in dislikes:\n            self.graph[i-1].append(j-1)\n            self.graph[j-1].append(i-1)\n        for i in range(n):\n            if not self.visited[i]:\n                if not self.dfs(i):\n                    return False\n        return True\n```\n\n### 复杂度分析\n\nT(n) = O(V+E)\n\nS(n) = O(V^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1472122819","body":"没做出来，看了题解，需要先对组进行一次拓扑排序，然后对项目进行拓扑排序，还是需要好好消化一下\n\n```python\nclass Solution:\n    # 拓扑排序\n    def tp_sort(self, items, indegree, neighbors):\n        q = collections.deque([])\n        ans = []\n        for item in items:\n            if not indegree[item]:\n                q.append(item)\n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if not indegree[neighbor]:\n                    q.append(neighbor)\n\n        return ans\n\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for project in range(n):\n            if group[project] == -1:\n                group[project] = max_group_id\n                max_group_id += 1\n\n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n\n        for project in range(n):\n            group_projects[group[project]].append(project)\n\n            for pre in pres[project]:\n                if group[pre] != group[project]:\n                    # 小组关系图\n                    group_indegree[group[project]] += 1\n                    group_neighbors[group[pre]].append(group[project])\n                else:\n                    # 项目关系图\n                    project_indegree[project] += 1\n                    project_neighbors[pre].append(project)\n\n        ans = []\n        # 先对组进行拓扑排序\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\n\n        if len(group_queue) != max_group_id:\n            return []\n\n        for group_id in group_queue:\n            # 对小组中的项目进行拓扑排序\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n\n            if len(project_queue) != len(group_projects[group_id]):\n                return []\n            ans += project_queue\n\n        return ans\n```\n复杂度：\n\nT(n) = O(m+n)\n\nS(n) = O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473144074","body":"### 思路\n\nU和D的次数一致并且L和R的次数一致就能回到原点，否则失败\n\n### 代码\n\n```python\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        return moves.count('U') == moves.count('D') and moves.count('L') == moves.count('R')\n```\n\n### 复杂度分析\n\nT(n) = O(n), n为动作长度\n\nS(n) = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474880082","body":"```python\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        tasks = [[idx, t, d] for idx, (t, d) in enumerate(tasks)]\n        tasks.sort(key=lambda x: (x[1])) \n        cur_t = tasks[0][1] \n        res = []\n        heap = []\n        n = len(tasks)\n        idx = 0 \n        while len(res) != n:\n            while idx < n and tasks[idx][1] <= cur_t: \n                t = tasks[idx]\n                heapq.heappush(heap, [t[2], t[0], t[1]]) \n                idx += 1\n            if not heap:\n                cur_t = tasks[idx][1]\n                continue\n            cur_task = heapq.heappop(heap)\n            res.append(cur_task[1])\n            cur_t = cur_t + cur_task[0]\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475114718","body":"### 思路\n\n1. 先判断有没有通宵，通宵finishTime+24小时\n\n2. 将startTime和finishTime分别调整至相应整刻钟点\n\n3. 计算完整对局数\n\n### 代码\n\n```python\nclass Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        login_hh = int(loginTime[:2])\n        login_mm = int(loginTime[-2:])\n        logout_hh = int(logoutTime[:2])\n        logout_mm = int(logoutTime[-2:])\n        if login_hh > logout_hh or (login_hh == logout_hh and login_mm > logout_mm):\n            logout_hh += 24\n        login_mm = math.ceil(login_mm/15)*15\n        logout_mm = math.floor(logout_mm/15)*15\n\n        if logout_mm - login_mm < 0:\n            if login_hh == logout_hh:\n                return 0\n            rounds = (logout_mm - login_mm + 60)/15\n            login_hh += 1\n        else:\n            rounds = (logout_mm - login_mm)/15\n\n        rounds += (logout_hh - login_hh)*4\n        return int(rounds)\n```\n\n### 复杂度分析\n\nT(n) = O(1)\n\nS(n) = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475550704","body":"### 思路\n\n分别枚举三种情况的可能性取最小\n\n### 代码\n\n参考了官方题解\n\n```python\nimport collections\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        a_num = collections.Counter(a)\n        b_num = collections.Counter(b)\n        total = len(a) + len(b)\n        \n        def all_greater(a_num, b_num):\n            ans = float('inf')\n            for i in range(1, 26):\n                t = 0\n                for j in range(i, 26):\n                    t += b_num[chr(97+j)]\n                for j in range(i):\n                    t += a_num[chr(97+j)]\n                ans = min(ans, t)\n            return ans\n        \n        def same(a_num, b_num, total):\n            ans = float('inf')\n            for i in range(26):\n                ans = min(ans, total-a_num[chr(97+i)]-b_num[chr(97+i)])\n            return ans\n        \n        return min(all_greater(a_num, b_num), all_greater(b_num, a_num), same(a_num, b_num, total))\n```\n\n### 复杂度分析\n\nT(n) = O(m+n)\n\nS(n) = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477227093","body":"```python\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n\n        def merge_sort(nums, l, r):\n            if l == r:\n                return\n            mid = (l + r) // 2\n            merge_sort(nums, l, mid)\n            merge_sort(nums, mid + 1, r)\n            tmp = []\n            i, j = l, mid + 1\n            while i <= mid or j <= r:\n                if i > mid or (j <= r and nums[j] < nums[i]):\n                    tmp.append(nums[j])\n                    j += 1\n                else:\n                    tmp.append(nums[i])\n                    i += 1\n            nums[l: r + 1] = tmp\n\n        merge_sort(nums, 0, len(nums) - 1)\n        return nums\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479432689","body":"### 思路\n\n二分\n\n### 代码\n\n```python\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        l = 0\n        r = x\n        res = 0\n        while l <= r:\n            mid = (l + r) // 2\n            if mid * mid > x:\n                r = mid - 1\n            else:\n                l = mid + 1\n                res = mid\n        return res\n```\n\n### 复杂度分析\n\nT(n) = O(logn)\n\nS(n) = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480489642","body":"### 思路\n\n二分法\n\n官方题解的经典概括：“二分碰到等于号的处理： 如果寻找最左边那么碰到等于继续收缩右边界，如果寻找最右边就是收缩左边界，如果查找指定值则是直接返回。”\n\n### 代码\n\n```python\n# The isBadVersion API is already defined for you.\n# def isBadVersion(version: int) -> bool:\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        l = 1\n        r = n\n        while l <= r:\n            mid = (l + r) // 2\n            if isBadVersion(mid):\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l\n```\n\n### 复杂度分析\n\nT(n) = O(logn)\n\nS(n) = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482433285","body":"### 思路\n\n分治法排序，合并的同时，若出现前一有序组i的值大于后一有序组j的值的两倍，则计数前一有序组i开始到最后一个元素的数量（其均大于后一有序组j的值的两倍）\n\n### 代码\n\n```python\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        self.cnt = 0\n        def merge(nums, l, r, mid):\n            num1 = nums[l:mid+1]\n            num2 = nums[mid+1:r+1]\n            i, j = 0, 0\n            temp = []\n\n            while i < len(num1) and j < len(num2):\n                if num1[i] <= num2[j]:\n                    temp.append(num1[i])\n                    i += 1\n                else:\n                    temp.append(num2[j])\n                    j += 1\n\n            while i < len(num1):\n                temp.append(num1[i])\n                i += 1\n            while j < len(num2):\n                temp.append(num2[j])\n                j += 1\n            nums[l:r+1] = temp\n\n            i, j = 0, 0\n            while i < len(num1) and j <len(num2):\n                if num1[i] <= num2[j]*2:\n                    i += 1\n                else:\n                    self.cnt += len(num1)-i\n                    j += 1\n\n        def mergesort(nums, l, r):\n            if l >= r:\n                return\n            else:\n                mid = (l+r)//2\n                mergesort(nums, l, mid)\n                mergesort(nums, mid+1, r)\n            merge(nums, l, r, mid)\n\n        mergesort(nums, 0, len(nums)-1)\n\n        return self.cnt\n```\n\n### 复杂度分析\n\nT(n) = O(nlogn)\n\nS(n) = O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483753420","body":"### 思路\n\n这次的题官网打不开，就做了官方题解里推荐的取暖器的题https://leetcode.cn/problems/heaters/\n\n利用二分搜索最左边界，然后判断mid的值是否能覆盖所有房间\n\n### 代码\n\n```python\nclass Solution:\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\n        houses.sort()\n        heaters.sort()\n        total = houses+heaters\n        total.sort()\n\n        def possible(r):\n            if bisect_left(houses, heaters[0]-r) == 0:\n                pass\n            else:\n                return False\n            for i in range(len(heaters)-1):\n                index_pre = bisect_right(houses, heaters[i]+r)\n                index_next = bisect_left(houses, heaters[i+1]-r)\n                if index_next > index_pre:\n                    return False\n            if bisect_right(houses, heaters[-1]+r) < len(houses):\n                return False\n            else:\n                return True\n\n        l, r = 0, total[-1]-total[0]\n        while l <= r:\n            mid = (l+r)//2\n            if possible(mid):\n                r = mid-1\n            else:\n                l = mid+1\n        \n        return l\n```\n\n### 复杂度分析\n\nT(n) = O(nlogn + lognlog（max_idx-min_idx)\n\nS(n) = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1484063120","body":"### 思路\n\n题目打不开做了推荐的这个https://leetcode.cn/problems/find-k-th-smallest-pair-distance/\n\n把差值范围[0, max-min]作为二分的对象进行操作，直到小于等于该差值的pair正好等于k个。\n\n但我的这个code超时没通过，看了官方题解，感觉和官方题解差不多，没想明白哪里的问题...所以这个代码还不对，先占个坑慢慢想...\n\n** 写完提交前再回去看了一眼官方题解，突然好像明白了，那个for里面的while循环更简洁复杂度更低！！\n\n### 代码\n\n我原来的（超时）：\n```python\nclass Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        l, r = 0, nums[-1]-nums[0]\n\n        def counts(diff):\n            cnt = 0\n            for i in range(1, len(nums)):\n                for j in range(i-1, -1, -1):\n                    if nums[i]-nums[j] <= diff:\n                        cnt += 1\n                    else:\n                        break\n                    if cnt >= k:\n                        return True\n\n            return False\n\n        while l <= r:\n            mid = (l+r)//2\n            if counts(mid):\n                r = mid - 1\n            else:\n                l = mid + 1\n\n        return l\n```\n\n根据官方题解里的修改之后（第二层for循环改成了while）：\n```python\nclass Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        l, r = 0, nums[-1]-nums[0]\n\n        def counts(diff):\n            cnt = 0\n            j = 0\n            for i in range(1, len(nums)):\n                while nums[i]-nums[j] > diff:\n                    j += 1    ## 主要这个j指针每一轮for循环重启时不会重启，是继续往后走的，不像原来的代码每次都要重头再来\n                cnt += i-j\n                if cnt >= k:\n                    return True\n\n            return False\n\n        while l <= r:\n            mid = (l+r)//2\n            if counts(mid):\n                r = mid - 1\n            else:\n                l = mid + 1\n\n        return l\n```\n\n### 复杂度分析\n\nT(n) = O(nlogn)\n\nS(n) = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484541863","body":"### 思路\n\n1. 总的对[0, max_depth]进行最左边界的二分，求能到达右下角的最小深度\n\n2. 二分时判断函数是对二维平面进行DFS\n\n** 注意记录搜索时已访问过的点集合visited\n\n** 注意每次清空集合visited\n\n(看了官方题解再做的)\n\n### 代码\n\n```python\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        N = len(grid)\n\n        def reached(depth, x, y):\n            if x > N-1 or x < 0 or y > N-1 or y < 0:\n                return False\n            elif grid[x][y] > depth:\n                return False\n            elif (x, y) in visited:\n                return False\n            elif x == N-1 and y == N-1:\n                return True\n            else:\n                visited.add((x, y))\n                res = reached(depth, x+1, y) or reached(depth, x-1, y) or reached(depth, x, y+1) or reached(depth, x, y-1)\n            return res\n        \n        l, r = 0, max([max(i) for i in grid])\n\n        while l <= r:\n            visited = set()\n            mid = (l+r)//2\n            if reached(mid, 0, 0):\n                r = mid - 1\n            else:\n                l = mid + 1\n                \n        return l\n```\n\n### 复杂度分析\n\nT(n) = O(n^2logm), n=len(grid), m = max([max(i) for i in grid])\n\nS(n) = O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486222646","body":"### 思路\n\n维护一个长度为k的队列，记录里面的元音字母数res，依次沿着字符串s往后移动，移除或加入一个字母都判断一下是否是元音字母,对应res加减\n\n### 代码\n```python\nimport collections\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        vowel = ['a', 'e', 'i', 'o', 'u']\n        res, ans = 0, 0\n        sub_s = collections.deque()\n        for i in s:\n            if len(sub_s) == k:\n                l = sub_s.popleft()\n                if l in vowel:\n                    res -= 1\n            sub_s.append(i)\n            if i in vowel:\n                res += 1\n            if res == k:\n                return k\n            ans = max(ans, res)\n        return ans\n```\n\n### 复杂度分析\n\nT(n) = O(n)\n\nS(n) = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1487870495","body":"### 思路\n\n滑动窗口+动态规划\n\n### 代码\n(看了官方题解)\n```python\nclass Solution:\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\n        dp = [0] * (k + maxPts)\n        win_sum = 0\n        for i in range(k, k + maxPts):\n            if i <= n:\n                dp[i] = 1\n            win_sum += dp[i]\n\n        for i in range(k - 1, -1, -1):\n            dp[i] = win_sum / maxPts\n            win_sum += dp[i] - dp[i + maxPts]\n        return dp[0]\n```\n\n### 复杂度分析\n\nT(n) = O(w+k)\n\nS(n) = O(w+k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489633962","body":"### 思路\n\n1. 滑动窗口依次遍历s的每个字符，并用字典记录\n\n2. 滑入一个p中的字符则字典相应值的键+1，滑出一个p中的字符则字典相应值的键-1\n\n3. 判断字典是否与p的原始字典相同，相同则记录该子串的起始位置\n\n### 代码\n\n```python\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        cnt, p_dic = {}, {}\n        for i in p:\n            if not i in cnt:\n                p_dic[i] = 1\n                cnt[i] = 0\n            else:\n                p_dic[i] += 1\n        \n        ans = []\n        for i in range(len(s)):\n            if s[i] in p:\n                cnt[s[i]] += 1\n            if i-len(p) >= 0:\n                if s[i-len(p)] in p:\n                    cnt[s[i-len(p)]] -= 1\n            if cnt == p_dic:\n                ans.append(i-len(p)+1)\n        return ans\n```\n\n### 复杂度分析\n\nT(n) = O(len(s)+len(p))\n\nS(n) = O(n), n为p中不重复的字符数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491217014","body":"### 思路\n\n滑动窗口 + 哈希表记录字符个数，并确定左边界的滑动条件\n\n### 代码\n（看了官方题解）\n```python\nfrom collections import Counter\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        l, counter, N, ct = 0, Counter(), len(s), Counter(t)\n        k = 0\n        ret, ans = inf, \"\"\n        for r in range(N):\n            counter[s[r]] += 1\n            if s[r] in t and counter[s[r]] == ct[s[r]]:\n                k += 1\n            while k == len(ct):\n                if r - l + 1 < ret:\n                    ans = s[l:r+1]\n                    ret = r - l + 1\n                counter[s[l]] -= 1\n                if s[l] in t and counter[s[l]] == ct[s[l]]-1:\n                    k -= 1\n                l += 1\n        return ans\n```\n\n### 复杂度分析\n\nT(n) = O(len(s)+len(t))\n\nS(n) = O(n)，n为t中不重复字符数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1493260625","body":"```python\nclass Solution:\n    def solve(self, A, target):\n        if not A and not target: return 0\n        target = sum(A) - target\n        ans = len(A) + 1\n        i = t = 0\n\n        for j in range(len(A)):\n            t += A[j]\n            while i <= j and t > target:\n                t -= A[i]\n                i += 1\n            if t == target: ans = min(ans, len(A) - (j - i + 1))\n        return -1 if ans == len(A) + 1 else ans\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493260393","body":"```python\nclass Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        def possible_number(count, minute=False):\n            if count == 0: return [0]\n            if minute:\n                return filter(lambda a: a < 60, map(sum, combinations([1, 2, 4, 8, 16, 32], count)))\n            return filter(lambda a: a < 12, map(sum, combinations([1, 2, 4, 8], count)))\n        ans = set()\n        for i in range(min(4, turnedOn + 1)):\n            for a in possible_number(i):\n                for b in possible_number(turnedOn - i, True):\n                    ans.add(str(a) + \":\" + str(b).rjust(2, '0'))\n        return list(ans)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1493628757","body":"看了官方题解..\n```js\n/**\n * @param {number} n\n * @return {number}\n * @param row 当前层\n * @param col 列\n * @param pie 左斜线\n * @param na 右斜线\n */\nconst totalNQueens = function (n) {\n  let res = 0;\n  const dfs = (n, row, col, pie, na) => {\n    if (row >= n) {\n      res++;\n      return;\n    }\n    // 将所有能放置 Q 的位置由 0 变成 1，以便进行后续的位遍历\n    // 也就是得到当前所有的空位\n    let bits = ~(col | pie | na) & ((1 << n) - 1);\n    while (bits) {\n      // 取最低位的1\n      let p = bits & -bits;\n      // 把P位置上放入皇后\n      bits = bits & (bits - 1);\n      // row + 1 搜索下一行可能的位置\n      // col ｜ p 目前所有放置皇后的列\n      // (pie | p) << 1 和 (na | p) >> 1) 与已放置过皇后的位置 位于一条斜线上的位置\n      dfs(n, row + 1, col | p, (pie | p) << 1, (na | p) >> 1);\n    }\n  };\n  dfs(n, 0, 0, 0, 0);\n  return res;\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501527044","body":"```python\nclass Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n\n        dp = [[1, 1] for i in range(n)]\n        ans = [1, 1]\n        longest = 1\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[j] > nums[i]:\n                    if dp[i][0] + 1 > dp[j][0]:\n                        dp[j][0] = dp[i][0] + 1\n\n                        dp[j][1] = dp[i][1]\n                        longest = max(longest, dp[j][0])\n                    elif dp[i][0] + 1 == dp[j][0]:\n                        dp[j][1] += dp[i][1]\n        return sum(dp[i][1] for i in range(n) if dp[i][0] == longest)\n```\nT(n) = O(n^2)\n\nS(n) = O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517536977","body":"```python\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n      \n        _max = 0\n        _len = len(nums)\n        for i in range(_len-1):\n            if _max < i:\n                return False\n            _max = max(_max, nums[i] + i)\n\n            if _max >= _len - 1:\n                return True\n        return _max >= _len - 1\n```\n\nT(n) = O(n)\n\nS(n) = O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1522802816","body":"```python\nclass Solution:\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res, end = [], 1 << len(nums)\n        for sign in range(end):\n            subset = []\n            for i in range(len(nums)):\n                if ((1 << i) & sign) != 0:\n                    subset.append(nums[i])\n            res.append(subset)\n        return res\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1531300116","body":"```python\nclass Solution:\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        root = [i for i in range(n)]\n\n        def find(p):\n            while p != root[p]:\n                root[p] = root[root[p]]\n                p = root[p]\n\n            return p\n\n        def union(p, q):\n            root[find(p)] = find(q)\n\n        have = 0\n        for connec in connections:\n            a, b = connec\n            if find(a) != find(b):\n                union(a, b)\n            else:\n                have += 1\n\n        diff_root = set()\n        for i in range(n):\n            diff_root.add(find(i))\n\n        return len(diff_root) - 1 if have >= len(diff_root) - 1 else -1\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null],"krabbejing":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429898395","body":"\n    class Solution:\n        def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n            i = len(num)-1\n            while k:\n                num[i] += k\n                k, num[i] = num[i] // 10, num[i] % 10\n                i -= 1\n                if i < 0 and k > 0:\n                    i = 0\n                    num.insert(0,0)\n            return num\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431543980","body":"    class Solution:\n        def shortestToChar(self, s: str, c: str) -> List[int]:\n            length = len(s)\n            res = [0 if s[i] == c else None for i in range(length)]\n            # left to right\n            for i in range(1, length):\n                if res[i] != 0 and res[i-1] is not None:\n                    res[i] = res[i-1] + 1\n            # right to left\n            for i in range(length-2, -1, -1):\n                if res[i] is None or res[i+1] + 1 < res[i]:\n                    res[i] =  res[i+1] + 1\n            return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433234776","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.currentSize = 0\n        self.storage = []\n\n    def push(self, x: int) -> None:\n        if self.currentSize < self.maxSize:\n            self.storage.append(x)\n            self.currentSize+=1\n\n    def pop(self) -> int:\n        if self.currentSize == 0:\n            return -1\n        self.currentSize-=1\n        return self.storage.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        incre_num = min(k, self.currentSize)\n        for i in range(incre_num):\n            self.storage[i] += val\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437174466","body":"```py\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        cur1 = head\n        tail = head\n        if head is None or head.next is None:\n            return head\n        length = 1\n        while tail.next is not None:\n            length += 1\n            tail = tail.next\n        \n        # new k\n        k = k % length\n        if k == 0:\n            return head\n        tail.next = cur1\n        step = 1\n        while step != length-k:\n            cur1 = cur1.next\n            step += 1\n        \n        head = cur1.next\n        cur1.next = None\n        return head\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438416752","body":"```py\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None or head.next is None:\n            return head\n        fake_head = ListNode()\n        fake_head.next = head\n        temp = fake_head\n\n        while temp.next and temp.next.next:\n            p1 = temp.next\n            p2 = temp.next.next\n            temp.next = p2\n            p1.next = p2.next\n            p2.next = p1\n            temp = p1\n\n        return fake_head.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439375918","body":"```py\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def findMedian(left, right):\n            slow, fast = left, left\n            while fast != right and fast.next != right:\n                slow = slow.next\n                fast = fast.next.next\n            return slow\n        \n        def buildBalanceTree(left, right):\n            if left == right:\n                return None\n            median_node = findMedian(left, right)\n            res = TreeNode(median_node.val)\n            res.left = buildBalanceTree(left, median_node)\n            res.right = buildBalanceTree(median_node.next, right)\n            return res\n\n        return buildBalanceTree(head, None)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441178979","body":"### 思路\nhash set\n### 代码\n```py\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        hash_set = set()\n        p1 = headA\n        p2 = headB\n        while p1 is not None:\n            hash_set.add(p1)\n            p1 = p1.next\n        while p2 is not None:\n            if p2 in hash_set:\n                return p2\n            else:\n                p2 = p2.next\n        return None\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443010315","body":"### 思路\n哈希表\n### 代码\n\n```py\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        hash_set = set()\n        while head:\n            if head in hash_set:\n                return head\n            else:\n                hash_set.add(head)\n                head = head.next\n        return None\n```\n空间复杂度O（N）\n\n### 思路2\n快慢指针\n### 代码\n```py\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast, slow = head, head\n        mark = None\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                mark = fast\n                break\n        if not mark:\n            return None\n\n        fast = head\n        while fast != mark:\n            fast = fast.next\n            mark = mark.next\n        return fast\n```\n空间复杂度O（1）\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445341506","body":"### 思路\n递归\n### 代码\n```py\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None: \n            return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447484854","body":"### 思路\nDFS\n### 代码\n```py\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(root, cur):\n            if root is None:\n                return 0\n            if root.left is None and root.right is None:\n                return cur * 10 + root.val\n            return dfs(root.left, cur*10+root.val) + dfs(root.right, cur*10+root.val)\n\n        return dfs(root, 0)\n```\n### 复杂度\n\n时间复杂度O(节点数)\n\n空间复杂度O(高度)\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456290010","body":"```py\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n        num = len(points)\n        for i in range(num):\n            collect = dict()\n            for j in range(num):\n                distance = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\n                if distance in collect:\n                    collect[distance] += 1\n                else:\n                    collect[distance] = 1\n            \n            for v in collect.values():\n                res += v * (v-1)\n\n        return res\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466378535","body":"### 思路\n最大堆/优先队列\n### 代码\n```py\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        ans = []\n        heap_max = []\n        for i in range(k):\n            heapq.heappush(heap_max, (-nums[i], i))\n        ans.append(-heap_max[0][0])\n\n        for i in range(k, n):\n            heapq.heappush(heap_max, (-nums[i], i))\n            while heap_max[0][1] < i-k+1:\n                heapq.heappop(heap_max)\n            ans.append(-heap_max[0][0])\n        return ans\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468219861","body":"### 思路\n出度为0，入度为n-1\n### 代码\n```py\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        in_degree = [0] * (n + 1)\n        out_degree = [0] * (n + 1)\n        for a, b in trust:\n            out_degree[a] += 1\n            in_degree[b] += 1\n        for i in range(1, n+1):\n            if in_degree[i] == n-1 and out_degree[i] == 0:\n                return i\n        return -1 \n```","onTime":true},null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480480206","body":"### 思路\n二分法\n### 复杂度\n\n* 时间 O(logn)\n* 空间 O(n)\n\n### 代码\n```py\n# The isBadVersion API is already defined for you.\n# def isBadVersion(version: int) -> bool:\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        l, r = 1, n\n        while l <= r:\n            mid = (l + r ) // 2\n            if isBadVersion(mid):\n                r = mid - 1\n            else:\n                l = mid + 1 \n        return l\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484651764","body":"### 思路\n二分查找\n\n### 代码\n```py\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        l, r = 0, max([max(row) for row in grid])\n        M, N = len(grid), len(grid[0])\n        seen = set()\n        def is_pass(value, x, y):\n            if x >= M or y >= N or x < 0 or y < 0:\n                return False\n            if value < grid[x][y]:\n                return False\n            if (x, y) == (M-1, N-1):\n                return True\n            if (x, y) in seen:\n                return False\n            seen.add((x, y))\n            ans = (is_pass(value, x + 1, y) \n                    or is_pass(value, x - 1, y)\n                    or is_pass(value, x, y - 1)\n                    or is_pass(value, x, y + 1))\n            return ans\n\n        while l <= r:\n            mid = (l + r) // 2\n            if is_pass(mid, 0, 0):\n                r = mid - 1\n            else:\n                l = mid + 1\n            seen = set()\n        return l\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486995062","body":"```py\n\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        vowels = ['a', 'e', 'i', 'o', 'u']\n        res = 0\n        for i in range(k):\n            res += 1 if s[i] in vowels else 0\n        if res == k: return k\n        temp = res\n        for i in range(k, len(s)):\n            temp += (s[i] in vowels) - (s[i-k] in vowels)\n            if temp == k: return k\n            res = max(temp, res)\n        return res\n\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494557701","body":"```py\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        res = 0\n        def dfs(n, row, col, left, right):\n            if row == n:\n                return 1\n            else:\n                res = 0\n                # 将所有能放置皇后的位置0变成1\n                bit = ~(right | col | left) & ((1<<n)-1)\n                while bit:\n                    # 取最低位的1，11100指的是第三位\n                    p = bit & -bit\n                    # 把最低位的1置为0，放上皇后\n                    bit = bit & (bit - 1)\n                    # col | p 目前所有放置皇后的列\n                    # (left|p)<<1 目前皇后的左对角线\n                    # (right|p)>>1 目前皇后的右对角线\n                    res += dfs(n, row+1, col | p, (left|p)<<1, (right|p)>>1)\n                return res\n        return dfs(n, 0, 0, 0, 0)\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498781063","body":"```py\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        boxes_i_have = set(initialBoxes)\n        boxes_i_can_open = [i for i in boxes_i_have if status[i]]\n        for box_i in boxes_i_can_open:\n            # 先把盒子box_i里内含的盒子放到我拥有的一堆\n            for j in containedBoxes[box_i]:\n                boxes_i_have.add(j)\n            # 能打开的放到能打开的一队\n                if status[j]:\n                    boxes_i_can_open.append(j)\n            # 再使用box_i里面放的钥匙\n            for k in keys[box_i]:\n                if status[k] == 0 and k in boxes_i_have:\n                    boxes_i_can_open.append(k)\n                # 一定要记得状态置为可以打开\n                status[k] = 1\n        return sum(candies[i] for i in boxes_i_can_open)\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501770637","body":"```py\nclass Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 0: return 0\n        if n == 1: return 1\n        longest = 1\n        dp = [[1,1] for i in range(n)]\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums[j] > nums[i]:\n                    if dp[i][0] + 1 > dp[j][0]:\n                        dp[j][0] = dp[i][0] + 1\n                        dp[j][1] = dp[i][1]\n                        longest = max(longest, dp[j][0])\n                    elif dp[i][0] + 1 == dp[j][0]:\n                        dp[j][1] += dp[i][1]\n        return sum(dp[i][1] for i in range(n) if dp[i][0] == longest)\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1508493320","body":"### 代码\n```py\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        @cache\n        def dfs(usedNumbers: int, currentTotal: int) -> bool:\n            for i in range(maxChoosableInteger):\n                if (usedNumbers >> i) & 1 == 0:\n                    if currentTotal + i + 1 >= desiredTotal or not dfs(usedNumbers | (1 << i), currentTotal + i + 1):\n                        return True\n            return False\n\n        return (1 + maxChoosableInteger) * maxChoosableInteger // 2 >= desiredTotal and dfs(0, 0)\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511486508","body":"```py\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dump = [float(\"inf\")] * (amount + 1)\n        dump[0] = 0\n        for i in range(1, amount+1):\n            for coin in coins:\n                if i>=coin:\n                    dump[i] = min(dump[i], dump[i-coin]+1)\n        if dump[amount] == float(\"inf\"):\n            return -1\n        else:\n            return dump[amount]\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519071700","body":"```py\nclass Solution:\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n        n = len(lists)\n\n        if lenth == 0: return None\n        if lenth == 1: return lists[0]\n        if lenth == 2: return self.mergeTwoLists(lists[0], lists[1])\n\n        mid = n // 2\n        return self.mergeTwoLists(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:n]))\n\n\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        res = ListNode(0)\n        c1, c2, c3 = l1, l2, res\n        while c1 or c2:\n            if c1 and c2:\n                if c1.val < c2.val:\n                    c3.next = ListNode(c1.val)\n                    c1 = c1.next\n                else:\n                    c3.next = ListNode(c2.val)\n                    c2 = c2.next\n                c3 = c3.next\n            elif c1:\n                c3.next = c1\n                break\n            else:\n                c3.next = c2\n                break\n\n        return res.next\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"firehaosky":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429903817","body":"# 思路：\n# k取余数与num的最后一位相加，数组长度i-1，用re来记录进位，当k取整或数组num的长度i为0时，将剩余数，插入数组前面。\n\n# 代码：\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        re = 0\n        ans = []\n        i_num = len(num)-1\n        i_k = len(str(k))-1\n\n        while i_num>=0 or i_k>=0:\n            x = num[i_num] if i_num>=0 else 0\n            y = k%10 if i_k>=0 else 0\n            k //= 10\n\n            sums = x+y+re\n            re = sums // 10\n            ans.insert(0, sums%10)\n\n            i_num -= 1\n            i_k -= 1\n        \n        if re>0:\n            ans.insert(0, re)\n        \n        return ans\n\n# 复杂度分析\n# 时间复杂度：O(n)\n# 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431347829","body":"# 思路：\n'''\n遍历数组，从左起以数组最大长度计算，逐个递减，当遇到c的时候更新被减数\n从右再遍历一遍，同之前的结果对比取最小值。\n'''\n# 解题 python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [0] * n\n\n        idx = -n\n        for i in range(0,n):\n            if s[i] == c:\n                idx = i\n            \n            ans[i] = i - idx\n        \n        idx = 2*n\n        for i in range(n-1, -1, -1):\n            if s[i] == c:\n                idx = i\n            \n            ans[i] = min(ans[i], idx-i)\n        \n        return ans\n\n# 复杂度分析：\n'''\n时间复杂度：for循环O（n）\n空间复杂度：O（1）\n'''","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432933019","body":"# 思路：\n'''\n首先根据最大值确定数组长度，以及数组计数\n'''\n\n# 解题 python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = [0] * maxSize\n        self.top_num = -1\n\n\n    def push(self, x: int) -> None:\n        if self.top_num != len(self.stack)-1:\n            self.top_num+=1\n            self.stack[self.top_num] = x\n\n\n\n    def pop(self) -> int:\n        if self.top_num != -1:\n            self.top_num -= 1\n            return self.stack[self.top_num+1]\n        else:\n            return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        lm = min(k, self.top_num+1)\n        for i in range(lm):\n            self.stack[i] += val\n\n\n\n\n# 复杂度分析：\n\"\"\"\n时间复杂度：只有inc中为O（n）\n空间复杂度：O（maxsize）\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434621754","body":"# 思路：\n\"\"\"\n采用递归，遇见数字就记录为数字，遇到[就将当前位置和字符串传入递归，当遇到]就返回保存的字符和位置\n\"\"\"\n\n# 解题：python\n\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        def dfs(s,i):\n            res = \"\"\n            multi = 0\n            while i < len(s):\n                if '0' <= s[i] <= '9':\n                    multi = multi*10 + int(s[i])\n                \n                elif s[i] == '[':\n                    i, tmp = dfs(s, i+1)\n                    res += multi * tmp\n                    multi = 0\n\n                elif s[i] == ']':\n                    return i, res\n\n                else:\n                    res += s[i]\n                \n                i+=1\n\n\n            return res\n        \n\n        return dfs(s,0)\n\n# 复杂度分析：\n\"\"\"\n时间复杂度：循环，O(n)\n空间复杂度：占用空间O(n)\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435660070","body":"class MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.s1 = []\n        self.s2 = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.s1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n        return self.s2.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.s2 == []:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n        return self.s2[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return self.s1 == [] and self.s2 == []\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435973222","body":"# 思路：\n\"\"\"\n要求分块的排序与原本排序一致，即当前块的最大值，要小于后面的所有值\n\n\"\"\"\n# 解题：python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for a in arr:\n            if len(stack) == 0 or a >= stack[-1]:\n                stack.append(a)\n            else:\n                mx = stack.pop()\n                while stack and a<stack[-1]:\n                    stack.pop()\n                stack.append(mx)\n        \n        return len(stack)\n\n\n# 复杂度分析：\n\"\"\"\n时间复杂度：采用了遍历，O(n)\n空间复杂度：使用了列表，O(n)\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437198448","body":"# 思路：\n\"\"\"\n循环，首先要判断其长度和循环后的起点位置，循环后顺序仍然相同，只需要找到断点即可\n\"\"\"\n\n# 解题：python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0 or not head or not head.next:\n            return head\n\n        cur = head\n        n = 1\n\n        while cur.next:\n            cur = cur.next\n            n += 1\n\n        if (add := n - k%n) == n:\n            return head\n\n        cur.next = head\n        while add:\n            cur = cur.next\n            add -= 1\n\n        re = cur.next\n        cur.next = None\n        return re\n\n# 复杂度分析：\n\"\"\"\n时间复杂度：采用了两个while循环，复杂度为O(n)\n空间复杂度：O(1)\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438460180","body":"# 思路：\n\"\"\"\n通过一个中间节点分别指向之后的两个节点，然后将这个中间节点推进至第二个节点的位置，重复上述过程，知道没有节点或只有一个节点的时候。\n\"\"\"\n# 解题：python\n\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        middle = ListNode[0]\n        middle.next = head\n        temp = middle\n        while temp.next and temp.next.next:\n            node1 = temp.next\n            node2 = temp.next.next\n            temp.next = node2\n            node1.next = node2.next\n            node2.next = node1\n            temp = node1\n        return middle.next\n\n# 复杂度分析：\n\"\"\"\n时间复杂度：O(n)\n空间复杂度：O(1)\n\"\"\"\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440300313","body":"`class Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        def getMiddle(left, right):\r\n            fast = slow = left\r\n            while fast!=right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n\r\n        def buildTree(left, right):\r\n            if left == right:\r\n                return None\r\n\r\n            mid = getMiddle(left, right)\r\n            root = TreeNode(mid.val)\r\n            root.left = buildTree(left, mid)\r\n            root.right = buildTree(mid.next, right)\r\n            return root\r\n\r\n        return buildTree(head, None)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441659165","body":"# 思路：\n\"\"\"\n通过两个指针，分别从头开始遍历两个链表，当到达末尾时，从另一个链表开始继续，当相等是为所需节点，或为空\n\"\"\"\n# 解题：python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if headA==None or headB==None:\n            return None\n        \n        pa = headA\n        pb = headB\n        while pa!=pb:\n            pa = pa.next if pa else headB\n            pb = pb.next if pb else headA\n        \n        return pa\n\n# 复杂度分析：\n\"\"\"\n时间复杂度：O(m+n) 最坏的情况需要两个链表都循环一遍\n空间复杂度：O(1)\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443719531","body":"# 思路：\n\"\"\"\n用两个指针，一个走两步，一个走一步，当相遇时，即为有环，否则返回空；此时慢指针步数为整数倍的环周期；\n再用一个指针，从头走，慢指针同时向前走，当两个指针相遇时，其位置即为环节点入口位置\n\"\"\"\n# 解题：python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast, slow = head, head\n        while True:\n            if not(fast and fast.next): return\n\n            fast = fast.next.next\n            slow = slow.next\n\n            if fast == slow:\n                break\n        \n        fast = head\n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n\n        return slow\n\n# 复杂度分析：\n\"\"\"\n时间复杂度：O(n)\n空间复杂度：O(1)\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1444994242","body":"# 思路：\n\"\"\"\n通过一个字典和链表来存储键值和顺序，通过设链表的头尾，用于链表指针的确定\n\"\"\"\n# 解题：python\n\nclass MyNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.next = None\n        self.prev = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cashe = dict()\n        self.head = MyNode()\n        self.tail = MyNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.size = 0\n        self.capacity = capacity\n\n\n    def get(self, key: int) -> int:\n        if key not in self.cashe:\n            return -1\n\n        node = self.cashe[key]\n        self.moveToHead(node)\n        return node.value\n\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cashe:\n            node = self.cashe[key]\n            node.value = value\n            self.moveToHead(node)\n        else:\n            node = MyNode(key, value)\n            self.cashe[key] = node\n            self.addToHead(node)\n            self.size+=1\n\n            if self.size>self.capacity:\n                removed = self.removeTail()\n                self.cashe.pop(removed.key)\n                self.size-=1\n\n    \n    def removeNode(self,node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def addToHead(self,node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n\n    def moveToHead(self,node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n# 复杂度分析：\n\"\"\"\n时间复杂度：O(1)\n空间复杂度:O(capacity)\n\"\"\"\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445266778","body":"# 思路：\n\"\"\"\n找最大深度，需要分别从左右节点中寻找最大深度，所以使用递归\n\"\"\"\n# 解题：python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n\n        else:\n            left_length = self.maxDepth(root.left)\n            right_length = self.maxDepth(root.right)\n            return max(left_length, right_length)+1\n\n# 复杂度分析：\n\"\"\"\n时间复杂度：需要便利所有节点，为O(n)\n空间复杂度：O(height)\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446454274","body":"# 思路：\n\"\"\"\n首先判断，是否为空，是否都有节点，然后递归计算左右节点是否相同\n\"\"\"\n\n# 解题：python\n\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n\n        elif not p or not q:\n            return False\n        \n        elif p.val != q.val:\n            return False\n        \n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\n# 复杂度分析：\n\"\"\"\n时间复杂度：O(min(m,n))\n空间复杂度：O(min(m,n))\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447514262","body":"# 思路：\n'''\n采用递归，分别遍历节点，并且将根节点的值传入\n'''\n\n# 解题：python\n```\n\n\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(root:Optional[TreeNode], prevale:int) -> int:\n            if not root:\n                return 0\n\n            cal = prevale * 10 + root.val\n            if not root.left and not root.right:\n                return cal\n\n            else:\n                return dfs(root.left, cal) + dfs(root.right, cal)\n    \n        return dfs(root,0)\n\n```\n# 复杂度分析：\n'''\n时间复杂度：O(n)\n空间复杂度：O(n)\n'''","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449276183","body":"# 思路：\n\"\"\"\n采用广度优先搜索，先存右节点，再存左节点，可以保证最后出现的是左节点\n\"\"\"\n# 解题：python\n```\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        q = deque([root])\n        while q:\n            node = q.popleft()\n            if node.right:\n                q.append(node.right)\n            if node.left:\n                q.append(node.left)\n            ans = node.val\n        return ans\n\n```\n# 复杂度分析：\n\"\"\"\n时间复杂度：O(n)\n空间复杂度:O(n)\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451241383","body":"# 思路：\n\"\"\"\n序列化：采用dfs，遍历并且将空节点存为None，转化为字符串，用，间隔\n反序列化：转化成列表，递归弹出节点，存入树中\n\"\"\"\n# 解题：python\n```\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return 'None'\n        return str(root.val) + ',' + str(self.serialize(root.left)) + ',' + str(self.serialize(root.right))\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def dfs(dataList):\n            val = dataList.pop(0)\n            if val == 'None':\n                return None\n            \n            root = TreeNode(int(val))\n            root.left = dfs(dataList)\n            root.right = dfs(dataList)\n            return root\n        \n        dataList = data.split(',')\n        return dfs(dataList)\n        \n```\n# 复杂度分析：\n\"\"\"\n时间复杂度：O(n)\n空间复杂度：O(n)\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1452793393","body":"# 思路：\n\"\"\"\n使用一个字典保存，列，行，值的信息，\n遍历树，进行保存，然后进行排序\n\"\"\"\n\n# 解题：python\n```\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def dfs(nood):\n            if not nood:\n                return\n\n            col,row,val = hashmap[nood]\n            if nood.left:\n                hashmap[nood.left] = [col - 1, row + 1, nood.left.val]\n                dfs(nood.left)\n            if nood.right:\n                hashmap[nood.right] = [col + 1, row + 1, nood.right.val]\n                dfs(nood.right)\n\n        hashmap = dict()\n        hashmap[root] = [0,0,root.val]\n        dfs(root)\n        lt = sorted(hashmap.values())\n        n = len(lt)\n        ans = []\n        i = 0\n        while i < n:\n            j = i\n            tmp = []\n            while j < n and lt[j][0] == lt[i][0]:\n                tmp.append(lt[j][2])\n                j+=1\n            ans.append(tmp)\n            i = j\n        return ans\n```\n# 复杂度分析：\n\"\"\"\n时间复杂度：O(nlogn)\n空间复杂度：O(n)\n\"\"\"\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454709572","body":"# 思路:\n\"\"\"\n通过字典，保存当前的位置和与目标的差\n\"\"\"\n# 解题：python\n```\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        target_de = dict()\n        for i, num in enumerate(nums):\n            if target - num in target_de:\n                return [target_de[target-num], i]\n            target_de[num] = i\n        \n        return []\n\n```\n# 复杂度分析：\n\"\"\"\n时间复杂度：O(n) 最坏情况下，需要全部遍历\n空间复杂度:O(n)  最坏情况下，需要把所有数存入字典\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455080256","body":"# 思路：\n\"\"\"\n首先，建立键值对，然后将键值对存入列表，使用python的heapq库，实现排序\n\n\"\"\"\n\n# 解题：python\n\n```\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dicts = dict()\n        for i in nums:\n            if i in dicts:\n                dicts[i] += 1\n            else:\n                dicts[i] = 1\n        \n        ans = []\n\n        for key,value in dicts.items():\n            if len(ans) >= k:\n                if value > ans[0][0]:\n                    heapq.heapreplace(ans, (value,key))\n            else:\n                heapq.heappush(ans,(value,key))\n        return [item[1] for item in ans]\n\n```\n\n# 复杂度分析：\n\"\"\"\n时间复杂度：字典O(n),排序O(logk),总共O(nlogk)\n空间复杂度：O(n)\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455489995","body":"# 思路：\n\"\"\"\n暴力枚举+哈希表计数，最后进行排列组合\n\"\"\"\n# 解题：python\n```\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for i in points:\n            dicts = defaultdict(int)\n            for j in points:\n                distance = ((i[0] - j[0])**2)+((i[1]-j[1])**2)\n                dicts[distance] += 1\n            for m in dicts.values():\n                ans += m * (m - 1)\n        return ans\n\n```\n# 复杂度分析：\n\"\"\"\n时间复杂度：O(n^2)\n空间复杂度：O(n)\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457590474","body":"# 思路：\n\"\"\"\n采用滑动窗口的思路，用一个哈希表储存当前走过的字符，用一个指针标注当前储存字符串的最左端，并且记录其长度，当无重复的字符时，直接将其与计数器比对大小，\n当有重复的字符时，弹出指针所指字符，知道没有重复\n\"\"\"\n# 解题：python\n```\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if not s:\n            return 0\n        left = 0\n        lookup = set()\n        n = len(s)\n        cur_num = 0\n        ans = 0\n        for i in range(n):\n            cur_num += 1\n            while s[i] in lookup:\n                lookup.remove(s[left])\n                left += 1\n                cur_num -= 1\n            ans = max(ans, cur_num)\n            lookup.add(s[i])\n        return ans\n\n```\n# 复杂度分析\n\"\"\"\n时间复杂度：O(n) 需要遍历字符串\n空间复杂度：O(n) \n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459613868","body":"# 思路：\n\"\"\"\n采用两个哈希表和滑动窗口，一个存储words的内容，一个统计滑动窗口的内容，统计从0-一个word的长度\n\"\"\"\n\n# 解题：python\n```\nfrom collections import Counter\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:\n            return []\n        one_word = len(words[0])\n        word_len = len(words)\n        n = len(s)\n        \n        if n < one_word * word_len:\n            return []\n        \n        words = Counter(words)\n        res = []\n\n        for i in range(0, one_word):\n            right = i\n            left = i\n            cur_cnt = 0\n            cur_counter = Counter()\n            while right + one_word <= n:\n                w = s[right:right+one_word]\n                right += one_word\n                if w not in words:\n                    cur_counter.clear()\n                    left = right\n                    cur_cnt = 0\n                else:\n                    cur_cnt+=1\n                    cur_counter[w] += 1\n\n                    while cur_counter[w] > words[w]:\n                        left_w = s[left:left+one_word]\n                        left += one_word\n                        cur_counter[left_w] -= 1\n                        cur_cnt -= 1\n\n\n                    if cur_cnt == word_len:\n                        res.append(left)\n                        left_w = s[left:left+one_word]\n                        left += one_word\n                        cur_counter[left_w] -= 1\n                        cur_cnt -= 1\n        return res\n\n```\n# 复杂度分析\n\"\"\"\n时间复杂度：O(n)\n空间复杂度：O(n)\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462279346","body":"# 思路：\n\"\"\"\n前缀和，哈希表，前缀和计算余数，哈希表记录下标\n\"\"\"\n# 解题：python\n```\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        mod = sum(nums) % p\n        if mod == 0: return 0\n        sub_mod = 0\n        index = {0:-1}\n        ans = len(nums)\n\n        for i, v in enumerate(nums):\n            sub_mod = (sub_mod + v) % p\n            if (sub_mod - mod + p) % p in index:\n                ans = min(ans, i - index[(sub_mod-mod) % p])\n            index[sub_mod] = i\n        return ans if ans < len(nums) else -1\n```\n# 复杂度分析：\n\"\"\"\n时间复杂度：O(n)\n空间复杂度：O(n)\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463301193","body":"# 思路：\n\"\"\"\n在链表中寻找中心点，采用快慢指针的方法，要求在偶数长度的链表时，选取右侧节点，所以判断fast.next是否为空\n\"\"\"\n\n#解题：python\n```\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None: return None\n\n        slow = head\n        fast = head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        return slow\n\n```\n\n# 复杂度分析\n\"\"\"\n时间复杂度：O(n) 快指针要遍历整个链表\n空间复杂度：O(1)\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464839994","body":"# 思路：\n\"\"\"\n用双指针，当快指针与慢指针相同时，快指针前进一位，当不相同时，快指针的值复制到慢指针前一位，慢指针前进一位，当两个指针位置差大于1时，更新\n\"\"\"\n# 解题：python\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        n = len(nums)\n        fast = 1\n        slow = 0\n        while fast < n:\n            if nums[fast] != nums[slow]:\n                if fast - slow > 1:\n                    nums[slow+1] = nums[fast]\n                slow += 1\n            fast += 1\n        \n        return slow + 1\n```\n# 复杂度分析：\n\"\"\"\n时间复杂度：O(n)\n空间复杂度：O(1)\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465144039","body":"# 思路：\n\"\"\"\n采用二分查找的方法\n\"\"\"\n# 解题：python\n```\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left = 0\n        right = len(nums)\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\n```\n# 复杂度分析：\n\"\"\"\n时间复杂度：O(logn)\n空间复杂度：O(1)\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465701836","body":"# 思路：\n\"\"\"\n方法一：优先队列，队列中保存数值和下标，当下标在范围内，队列头即为最大值；否则就弹出队列头；<br/>\n方法二：单调队列，在优先队列的方法基础上，先保存前k个范围的最大值，及其后面的值，队列中保存其下标；<br/>\n然后遍历，小于最后值的直接保存；大于的，弹出队列末尾，知道符合条件，然后检测队列头的下标是否符合，否则弹出，保存当前最大值。\n\"\"\"\n# 代码：python\n```\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        q = collections.deque()\n        for i in range(k):\n            while q and nums[i] >= nums[q[-1]]:\n                q.pop()\n            q.append(i)\n        \n        ans = [nums[q[0]]]\n        for i in range(k,n):\n            while q and nums[i] >= nums[q[-1]]:\n                q.pop()\n            q.append(i)\n            while q[0] <= i-k:\n                q.popleft()\n            ans.append(nums[q[0]])\n        return ans\n```\n# 复杂度分析：\n\"\"\"\n时间复杂度：O(n) <br/>\n空间复杂度：O(k)\n\"\"\"\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467437987","body":"# 思路：\n\"\"\"<br/>\n按照讲义中的思路，先构建领接矩阵，然后将信任关系存入矩阵相应位置中，<br/>\n然后统计当前节点的出度和入度，如果入度为n-1，出度为0，就是秘密法官，<br/>\n这种情况下，存入时间复杂度O(m),统计时间复杂度O(n^2)<br/>\n所以，领接矩阵改为两个单独列表，分别统计入度和出度，最后找到符合条件的下标。<br/>\n\"\"\"\n# 代码：python\n```\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        in_trust = [0]*(n+1)\n        out_trust = [0]*(n+1)\n        for a,b in trust:\n            in_trust[b] += 1\n            out_trust[a] += 1\n\n        for i in range(1,n+1):\n            if in_trust[i] == n-1 and out_trust[i] == 0:\n                return i\n        return -1\n```\n# 复杂度分析\n\"\"\"<br/>\n时间复杂度：O(n+m),m为trust长度<br/>\n空间复杂度：O(n)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469563727","body":"# 思路：\n\"\"\"<br/>\n图染色法，对相邻点进行数值判断，并且向下迭代，向上传递，<br/>\n可以采用DFS，BFS<br/>\n\n\"\"\"\n# 代码：python\n```\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        group = [[] for _ in range(n)]\n        for a,b in dislikes:\n            group[a-1].append(b-1)\n            group[b-1].append(a-1)\n        color = [0]*n\n        \n        def dfs(index_i, color_value):\n            color[index_i] = color_value\n            for j in group[index_i]:\n                if color[j] == color_value:\n                    return False\n                if color[j] == 0 and not dfs(j, 3-color_value):\n                    return False\n            return True\n        \n        return all(color_value or dfs(index_i, 1) for index_i, color_value in enumerate(color))\n```\n# 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n+m)<br/>\n空间复杂度：O(n+m)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1471527194","body":"# 思路：\n\"\"\"<br/>\n双拓扑排序，<br/>\n1：修改分组信息<br/>\n2：建立组内和组间的领接矩阵<br/>\n3：拓扑排序，可以使用DFS，BFS<br/>\n4：先进行组内排序，然后进行组间排序，如果没问题，合成答案<br/>\n5：其实我也没看懂，看写完能不能懂<br/>\n\"\"\"\n# 代码：python\n```\nclass Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        \"\"\"\n        n:项目数\n        m:小组数\n        group:项目所属\n        beforeItems:项目前置任务，即简单拓扑要解决的排序问题\n        \"\"\"\n        # 修改分组信息\n        groupIndex2groupMember = defaultdict(list) # 保存了{小组：[项目]}\n        for i in range(n):\n            if group[i] == -1:\n                group[i] = m\n                m += 1\n            groupIndex2groupMember[group[i]].append(i)\n        \n        # 2:组内和组间建领接矩阵\n        inter = defaultdict(list)  # 组间\n        inner = defaultdict(lambda:defaultdict(list))   # 组内\n        for i in range(n):\n            for j in beforeItems[i]:\n                # j -> i\n                if group[i] == group[j]:  # i的前置任务j在同一个组中\n                    inner[group[i]][j].append(i)  # {任务组：{前置任务号：[项目号]}}\n                else:\n                    inter[group[j]].append(group[i])  # {前置任务号：[项目号]}\n        # 以上，实现了在同一个项目组下，j->i的图建立,和不同任务下j->i的图建立\n\n        # 3：拓扑排序\n        def check_topo(g, nodes):\n            \"\"\"\n            首先，对于有向无环图中的每个节点，使用 defaultdict(int) 创建一个名为 \"indeg\" 的字典，记录每个节点的入度。\n            然后，遍历有向无环图中的每个节点，将与该节点相邻的节点的入度加1。\n            接着，从所有入度为0的节点开始，执行拓扑排序的过程。将这些入度为0的节点存储在一个列表 \"q\" 中，\n                并将其复制到 \"topo_ans\" 列表中，用于存储拓扑排序的结果。\n            然后，循环遍历 \"q\" 列表，对于每个节点 \"qq\"，将与其相邻的节点 \"next_node\" 的入度减1，\n                并将入度变为0的节点添加到 \"new_q\" 列表中，用于下一轮遍历。\n            最后，将 \"new_q\" 列表赋值给 \"q\"，继续执行上述循环过程，直到所有节点都被遍历完毕。\n                如果拓扑排序结果中的节点数与输入节点列表 \"nodes\" 的长度相等，则返回拓扑排序的结果，否则返回一个空列表。\n            \"\"\"\n            indeg = defaultdict(int)\n            for x in g:\n                for y in g[x]: # y入度+1\n                    indeg[y] += 1\n            q = [i for i in nodes if indeg[i] == 0]  # 在indeg函数中，i为0时，存入\n            topo_ans = q[:]\n            while q:\n                new_q = []\n                for qq in q:\n                    for next_node in g[qq]:\n                        indeg[next_node] -= 1\n                        if indeg[next_node] == 0:\n                            topo_ans.append(next_node)\n                            new_q.append(next_node)\n                q = new_q\n            return topo_ans if len(topo_ans) == len(nodes) else []\n\n        # 4:组间 topo\n        inter_topo = check_topo(inter,list(set(group)))\n        if len(inter_topo) == 0:\n            return []\n        \n        # 5:组内topo\n        whole_topo = []\n        for idx in inter_topo: # 按照inter_topo取出group的idx\n            inner_topo = check_topo(inner[idx], groupIndex2groupMember[idx])\n\n            if len(inner_topo) == 0:\n                return []\n            whole_topo.extend(inner_topo)\n        return whole_topo\n```\n# 复杂度分析\n\"\"\"<br/>\n时间复杂度：O(m+n)\n空间复杂度：O(m+n)\n\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473345136","body":"# 思路：\n\"\"\"<br/>\n令U为y-1,D为y+1,L为x-1,R为x+1<br/>\n\"\"\"\n# 代码：python\n```\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        x=y=0\n        for move in moves:\n            if move == \"U\":y-=1\n            elif move == 'D':y+=1\n            elif move == \"L\":x-=1\n            elif move == \"R\":x+=1\n        \n        return x == y == 0\n```\n# 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n)<br/>\n空间复杂度：O(1)<br/>\n\n\"\"\"\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474668082","body":"# 思路：\n\"\"\"<br/>\n用两个表来维护优先顺序和当前队列中的任务，所以一个用小根堆<br/>\n\"\"\"\n# 代码：python\n```\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        n = len(tasks)\n        indices = list(range(n))\n        indices.sort(key=lambda x:tasks[x][0])\n\n        ans = []\n        q=[]\n        timestamp = 0\n        ptr = 0\n\n        for i in range(n):\n            if not q:\n                timestamp = max(timestamp, tasks[indices[ptr]][0])\n            while ptr < n and tasks[indices[ptr]][0] <= timestamp:\n                heapq.heappush(q,(tasks[indices[ptr]][1],indices[ptr]))\n                ptr+=1\n            process,index = heapq.heappop(q)\n            timestamp += process\n            ans.append(index)\n        return ans\n```\n# 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(nlogn)<br/>\n空间复杂度：O(n)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475063034","body":"# 思路：\n\"\"\"<br/>\n将时间转化为分钟计数，当通宵之后，加一天1440<br/>\n\"\"\"\n```\nclass Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        strat_time = 60*int(loginTime[:2]) + int(loginTime[3:])\n        end_time = 60*int(logoutTime[:2]) + int(logoutTime[3:])\n\n        if end_time < strat_time:\n            end_time += 1440\n        \n        end_time = end_time//15 * 15\n\n        return max(0, end_time-strat_time)//15\n```\n#复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(1)<br/>\n空间复杂度：O(1)<br/>\n\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475681803","body":"# 思路：\n\"\"\"<br/>\n分别统计两个字符串中对于某一字母的大小统计，然后对26个字母依次进行遍历，选取满足条件的最小值。<br/>\n\"\"\"\n# 代码：python\n```\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        a = [ord(i) - 97 for i in a]\n        b = [ord(i) - 97 for i in b]\n        AA = Counter(a)\n        BB = Counter(b)\n        C = AA + BB\n        ans = sum(C.values()) - max(C.values())\n        A = [0] * 26\n        B = [0] * 26\n        for k,v in AA.items():\n            A[k] = v\n        for k,v in BB.items():\n            B[k] = v\n\n        for i in range(1,26):\n            ans = min(ans,sum(A[i:])+sum(B[:i]))\n            ans = min(ans,sum(A[:i])+sum(B[i:]))\n        return ans\n```\n# 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(m+n)<br/>\n空间复杂度：O(26)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477355033","body":"# 思路：\n\"\"\"<br/>\n快速排序超时了，全是2.改用归并排序，先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。\n\"\"\"\n# 代码：python\n```\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def mergeSort(arr, low, high):\n            if low >= high:\n                return\n            \n            mid = low + (high-low)//2\n            mergeSort(arr,low,mid)\n            mergeSort(arr,mid+1, high)\n\n            left, right = low, mid+1\n            tmp = []\n            while left <= mid and right <= high:\n                if arr[left] <= arr[right]:\n                    tmp.append(arr[left])\n                    left += 1\n                else:\n                    tmp.append(arr[right])\n                    right += 1\n            \n            while left <= mid:\n                tmp.append(arr[left])\n                left += 1\n            \n            while right <= high:\n                tmp.append(arr[right])\n                right += 1\n\n            arr[low:high+1] = tmp\n        \n        mergeSort(nums, 0, len(nums)-1)\n        return nums\n```\n# 复杂度分析\n<br/>\n\"\"\"<br/>\n时间复杂度：O(nlogn)<br/>\n空间复杂度：O(n)<br/>\n\"\"\"\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1478982837","body":"# 思路：\n\"\"\"<br/>\n牛顿迭代法<br/>\n\"\"\"\n# 代码：python\n```\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 0:\n            return 0\n        c, x0 = float(x), float(x)\n        while True:\n            xi = 0.5* (x0 + c/x0)\n            if abs(xi - x0) < 1e-7:\n                break\n            x0 = xi\n        return int(x0)\n```\n# 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(logn)<br/>\n空间复杂度：O(1)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480629663","body":"# 思路：二分法\n#代码：python\n```\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        left,right = 1,n\n        while left <= right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n```\n# 复杂度分析\n\"\"\"<br/>\n时间复杂度：O(logn)<br/>\n空间复杂度：O(1)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482398822","body":"# 思路：并归排序\n# 代码：python\n```\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        def find_reversed_pairs(nums, left,right):\n            res,mid = 0, (left+(right-left)//2)\n            j=mid+1\n            for i in range(left,mid+1):\n                while j <= right and nums[i] > 2*nums[j]:\n                    res += mid-i+1\n                    j+=1\n            return res\n\n        def merge_sort(nums, nums_sorted,l,r):\n            if l >= r:return 0\n            mid = l + (r-l)//2\n            res = merge_sort(nums,nums_sorted,l,mid) +merge_sort(nums,nums_sorted, mid+1, r) +find_reversed_pairs(nums,l,r)\n\n            i,j,k = l,mid+1,l\n            while i <= mid and j <= r:\n                if nums[i] <= nums[j]:\n                    nums_sorted[k] = nums[i]\n                    i += 1\n                else:\n                    nums_sorted[k] = nums[j]\n                    j += 1\n                k += 1\n            while i <= mid:\n                nums_sorted[k] = nums[i]\n                i+=1\n                k+=1\n            while j <= r:\n                nums_sorted[k] = nums[j]\n                j+=1\n                k+=1\n            for k in range(l,r+1): nums[k] = nums_sorted[k]\n            return res\n\n        if not nums: return 0\n        nums_sorted = [0]*len(nums)\n        return merge_sort(nums,nums_sorted,0,len(nums)-1)\n```\n# 复杂度分析<br/>\n\"\"\"<br/>\n时间复杂度：O(nlogn)<br/>\n空间复杂度：O(n)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483774412","body":"# 思路：排序+二分查找\n# 代码：python\n```\nclass Solution:\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\n        ans = 0\n        heaters.sort()\n        for house in houses:\n            j = bisect_right(heaters, house)\n            i = j - 1\n            rightDistance = heaters[j] - house if j < len(heaters) else float('inf')\n            leftDistance = house - heaters[i] if i >= 0 else float('inf')\n            curDistance = min(leftDistance, rightDistance)\n            ans = max(ans, curDistance)\n        return ans\n```\n#复杂度分析：<br/>\n\"\"\"<br/>\n时间复杂度：o((m+n)logn)<br/>\n空间复杂的：o(nlogn)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1483996605","body":"# 思路：二分法\n# 代码：python\n```\ndef kthSmallestPair(nums, k):\n    # 先对nums列表排序\n    nums.sort()\n    # 左右两个指针，指向nums列表的两个端点\n    low = 0\n    high = nums[-1] - nums[0]\n    n = len(nums)\n    # 用二分法查找第k小的绝对值差\n    while low < high:\n        # 计算mid值\n        mid = (low + high) // 2\n        count = 0\n        left = 0\n        # 双指针技术计算小于等于mid的绝对值差的数量\n        for right in range(n):\n            # 当nums[right] - nums[left] > mid时，移动左指针\n            while nums[right] - nums[left] > mid:\n                left += 1\n            # 计算小于等于mid的绝对值差的数量\n            count += right - left\n        # 如果数量大于等于k，则mid太大，继续在左半边搜索\n        if count >= k:\n            high = mid\n        # 如果数量小于k，则mid太小，继续在右半边搜索\n        else:\n            low = mid + 1\n    # 返回low，它是第k小的绝对值差\n    return low\n```\n# 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(nlogn*logM)<br/>\n空间复杂的：O(1)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484554455","body":"# 思路：二分法\n# 代码：python\n```\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        l = 0\n        r = n * n - 1\n\n        while l < r:\n            mid = l + (r-l)//2\n            if grid[0][0] <= mid and self.check(grid,mid,n):\n                r = mid\n            else:\n                l = mid + 1\n        return l\n    \n    def check(self,grid, mid,n):\n        queue = collections.deque()\n        queue.append((0,0))\n\n        visited = [[False] * n for i in range(n)]\n        visited[0][0] = True\n\n        while queue:\n            x,y = queue.popleft()\n\n            for dx,dy in [(1,0),(-1,0),(0,1),(0,-1)]:\n                nx,ny = x+dx,y+dy\n\n                if  0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] <= mid:\n                    queue.append((nx,ny))\n                    visited[nx][ny] = True\n                    if (nx,ny) == (n-1,n-1):\n                        return True\n\n        return False\n\n```\n# 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n^2logn)<br/>\n空间复杂度:O（n^2）<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486252884","body":"# 思路：滑动窗口\n# 代码：python\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        def isVoxel(ch):\n            return int(ch in 'aeiou')\n        \n        n = len(s)\n        vowel_count = sum(1 for i in range(k) if isVoxel(s[i]))\n        ans = vowel_count\n        for i in range(k,n):\n            vowel_count += isVoxel(s[i]) - isVoxel(s[i-k])\n            ans = max(ans, vowel_count)\n        return ans\n```\n# 复杂度分析：\n\"\"\"<br/>\n时间复杂度：o(n)<br/>\n空间复杂度：o(1)<br/>\n\"\"\"\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1487967378","body":"# 思路：\n\"\"\"<br/>\n二分法，从k-1的时候开始计算后续可能结果的概率，并进行累加<br/>\n\"\"\"\n# 代码：python\n```\nclass Solution:\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\n        dp = [0] * (k+maxPts)\n        s = 0\n        for i in range(k, k+maxPts):\n            dp[i] = 1 if i <= n else 0\n            s+=dp[i]\n        for i in range(k-1,-1,-1):\n            dp[i] = s/maxPts\n            s = s-dp[i+maxPts]+dp[i]\n        return dp[0]\n```\n# 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(k+maxPts)<br/>\n空间复杂度：O(k+maxPts)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489771890","body":"# 思路：\n\"\"\"<br/>\n滑动窗口与哈希表<br/>\n\"\"\"\n# 代码：python\n```\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        n,m,res = len(s), len(p), []\n        if n < m:\n            return res\n        p_cnt = [0] * 26\n        s_cnt = [0] * 26\n        for i in range(m):\n            p_cnt[ord(p[i]) - 97] += 1\n            s_cnt[ord(s[i]) - 97] += 1\n        \n        if s_cnt == p_cnt:\n            res.append(0)\n        \n        for i in range(m, n):\n            s_cnt[ord(s[i-m]) - 97] -= 1\n            s_cnt[ord(s[i]) - 97] += 1\n            if s_cnt == p_cnt:\n                res.append(i-m+1)\n        return res\n```\n# 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n)<br/>\n空间复杂度:O(1)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491329347","body":"# 思路：滑动窗口，哈希表\n# 代码：python\n```\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        needs = defaultdict(int)\n        for i in t:\n            needs[i] += 1\n        nCount = len(t)\n        l = 0\n        res = (0, float('inf'))\n\n        for r, v in enumerate(s):\n            if needs[v] > 0:\n                nCount -= 1\n            needs[v] -= 1\n\n            if nCount == 0:\n                while True:\n                    v  = s[l]\n                    if needs[v] == 0:\n                        break\n                    needs[v] += 1\n                    l += 1\n                \n                if r - l < res[1] - res[0]:\n                    res = (l, r)\n                needs[s[l]] += 1\n                nCount += 1\n                l += 1\n        return '' if res[1] > len(s) else s[res[0]:res[1]+1]\n```\n# 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n)<br/>\n空间复杂度：O(s+t)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1492860576","body":"# 思路：滑动窗口+前缀和\n# 代码：python\n```\ndef min_operations(nums, target):\n    # 计算 nums 的前缀和数组 prefix\n    prefix = [0] * (len(nums) + 1)\n    for i in range(len(nums)):\n        prefix[i+1] = prefix[i] + nums[i]\n    # 初始化左右指针和删除元素的次数\n    left, right, cnt = 0, 0, float('inf')\n    while right < len(nums):\n        # 如果当前滑动窗口中的元素之和小于等于 target，则将右指针向右移动\n        if prefix[right+1] - prefix[left] <= target:\n            right += 1\n        else:\n            # 如果当前滑动窗口中的元素之和大于 target，则将左指针向右移动\n            left += 1\n        # 如果当前滑动窗口中的元素之和等于 target，则更新删除元素的次数\n        if prefix[right] - prefix[left] == target:\n            cnt = min(cnt, right - left)\n    # 如果没有找到任何一个满足条件的滑动窗口，则返回 -1\n    if cnt == float('inf'):\n        return -1\n    else:\n        return cnt\n```\n# 复杂度分析：\n时间复杂度：O(n)\n空间复杂的：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493356023","body":"# 思路：回溯法\n#代码：python\n```\ndef getCnt(x):\n    ans,i=0,x\n    while i >0:\n        ans += 1\n        i -= lowbit(i)\n    return ans\n\ndef lowbit(x):\n    return x & -x\n\nmap = defaultdict(list)\nfor h in range(12):\n    for m in range(60):\n        tot = getCnt(h) + getCnt(m)\n        map[tot].append(f\"{h}:{m:02d}\")\n\nclass Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        return map[turnedOn]\n```\n# 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(1)<br/>\n空间复杂度：O(n)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1493695420","body":"# 思路：回溯+dfs+位运算\n# 代码：python\n```\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        def dfs(n, row, cols, left, right):\n            if (row == n):\n                return 1\n            count = 0\n            void_posisiont = (~(cols| left | right)) & ((1 << n) - 1)\n            while void_posisiont != 0:\n                now_position = void_posisiont & (-void_posisiont)\n                void_posisiont &= (void_posisiont - 1)\n                count += dfs(n, row+1, cols|now_position, (left|now_position) << 1, (right|now_position)>>1)\n            return count\n        \n        return dfs(n, 0, 0, 0, 0)\n```\n# 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n!)<br/>\n空间复杂度：O(n!)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495378232","body":"# 思路：dfs\n#代码：python\n```\nclass Solution:\n    def dfs(self,grid,cur_i, cur_j):\n        if cur_i < 0 or cur_j < 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:\n            return 0\n        grid[cur_i][cur_j] = 0\n        ans = 1\n        for di, dj in [[1,0],[-1,0],[0,1],[0,-1]]:\n            next_i, next_j = cur_i + di, cur_j + dj\n            ans += self.dfs(grid, next_i, next_j)\n        return ans\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        ans = 0\n        for i, l in enumerate(grid):\n            for j, n in enumerate(l):\n                ans = max(self.dfs(grid,i,j), ans)\n        return ans\n```\n# 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(nxm)<br/>\n空间复杂度：O(nxm)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497045503","body":"# 思路：多远bfs\n# 代码：python\n```\nclass Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n\n        # 将所有陆地的位置入队\n        q = deque()\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    q.append((i, j))\n\n        if len(q) == 0 or len(q) == n * m:\n            # 特判：如果地图上没有陆地或者所有位置都是陆地，则返回 -1\n            return -1\n\n        ans = -1\n        while q:\n            # 多源 BFS，从多个起点开始搜索\n            size = len(q)\n            for i in range(size):\n                x, y = q.popleft()\n\n                # 对于每个起点，向四个方向扩展\n                for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    nx, ny = x + dx, y + dy\n\n                    # 判断扩展出的新位置是否越界\n                    if nx < 0 or nx >= n or ny < 0 or ny >= m:\n                        continue\n\n                    # 判断扩展出的新位置是否为陆地或者已经访问过\n                    if grid[nx][ny] == 1 or grid[nx][ny] == 2:\n                        continue\n\n                    # 标记当前位置已经访问过，并将其入队\n                    grid[nx][ny] = 2\n                    q.append((nx, ny))\n\n            # 每搜索一层，位置加 1\n            ans += 1\n\n        # 返回位置的最大值即为所求\n        return ans\n```\n# 复杂度分析：\n\"\"\"<br/>\n时间复杂度：o(N*M)<br/>\n空间复杂度：O（N*M）<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498542637","body":"### 思路：bfs，记录遍历过的信息\n### 代码：python\n```\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        boxes = set(initialBoxes)\n        q = [i for i in boxes if status[i]]\n        for i in q:\n            for j in containedBoxes[i]:\n                boxes.add(j)\n                if status[j]:\n                    q.append(j)\n            for j in keys[i]:\n                if status[j] == 0 and j in boxes:\n                    q.append(j)\n                status[j] = 1\n        return sum(candies[i] for i in q)\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n)<br/>\n空间复杂度：O(n)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1499954351","body":"### 思路：哈希表+dfs\n### 代码：python\n```\nclass solution:\n    def top_view(root):\n        if not root:\n            return []\n        map = {}\n\n        def dfs(node, row, col, map):\n            if not node:\n                return\n            if col not in map:\n                map[col] = [node.val, row]\n            else:\n                if row < map[col][1]:\n                    map[col] = [node.val, row]\n\n            dfs(node.left, row+1, col-1, map)\n            dfs(node.right, row+1, col-1, map)\n\n        dfs(root, 0,0,map)\n        sorted_keys = sorted(map.key())\n\n        return [map[key][0] for key in sorted_keys]\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n)<br/>\n空间复杂度：O(n)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500861048","body":"### 思路：动态规划，迭代计算没一层需要使用的步数\n### 代码：python\n```\nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        pre = cur = 0\n        for i in range(2, len(cost)+1):\n            nxt = min(cur + cost[i - 1], pre + cost[i - 2])\n            pre, cur = cur, nxt\n        \n        return cur\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n)<br/>\n空间复杂度：O(1)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501127288","body":"### 思路：动态规划\n### 代码：python\n```\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        pre = cur = 0\n        for i in nums:\n            pre, cur = cur, max(cur, pre+i)\n        return cur\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n)<br/>\n空间复杂度：O(1)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501437156","body":"### 思路：动态规划，在进行数组大小比较的同时，进行计数操作，然后一遍遍的更新长度\n### 代码：python\n```\n\nclass Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_len = 0\n        ans = 0\n        dp = [0] * n\n        cnt = [0] * n\n\n        for i, x in enumerate(nums):\n            dp[i] = 1\n            cnt[i] = 1\n\n            for j in range(i):\n                if x > nums[j]:\n                    if dp[j] + 1 > dp[i]:\n                        dp[i] = dp[j] + 1\n                        cnt[i] = cnt[j]\n                    elif dp[j]+1 == dp[i]:\n                        cnt[i] += cnt[j]\n            if dp[i] > max_len:\n                max_len = dp[i]\n                ans = cnt[i]\n            elif dp[i] == max_len:\n                ans += cnt[i]\n        return ans\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n^2)<br/>\n空间复杂度：O(n)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1502837911","body":"### 思路：动态规划，顺序不需要连续，两个字符串分别做横坐标和纵坐标\n### 代码：python\n```\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        m, n = len(text1), len(text2)\n        dp = [[0]*(n+1) for _ in range(m+1)]\n\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if text1[i-1] == text2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]+1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        return dp[m][n]\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n*m)<br/>\n空间复杂度：O(mn)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1504677001","body":"### 思路：动态规划 dp[i][j] = dp[i-1][j] + dp[i][j-1]\n### 代码：python\n```\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[1]*n] + [[1]+[0]*(n-1) for _ in range(m-1)]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[m-1][n-1]\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(nm)<br/>\n空间复杂度：O(nm)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506485301","body":"### 思路：动态规划，只考虑当前步数，由前面的累计，dp[k][i][j] = 累加dp[k-1][ni][nj]\n### 代码：pthon\n```\nclass Solution:\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n        dp = [[[0] * n for _ in range(n)] for _ in range(k+1)]\n        for step in range(k+1):\n            for i in range(n):\n                for j in range(n):\n                    if step == 0:\n                        dp[step][i][j] = 1\n                    else:\n                        for di, dj in ((-2,1),(-2,-1),(2,1),(2,-1),(1,2),(1,-2),(-1,2),(-1,-2)):\n                            ni,nj = i+di,j+dj\n                            if 0 <= ni < n and 0 <= nj < n:\n                                dp[step][i][j] += dp[step-1][ni][nj]/8\n        return dp[k][row][column]\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(knn)<br/>\n空间复杂度：O(knn)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1507972061","body":"### 思路：动态规划，对于记录且累加的问题，有限长度，使用二进制存储结果，递归进行遍历\n### 代码：python\n```\n\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        if maxChoosableInteger >= desiredTotal:\n            return True\n        if maxChoosableInteger*(maxChoosableInteger+1)/2 < desiredTotal:\n            return False\n        visited = [0] * (1<<21)\n\n        def dfs(state, sum):\n            if visited[state] == 1:\n                return True\n            if visited[state] == 2:\n                return False\n            for x in range(1, maxChoosableInteger+1):\n                if (1<<x) & state:\n                    continue\n                if sum + x >= desiredTotal:\n                    visited[state] = 1\n                    return True\n                if not dfs((1<<x) | state, sum + x):\n                    visited[state]=1\n                    return True\n            visited[state] = 2\n            return False\n        return dfs(0,0)\n\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(m*2^m)<br/>\n空间复杂度：O(2^m)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509870603","body":"### 思路：动态规划\n### 代码：python\n```\nclass Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        n = len(nums)\n        if n < 2:\n            return False\n        total = sum(nums)\n        if total % 2 != 0:\n            return False\n        \n        target = total // 2\n        dp = [True] + [False] * target\n        for i, num in enumerate(nums):\n            for j in range(target, num - 1, -1):\n                dp[j] |= dp[j - num]\n        return dp[target]\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n*target)<br/>\n空间复杂度：O(target)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510075216","body":"### 思路：动态规划，滚动数组\n### 代码：python\n```\nclass Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        t = sum(nums) + target\n        if t % 2 or t <0:\n            return 0\n        pos = t // 2\n\n        dp = [1] + [0] * pos\n\n        for i in nums:\n            for j in range(pos, i - 1, -1):\n                dp[j] += dp[j - i]\n        return dp[pos]\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n*pos)<br/>\n空间复杂度：O(pos)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1510795720","body":"### 思路：动态规划， 状态转移F(s) = min(c in coins)(F(s-c)) + 1\n### 代码：python\n```\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0] + [float('inf')] * amount\n\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] = min(dp[x], dp[x-coin]+1)\n        return dp[amount] if dp[amount] != float('inf') else -1\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(amount*n)<br/>\n空间复杂度：O(amount)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1512477794","body":"### 思路：动态规划\n### 代码：python\n```\n\nclass Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [1] + [0] * amount\n\n        for coin in coins:\n            for i in range(coin, amount+1):\n                dp[i] += dp[i-coin]\n        \n        return dp[amount]\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(amount*len(coins))<br/>\n空间复杂度：O(amount)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514289108","body":"### 思路：贪心\n### 代码：python\n```\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g = sorted(g)\n        s = sorted(s)\n        g_len = len(g)\n        i = 0\n        count = 0\n        for j, x in enumerate(s):\n            if x >= g[i]:\n                count += 1\n                i += 1\n            if i == g_len:\n                break\n        return count\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(mlogm+nlogn)<br/>\n空间复杂度：O(logm+logn)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1515750236","body":"### 思路：贪心算法\n### 代码：python\n```\nclass Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        if not intervals:\n            return 0\n\n        intervals.sort(key=lambda x: x[1])\n        n = len(intervals)\n        right = intervals[0][1]\n        ans = 1\n\n        for i in range(1, n):\n            if intervals[i][0] >= right:\n                right = intervals[i][1]\n                ans += 1\n        \n        return n - ans\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(nlogn)<br/>\n空间复杂度：O(logn)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517233464","body":"### 思路：贪心算法\n### 代码：python\n```\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        n, right = len(nums), 0\n        for i in range(n):\n            if i <= right:\n                right = max(right, i + nums[i])\n                if right >= n-1:\n                    return True\n        return False\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n)<br/>\n空间复杂度：O(1)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518686669","body":"### 思路：动态规划\n### 代码：python\n```\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        C = 1\n        for i in range(0, n):\n            C = C * 2*(2*i+1)/(i+2)\n        return int(C)\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：o(n)<br/>\n空间复杂度：O(1)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1518954440","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\n### 思路：分治，归并\n### 代码：python\n```\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        return self.merge(lists, 0, len(lists)-1)\n    \n    def merge(self, lists, left, right):\n        if left == right:\n            return lists[left]\n        \n        if left > right:\n            return None\n        \n        mid = left + (right - left)//2\n        return self.mergeTwoLists(self.merge(lists, left, mid), self.merge(lists, mid+1, right))\n    \n    def mergeTwoLists(self, a, b):\n        if not a or not b:\n            return a if a else b\n        head = ListNode(0)\n        tail = head\n        aPtr = a\n        bPtr = b\n        while aPtr and bPtr:\n            if aPtr.val < bPtr.val:\n                tail.next = aPtr\n                aPtr = aPtr.next\n            else:\n                tail.next = bPtr\n                bPtr = bPtr.next\n            tail = tail.next\n\n        tail.next = aPtr if aPtr else bPtr\n        return head.next\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(knlogk)<br/>\n空间复杂度: O(logk)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1519538261","body":"### 思路：分治算法，分列奇偶列表\n### 代码：python\n```\nclass Solution:\n    def beautifulArray(self, n: int) -> List[int]:\n        memo = {1: [1]}\n\n        def f(N):\n            if N not in memo:\n                odds = f((N+1)//2)\n                evens = f(N//2)\n                memo[N] = [2*x-1 for x in odds] + [2*x for x in evens]\n            return memo[N]\n\n        return f(n)\n```\n### 复杂度分析\n\"\"\"<br/>\n时间复杂度：O(nlogn)<br/>\n空间复杂度：O(nlogn)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521188000","body":"### 思路：异或和\n### 代码：python\n```\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        xorsum = 0\n        for num in nums:\n            xorsum ^= num\n        \n        lsb = xorsum & (-xorsum)\n        type1 = type2 = 0\n        for num in nums:\n            if num & lsb:\n                type1 ^= num\n            else:\n                type2 ^= num\n        return [type1, type2]\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n)<br/>\n空间复杂度：O(1)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1522842247","body":"### 思路：位运算\n### 代码：python\n```\n\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        size = len(nums)\n        n = 1 << size\n        res = []\n        for i in range(n):\n            cur = []\n            for j in range(size):\n                if i >> j & 1:\n                    cur.append(nums[j])\n            res.append(cur)\n        return res\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n*size)<br/>\n空间复杂度：O(n)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1524844097","body":"### 思路：字典树\n### 代码：python\n```\nclass Trie:\n\n    def __init__(self):\n        self.children = [None] * 26\n        self.isEnd = False\n\n    def searchPrefix(self, prefix: str) -> \"Trie\":\n        node = self\n        for ch in prefix:\n            ch = ord(ch) - ord(\"a\")\n            if not node.children[ch]:\n                return None\n            node = node.children[ch]\n        return node\n\n    def insert(self, word: str) -> None:\n        node = self\n        for ch in word:\n            ch = ord(ch) - ord(\"a\")\n            if not node.children[ch]:\n                node.children[ch] = Trie()\n            node = node.children[ch]\n        node.isEnd = True\n\n    def search(self, word: str) -> bool:\n        node = self.searchPrefix(word)\n        return node is not None and node.isEnd\n\n    def startsWith(self, prefix: str) -> bool:\n        return self.searchPrefix(prefix) is not None\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(len(word))<br/>\n空间复杂度：O(∣T∣⋅Σ)<br/>\n\"\"\"\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1527046195","body":"### 思路：前缀树，dfs\n### 代码：python\n```\nclass TrieNode:\n    def __init__(self):\n        self.val = 0\n        self.next = [None for _ in range(26)]\n\nclass MapSum:\n\n    def __init__(self):\n        self.root = TrieNode()\n        self.map = {}\n\n    def insert(self, key: str, val: int) -> None:\n        delta = val\n        if key in self.map:\n            delta -= self.map[key]\n        self.map[key] = val\n        node = self.root\n        for c in key:\n            if node.next[ord(c) - ord('a')] is None:\n                node.next[ord(c) - ord('a')] = TrieNode()\n            node = node.next[ord(c) - ord('a')]\n            node.val += delta\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for c in prefix:\n            if node.next[ord(c) - ord('a')] is None:\n                return 0\n            node = node.next[ord(c) - ord('a')]\n        return node.val\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(N)<br/>\n空间复杂度：O(c*len(map)*len(key))<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528661451","body":"### 思路：多次搜索，前缀树\n### 代码：python\n```\nclass Trie:\n    def __init__(self, words):\n        self.d = {}\n        for word in words:\n            t = self.d\n            for w in word:\n                if w not in t:\n                    t[w] = {}\n                t = t[w]\n            t['end'] = word\n    def search(self,s):\n        t = self.d\n        res = []\n        for w in s:\n            if w not in t:\n                break\n            t = t[w]\n            if 'end' in t:\n                res.append(t['end'])\n        return res\n\nclass Solution:\n    def multiSearch(self, big: str, smalls: List[str]) -> List[List[int]]:\n        trie = Trie(smalls)\n        hit = collections.defaultdict(list)\n\n        for i in range(len(big)):\n            matchs = trie.search(big[i:])\n            for word in matchs:\n                hit[word].append(i)\n\n        res = []\n        for word in smalls:\n            res.append(hit[word])\n        return res\n\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(len(big)*len(small))<br/>\n空间复杂度：O(len(small)*max(len(smalls[i])))<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1529011416","body":"### 思路：并查集\n### 代码：python\n```\nclass UnionFind:\n    def __init__(self):\n        self.father = {}\n        self.num_of_sets = 0\n    \n    def find(self,x):\n        root = x\n        while self.father[root] != None:\n            root = self.father[root]\n        \n        while x != root:\n            original_father = self.father[x]\n            self.father[x] = root\n            x = original_father\n        return root\n    \n    def merge(self, x, y):\n        root_x, root_y = self.find(x), self.find(y)\n\n        if root_x != root_y:\n            self.father[root_x] = root_y\n            self.num_of_sets -= 1\n    \n    def add(self, x):\n        if x not in self.father:\n            self.father[x] = None\n            self.num_of_sets += 1\n\nclass Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        uf = UnionFind()\n        for i in range(len(isConnected)):\n            uf.add(i)\n            for j in range(i):\n                if isConnected[i][j]:\n                    uf.merge(i,j)\n        return uf.num_of_sets\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n^2logn)<br/>\n空间复杂度：O(n)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1529308549","body":"### 思路：并查集\n### 代码：python\n```\nclass UnionFind:\n    def __init__(self, n):\n        self.root = [i for i in range(n)]\n        self.size = [1]*n\n        self.part = n\n\n    def find(self, x):\n        if x != self.root[x]:\n            # 在查询的时候合并到顺带直接根节点\n            root_x = self.find(self.root[x])\n            self.root[x] = root_x\n            return root_x\n        return x\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return\n        if self.size[root_x] >= self.size[root_y]:\n            root_x, root_y = root_y, root_x\n        self.root[root_x] = root_y\n        self.size[root_y] += self.size[root_x]\n        # 将非根节点的秩赋0\n        self.size[root_x] = 0\n        self.part -= 1\n        return\n\n    def is_connected(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def get_root_part(self):\n        # 获取每个根节点对应的组\n        part = defaultdict(list)\n        n = len(self.root)\n        for i in range(n):\n            part[self.find(i)].append(i)\n        return part\n\n    def get_root_size(self):\n        # 获取每个根节点对应的组大小\n        size = defaultdict(int)\n        n = len(self.root)\n        for i in range(n):\n            size[self.find(i)] = self.size[self.find(i)]\n        return size\n\n\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        n = len(graph)\n        uf = UnionFind(n)\n        for i in range(n):\n            for j in range(i+1, n):\n                if graph[i][j]:\n                    uf.union(i, j)\n        add = -1\n        ans = -1\n        virus = set(initial)\n        part = uf.get_root_part()\n        for k in part:\n            cur = 0\n            node = -1\n            for i in part[k]:\n                if i in virus:\n                    cur += 1\n                    node = i\n            if cur == 1:\n                if len(part[k]) > add:\n                    add = len(part[k])\n                    ans = node\n                elif len(part[k]) == add and node < ans:\n                    ans = node\n        return ans if ans != -1 else min(initial)\n\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n^2)<br/>\n空间复杂度：O(n)<br/>\n\"\"\"\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1531268754","body":"```\nclass UnionFind:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.n = n\n        # 当前连通分量数目\n        self.setCount = n\n    \n    def findset(self, x: int) -> int:\n        if self.parent[x] == x:\n            return x\n        self.parent[x] = self.findset(self.parent[x])\n        return self.parent[x]\n    \n    def unite(self, x: int, y: int) -> bool:\n        x, y = self.findset(x), self.findset(y)\n        if x == y:\n            return False\n        if self.size[x] < self.size[y]:\n            x, y = y, x\n        self.parent[y] = x\n        self.size[x] += self.size[y]\n        self.setCount -= 1\n        return True\n    \n    def connected(self, x: int, y: int) -> bool:\n        x, y = self.findset(x), self.findset(y)\n        return x == y\n\nclass Solution:\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        if len(connections) < n - 1:\n            return -1\n        \n        uf = UnionFind(n)\n        for x, y in connections:\n            uf.unite(x, y)\n        \n        return uf.setCount - 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1533232108","body":"### 思路：递归\n### 代码：python\n```\nclass Solution:\n    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if root is None:\n            return None\n        root.left = self.pruneTree(root.left)\n        root.right = self.pruneTree(root.right)\n        if root.left is None and root.right is None and root.val == 0:\n            return None\n        return root\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(n)<br/>\n空间复杂度：O(n)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1534268723","body":"### 思路：回溯，剪枝\n### 代码：python\n```\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        def dfs(candidates, begin, size, path, res, target):\n            if target == 0:\n                res.append(path)\n                return\n            \n            for index in range(begin, size):\n                residue = target - candidates[index]\n                if residue < 0:\n                    break\n                \n                dfs(candidates, index, size, path + [candidates[index]], res, residue)\n        \n        size = len(candidates)\n        if size == 0:\n            return []\n        candidates.sort()\n        path = []\n        res = []\n        dfs(candidates, 0, size, path, res, target)\n        return res\n```\n### 复杂度分析：\n\"\"\"<br/>\n时间复杂度：O(sum(len(res)))<br/>\n空间复杂度：O(target)<br/>\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1535788948","body":"```\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        def dfs(begin, path, residue):\n            if residue == 0:\n                res.append(path[:])\n                return\n\n            for index in range(begin, size):\n                if candidates[index] > residue:\n                    break\n\n                if index > begin and candidates[index - 1] == candidates[index]:\n                    continue\n\n                path.append(candidates[index])\n                dfs(index + 1, path, residue - candidates[index])\n                path.pop()\n\n        size = len(candidates)\n        if size == 0:\n            return []\n\n        candidates.sort()\n        res = []\n        dfs(0, [], target)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1537149766","body":"```\nclass Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        self.res = []\n        check = [0 for i in range(len(nums))]\n        \n        self.backtrack([], nums, check)\n        return self.res\n        \n    def backtrack(self, sol, nums, check):\n        if len(sol) == len(nums):\n            self.res.append(sol)\n            return\n        \n        for i in range(len(nums)):\n            if check[i] == 1:\n                continue\n            if i > 0 and nums[i] == nums[i-1] and check[i-1] == 0:\n                continue\n            check[i] = 1\n            self.backtrack(sol+[nums[i]], nums, check)\n            check[i] = 0\n```","onTime":true},null,null,null,null,null,null,null,null,null],"chao-cc":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429926937","body":"###思路\r\n\r\n最近才接触算法，很懵逼看了leetcode题解，先照着做下学习下思路\r\n\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n   和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n   当前位 = 和 % 10;\r\n   进位 = 和 / 10;\r\n\r\n判断是否有进位\r\n\r\n\r\n\r\n###代码\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int numL = num.length;\r\n        List<Integer> res = new ArrayList<>();\r\n        int i = numL -1, sum = 0 , carry = 0;\r\n        while(i>=0||k!=0){\r\n            int x = i>=0? num[i]:0;\r\n            int y = k!=0? k%10:0;\r\n            sum = x + y + carry;\r\n            carry  = sum/10;\r\n            k = k/10;\r\n            i--;\r\n            res.add(0,sum%10);\r\n        }\r\n        if(carry !=0){\r\n            res.add(0,carry);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n###复杂度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431581701","body":"###思路\n\n看解题思路，左右个遍历一次，分别记录距离，然后对比大小\n\n###代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int count = s.length();\n        int[] ans = new int[n];\n        Arrays.fill(ans, count + 1);\n        for (int i = 0, j = -1; i < count; i++) {\n            if (s.charAt(i) == c) j = i;\n            if (j != -1) ans[i] = i - j;\n        }\n        for (int i = count - 1, j = -1; i >= 0; i--) {\n            if (s.charAt(i) == c) j = i;\n            if (j != -1) ans[i] = Math.min(ans[i], j - i);\n        }\n        return ans;\n    }\n}\n```\n\n###复杂度分析\n\n时间复杂度 ：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433280746","body":"### 思路\n\n看了官方解题， 知道了 push pop的原理，希望能进步一点点，用数组模拟栈 变量top来记录当前栈顶的位置\n\n### 代码\n\n````java\nclass CustomStack{\n  int[] stack;\n  int top;\n  public CustomStack(int maxSize){\n    stack = new int[maxSize];\n    top = -1;\n   \n  }\n  public void push(int x){\n    if(top != stack.length -1){\n      top++;\n      stack[top] =x;\n    }\n\t}\n  public int pop(){\n    if(top == -1){\n      return top;\n    }\n    --top;\n    return stack[top+1];\n  }\n  public void increment(int k, int val){\n\t\tint limit = Math.min(k, top + 1);\n    for(int i=0; i < limit; ++i){\n\t\t\tstack[i] += val;\n    }\n  }\n  \n}\n````\n\n### 复杂度\n\n- 时间复杂度：incremet 方法里面循环操作 O(k)\n- 空间复杂度：O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinjin680":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429932323","body":"## 思路\n\n- 直接把K加到A的每一位中，再做取余处理得到和的数组形式对应位置的数；加了K之后的A[i]除以10得到新的K\n- 若加了该数字加了K之后，位数变多了\n  - 两数位数相同，和多了一位\n  - K位数比该数多\n- 在数组前面插入0，继续循环直至K为0\n\n## 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        i = len(A) - 1\n        while K:\n            A[i] += K\n            K = A[i] // 10\n            A[i] = A[i] % 10\n            #处理加了该数字加了K之后，位数变多了的情况（两数位数相同，和多了一位；K位数比该数多）\n            i -= 1\n            if i < 0 and K:\n                A.insert(0,0)\n                i = 0\n        return A\n```\n\n ## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431556364","body":"## 思路\n\n- 思路1：从左到右遍历一遍，得到离左边C的距离；再从右到左遍历一遍，得到离右边C的距离；取二者之间较小的那一个\n- 思路2：双指针\n  1. 未遇到C时，右指针右移；\n  2. 当右指针遇到C时，左指针的值即为与右指针之间的距离和当前值的最小项\n  3. 当右指针遇到C后，右指针右移，且右指针所在值为前一值加1\n\n## 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        l = r = 0\n        n = len(s)\n        res = [n] * n\n        flag = False  # 判断是否遇到过C\n        while r <= n - 1:\n            if s[r] == c: # 遇到C了\n                res[r] = 0 # 遇到c，距离为0\n                while l <= r: # 若l<=r，更新从左指针到r-1位置\n                    res[l] = min(res[l], r - l) # r - left  # 取两者距离最小值\n                    l += 1\n                r += 1\n                flag = True\n            else:\n                if flag:\n                    res[r] = res[r-1] + 1  # 算的是与左边C的距离\n                r += 1 # 没有遇到过c，右指针往右移\n        return res\n\n\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cruiseyugh":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429943458","body":"## 思路\n方法1.  将整个加数 k 加入从数组的最低位加起来，然后分别取最低位为num的结果，以及sum//10 为下一位的累加值\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num) -1\n        while k:\n            num[n] += k\n            #k,num[n] = num[n]//10, num[n]%10\n            num[n],k = num[n]%10, num[n]//10\n            n -= 1\n            if n<0 and k:\n                num.insert(0,0)\n                n = 0\n        return num\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431455081","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = [ len(s)+1 for _ in range(len(s))]\n        flag_index =-1\n        for index in range(len(s)):\n            \n            if s[index]==c:\n                ans[index] = 0\n                flag_index = index\n            elif flag_index !=-1:\n                ans[index] = index -flag_index\n        #print(ans)\n        flag_index =-1\n        for index in range(len(s)-1,-1,-1):\n            if s[index]==c:\n                ans[index] = 0\n                flag_index = index\n            elif flag_index !=-1:\n                ans[index] = min(flag_index-index ,ans[index] )\n        return ans\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(2n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433229854","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if (self.top+1) ==len(self.stk):\r\n            return \r\n        self.top += 1\r\n        self.stk[self.top] = x\r\n        #print(self.stk)\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -=1 \r\n        #print(self.stk)\r\n        return self.stk[self.top+1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        k = min(self.top+1,k)\r\n        for index in range(k):\r\n            self.stk[index] +=val\r\n        #print(self.stk)\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(k)$\r\n- 空间复杂度：$O(maxsize)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1435994659","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in range(len(s)):\n            if s[i] != \"]\":\n                stack.append(s[i])\n            else:\n                cur = \"\"\n                while stack[-1] != \"[\":\n                    cur = stack.pop() + cur\n                stack.pop()\n\n                k = \"\"\n                while stack and stack[-1].isdigit():\n                    k = stack.pop() + k\n                stack.append(cur * int(k))\n        return \"\".join(stack)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435994448","body":"class MyQueue:\n\n    def __init__(self):\n        self.stack = []\n        self.len = 0\n\n    def push(self, x: int) -> None:\n        # O(1)\n        self.stack.append(x)\n        self.len += 1\n\n    def pop(self) -> int:\n        # O(N) 将 stack 清空直至剩下最后一个，即 queue pop\n        # 需要将 len-1，代表 pop\n        tmp_stack = copy(self.stack)\n        tmp_len = self.len\n        while tmp_len > 1:\n            tmp_stack.pop()\n            tmp_len -= 1\n        self.len -= 1 # reduse len when pop\n        return tmp_stack.pop()\n\n    def peek(self) -> int:\n        # O(N) 将 stack 清空直至剩下最后一个，即 queue peek\n        tmp_stack = copy(self.stack)\n        tmp_len = self.len\n        while tmp_len > 1:\n            tmp_stack.pop()\n            tmp_len -= 1\n        return tmp_stack.pop()\n\n    def empty(self) -> bool:\n        # O(1)\n        return self.len == 0","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435994135","body":"'''\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        count_a = collections.defaultdict(int)\n        count_b = collections.defaultdict(int)\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            count_a[a] += 1\n            count_b[b] += 1\n            if count_a == count_b: ans += 1\n\n        return ans\n'''","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437024878","body":"## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head:\n            slow , fast = head ,head\n            tmp = head\n            leng = 0\n            while tmp:\n                tmp = tmp.next\n                leng +=1\n            k = k%leng\n            while k:\n                fast = fast.next\n                k -=1\n            while fast.next:\n                slow = slow.next\n                fast = fast.next\n            if slow.next:\n                tmp = slow.next\n            else:\n                return head\n            slow.next = None\n            fast.next = head\n            return tmp\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438717630","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        pre = ListNode(0)\n        pre.next =head\n        if not head or head.next ==None:\n            return head\n        pre_cu,cur,cur_next = pre,head,head.next\n        while cur and cur_next:\n            pre_cu.next = cur_next\n            cur.next = cur_next.next\n            cur_next.next =cur\n            print(pre)\n            pre_cu = cur\n            cur =pre_cu.next\n            if cur==None:\n                break\n            cur_next = cur.next\n        return pre.next\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440219381","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  利用快慢指针找出链表中点，然后将左右分别进行递归操作，构成搜索二叉树。\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def mediu_node(left,right):\r\n            slow = left\r\n            fast = left\r\n            while fast!=right and fast.next!=right:\r\n                slow = slow.next\r\n                fast = fast.next.next\r\n            return slow\r\n        def build_tree(left,right):\r\n            if left == right:\r\n                return None\r\n            med = mediu_node(left,right)\r\n            root = TreeNode(med.val)\r\n            root.left = build_tree(left,med)\r\n            root.right = build_tree(med.next,right)\r\n            return root\r\n        return build_tree(head,None)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441952040","body":"```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        A, B = [], []\r\n        while headA:\r\n            A.append(headA)\r\n            headA = headA.next\r\n        while headB:\r\n            B.append(headB)\r\n            headB = headB.next\r\n        \r\n        ans = None\r\n        for i in range(-1, -min(len(A)+1, len(B)+1), -1):\r\n            if A[i]==B[i]:\r\n                ans = A[i]        \r\n        return ans\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445377495","body":"`from queue import Queue\r\nclass Solution(object):\r\n    def maxDepth(self, root):\r\n        if not root: return 0\r\n        queue = Queue()\r\n        queue.put(root)\r\n        height = 0\r\n\r\n        while not queue.empty():\r\n            currentSize = queue.qsize()\r\n            for i in range(currentSize):\r\n                node = queue.get()\r\n                if node.left: queue.put(node.left)\r\n                if node.right: queue.put(node.right)\r\n            height += 1\r\n            \r\n        return height\r\n`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446372810","body":"\n## 关键点\n\n-  BFS ,递归的逻辑\n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val !=q.val:\n            return False\n        return self.isSameTree(p.right,q.right) and self.isSameTree(p.left,q.left)\n        \n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(min(n,m))$\n- 空间复杂度：$O(min(n,m))$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448193646","body":"## 思路\n\n## 关键点\n\n-  dfs\n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        #dfs\n        def dfs(root,presum):\n            if root is None:\n                return 0\n            presum = presum*10 +root.val\n            if root.left is None and root.right is None:\n                return presum\n            return dfs(root.left,presum) + dfs(root.right,presum)\n        return dfs(root,0)\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450227543","body":"## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        # dfs\n        curVal = curHeight = 0\n        def dfs(node,deep_num):\n            if node is None :\n                return \n            dfs(node.left,deep_num+1)\n            dfs(node.right,deep_num+1)\n            nonlocal curVal, curHeight\n            if  deep_num+1>curHeight:\n                curVal = node.val\n                curHeight = deep_num+1\n        dfs(root,0)\n        return curVal\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1452054722","body":"## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return 'None'\n        return str(root.val)+ ',' + self.serialize(root.left)+ ',' + self.serialize(root.right)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        \n        dataList = data.split(',')\n        print(dataList)\n        def dfs():\n            val = dataList.pop(0)\n            if val == 'None':\n                return None\n            root = TreeNode(val)\n            root.left = dfs()\n            root.right = dfs()\n            return root\n        \n        return dfs()\n        \n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454734531","body":"## 思路\n\n## 关键点\n\n-  hash\n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hash ={}\n        for index in range(len(nums)):\n            diff = target-nums[index]\n            if nums[index] in hash:\n                return [index,hash[nums[index]]]\n            else:\n                hash[diff]=index\n            #print(hash)\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1458314174","body":"## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if not s:return 0\n        left = 0\n        lookup = set()\n        n = len(s)\n        max_len = 0\n        cur_len = 0\n        for i in range(n):\n            cur_len += 1\n            while s[i] in lookup:\n                lookup.remove(s[left])\n                left += 1\n                cur_len -= 1\n            if cur_len > max_len:max_len = cur_len\n            lookup.add(s[i])\n        return max_len\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462261504","body":"class Solution:\n    def minSubarray(self, nums, k):\n        total = sum(nums)\n        mod = total % k\n\n        ans = len(nums)\n        total = 0\n        dic = {0: -1}\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % k\n            target = (cur - mod + k) % k\n            if target in dic:\n                ans = min(ans, j - dic[target])\n            dic[cur] = j\n\n        if ans == len(nums):\n            return -1\n        return ans","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465115268","body":"## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        l,r = 0,n-1\n\n        while l<=r:\n            mid = (l+r)//2\n            if nums[mid]==target:\n                return mid\n            elif nums[mid]>target:\n                r = mid-1\n            else:\n                l=mid+1\n        return l\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(logn)$\n- 空间复杂度：$O(1)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468263324","body":"class Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        inDegrees = Counter(y for _, y in trust)\n        outDegrees = Counter(x for x, _ in trust)\n        return next((i for i in range(1, n + 1) if inDegrees[i] == n - 1 and outDegrees[i] == 0), -1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1470169715","body":"## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        p = [i for i in range(0, 2 * n + 10)]\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n        def union(a, b):\n            p[find(a)] = p[find(b)]\n        def query(a, b):\n            return find(a) == find(b)\n        for info in ds:\n            a, b = info[0], info[1]\n            if query(a, b):\n                return False\n            else:\n                union(a, b + n)\n                union(b, a + n)\n        return True\n  \n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473936099","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        start=[0,0]\n        for move in moves:\n            if move == \"R\":\n                start[0]+=1\n            elif move == \"L\":\n                start[0]-=1\n            elif move == \"U\":\n                start[1]+=1\n            elif move == \"D\":\n                start[1]-=1\n    \n        return start==[0,0]\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1481171064","body":"## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\n# The isBadVersion API is already defined for you.\n# def isBadVersion(version: int) -> bool:\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        l,r=1,n\n        while l<n:\n            mid = (l+n)//2\n            if isBadVersion(mid):\n                n = mid\n            else:\n                l = mid+1\n        return l\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(logn)$\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486972742","body":"\"\"\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        current = 0\n        result = 0\n        for pos in range(k):\n            if s[pos] in \"aeiou\":\n                current += 1\n        result = current\n        for pos in range(1, len(s) - k + 1):\n            if s[pos - 1] in \"aeiou\":\n                current -= 1\n            if s[pos + k - 1] in \"aeiou\":\n                current += 1\n            result = max(result, current)\n        return result\n\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488661056","body":"# 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass Solution:\n     def new21Game(self, N: int, K: int, W: int) -> float:\n        # 滑动窗口优化（固定窗口大小为 W 的滑动窗口）\n        dp = [0] * (K + W)\n        win_sum = 0\n        for i in range(K, K + W):\n            if i <= N:\n                dp[i] = 1\n            win_sum += dp[i]\n\n        for i in range(K - 1, -1, -1):\n            dp[i] = win_sum / W\n            win_sum += dp[i] - dp[i + W]\n        return dp[0]\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494298654","body":"class Solution:\n    def totalNQueens(self, n: int) -> int:\n        board = [[0] * n for _ in range(n)]\n        res = 0\n\n        def helper(level):\n            for i in range(n):\n                if judge(level, i):\n                    if level == n-1:\n                        nonlocal res\n                        res += 1\n                        return\n                    if level < n-1:\n                        board[level][i] = 1\n                        helper(level + 1)\n                        board[level][i] = 0\n            return\n\n        def judge(level, index):\n\n            # zong            \n            for i in range(n):\n                if board[i][index] == 1:\n                    return False\n            # xie            \n            mi = min(level, index)\n            startlevel = level - mi\n            startindex = index - mi\n            while startlevel < n and startindex < n:\n                if board[startlevel][startindex] == 1:\n                    return False\n                    \n                startlevel += 1\n                startindex += 1\n            ma = min(level, n - index-1)\n            startlevel = level - ma\n            startindex = index + ma\n            while startlevel < n and startindex >= 0:\n                if board[startlevel][startindex] == 1:\n                    return False\n                    \n                startlevel += 1\n                startindex -= 1\n            return True\n\n        helper(0)\n        return res","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1521809256","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\r\n        n = len(cost)+1\r\n        dp = [0]*n\r\n        dp[0]=0\r\n        for i in range(2,n):\r\n            dp[i]=min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])\r\n        return dp[-1]\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1521811219","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def rob(self, nums: List[int]) -> int:\r\n        #dp[i]=max(dp[i+2]+nums[i],dp[i+1])\r\n        if not nums:\r\n            return 0\r\n        dp =[0 for _ in range(len(nums)+1)]\r\n        dp[-2] = nums[-1]\r\n        for i in range(len(nums)-2,-1,-1):\r\n            dp[i]=max(dp[i+2]+nums[i],dp[i+1])\r\n        return dp[0]\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501568118","body":"class Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp, cnt, max_val = [1]*n, [1]*n, 1\n        for i in range(1,n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    if dp[j] + 1 > dp[i]:\n                        dp[i], cnt[i] = 1 + dp[j], cnt[j]\n                    elif dp[j] + 1 == dp[i]:\n                        cnt[i] += cnt[j]\n            max_val = max(max_val,dp[i])\n\n        return sum([j for i,j in zip(dp,cnt) if i == max_val])","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511608530","body":"'''\nclass Solution(object):\n    def coinChange(self, coins, amount):\n        dp = [amount + 1] * (amount+1)\n        dp[0] = 0\n        for i in range(1, amount+1):\n            for coin in coins:\n                if i >= coin:\n                    dp[i] = min(dp[i], dp[i-coin]+1)\n        return -1 if dp[amount] == amount + 1 else dp[amount]\n'''\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519080482","body":"## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoList(self,list_1,list_2):\n        if not list_1: return list_2\n        if not list_2: return list_1\n        if list_1.val < list_2.val :\n            list_1.next = self.mergeTwoList(list_1.next,list_2)\n            return list_1\n        else:\n            list_2.next = self.mergeTwoList(list_1,list_2.next)\n            return list_2\n    def merge(self,lists, left, right):\n        if left == right:\n            return lists[left]\n        mid = left + (right - left) // 2\n        l1 = self.merge(lists, left, mid)\n        l2 = self.merge(lists, mid+1, right)\n        return self.mergeTwoList(l1, l2)\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if not lists:\n            return\n        n = len(lists)\n        return self.merge(lists,0,n-1)\n        \n\n```\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521794992","body":"## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        xorsum = 0\n        for num in nums:\n            xorsum ^= num\n        lsb = xorsum & (-xorsum)\n        type1 = type2 = 0\n        for num in nums:\n            if num & lsb:\n                type1 ^= num\n            else:\n                type2 ^= num\n        return [type1, type2]\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"quieter2018":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429944216","body":"**思路**\r\n从低位逐个相加，进位加1，加完倒序；\r\n\r\n**代码**\r\n下述代码未考虑到 k 的位数比num多的情况，导致越界\r\n```C++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n\r\n        int len = num.size()-1;\r\n        int rem = 0;\r\n        vector<int> result;\r\n        while(len >= 0 ||k != 0){\r\n            rem = k % 10;\r\n            k = k / 10;\r\n            int sum = num[len]+rem;\r\n            if(sum >= 10){\r\n                k = k+1;\r\n                rem = sum % 10;\r\n                result.push_back(rem);\r\n            }else{\r\n                result.push_back(sum);\r\n            }\r\n            len--;\r\n        }\r\n        return {result.rbegin(), result.rend()};\r\n\r\n    }\r\n};\r\n\r\n```\r\n修改后\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n\r\n        int len = num.size()-1;\r\n        int rem = 0;\r\n        vector<int> result;\r\n        while(len >= 0 ||k != 0){\r\n            rem = k % 10;\r\n            k = k / 10;\r\n            \r\n            if(len>=0){\r\n                int sum = num[len]+rem;\r\n                if(sum >= 10){\r\n                    k = k+1;\r\n                }\r\n                 result.push_back(sum%10);\r\n            }else{\r\n                result.push_back(rem);\r\n            }\r\n            len--;\r\n        }\r\n        return {result.rbegin(), result.rend()};\r\n\r\n    }\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431231443","body":"**思路**\r\n从左往右遍历计算距离，从右往左遍历，取最小值。\r\n\r\n**代码**\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> dis(s.size());\r\n        int c_idx_1=0;\r\n        int c_idx_2=1;\r\n\r\n        for(int i = 0;i<s.size(); i++){\r\n            if(s[i]==c){\r\n                c_idx_2 = i;\r\n                dis[i]=0;\r\n                for(int j=c_idx_1; j<i;j++){\r\n                    dis[j]=abs(c_idx_2-j);\r\n                }\r\n                c_idx_1 =c_idx_2+1;\r\n            }else{\r\n                dis[i]=abs(c_idx_2-i);\r\n            }\r\n        }\r\n\r\n        c_idx_1= s.size()-1;\r\n        c_idx_2= s.size()-1;\r\n        vector<int> dis_back(s.size());\r\n\r\n        for(int i = s.size()-1;i>=0; i--){\r\n            if(s[i]==c){\r\n                c_idx_2 = i;\r\n                dis[i]=0;\r\n                for(int j=c_idx_1; j>i;j--){\r\n\r\n                    dis_back[j]=abs(c_idx_2-j);\r\n                }\r\n                c_idx_1 =c_idx_2-1;\r\n            }else{\r\n                dis_back[i]=abs(c_idx_2-i);\r\n            }\r\n        }\r\n\r\n        for(int i = 0;i<s.size(); i++){\r\n            dis[i]= min(dis_back[i],dis[i]);\r\n        }\r\n\r\n    return dis;    \r\n\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(n)\r\n\r\n- 空间复杂度：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433238056","body":"**思路**\r\n就按照题目所述进行实现即可。\r\n\r\n**代码**\r\n```C++\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stack;\r\n    int maxSize;\r\n    int top_idx = -1;\r\n\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize);\r\n        this->maxSize = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top_idx >= maxSize-1){\r\n            return;\r\n        }\r\n        top_idx++;\r\n        stack[top_idx]=x;\r\n\r\n    }\r\n    \r\n    int pop() {\r\n        if(top_idx<0){\r\n            return -1;\r\n        }\r\n        int res =  stack[top_idx];\r\n        top_idx--;\r\n        return res;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for(int i=0;i<=top_idx && i< k;i++){\r\n            stack[i]+=val;\r\n        }\r\n\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：push()、pop() 为 O(1) ;  increment操作是 O(k);\r\n- 空间复杂度:  O(n);","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435988388","body":"**思路**\r\n使用单调栈，分析可知当前值小于之前块的最大值时，则当前值为下一个分块的起点。\r\n\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> max;\r\n        int top=0;\r\n        int top_tmp =0;\r\n        if(arr.empty()){\r\n            return 0;\r\n        }\r\n        for(int i=0; i<arr.size()-1;i++){\r\n          if(i==0){\r\n              max.push(arr[i]);\r\n          }\r\n\r\n          if(arr[i+1]>=max.top()){\r\n            max.push(arr[i+1]);\r\n          }else{\r\n            top = max.top();\r\n            top_tmp = max.top();\r\n            while(arr[i+1]< top_tmp && (!max.empty() )){\r\n                if(max.size()>1){\r\n                  max.pop();\r\n                  top_tmp = max.top();\r\n                }else{\r\n                    max.pop();\r\n                }\r\n            }\r\n            max.push(top);\r\n          } \r\n        }\r\n        if(max.empty()){\r\n            return 1;\r\n        }\r\n        return max.size();\r\n\r\n    }\r\n};\r\n```\r\n**复杂度:**\r\n时间复杂度：O(n);\r\n空间复杂度：O(n);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436953794","body":"**思路：**\r\n将尾部向前数第K个元素作为头，原来的头接到原来的尾上，其实就是找倒数第k个元素。\r\n\r\n**代码：**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(head == NULL || head->next == NULL|| k == 0){\r\n            return head;\r\n        }\r\n\r\n        //计算链表长度\r\n        int length = 1;\r\n        ListNode *p = head;\r\n        while(p->next!=NULL){\r\n            length++;\r\n            p = p->next;\r\n        }\r\n\r\n        //若右移k == n*length,相当于链表不用动\r\n        k= k % length;\r\n        if(k==0){\r\n            return head;\r\n        }\r\n\r\n        //快慢指针,找到倒数k个值\r\n        ListNode *fast = head;\r\n        ListNode *slow = head;\r\n        int i = k;\r\n        while(i>0){\r\n            fast = fast->next;\r\n            i--;\r\n        }\r\n\r\n        while(fast->next!= NULL){\r\n            slow = slow->next;\r\n            fast = fast->next;\r\n        }\r\n\r\n        ListNode *new_head =  slow->next; \r\n        slow->next = NULL;\r\n        fast->next = head;\r\n\r\n        return new_head;\r\n\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析：**\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438593077","body":"**思路**\r\n利用虚拟节点，并创建 temp 表示当前到达的节点，每次需要交换 temp 后面的两个节点即可。\r\n\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        ListNode* newHead = new ListNode(0);\r\n        newHead->next = head; //指向原始链表\r\n        ListNode* temp = newHead;\r\n        while (temp->next != NULL && temp->next->next != NULL) {\r\n            ListNode* node1 = temp->next;\r\n            ListNode* node2 = temp->next->next;\r\n            temp->next = node2;//交换两个节点\r\n            node1->next = node2->next;\r\n            node2->next = node1;\r\n            temp = node1;\r\n        }\r\n        return newHead->next;\r\n    }\r\n};\r\n```\r\n**复杂度：**\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441241535","body":"**思路**\r\n当链表 headA 和 headB 都不为空时，两个链表才可能相交；两个指针 分别走 A+B 和 B+A，寻找到距尾部个数相同的节点位置，然后找交点。\r\n\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        //为空则不存在\r\n        if (headA == NULL || headB== NULL) { \r\n            return NULL;\r\n        }\r\n        //使用快慢指针，构造相同长度的两个链表\r\n        ListNode *pA = headA, *pB = headB;\r\n        while (pA != pB) { //不相等说明不相交\r\n            pA = (pA == NULL) ? headB:pA->next; \r\n            pB = (pB == NULL)?  headA:pB->next; \r\n        }\r\n\r\n        return pA;\r\n    }\r\n        \r\n};\r\n```\r\n**复杂度**\r\n时间复杂度： O(m+n) 　　m,n分别为两个链表的长度\r\n空间复杂度： O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445733128","body":"**思路**\r\n   递归；\r\n\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if( p == NULL && q == NULL)  return true; //都为空\r\n        if( p == NULL) return false; //一个为空，一个不为空\r\n        if( q == NULL) return false;\r\n        if( q->val != p->val) return false; //值不相等\r\n\r\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n \r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n空间复杂度：O(n)\r\n时间复杂度：O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455093277","body":"**思路：**\r\n先试用 hash 表存储数据出现次数，之后用 优先队列 对次数进行排序，取出最顶部的数据即可。\r\n\r\n**代码：**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        //用map对数据及其出现的次数进行存储\r\n        unordered_map<int, int> map;\r\n        for(int num : nums){\r\n            map[num]++;\r\n        }\r\n\r\n        //对map中出现的次数进行排序，使用优先队列\r\n        priority_queue<pair<int, int>> queue;\r\n        for(auto count : map){\r\n            queue.emplace(count.second, count.first); //second是次数，对次数按照大顶堆排序\r\n        }\r\n        \r\n        //获取最顶上的k个值\r\n        vector<int> result;\r\n        for(int i = 0;i < k; i++){\r\n            int top = queue.top().second; //second 是数据，first是次数\r\n            result.push_back(top);\r\n            queue.pop();\r\n        }\r\n\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析：**\r\n时间复杂度：O(nlogn)，堆排序\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455470232","body":"**思路：**\r\n     统计距离某个点的距离相等的点的个数（hash 表），然后计算排列数；\r\n\r\n**代码：**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int numberOfBoomerangs(vector<vector<int>>& points) {\r\n        int len = points.size();\r\n        int result = 0;\r\n\r\n        for(int i = 0; i < len; i++){\r\n            unordered_map<int,int> map; //哈希表\r\n            for(int j = 0;j < len;j++){\r\n                if(i==j) continue;  //同一个点\r\n                int x = points[i][0]-points[j][0];  //计算距离\r\n                int y = points[i][1]-points[j][1];\r\n                int dist = x*x + y*y;\r\n                map[dist]++; //储存到i点距离相等的个数；\r\n            }\r\n\r\n            for(auto p : map){ //距离相等的排列数\r\n                result += p.second* (p.second-1); // 排列数，n*(n-1)\r\n            }\r\n\r\n        }\r\n\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析：**\r\n时间复杂度：O(n^2)\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465538909","body":"**思路**\r\n见下述代码释义。\r\n\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\r\n        vector<int> result;\r\n        //双向队列\r\n        deque<int> dq;\r\n        for (int i = 0; i < nums.size(); ++i) {\r\n            //如果窗口长度超过了k，则将最左边的元素移除\r\n            if (!dq.empty() && dq.front() == i - k) \r\n                dq.pop_front();\r\n\r\n            //从后往前移除所有队列中小于当前元素的元素\r\n            while (!dq.empty() && nums[i] > nums[dq.back()]) \r\n                dq.pop_back();\r\n\r\n            //在队列中添加当前元素的坐标\r\n            dq.push_back(i);\r\n\r\n            //如果窗口长度已经到达了k，则在结果中插入最大值(deque最前面的元素)\r\n            if (i >= k-1) \r\n                result.push_back(nums[dq.front()]);\r\n        }\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475647230","body":"**思路**\r\n见代码注释。\r\n\r\n**代码：**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int minCharacters(string a, string b) {\r\n        //统计各个字符出现次数\r\n        vector<int> a_num(26), b_num(26);\r\n        for(char s : a){\r\n            a_num[s - 'a']++;\r\n        }\r\n        for(char s : b){\r\n            b_num[s - 'a']++;\r\n        }\r\n\r\n        int a_size = a.size();\r\n        int b_size = b.size();\r\n\r\n        int res = a_size + b_size; //步数最大\r\n\r\n        // a = b: 将a、b换成同一个字符，遍历所有字符,求换成某一个字符所需最小步数\r\n        for(int i = 0; i < 26; i++){\r\n            res = min(res, a_size + b_size - a_num[i] - b_num[i]);\r\n        }\r\n\r\n        //累加小于某字符的字符个数\r\n        for (int i = 1; i < 26; i++) {\r\n            a_num[i] += a_num[i - 1];\r\n            b_num[i] += b_num[i - 1];\r\n        }\r\n\r\n        for(int i = 0; i < 25; i++){ \r\n            // a > b: 以 i 为边界，将 a中字符转为全部大于i所需步数，将 b中字符转为全部小于等于 i 所需步数\r\n            res = min(res, a_num[i] + b_size - b_num[i]);\r\n            // a < b: 以 i 为边界，将 a中字符转为全部小于等于i所需步数，将 b中字符转为全部大于 i 所需步数\r\n            res = min(res, a_size - a_num[i] + b_num[i]);\r\n        }\r\n        return res;\r\n\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n时间复杂度：O(m + n)\r\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jadeliu13":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429970650","body":"'''\nK取余作为相加的位数，K取整作为进一位的相加结果\n'''\nclass Solution:\n    def addToArrayForm(self, A: list[int], K: int) -> list[int]:\n        n = len(A)\n        ans = []\n\n        for i in range(n-1, -1, -1):\n            sum = A[i] + K % 10\n            K //= 10\n            # 当前位相加结果大于 10 时，进位 1 加入下一位计算\n            if sum >= 10:                \n                K += 1\n            # 进入数组\n            ans.append(sum % 10)\n            \n        # 若数组 A 的长度小于整数 K 位数个数的情况\n        while K > 0:\n            ans.append(K % 10)\n            K //= 10\n        # 因为添加进来是由低位往高位，输出时进行逆序输出\n        return ans[::-1]\n'''\n待解\n时间复杂度：O(n)\n空间复杂度：O(n)\n'''","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431595411","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n\n        def find_c():\n            yield from (i for i, j in enumerate(s) if j == c)\n            yield n * 2\n\n        f = find_c()\n        x, y = n * 2, next(f)\n        \n        ans = list()\n        for i, j in enumerate(s):\n            if j == c:\n                x, y = i, next(f)\n            ans.append(min(abs(i - x), abs(i - y)))\n        return ans","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434842143","body":"'''\n1. 栈里面每次存储两个信息, (左括号前的字符串, 左括号前的数字), \n比如abc3[def], 当遇到第一个左括号的时候，压入栈中的是(\"abc\", 3), 然后遍历括号里面的字符串def, \n当遇到右括号的时候, 从栈里面弹出一个元素(s1, n1), 得到新的字符串为s1+n1*\"def\", 也就是abcdefdefdef。\n对于括号里面嵌套的情况也是同样处理方式。\n2. 凡是遇到左括号就进行压栈处理，遇到右括号就弹出栈，栈中记录的元素很重要。\n'''\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxSize=maxSize\n        self.stack=[]\n\n\n    def push(self, x):\n        if len(self.stack)<self.maxSize:\n            self.stack.append(x)\n\n\n    def pop(self):\n        if len(self.stack)==0:\n            return -1\n        return self.stack.pop()\n\n\n    def increment(self, k, val):\n        if len(self.stack)<k:\n            for i in range(len(self.stack)):\n                self.stack[i]+=val\n        else:\n            for i in range(k):\n                self.stack[i]+=val\n        return self.stack\n# 有参考评论 https://leetcode.cn/problems/decode-string/comments/","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436017592","body":"# 一个数组可以分成好几个小数组，每个小数组内部都是递增排列的，最后这几个小数组可以按顺序组成的大数组刚好是这个数组的递增序列\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        arr = zip(arr, range(len(arr)))\n        arr = sorted(arr)\n        arrs = [0]*len(arr)\n        for idx,i in enumerate(arr):\n            arrs[i[1]] = idx\n        m = -float('inf')\n        res = 0\n        for i in range(len(arrs)):\n            m = max(m, arrs[i])\n            if m == i:\n                res += 1\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437239492","body":"#首尾相连，再找到位置断开循环.将尾部向前数第K个元素作为头，原来的头接到原来的尾上https://leetcode.cn/problems/rotate-list/\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n    #遍历到none，就从0开始计数（右开空间），如果遍历到最后有效位，就从1开始（右闭空间）\n        if head is None or head.next is None: return head\n        start, end, len = head, None, 0\n        while head:\n            end = head\n            head = head.next\n            len += 1\n        #首尾连接\n        end.next = start\n        #计算有效移动步数\n        pos = len - k % len\n        while pos > 1:\n            start = start.next\n            pos -= 1\n        ret = start.next\n        start.next = None\n        return ret","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437287514","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        res = ListNode(next=head)\n        pre = res\n      # 剩1或0，则遍历结束\n        while pre.next and pre.next.next:\n            cur = pre.next\n            post = pre.next.next            \n            # pre，cur，post对应最左，中间的，最右边的节点\n            cur.next = post.next\n            post.next = cur\n            pre.next = post\n\n            pre = pre.next.next\n        return res.next","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440286189","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n# 需要先找到链表的中间节点，然后将该中间节点作为二叉搜索树的根节点，创建完根节点之后，再递归的处理链表的左半部分和右半部分\n# 递归。用head和tail定义链首和链尾，链表区间为左闭右开，即 [ head , tail ）\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if head == None:\n            return None\n        return self.helper(head, None)\n    \n    def helper(self, start, end):\n        fast = slow = start\n        if start == end:\n            return None\n        while fast != end and fast.next != end:\n            fast = fast.next.next\n            slow = slow.next\n        root = TreeNode(slow.val)\n        root.left = self.helper(start, slow)\n        root.right = self.helper(slow.next, end)\n        return root\n\n    ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1442015190","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if not (headA and headB):\n            return None\n\n        num_a = num_b = 1\n        node_a, node_b = headA, headB\n        while node_a.next:\n            node_a = node_a.next\n            num_a += 1\n\n        while node_b.next:\n            node_b = node_b.next\n            num_b += 1\n\n        node_a, node_b = headA, headB\n        if num_a > num_b:\n            for _ in range(num_a - num_b):\n                node_a = node_a.next\n        else:\n            for _ in range(num_b - num_a):\n                node_b = node_b.next\n\n        while node_a != node_b:\n            node_a = node_a.next\n            node_b = node_b.next\n\n        return node_a","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1445124512","body":"### 使用快慢指针找环；如果存在环，那么快慢指针会在环内相遇，但是相遇的点，不一定是环的起点\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast = head\n        slow = head\n        while fast != None and fast.next != None:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                fast = head\n                while fast != slow:\n                    fast = fast.next\n                    slow = slow.next\n                return slow\n        return None","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445126142","body":"#### 毫无思路，看评论需要补充下LRU基础\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n            return self.cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        self.cache[key] = value\n        self.cache.move_to_end(key)\n        if len(self.cache)>self.cap:\n            self.cache.popitem(last=False)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445392825","body":"#### DFS深度优先搜索，利用递归的栈，借助level标记当前层\n#### 每个节点仅访问一次，时间复杂度O(n)\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        self.ans = 0\n        self._dfs(root, 0)\n        return self.ans\n        \n    def _dfs(self, node, level):\n        if not node:\n            return\n        if self.ans < level + 1:\n            self.ans = level + 1\n        self._dfs(node.left, level + 1)\n        self._dfs(node.right, level + 1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446233428","body":"class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        # 全空\n        if not p and not q: return True\n        # 一边空，不对称\n        elif not p or not q: return False\n        # 不空，但不同\n        elif p.val != q.val: return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448343023","body":"class Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        res = 0\n        path = []\n        def backtrace(root):\n            nonlocal res\n            # 节点空则返回\n            if not root: return\n            path.append(root.val)\n            # 遇到叶子节点\n            if not root.left and not root.right:\n                res += get_sum(path)\n            # 左子树不空\n            if root.left:\n                backtrace(root.left)\n            # 右子树不空\n            if root.right:\n                backtrace(root.right)\n            path.pop()\n\n        def get_sum(arr):\n            s = 0\n            for i in range(len(arr)):\n                s = s * 10 + arr[i]\n            return s\n\n        backtrace(root)\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450192664","body":"class Solution:\n    def findBottomLeftValue(self, root: TreeNode) -> int:\n        max_depth = -float(\"INF\")\n        leftmost_val = 0\n\n        def __traverse(root, cur_depth): \n            nonlocal max_depth, leftmost_val\n            if not root.left and not root.right: \n                if cur_depth > max_depth: \n                    max_depth = cur_depth\n                    leftmost_val = root.val  \n            if root.left: \n                cur_depth += 1\n                __traverse(root.left, cur_depth)\n                cur_depth -= 1\n            if root.right: \n                cur_depth += 1\n                __traverse(root.right, cur_depth)\n                cur_depth -= 1\n\n        __traverse(root, 0)\n        return leftmost_val","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1452091422","body":"#### 使用前序遍历和中序遍历\nclass Codec:\n\n    def serialize(self, root):\n        inorder = []\n        preorder = []\n        def dfsinoder(cur: TreeNode, depth: int):\n            if cur == None:\n                return\n            if cur.left != None:\n                dfsinoder(cur.left, depth+1)\n            inorder.append(str(cur.val) + \".\" + str(depth))\n            if cur.right != None:\n                dfsinoder(cur.right, depth+1)\n\n        def dfspreorder(cur: TreeNode, depth):\n            if cur == None:\n                return\n            preorder.append(str(cur.val) + \".\" + str(depth))\n            if cur.left != None:\n                dfspreorder(cur.left, depth+1)\n            if cur.right != None:\n                dfspreorder(cur.right, depth+1)\n            \n        dfsinoder(root, 0)\n        dfspreorder(root, 0)\n        return \";\".join([\" \".join(inorder), \" \".join(preorder)])\n        \n\n    def deserialize(self, data):\n        self.cnt = 0\n        def buildTree(lst: List[str]) -> TreeNode:\n            cur = preorder[self.cnt]\n            val, depth = cur.split(\".\")\n            curnode = TreeNode(int(val))\n\n            idx = lst.index(cur)\n\n            left = lst[:idx]\n            right = lst[idx+1:]\n\n            if len(left) > 0:\n                self.cnt += 1\n                curnode.left = buildTree(left)\n            if len(right) > 0:\n                self.cnt += 1\n                curnode.right = buildTree(right)\n            return curnode\n\n        str1, str2 = data.split(\";\")\n        inorder = str1.split()\n        preorder = str2.split()\n        if len(inorder) == 0:\n            return None\n        else:\n            return buildTree(inorder)\n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453667486","body":"class Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def read(root, x, y): \n            if root:\n                nums = d.get(x, [])\n                nums.append((y, root.val)) #把层数y与结点val添加到第x列\n                d[x] = nums\n                read(root.left, x - 1, y + 1) #左列数-1，层数+1\n                read(root.right, x + 1, y + 1) #右列数+1，层数+1\n\n        d = dict() #key是列下标， value是这列各结点的(层数，值)的列表\n        read(root, 0, 0) #遍历树\n\n        res = list()\n        for k in sorted(d.keys()): #列数排序，从左到右\n            x = sorted(d[k])   #层数与值排序，从小到大\n            x = [i[1] for i in x] #从(y, root.val)取val\n            res.append(x)\n\n        return res","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1462271310","body":"class Solution:\r\n    def minSubarray(self, nums: List[int], p: int) -> int:\r\n        target = sum(nums) % p\r\n        if target == 0: \r\n            return 0\r\n        curr, seen, ans = 0, {0:0}, len(nums)\r\n        for i, num in enumerate(nums):\r\n            curr = (curr + num) % p\r\n            prev = (curr - target) % p\r\n            if prev in seen:\r\n                ans = min(ans, i + 1 - seen[prev])\r\n            seen[curr] = i + 1\r\n        return ans if ans < len(nums) else -1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463702884","body":"#### 快慢指针，快指针每次走两步，慢指针每次走一步，所以快指针走的距离为慢指针的两倍，故当快指针遍历到链表末尾时，慢指针指向记为中间节点\r\n\r\nclass Solution:\r\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        return slow","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466424907","body":"#### 参考思路：维护窗口，向右移动时左侧超出窗口的值弹出，因为需要的是窗口内的最大值，所以只要保证窗口内的值是递减的即可，小于新加入的值全部弹出，最左端即为窗口最大值\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        win, ret = [], []\r\n        for i, v in enumerate(nums):\r\n            if i >= k and win[0] <= i - k: win.pop(0)\r\n            while win and nums[win[-1]] <= v: win.pop()\r\n            win.append(i)\r\n            if i >= k - 1: ret.append(nums[win[0]])\r\n        return ret","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468373907","body":"class Solution:\r\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\r\n        if n == 1:\r\n            return 1\r\n        # 存放有相信他人的人\r\n        lis = set()\r\n        # 以被相信人为key，统计相信他的人有多少\r\n        dic = {}\r\n        for x,y in trust:\r\n            if y not in dic:\r\n                dic[y] = 0\r\n            dic[y] += 1\r\n            lis.add(x)\r\n        for key in dic:\r\n            # 如果有n-1的人相信他，且他不相信任何人，则他是法官\r\n            if dic[key] == n-1 and key not in lis:\r\n                return key\r\n        return -1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1470173352","body":"#### 无向图\r\n`\r\n\r\nclass Solution:\r\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\r\n        graph = collections.defaultdict(list)   # 刻画a, b两人的关系图, 无向图\r\n        for s, e in dislikes:\r\n            graph[s].append(e)\r\n            graph[e].append(s)\r\n        \r\n        group = dict()\r\n\r\n        @functools.lru_cache(None)               # 缓存dfs搜索中间结果, 下次i相同就相当于表查询, 时间复杂度为O(n)\r\n        def dfs(i, g=1):\r\n            if i in group:\r\n                return group[i] == g            # i的组划分,已经判定在了group当中, 所以判断是否矛盾\r\n            group[i] = g                        # 不矛盾的话, 判定给组g\r\n            for con in graph[i]:                # 如果i的邻接节点,都能不矛盾地\"安排\", 返回true\r\n                if not dfs(con, -1 * g):\r\n                    return False\r\n            return True\r\n        \r\n        for i in range(1, N + 1):\r\n            if i not in group and not dfs(i):   # 此处必须强调i不在group, 因为前面搜索中可能将\r\n                return False                    # i判定给了-1, 但是此时如果再次dfs搜索, 将其默认为1,会矛盾\r\n        return True\r\n`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1472253997","body":"\r\n`from collections import defaultdict`\r\n\r\n`\r\nclass Solution:\r\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\r\n        # 将不属于任何组的单独成组赋予组编号并记录每个组的成员\r\n        dct = defaultdict(list)\r\n        for i in range(n):\r\n            if group[i] == -1:\r\n                group[i] = m\r\n                m += 1\r\n            dct[group[i]].append(i)\r\n        # 记录组间的拓扑关系与组内的拓扑关系\r\n        inter_edge = defaultdict(list)\r\n        inner_edge = defaultdict(lambda: defaultdict(list))\r\n        for i in range(n):\r\n            for j in beforeItems[i]:\r\n                if group[i] == group[j]:\r\n                    inner_edge[group[i]][j].append(i)\r\n                else:\r\n                    inter_edge[group[j]].append(group[i])\r\n        # 检查网络拓扑是否可行\r\n        def check(edge, nodes):\r\n            degree = defaultdict(int)\r\n            for j in edge:\r\n                for i in edge[j]:\r\n                    degree[i] += 1\r\n            ans = []\r\n            stack = [i for i in nodes if not degree[i]]\r\n            while stack:\r\n                ans.extend(stack)\r\n                nex = []\r\n                for j in stack:\r\n                    for i in edge[j]:\r\n                        degree[i] -= 1\r\n                        if not degree[i]:\r\n                            nex.append(i)\r\n                stack = nex[:]\r\n            return ans if len(ans) == len(nodes) else []\r\n        \r\n        # 确定组间的可行顺序\r\n        inter_order = check(inter_edge, list(set(group)))\r\n        if not inter_order:\r\n            return inter_order\r\n        # 确定组内的可行的顺序        \r\n        res = []\r\n        for g in inter_order:\r\n            inner_order = check(inner_edge[g], dct[g])\r\n            if not inner_order:\r\n                return inner_order\r\n            res.extend(inner_order)\r\n        return res\r\n`\r\n##### 参考\r\n链接：https://leetcode.cn/problems/sort-items-by-groups-respecting-dependencies/solution/er-xu-cheng-ming-jiu-xu-zui-by-liupengsa-e2f3/","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1474049428","body":"```\r\nclass Solution:\r\n\r\n    def judgeCircle(self, moves: str) -> bool:\r\n        x = 0 # 记录当前位置\r\n        y = 0\r\n        for i in range(len(moves)):\r\n            if (moves[i] == 'U'):\r\n                y += 1\r\n            if (moves[i] == 'D'):\r\n                y -= 1\r\n            if (moves[i] == 'L'):\r\n                x += 1\r\n            if (moves[i] == 'R'):\r\n                x -= 1\r\n        return x == 0 and y == 0``\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476504402","body":"```\r\nclass Solution:\r\n    def minCharacters(self, a: str, b: str) -> int:\r\n        na, nb = len(a), len(b)\r\n        cnta, cntb = [0] * 26, [0] * 26\r\n        for c in a:\r\n            i = ord(c) - ord('a')\r\n            cnta[i] += 1\r\n        for c in b:\r\n            i = ord(c) - ord('a')\r\n            cntb[i] += 1\r\n\r\n        presuma, presumb = [0] * 26, [0] * 26\r\n        presuma[0], presumb[0] = cnta[0], cntb[0]\r\n        for i in range(1, 26):\r\n            presuma[i] = presuma[i - 1] + cnta[i]\r\n            presumb[i] = presumb[i - 1] + cntb[i]\r\n\r\n        ans = float('inf')\r\n        for i in range(26):\r\n            res = na - cnta[i] + nb - cntb[i]\r\n            ans = min(ans, res)\r\n            for j in range(i + 1, 26):\r\n                res = na - presuma[i] + presumb[j - 1]\r\n                ans = min(ans, res)\r\n                res = nb - presumb[i] + presuma[j - 1]\r\n                ans = min(ans, res)\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477560154","body":"#### 快排\r\n```\r\nclass Solution:\r\n    def sortArray(self, nums: List[int]) -> List[int]:\r\n        low = 0\r\n        high = len(nums) - 1\r\n        self.quickSort(nums, low, high)\r\n        return nums\r\n    \r\n    def quickSort(self, nums, low, high):\r\n        if low >= high:\r\n            return nums\r\n        q = self.partition(nums, low, high)\r\n        self.quickSort(nums, low, q-1)\r\n        self.quickSort(nums, q+1, high)\r\n        return nums\r\n    \r\n    def partition(self, nums, low, high):\r\n        pivot = nums[high]\r\n        i = low\r\n        for j in range(low, high+1):\r\n            if nums[j] < pivot:\r\n                nums[i], nums[j] = nums[j], nums[i]\r\n                i += 1\r\n        \r\n        nums[i], nums[high] = nums[high], nums[i]\r\n\r\n        return i\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479928330","body":"#### 二分法循环\r\n\r\n```\r\nclass Solution:\r\n    def mySqrt(self, x: int) -> int:\r\n        if x <= 1:\r\n            return x\r\n        min = 0\r\n        max = x\r\n        while max-min>1:\r\n            mid = int((max+min)/2)   \r\n            if mid>x/mid:     # 平方可能溢出，作除法\r\n                max = mid\r\n            else:\r\n                min = mid\r\n        return int(min)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480714352","body":"```\r\nclass Solution:\r\n    def firstBadVersion(self, n: int) -> int:\r\n        left = 0\r\n        right = n\r\n        while left < right:\r\n            middle = (left+right)//2\r\n            if isBadVersion(middle):\r\n                right = middle\r\n            else:\r\n                left = middle+1\r\n        return left\r\n```","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491335409","body":"\r\n#### 采用类似滑动窗口的思路，即用两个指针表示窗口左端left和右端right。 向右移动right，保证left与right之间的字符串足够包含需要包含的所有字符， 而在保证字符串能够包含所有需要的字符条件下，向右移动left，保证left的位置对应为需要的字符，这样的 窗口才有可能最短，此时只需要判断当期窗口的长度是不是目前来说最短的，决定要不要更新minL和minR\r\n\r\n#### 移动right的时候，碰到t中的一个字符，对应字典的计数就减一，那么当字典这些元素的值都不大于0的时候，窗口里面就包含了所有需要的字符\r\n#### 移动left，直到找到目标字符串中的字符，同时又希望窗口尽可能短，因此希望找到的left使得窗口的开头就是要求的字符串中的字符，同时整个窗口含有所有需要的字符数量\r\n\r\n\r\n```\r\nfrom collections import defaultdict\r\nclass Solution:\r\n    def minWindow(self, s: str, t: str) -> str:\r\n        #s的长度必须不小于t\r\n        if len(s) < len(t): return ''\r\n        #初始化\r\n        rec = defaultdict(int)\r\n        len_t = len(t)\r\n        minLeft, minRight = 0, len(s)\r\n\r\n        #记录t中各个字母的出现频次\r\n        for i in t:\r\n            rec[i] += 1\r\n\r\n        #开始寻找子串\r\n        left = 0\r\n        for right, str in enumerate(s):\r\n            if rec[str] > 0:  #找到t中的字母,对于不存在的valu而等于0（这就是defaultdic的方便之处）\r\n                len_t -= 1\r\n            rec[str] -= 1 #值为负的要么是多余的在t中的字符，要么是不在t中的字母，便于后面left移动\r\n\r\n            if  len_t == 0:\r\n                while rec[s[left]] < 0: #值为负的要么是多余的在t中的字符，要么是不在t中的字母，left向右移动\r\n                    rec[s[left]] += 1\r\n                    left += 1\r\n\r\n                if right - left < (minRight - minLeft):  #上一步left到位，现在更新最小区间\r\n                    minLeft, minRight = left, right\r\n\r\n                rec[s[left]] += 1 # 开始找下一个窗口\r\n                left += 1\r\n                len_t += 1\r\n\r\n        return '' if minRight == len(s) else s[minLeft:minRight+1]\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495295206","body":"py3\r\n```\r\nclass Solution:\r\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\r\n        if not grid:\r\n            return 0\r\n        res=0\r\n        row,column=len(grid),len(grid[0])\r\n        moveset=[(0,1),(1,0),(-1,0),(0,-1)]\r\n\r\n        \r\n        def dfs(grid,i,j):\r\n            if i < 0 or j<0 or i>=row or j>=column or grid[i][j] == 0:\r\n                return 0            \r\n            s=1\r\n            grid[i][j]=0\r\n            for cood in moveset:\r\n                s+=dfs(grid,i+cood[0],j+cood[1])\r\n            return s\r\n\r\n        for i in range(row):\r\n            for j in range(column):\r\n                if grid[i][j]==1:\r\n                    res=max(res,dfs(grid,i,j))            \r\n        return res\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaoq777":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429974006","body":"```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> kList = new ArrayList<>();\r\n        while(k != 0) {\r\n            kList.add(k % 10);\r\n            k = k / 10;\r\n        }\r\n        Collections.reverse(kList);\r\n        \r\n        int i = num.length - 1, j = kList.size() - 1;\r\n        List<Integer> result = new ArrayList<>();\r\n        int add = 0;\r\n        while(i >= 0 || j >= 0) {\r\n            int sum = add;\r\n            if(i >= 0) {\r\n                sum += num[i--];\r\n            }\r\n            if(j >= 0) {\r\n                sum += kList.get(j--);\r\n            }\r\n            add = sum >= 10 ? 1 : 0;\r\n            result.add(sum % 10);\r\n        }\r\n        if(add != 0) {\r\n            result.add(1);\r\n        }\r\n        Collections.reverse(result);\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431568984","body":"## 思路\r\n先从左至右遍历，记录最后出现的字符c的索引j，得到每个位置与 向左找最近的字符c 的距离Math.abs(i-j)。\r\n再从右至左遍历，同上方式得到每个位置与 向右找最近的字符c 的距离。\r\n若在某个位置上向左找向右找都有字符c，就求 向左找最小距离 与 向右找最小距离 的较小值作为结果。\r\n\r\n\r\n## 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] result = new int[len];\r\n        Arrays.fill(result, Integer.MAX_VALUE);\r\n        int j = -1;\r\n        for(int i = 0; i < len; i++) {\r\n            if(s.charAt(i) == c) {\r\n                j = i;\r\n            }\r\n            if(j != -1) {\r\n                result[i] = Math.abs(i - j);\r\n            }\r\n        }\r\n        j = -1;\r\n        for(int i = len - 1; i >= 0; i--) {\r\n            if(s.charAt(i) == c) {\r\n                j = i;\r\n            }\r\n            if(j != -1) {\r\n                result[i] = Math.min(result[i], Math.abs(i - j));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n时间复杂度 O(N)\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433266099","body":"### 思路\r\n使用数组实现栈，使用一个tail变量记录当前栈顶的索引。\r\n入栈操作tail+1，出栈操作tail-1。\r\n\r\n### 代码\r\n```java\r\nclass CustomStack {\r\n\r\n    int[] arr;\r\n    int tail = -1;\r\n\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(tail == arr.length - 1) {\r\n            return;\r\n        }\r\n        arr[++tail] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(tail == -1) {\r\n            return -1;\r\n        }\r\n        return arr[tail--];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i = 0; i < Math.min(k, arr.length); i++) {\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度:\r\n* push: O(1)\r\n* pop: O(1)\r\n* increment: O(k)或O(maxSize)\r\n\r\n空间复杂度:\r\nO(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434643795","body":"### 思路\r\n使用栈数据结构，将字符依次入栈，遇到']'时取出栈中需要重复的连续字符放入list，直到遇到'['后再从栈中取出连续的数字n，将这一段内容解码(将list内容重复n次)后,  将这段内容再放入栈中继续处理。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Deque<Character> stack = new LinkedList<>();\r\n        StringBuffer buffer = new StringBuffer();\r\n        for(int i = 0; i < s.length(); i++) {\r\n            char c = s.charAt(i);\r\n            if(c == ']') {\r\n                List<Character> list = new ArrayList<>();\r\n                while(!stack.isEmpty()) {\r\n                    char d = stack.pop();\r\n                    if(d == '[') {\r\n                        break;\r\n                    }\r\n                    list.add(d);\r\n                }\r\n                int num = 0;\r\n                int n = 1;\r\n                while(!stack.isEmpty()) {\r\n                    char d = stack.pop();\r\n                    if(d - '0' <= 9) {\r\n                        num += n * (d - '0');\r\n                        n *= 10;\r\n                    }else {\r\n                        stack.push(d);\r\n                        break;\r\n                    }\r\n                }\r\n                num = num == 0 ? 1 : num;\r\n                for(int j = 0; j < num; j++) {\r\n                    for(int k = list.size() - 1; k >= 0; k--) {\r\n                        stack.push(list.get(k));\r\n                    }\r\n                }\r\n            }else {\r\n                stack.push(c);\r\n            }\r\n        }\r\n        while(!stack.isEmpty()) {\r\n            buffer.append(stack.pollLast());\r\n        }\r\n        return buffer.toString();\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435493598","body":"### 思路\r\n使用两个栈模拟，peek或pop操作时将第一个栈中的元素全部移动到第二个栈中(第一个栈的栈顶元素将被放到第二个栈的栈底)。\r\n这样从第二个栈的栈顶取元素相当于整体顺序先入先出。\r\n\r\n### 代码\r\n```java\r\nclass MyQueue {\r\n\r\n    Stack<Integer> stack1 = new Stack<>();\r\n    Stack<Integer> stack2 = new Stack<>();\r\n\r\n    public MyQueue() {\r\n\r\n    }\r\n    \r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        move();\r\n        if(!stack2.isEmpty()) {\r\n            return stack2.pop();\r\n        }else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public int peek() {\r\n        move();\r\n        return stack2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stack1.isEmpty() && stack2.isEmpty();\r\n    }\r\n\r\n    public void move() {\r\n        if(stack2.isEmpty()) {\r\n            while(!stack1.isEmpty()) {\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436024728","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack();\r\n        int n = 0;\r\n        for(int i = 0; i < arr.length; i++) {\r\n            if(stack.isEmpty() || arr[i] >= stack.peek()) {\r\n                stack.push(arr[i]);\r\n            }else {\r\n                int t = stack.pop();\r\n                while(!stack.isEmpty() && stack.peek() > arr[i]) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(t);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437231281","body":"```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (k == 0 || head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        int len = 1;\r\n        ListNode node = head;\r\n        while (node.next != null) {\r\n            node = node.next;\r\n            len++;\r\n        }\r\n        int n = len - k % len;\r\n        if (n == len) {\r\n            return head;\r\n        }\r\n        node.next = head;\r\n        for(int i = 0; i < n; i++) {\r\n            node = node.next;\r\n        } \r\n        ListNode result = node.next;\r\n        node.next = null;\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438621802","body":"```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        ListNode result = head.next;\r\n        ListNode pre = null;\r\n        while(head != null && head.next != null) {\r\n            ListNode next = head.next.next;\r\n            head.next.next = head;\r\n            if(pre != null) {\r\n                pre.next = head.next;\r\n            }\r\n            head.next = next;\r\n            pre = head;\r\n            head = next;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439940171","body":"```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        List<Integer> list = new ArrayList<>();\r\n        while(head != null) {\r\n            list.add(head.val);\r\n            head = head.next;\r\n        }\r\n        if(list.isEmpty()) {\r\n            return null;\r\n        }\r\n        return buildTree(list, 0, list.size() - 1);\r\n    }\r\n\r\n    public TreeNode buildTree(List<Integer> list, int start, int end) {\r\n        int mid = start + (end - start) / 2;\r\n        TreeNode node = new TreeNode(list.get(mid));\r\n        if(mid > start) {\r\n            node.left = buildTree(list, start, mid - 1);\r\n        }\r\n        if(end > mid) {\r\n            node.right = buildTree(list, mid + 1, end);\r\n        }\r\n        return node;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441866922","body":"```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if(headA == null || headB == null) {\r\n            return null;\r\n        }\r\n        ListNode pa = headA, pb = headB;\r\n        while(true) {\r\n            if(pa == pb) {\r\n                return pa;\r\n            }\r\n            pa = pa.next;\r\n            pb = pb.next;\r\n            if(pa == null && pb != null) {\r\n                pa = headB;\r\n            }\r\n            if(pb == null && pa != null) {\r\n                pb = headA;\r\n            }\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443840288","body":"```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode slow = head, fast = head, s = head;\r\n        while(slow != null && fast!= null) {\r\n            slow = slow.next;\r\n            if(fast.next == null || fast.next.next == null) {\r\n                return null;\r\n            }\r\n            fast = fast.next.next;\r\n            if(slow == fast) {\r\n                break;\r\n            }\r\n        }\r\n        while(true) {\r\n            if(s == slow) {\r\n                return s;\r\n            }\r\n            s = s.next;\r\n            slow = slow.next;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445148001","body":"```java\r\nclass LRUCache {\r\n\r\n    class ListNode {\r\n        int key;\r\n        int val;\r\n        ListNode next;\r\n        ListNode pre;\r\n    }\r\n\r\n    private int capacity;\r\n\r\n    private int count = 0;\r\n\r\n    private Map<Integer, ListNode> map;\r\n\r\n    private ListNode head, tail;\r\n\r\n    public LRUCache(int capacity) {\r\n        map = new HashMap<>();\r\n        head = new ListNode();\r\n        tail = head;\r\n        this.capacity = capacity;\r\n    }\r\n\r\n    public int get(int key) {\r\n        if(!map.containsKey(key)) {\r\n            return -1;\r\n        }\r\n        ListNode node = map.get(key);\r\n        moveToTail(node);\r\n        return map.get(key).val;\r\n    }\r\n\r\n    private void moveToTail(ListNode node) {\r\n        if(node == tail) {\r\n            return;\r\n        }\r\n        node.pre.next = node.next;\r\n        if(node.next != null) {\r\n            node.next.pre = node.pre;\r\n        }\r\n        node.pre = tail;\r\n        node.next = null;\r\n        tail.next = node;\r\n        tail = node;\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        ListNode node = map.get(key);\r\n        if(node == null) {\r\n            node = new ListNode();\r\n            count += 1;\r\n            if(count > capacity) {\r\n                ListNode remove = head.next;\r\n                map.remove(head.next.key);\r\n                head.next = remove.next;\r\n                if(remove.next != null) {\r\n                    remove.next.pre = head;\r\n                }\r\n                count -= 1;\r\n            }\r\n        }else {\r\n            moveToTail(node);\r\n        }\r\n        map.put(key, node);\r\n        node.key = key;\r\n        node.val = value;\r\n        tail.next = node;\r\n        node.pre = tail;\r\n        tail = node;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445349006","body":"```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null) {\r\n            return 0;\r\n        }\r\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446259266","body":"```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null || q == null) {\r\n             return p == q;\r\n        }\r\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448085698","body":"```java\r\nclass Solution {\r\n    int result = 0;\r\n\r\n    public int sumNumbers(TreeNode root) {\r\n        sum(root, 0);\r\n        return result;\r\n    }\r\n\r\n    public void sum(TreeNode node, int num) {\r\n        if(node == null) {\r\n            return;\r\n        }\r\n        if(node.left == null && node.right == null) {\r\n            result += num * 10 + node.val;\r\n        }else {\r\n            num = num * 10 + node.val;\r\n            sum(node.left, num);\r\n            sum(node.right, num);\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450347853","body":"```java\r\nclass Solution {\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        queue.offer(root);\r\n        int result = root.val;\r\n        List<TreeNode> list = new ArrayList<>();\r\n        while(!queue.isEmpty()) {\r\n            TreeNode node = queue.poll();\r\n            if(node.left != null) {\r\n                list.add(node.left);\r\n            }\r\n            if(node.right != null) {\r\n                list.add(node.right);\r\n            }\r\n            if(queue.isEmpty()) {\r\n                if(!list.isEmpty()) {\r\n                    result = list.get(0).val;\r\n                    queue.addAll(list);\r\n                    list.clear();\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451811346","body":"```java\r\npublic class Codec {\r\n\r\n     public String serialize(TreeNode root) {\r\n        return serialize1(root, \"\");\r\n     }\r\n\r\n     public String serialize1(TreeNode node, String result) {\r\n        if(node != null) {\r\n            result += node.val + \",\";\r\n            result = serialize1(node.left, result);\r\n            result = serialize1(node.right, result);\r\n        }else {\r\n            result += \"*\" + \",\";\r\n        }\r\n        return result;\r\n     }\r\n\r\n     // Decodes your encoded data to tree.\r\n     public TreeNode deserialize(String data) {\r\n        String[] arr = data.split(\",\");\r\n        List<String> list = new ArrayList<>(Arrays.asList(arr));\r\n        return deserialize1(list);\r\n     }\r\n\r\n     public TreeNode deserialize1(List<String> list) {\r\n        if(\"*\".equals(list.get(0))) {\r\n            list.remove(0);\r\n            return null;\r\n        }\r\n        TreeNode node = new TreeNode(Integer.parseInt(list.get(0)));\r\n        list.remove(0);\r\n        node.left = deserialize1(list);\r\n        node.right = deserialize1(list);\r\n        return node;\r\n     }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453468881","body":"```java\r\nclass Solution {\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        List<List<Integer>> result = new ArrayList<>();\r\n        Stack<TreeNode> stack = new Stack<>();\r\n        stack.push(root);\r\n        Map<TreeNode, Integer> cMap = new HashMap<>();\r\n        Map<TreeNode, Integer> rMap = new HashMap<>();\r\n        cMap.put(root, 0);\r\n        rMap.put(root, 0);\r\n        int min = 0;\r\n        int max = 0;\r\n        int c = -1;\r\n        int r = -1;\r\n        while(!stack.isEmpty()) {\r\n            TreeNode node = stack.pop();\r\n            c = cMap.get(node);\r\n            r = rMap.get(node);\r\n            cMap.put(node, c);\r\n            if(node.left != null) {\r\n                cMap.put(node.left, c - 1);\r\n                rMap.put(node.left, r + 1);\r\n                stack.push(node.left);\r\n                min = Math.min(c - 1, min);\r\n            }\r\n            if(node.right != null) {\r\n                cMap.put(node.right, c + 1);\r\n                rMap.put(node.right, r + 1);\r\n                stack.push(node.right);\r\n                max = Math.max(c + 1, max);\r\n            }\r\n        }\r\n        Map<Integer, List<TreeNode>> map1 = new HashMap<>();\r\n        Iterator<Map.Entry<TreeNode, Integer>> iterator = cMap.entrySet().iterator();\r\n        while(iterator.hasNext()) {\r\n            Map.Entry<TreeNode, Integer> entry = iterator.next();\r\n            map1.putIfAbsent(entry.getValue(), new ArrayList<>());\r\n            map1.get(entry.getValue()).add(entry.getKey());\r\n        }\r\n        for(int i = min; i <= max; i++) {\r\n            if(map1.get(i) != null) {\r\n                Collections.sort(map1.get(i), new Comparator<TreeNode>() {\r\n                    @Override\r\n                    public int compare(TreeNode o1, TreeNode o2) {\r\n                        if(rMap.get(o1) != rMap.get(o2)) {\r\n                            return rMap.get(o1) - rMap.get(o2);\r\n                        }else {\r\n                            return o1.val - o2.val;\r\n                        }\r\n                    }\r\n                });\r\n                List<Integer> list = map1.get(i).stream().map(new Function<TreeNode, Integer>() {\r\n\r\n                    @Override\r\n                    public Integer apply(TreeNode treeNode) {\r\n                        return treeNode.val;\r\n                    }\r\n                }).collect(Collectors.toList());\r\n                result.add(list);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454356092","body":"```java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        for(int i = 0; i < nums.length; i++) {\r\n            if(map.containsKey(target - nums[i])) {\r\n                return new int[]{i, map.get(target - nums[i])};\r\n            }\r\n            map.put(nums[i], i);\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455114087","body":"```java\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        for(int i : nums) {\r\n            map.put(i, map.getOrDefault(i, 0) + 1);\r\n        }\r\n        Queue<Map.Entry<Integer, Integer>> queue = new PriorityQueue<>(new Comparator<Map.Entry<Integer, Integer>>() {\r\n            public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) {\r\n                return o1.getValue() - o2.getValue();\r\n            }\r\n        });\r\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()) {\r\n            if(queue.size() == k) {\r\n                if(entry.getValue() > queue.peek().getValue()) {\r\n                    queue.poll();\r\n                    queue.offer(entry);\r\n                }\r\n            }else {\r\n                queue.offer(entry);\r\n            }\r\n            \r\n        }\r\n        int[] result = new int[k];\r\n        for(int i = 0; i < k; i++) {\r\n            result[i] = queue.poll().getKey();\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456299219","body":"```java\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        int result = 0;\r\n        for(int i = 0; i < points.length; i++) {\r\n            int[] p = points[i];\r\n            Map<Integer, Integer> countMap = new HashMap<>();\r\n            for(int j = 0; j < points.length; j++) {\r\n                int[] q = points[j];\r\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) \r\n                + (p[1] - q[1]) * (p[1] - q[1]); \r\n                countMap.put(dis, countMap.getOrDefault(dis, 0) + 1);\r\n            }\r\n            for(Integer val : countMap.values()) {\r\n                result += val * (val -1);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1458243359","body":"```java\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        int i = 0, j = 0;\r\n        Map<Character, Integer> map = new HashMap<>();\r\n        int ans = 0;\r\n        while(j < s.length()) {\r\n            char r = s.charAt(j);\r\n            map.put(r, map.getOrDefault(r, 0) + 1);\r\n            if(map.get(r) > 1) {\r\n                ans = Math.max(ans, j - i);\r\n                while(map.get(r) > 1) {\r\n                    map.put(s.charAt(i), map.get(s.charAt(i)) - 1);\r\n                    i += 1;\r\n                }\r\n            }\r\n            if(j == s.length() - 1) {\r\n                ans = Math.max(ans, j - i + 1);\r\n            }\r\n            j++;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460076393","body":"```java\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        List<Integer> result = new ArrayList<>();\r\n        int len = words[0].length();\r\n        Map<String, Integer> map = new HashMap<>();\r\n        for(String str : words) {\r\n            map.put(str, map.getOrDefault(str, 0) + 1);\r\n        }\r\n        for(int i = 0; i < s.length(); i ++) {\r\n            int end = i + words.length * len;\r\n            if(end > s.length()) {\r\n                break;\r\n            }\r\n            Map<String, Integer> countMap = count(s.substring(i, end), len);\r\n            if(countEqual(map, countMap)) {\r\n                result.add(i);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public boolean countEqual(Map<String, Integer> map1, Map<String, Integer> map2) {\r\n        for(String key : map1.keySet()) {\r\n            if(!map1.get(key).equals(map2.get(key))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public Map<String, Integer> count(String s, int len) {\r\n        Map<String, Integer> map = new HashMap<>();\r\n        for(int i = 0; i < s.length(); i+= len) {\r\n            String s1 = s.substring(i, i + len);\r\n            map.put(s1, map.getOrDefault(s1, 0) + 1);\r\n        }\r\n        return map;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461999877","body":"```java\r\nclass Solution {\r\n    public int minSubarray(int[] nums, int p) {\r\n        int sum = 0;\r\n        for(int i : nums) {\r\n            sum = (i + sum) % p;\r\n        }\r\n        int need = sum % p;\r\n        if(need == 0) {\r\n            return 0;\r\n        }\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        int res = nums.length;\r\n        int cur = 0;\r\n        for(int i = 0; i < nums.length; i++) {\r\n            map.put(cur, i);\r\n            cur = (cur + nums[i]) % p;\r\n            int n = (cur  + p - need) % p;\r\n            if(map.containsKey(n)) {\r\n                res = Math.min(res, i - map.get(n) + 1);\r\n            }\r\n        }\r\n        return res == nums.length ? -1 : res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1464034776","body":"```java\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n        ListNode slow = head, fast = head;\r\n        while (fast != null && fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464935429","body":"```java\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int n = nums.length;\r\n        if (n == 0) {\r\n            return 0;\r\n        }\r\n        int f = 1, s = 1;\r\n        while (f < n) {\r\n            if (nums[f] != nums[f - 1]) {\r\n                nums[s] = nums[f];\r\n                s++;\r\n            }\r\n            f++;\r\n        }\r\n        return s;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465092031","body":"```java\r\nclass Solution {\r\n    public int searchInsert(int[] nums, int target) {\r\n        int l = 0, r = nums.length - 1;\r\n        while(l <= r) {\r\n            int mid = l + (r - l) / 2;\r\n            if(nums[mid] == target ) {\r\n                return mid;\r\n            } else if(nums[mid] < target) {\r\n                l = mid + 1;\r\n            } else {\r\n                r = mid - 1;\r\n            }\r\n        }\r\n        return l;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466054642","body":"```java\r\nclass Solution {\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        Deque<Integer> deque = new LinkedList<>();\r\n        int[] result = new int[nums.length - k + 1];\r\n        for(int i = 0; i < nums.length; i++) {\r\n            while(!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {\r\n                deque.pollLast();\r\n            }\r\n            if(!deque.isEmpty() && i - deque.peek() >= k) {\r\n                deque.poll();\r\n            }\r\n            deque.offer(i);\r\n            if(i >= k-1) {\r\n                result[i - k + 1] = nums[deque.peek()];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468004957","body":"```java\r\nclass Solution {\r\n    public int findJudge(int n, int[][] trust) {\r\n        int[] in = new int[n];\r\n        int[] out = new int[n];\r\n        for (int[] t: trust) {\r\n            in[t[1] - 1]++;\r\n            out[t[0] - 1]++;\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            if (in[i] == n - 1 && out[i] == 0) {\r\n                return i + 1;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469905869","body":"```java\r\nclass Solution {\r\n    public boolean possibleBipartition(int n, int[][] dislikes) {\r\n        int[] visited = new int[n + 1];\r\n        Map<Integer, List<Integer>> map = new HashMap<>();\r\n        for(int i = 0; i < dislikes.length; i++) {\r\n            map.putIfAbsent(dislikes[i][0], new ArrayList<>());\r\n            map.get(dislikes[i][0]).add(dislikes[i][1]);\r\n            map.putIfAbsent(dislikes[i][1], new ArrayList<>());\r\n            map.get(dislikes[i][1]).add(dislikes[i][0]);\r\n        }\r\n        Queue<Integer> queue = new LinkedList<>();\r\n        for(int j = 1; j <= n; j++) {\r\n            if(visited[j] != 0) {\r\n                continue;\r\n            }\r\n            queue.offer(j);\r\n            int last = 2;\r\n            while(!queue.isEmpty()) {\r\n                List<Integer> list = new ArrayList<>();\r\n                while(!queue.isEmpty()) {\r\n                    Integer i = queue.poll();\r\n                    int color = last == 2 ? 1 : 2;\r\n                    if(visited[i] != 0 && visited[i] == color) {\r\n                        continue;\r\n                    }\r\n                    if(visited[i] == 0) {\r\n                        visited[i] = color;\r\n                    }\r\n                    if(visited[i] != 0 && visited[i] != color) {\r\n                        return false;\r\n                    }\r\n                    if(map.get(i) != null) {\r\n                        list.addAll(map.get(i));\r\n                    }\r\n                }\r\n                last = last == 2 ? 1 : 2;\r\n                queue.addAll(list);\r\n                list.clear();\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1471858264","body":"```java\r\nclass Solution {\r\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\r\n        for(int i = 0; i < group.length; i++) {\r\n            if(group[i] == -1) {\r\n                group[i] = m;\r\n                m += 1;\r\n            }\r\n        }\r\n\r\n        List<List<Integer>> groupGraph = new ArrayList<>();\r\n        List<List<Integer>> itemsGraph = new ArrayList<>();\r\n        for(int i = 0; i < m; i++) {\r\n            groupGraph.add(new ArrayList<>());\r\n        }\r\n        for(int i = 0; i < n; i++) {\r\n            itemsGraph.add(new ArrayList<>());\r\n        }\r\n        int[] groupInDegree = new int[m];\r\n        for(int i = 0; i < beforeItems.size(); i++) {\r\n            int curGroup = group[i];\r\n            for(Integer j : beforeItems.get(i)) {\r\n                if (curGroup != group[j]) {\r\n                    groupGraph.get(group[j]).add(curGroup);\r\n                    groupInDegree[curGroup] += 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        int[] itemsInDegree = new int[n];\r\n        for(int i = 0; i < beforeItems.size(); i++) {\r\n            for(int j : beforeItems.get(i)) {\r\n                itemsGraph.get(j).add(i);\r\n                itemsInDegree[i] += 1;\r\n            }\r\n        }\r\n\r\n        List<Integer> groupSorted = topologicalSort(groupGraph, groupInDegree, m);\r\n        List<Integer> itemsSorted = topologicalSort(itemsGraph, itemsInDegree, n);\r\n        if(groupSorted == null || itemsSorted == null) {\r\n            return new int[0];\r\n        }\r\n\r\n        Map<Integer, List<Integer>> groupItemsMap = new HashMap<>();\r\n        for(int i = 0; i < itemsSorted.size(); i++) {\r\n            groupItemsMap.computeIfAbsent(group[itemsSorted.get(i)], k -> new ArrayList<>()).add(itemsSorted.get(i));\r\n        }\r\n        int[] result = new int[n];\r\n        int j = 0;\r\n        for(int i = 0; i < groupSorted.size(); i++) {\r\n            List<Integer> list = groupItemsMap.get(groupSorted.get(i));\r\n            if(list == null) {\r\n                continue;\r\n            }\r\n            for(int k : list) {\r\n                result[j++] = k;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private static List<Integer> topologicalSort(List<List<Integer>> graph, int[] inDegree, int l) {\r\n        int len = inDegree.length;\r\n        Queue<Integer> queue = new LinkedList<>();\r\n        for(int i = 0; i < len; i++) {\r\n            if(inDegree[i] == 0) {\r\n                queue.offer(i);\r\n            }\r\n        }\r\n        List<Integer> result = new ArrayList<>();\r\n        while(!queue.isEmpty()) {\r\n            int i = queue.poll();\r\n            result.add(i);\r\n            for(Integer j : graph.get(i)) {\r\n                inDegree[j] -= 1;\r\n                if(inDegree[j] == 0) {\r\n                    queue.offer(j);\r\n                }\r\n            }\r\n        }\r\n        if(result.size() != l) {\r\n            return null;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473756434","body":"```java\r\nclass Solution {\r\n    public boolean judgeCircle(String moves) {\r\n        int x = 0, y = 0;\r\n        for(int i = 0; i < moves.length(); i++) {\r\n            switch (moves.charAt(i)) {\r\n                case 'U':\r\n                    y -= 1;\r\n                    break;\r\n                case 'D':\r\n                    y += 1;\r\n                    break;\r\n                case 'L':\r\n                    x -= 1;\r\n                    break;\r\n                case 'R':\r\n                    x += 1;\r\n            }\r\n        }\r\n        if(x == 0 && y == 0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474886062","body":"```java\r\nclass Solution {\r\n    public int[] getOrder(int[][] tasks) {\r\n        int t = 0;\r\n        int taskIndex = 0;\r\n        Map<int[], Integer> map = new HashMap<>();\r\n        for(int i = 0; i < tasks.length; i++) {\r\n            map.put(tasks[i], i);\r\n        }\r\n        Arrays.sort(tasks, (o1, o2) -> {\r\n            return o1[0] - o2[0];\r\n        });\r\n        Queue<int[]> queue = new PriorityQueue<>((o1, o2) -> {\r\n            if(o1[1] - o2[1] != 0) {\r\n                return o1[1] - o2[1];\r\n            }else {\r\n                return map.get(o1) - map.get(o2);\r\n            }\r\n        });\r\n        int cpuJob = 0;\r\n        int[] currentJob = null;\r\n        boolean busy = false;\r\n        List<Integer> result = new ArrayList<>();\r\n        while(true) {\r\n            t += 1;\r\n            for(int i = taskIndex; i < tasks.length; i++) {\r\n                if(tasks[i][0] > t) {\r\n                    taskIndex = i;\r\n                    break;\r\n                }\r\n                if(tasks[i][0] >= t) {\r\n                    queue.offer(tasks[i]);\r\n                }\r\n            }\r\n            if(!busy && !queue.isEmpty()) {\r\n                currentJob = queue.poll();\r\n                busy = true;\r\n            }\r\n            if(currentJob != null) {\r\n                currentJob[1] -= 1;\r\n                if(currentJob[1] == 0) {\r\n                    result.add(map.get(currentJob));\r\n                    busy = false;\r\n                }\r\n            }\r\n            if(result.size() == tasks.length) {\r\n                return result.stream().mapToInt(Integer::intValue).toArray();\r\n            }\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475275641","body":"```java\r\nclass Solution {\r\n    public int numberOfRounds(String loginTime, String logoutTime) {\r\n        String[] loginTimeArr = loginTime.split(\":\");\r\n        String[] lougoutTimeArr = logoutTime.split(\":\");\r\n        int start = Integer.parseInt(loginTimeArr[0]) * 60 + Integer.parseInt(loginTimeArr[1]);\r\n        int end = Integer.parseInt(lougoutTimeArr[0]) * 60 + Integer.parseInt(lougoutTimeArr[1]);\r\n        if(end < start) {\r\n            end += 1440;\r\n        }\r\n        start = start % 15 > 0 ? (start / 15 + 1)* 15 : start /15 * 15;\r\n        end = end / 15 * 15;\r\n        return Math.max(end - start, 0) / 15;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476160254","body":"```java\r\nclass Solution {\r\n    public int minCharacters(String a, String b) {\r\n        int[] countA = new int[26];\r\n        int[] countB = new int[26];\r\n        for(int i = 0; i < a.length(); i++) {\r\n            countA[a.charAt(i) - 'a'] += 1;\r\n        }\r\n        for(int i = 0; i < b.length(); i++) {\r\n            countB[b.charAt(i) - 'a'] += 1;\r\n        }\r\n        int ans = Math.max(a.length(), b.length());\r\n        for(int i = 0; i < 26; i++) {\r\n            ans = Math.min(a.length() - countA[i] + b.length() - countB[i], ans);\r\n            int n = 0, m = 0;\r\n            if (i == 0) {\r\n                continue;\r\n            }\r\n            for (int j = i; j < 26; j++) {\r\n                n += countA[j];\r\n                m += countB[j];\r\n            }\r\n            for (int j = 0; j < i; j++) {\r\n                n += countB[j];\r\n                m += countA[j];\r\n            }\r\n            ans = Math.min(Math.min(m, n), ans);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477776980","body":"```java\r\nclass Solution {\r\n    public int[] sortArray(int[] nums) {\r\n        sort(nums, 0, nums.length - 1);\r\n        return nums;\r\n    }\r\n\r\n    public void sort(int[] arr, int l, int r) {\r\n        if(l >= r) {\r\n            return;\r\n        }\r\n        int a = arr[r];\r\n        int i = l-1, j = r, k = l;\r\n        while(k < j) {\r\n            if(arr[k] < a) {\r\n                swap(arr, i+1, k);\r\n                i++;\r\n                k++;\r\n            }else if(arr[k] == a) {\r\n                k++;\r\n            }else if(arr[k] > a) {\r\n                swap(arr, k, j-1);\r\n                j--;\r\n            }\r\n        }\r\n        swap(arr, j, r);\r\n        sort(arr, l, i);\r\n        sort(arr, j, r);\r\n    }\r\n\r\n    public void swap(int[] arr, int i, int j) {\r\n        int tmp = arr[i];\r\n        arr[i] = arr[j];\r\n        arr[j] = tmp;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangyanlineu":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429976257","body":"### Idea\r\n- use``` k%10``` to get the least important digit (the last one)\r\n- use ```carry_on``` to memorize the number that we carried from last round, the original ```carry_on``` should be 0\r\n- loop from the last element in array num to the start, ```carry_on+num_element + k%10``` should be the current number\r\n- update the ```carry_on``` and ```num_element``` in different way based on if ```carry_on+num_element + k%10 >= 10```\r\n- if we run out of the num element, then we insert the new digit to the index 0 until ```k == 0 and carry_on == 0```\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = len(num)-1\r\n        carry_on = 0\r\n        while i >= 0:\r\n            carry_on += k%10\r\n            k = k//10\r\n            temp = num[i] + carry_on\r\n            if temp >= 10:\r\n                carry_on = temp//10\r\n                num[i] = temp%10\r\n            else:\r\n                num[i] = temp\r\n                carry_on = 0\r\n            i -= 1\r\n\r\n        while carry_on or k:\r\n            carry_on += k%10\r\n            k = k//10\r\n            if carry_on >= 10:\r\n                num.insert(0, carry_on%10)\r\n                carry_on = carry_on//10\r\n            else:\r\n                num.insert(0, carry_on)\r\n                carry_on = 0\r\n        return num\r\n```\r\n- Time Complexity:  O(N)  <b>N = len(max(len(num), len(k_digits))</b>\r\n- Space Complexity: O(1) <b> insert new digits to the original num array</b>","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430346702","body":"### Idea\r\n- use <b>Two Pointers</b> to decide which index is the cloest\r\n- get all c's index in s\r\n- iterate through s and get the smallest distance\r\n```python3\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        # Get all c's index in s\r\n        c_index = []\r\n        for index, value in enumerate(s):\r\n            if value == c:\r\n                c_index.append(index)\r\n                \r\n        ans = []\r\n        cur = c_index.pop(0)\r\n        for i in range(len(s)):\r\n            distance_cur = cur-i if cur-i >= 0 else i-cur\r\n            if not c_index:\r\n                ans.append(distance_cur)\r\n            else:\r\n                distance_next = c_index[0]-i if c_index[0]-i>=0 else i-c_index[0]\r\n                ans.append(min(distance_cur, distance_next))\r\n                if distance_next <= distance_cur:\r\n                    cur = c_index.pop(0)\r\n        return ans\r\n```\r\n- Time Complexity = O(N) <b>N= len(s)</b>\r\n- Space Complexity = O(N) <b>N= len(s)</b>","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433316573","body":"###Idea\r\n- use self.cur_length to memorize the length of the stack\r\n- self.limit represents the maxSize of the stack\r\n- use array's append and pop to do push and pop\r\n\r\n```python3\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.limit = maxSize\r\n        self.cur_length = 0\r\n        self.stack = []\r\n        \r\n    def push(self, x: int) -> None:\r\n        if self.cur_length < self.limit:\r\n            self.stack.append(x)\r\n            self.cur_length += 1\r\n        else:\r\n            return\r\n    \r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            self.cur_length -= 1\r\n            return self.stack.pop()\r\n        return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        k = min(k, self.cur_length)\r\n        while k>0 :\r\n            self.stack[k-1] += val\r\n            k -= 1\r\n        return\r\n```\r\n- Time Complexity = O(1) for push and pop, O(N) for increment N=min(k, self.cur_length)\r\n- Space Complexity = O(N) N=maxSize","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1433978030","body":"### Idea \r\n- Recursively\r\n```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        def findNum(index: int) -> list:\r\n            num = ''\r\n            while index<len(s) and s[index].isnumeric():\r\n                num += s[index]\r\n                index += 1\r\n            return [int(num), index]\r\n        def findPairBracket(first_bracket: int) -> int:\r\n            num_of_first_bracket = 0\r\n            for i in range(first_bracket, len(s)):\r\n                if s[i] == '[':\r\n                    num_of_first_bracket += 1\r\n                elif s[i] == ']':\r\n                    num_of_first_bracket -= 1\r\n                if num_of_first_bracket == 0:\r\n                    return i\r\n        res = ''\r\n        index = 0\r\n        while index<len(s):\r\n            if s[index].isnumeric(): \r\n                [repeat_num, first_bracket] = findNum(index)\r\n                second_bracket = findPairBracket(first_bracket) \r\n                res += self.decodeString(s[first_bracket+1:second_bracket])*repeat_num \r\n                index = second_bracket + 1\r\n            else:\r\n                res += s[index]\r\n                index += 1\r\n        return res\r\n```\r\n- Stack\r\n```python3\r\ndef decodeString(self, s: str) -> str:\r\n        stack = []\r\n        num = ''\r\n        cur_str = ''\r\n        for char in s:\r\n            if char == '[':\r\n                stack.append(cur_str)\r\n                stack.append(int(num))\r\n                num = cur_str = ''\r\n            elif char == ']':\r\n                repeat_num = stack.pop()\r\n                prev = stack.pop()\r\n                cur_str = prev + cur_str*repeat_num\r\n            elif char.isnumeric():\r\n                num += char\r\n            else:\r\n                cur_str += char\r\n        return cur_str\r\n```\r\n- Time Complexity = O(N)\r\n- Space Complexity = O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435465026","body":"```python3\nclass MyQueue:\n\n    def __init__(self):\n        self.queue = []\n        \n    def push(self, x: int) -> None:\n        self.queue.append(x)\n        \n    def pop(self) -> int:\n        if self.queue:\n            return self.queue.pop(0)\n\n    def peek(self) -> int:\n        if self.queue:\n            return self.queue[0]\n\n    def empty(self) -> bool:\n        if not self.queue:\n            return True\n        return False\n```\n- space = O(N)\n- time = O(1) except that pop() is O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436287975","body":"```python3\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack =[]\n        for num in arr:\n            if not stack or stack[-1] <= num:\n                stack.append(num)\n            else:\n                cur = stack[-1]\n                while stack and stack[-1] > num:\n                    cur = max(cur, stack.pop())\n                stack.append(cur)\n        return len(stack)\n```\n- Time Complexity = O(N)\n- Space Complexity = O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436258891","body":"### Idea\n- get the length of the linked list\n- k = k%length\n- break and rebuild the link\n```python3\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n        length = 0\n        cur = head\n        while cur:\n            length += 1\n            cur = cur.next\n\n        k = k%length\n        if k == 0:\n            return head\n        slow = fast = head\n        for _ in range(length-k-1):\n            fast = fast.next\n        end = fast\n        newHead = fast = fast.next\n        end.next = None\n        while fast and fast.next:\n            fast = fast.next\n        fast.next = slow\n        return newHead\n```\n- Time Complexity = O(N)\n- Space Complexity = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437348055","body":"### Idea\n- remove and rebuild the link until there is less than 2 nodes left \n```python3\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        dummy = ListNode(0, head)\n        prev = dummy\n        first = prev.next\n        while first and first.next:\n            second = first.next\n            prev.next = second\n            first.next = second.next\n            second.next = first\n            prev = first\n            first = prev.next\n        return dummy.next\n```\n- Time = O(N) N=length of the listed list\n- Space = O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1438888980","body":"- find the middle node in the linked list\r\n- **divide** it in the middle **and conquer** left segment and right segment\r\n```python3\r\nclass Solution:\r\n    def divideConquer(self, segment: Optional[ListNode], length: int) -> Optional[TreeNode]:\r\n        if not segment: return\r\n        if not segment.next: return TreeNode(segment.val)\r\n        # find the middle node to divide and conquer\r\n        prev, middle = segment, segment.next\r\n        for _ in range(length//2-1):\r\n            prev, middle =  prev.next, middle.next \r\n        # divide and conquer\r\n        prev.next = None\r\n        leftTree = self.divideConquer(segment, length//2)\r\n        rightTree = self.divideConquer(middle.next, length-length//2-1)\r\n        middle.next = None\r\n        return TreeNode(middle.val, leftTree, rightTree) \r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head: return\r\n        if not head.next: return TreeNode(head.val)\r\n        # Get the length of the linked list\r\n        length = 0\r\n        cur = head\r\n        while cur:\r\n            length += 1\r\n            cur = cur.next\r\n        return self.divideConquer(head, length)\r\n```\r\n- Time = O(NlogN)\r\n- Space = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1440582904","body":"- Find the length of headA and headB\n- move the longer one's pointer few steps away (difference between length)\n- move both pointers forward until find the joint point\n- **Time = O(m+n)**\n- **Space = O(1)**\n```python3\nclass Solution:\n    def getLength(self, head: ListNode) -> int:\n        res = 0\n        cur = head\n        while cur:\n            res += 1\n            cur = cur.next\n        return res\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        a, b = self.getLength(headA), self.getLength(headB)\n        [long, short] = [headA, headB] if a>=b else [headB, headA]\n        for _ in range(abs(a-b)):\n            long = long.next\n        while long:\n            if long == short:\n                return long\n            long, short = long.next, short.next\n        return None\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442381141","body":"- Two pointers\n- Time = O(n)\n- Space = O(1)\n```python3\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        time = 0\n        slow = fast = head\n        while slow and fast:\n            if not fast.next:\n                return None\n            slow = slow.next\n            fast = fast.next.next\n            time += 1\n            if slow == fast:\n                slow = head\n                while slow != fast:\n                    slow = slow.next\n                    fast = fast.next\n                return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1444239810","body":"- Use OrderedDict\n- Time = O(1)\n- Space = O(N)\n```python3\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.length = 0\n        self.capacity = capacity\n        \n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n            return self.cache[key]\n        return -1\n        \n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache[key] = value\n            self.cache.move_to_end(key)\n        else:\n            if self.length < self.capacity:\n                self.length += 1\n            else:\n                self.cache.popitem(False)\n            self.cache[key] = value\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445276212","body":"- Recursion\n- Time = O(n)\n- Space = O(n)\n```python3\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        leftDepth = self.maxDepth(root.left)\n        rightDepth = self.maxDepth(root.right)\n        return 1 + max(leftDepth, rightDepth)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445427056","body":"- recursion\n- T = O(N) N = number of nodes\n- S = O(N) N = height of the tree\n```python3\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1446817913","body":"- DFS\n- T = O(N) N is the number of nodes\n- S = O(1) \n```python3\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(head, prev):\n            if not head:\n                return prev\n            if not head.left and not head.right:\n                return prev*10 + head.val\n            res = 0\n            if head.left:\n                res += dfs(head.left, prev*10+head.val)\n            if head.right:\n                res += dfs(head.right, prev*10+head.val)\n            return res\n        return dfs(root, 0)\n```\n- BFS\n- T = O(N) N is the number of nodes\n- S = O(N) N is the largest number of nodes in one layer\n```python3\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        branches = [root]\n        res = 0\n        while branches:\n            temp = []\n            for branch in branches:\n                if not branch.left and not branch.right:\n                    res += branch.val\n                if branch.left:\n                    branch.left.val = branch.val*10+branch.left.val\n                    temp.append(branch.left)\n                if branch.right:\n                    branch.right.val = branch.val*10+branch.right.val\n                    temp.append(branch.right)\n            branches = temp\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1448801844","body":"- BFS\n- T = O(N) N is the number of the nodes in the tree\n- S = O(N) N is the greatest number of the nodes in one layer\n```python3\n class Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        trees = [root]\n        leftMost = None\n        while trees:\n            leftMost = trees[0].val\n            temp = []\n            for tree in trees:\n                if tree.left:\n                    temp.append(tree.left)\n                if tree.right:\n                    temp.append(tree.right)\n            trees = temp\n        return leftMost\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1452274982","body":"```python3\nclass Codec:\n    def serialize(self, root):\n        def preorder(root):\n            if not root:\n                return \"null,\"\n            return str(root.val) + \",\" + preorder(root.left) + preorder(root.right)\n\n        return preorder(root)[:-1]\n    def deserialize(self, data):\n        nodes = data.split(\",\")\n\n        def preorder(i):\n            if i >= len(nodes) or nodes[i] == \"null\":\n                return i, None\n            root = TreeNode(nodes[i])\n            j, root.left = preorder(i + 1)\n            k, root.right = preorder(j + 1)\n            return k, root\n\n        return preorder(0)[1]\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453007590","body":"- DFS to label node row & column value\n- use column as key, store node.val and node row \n- use heap to pop out the node row and node val\n- T = O(NlogN) dfs is O(N), heap.push is O(logN)\n- S = O(N)\n```python3\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        store, res = {}, []\n\n        def dfs(tree, column, row):\n            if column not in store:\n                store[column] = []\n                heapq.heapify(store[column])\n            heapq.heappush(store[column], [row, tree.val])\n            if tree.left:\n                dfs(tree.left, column-1, row+1)\n            if tree.right:\n                dfs(tree.right, column+1, row+1)\n\n        dfs(root, 0, 0)\n\n        for key in sorted(store.keys()):\n            res.append([])\n            values = store[key]\n            while values:\n                res[-1].append(heapq.heappop(values)[1])\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454143211","body":"- use dictionary to store the number and index\n- look up the target-num in dictionary\n- T = O(n)\n- T = O(n)\n```python3\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for index, num in enumerate(nums):\n            diff = target - num\n            if diff in seen:\n                return [seen[diff], index]\n            seen[num] = index\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1454840688","body":"- count the frequency of each element\n- use min heap to store [-frequency, element]\n- T = O(NlogM) N = len(nums) M=len(frequency.keys()) \n- S = O(N)\n```python3\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        # find each element's frequency\n        frequency = {}\n        for num in nums:\n            if num not in frequency:\n                frequency[num] = 0\n            frequency[num] += 1\n        \n        # heap to sort the frequency\n        heap = []\n        heapq.heapify(heap) # min heap\n        for key, value in frequency.items():\n            heapq.heappush(heap, [-value, key])\n        result = []\n        for i in range(k):\n            if heap:\n                [neg_frequency, num] = heapq.heappop(heap)\n                result.append(num)\n        return result\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455161563","body":"- use dictionary to count \r\n- T = O(n^2)\r\n- S = O(n)\r\n```python3\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        res = 0\r\n        distances = {}\r\n        for i in range(len(points)):\r\n            for j in range(i+1, len(points)):\r\n                count = 0\r\n                first, second = points[i], points[j]\r\n                d = (first[0]-second[0])**2+(first[1]-second[1])**2\r\n                if d in distances:\r\n                    if i in distances[d]: count += distances[d][i]\r\n                    if j in distances[d]: count += distances[d][j]\r\n                if d not in distances:\r\n                    distances[d] = defaultdict(int)\r\n                distances[d][i] += 1\r\n                distances[d][j] += 1\r\n                res += count\r\n        return res*2\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1456735404","body":"- use dictionary to memorize the index of char\r\n- update each char's index\r\n- T = O(N) n is the length of string s\r\n- S = O(N) n is the length of distinct chars in s\r\n```python\r\nclass Solution(object):\r\n    def lengthOfLongestSubstring(self, s):\r\n        seen = defaultdict(int)\r\n        start = res = None\r\n        for index, char in enumerate(s):\r\n            if start == None:\r\n                start = index\r\n                seen[char] = index\r\n                res = 1\r\n                continue\r\n            if char not in seen:\r\n                seen[char] = index\r\n                res = max(res, index-start+1)\r\n            else:\r\n                if seen[char] >= start:\r\n                    res = max(res, index-start)\r\n                    start = seen[char]+1\r\n                else:\r\n                    res = max(res, index-start+1)\r\n                seen[char] = index\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459016177","body":"- T = O(MN) M= len(s) N = len(words)\n- S = O(N) N = distinct elements in words\n```python3\nclass Solution(object):\n    def findSubstring(self, s, words):\n        wordsLength = len(words)*len(words[0])\n        wordsDict = defaultdict(int)\n        res = []\n        for word in words:\n            wordsDict[word] += 1\n        for i in range(len(s)-wordsLength+1):\n            sub = s[i:i+wordsLength]           \n            temp = defaultdict(int)\n            for j in range(0, wordsLength, len(words[0])):\n                temp[sub[j:j+len(words[0])]] += 1\n            if wordsDict == temp:\n                res.append(i)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1460840847","body":"```python3\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        need = sum(nums) % p\n        store = {0: -1}\n        cur = 0\n        res = len(nums)\n        for i, num in enumerate(nums):\n            cur = (cur + num) % p\n            store[cur] = i\n            if (cur - need) % p in store:\n                res = min(res, i - store[(cur - need) % p])\n        return res if res < len(nums) else -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1462684965","body":"- slow and fast pointers\n- T = O(N)\n- S = O(1)\n```python3\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464545747","body":"- Two pointers\n- T = O(N)\n- S = O(1)\n```python3\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        slow = 0\n        for fast in range(1, len(nums)):\n            if nums[slow] == nums[fast]:\n                continue\n            else:\n                nums[slow+1] = nums[fast]\n                slow += 1\n        return slow+1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1464990098","body":"- Binary Search\n- T = O(logN)\n- S = O(1)\n```python\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        left, right = 0, len(nums)-1\n        while left < right:\n            middle = left+(right-left)//2\n            if nums[middle] >= target:\n                right = middle\n            else:\n                left = middle + 1\n        return left if nums[left]>=target else left+1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465286893","body":"- heap\n- T = O(NlogN)\n- S = O(N)\n```python3\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        res = []\n        heap1 = []\n        heapq.heapify(heap1)\n        for i in range(len(nums)+1):\n            if i>=k:\n                found = False\n                while not found:\n                    [value, index] = heapq.heappop(heap1)\n                    if index+k >= i:\n                        res.append(value*(-1))\n                        found = True\n                        heapq.heappush(heap1, [value, index])\n            i<len(nums) and heapq.heappush(heap1, [-1*nums[i], i])\n        return res\n```\n- deque\n- T = O(N)\n- S = O(K)\n```python\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        window = deque()\n        res = []\n        for i in range(len(nums)):\n            # remove the index that is out of the window\n            while window and window[0] <= i-k:\n                window.popleft()\n            # the first element is always the index of greatest number in this window\n            while window and nums[window[-1]] < nums[i]:\n                window.pop()\n            window.append(i)\n            if i>=k-1:\n                res.append(nums[window[0]])\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1466928597","body":"- dictionary\n- T = O(N)\n- S = O(N)\n```python3\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        aTrustb = {}\n        bisTrusteda = {}\n        for i in range(1, n+1):\n            aTrustb[i] = set()\n            bisTrusteda[i] = set()\n        for a, b in trust:\n            aTrustb[a].add(b)\n            bisTrusteda[b].add(a)\n        for key, value in bisTrusteda.items():\n            if len(value) == n-1 and len(aTrustb[key]) == 0:\n                return key\n        return -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1468817574","body":"- T = O(V+E) total number of nodes and links\r\n- S = O(N)\r\n```python3\r\nclass Solution:\r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n        dislike, label = defaultdict(set), {}\r\n        for i,j in dislikes : dislike[i].add(j), dislike[j].add(i)\r\n        \r\n        def dfs(i, p):\r\n            if i in label: return label[i] == p\r\n            label[i] = p\r\n            return all(dfs(j, not p) for j in dislike[i])\r\n\r\n        for i in range(1, n+1):\r\n            if i not in label:\r\n                if not dfs(i, True): return False\r\n        return True\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1471351918","body":"···python3\nclass Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        for i in range(n): \n            if group[i] == -1: group[i] = i + m # re-group \n        \n        graph0 = {} # digraph of groups \n        indeg0 = [0]*(m+n) # indegree of groups \n        \n        graph1 = {} # digrpah of items \n        indeg1 = [0]*n # indegree of items\n        \n        for i, x in enumerate(beforeItems): \n            for xx in x: \n                if group[xx] != group[i]: \n                    graph0.setdefault(group[xx], []).append(group[i])\n                    indeg0[group[i]] += 1\n                graph1.setdefault(xx, []).append(i)\n                indeg1[i] += 1\n        \n        def fn(graph, indeg): \n            \"\"\"Return topological sort of graph using Kahn's algo.\"\"\"\n            ans = []\n            stack = [k for k in range(len(indeg)) if indeg[k] == 0]\n            while stack: \n                n = stack.pop()\n                ans.append(n)\n                for nn in graph.get(n, []):\n                    indeg[nn] -= 1\n                    if indeg[nn] == 0: stack.append(nn)\n            return ans \n        \n        tp0 = fn(graph0, indeg0) \n        if len(tp0) != len(indeg0): return [] \n        \n        tp1 = fn(graph1, indeg1)\n        if len(tp1) != len(indeg1): return []\n        \n        mp0 = {x: i for i, x in enumerate(tp0)}\n        mp1 = {x: i for i, x in enumerate(tp1)}\n        \n        return sorted(range(n), key=lambda x: (mp0[group[x]], mp1[x]))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1472437326","body":"- T = O(N) N=len(moves)\n- S = O(1)\n```python3\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        past = defaultdict(int)\n        for m in moves:\n            past[m] += 1\n        return past['U'] == past['D'] and past['L'] == past['R']\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474679379","body":"- Heap\n- Time = O(NlogN)\n- Space = O(N)\n```python3\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        res, heap, goodToGo = [], [], []\n        heapq.heapify(heap)\n        heapq.heapify(goodToGo)\n        \n        for index, value in enumerate(tasks):\n            heapq.heappush(heap, [value[0], value[1], index])\n\n        cutTime = 0\n        while True:\n            if not heap and not goodToGo:\n                return res\n            while heap and heap[0][0]<=cutTime:\n                [start, time, index] = heapq.heappop(heap)\n                heapq.heappush(goodToGo, [time, index])\n            if not goodToGo:\n                cutTime = heap[0][0]\n            else:\n                [time, index] = heapq.heappop(goodToGo)\n                res.append(index)\n                cutTime = cutTime + time\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1474982823","body":"- T = O(1)\n- S = O(1)\n```python3\nclass Solution:\n    def correctTime(self, minute, start = True) -> int:\n        if minute%15 == 0:\n            return minute\n        if start:\n            if minute > 0 and minute < 15:\n                return 15\n            if minute > 15 and minute < 30:\n                return 30\n            if minute > 30 and minute < 45:\n                return 45\n            return 60\n        else:\n            if minute > 0 and minute < 15:\n                return 0\n            if minute > 15 and minute < 30:\n                return 15\n            if minute > 30 and minute < 45:\n                return 30\n            return 45\n\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        startHour, startMinute = loginTime.split(':')\n        endHour, endMinute = logoutTime.split(':')\n        startH, startM, endH, endM = int(startHour), int(startMinute), int(endHour), int(endMinute)\n\n        if startH == endH and endM > startM and endM - startM < 15: \n            return 0\n\n        startM = self.correctTime(startM, True)\n        endM = self.correctTime(endM, False)\n\n\n        if startM == 60:\n            startH += 1\n            startM = 0\n        \n        if endH < startH or (endH == startH and endM < startM):\n            res = (24-(startH+1))*4 + endH*4\n            \n        else:\n            res = 4*(endH - (startH + 1))\n            \n        res += (60-startM)//15 + endM//15\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475386835","body":"```python3\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        counter_A, counter_B = [0] * 26, [0] * 26\n        # get the frequency of each char in a and b\n        for char in a:\n            counter_A[ord(char) - ord('a')] += 1\n        for char in b:\n            counter_B[ord(char) - ord('a')] += 1\n        ans = len(a) + len(b)\n        # case 3: a and b consist of only one char\n        for i in range(26):\n            ans = min(ans, len(a) + len(b) - counter_A[i] - counter_B[i])\n        # case 2: a > b\n        for i in range(1, 26):\n            t = 0\n            for j in range(i, 26):\n                t += counter_A[j]\n            for j in range(i):\n                t += counter_B[j]\n            ans = min(ans, t)\n        # case 1: b > a\n        for i in range(1, 26):\n            t = 0\n            for j in range(i, 26):\n                t += counter_B[j]\n            for j in range(i):\n                t += counter_A[j]\n            ans = min(ans, t)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1476832346","body":"- Merge Sort\r\n- T = O(NLogN)\r\n- S = O(N)\r\n```python\r\nclass Solution(object):\r\n    def sortArray(self, nums):\r\n        if len(nums)<=1:\r\n            return nums\r\n        res = []\r\n        middle = len(nums)//2\r\n        left = self.sortArray(nums[:middle])\r\n        right = self.sortArray(nums[middle:])\r\n        while left and right:\r\n            if left[0] < right[0]:\r\n                res.append(left.pop(0))\r\n            else:\r\n                res.append(right.pop(0))\r\n        return res+left if left else res+right\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1478347763","body":"- Binary Search\n- T = O(logN)\n- S = O(1)\n```python3\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        mini, maxi = 0, math.ceil(maxi/2)\n        while mini < maxi:\n            middle = mini+(maxi-mini)//2\n            if middle*middle > x:\n                maxi = middle-1\n            else:\n                mini = middle\n            if maxi - mini == 1:\n                return mini if maxi*maxi > x else maxi\n        return mini\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1479944634","body":"- Binary Search\n- T = O(logN)\n- S = O(1)\n```python3\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        left, right = 0, n\n        while left < right:\n            middle = (left+right)//2\n            if isBadVersion(middle):\n                right = middle\n            else:\n                left = middle+1\n        return left\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482030307","body":"- MergeSort\n- T = O(NlogN)\n- S = O(N)\n```python3\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        self.cnt = 0\n        def mergeSort(array):\n            if len(array)<=1:\n                return array\n            start, end, res = 0, len(array), []\n            middle = (start+end)//2\n            left, right = mergeSort(array[start:middle]), mergeSort(array[middle:end])\n            i = j = 0\n            while i<len(left) and j<len(right):\n                if left[i] > 2*right[j]:\n                    self.cnt += len(left)-i\n                    j += 1\n                else:\n                    i += 1\n            while left and right:\n                if left[0] < right[0]:\n                    res.append(left.pop(0))\n                else:\n                    res.append(right.pop(0))\n            while left:\n                res.append(left.pop(0))\n            while right:\n                res.append(right.pop(0))\n            return res\n        mergeSort(nums)\n        return self.cnt\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483294525","body":"- Binary Search\n- T = O(Nlog(10**9)) N = len(heaters)\n- S = O(N) N = len(heaters)\n```python3\nclass Solution:\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\n        mini, maxi = 0, 10**9-1\n        houses, heaters = sorted(houses), sorted(heaters)\n        def isNotEnough(radius):\n            ranges = [[heater-radius, heater+radius] for heater in heaters]\n            for house in houses:\n                while ranges and house > ranges[0][1]:\n                    ranges.pop(0)\n                if not ranges:\n                    return True\n                if house < ranges[0][0]:\n                    return True\n            return False\n        while mini < maxi:\n            middle = (maxi+mini)//2\n            if isNotEnough(middle):\n                mini = middle+1\n            else:\n                maxi = middle\n        return mini\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/47#issuecomment-1483916957","body":"- Binary Seach\n- T = O(NlogN)\n- S = O(1)\n```python3\nclass Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        l, r, n = 0, nums[-1]-nums[0], len(nums)\n\n        def countLessThan(cur):\n            i = j = cnt = 0\n            while i < len(nums):\n                while j<len(nums) and nums[j]-nums[i]<=cur:\n                    j += 1\n                cnt += j-i-1\n                i += 1\n            return cnt\n\n        while l<r:\n            middle = (l+r)//2\n            if countLessThan(middle) < k:\n                l = middle+1\n            else:\n                r = middle\n        return l\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484285893","body":"- DFS with memorization\n- T = O(MN) M = len(grid) N = len(grid[0])\n- S = O(MN)\n```python3\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        self.res = float('inf')\n        self.directions = [[1,0],[-1,0],[0,1],[0,-1]]\n        memo = {}\n\n        def inBound(row, col):\n            return row >= 0 and row < len(grid) and col >= 0 and col<len(grid[0])\n\n        def dfs(row, col, cur, seen):\n            if (row, col) not in memo:\n                memo[(row, col)] = cur\n            else:\n                if cur >= memo[(row, col)]:\n                    return\n                else:\n                    memo[(row, col)] = cur\n            if row == len(grid)-1 and col == len(grid[0])-1:\n                self.res = min(self.res, cur)\n                return\n            seen.add((row, col))\n            for dx, dy in self.directions:\n                newX, newY = row+dx, col+dy\n                if inBound(newX, newY) and (newX, newY) not in seen:\n                    dfs(newX, newY, cur if grid[newX][newY] <= grid[row][col] else max(cur, grid[newX][newY]), seen)\n            seen.remove((row, col))\n\n        dfs(0, 0, grid[0][0], set())\n        return self.res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1485866643","body":"- Sliding Window\n- T = O(N)\n- S = O(N)\n```python3\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        vowels = set(['a', 'e', 'i', 'o', 'u'])\n        isVowel = [1 if char in vowels else 0 for char in s]\n\n        accumulate = [0]+[isVowel[0]]\n        for i in range(1, len(s)):\n            accumulate.append(isVowel[i]+accumulate[-1])\n\n        res = 0\n        for i in range(k, len(s)+1):\n            res = max(res, accumulate[i]-accumulate[i-k])\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1487730952","body":"class Solution:\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\n        dp = collections.deque([float(i <= n) for i in range(k, k + maxPts)])\n        s = sum(dp)\n        for i in range(k):\n            dp.appendleft(s / maxPts)\n            s += dp[0] - dp.pop()\n        \n        return dp[0]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489001408","body":"- Sliding Window\n- T = O(N) N = len(s)\n- S = O(N) N = len(p)\n```python3\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        pChars = defaultdict(int)\n        for char in p:\n            pChars[char] += 1\n        res, temp = [], []\n\n        i = 0\n        while i<len(s)+1:\n            if len(temp) == len(p):\n                [value, index] = temp.pop(0)\n                res.append(index)\n                pChars[value] += 1\n\n            if i == len(s):\n                return res\n\n            if s[i] not in pChars.keys():\n                while temp:\n                    [value, index] = temp.pop(0)\n                    if value in pChars.keys():\n                        pChars[value] += 1\n                i += 1\n            else:\n                if pChars[s[i]] > 0:\n                    temp.append([s[i], i])\n                    pChars[s[i]] -= 1\n                    i += 1\n                else:\n                    [value, index] = temp.pop(0)\n                    pChars[value] += 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491188485","body":"```python3\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        d = Counter(t)\n        c = len(d)\n        i = start = 0\n        n = len(s)\n        ans = n+1\n        for j in range(n):\n            if s[j] in d:\n                d[s[j]]-=1\n                if d[s[j]]==0:\n                    c-=1            \n            while c==0:\n                if ans>j-i+1:\n                    ans=j-i+1\n                    start=i\n                if s[i] in d:\n                    d[s[i]]+=1\n                    if d[s[i]]>0:\n                        c+=1\n                i+=1\n        if ans>n:\n            return \"\"\n        return s[start:start+ans]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1500404271","body":"- Sliding Window\n- T = O(N)\n- S = O(1)\n```python3\nclass Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        # Get the minimum score in between\n        res = float('inf')\n        cur = 0\n        midLength = len(cardPoints)-k\n        for i in range(len(cardPoints)):\n            if i >= midLength:\n                cur -= cardPoints[i-midLength]\n            cur += cardPoints[i]\n            if i>=midLength-1: \n                res = min(res, cur)\n        return sum(cardPoints) - res\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1500414893","body":"``` python3\nclass Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        output = []\n        for h in range(12):\n            for m in range(60):\n                if bin(h).count('1') + bin(m).count('1') == turnedOn:  # Check if the number of set bits in hours and minutes equals the target number\n                    output.append(f\"{h}:{m:02d}\")  # Add the valid combination of hours and minutes to the output list\n        return output\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1494736230","body":"- DFS\r\n```python3\r\nclass Solution:\r\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\r\n        self.res = 0\r\n        directions = [[1,0],[-1,0],[0,1],[0,-1]]\r\n        \r\n        def inBound(row, col):\r\n            return row >= 0 and col >= 0 and row <len(grid) and col < len(grid[0])\r\n\r\n        def dfs(row, col, seen, cur):\r\n            for dx, dy in directions:\r\n                newR = row+dx\r\n                newC = col+dy\r\n                if inBound(newR, newC) and (newR, newC) not in seen and grid[newR][newC] == 1:\r\n                    seen.add((newR, newC))\r\n                    cur += dfs(newR, newC, seen, 1)\r\n                    grid[newR][newC] = 2\r\n            return cur\r\n\r\n        for row in range(len(grid)):\r\n            for col in range(len(grid[0])):\r\n                if grid[row][col] == 1:\r\n                    self.res = max(self.res, dfs(row, col, set([(row, col)]), 1))\r\n        return self.res\r\n```\r\n- BFS\r\n```python3\r\nclass Solution:\r\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\r\n        self.res = 0\r\n        directions = [[1,0],[-1,0],[0,1],[0,-1]]\r\n\r\n        def inBound(row, col):\r\n            return row >= 0 and col >= 0 and row <len(grid) and col < len(grid[0])\r\n        \r\n        def bfs(row, col, seen):\r\n            island = 0\r\n            qualified = [(row, col)]\r\n            while qualified:\r\n                island += 1\r\n                row, col = qualified.pop(0)\r\n                for dx, dy in directions:\r\n                    newR, newC = row+dx, col+dy\r\n                    if inBound(newR, newC) and grid[newR][newC] == 1 and (newR, newC) not in seen:\r\n                        seen.add((newR, newC))\r\n                        qualified.append((newR, newC))\r\n                        grid[newR][newC] = 2\r\n            return island\r\n        for row in range(len(grid)):\r\n            for col in range(len(grid[0])):\r\n                if grid[row][col] == 1:\r\n                    self.res = max(self.res, bfs(row, col, set([(row, col)])))\r\n        return self.res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1496415732","body":"- BFS\r\n```python3\r\nclass Solution:\r\n    def maxDistance(self, grid: List[List[int]]) -> int:\r\n        self.directions = [[1,0],[0,1],[-1,0],[0,-1]]\r\n        self.distance = [[0 for _ in grid[0]] for _ in grid]\r\n        self.res = -1\r\n        level = []\r\n        seen = set([])\r\n\r\n        def inBound(r, c):\r\n            return r>=0 and c>=0 and r<len(grid) and c<len(grid[0])\r\n       \r\n        for row in range(len(grid)):\r\n            for col in range(len(grid[0])):\r\n                if grid[row][col] == 1:\r\n                    level.append([row, col])\r\n                    seen.add((row, col))\r\n\r\n        while level:\r\n            nextLevel = []\r\n            for row, col in level:\r\n                for dx, dy in self.directions:\r\n                    newR, newC = dx+row, dy+col\r\n                    if inBound(newR, newC) and grid[newR][newC] == 0 and (newR, newC) not in seen:\r\n                        seen.add((newR, newC))\r\n                        self.distance[newR][newC] = self.distance[row][col]+1\r\n                        self.res = max(self.res, self.distance[newR][newC])\r\n                        nextLevel.append([newR, newC])\r\n            level = nextLevel\r\n        return self.res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1497975730","body":"```python3\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        res = 0\n        opened_box, closed_box, have_key, candy_taken  = [], set(), set(), set()\n\n        for box in initialBoxes:\n            if status[box] == 1: \n                opened_box.append(box)\n                for key in keys[box]:\n                    have_key.add(key)\n                for b in containedBoxes[box]:\n                    if status[b] == 1: \n                        opened_box.append(b)\n                    elif b in have_key:\n                        opened_box.append(b)\n                        have_key.remove(b)\n                    else:\n                        closed_box.add(b)\n            else: \n                closed_box.add(box)\n        while opened_box:\n            box = opened_box.pop()\n            if box not in candy_taken:\n                res += candies[box]\n                candy_taken.add(box)\n                for key in keys[box]:\n                    if key in closed_box:\n                        opened_box.append(key)\n                        closed_box.remove(key)\n                    else:\n                        have_key.add(key)\n                for b in containedBoxes[box]:\n                    if status[b] == 1:\n                        opened_box.append(b)\n                    elif b in have_key:\n                        have_key.remove(b)\n                        opened_box.append(b)\n                    else:\n                        closed_box.add(b)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1499445315","body":"- leetcode 987\r\n- DFS + Heap\r\n- T  = O(LogN) N = len(Nodes)\r\n- S = O(N) N = len(Nodes)\r\n```python3\r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        heap = []\r\n        heapq.heapify(heap)\r\n        def labelNode(tree, row, col):\r\n            heapq.heappush(heap, [col, row, tree.val])\r\n            if tree.left:\r\n                labelNode(tree.left, row+1, col-1)\r\n            if tree.right:\r\n                labelNode(tree.right, row+1, col+1)\r\n\r\n        labelNode(root, 0, 0)\r\n        result = []\r\n        curCol = float('-inf')\r\n\r\n        while heap:\r\n            [col, row, value] = heapq.heappop(heap)\r\n            if col>curCol:\r\n                curCol = col\r\n                result.append([])\r\n            result[-1].append(value)\r\n        return result\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500503761","body":"- DP\n- T = O(N)\n- S = O(1)\n```python\nclass Solution(object):\n    def minCostClimbingStairs(self, cost):\n        if len(cost)==2: return min(cost)\n        prev_two, prev_one = 0, min(cost[0], cost[1])\n        for i in range(3, len(cost)):\n            cur = min(prev_one+cost[i-1], prev_two+cost[i-2])\n            prev_two, prev_one = prev_one, cur\n        return min(prev_two+cost[-2], prev_one+cost[-1])\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501028548","body":"- DP\n- T = O(N)\n- S = O(1)\n```python\nclass Solution(object):\n    def rob(self, nums):\n        if len(nums) == 1: return nums[0]\n        prev_two, prev_one = nums[0], max(nums[0], nums[1])\n        for i in range(2, len(nums)):\n            prev_two, prev_one = prev_one, max(prev_two+nums[i], prev_one)\n        return prev_one\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501176710","body":"```python3\nclass Solution:\n  def findNumberOfLIS(self, nums: List[int]) -> int:\n    dp = [1] * len(nums)\n    count = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                if dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n                    count[i] = count[j]\n                elif dp[j] + 1 == dp[i]:\n                    count[i] += count[j]\n    max_len = max(dp)\n    return sum([count[i] for i in range(len(nums)) if dp[i] == max_len])\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1502050826","body":"- DP\n- T = O(MN)\n- S = O(MN)\n```c++\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int one = text1.size();\n        int two = text2.size();\n        int dp[one][two];\n\n        for (int row = 0; row < one; row++){\n            for (int col = 0; col < two; col++){\n                if (row == 0 && col == 0){\n                    dp[row][col] = int(text1[row]==text2[col]);\n                } else if (row == 0){\n                    dp[row][col] = max(dp[row][col-1], int(text1[row]==text2[col]));\n                } else if (col == 0){\n                    dp[row][col] = max(dp[row-1][col], int(text1[row]==text2[col]));\n                } else {\n                    dp[row][col] = max(max(dp[row-1][col-1]+int(text1[row]==text2[col]), dp[row-1][col]), dp[row][col-1]);\n                }\n            }\n        }\n        return dp[one-1][two-1];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1503686984","body":"- DP\n- T = O(mn)\n- S = O(mn)\n```c++\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int dp[m][n];\n        for (int row = 0; row < m; row++){\n            for (int col = 0; col < n; col++){\n                if (row == 0 || col == 0){\n                    dp[row][col] = 1;\n                }else {\n                    dp[row][col] = dp[row-1][col]+dp[row][col-1];\n                }\n            }\n        }\n        return dp[m-1][n-1];\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1507622418","body":"```python3\nclass Solution:\n    def canIWin(self, maxi: int, target: int) -> bool:\n        if target <= 0 or maxi >= target: return True\n        if (1+maxi)*maxi//2 < target: return False\n        \n        memo = {}\n        choices = [i for i in range(1, maxi+1)]\n\n        def dp(left, subTarget):\n            if left[-1] >= subTarget:\n                return True\n            if tuple(left) in memo:\n                return memo[tuple(left)]\n            for i in range(len(left)):\n                newLeft = left[:i] + left[i+1:]\n                if not dp(newLeft, subTarget-left[i]):\n                    memo[tuple(left)] = True\n                    return True\n            memo[tuple(left)] = False\n            return False\n        return dp(choices, target)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509051162","body":"```python3\nclass Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        def dp(i,target ):\n            if(target==0):\n                return True\n            if(i==len(nums) or target < 0):\n                return False \n            if(self.dp[i][target] != -1 ):\n                return self.dp[i][target]\n            self.dp[i][target]= dp(i+1,target-nums[i]) or dp(i+1,target)\n            return self.dp[i][target]\n        totalsum = sum(nums)\n        if(totalsum%2): return False \n        else: \n            self.dp = [ [-1]*((totalsum//2)+1) for _ in range(len(nums))]\n            return dp(0,totalsum//2)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxiner":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429985050","body":"## 思路\r\n 1. 将k转为数组\r\n 2. 数组形式逐位相加\r\n\r\n## 代码（JavaScript）\r\n\r\n```javascript\r\nvar addToArrayForm = function (num, k) {\r\n    let i1 = num.length - 1;\r\n    let kArray = k.toString().split('').map(i => Number(i));\r\n    let i2 = kArray.length - 1;\r\n    const carry =0;\r\n    const res = []\r\n    while (i1 >= 0 || i2 >= 0) {\r\n        const sum = num[i1] + kArray[i2] + carry;\r\n        const val = sum % 10;\r\n        carry = Math.floor(sum / 10);\r\n        res.push(val);\r\n        i1--;\r\n        i2--;\r\n    }\r\n    if(!!carry) {\r\n        res.push(carry)\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\n\r\n```\r\n\r\n\r\n## 复杂度分析\r\n时间O(N)\r\n空间O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431571499","body":"# 思路：\n两次遍历\n\nvar shortestToChar = function (s, c) {\n    const arr = s.split('');\n    const n = arr.length;\n    const res = [];\n    for (let i = 0, idx = -n; i < n; i++) {\n        if (arr[i] == c) {\n            idx = i;\n        }\n        res[i] = i - idx;\n    }\n\n    for (let i = n - 1, idx = 2 * n; i >= 0; i--) {\n        if (arr[i] == c) {\n            idx = i;\n        }\n        res[i] = Math.min(res[i], idx - i);\n    }\n    return res\n\n};\n\n时间&空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433193468","body":"思路：模拟数组原生pop和push\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize = maxSize;\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    let stack = this.stack;\r\n    if(stack.length < this.maxSize) {\r\n        stack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    let stack = this.stack;\r\n    if(stack.length > 0) {\r\n        return stack.pop();\r\n    }\r\n    return -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    let stack = this.stack;\r\n    for(let i = 0; i < Math.min(stack.length, k); i++) {\r\n        stack[i] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1435535241","body":"以下是使用 JavaScript 实现给定编码字符串的解码函数：\n\n```javascript\nfunction decodeString(s) {\n  const stack = [];\n  let currentStr = \"\";\n  let currentNum = 0;\n\n  for (let i = 0; i < s.length; i++) {\n    const char = s.charAt(i);\n\n    if (/[0-9]/.test(char)) {\n      currentNum = currentNum * 10 + parseInt(char);\n    } else if (char === \"[\") {\n      stack.push(currentStr);\n      stack.push(currentNum);\n      currentStr = \"\";\n      currentNum = 0;\n    } else if (char === \"]\") {\n      const num = stack.pop();\n      const prevStr = stack.pop();\n      currentStr = prevStr + currentStr.repeat(num);\n    } else {\n      currentStr += char;\n    }\n  }\n\n  return currentStr;\n}\n```\n### 使用了一个栈来辅助解码。我们遍历给定的字符串，对于每个字符，执行以下操作：\n\n如果是数字，更新当前数字；\n如果是左括号，将当前字符串和数字入栈，并清空当前字符串和数字；\n如果是右括号，从栈中弹出之前保存的字符串和数字，重复当前字符串并拼接到弹出的字符串后面；\n如果是字母，将它拼接到当前字符串后面。\n最后返回当前字符串即为解码后的字符串。\n### 复杂度分析：\n时间：O(N)\n空间：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435618399","body":"```javascript\nvar MyQueue = function () {\n    this.stack1 = [];\n    this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n    if (this.stack2.length === 0) {\n        while (this.stack1.length > 0) {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n    if (this.stack2.length === 0) {\n        while (this.stack1.length > 0) {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    const top = this.stack2.pop();\n    this.stack2.push(top);\n    return top;\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n    return this.stack1.length === 0 && this.stack2.length === 0;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n```\n\n### 使用两个栈实现一个先入先出队列，其中一个栈 stack1 用于入队，另一个栈 stack2 用于出队。入队操作时，将元素压入 stack1；出队操作时，如果 stack2 不为空，则直接弹出栈顶元素；如果 stack2 为空，则依次将 stack1 的元素弹出并压入 stack2，再弹出 stack2 的栈顶元素。peek 操作时，先执行和 pop 操作类似的步骤，最后将栈顶元素压回 stack2 中。\n\n### 复杂度\n空间： O(2N)\n时间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436023370","body":"努力看懂大神们的解法ing\n```javascript\n\nvar maxChunksToSorted = function (arr) {\n    var count = 1;\n    let max = 0;\n    for (let i = 0; i < arr.length; i++) {\n        max = Math.max(max, arr[i]);\n        if (max === i) {\n            count++;\n        }\n    }\n    return count;\n};\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437192206","body":"```javascript\nvar rotateRight = function(head, k) {\n    if( !k || !head || !head.next) return head;\n    let n = 1;\n    let cur = head;\n    while(cur.next) {\n        cur = cur.next;\n        n++;\n    }\n    cur.next = head;\n    let end = n - k % n;\n    while(end) {\n        cur = cur.next\n        end--;\n    }\n    const ret = cur.next;\n    cur.next = null;\n    return ret\n};\n```\n\n### 思路：\n\n遍历链表，得到链表长度N和尾巴\n将链表尾巴指向head，得到循环链表\n遍历（N - k % N）次，得到预期结果的上一个节点cur\n\n### 复杂度：\n空间 O(N)\n时间 O(2N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438559813","body":"```javascript\nvar swapPairs = function (head) {\n    const ghost = new ListNode(0, head);\n    let cur = ghost;\n    while (cur.next && cur.next.next) {\n        const next = cur.next;\n        const end = next.next;\n        cur.next = end;\n        next.next = end.next;\n        end.next = next;\n        cur = next;\n        // console.log(ghost.next)\n    }\n    return ghost.next;\n};\n\n```\n### 思路：\n非递归，中间变量用的好，交换无烦恼\n\n## 复杂度：\n时间： O(N)\n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440144499","body":"```javascript\nvar sortedListToBST = function (head) {\n    return buildTree(head, null);\n};\n\nfunction buildTree(left, right) {\n    if (left === right) return null;\n    var mid = getMedian(left, right);\n    var root = new TreeNode(mid.val);\n    root.left = buildTree(left, mid);\n    root.right = buildTree(mid.next, right);\n    return root\n}\n\nfunction getMedian(left, right) {\n    var fast = left;\n    var slow = left;\n    while (fast !== right && fast.next !== right) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    return slow\n}\n\n```\n\n### 思路：\n递归找中值作为root节点，找中值的方法利用快慢针\n\n### 复杂度：\n空间： O(Nlog(N))\n时间： O(log(N))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441861047","body":"```javascript\n\nvar getIntersectionNode = function (headA, headB) {\n    if (!headA || !headB) return null;\n    let c1 = headA;\n    let c2 = headB;\n    while (c1 !== c2) {\n        c1 = c1 ? c1.next : headB;\n        c2 = c2 ? c2.next : headA;\n    }\n    return c1\n};\n```\n\n\n### 思路：\n为了消除两条链条的长度，双指针分别遍历的顺序为A->B, B->A;\n若有交点则会在两指针遍历第二条链条时相交，否则不相交\n\n### 复杂度：\n时间： O(m+n)\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443593623","body":"```javascript\nvar detectCycle = function(head) {\n    if(!head) return null;\n    let fast = head;\n    let slow = head;\n    while(fast) {\n        console.log('-',fast.val, slow.val)\n        slow = slow.next;\n        if(!fast.next) return null;\n        if(!fast.next.next) return null;\n        fast = fast.next.next;\n        console.log(fast.val, slow.val)\n        if(fast === slow) {\n            let test = head;\n            while(test !== slow) {\n                test = test.next;\n                slow = slow.next;\n            }\n            return test\n        }\n    }\n};\n```\n### 思路：\n双指针+计算入环节点公式\na+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)\n\n### 复杂度\n空间：O(1)\n时间：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1446467306","body":"```javascript\r\nvar maxDepth = function(root) {\r\n    return depthFn(root, 0);\r\n};\r\nvar depthFn = function(root, depth) {\r\n    if(!root) return depth;\r\n    depth++;\r\n    const left = depthFn(root.left, depth);\r\n    const right = depthFn(root.right, depth);\r\n    return Math.max(left, right);\r\n}\r\n```\r\n### 思路\r\n深度优先递归算法\r\n\r\n### 复杂度\r\n空间：O(N)\r\n时间：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446448708","body":"```javacript\nvar isSameTree = function (p, q) {\n    if (p === null && q === null) return true;\n    if (p === null || q === null) return false;\n    if (p.val !== q.val) return false;\n    if (isSameTree(p.left, q.left) && isSameTree(p.right, q.right)) return true;\n    return false;\n};\n```\n### 思路：\n深度优先递归算法\n### 复杂度分析：\n时间：O(min(m,n))\n空间：O(min(m,n))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448395139","body":"```javascript\nvar sumNumbers = function (root) {\n    if (!root) return 0;\n    return dfsNum(root, 0);\n};\nvar dfsNum = function (node, prev) {\n    if(!node) return 0;\n    const sum = prev * 10 + node.val;\n    if(!node.left && !node.right) return sum;\n    return dfsNum(node.left, sum) + dfsNum(node.right, sum)\n}\n```\n\n### 思路\n深度优先算法：\n递归结束条件：node节点不存在，返回0；node节点没有叶子结点，返回sum；\n\n### 复杂度：\nO(1) O(min(m,n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450351096","body":"```javascript\r\nvar findBottomLeftValue = function(root) {\r\n    let ret = root.val;\r\n    let curDepth = 0;\r\n    var dfs = (root, depth) => {\r\n    if(!root) return;\r\n    depth++;\r\n    dfs(root.left, depth);\r\n    dfs(root.right, depth);\r\n    if(curDepth < depth) {\r\n        curDepth = depth;\r\n        ret = root.val;\r\n    }\r\n}\r\n    dfs(root, 0);\r\n    return ret;\r\n};\r\n```\r\n\r\n### 思路\r\n深度优先搜索，记录当前节点深度\r\n\r\n### 复杂度\r\n时间 O（N）\r\n空间 O（N）","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456166298","body":"```javascript\nvar numberOfBoomerangs = function (points) {\n    let ret=0;\n    points.forEach(p => {\n        let map = new Map();\n        points.forEach(q => {\n            if (p !== q) {\n                const dist = Math.pow(p[0] - q[0], 2) + Math.pow(p[1] - q[1], 2);\n                map.set(dist, (map.get(dist) || 0) + 1);\n            }\n        })\n        map.forEach((v) => {\n            ret += v * (v - 1);\n        })\n    })\n    return ret;\n};\n```\n\n### 思路：\n利用map保存路径次数，通过公式计算总共满足条件的次数\n\n### 复杂度：\n时间：O(n^2)\n空间：O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465228672","body":"```javascript\nvar searchInsert = function (nums, target) {\n    let ret;\n    for(let i = 0; i< nums.length;i++){\n        if (nums[i] >= target) {\n            ret = i;\n            return ret;\n        } \n    }\n    return nums.length;\n};\n\n```\n\n### 思路：\n遍历数组，当数值>=target时则为应当插入的位置，即返回index\n否则插入最后位置，即返回数组长度\n\n### 复杂度：\n空间：O(1)\n时间：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufanzh":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1430340398","body":"# intuition: convert k to list of num, then add backwards\n# tc: o(n)\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # first convert k to array \n        # then use carrier to add backwards\n        k_list = list(map(int, str(k))) #map(func, iter)\n        # print(k_list)\n        # now we add backwards\n        i = len(num) - 1\n        j = len(k_list) - 1\n        carry = 0\n        ans = []\n        while i >= 0 or j >= 0:\n            a = num[i] if i >= 0 else 0 \n            b = k_list[j] if j >= 0 else 0\n            val = a + b + carry\n            carry = val // 10\n            i -= 1\n            j -= 1\n            ans.append(val%10)\n        # now ans is in reversed order\n        if carry != 0:\n            ans.append(carry)\n        ans.reverse()\n        return ans\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430315284","body":"#forward and backward array traverse\n# tc: o(n) since we traverse the array without nest\n# sc: o(n) for initialize ans array\n\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = [float('inf')] * len(s)\n        # traverse forward and backward to get two list, first the min value between those two list\n        # correct way to initialize ans\n        ans = [0 if s[i] == c else None for i in range(len(s))] # 0 means distance\n        # forward scan\n        for i in range(1, len(s)):\n            if ans[i] != 0 and ans[i-1] is not None:\n                ans[i] = ans[i-1] + 1\n                # if i index is not c, and previous distance has value\n        \n        # backward scan\n        for i in range(len(s)-2, -1, -1):\n            if ans[i] is None or ans[i] > ans[i+1] + 1:\n                ans[i] = ans[i+1] + 1 # not updated yet or value larger than backward scan\n        return ans\n\n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1431948381","body":"```\r\nclass CustomStack:\r\n# keep a separate increment array to add only on the boundary\r\n    def __init__(self, maxSize: int):\r\n        self.max = maxSize\r\n        self.stack = []\r\n        self.incr = []\r\n        \r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max:\r\n            self.stack.append(x)\r\n            self.incr.append(0)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) == 0:\r\n            return -1 # empty stack\r\n        if len(self.stack) > 1:\r\n            self.incr[-2] += self.incr[-1]\r\n        return self.stack.pop() + self.incr.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.incr:\r\n            idx = min(k, len(self.incr))\r\n            self.incr[idx - 1] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1435771409","body":"```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        # example using stack 32[a]2[bc]\n        # ch in s can be under the following four situations\n        # digit, [, letter, ]\n        ans = \"\"\n        stack = []\n        num = 0\n        for ch in s:\n            if ch.isdigit():\n                num = num * 10 + int(ch)\n            elif ch == \"[\":\n                # we put previous string/num to stack\n                stack.append(ans)\n                stack.append(num)\n                ans = \"\"\n                num = 0\n            elif ch.isalpha():\n                ans += ch\n            elif ch == \"]\":\n                # pop out from stack\n                preNum = stack.pop()\n                preString = stack.pop()\n                ans = preString + preNum * ans\n        return ans\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435773907","body":"```\nclass MyQueue:\n# QUEUE: FIFO\n# STACK: LIFO\n    def __init__(self):\n        #use an out stack for pop function \n        self.instk = []\n        self.out = []\n\n    def push(self, x: int) -> None:\n        self.instk.append(x)\n\n    def pop(self) -> int:\n        if not self.out:\n            while self.instk:\n                val = self.instk.pop()\n                self.out.append(val)\n        return self.out.pop()\n\n    def peek(self) -> int:\n        if not self.out:\n            while self.instk:\n                val = self.instk.pop()\n                self.out.append(val)\n        return self.out[-1]\n\n    def empty(self) -> bool:\n        return not self.out and (not self.instk)\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435769946","body":"* idea: monotonic stack keep max value for each chunk.\\n\n* tc: O(N), only need to traverse the array once.\n\n\n```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        # from the problem we know that, for all the chuncks\n        # max value of left must <= max value of right to make the sorted possible\n        # then we can maintain a monotonic stack, if num[i] >= stack[-1], we put it in. if nums[i] < stack[-1], then it must belong to some previous chunck, we need to pop up top of stack.\n        mono_stack = []\n        for num in arr:\n            if len(mono_stack) == 0 or mono_stack[-1] <= num:\n                mono_stack.append(num)\n            else:\n                ma = mono_stack[-1]\n                while mono_stack and num < mono_stack[-1]:\n                    ma = max(ma, mono_stack.pop())\n                    # !! add max value to stack, not number when we found those small values, stack should keep max value for each chunck\n                mono_stack.append(ma)\n            print(mono_stack)\n        return len(mono_stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436295396","body":"```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        # this has to split the linked list at k places --> consider slow-fast pointers\n        # edge case for linked list\n        if not head or not head.next or k == 0:\n            return head\n        # based on constraint, k is not necessarily smaller than length of node, so there can be multiples, we want to get the mod to be more efficient\n        # step 1, get the length of the linked list first\n        length = 1\n        p0 = head\n        while p0.next:\n            p0 = p0.next\n            length += 1\n        k = k % length\n\n        # now use fast slow pointers to find the k places\n        p_slow = head\n        p_fast = head\n        while k > 0:\n            p_fast = p_fast.next\n            k -= 1\n        while p_fast.next:\n            p_fast = p_fast.next\n            p_slow = p_slow.next\n        # now we reach the flip location\n        p_fast.next = head\n        res = p_slow.next\n        p_slow.next = None\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437503835","body":"two approaches: recursive and iteratively.\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # typical linked list problem: recursive & iterative\n        # method 1. recursive:\n        # p1 --> p2 --> rest\n        # p2 --> p1 --> rest\n        # # edge case\n        # while not head or not head.next:\n        #     return head\n        # p1 = head\n        # p2 = head.next\n        # p1.next = self.swapPairs(p2.next)\n        # p2.next = p1\n        # return p2\n\n        # method 2. iteratively\n        # keep point1, 2 to move and swap p1 --> p2 --> next\n        while not head or not head.next:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head\n        p0 = dummy\n        while p0 and p0.next and p0.next.next:\n            p1 = p0.next\n            p2 = p0.next.next\n            # start to swap\n            p1.next = p2.next\n            p2.next = p1\n            p0.next = p2\n            p0 = p1\n        return dummy.next\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441229309","body":"```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        # two pointers\n        p1 = headA\n        p2 = headB\n      #the critical part is headA and headB doesn't necessarily meet at intersection after same steps\n    #One way to do it is to tranverse headA to headB, and then tranverse headB to headA, then their intersection will both appear in the end (or as nullptr)\n        while p1 != p2:\n            if p1 == None:\n                p1 = headB\n            else:\n                p1 = p1.next\n            if p2 == None:\n                p2 = headA\n            else:\n                p2 = p2.next\n        return p1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1444088358","body":"```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        #slow fast pointer\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if fast == slow:\n                break\n        \n        #no circle condition\n        if fast == None or fast.next == None:\n            return None\n        fast = head\n        while slow != fast:\n            slow = slow.next\n            fast = fast.next\n        return slow\n        ``","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1443952771","body":"```\n# hashmap + doubly linked list\n# hashmap key: key, value: doubly linked node\n# create a doubly linked node class for convenience\nclass Node:\n    def __init__(self, key, val):\n        \"\"\" The node class store(key, val)\n            this Node is a doubly linked node,\n            so it should also initialize prev and next pointer\n        \"\"\"\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        #initialize a hashmap and a doubly linked list\n        self.cap = capacity\n        self.cache = {}\n\n        # initialize two nodes to define boundary\n        self.left = Node(0, 0) # lru  \n        self.right = Node(0, 0) # mru\n        # generate doubly linked list\n        self.left.next = self.right\n        self.right.prev = self.left\n        \n    def get(self, key: int) -> int:\n        \"\"\"\" if key exists, return its value and insert it to mru node\n            if key not exists, return -1\n        \"\"\"\n        if key not in self.cache:\n            return -1\n        else:\n            self.remove(self.cache[key])\n            self.insert(self.cache[key])\n            return self.cache[key].val\n        \n\n    def put(self, key: int, value: int) -> None:\n        \"\"\" if key exists, we need to remove and re-insert to mru\n            if key not exists, just insert to mru\n            we also need to deal with exceeding capacity situation\n        \"\"\"\n        if key in self.cache:\n            self.remove(self.cache[key])\n        # put to hashmap\n        self.cache[key] = Node(key, value)\n        self.insert(self.cache[key])\n\n        if len(self.cache) > self.cap:\n            # remove lru first\n            lru = self.left.next\n            self.remove(lru)\n            del self.cache[lru.key]\n    \n    def insert(self, node: Node) -> None:\n        \"\"\" insert node before mru\n            example a <-> node <--> right\n        \"\"\"\n        prv = self.right.prev\n        prv.next = node\n        node.prev = prv\n        node.next = self.right\n        self.right.prev = node\n    \n    def remove(self, node: Node) -> None: \n        \"\"\" remove node from a doubly linked list\n            example a <-> b <-> c\n        \"\"\"\n        prv = node.prev \n        nxt = node.next\n        prv.next = nxt\n        nxt.prev = prv \n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445250726","body":"```\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445449384","body":"```\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        # recursive way, get the base case first\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val == q.val:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448406594","body":"```\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        # recursive way\n        if not root:\n            return 0\n        return self.helper(root, 0)\n    \n    def helper(self, node, cur):\n        if not node:\n            return 0\n        cur = cur * 10 + node.val\n        if not node.left and not node.right:\n            return cur\n        return self.helper(node.left, cur) + self.helper(node.right, cur)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1448988577","body":"```\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        # what's the best way to keep track of the layer depth? --> BFS, as the queue record the leftmost value in the head of the queue\n        queue = collections.deque()\n        queue.append(root)\n        while queue:\n            nlen = len(queue)\n            ans = queue[0].val\n            for i in range(nlen):\n                cur = queue.popleft()\n                if cur.left:\n                    queue.append(cur.left)\n                if cur.right:\n                    queue.append(cur.right)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1450976879","body":"```\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        # post order to convert bt to string\n        if not root:\n            return \"#,\"\n        l = self.serialize(root.left)\n        r = self.serialize(root.right)\n        return str(root.val) + \",\" + l + r\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        # pre order to convert string back to bt\n        # use dfs + deque\n        def dfs(queue):\n            if len(queue) == 0:\n                return None\n            curVal = queue.popleft()\n            if curVal == \"#\":\n                return None\n            root = TreeNode(curVal)\n            root.left = dfs(queue)\n            root.right = dfs(queue)\n            return root\n        \n        if data == \"#\":\n            return None\n        queue = deque(data.split(\",\"))\n        return dfs(queue)\n        \n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453742916","body":"tc: o(nlogn) due to sort\nsc: o(n)\n```\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        # bfs + deque\n        que = collections.deque()\n        que.append((root, 0, 0)) # add in node, col, row\n        # keep track of the max col while performing bfs\n        minCol = float('inf')\n        maxCol = float('-inf')\n\n        col_dict = collections.defaultdict(list) # key: col, val:node and row\n        while que:\n            node, col, row = que.popleft()\n            minCol = min(minCol, col)\n            maxCol = max(maxCol, col)\n            \n            col_dict[col].append((row, node.val))\n            \n            if node.left:\n                que.append((node.left, col-1, row+1))\n            \n            if node.right:\n                que.append((node.right, col+1, row+1))\n        \n        res = []\n        for col in range(minCol, maxCol+1):\n            tmp = []\n            for val in sorted(col_dict[col]):\n                tmp.append(val[1])\n            res.append(tmp)\n\n        return res\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1454850914","body":"use minHeap for this problem.\\n\ntc: O(nlogn)\nsc:O(k)\n```\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        # k most frequency elements\n        pq = [] # sort by frequency\n        freqCnt = Counter(nums)\n        for num, freq in freqCnt.items():\n            if len(pq) < k:\n                heapq.heappush(pq, (freq, num))\n            else:\n                heapq.heappushpop(pq, (freq, num))\n        return [num for freq, num in pq]\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459401186","body":"because we have the same size of data, sliding window jump by word length, not by 1\n```\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        #tricking part \n        #==> we are searching by word not character\n        # so r/l pointer will jump by one_word length m\n        # in that case, if we start from 0, we will be missing 1, 2, ...m-1 checking\n        #Thus, we will need to traverse 0 to m and do sliding window search to return all the starting indices\n        oneLen = len(words[0])\n        n = len(words)\n        target = collections.defaultdict(int)\n        for word in words:\n            target[word] += 1\n        \n        res = []\n        for i in range(oneLen):\n            match = 0\n            l = r = i\n            window = collections.defaultdict(int)\n            while r <= len(s) - oneLen:\n                rword = s[r:r+oneLen]\n                if rword in target:\n                    window[rword] += 1\n                    if window[rword] == target[rword]:\n                        match += 1\n                r += oneLen\n                while match == len(target):\n                    # return condition\n                    if r - l == oneLen * n:\n                        res.append(l)\n                    lword = s[l : l+oneLen]\n                    if lword in target:\n                        window[lword] -= 1\n                        if window[lword] < target[lword]:\n                            match -= 1\n                    l += oneLen\n        return res\n\n```\n\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463283279","body":"```\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        #slow fast pointer\n        dummy = ListNode(0)\n        dummy.next = head\n        slow = dummy.next\n        fast = dummy.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465025368","body":"```\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        # binary search\n        # wrong for this case [1,3,5,6], 7\n        left = 0\n        right = len(nums) - 1\n        while left + 1 < right:\n            mid = (left + right) // 2\n            if nums[mid] >= target:\n                right = mid\n            elif nums[mid] < target:\n                left = mid\n        if nums[right] < target:\n            return right + 1\n        if nums[left] < target:\n            return left + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465288629","body":"To do it in O(1), consider using a monotonic stack(decreasing stack) so that max value is at the top of queue.\\n\nWe use a deque data structure in python so that when we exceeding the sliding window size, we can do popleft()\n```\nimport collections\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        # monotonic stack -- decreasing stack, so max value is at top of queue\n        mono = collections.deque()\n        ans = []\n\n        for i, num in enumerate(nums):\n            while mono and nums[mono[-1]] <= num:\n                mono.pop()\n            mono.append(i)\n            # when sliding window left, we pop the head of deque, that's why we stored the index\n            if mono[0] == i - k:\n                mono.popleft()\n            # when window size == k, we start to record and append max value to results\n            if i >= k - 1:\n                ans.append(nums[mono[0]])\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1466888949","body":"based on the requirement in the question,\\n\nthe judge should have outdegree of 0 and indegree of n-1.\n```\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        # topologic sort\n        graph = collections.defaultdict(list)\n        outdegree = collections.defaultdict(int)\n        for a, b in trust:\n            graph[b].append(a)\n            outdegree[a] += 1\n        for i in range(1, n+1):\n            if outdegree[i] == 0 and len(graph[i]) == n-1:\n                return i\n        return -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469351014","body":"```\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        # coloring using dfs for graph\n        graph = collections.defaultdict(list)\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n        # since disliked persons cannot be included in the same group\n        # we need to color them differently(different color <--> different group)\n        # red -- 1, blue -- (-1), not colored -- 0\n        colors = [0]*(n+1)\n        def dfs(pos, color):\n            colors[pos] = color\n            for u in graph[pos]:\n                if colors[u] == color:\n                    return False\n                if colors[u] == 0 and not dfs(u, -color):\n                    return False\n            return True\n        \n        for i in range(1, n+1):\n            if colors[i] == 0 and not dfs(i, 1):\n                return False\n        return True\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1472709039","body":"```\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        # simulation problem\n        # starting (0,0)\n        x = 0\n        y = 0\n        for move in moves:\n            if move == \"U\":\n                y += 1\n            if move == \"D\":\n                y -= 1\n            if move == \"L\":\n                x -= 1\n            if move == \"R\":\n                x += 1\n        return x == 0 and y == 0\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475115764","body":"```\nclass Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        # str and numberOfRounds\n        shh, smm = loginTime.split(\":\")\n        fhh, fmm = logoutTime.split(\":\")\n        start_time = int(shh)*60 + int(smm)\n        finish_time = int(fhh)*60 + int(fmm)\n        if start_time > finish_time:\n            finish_time += 24*60 # next day\n        n = math.floor(finish_time/15) - math.ceil(start_time/15)\n        if n <= 0:\n            return 0\n        else:\n            return n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475403712","body":"```\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        # simulation three conditions\n        a_cnt = collections.Counter(a)\n        b_cnt = collections.Counter(b)\n        def greater_cost(a_cnt, b_cnt):\n            ans = len(a) + len(b)\n            for i in range(1, 26):\n                count = 0\n                for j in range(i):\n                    # change minimum value \n                    count += a_cnt[chr(97+j)]\n                for j in range(i, 26):\n                    count += b_cnt[chr(97+j)]\n                ans = min(ans, count)\n            return ans\n        def equal_cost(a_cnt, b_cnt):\n            ans = len(a) + len(b)\n            for i in range(26):\n                ans = min(ans, len(a) + len(b) - a_cnt[chr(97+i)] - b_cnt[chr(97+i)])\n            return ans\n        return min(greater_cost(a_cnt, b_cnt), greater_cost(b_cnt, a_cnt), equal_cost(a_cnt, b_cnt))\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"franciszq":[null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431327395","body":"## 思路\n\n求最短距离，一维数据的话，需要从前往后，从后往前各自遍历一遍，然后每个位置，取较小的一个。\n\n## 代码\n\n~~~c++\nclass Solution\n{\npublic:\n    vector<int> shortestToChar(string s, char c)\n    {\n        vector<int> from_begin_length, from_end_length, res;\n        int length_tmp = 999999;\n        for (int i = 0; i < s.size(); ++i) {    // 从头遍历\n            if (s[i] == c) {\n                length_tmp = 0;\n            } else {\n                length_tmp++;\n            }\n            from_begin_length.emplace_back(length_tmp);\n        }\n        length_tmp = 9999999;\n        for (int i = s.size() - 1; i >= 0; --i) {     // 从尾遍历\n            if (s[i] == c) {\n                length_tmp = 0;\n            } else {\n                length_tmp++;\n            }\n            from_end_length.emplace_back(length_tmp);\n        }\n        for (int i = 0; i < s.size(); ++i) {\n            if (from_begin_length[i] < from_end_length[s.size() - i - 1]) {\n                res.emplace_back(from_begin_length[i]);\n            } else {\n                res.emplace_back(from_end_length[s.size() - i - 1]);\n            }\n        }\n        return res;\n    }\n};\n\n\n\n\n~~~\n\n## 复杂度\n\n* 时间复杂度O(3n)\n* 空间复杂度O(3n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432964991","body":"## 思路\n\n用数组来模拟栈。\n\n## 代码\n\n~~~c++\nclass CustomStack\n{\npublic:\n    CustomStack(int maxSize)\n    {\n        max_size = maxSize;\n        stack.reserve(max_size);\n    }\n\n    void push(int x)\n    {\n        if (stack.size() >= max_size) {\n            return;\n        }\n        stack.emplace_back(x);\n    }\n\n    int pop()\n    {\n        if (stack.size() > 0) {\n            int val = stack.back();\n            stack.pop_back();\n            return val;\n        } else {\n            return -1;\n        }\n\n    }\n\n    void increment(int k, int val)\n    {\n        int add_size = min(k, int(stack.size()));\n        for (int add_id = 0; add_id < add_size; ++add_id) {\n            stack[add_id] = stack[add_id] + val;\n        }\n    }\nprivate:\n    vector<int> stack;\n    int max_size;\n    int cur_size;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n~~~\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434671781","body":"## 思路\n\n自己没有想出来，看题解的。思想如下：\n\n* 遍历字符串，使用栈来存储需要的信息，并且记录当前遍历的位置id\n* 如果遇到数字，则需要找连续的数字，然后放到栈当中\n* 遇到字母和\"[\"，就放到栈当中\n\n重点：\n\n* 遇到 \"]\"，说明之前栈中的肯定全是字母，直到遇到“[”，把字母全部取出来\n* “【”前面肯定是数字，把数字取出来，然后将取出来的字母拼起来，重复数字的数倍，再push进栈中\n* 直到遍历完整个字符串，栈中肯定全是字母，拼起来后return。\n\n#### 注意点\n\n* id的增加\n* 取出的字母要翻转一下。\n\n## 代码\n\n~~~c++\nclass Solution {\npublic:\n    std::string get_digit(string& s, int& id)\n{\n    std::string s_digit;\n    while (isdigit(s[id])) {\n        s_digit += s[id++];\n    }\n    return s_digit;\n}\n\nstd::string get_string(std::vector<std::string>& stk)\n{\n    std::string res;\n    for (auto s : stk) {\n        res += s;\n    }\n    return res;\n}\n\nstring decodeString(string s)\n{\n    std::vector<std::string> stk;\n    int id = 0;\n    while (id < s.size()) {\n        if (isdigit(s[id])) {\n            stk.push_back(get_digit(s, id));\n        } else if (isalpha(s[id]) || s[id] == '[') {\n            stk.push_back(std::string(1, s[id++]));\n        } else {     //\n            id++;\n            std::vector<std::string> v_str;\n            while (stk.back() != \"[\") {\n                v_str.push_back(stk.back());\n                stk.pop_back();\n            }\n            reverse(v_str.begin(), v_str.end());\n            stk.pop_back();   // 左括号出栈\n            int rep_time = stoi(stk.back());\n            stk.pop_back();\n            std::string sub_str = get_string(v_str);\n            std::string t;\n            for (int i = 0; i < rep_time; ++i) {\n                t += sub_str;\n            }\n            stk.push_back(t);\n        }\n    }\n    return get_string(stk);\n}\n};\n~~~\n\n## 复杂度\n\n* 时间复杂度O(n)\n* 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435667304","body":"## 思路\n\n两个栈，一个做入栈，一个做出栈\n\n出栈的数据来自于入栈，当出栈为空时，将入栈的数据全部塞进出栈。\n\n\n\n## 代码\n\n~~~c++\nclass MyQueue\n{\npublic:\n    MyQueue()\n    {\n\n    }\n\n    void push(int x)\n    {\n        stk_in.push(x);\n    }\n\n    int pop()\n    {\n        if (stk_in.empty() && stk_out.empty()) {\n            return -1;\n        }\n        if (stk_out.empty()) {\n            while (!stk_in.empty()) {\n\n                stk_out.push(stk_in.top());\n                stk_in.pop();\n            }\n        }\n        int tmp = stk_out.top();\n        stk_out.pop();\n        return tmp;\n    }\n\n    int peek()\n    {\n        if (stk_out.empty()) {\n            while (!stk_in.empty()) {\n                int nub = stk_in.top();\n                stk_in.pop();\n                stk_out.push(nub);\n            }\n        }\n        return stk_out.top();\n    }\n\n    bool empty()\n    {\n        if (stk_in.empty() && stk_out.empty()) {\n            return true;\n        }\n        return false;\n    }\n\nprivate:\n    std::stack<int> stk_in;\n    std::stack<int> stk_out;\n};\n\n~~~\n\n## 复杂度\n\n* 时间复杂度O(1)\n* 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435995510","body":"## 思路\n\n第一个靠自己过hard难度的题目的，也是挺兴奋的。\n\n这题感觉就是找规律，一开始的思想是如何找出一种分法，则必须前面一块的数字都要比后面一块小，概况就是前面一块的最大值，比后面一块的最小值都要小，则就可以分开。\n\n细想一下，就是遍历整个数组，按遍历到的数字分为前面和后面，只要前面的最大值小于后面的最小值，则就是一种分法。但是直接这么做，复杂度有点高，因此，想到的如下的方式。\n\n* 从前往后遍历，找到每一位之前最大的数字，记录下来到max_size。\n* 从后往前遍历，找到每一位之前最小的数字，记录下来到min_size\n* 遍历比较max_size[i]和min_size[i+1]，如果max_size[i] <=min_size[i+1]，则结果+1。\n\n#### 注意点\n\n* 结果从1开始累加\n\n## 代码\n\n~~~c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int arr_size = arr.size();\n        if(arr_size == 1)\n        {\n            return 1;\n        }\n        int res = 1;\n        vector<int> max_size(arr_size, 0);\n        vector<int> min_size(arr_size, 0);\n        max_size[0] = arr[0];\n        min_size[arr_size-1] = arr[arr_size-1];\n        for(int i = 1; i < arr_size; ++i)\n        {\n            if (arr[i] > max_size[i-1])\n            {\n                max_size[i] = arr[i];\n            }\n            else\n            {\n                max_size[i] = max_size[i-1];\n            }\n            if (arr[arr_size-i-1] < min_size[arr_size-i])\n            {\n                min_size[arr_size-1-i] = arr[arr_size-i-1];\n            }\n            else\n            {\n                min_size[arr_size-1-i] = min_size[arr_size-i];\n            }\n        }\n        for(int i = 0; i < arr_size-1; ++i)\n        {\n            if (max_size[i] <= min_size[i + 1])\n            {\n                res++;\n            } \n        }\n        return res;\n    }\n};\n~~~\n\n## 复杂度\n\n* 时间复杂度O(3n)\n* 空间复杂度O(2n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436863915","body":"## 思路\r\n\r\n就是截断链表，重新换个链表头，并且原来的尾巴指向原来的表头。步骤如下\r\n\r\n* 先计算链表的长度size\r\n* 如果k大于size的话，会有重复，所以用k%size，得到的值，就是移动的距离move_size\r\n* 找到4个节点：原来的表头，原来的表尾，原来的size-move_size-1的节点（cut_node），size-move_size的节点（新的表头）。\r\n* 表尾next指向表头，size-move_size-1；cut_node的next指向null。返回size-move_size的节点\r\n\r\n#### 注意点\r\n\r\n* if (head == nullptr || head->next == nullptr || k == 0)的话，直接返回head\r\n\r\n* k%size == 0的话，不旋转\r\n\r\n## 代码\r\n\r\n~~~c++\r\nclass Solution\r\n{\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k)\r\n    {\r\n        if (head == nullptr || head->next == nullptr || k == 0) {\r\n            return head;\r\n        }\r\n        ListNode* first_node = head;\r\n        int list_size = 1;\r\n        while (head->next != nullptr) {\r\n            head = head->next;\r\n            list_size++;\r\n        }\r\n        ListNode* last_node = head;\r\n        int rotate_size = k % list_size;\r\n        if (rotate_size == 0) {\r\n            return first_node;\r\n        }\r\n        ListNode* cut_node = first_node;\r\n        for (int i = 0; i < list_size - rotate_size - 1; ++i) {\r\n            cut_node = cut_node->next;\r\n        }\r\n        head = cut_node->next;\r\n        last_node->next = first_node;\r\n        cut_node->next = nullptr;\r\n        return head;\r\n\r\n    }\r\n};\r\n~~~\r\n\r\n## 复杂度\r\n\r\n* 时间复杂度O(n)\r\n* 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438594311","body":"## 思路\n\n加虚拟头，就是每两个节点交换。只要记录4个节点：head，first_head，second_head，next_head。\n\n然后head指向second_head，second_head指向first_head，first_head指向next_head。\n\n#### 注意点\n\n无。\n\n## 代码\n\n~~~c++\nListNode* swapPairs(ListNode* head)\n    {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        ListNode* virtual_head = new ListNode;\n        virtual_head->next = head;\n        head = virtual_head;\n        while (head->next && head->next->next) {\n            ListNode* first_node = head->next;\n            ListNode* second_node = head->next->next;\n            ListNode* next_first = head->next->next->next;\n            head->next = second_node;\n            second_node->next = first_node;\n            first_node->next = next_first;\n            head = head->next->next;\n        }\n\n        return virtual_head->next;\n    }\n~~~\n\n## 复杂度\n\n* 时间复杂度O(n)\n* 空间复杂度O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441633538","body":"## 思路\n\n又是想不出来的一道题，看的官方解答。\n\n最基础的就是多对多的遍历，但是时间复杂度为O（m*n），肯定不行。\n\n简答的方法是两个指针，然后同时从A，B开始遍历，各自遍历完后，去遍历另一个指针，因为如果有相交，碰到同一个指针，则就是相交点。\n\n因为如果有相交，则A相交前有3个点，B相交前有5个点，相交后都有2个点，则按上面那种方式，会同时走3+2+5。\n\n#### 注意点\n\n无。\n\n## 代码\n\n~~~c++\nListNode* getIntersectionNode(ListNode* headA, ListNode* headB)\n    {\n        if (headA == nullptr || headB == nullptr) {\n            return nullptr;\n        }\n        ListNode* headA_run = headA;\n        ListNode* headB_run = headB;\n        while (headA_run != headB_run) {\n            headA_run = headA_run == nullptr ? headB : headA_run->next;\n            headB_run = headB_run == nullptr ? headA : headB_run->next;\n        }\n\n        return headA_run;\n    }\n~~~\n\n## 复杂度\n\n* 时间复杂度O(m+n)\n* 空间复杂度O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445376584","body":"## 思路\n\nDFS，等于左右两个子树中最大的+1.\n\n#### 注意点\n\n无。\n\n## 代码\n\n~~~c++\nint maxDepth(TreeNode* root) {\n    if (root == nullptr)\n    {\n        return 0;\n    }\n    return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n}\n~~~\n\n## 复杂度\n\n* 时间复杂度O(n)\n* 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446262187","body":"## 思路\n\nDFS\n\n#### 注意点\n\n如果两个都为空，则返回true，如果有一个为空，则false，如果值不一样，则false\n\n## 代码\n\n~~~c++\nbool isSameTree(TreeNode* p, TreeNode* q)\n{\n    if (p == nullptr && q == nullptr) {\n        return true;\n    }\n    if (p == nullptr || q == nullptr) {\n        return false;\n    }\n    if (p->val != q->val) {\n        return false;\n    }\n    return (isSameTree(p->left, q->left) && isSameTree(p->right, q->right));\n}\n~~~\n\n## 复杂度\n\n* 时间复杂度O(n)\n* 空间复杂度O(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1454955640","body":"## 思路\n\n* 先用map来进行出现字数的存储\n* 对出现次数进行排序，由于时间复杂度的要求，需要使用堆排序，因此使用优先队列来进行排序，其内部使用的就是堆。\n\n#### 注意点\n\n\n\n## 代码\n\n~~~c++\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n\tmap<int, int> fre_map;\n\tfor (auto num : nums)\n\t{\n\t\tfre_map[num]++;\n\t}\n\tpriority_queue<pair<int, int>> que;\n\tfor (auto it : fre_map)\n\t{\n\t\tque.emplace(it.second, it.first);\n\t}\n\tvector<int> res;\n\tfor (int i = 0; i < k ; i++)\n\t{\n\t\tres.push_back(que.top().second);\n\t\tque.pop();\n\t}\n    return res;\n}   \n};\n~~~\n\n## 复杂度\n\n* 时间复杂度O(nlogn)\n* 空间复杂度O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1458178441","body":"## 思路\n\n* 遍历字符串，从前往后找最长的无重复的字串，\n* 使用双指针的方式，两个指针之间的，就是当前最长的字串。\n* 一开始都指向第一个，获得last指针后面指向的字符，如果之前字串中没有，则llast指针向后一个，并且更新最长字串，得到当前的字符串大小，如果比之前的大，则更新。\n* 如果之前的字串中有，则first指针向前走一个。\n* 循环知道last指向最后一个字符。\n\n#### 注意点\n\n\n\n## 代码\n\n~~~c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s)\n{\n    if (s.size() == 0) {\n        return 0;\n    }\n    int first_id = 0;\n    int last_id = 0;\n    int str_size = s.size();\n    int res = 1;\n    string sub_str = s.substr(first_id, last_id - first_id + 1);\n    while (last_id != str_size - 1) {\n        string next_str = s.substr(last_id + 1, 1);\n        if (sub_str.find(next_str) == string::npos) { // 没找到\n            last_id++;\n            sub_str = s.substr(first_id, last_id - first_id + 1);\n            if (sub_str.size() > res) {\n                res = sub_str.size();\n            }\n        } else {\n            first_id++;\n            sub_str = s.substr(first_id, last_id - first_id + 1);\n        }\n    }\n    return res;\n}\n};\n~~~\n\n## 复杂度\n\n* 时间复杂度O(n)\n* 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460113683","body":"## 思路\n\n* 一路思考下来，就是判断一个字符串与一组字符串之间是否完全相等。\n* 一开始想遍历字符串组来匹配字串，但是发现，这个方式不太行，因此匹配字串的时候，会从任意一个id开始。\n* 后来拆分字串来匹配字符串数组：方式就是使用一个map来存放数组中每个字符串出现的次数，然后遍历拆分的字串，map[拆分的]--。\n* 如果map正好全部为0，则是相等的。\n\n#### 注意点\n\n\n\n## 代码\n\n~~~c++\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words)\n{\n    vector<int> res;\n    if (s.size() == 0 || words.size() == 0) {\n        return res;\n    }\n    int words_num = words.size();\n    int single_word_size = words[0].size();\n    int sub_str_size = words_num * single_word_size;\n    if (s.size() < sub_str_size) {\n        return res;\n    }\n    map<string, int> map_word;\n    for (int i = 0; i < words.size(); ++i) {\n        map_word[words[i]]++;\n    }\n\n    for (int i = 0; i <= s.size() - sub_str_size; ++i) {\n        map<string, int> map_word_tmp = map_word;\n        for (int word_id = 0; word_id < words_num; ++word_id) {\n            string sub_str = s.substr(i + word_id * single_word_size, single_word_size);\n            map_word_tmp[sub_str]--;\n            if (map_word_tmp[sub_str] < 0) {\n                break;\n            }\n            if (map_word_tmp[sub_str] == 0) {\n                map_word_tmp.erase(sub_str);\n            }\n\n        }\n        if (map_word_tmp.size() == 0) {\n            res.push_back(i);\n        }\n    }\n    return res;\n}\n};\n~~~\n\n## 复杂度\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463888365","body":"## 思路\n\n快慢指针\n\n#### 注意点\n\n\n\n## 代码\n\n~~~c++\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head)\n{\n    ListNode* quick_node = head;\n    ListNode* slow_node = head;\n    while (quick_node != nullptr && quick_node->next != nullptr) {\n        quick_node = quick_node->next->next;\n        slow_node = slow_node->next;\n    }\n    return slow_node;\n}\n};\n~~~\n\n## 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464896823","body":"## 思路\n\n整体思路：遍历数组，把不相同的数组放进原始数组，如果重复的，则跳过。需要两个额外空间，一个是修改后的数组的位置，一个是当前数字，因为已经是排序过的，所以重复出现的肯定是相邻的。\n\n#### 注意点\n\n\n\n## 代码\n\n~~~c++\nint removeDuplicates(vector<int>& nums)\n{\n    if (nums.size() == 0 || nums.size() == 1) {\n        return nums.size();\n    }\n    int res = 1;\n    int compare_num = nums[0];\n    for (int i = 1; i < nums.size(); ++i) {\n        if (nums[i] != compare_num) {\n            nums[res++] = nums[i];\n            compare_num = nums[i];\n        }\n    }\n    return res;\n}\n~~~\n\n## 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465097018","body":"## 思路\n\n#### 注意点\n\n\n\n## 代码\n\n~~~c++\nint searchInsert(vector<int>& nums, int target) {\n        if (nums.size() == 0)\n        {\n            return 0;\n        }\n        if (target <= nums[0])\n        {\n            return 0;\n        }\n        if (target == nums[nums.size()-1])\n        {\n            return nums.size()-1;\n        }\n        if (target > nums[nums.size()-1])\n        {\n            return nums.size();\n        }\n        for(int i = 0; i < nums.size()-1; ++i)\n        {\n            if (target == nums[i])\n            {\n                return i;\n            }\n            if (target > nums[i] && target < nums[i+1])\n            {\n                return i + 1;\n            }\n        }\n        return 0;\n    }\n~~~\n\n## 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468104278","body":"## 思路\n\n图的知识，被信任的人当作input，信任的人当作output\n\n#### 注意点\n\n\n\n## 代码\n\n~~~c++\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust)\n{\n        if (trust.size() == 0 && n == 1) {\n        return 1;\n    }\n    vector<int> in_array(n + 1);\n    vector<int> out_array(n + 1);\n    for (int i = 0; i < trust.size(); ++i) {\n        int out_num = trust[i][0];\n        int in_num = trust[i][1];\n        in_array[in_num]++;\n        out_array[out_num]++;\n    }\n    for (int i = 0; i <= n; ++i) {\n        if (in_array[i] == n - 1 && out_array[i] == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n};\n~~~\n\n## 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kangqinsen":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1431529917","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode.cn/problems/add-to-array-form-of-integer/\n\n## 思路\n\n两数相加，从后往前，两数遍历完最后看carry。\n其中一个数遍历完，后续取0。\n最后reverse下。\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new ArrayList<>();\n        int c = 0;\n\n        int i = num.length-1 ; \n\n        int carry = 0;\n        while(i>=0 || k >0){\n          int ki = k % 10;\n          int numi = i >= 0 ? num[i] : 0;\n\n          k /= 10;\n          i--;\n\n          int sum = (ki + numi + carry) ;\n          carry = sum / 10;\n          ans.add(sum%10);\n        }\n        if(carry>0){\n          ans.add(carry);\n        }\n        List<Integer> result = new ArrayList<>();\n        for(int idx = ans.size()-1 ; idx >= 0 ; idx --){\n          result.add(ans.get(idx));\n        }\n        return result;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431448135","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode.cn/problems/shortest-distance-to-a-character/\n\n\n## 思路\n两次循环，第一次从左到右，第二次从左到右，分别找到从左到右最小的距离和从右到校最小的距离，二者取最小\n## 关键点\n两次循环中，第一次从左到右，在找到第一个c之前，result[i] = 无限大，在第一次c之前的结果，在第二次循环从右到左一定能找到最近的c，且是最终答案。\n同理，从右到左，也是无限大。\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n      int size = s.length();\n      int[] result = new int[size];\n      int currentIndexC = -1*size;\n      for(int i = 0 ; i < size ; i++){\n        int ch = s.charAt(i);\n        if(ch == c){\n          currentIndexC = i;\n        }\n      result[i] = Math.abs(currentIndexC - i);\n      }\n\n      currentIndexC = size*2;\n      for(int i = size - 1 ; i >= 0 ; i--){\n        int ch = s.charAt(i);\n        if(ch == c){\n          currentIndexC = i;\n        }\n        result[i] = Math.min(result[i] , Math.abs(currentIndexC - i));\n      }\n      \n      return result;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437746965","body":"\n\n## 思路\n定义一个prev， 一个current（current 是 prev.next) 。保持prev不变，交换current和current.next 。 然后prev指向current(即交换后的next)\n## 关键点\nhead指针会变化的题，定义dummy。 dummy也是最开始的prev\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode prev = dummy;\n        ListNode current= dummy.next; \n        ListNode nextNode= null;\n        while(current != null && current.next != null){\n          nextNode = current.next;\n          prev.next = nextNode; \n          current.next = nextNode.next;\n          nextNode.next = current;\n\n          prev = current;\n          current = prev.next ; \n        }\n      \n        return dummy.next;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448170263","body":"\n## 题目地址(129. 求根节点到叶节点数字之和)\n\nhttps://leetcode.cn/problems/sum-root-to-leaf-numbers/\n\n## 前置知识\n二叉树的遍历-深度遍历\n- \n\n\n## 思路\n前序搜索的关键点\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int sum = 0 ; \n    public int sumNumbers(TreeNode root) {\n      if(root == null ){\n        return 0 ; \n      }\n      dfs(root , 0);\n      return sum;\n    }\n    private void dfs(TreeNode root , int val){\n      val*=10;\n      val+=root.val;\n      if(root.left == null && root.right == null){\n        sum+=val;\n      }\n      if(root.left != null){\n        dfs(root.left , val);\n      }\n      if(root.right != null){\n        dfs(root.right , val);\n      }\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"manwzy":[null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431519341","body":"/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\n\nvar shortestToChar = function(s, c) {\n  let i=-1,j=0,cur=0;\n  let res = []\n  while(i<s.length){\n    if(s[j]!==c && j<s.length){\n      j++\n      continue\n    }\n\n    if(i===-1){\n      cur = 0\n      while(cur<j){\n        res.push(j-cur++)\n      }\n    }else if(j===s.length){\n      cur = i\n      while(cur<j){\n        res.push(cur++-i)\n      }\n    }else{\n      cur = i\n      while(cur<j){\n        res.push(Math.min(cur-i,j-cur))\n        cur++\n      }\n    }\n    i=j\n    j++\n  }\n  return res\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436023615","body":"/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n  if(arr.length===1){\r\n    return 1\r\n  }\r\n  let minMaxRes = []\r\n  let currentMax = arr[0]\r\n  let currentMin = arr[0]\r\n  for(let i=1;i<arr.length;++i){\r\n    if(arr[i]>=currentMax){\r\n      minMaxRes.push(currentMin, currentMax)\r\n      currentMax = arr[i]\r\n      currentMin = arr[i]\r\n    }\r\n    currentMin = Math.min(arr[i], currentMin)\r\n  }\r\n  minMaxRes.push(currentMin, currentMax)\r\n\r\n  let length = minMaxRes.length / 2\r\n  for(let i=length-1;i>0;--i){\r\n    if(minMaxRes[i*2] < minMaxRes[i*2-1]){\r\n      //current max ,next min,need merge\r\n      length--\r\n      minMaxRes[i*2-1] = minMaxRes[i*2+1]\r\n      minMaxRes[i*2-2] = Math.min(minMaxRes[i*2],minMaxRes[i*2-2])\r\n    }\r\n  }\r\n\r\n  return length\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436034355","body":"/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n  if(k===0){\r\n    return head\r\n  }\r\n  let stash = []\r\n  let cur = head\r\n  \r\n  while(cur && k>0){\r\n    stash.push(cur.val)\r\n    cur = cur.next\r\n    k--\r\n  }\r\n  let i = 0\r\n\r\n  if(!cur && !k){\r\n    return head\r\n  }\r\n\r\n  if(!cur){\r\n    k%=stash.length\r\n    cur = head\r\n    while(cur){\r\n      cur.val = stash[(i+stash.length - k)%stash.length] \r\n      cur = cur.next\r\n      i++\r\n    }\r\n  }else{\r\n    while(cur){\r\n      stash.push(cur.val)\r\n      cur.val = stash[i] \r\n      cur = cur.next\r\n      i++\r\n    }\r\n    cur = head\r\n    while(i<stash.length){\r\n      cur.val = stash[i]\r\n      cur = cur.next\r\n      i++\r\n    }\r\n  }\r\n \r\n  return head\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437278469","body":"var swapPairs = function(cur) {\r\n  if(!cur || !cur.next){\r\n    return cur\r\n  }\r\n  let tmp = cur.next\r\n  cur.next = swapPairs(tmp.next)\r\n  tmp.next = cur\r\n  return tmp\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1438873574","body":"/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\n\r\nconst trans = (arr, start, end) => {\r\n  if(start > end){\r\n    return null\r\n  }\r\n  if(start === end){\r\n    return arr[start]\r\n  }\r\n  let i = start + Math.floor((end-start) / 2)\r\n  arr[i].left = trans(arr,start,i-1)\r\n  arr[i].right = trans(arr,i+1,end)\r\n  return arr[i]\r\n}\r\n\r\nvar sortedListToBST = function(head) {\r\n  if(!head){\r\n    return null\r\n  }\r\n  let arr = []\r\n  while(head){\r\n    arr.push(new TreeNode(head.val))\r\n    head = head.next\r\n  }\r\n\r\n  return trans(arr,0,arr.length-1)\r\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1446697320","body":"/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\n\r\nconst traves = (root,arr,res)=>{\r\n  if(!root.left && !root.right){\r\n    arr.push(root.val)\r\n    res.push(arr.reduce((sum,cur,index)=>{\r\n      sum+=cur*Math.pow(10,arr.length - index - 1)\r\n      return sum\r\n    },0))\r\n    arr.pop()\r\n    return\r\n  }\r\n  arr.push(root.val)\r\n  if(root.left){\r\n    traves(root.left,arr,res)\r\n  }\r\n  if(root.right){\r\n    traves(root.right,arr,res)\r\n  }\r\n  arr.pop()\r\n}\r\nvar sumNumbers = function(root) {\r\n  if(!root){\r\n    return 0\r\n  }\r\n  let res = []\r\n  let arr = []\r\n  traves(root,arr,res)\r\n  return res.reduce((sum,cur)=>{\r\n    sum+=cur\r\n    return sum\r\n  },0)\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1448502238","body":"/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\n\r\nvar traves = (node,depth)=>{\r\n  if(!node){\r\n    return null\r\n  }\r\n  const left = traves(node.left,depth+1)\r\n  const right = traves(node.right,depth+1)\r\n  if(!left && !right){\r\n    node.depth = depth\r\n  } else if(!right || (left && left.depth >= right.depth)){\r\n      node.depth = left.depth\r\n      node.val = left.val\r\n  } else {\r\n      node.depth = right.depth\r\n      node.val = right.val\r\n    }\r\n  \r\n  return node\r\n}\r\nvar findBottomLeftValue = function(root) {\r\n  return traves(root,0).val\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1450693261","body":"/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n\r\n/**\r\n * Encodes a tree to a single string.\r\n *\r\n * @param {TreeNode} root\r\n * @return {string}\r\n */\r\nvar serialize = function(root) {\r\n    if(!root){\r\n      return ''\r\n    }\r\n    let queue = [root],cur;\r\n    let res = '' + root.val\r\n    while(queue.length){\r\n      cur = queue.shift()\r\n      res += '*'\r\n      if(cur.left){\r\n        queue.push(cur.left)\r\n        res += cur.left.val\r\n      }else{\r\n        res+='N'\r\n      }\r\n      res += '*'\r\n      if(cur.right){\r\n        queue.push(cur.right)\r\n        res += cur.right.val\r\n      }else{\r\n        res+='N'\r\n      }\r\n    }\r\n    return res + '*'\r\n};\r\n\r\n/**\r\n * Decodes your encoded data to tree.\r\n *\r\n * @param {string} data\r\n * @return {TreeNode}\r\n */\r\nvar deserialize = function(data) {\r\n    if(!data){\r\n      return null\r\n    }\r\n    let queue=[],cur,left,right,head,i=0,res='';\r\n\r\n    const getData = ()=>{\r\n      res = ''\r\n      while(data[i]!==\"*\"){\r\n        res += data[i++]\r\n      }\r\n      i++\r\n      return res\r\n    }\r\n    \r\n    cur = getData()\r\n    head = cur = new TreeNode(cur)\r\n    queue.unshift(cur)\r\n   \r\n    while(queue.length){\r\n      cur = queue.shift()\r\n      left = getData()\r\n      if(left !== 'N'){\r\n        left = new TreeNode(left)\r\n        cur.left = left\r\n        queue.push(left)\r\n      }\r\n\r\n      right = getData()\r\n      if(right !== 'N'){\r\n        right = new TreeNode(right)\r\n        cur.right = right\r\n        queue.push(right)\r\n      }\r\n    }\r\n\r\n    return head\r\n};\r\n\r\n/**\r\n * Your functions will be called as such:\r\n * deserialize(serialize(root));\r\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1452299861","body":"/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number[][]}\r\n */\r\n\r\nconst traves = (root, res,row, col)=>{\r\n  if(!root){\r\n    return col\r\n  }\r\n  if(col === -1){\r\n    col++\r\n    res.unshift([])\r\n  }else if(col === res.length){\r\n    res.push([])\r\n  }\r\n\r\n  if(res[col][row]!==undefined){\r\n    if(!Array.isArray(res[col][row])){\r\n      res[col][row] = [res[col][row]]\r\n    }\r\n    res[col][row].push(root.val)\r\n  }else{\r\n    res[col][row] = root.val\r\n  }\r\n\r\n  col = traves(root.left,res,row + 1,col-1)\r\n  \r\n  col = traves(root.right, res ,row + 1, col + 2)\r\n\r\n  return col - 1\r\n}\r\nvar verticalTraversal = function(root) {\r\n  let res = [[]]\r\n  traves(root,res,0,0)\r\n  res = res.map(el=>el.reduce((data,cur)=>{\r\n    if(cur === undefined){\r\n      return data\r\n    }\r\n    if(Array.isArray(cur)){\r\n      cur.sort((a,b)=>a-b)\r\n      cur.forEach(tmp=>data.push(tmp))\r\n      return data\r\n    }\r\n\r\n    data.push(cur)\r\n    return data\r\n  },[]))\r\n  return res\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry9926":[null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431523338","body":"思路：\n1. 计算目标字符的下标数组\n2. 遍历字符串，计算每个字符与目标字符的距离\n3. 对比距离取最小值记录\n4. 输出\n\n```js\nvar shortestToChar = function(s, c) {\n    // i=目标字符的下标,e=结果\n    var i = [], e = []\n    s.split('').forEach(function(item, index) {\n        item == c && i.push(index)\n    })\n    s.split('').forEach(function(num, index) {\n        if (num == c) {\n            e.push(0)\n        } else {\n            // b=当前距离\n            var b = s.length\n            i.forEach(function(item) {\n                if (Math.abs(item-index) < b) {\n                    b = Math.abs(item-index)\n                }\n            })\n            e.push(b)\n        }\n    })\n    return e\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432601446","body":"时间复杂度\npush、pop=O(1)\nincrement=O(n)\n空间复杂度\nO(maxSize)\n\n```js\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.value=[]\n    this.maxSize=maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.value.length < this.maxSize) {\n        this.value.unshift(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.value.length === 0) {\n        return -1\n    }\n    return this.value.shift()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    var n=0\n    for (var i=this.value.length-1; i >= 0; i--) {\n        if (n < k) {\n            n++\n            this.value[i] = this.value[i] + val    \n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"soso1105":[null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431572670","body":"### 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        left = []\n        res = []\n        for i in range(len(s)):\n            if c == s[i]:\n                left.append(i)\n\n        for j in range(len(s)):\n            t = len(s)\n            for i in left:\n                t = min(abs(j-i), t)\n            res.append(t)\n        \n        return res\n```\n\n**复杂度分析**\n\n\\- 时间复杂度：O(N^2)\n\\- 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433263826","body":"### 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.currentSize = 0\n        self.storage = []\n\n    def push(self, x: int) -> None:\n        if self.currentSize < self.maxSize:\n            self.storage.append(x)\n            self.currentSize+=1\n\n    def pop(self) -> int:\n        if self.currentSize == 0:\n            return -1\n        self.currentSize-=1\n        return self.storage.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        incre_num = min(k, self.currentSize)\n        for i in range(incre_num):\n            self.storage[i] += val\n```\n\n**复杂度分析**\n\n\\- 时间复杂度：O(1)\n\\- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435705496","body":"### 代码\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.arr=[]\r\n    \r\n    def push(self, x: int) -> None:\r\n        self.arr.append(x)\r\n\r\n    def pop(self) -> int:\r\n        return self.arr.pop(0)\r\n\r\n    def peek(self) -> int:\r\n        return self.arr[0]\r\n        \r\n\r\n    def empty(self) -> bool:\r\n        return not self.arr\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450326674","body":"class Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        # dfs\n        curVal = curHeight = 0\n        def dfs(node,deep_num):\n            if node is None :\n                return \n            dfs(node.left,deep_num+1)\n            dfs(node.right,deep_num+1)\n            nonlocal curVal, curHeight\n            if  deep_num+1>curHeight:\n                curVal = node.val\n                curHeight = deep_num+1\n        dfs(root,0)\n        return curVal","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456313412","body":"class Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        if len(points)<3: return 0\n        \n        def cal_distance(p1: List[int], p2: List[int]):\n            return ((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)**(1/2)\n\n        def permutation(n, m=2):\n            return factorial(n)//factorial(n-m) if n>=2 else 0\n        \n        result = 0\n        for p1 in points:\n            distances = []\n            for p2 in points:\n                distances.append(cal_distance(p1, p2))\n            counter = Counter(distances) # hashmap\n            for n in counter.values():\n                result += permutation(n)\n        return result","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461196589","body":"class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        need = sum(nums) % p\n        store = {0: -1}\n        cur = 0\n        res = len(nums)\n        for i, num in enumerate(nums):\n            cur = (cur + num) % p\n            store[cur] = i\n            if (cur - need) % p in store:\n                res = min(res, i - store[(cur - need) % p])\n        return res if res < len(nums) else -1","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465448631","body":"class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        q = collections.deque() \n        ans = []\n        for i in range(len(nums)):\n            while q and nums[q[-1]] <= nums[i]: q.pop() \n            while q and i - q[0] >= k: q.popleft() \n            q.append(i)\n            if i >= k - 1: ans.append(nums[q[0]])\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468123938","body":"class Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        in_degree = collections.defaultdict(int)\n        out_degree = collections.defaultdict(int)\n        for edge in trust:\n            out_degree[edge[0]] += 1\n            in_degree[edge[1]] += 1\n        for i in range(1, n+1):\n            if in_degree[i] == n - 1 and out_degree[i] == 0:\n                return i\n        return -1","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473981163","body":"class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        start=[0,0]\n        for move in moves:\n            if move == \"R\":\n                start[0]+=1\n            elif move == \"L\":\n                start[0]-=1\n            elif move == \"U\":\n                start[1]+=1\n            elif move == \"D\":\n                start[1]-=1\n    \n        return start==[0,0]","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1478103945","body":"class Solution:\n    def max_heapify(self, heap, root, heap_len):\n        p = root\n        while p * 2 + 1 < heap_len:\n            l, r = p * 2 + 1, p * 2 + 2\n            if heap_len <= r or heap[r] < heap[l]:\n                nex = l\n            else:\n                nex = r\n            if heap[p] < heap[nex]:\n                heap[p], heap[nex] = heap[nex], heap[p]\n                p = nex\n            else:\n                break\n        \n    def build_heap(self, heap):\n        for i in range(len(heap) - 1, -1, -1):\n            self.max_heapify(heap, i, len(heap))\n\n    def heap_sort(self, nums):\n        self.build_heap(nums)\n        for i in range(len(nums) - 1, -1, -1):\n            nums[i], nums[0] = nums[0], nums[i]\n            self.max_heapify(nums, 0, i)\n            \n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.heap_sort(nums)\n        return nums","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1481323450","body":"class Solution:\n    def firstBadVersion(self, n: int) -> int:\n        left = 1\n        right = n\n        while left < right:\n            mid = (left + right) >> 1\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1485349675","body":"    def test(mid, x, y):\n        if x > len(grid) - 1 or x < 0 or y > len(grid[0]) - 1 or y < 0:\n            return False\n        if grid[x][y] > mid:\n            return False\n        if (x, y) == (len(grid) - 1, len(grid[0]) - 1):\n            return True\n        if (x, y) in seen:\n            return False\n        seen.add((x, y))\n        ans = test(mid, x + 1, y) or test(mid, x - 1,\n                                          y) or test(mid, x, y + 1) or test(mid, x, y - 1)\n        return ans\n    while l <= r:\n        mid = (l + r) // 2\n        if test(mid, 0, 0):\n            r = mid - 1\n        else:\n            l = mid + 1\n        seen = set()\n    return l","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491194536","body":"class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        d = Counter(t)\n        c = len(d)\n        i = start = 0\n        n = len(s)\n        ans = n+1\n        for j in range(n):\n            if s[j] in d:\n                d[s[j]]-=1\n                if d[s[j]]==0:\n                    c-=1            \n            while c==0:\n                if ans>j-i+1:\n                    ans=j-i+1\n                    start=i\n                if s[i] in d:\n                    d[s[i]]+=1\n                    if d[s[i]]>0:\n                        c+=1\n                i+=1\n        if ans>n:\n            return \"\"\n        return s[start:start+ans]","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494077368","body":"class Solution:\n    def totalNQueens(self, n: int) -> int:\n        cols = set()\n        dia1 = set()\n        dia2 = set()\n\n        def backtrack(row):\n            if row == n:\n                return 1\n            \n            count = 0\n            for i in range(n):\n                if i in cols or row - i in dia1 or row + i in dia2:\n                    continue\n                cols.add(i)\n                dia1.add(row - i)\n                dia2.add(row + i)\n                count += backtrack(row + 1)\n\n                cols.remove(i)\n                dia1.remove(row - i)\n                dia2.remove(row + i)\n            return count\n        \n        return backtrack(0)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500737267","body":"class Solution(object):\n    def minCostClimbingStairs(self, cost):\n        if len(cost)==2: return min(cost)\n        prev_two, prev_one = 0, min(cost[0], cost[1])\n        for i in range(3, len(cost)):\n            cur = min(prev_one+cost[i-1], prev_two+cost[i-2])\n            prev_two, prev_one = prev_one, cur\n        return min(prev_two+cost[-2], prev_one+cost[-1])","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501286205","body":"class Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp, cnt, max_val = [1]*n, [1]*n, 1\n        for i in range(1,n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    if dp[j] + 1 > dp[i]:\n                        dp[i], cnt[i] = 1 + dp[j], cnt[j]\n                    elif dp[j] + 1 == dp[i]:\n                        cnt[i] += cnt[j]\n            max_val = max(max_val,dp[i])\n\n        return sum([j for i,j in zip(dp,cnt) if i == max_val])","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1510981865","body":"class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [sys.maxsize] * (amount + 1)\n        dp[0] = 0\n\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] = min(dp[x], dp[x - coin] + 1)\n        \n        return dp[amount] if dp[amount] != sys.maxsize else -1","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519060350","body":"class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if not lists:\n            return None\n            \n        n = len(lists)\n        interval = 1\n        while interval < n:\n            for i in range(0, n - interval, interval * 2):\n                lists[i] = self.merge2Lists(lists[i], lists[i + interval])\n            interval *= 2\n        \n        return lists[0]\n\n    def merge2Lists(self, l1, l2):\n        dummy = ListNode(0)\n        cur = dummy\n        while l1 and l2:\n            if l1.val <= l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n            cur = cur.next\n        \n        cur.next = l1 if l1 else l2\n        return dummy.next","onTime":true},null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1535999432","body":"class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        res = []\n        candidates.sort()\n\n        def backtrack(s, target, path):\n            if target < 0:\n                return\n            if target == 0:\n                res.append(path[::])\n\n            for i in range(s, len(candidates)):\n                if i > s and candidates[i] == candidates[i - 1]:\n                    continue\n                path.append(candidates[i])\n                backtrack(i + 1, target - candidates[i], path)\n                path.pop()\n                \n        backtrack(0, target, [])\n        return res","onTime":true},null,null,null,null,null,null,null,null,null,null],"pkuphy":[null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432292492","body":"```rust\r\nstruct CustomStack {\r\n    elements: Vec<i32>, // 使用 vector 模拟 stack\r\n    maxSize: usize, // 初始化 maxSize，后续比较多用 usize 所以此处使用 usize 类型\r\n}\r\n\r\n\r\nimpl CustomStack {\r\n\r\n    fn new(maxSize: i32) -> Self {\r\n        CustomStack {\r\n            elements: Vec::new(), // new vector\r\n            maxSize: maxSize as usize,\r\n        }\r\n    }\r\n    \r\n    fn push(&mut self, x: i32) { // &mut self\r\n        if self.elements.len() < self.maxSize {\r\n            self.elements.push(x)\r\n        }\r\n    }\r\n    \r\n    fn pop(&mut self) -> i32 {\r\n        self.elements.pop().unwrap_or(-1)\r\n    }\r\n    \r\n    fn increment(&mut self, k: i32, val: i32) {\r\n        let k = std::cmp::min(k as usize, self.elements.len());\r\n\r\n        for i in 0..k {\r\n            *(self.elements.get_mut(i).unwrap()) += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\npush, pop O(1)\r\nincrement O(k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhenya-zhu":[null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431616262","body":"思路：\n遇到c将count置0。顺序遍历，倒序遍历，填充时取最小值\n```\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\n\nvar shortestToChar = function(s, c) {\n    let arr = s.split('').map(ch => {\n        if (ch == c) {\n            return 0\n        } else{\n            return null\n        }\n    })\n\n    let dis = null\n    for (let i = 0; i < arr.length; i++){\n        cur = arr[i]\n        if (cur === 0){\n            dis = 0\n        }else{\n            if (dis !== null){\n                dis++\n                if (arr[i] == null){\n                    arr[i] = dis\n                }else{\n                    arr[i] = Math.min(arr[i], dis)\n                }\n            }\n        }\n    }\n    dis = null\n    for (let i = arr.length - 1; i > -1; i--){\n        cur = arr[i]\n        if (cur === 0){\n            dis = 0\n        }else{\n            if (dis !== null){\n                dis++\n                if (arr[i] == null){\n                    arr[i] = dis\n                }else{\n                    arr[i] = Math.min(arr[i], dis)\n                }\n            }\n        }\n    }\n    return arr\n\n};\n```\n\n时间复杂度：3次遍历，O(n)\n空间复杂度：O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433025382","body":"/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.stack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length < this.maxSize){\n        this.stack.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.stack.length > 0){\n        return this.stack.pop()\n    }else{\n        return -1\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const len = this.stack.length\n    for(let i = 0; i < k && i < len; i++){\n        this.stack[i] += val\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438627269","body":"#思路\r\n递归求解\r\n\r\n#代码\r\n```js\r\nvar swapPairs = function(head) {\r\n    function swap(first){\r\n        if(!first) return first\r\n        let second = first.next\r\n        if(!second) return first\r\n        let rest = second.next\r\n        first.next = swap(rest)\r\n        second.next = first\r\n        return second\r\n    }\r\n    return swap(head)\r\n};\r\n```\r\n\r\n#复杂度\r\n时间：On\r\n空间：O1","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wty9sky":[null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432367108","body":"``` javascript\nfunction ListNode(val){\n    this.val=val;\n    this.next=null;\n}\nvar CustomStack = function(maxSize) {\n    this.maxSize=maxSize;\n    this.head=null;\n    this.length=0;\n};\n\nCustomStack.prototype.push = function(x) {\n    if(this.length===this.maxSize) return;\n    let node=new ListNode(x);\n    let linkList=this.head;\n    node.next=linkList;\n    this.head=node;\n    this.length++;\n};\n\nCustomStack.prototype.pop = function() {\n    if(this.length===0) return -1;\n    let linkList=this.head.next;\n    let popVal=this.head.val;\n    this.head=linkList;\n    this.length--;\n    return popVal;\n};\n\nCustomStack.prototype.increment = function(k, val) {\n    if(k<0) return;\n    let start=this.length-k;\n    let currentNode=this.head;\n    if(start>0){\n        for(let i=0;i<start;++i){\n            currentNode=currentNode.next;\n        }\n    }\n    while(currentNode){\n        currentNode.val+=val;\n        currentNode=currentNode.next;\n    }\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440172599","body":"``` javascript\nconst sortedListToBST = (head) => {\n  const arr = [];\n  while (head) { // 将链表节点的值逐个推入数组arr\n    arr.push(head.val);\n    head = head.next;\n  }\n  // 根据索引start到end的子数组构建子树\n  const buildBST = (start, end) => {\n    if (start > end) return null;        // 指针交错，形成不了子序列，返回null节点\n    const mid = (start + end) >>> 1;     // 求中间索引 中间元素是根节点的值\n    const root = new TreeNode(arr[mid]); // 创建根节点\n    root.left = buildBST(start, mid - 1); // 递归构建左子树\n    root.right = buildBST(mid + 1, end);  // 递归构建右子树\n    return root;                          // 返回当前子树\n  };\n\n  return buildBST(0, arr.length - 1);  // 根据整个arr数组构建\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skyoct":[null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432523094","body":"class CustomStack {\r\n\r\n    private int[] stack;\r\n    private int top = 0;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top >= stack.length) {\r\n            return;\r\n        }\r\n        stack[top++] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == 0) {\r\n            return -1;\r\n        }\r\n        return stack[--top];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int end = k > top ? top : k ;\r\n        for(int i=0; i<end; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bingzxy":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1433279109","body":"### 题目：\r\n\r\n[989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\r\n\r\n### 思路\r\n数组逐位相加，模拟\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> kArr = new ArrayList<> ();\r\n        while (k > 0) {\r\n            System.out.println(k % 10);\r\n            kArr.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        List<Integer> nArr = new ArrayList<> ();\r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            nArr.add(num[i]);\r\n        }\r\n\r\n        List<Integer> ans = new ArrayList<> ();\r\n        int extr = 0;\r\n        int size = Math.min(kArr.size(), nArr.size());\r\n        for (int i = 0; i < size; i++) {\r\n            int tmp = kArr.get(i) + nArr.get(i) + extr;\r\n            extr = tmp / 10;\r\n            ans.add(tmp % 10);\r\n        }\r\n\r\n        if (size < kArr.size()) {\r\n            for (int i = size; i < kArr.size(); i++) {\r\n                int tmp = kArr.get(i) + extr;\r\n                extr = tmp / 10;\r\n                ans.add(tmp % 10);\r\n            }\r\n        }\r\n\r\n        if (size < nArr.size()) {\r\n            for (int i = size; i < nArr.size(); i++) {\r\n                int tmp = nArr.get(i) + extr;\r\n                extr = tmp / 10;\r\n                ans.add(tmp % 10);\r\n            }\r\n        }\r\n\r\n        if (extr == 1) {\r\n            ans.add(extr);\r\n        }\r\n\r\n        List<Integer> reverseAns = new ArrayList<> ();\r\n        for (int i = ans.size() - 1; i >= 0; i--) {\r\n            reverseAns.add(ans.get(i));\r\n        }\r\n\r\n        return reverseAns;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1448461852","body":"### 思路\r\n1. 使用两个数组分别记录下标 i，左右侧距离最近的字符c的位置；\r\n2. 遍历原数组，计算距离符合条件的左右字符的距离，记录最小值。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] left = new int[len];\r\n        int[] right = new int[len];\r\n        for (int i = 0; i < len; i++) {\r\n            if (s.charAt(i) == c) {\r\n                left[i] = i;\r\n            } else {\r\n                left[i] = i == 0 ? -1 : left[i - 1];\r\n            }\r\n        }\r\n\r\n        for (int j = len - 1; j >= 0; j--) {\r\n            if (s.charAt(j) == c) {\r\n                right[j] = j;\r\n            } else {\r\n                right[j] = j == len - 1 ? -1 : right[j + 1];\r\n            }\r\n        }\r\n\r\n        int[] ans = new int[len];\r\n        for (int i = 0; i < len; i++) {\r\n            if (s.charAt(i) == c) {\r\n                ans[i] = 0;\r\n            } else {\r\n                if (left[i] != -1) {\r\n                    ans[i] = i - left[i];\r\n                }\r\n                if (right[i] != -1) {\r\n                    ans[i] = ans[i] != 0 ? Math.min(ans[i], right[i] - i) : right[i] - i;\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433197588","body":"### 思路\r\n使用数组模拟栈操作\r\n\r\n### 代码\r\n```java\r\nclass CustomStack {\r\n\r\n    int[] stack;\r\n    int current;\r\n    int size;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        size = maxSize;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (current == size) {\r\n            return;\r\n        }\r\n        stack[current++] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if (current == 0) {\r\n            return -1;\r\n        }\r\n        return stack[--current];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < Math.min(k, current); i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push、pop O(1)，increment O(k)\r\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435701057","body":"### 思路\r\n使用两个栈进行模拟，一个栈负责接受数据，另一个负责输出数据\r\n\r\n### 代码\r\n```java\r\nclass MyQueue {\r\n    Deque<Integer> stackA = new ArrayDeque<> ();\r\n    Deque<Integer> stackB = new ArrayDeque<> (); \r\n    public MyQueue() {\r\n\r\n    }\r\n    \r\n    public void push(int x) {\r\n        stackA.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (!stackB.isEmpty()) {\r\n            return stackB.pop();\r\n        }\r\n        while (!stackA.isEmpty()) {\r\n            stackB.push(stackA.pop());\r\n        }\r\n        return pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (!stackB.isEmpty()) {\r\n            return stackB.peek();\r\n        }\r\n        while (!stackA.isEmpty()) {\r\n            stackB.push(stackA.pop());\r\n        }\r\n        return peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stackA.isEmpty() && stackB.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1438605120","body":"### 思路\r\n指针操作，注意将操作数 k 进行取模\r\n\r\n### 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        int cnt = 0;\r\n        ListNode cur = head;\r\n        while (cur != null) {\r\n            cnt++;\r\n            cur = cur.next;\r\n        }\r\n\r\n        k = k % cnt;\r\n        if (k == 0) {\r\n            return head;\r\n        }\r\n        ListNode pre = head;\r\n        cur = head;\r\n        while (k-- > 0) {\r\n            cur = cur.next;\r\n        }\r\n\r\n        while (cur.next != null) {\r\n            cur = cur.next;\r\n            pre = pre.next;\r\n        }\r\n\r\n        ListNode nextHead = pre.next;\r\n        pre.next = null;\r\n        cur.next = head;\r\n        return nextHead;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438578863","body":"### 思路\r\n递归，每层交换两个元素，当链表为空或单节点时可以直接返回。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n\r\n        ListNode l1 = head, l2 = head.next;\r\n        ListNode next = l2.next;\r\n        l2.next = l1;\r\n        l1.next = swapPairs(next);\r\n        return l2;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440174243","body":"### 思路\r\n按平衡树要求，可以将链表转为数组，此时数据递增，可以取中间节点作为根节点，则左子树和右子树的数量一致，递归生成左子树和右子树。\r\n\r\n### 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        int cnt = 0;\r\n        ListNode cur = head;\r\n        List<ListNode> list = new ArrayList<> ();\r\n        while (cur != null) {\r\n            cnt++;\r\n            ListNode next = cur.next;\r\n            cur.next = null;\r\n            list.add(cur);\r\n            cur = next;\r\n        }\r\n        return sortedListToBST(list, 0, cnt - 1);\r\n    }\r\n\r\n    private TreeNode sortedListToBST(List<ListNode> list, int start, int end) {\r\n        if (start > end) {\r\n            return null;\r\n        }\r\n        int mid = start + (end - start) / 2;\r\n        TreeNode head = new TreeNode(list.get(mid).val);\r\n        head.left = sortedListToBST(list, start, mid - 1);\r\n        head.right = sortedListToBST(list, mid + 1, end);\r\n        return head;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441937183","body":"### 思路\r\n1. 哈希表，可以先遍历其中一个链表，将每个链表节点添加到哈希表中；然后遍历另外一个链表，当遇到第一个存在的节点，就是相遇节点，如果遍历完第二个链表，也没有相同节点，则不相交。\r\n2. 双指针\r\n\r\n### 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null) {\r\n            return null;\r\n        }\r\n        if (headB == null) {\r\n            return null;\r\n        }\r\n\r\n        ListNode l1 = headA, l2 = headB;\r\n        while (l1 != l2) {\r\n            if (l1 == null) {\r\n                l1 = headB;\r\n            } else {\r\n                l1 = l1.next;\r\n            }\r\n            if (l2 == null) {\r\n                l2 = headA;\r\n            } else {\r\n                l2 = l2.next;\r\n            }\r\n        }\r\n        return l1;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(m+n)，m、n 为链表长度\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443867265","body":"### 思路\r\n快慢指针，如果不存在环，则快指针必定先指向 NULL，否则，快慢指针必定相交。\r\n\r\n### 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode slow = head, fast = head;\r\n\r\n        do {\r\n            if (fast == null || fast.next == null) {\r\n                return null;\r\n            }\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        } while (slow != fast);\r\n\r\n        fast = head;\r\n        while (fast != slow) {\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return fast;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445047159","body":"### 思路\r\n- 使用双向链表实现 LRU 缓存机制，为了能够在 O(1) 时间复杂度内找到指定节点，可以使用哈希表缓存节点信息。\r\n\r\n### 代码实现\r\n```java\r\nclass LRUCache {\r\n\r\n    int capacity, size;\r\n    Map<Integer, Node> map;\r\n    Node head, tail;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        map = new HashMap<> ();\r\n        head = new Node();\r\n        tail = new Node();\r\n        head.next = tail;\r\n        tail.pre = head;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if (!map.containsKey(key)) {\r\n            return -1;\r\n        }\r\n\r\n        Node node = map.get(key);\r\n        Node preNode = node.pre, nextNode = node.next;\r\n        preNode.next = nextNode;\r\n        nextNode.pre = preNode;\r\n        \r\n        Node headNext = head.next;\r\n        head.next = node;\r\n        node.next = headNext;\r\n        headNext.pre = node;\r\n        node.pre = head;\r\n\r\n        return node.value;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n\r\n        if (map.containsKey(key)) {\r\n            get(key);\r\n            map.get(key).value = value;\r\n            return;\r\n        }\r\n\r\n        if (size == capacity) {\r\n            Node last = tail.pre;\r\n            last.pre.next = tail;\r\n            tail.pre = last.pre;\r\n            last.pre = null;\r\n            last.next = null;\r\n            map.remove(last.key);\r\n            size--;\r\n            put(key, value);\r\n        } else {\r\n            size++;\r\n            Node first = new Node();\r\n            first.key = key;\r\n            first.value = value;\r\n\r\n            Node next = head.next;\r\n            head.next = first;\r\n            first.pre = head;\r\n            first.next = next;\r\n            next.pre = first;\r\n\r\n            map.put(key, first);\r\n        }\r\n    }\r\n\r\n    class Node {\r\n        private int key;\r\n        private int value;\r\n        Node pre, next;\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445254566","body":"### 思路\r\n递归计算\r\n二叉树最大深度 = Max(左子树最大深度、右子树最大深度) + 1\r\n\r\n### 代码\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n\r\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(h)，h为最大深度，需要做出入栈操作","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446510021","body":"### 思路\r\n递归判断两个树的根节点，左子树，右子树是否相等。\r\n\r\n### 代码\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null) {\r\n            return q == null;\r\n        }\r\n        if (q == null) {\r\n            return p == null;\r\n        }\r\n\r\n        if (p.val != q.val) {\r\n            return false;\r\n        }\r\n\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(min(m,n))，其中，m、n 为两个树的节点数量\r\n- 空间复杂度：O(min(m,n))，其中，m、n 为两个树的节点数量，由于最大不会超过其中两颗树高度的最大值，而最坏情况下树高和节点数一致","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448427060","body":"### 思路\r\ndfs 计算每条支路的数据和。\r\n\r\n### 代码\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        return dfs(root, 0);\r\n    }\r\n\r\n    private int dfs(TreeNode root, int pre) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        int cur = 10 * pre + root.val;\r\n        if (root.left == null && root.right == null) {\r\n            return cur;\r\n        } else {\r\n            return dfs(root.left, cur) + dfs(root.right, cur);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)，n为节点数量\r\n- 空间复杂度：O(n)，需要栈的深度为树高，最差情况下为节点数量","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450308873","body":"### 思路\r\n广度优先遍历每一层节点\r\n\r\n### 代码\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        Deque<TreeNode> queue = new ArrayDeque<> ();\r\n        queue.offer(root);\r\n        int ans = root.val;\r\n        while (!queue.isEmpty()) {\r\n            int size = queue.size();\r\n            size--;\r\n            TreeNode node = queue.poll();\r\n            ans = node.val;\r\n            if (node.left != null) {\r\n                queue.offer(node.left);\r\n            }\r\n            if (node.right != null) {\r\n                queue.offer(node.right);\r\n            }\r\n            while (size-- > 0) {\r\n                node = queue.poll();\r\n                if (node.left != null) {\r\n                    queue.offer(node.left);\r\n                }\r\n                if (node.right != null) {\r\n                    queue.offer(node.right);\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453630196","body":"### 思路\r\nbfs + 哈希表，哈希表的key为每个元素的纵坐标，value 为节点值的集合，对于同一层纵坐标相同的数据需要排序。\r\n\r\n### 代码\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        Map<Integer, List<Integer>> map = new HashMap<> ();\r\n        Deque<Integer> colQueue = new ArrayDeque<> ();\r\n        Deque<TreeNode> queue = new ArrayDeque<> ();\r\n        queue.offer(root);\r\n        colQueue.offer(0);\r\n        while (!queue.isEmpty()) {\r\n            int size = queue.size();\r\n            Map<Integer, List<Integer>> tmpMap = new HashMap<> ();\r\n            while (size-- > 0) {\r\n                TreeNode node = queue.poll();\r\n                int index = colQueue.poll();\r\n                tmpMap.putIfAbsent(index, new ArrayList<> ());\r\n                tmpMap.get(index).add(node.val);\r\n                if (node.left != null) {\r\n                    queue.offer(node.left);\r\n                    colQueue.offer(index - 1);\r\n                }\r\n                if (node.right != null) {\r\n                    queue.offer(node.right);\r\n                    colQueue.offer(index + 1);\r\n                }\r\n            }\r\n\r\n            for (int key : tmpMap.keySet()) {\r\n                tmpMap.get(key).sort((a, b) -> a - b);\r\n                map.putIfAbsent(key, new ArrayList<> ());\r\n                map.get(key).addAll(tmpMap.get(key));\r\n            }\r\n        }\r\n\r\n        List<Integer> keys = new ArrayList<> (map.keySet());\r\n        keys.sort((a,b) -> a - b);\r\n        List<List<Integer>> ans = new ArrayList<> ();\r\n        for (int key : keys) {\r\n            ans.add(map.get(key));\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(nlgn)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454364373","body":"### 思路\r\n通过hash表记录已经遍历过的元素，key为元素值，value为下标。假如当前遍历下标为 i，则期望在原数组中找到元素值 target - nums[i]，我们可以利用哈希表来加速该元素查找。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        Map<Integer, Integer> map = new HashMap<> ();\r\n        for (int i = 0; i < nums.length; i++) {\r\n            int tmp = target - nums[i];\r\n            if (map.containsKey(tmp)) {\r\n                return new int[] {i, map.get(tmp)};\r\n            } else {\r\n                map.put(nums[i], i);\r\n            }\r\n        }\r\n        return new int[2];\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455031529","body":"### 思路\r\n统计每个数字出现的次数，对统计结果按次数进行排序，获取前 ke 个高频元素\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        Map<Integer, Integer> map = new HashMap<> ();\r\n        for (int num : nums) {\r\n            map.put(num, map.getOrDefault(num, 0) + 1);\r\n        }\r\n\r\n        List<int[]> arr = new ArrayList<> ();\r\n        for (int key : map.keySet()) {\r\n            arr.add(new int[] {key, map.get(key)});\r\n        }\r\n\r\n        arr.sort((a, b) -> b[1] - a[1]);\r\n        int[] ans = new int[k];\r\n        for (int i = 0; i < k; i++) {\r\n            ans[i] = arr.get(i)[0];\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(nllogn)\r\n- 空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1458377999","body":"### 思路\r\n1. 使用双指针（left，right）记录当前字符串的左右边界，哈希表记录当前字符串包含的元素；\r\n2. 优先移动right指针，并且判断当前指向字符在哈希表中是否存在，如果不存在则加入哈希表，并且向右移动一位；\r\n3. 如果存在，则移动 left 指针，判断当前left指向字符与right指向是否相等，不存在则将该字符移除哈希表；\r\n4. 每次移动完成后更新结果，当有指针指向字符串结尾时结束。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        Set<Character> set = new HashSet<> ();\r\n        int ans = 0, left = 0, right = 0, len = s.length();\r\n        while (right < len) {\r\n            if (!set.contains(s.charAt(right))) {\r\n                set.add(s.charAt(right));\r\n                ans = Math.max(ans, right - left + 1);\r\n                right++;\r\n            } else {\r\n                while (s.charAt(left) != s.charAt(right)) {\r\n                    set.remove(s.charAt(left));\r\n                    left++;\r\n                }\r\n                left++;\r\n                ans = Math.max(ans, right - left + 1);\r\n                right++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460365358","body":"### 思路\r\n1. 通过哈希表记录字符串数组中每个字符串出现的频次，记入哈希表1；\r\n2. 根据字符串数组的特性（每个字符等长），获取滑动窗口大小；\r\n3. 通过窗口中子字符串的频次，记入哈希表2；\r\n4. 比较哈希表1和哈希表2中的元素，如果完全相同，则计入一个符合条件的下标；\r\n5. 如果滑动窗口还能往右移动，则向右移动滑动一步窗口，回到步骤2，否则结束。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        int wordLen = words[0].length(), len = words.length;\r\n        Map<String, Integer> cache = new HashMap<> ();\r\n        for (String word : words) {\r\n            cache.put(word, cache.getOrDefault(word, 0) + 1);\r\n        }\r\n\r\n        int left = 0, right = len * wordLen - 1;\r\n        List<Integer> ans = new ArrayList<> ();\r\n        System.out.println(s.length());\r\n        while (right < s.length()) {\r\n            Map<String, Integer> tmp = new HashMap<> ();\r\n            int cur = left;\r\n            for (int i = 0; i < len; i++) {\r\n                String next = s.substring(cur, cur + wordLen);\r\n                tmp.put(next, tmp.getOrDefault(next, 0) + 1);\r\n                cur += wordLen;\r\n            }\r\n            if (isValid(tmp, cache) && isValid(cache, tmp)) {\r\n                ans.add(left);\r\n            }\r\n            left++;\r\n            right++;\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    private boolean isValid(Map<String, Integer> baseMap, Map<String, Integer> targetMap) {\r\n        for (String key : baseMap.keySet()) {\r\n            if (!targetMap.containsKey(key) || !targetMap.get(key).equals(baseMap.get(key))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(sLen * len(words))，其中sLen为字符串s长度\r\n- 空间复杂度：O(len(words) * n)，n 为单词长度","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463866119","body":"### 思路\r\n快慢指针\r\n\r\n### 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n        if (head.next == null) {\r\n            return head;\r\n        }\r\n        ListNode fast = head, slow = head;\r\n        while (fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464826323","body":"### 思路\r\n遍历数据，将元素逐步往前移动，遇到重复数据就跳过，维护输出数组下标和最后的值。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int preIndex = 0, pre = nums[0], len = nums.length;\r\n        for (int i = 1; i < len; i++) {\r\n            if (nums[i] != pre) {\r\n                nums[++preIndex] = nums[i];\r\n                pre = nums[i];\r\n            }\r\n        }\r\n\r\n        return preIndex + 1;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465075441","body":"### 思路\r\n二分\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int searchInsert(int[] nums, int target) {\r\n        int left = 0, right = nums.length - 1;\r\n        int mid = 0;\r\n        while (left <= right) {\r\n            mid = left + (right - left) / 2;\r\n            if (nums[mid] == target) {\r\n                return mid;\r\n            } else if (nums[mid] > target) {\r\n                right = mid - 1;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        if (mid == 0) {\r\n            return nums[mid] > target ? 0 : 1;\r\n        } else {\r\n            return nums[mid] > target && nums[mid - 1] < target ? mid : mid + 1;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(logn)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466366311","body":"### 思路\r\n优先队列\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        int len = nums.length;\r\n        PriorityQueue<int[]> pq = new PriorityQueue<> ((a, b) -> a[0] == b[0] ? b[1] - a[1] : b[0] - a[0]);\r\n        for (int i = 0; i < k; i++) {\r\n            pq.offer(new int[] {nums[i], i});\r\n        }\r\n\r\n        int[] ans = new int[len - k + 1];\r\n        ans[0] = pq.peek()[0];\r\n        for (int i = k; i < len; i++) {\r\n            pq.offer(new int[] {nums[i], i});\r\n            while (pq.peek()[1] <= i - k) {\r\n                pq.poll();\r\n            }\r\n            ans[i - k  + 1] = pq.peek()[0];\r\n        }\r\n        ans[len - k] = pq.peek()[0];\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468376661","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int findJudge(int n, int[][] trust) {\r\n        if (trust.length == 0) {\r\n            return n == 1 ? 1 : -1;\r\n        }\r\n        int[] arr = new int[n + 1];\r\n        for (int[] row : trust) {\r\n            if (arr[row[0]] == 0) {\r\n                arr[row[0]] = 1;\r\n            }\r\n        }\r\n\r\n        int ans = -1;\r\n        boolean flag = false;\r\n        for (int i = 1; i <= n; i++) {\r\n            if (arr[i] == 0) {\r\n                if (flag) {\r\n                    return -1;\r\n                }\r\n                ans = i;\r\n                flag = true;\r\n            }\r\n        }\r\n\r\n        for (int[] row : trust) {\r\n            if (row[1] == ans && arr[row[0]] == 1) {\r\n                arr[row[0]] = 2;\r\n            }\r\n        }\r\n\r\n        for (int i = 1; i <= n; i++) {\r\n            if (i == ans) {\r\n                continue;\r\n            }\r\n            if (arr[i] != 2) {\r\n                return -1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/36#issuecomment-1469426339","body":"### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public boolean possibleBipartition(int n, int[][] dislikes) {\r\n        int[] color = new int[n + 1];\r\n        List<Integer>[] g= new List[n + 1];\r\n        for (int i = 0; i <= n; i++) {\r\n            g[i] = new ArrayList<Integer>();\r\n        }\r\n        for (int[] p : dislikes) {\r\n            g[p[0]].add(p[1]);\r\n            g[p[1]].add(p[0]);\r\n        }\r\n        for (int i = 1; i <= n; i++) {\r\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private boolean dfs(int curnode, int nowcolor, int[] color, List<Integer>[] g) {\r\n        color[curnode] = nowcolor;\r\n        for (int nextnode : g[curnode]) {\r\n            if (color[nextnode] != 0 && color[nextnode] == color[curnode]) {\r\n                return false;\r\n            }\r\n            if (color[nextnode] == 0 && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473934003","body":"### 思路\r\n使用数组记录位置，模拟移动\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public boolean judgeCircle(String moves) {\r\n        int[] pos = new int[2];\r\n        for (char c : moves.toCharArray()) {\r\n            if (c == 'U') {\r\n                pos[1]++;\r\n            } else if (c == 'D') {\r\n                pos[1]--;\r\n            } else if (c == 'L') {\r\n                pos[0]--;\r\n            } else {\r\n                pos[0]++;\r\n            }\r\n        }\r\n        return pos[0] == 0 && pos[1] == 0;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474870529","body":"### 思路\r\n1. 使用二维数组记录每个任务的下标 int[n][3]\r\n2. 使用优先队列记录当前可执行任务\r\n对任务先进行排序，将符合执行条件的任务放入优先队里，模拟 CPU 执行，每次执行完成后记录当前任务下标值，并更新当前时间，同时将符合条件的任务放入优先队列，循环上述操作，直至任务都执行完成。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] getOrder(int[][] tasks) {\r\n        int len = tasks.length;\r\n        int[][] arr = new int[len][3];\r\n        \r\n        for (int i = 0; i < len; i++) {\r\n            arr[i] = new int[] {tasks[i][0], tasks[i][1], i};\r\n        }\r\n        Arrays.sort(arr, (a, b) -> a[0] - b[0]);\r\n\r\n        int[] ans = new int[len];\r\n        int index = 0;\r\n        PriorityQueue<int[]> pq = new PriorityQueue<> ((a, b) -> {\r\n            if (a[1] == b[1]) {\r\n                return a[2] - b[2];\r\n            }\r\n            return a[1] - b[1];\r\n        });\r\n\r\n        int i = 0;\r\n        int currentTime = 1;\r\n        for (; index < len;) {\r\n            while ((i < len && currentTime >= arr[i][0])) {\r\n                pq.offer(arr[i++]);\r\n            }\r\n            if (pq.isEmpty()) {\r\n                currentTime = arr[i][0];\r\n            } else {\r\n                // 执行任务\r\n                int[] curTask = pq.poll();\r\n                ans[index++] = curTask[2];\r\n                currentTime += curTask[1];\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475223716","body":"### 思路\r\n模拟\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int numberOfRounds(String loginTime, String logoutTime) {\r\n        String[] loginArr = loginTime.split(\":\");\r\n        String[] logoutArr = logoutTime.split(\":\");\r\n        int loginHour = Integer.valueOf(loginArr[0]), loginMinute = Integer.valueOf(loginArr[1]);\r\n        int logoutHour = Integer.valueOf(logoutArr[0]), logoutMinute = Integer.valueOf(logoutArr[1]);\r\n        boolean moreThanOneDay = (loginHour > logoutHour) || (loginHour == logoutHour && loginMinute > logoutMinute);\r\n\r\n        int t1 = loginHour * 60 + loginMinute, t2 = logoutHour * 60 + logoutMinute;\r\n        if (t1 > t2) {\r\n            t2 += 1440;\r\n        }\r\n        t2 = t2 / 15 * 15;\r\n        return Math.max(0, (t2 - t1) / 15);\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1478002868","body":"### 思路\r\n归并排序\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    int[] tmp;\r\n    public int[] sortArray(int[] nums) {\r\n        int len = nums.length;\r\n        tmp = new int[len];\r\n        mergeSort(nums, 0, len - 1);\r\n        return nums;\r\n    }\r\n\r\n    private void mergeSort(int[] nums, int l, int r) {\r\n        if (l >= r) {\r\n            return;\r\n        }\r\n        int mid = l + (r - l) / 2;\r\n        mergeSort(nums, l, mid);\r\n        mergeSort(nums, mid + 1, r);\r\n        \r\n        int i = l, j = mid + 1;\r\n        int cnt = 0;\r\n        while (i <= mid && j <= r) {\r\n            if (nums[i] <= nums[j]) {\r\n                tmp[cnt++] = nums[i++];\r\n            } else {\r\n                tmp[cnt++] = nums[j++];\r\n            }\r\n        }\r\n        while (i <= mid) {\r\n            tmp[cnt] = nums[i];\r\n            cnt++;\r\n            i++;\r\n        }\r\n        while (j <= r) {\r\n            tmp[cnt] = nums[j];\r\n            cnt++;\r\n            j++;\r\n        }\r\n        for (int k = 0; k < r - l + 1; k++) {\r\n            nums[l + k] = tmp[k];\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1481302629","body":"### 思路\r\n二分\r\n\r\n### 代码\r\n```java\r\n/* The isBadVersion API is defined in the parent class VersionControl.\r\n      boolean isBadVersion(int version); */\r\n\r\npublic class Solution extends VersionControl {\r\n    public int firstBadVersion(int n) {\r\n        int left = 0, right = n;\r\n        while (left <= right) {\r\n            int mid = left + (right - left) / 2;\r\n            if (isBadVersion(mid)) {\r\n                right = mid - 1;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n\r\n        return left;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(log(n))\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486014027","body":"### 思路\r\n滑动窗口\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int maxVowels(String s, int k) {\r\n        int ans = 0, len = s.length();\r\n        Set<Character> set = new HashSet<> () {{\r\n            add('a');\r\n            add('e');\r\n            add('i');\r\n            add('o');\r\n            add('u');\r\n        }};\r\n        for (int i = 0; i < k; i++) {\r\n            if (set.contains(s.charAt(i))) {\r\n                ans++;\r\n            }\r\n        }\r\n\r\n        int left = 0, right = k - 1;\r\n        int cur = ans;\r\n        while (right < len) {\r\n            int tmp = cur;\r\n            right = right + 1;\r\n            if (right >= len) {\r\n                return ans;\r\n            }\r\n            if (set.contains(s.charAt(right))) {\r\n                tmp++;\r\n            }\r\n            if (set.contains(s.charAt(left))) {\r\n                tmp--;\r\n            }\r\n            left++;\r\n            cur = tmp;\r\n            ans = Math.max(ans, tmp);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489519832","body":"### 思路\r\n滑动窗口 + 哈希表\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> findAnagrams(String s, String p) {\r\n        List<Integer> ans = new ArrayList<> ();\r\n        int sLen = s.length(), pLen = p.length();\r\n        if (pLen > sLen) {\r\n            return ans;\r\n        }\r\n        Map<Character, Integer> pCntMap = new HashMap<> ();\r\n        for (char c : p.toCharArray()) {\r\n            pCntMap.put(c, pCntMap.getOrDefault(c, 0) + 1);\r\n        }\r\n        int left = 0, right = pLen - 1;\r\n        Map<Character, Integer> slideMap = new HashMap<> ();\r\n        for (int i = 0; i <= right; i++) {\r\n            slideMap.put(s.charAt(i), slideMap.getOrDefault(s.charAt(i), 0) + 1);\r\n        }\r\n\r\n        do {\r\n            if (valid(pCntMap, slideMap) && valid(slideMap, pCntMap)) {\r\n                ans.add(left);\r\n            }\r\n            right++;\r\n            if (right >= sLen) {\r\n                return ans;\r\n            }\r\n            slideMap.put(s.charAt(right), slideMap.getOrDefault(s.charAt(right), 0) + 1);\r\n            slideMap.put(s.charAt(left), slideMap.get(s.charAt(left)) - 1);\r\n            left++;\r\n        } while (right < sLen);\r\n\r\n        return ans;\r\n    }\r\n\r\n    private boolean valid(Map<Character, Integer> targetMap, Map<Character, Integer> baseMap) {\r\n        for (Character key : targetMap.keySet()) {\r\n            if ((!baseMap.containsKey(key) && targetMap.get(key) > 0) ||\r\n            (baseMap.containsKey(key) && !baseMap.get(key).equals(targetMap.get(key)))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(p.length())","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491426394","body":"### 思路\r\n滑动窗口\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public String minWindow(String s, String t) {\r\n        if (s.length() < t.length()) {\r\n            return \"\";\r\n        }\r\n        boolean[] exists = new boolean[128];\r\n        int[] arr = new int[128];\r\n        for (char c : t.toCharArray()) {\r\n            exists[c] = true;\r\n            arr[c]++;\r\n        }\r\n\r\n        int cnt = 0, left = 0, right = 0, minLen = s.length() + 1, minIndex = 0;\r\n        for (; right < s.length(); right++) {\r\n            if (exists[s.charAt(right)]) {\r\n                arr[s.charAt(right)]--;\r\n                if (arr[s.charAt(right)] >= 0) {\r\n                    cnt++;\r\n                }\r\n\r\n                while (cnt == t.length()) {\r\n                    if (minLen > right - left + 1) {\r\n                        minLen = right - left + 1;\r\n                        minIndex = left;\r\n                    }\r\n                    if (exists[s.charAt(left)]) {\r\n                        arr[s.charAt(left)]++;\r\n                        if (arr[s.charAt(left)] > 0) {\r\n                            cnt--;\r\n                        }\r\n                    }\r\n                    left++;\r\n                }\r\n            }\r\n        }\r\n        return minLen > s.length() ? \"\" : s.substring(minIndex, minIndex + minLen);\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(C)，C 为字符集大小","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1493924001","body":"### 思路\r\n回溯\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int totalNQueens(int n) {\r\n        return solveNQueens(n).size();\r\n    }\r\n\r\n    public List<List<String>> solveNQueens(int n) {\r\n        List<List<String>> ans = new ArrayList<> ();\r\n        int[] cols = new int[n];\r\n        solveNQueens(n, 0, ans, cols);\r\n        return ans;\r\n    }\r\n\r\n    private void solveNQueens(int n, int row, List<List<String>> ans, int[] cols) {\r\n        if (row == n) {\r\n            List<String> oneAns = new ArrayList<> ();\r\n            for (int i = 0; i < n; i++) {\r\n                String tmp = \"\";\r\n                for (int j = 0; j < n; j++) {\r\n                    tmp += cols[i] == j ? \"Q\" : \".\";\r\n                }\r\n                oneAns.add(tmp);\r\n            }\r\n            ans.add(oneAns);\r\n            return;\r\n        }\r\n\r\n        for (int j = 0; j < n; j++) {\r\n            if (canVisit(n, cols, row, j)) {\r\n                cols[row] = j;\r\n                solveNQueens(n, row + 1, ans, cols);\r\n            }\r\n        }\r\n    }\r\n\r\n    private boolean canVisit(int n, int[] cols, int row, int col) {\r\n        int leftUp = col - 1, rightUp = col + 1;\r\n        for (int i = row - 1; i >= 0; i--) {\r\n            if (cols[i] == col) return false;\r\n            if (leftUp >= 0 && cols[i] == leftUp) return false;\r\n            if (rightUp < n && cols[i] == rightUp) return false;\r\n            leftUp--;rightUp++;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n!)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495136688","body":"### 思路\r\ndfs\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int maxAreaOfIsland(int[][] grid) {\r\n        int ans = 0;\r\n        for (int i = 0; i < grid.length; i++) {\r\n            for (int j = 0; j < grid[0].length; j++) {\r\n                if (grid[i][j] == 1) {\r\n                    ans = Math.max(ans, dfs(grid, i, j));\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    private int dfs(int[][] grid, int i, int j) {\r\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != 1) {\r\n            return 0;\r\n        }\r\n        grid[i][j] = 2;\r\n        return dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j + 1) + dfs(grid, i, j - 1) + 1;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度：O(mn)\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500872696","body":"### 思路\r\n动态规划\r\n定义 dp[i] 为到台阶 i 所需花费的最小费用，状态转移方程：dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int minCostClimbingStairs(int[] cost) {\r\n        int len = cost.length;\r\n        int[] dp = new int[len + 1];\r\n        dp[1] = cost[0];\r\n        for (int i = 2; i <= len; i++) {\r\n            dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i - 1];\r\n        }\r\n        return Math.min(dp[len - 1], dp[len]);\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501143581","body":"### 思路\r\n动态规划\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int rob(int[] nums) {\r\n        int preRobMax = 0, preNotRobMax = 0;\r\n        for (int num : nums) {\r\n            int curRobMax = preNotRobMax + num;\r\n            int curNotRobMax = Math.max(preRobMax, preNotRobMax);\r\n            preNotRobMax = curNotRobMax;\r\n            preRobMax = curRobMax;\r\n        }\r\n        return Math.max(preNotRobMax, preRobMax);\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1503621397","body":"### 思路\r\n定义状态 dp[i][j]，为字符串 text1.substring(0, i), text2.substring(0,j) 最大公共子序列的长度。\r\n转移方程为 dp[i][j] = dp[i-1][j-1] + 1，当text1中下标 i 的字符和text2中下标 j 的字符相等时；dp[i][j] = Math.max(dp[i-1], dp[i][j-1]，当两字符串结尾字符不相等时\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int longestCommonSubsequence(String text1, String text2) {\r\n        int text1Len = text1.length(), text2Len = text2.length();\r\n        int[][] dp = new int[text1Len + 1][text2Len + 1];\r\n        for (int i = 1; i <= text1Len; i++) {\r\n            for (int j = 1; j <= text2Len; j++) {\r\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\r\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\r\n                } else {\r\n                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);\r\n                }\r\n            }\r\n        }\r\n        return dp[text1Len][text2Len];\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n * m)\r\n- 空间复杂度：O(n * m)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511381005","body":"### 思路\r\n动态规划，定义状态方程 dp[i] 表示为达成金额 i 的最小硬币数据，转移方程 dp[i] = Math.min(dp[i - j], dp[i]) , j ∈ coins, 当 i - j >= 0\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int coinChange(int[] coins, int amount) {\r\n        if (amount == 0) {\r\n            return 0;\r\n        }\r\n        int[] dp = new int[amount + 1];\r\n\r\n        for (int i = 1; i <= amount; i++) {\r\n            dp[i] = amount + 1;\r\n        }\r\n\r\n        for (int i = 1; i <= amount; i++) {\r\n            for (int coin : coins) {\r\n                if (i >= coin) {\r\n                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);\r\n                }\r\n            }\r\n        }\r\n        return dp[amount] == amount + 1 ? -1 : dp[amount];\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(amount * len(coins))\r\n- 空间复杂度：O(amount)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1513375494","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int change(int amount, int[] coins) {\r\n        int[] dp = new int[amount + 1];\r\n        dp[0] = 1;\r\n        for (int coin : coins) {\r\n            for (int i = coin; i <= amount; i++) {\r\n                dp[i] += dp[i - coin];\r\n            }\r\n        }\r\n        return dp[amount];\r\n    }\r\n}\r\n```\r\n\r\n###复杂度分析\r\n- 时间复杂度：O(amount * n)\r\n- 空间复杂度：O(amount)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518663833","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int numTrees(int n) {\r\n        if (n == 1) {\r\n            return 1;\r\n        }\r\n        if (n == 2) {\r\n            return 2;\r\n        }\r\n        int[] dp = new int[n + 1];\r\n        dp[0] = 1;\r\n        dp[1] = 1;\r\n        dp[2] = 2;\r\n        for (int i = 3; i <= n; i++) {\r\n            for (int j = 0; j < i; j++) {\r\n                dp[i] += dp[j] * dp[i - j - 1];\r\n            }\r\n        }\r\n        return dp[n];\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n^2)\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1525913677","body":"### 代码实现\r\n```java\r\nclass Trie {\r\n\r\n    private Node[] root;\r\n    private Node[] cur;\r\n\r\n    public Trie() {\r\n        root = new Node[26];\r\n        cur = root;\r\n    }\r\n    \r\n    public void insert(String word) {\r\n        cur = root;\r\n        Node curNode = null;\r\n        for (char c : word.toCharArray()) {\r\n            int index = c - 'a';\r\n            if (cur[index] == null) {\r\n                cur[index] = new Node();\r\n            }\r\n            curNode = cur[index];\r\n            cur = cur[index].next;\r\n        }\r\n        curNode.end = true;\r\n    }\r\n    \r\n    public boolean search(String word) {\r\n        cur = root;\r\n        Node curNode = null;\r\n        for (char c : word.toCharArray()) {\r\n            int index = c - 'a';\r\n            if (cur[index] == null) {\r\n                return false;\r\n            }\r\n            curNode = cur[index];\r\n            cur = cur[index].next;\r\n        }\r\n        return curNode.end;\r\n    }\r\n    \r\n    public boolean startsWith(String prefix) {\r\n        cur = root;\r\n        Node curNode = null;\r\n        for (char c :  prefix.toCharArray()) {\r\n            int index = c - 'a';\r\n            if (cur[index] == null) {\r\n                return false;\r\n            }\r\n            curNode = cur[index];\r\n            cur = cur[index].next;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    class Node {\r\n        private boolean end;\r\n        private Node[] next = new Node[26];\r\n    }\r\n}\r\n\r\n/**\r\n * Your Trie object will be instantiated and called as such:\r\n * Trie obj = new Trie();\r\n * obj.insert(word);\r\n * boolean param_2 = obj.search(word);\r\n * boolean param_3 = obj.startsWith(prefix);\r\n */\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaodingc":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1433470554","body":"```\r\n        public IList<int> AddToArrayForm(int[] num, int k)\r\n        {\r\n            #region 方法1\r\n\r\n            //从右到左遍历数组，用carry记录每次需要相加的值，\r\n            //这里的carry并不是进位，而是数组A每个元素应该相加的值。\r\n            //A = [1,2,3,4], K = 34，那么tmp =4+34=38 将38%10=8添加进res数组中\r\n            //carry=38/10=3，tmp=3+3=6, A=[1,2,6,8] 1 33337\r\n\r\n            IList<int> res = new List<int>();\r\n            int carry = k;\r\n            for (int i = num.Length - 1; i >= 0; i--)\r\n            {\r\n                var tmp = num[i] + carry;\r\n                res.Add(tmp % 10);\r\n                carry = tmp / 10;\r\n            }\r\n\r\n            while (carry > 0)\r\n            {\r\n                res.Add(carry % 10);\r\n                carry = carry / 10;\r\n            }\r\n\r\n\r\n            return res.Reverse().ToList();\r\n            #endregion\r\n        }\r\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433349820","body":"C#版本\r\n```\r\npublic class CustomStack {\r\n    int[] num;\r\n    int cur = -1;\r\n\r\n    public CustomStack(int maxSize) {\r\n        num = new int[maxSize];\r\n    }\r\n    \r\n    public void Push(int x) {\r\n        if(cur < num.Length-1){\r\n            ++cur;\r\n            num[cur] = x;\r\n        }\r\n    }\r\n    \r\n    public int Pop() {\r\n        if(cur == -1)\r\n            return -1;\r\n        cur--;\r\n        return num[cur+1];\r\n    }\r\n    \r\n    int t;\r\n    public void Increment(int k, int val) {\r\n        t = Math.Min(k, cur +1);\r\n        for(int i = 0 ; i < t ; i++){\r\n            num[i] += val;\r\n        }\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434863642","body":"```  \r\n  //定义一个字符栈，一个数字栈\r\n  //如果是连续数字就对该数字进行转换操作\r\n  //如果遇到'[' 字符串及数字栈入栈，且数字置0\r\n  //如果遇到']'字符串 数字栈出栈 并根据出栈值循环字符串的长度\r\n  //如果不是上述情况，用StringBuilder追加该字符长度\r\n  public string DecodeString(string s)\r\n        {\r\n            Stack<string> stringStack = new Stack<string>();\r\n            Stack<int> numStack = new Stack<int>();\r\n            StringBuilder sb =new StringBuilder();\r\n            int num = 0;\r\n            foreach (var c in s)\r\n            {\r\n                if (c<='9' && c>='0')\r\n                {\r\n                    num =10*num+ (c - '0');\r\n                }\r\n                else if(c=='[')\r\n                {\r\n                    stringStack.Push(sb.ToString());\r\n                    numStack.Push(num);\r\n                    num = 0;\r\n                    sb=new StringBuilder();\r\n                }else if (c == ']')\r\n                {\r\n                    StringBuilder tem= new StringBuilder();\r\n                    int count = numStack.Pop();\r\n                    for (int i = 0; i < count; i++)\r\n                    {\r\n                        tem.Append(sb.ToString());\r\n                    }\r\n                    sb = new StringBuilder(stringStack.Pop() + tem);\r\n                }\r\n                else\r\n                {\r\n                    sb.Append(c);\r\n                }\r\n            }\r\n            return sb.ToString();\r\n        }\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1434886854","body":"```\r\n       public class MyQueue\r\n        {\r\n            private Stack<int> s1, s2;\r\n            public MyQueue()\r\n            {\r\n                s1=new Stack<int>();\r\n                s2=new Stack<int>();\r\n            }\r\n\r\n            public void Push(int x)\r\n            {\r\n                s1.Push(x);\r\n            }\r\n\r\n            public int Pop()\r\n            {\r\n                Peek();\r\n                return s2.Pop();\r\n            }\r\n\r\n            //1 2 3 // 3 2 1\r\n            public int Peek()\r\n            {\r\n                if (s2.Count==0)\r\n                {\r\n                    while (s1.Count!=0)\r\n                    {\r\n                        s2.Push(s1.Pop());\r\n                    }\r\n                }\r\n                return s2.Peek();\r\n            }\r\n\r\n            public bool Empty()\r\n            {\r\n                if (s1.Count==0 && s2.Count==0)\r\n                {\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436016116","body":"看了单调递增栈解答，想了好久时间才明白  \r\nC#版本\r\n```\r\n     public static int MaxChunksToSorted(int[] arr)\r\n        {\r\n            Stack<int> stack = new Stack<int>();\r\n            int i = 0;\r\n            while (arr.Length-1>=i)\r\n            {\r\n                var a = arr[i];\r\n                if (stack.Count>0 && stack.Peek()> a)\r\n                {\r\n                    int temp = stack.Peek();\r\n                    //注意 如果条件换了，stack为空时要加条件\r\n                    while (stack.Count > 0 && stack.Peek() > a)\r\n                    {\r\n                        stack.Pop();\r\n                      \r\n                    }\r\n                    stack.Push(temp);\r\n                }\r\n                else\r\n                {\r\n                    stack.Push(a);\r\n                }\r\n                i++;\r\n            }\r\n\r\n            return stack.Count;\r\n        }\r\n```\r\n复杂度分析\r\n1.时间复杂度：O(N)\r\n2.空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437232271","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     public int val;\r\n *     public ListNode next;\r\n *     public ListNode(int val=0, ListNode next=null) {\r\n *         this.val = val;\r\n *         this.next = next;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode RotateRight(ListNode head, int k) {\r\n        if(head == null || k==0)\r\n            return head;\r\n        ListNode cur = head;\r\n        ListNode pre = null;\r\n        int count = 1;\r\n        while(cur.next!=null)\r\n        {\r\n            cur = cur.next;\r\n            count++;\r\n        }\r\n        if(k>=count)\r\n        {\r\n            k%=count;\r\n        }\r\n        cur.next = head;\r\n        while(count-k>0)\r\n        {\r\n            pre = head;\r\n            head = head.next;\r\n            count--;\r\n        }\r\n        pre.next = null;\r\n        return head;\r\n    }\r\n}\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jyjsunny":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434348480","body":"import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.List;\n\n//import java.util.Scanner;\n\npublic class Solution {\n    //static int min = 100000000;\n\n    public static void main(String[] args){\n        //Scanner sc = new Scanner(System.in);\n        System.out.println(\"hello \");\n        String s = \"2[abc]3[cd]ef\";\n        //String s = \"3[a]2[bc]\";\n        decoder(s);\n       \n        //sc.close(); \n    }\n    public static String decoder(String s){\n\n        Deque<Integer> numStack  = new ArrayDeque<>();//??\n        Deque<Character> charStack = new ArrayDeque<>();\n        int len = s.length();\n        for(int i=0;i<len;i++){\n            char c = s.charAt(i);\n            if(isNumber(c)){//k计算\n                int num = c-'0';\n                while((i<(len-1))&&isNumber(s.charAt(i+1))){\n                    c=s.charAt(i+1);\n                    num*=10;\n                    num+=c-'0';\n                    i++;\n                }\n                numStack.push(num);\n            }\n            else{\n                if(c!=']')\n                    charStack.push(c);\n                else{\n                    int k = numStack.pollFirst();\n                    List<Character> tmp = new ArrayList<>();\n                    while(charStack.peek()!='['){\n                        char cc = charStack.pollFirst();\n                       tmp.add(cc); \n                    }\n                    //System.out.println(charStack.peek());\n                    charStack.pop();\n                    for(int j=0;j<k;j++){\n                        \n                        for(int p = tmp.size()-1;p>=0;p--){\n                            //System.out.print(tmp.get(p));\n                            charStack.push(tmp.get(p));\n                        }\n                    }\n                    \n                    \n                }\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        while(!charStack.isEmpty()){\n            sb.append(charStack.pollLast());\n        }\n        System.out.println(sb.toString());\n\n        return sb.toString();\n    }\n    public static boolean isNumber(char c){\n        return ((c-'0')>=0 && (c-'0')<=9)?true:false;\n    }\n\n    \n\n\n\n\n\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438528833","body":"## 思路\n\n-    方法一：设置pre和node，每两个点为一组表示关系、进行交换（看重链表性质以及构造逻辑）\n-    方法二：两点为一组，递归求解（利用递归特性）\n\n## 代码\n```\n//方法一：利用list逻辑\n    public static ListNode SwapList(ListNode node){\n        if(node==null||node.next==null)  return node;\n        ListNode newhead = node.next;\n        ListNode pre = new ListNode();\n        pre.next = node;\n\n        while(node!=null&&node.next!=null){\n            pre.next = node.next;\n            node.next = node.next.next;\n            pre.next.next = node;\n            pre = node;\n            node = pre.next;\n        }\n    \n        return newhead;\n    }\n//方法二：利用递归\n    public static ListNode SwapList(ListNode node){\n        //方法二：递归\n        //递归：1）终止条件，2）返回值，3）单步过程\n        //终止条件\n        if(node==null||node.next==null)\n        {\n            return node;\n        }\n        ListNode next = node.next;\n        //单步过程\n        node.next= SwapList(next.next);\n        next.next=node;\n        //返回值\n        return next;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aoxiangw":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434802798","body":"```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for i in range(len(s)):\r\n            if s[i] != \"]\":\r\n                stack.append(s[i])\r\n            else:\r\n                cur = \"\"\r\n                while stack[-1] != \"[\":\r\n                    cur = stack.pop() + cur\r\n                stack.pop()\r\n\r\n                k = \"\"\r\n                while stack and stack[-1].isdigit():\r\n                    k = stack.pop() + k\r\n                stack.append(cur * int(k))\r\n        return \"\".join(stack)\r\n```\r\n\r\nTime complexity: O(n)\r\nSpace complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435480497","body":"```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.input = []\r\n        self.output = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.input.append(x)\r\n\r\n    def pop(self) -> int:\r\n        self.peek()\r\n        return self.output.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.output:\r\n            while self.input:\r\n                self.output.append(self.input.pop())\r\n        return self.output[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return not self.input() and not self.output()\r\n```\r\nTime complexity: O(1)\r\nSpace complexity: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438635504","body":"```python\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        dummy = ListNode(0, head)\r\n        prev, cur = dummy, head\r\n        while cur and cur.next:\r\n            second = cur.next\r\n            nxt = cur.next.next\r\n            cur.next = nxt\r\n            second.next = cur\r\n            prev = cur\r\n            cur = nxt\r\n        return dummy.next\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448283072","body":"```python\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        def dfs(cur, num):\r\n            if not cur:\r\n                return 0\r\n            num = num * 10 + cur.val\r\n            if not cur.left and not cur.right:\r\n                return num\r\n            return dfs(cur.left, num) + dfs(cur.right, num)\r\n        return dfs(root, 0)\r\n```\r\nTime complexity: O(n)\r\nSpace complexity: O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450371762","body":"```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        q = deque([root])\r\n        while q:\r\n            node = q.popleft()\r\n            if node.right:\r\n                q.append(node.right)\r\n            if node.left:\r\n                q.append(node.left)\r\n        return node.val\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1452106405","body":"```python\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        res = []\r\n        \r\n        def dfs(node):\r\n            if not node:\r\n                res.append(\"null\")\r\n                return\r\n            res.append(str(node.val))\r\n            dfs(node.left)\r\n            dfs(node.right)\r\n            \r\n        dfs(root)\r\n        return \",\".join(res)\r\n        \r\n    def deserialize(self, data):\r\n        vals = data.split(\",\")\r\n        self.i = 0\r\n        \r\n        def dfs():\r\n            if vals[self.i] == \"null\":\r\n                self.i += 1\r\n                return None\r\n            node = TreeNode(int(vals[self.i]))\r\n            self.i += 1\r\n            node.left = dfs()\r\n            node.right = dfs()\r\n            return node\r\n        \r\n        return dfs()\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1453735679","body":"```python\r\nclass Solution:\r\n  def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n    ans = []\r\n    xToNodes = collections.defaultdict(list)\r\n\r\n    def dfs(node: Optional[TreeNode], x: int, y: int) -> None:\r\n      if not node:\r\n        return\r\n\r\n      xToNodes[x].append((-y, node.val))\r\n      dfs(node.left, x - 1, y - 1)\r\n      dfs(node.right, x + 1, y - 1)\r\n\r\n    dfs(root, 0, 0)\r\n\r\n    for _, nodes in sorted(xToNodes.items(), key=lambda item: item[0]):\r\n      ans.append([val for _, val in sorted(nodes)])\r\n\r\n    return ans\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463187242","body":"```python\r\nclass Solution:\r\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        return slow\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465215293","body":"```python\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        l, r = 0, len(nums)\r\n        while l < r:\r\n            m = (l + r) // 2\r\n            if nums[m] == target:\r\n                return m\r\n            if nums[m] < target:\r\n                l = m + 1\r\n            else:\r\n                r = m\r\n        return l\r\n```\r\nTime: N(logn)\r\nSpace: N(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467415825","body":"```python\r\nclass Solution:\r\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\r\n        count = [0] * (n + 1)\r\n        for a, b in trust:\r\n            count[a] -= 1\r\n            count[b] += 1\r\n\r\n        for i in range(1, n + 1):\r\n            if count[i] == n - 1:\r\n                return i\r\n        \r\n        return -1\r\n```\r\nTime, Space: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473149324","body":"```python\r\nclass Solution:\r\n    def judgeCircle(self, moves: str) -> bool:\r\n        origin = {\"X\":0, \"Y\":0}\r\n        for move in moves:\r\n            if move == \"U\":\r\n                origin[\"X\"] += 1\r\n            elif move == \"D\":\r\n                origin[\"X\"] -= 1\r\n            elif move == \"L\":\r\n                origin[\"Y\"] -= 1\r\n            elif move == \"R\":\r\n                origin[\"Y\"] += 1\r\n        return origin['X'] == 0 and origin['Y'] == 0\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/39#issuecomment-1474886076","body":"```python\r\nclass Solution:\r\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\r\n        n = len(tasks)\r\n        A = [[*task, i] for i, task in enumerate(tasks)]\r\n        ans = []\r\n        minHeap = []\r\n        i = 0\r\n        time = 0\r\n\r\n        A.sort()\r\n\r\n        while i < n or minHeap:\r\n            if not minHeap:\r\n                time = max(time, A[i][0])\r\n            while i < n and time >= A[i][0]:\r\n                heapq.heappush(minHeap, (A[i][1], A[i][2]))\r\n                i += 1\r\n            procTime, index = heapq.heappop(minHeap)\r\n            time += procTime\r\n            ans.append(index)\r\n\r\n        return ans\r\n```\r\nTime, Space: O(nlogn), O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475837699","body":"```python\r\nclass Solution:\r\n    def minCharacters(self, a: str, b: str) -> int:\r\n        countA = collections.Counter(a)\r\n        countB = collections.Counter(b)\r\n        s = countA + countB\r\n        res = len(a) + len(b) - max(s.values())\r\n        nord = lambda x: ord(x) - 97\r\n        for bd in range(nord('a'),nord('z')):\r\n            res1, res2 = 0, 0\r\n            for m in countA:\r\n                if nord(m) > bd:\r\n                    res1 += countA[m]\r\n                else:\r\n                    res2 += countA[m]\r\n            for n in countB:\r\n                if nord(n) > bd:\r\n                    res2 += countB[n]\r\n                else:\r\n                    res1 += countB[n]\r\n            \r\n            res = min(res, res1, res2)\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1478062649","body":"```python\r\nclass Solution:\r\n    def sortArray(self, nums: List[int]) -> List[int]:\r\n        def merge(arr, L, M, R):\r\n            left, right = arr[L:M+1], arr[M+1:R+1]\r\n            i, j, k = L, 0, 0\r\n\r\n            while j < len(left) and k < len(right):\r\n                if left[j] <= right[k]:\r\n                    arr[i] = left[j]\r\n                    j += 1\r\n                else:\r\n                    arr[i] = right[k]\r\n                    k += 1\r\n                i += 1\r\n            while j < len(left):\r\n                nums[i] = left[j]\r\n                j += 1\r\n                i += 1\r\n            while k < len(right):\r\n                nums[i] = right[k]\r\n                k += 1\r\n                i += 1\r\n\r\n\r\n        def mergeSort(arr, l, r):\r\n            if l == r:\r\n                return arr\r\n            m = (l + r) // 2\r\n            mergeSort(arr, l, m)\r\n            mergeSort(arr, m + 1, r)\r\n            merge(arr, l, m, r)\r\n            return arr\r\n        return mergeSort(nums, 0, len(nums) - 1)\r\n```\r\nO(nlogn), O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1481370351","body":"```python\r\nclass Solution:\r\n    def firstBadVersion(self, n: int) -> int:\r\n        l, r = 1, n\r\n        while l < r:\r\n            m = (l + r) // 2\r\n            if isBadVersion(m):\r\n                r = m\r\n            else:\r\n                l = m + 1\r\n        return l\r\n```\r\nO(logN), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482330582","body":"```python\r\ndef reversePairs(self, nums: List[int]) -> int:\r\n    res = 0\r\n    aux = []\r\n    for y in nums:\r\n        i = bisect.bisect_right(aux, y * 2)\r\n        res += len(aux) - i\r\n        bisect.insort(aux, y)\r\n    return res\r\n```\r\nTime, space: O(nlogn), O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483752100","body":"Minimum Light Radius\r\n```python\r\nimport bisect\r\ndef solve(nums):\r\n    nums.sort()\r\n    N = len(nums)\r\n    if N <= 3:\r\n        return 0\r\n    lights = 3\r\n\r\n    def possible(diameter):\r\n        start = nums[0]\r\n        end = start + diameter\r\n        for i in range(lights):\r\n            i = bisect.bisect_right(nums, end)\r\n            if i >= N:\r\n                return True\r\n            start = nums[i]\r\n            end = start + diameter\r\n        return False\r\n    \r\n    l, r = 0, nums[-1] - nums[0]\r\n    while l <= r:\r\n        mid = (l + r) // 2\r\n        if possible(mid):\r\n            r = mid - 1\r\n        else:\r\n            l = mid + 1\r\n    return l / 2\r\n```\r\nTime, space: O(nlogn), O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1485264788","body":"```python\r\nclass Solution:\r\n    def swimInWater(self, grid: List[List[int]]) -> int:\r\n        N = len(grid)\r\n        visit = set()\r\n        minH = [[grid[0][0], 0, 0]]\r\n        directions = [[0,1], [0,-1], [1,0], [-1,0]]\r\n        visit.add((0,0))\r\n        while minH:\r\n            t, r, c = heapq.heappop(minH)\r\n            visit.add((r,c))\r\n            if r == N - 1 and c == N - 1:\r\n                return t\r\n            for dr, dc in directions:\r\n                neiR, neiC = r + dr, c + dc\r\n                if (neiR < 0 or neiC < 0 or\r\n                    neiR == N or neiC == N or\r\n                    (neiR, neiC) in visit):\r\n                    continue\r\n                visit.add((neiR, neiC))\r\n                heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])\r\n```\r\ntime, space: O(n^2logn), O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486961751","body":"```python\r\nclass Solution:\r\n    def maxVowels(self, s: str, k: int) -> int:\r\n        maxv, ans = 0, 0\r\n        vowels = {'a', 'e', 'i', 'o', 'u'}\r\n        for i, c in enumerate(s):\r\n            if c in vowels:\r\n                maxv += 1\r\n            if i >= k and s[i - k] in vowels:\r\n                maxv -= 1\r\n            ans = max(ans, maxv)\r\n        return ans\r\n```\r\ntime, space: O(n), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/50#issuecomment-1488068113","body":"```python\r\nclass Solution:\r\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\r\n        dp = [0.0] * (k + maxPts)\r\n        for i in range(k, min(n + 1, k + maxPts)):\r\n            dp[i] = 1.0\r\n        s = min(n - k + 1,maxPts)\r\n        for j in range(k -1, -1, -1):\r\n            dp[j] = s/float(maxPts)\r\n            s += dp[j] - dp[j + maxPts]\r\n        return dp[0]\r\n```\r\ntime, space: O(n+1)/O(k+maxPts), O(k + maxPts)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489957013","body":"```python\r\nclass Solution:\r\n    def findAnagrams(self, s: str, p: str) -> List[int]:\r\n        if len(p) > len(s):\r\n            return []\r\n        sCount, pCount = {}, {}\r\n        for i in range(len(p)):\r\n            sCount[s[i]] = sCount.get(s[i], 0)\r\n            pCount[p[i]] = pCount.get(p[i], 0)\r\n        res = [0] if sCount == pCount else []\r\n        \r\n        l = 0\r\n        for r in range(len(p), len(s)):\r\n            sCount[s[r]] = 1 + sCount.get(s[r], 0)\r\n            sCount[s[l]] -= 1\r\n            if sCount[s[l]] == 0:\r\n                sCount.pop(s[l])\r\n            l += 1\r\n            if sCount == pCount:\r\n                res.append(l)\r\n        return res\r\n```\r\ntime, space: O(n), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491446319","body":"```python\r\nclass Solution:\r\n    def minWindow(self, s: str, t: str) -> str:\r\n        if t == \"\":\r\n            return \"\"\r\n        countT, window = {}, {}\r\n        for c in t:\r\n            countT[c] = 1 + countT.get(c, 0)\r\n        \r\n        l = 0\r\n        res, resLen = [-1,-1], float(\"inf\")\r\n        have, need = 0, len(countT)\r\n\r\n        for r in range(len(s)):\r\n            c = s[r]\r\n            window[c] = 1 + window.get(c, 0)\r\n            \r\n            if c in countT and window[c] == countT[c]:\r\n                have += 1\r\n\r\n            while have == need:\r\n                if (r - l + 1) < resLen:\r\n                    res = [l, r]\r\n                    resLen = r - l + 1\r\n                window[s[l]] -= 1\r\n                if s[l] in countT and window[s[l]] < countT[s[l]]:\r\n                    have -= 1\r\n                l += 1\r\n        \r\n        l, r = res\r\n        return s[l:r+1] if resLen != float(\"inf\") else \"\"\r\n```\r\nO(s+t), O(t)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1492822239","body":"```python\r\ndef solve(A, target):\r\n    if not A and not target:\r\n        return 0\r\n    newT = sum(A) - target\r\n    ans = len(A) + 1\r\n    i = t = 0\r\n\r\n    for j in range(len(A)):\r\n        t += A[j]\r\n        while i <= j and t > newT:\r\n            t -= A[i]\r\n            i += 1\r\n        if t == newT:\r\n            ans = min(ans, len(A) - (j - i + 1))\r\n    return -1 if ans == len(A) + 1 else ans\r\n```\r\ntime, space: O(n), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493198910","body":"```python\r\nclass Solution:\r\n    def readBinaryWatch(self, num: int) -> List[str]:\r\n        return [f\"{h}:{m:02d}\" for h in range(12) for m in range(60) if bin(h).count('1') + bin(m).count('1') == num]\r\n```\r\nO(1), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1493910155","body":"```python\r\nclass Solution:\r\n    def totalNQueens(self, n: int) -> int:\r\n        col = set()\r\n        posDiag = set()\r\n        negDiag = set()\r\n\r\n        res = 0\r\n        def backtrack(r):\r\n            if r == n:\r\n                nonlocal res\r\n                res += 1\r\n                return\r\n          \r\n            for c in range(n):\r\n                if c in col or (r + c) in posDiag or (r - c) in negDiag:\r\n                    continue\r\n\r\n                col.add(c)\r\n                posDiag.add(r + c)\r\n                negDiag.add(r - c)\r\n                backtrack(r + 1)\r\n                col.remove(c)\r\n                posDiag.remove(r + c)\r\n                negDiag.remove(r - c)\r\n        \r\n        backtrack(0)\r\n        return res\r\n```\r\nTime, space: O(n!), O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495495997","body":"```python\r\nclass Solution:\r\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\r\n        if not grid:\r\n            return 0\r\n        m = len(grid)\r\n        n = len(grid[0])\r\n        ans = 0\r\n        def dfs(i, j):\r\n            if i < 0 or i >= m or j < 0 or j >= n:\r\n                return 0\r\n            if grid[i][j] == 0:\r\n                return 0\r\n            grid[i][j] = 0\r\n            top = dfs(i - 1, j)\r\n            bottom = dfs(i + 1, j)\r\n            left = dfs(i, j - 1)\r\n            right = dfs(i, j + 1)\r\n            return 1 + sum([top, bottom, left, right])\r\n        for i in range(m):\r\n            for j in range(n):\r\n                ans = max(ans, dfs(i, j))\r\n        return ans\r\n```\r\nO(m*n), O(m*n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497387016","body":"```python\r\nclass Solution:\r\n    def maxDistance(self, grid: List[List[int]]) -> int:\r\n        N = len(grid)\r\n        q = deque()\r\n        for r in range(N):\r\n            for c in range(N):\r\n                if grid[r][c]:\r\n                    q.append([r,c])\r\n        res = -1\r\n        direct = [[0,1],[1,0],[0,-1],[-1,0]]\r\n        while q:\r\n            r, c = q.popleft()\r\n\r\n            res = grid[r][c]\r\n            for dr,dc in direct:\r\n                newR, newC = r + dr, c + dc\r\n                if (min(newR, newC) >= 0 and\r\n                    max(newR, newC) < N and\r\n                    grid[newR][newC] == 0):\r\n                    q.append([newR, newC])\r\n                    grid[newR][newC] = grid[r][c] + 1\r\n        return res - 1 if res > 1 else -1\r\n```\r\ntime, space: O(n^2), O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1499231957","body":"```python\r\nclass Solution:\r\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\r\n        boxes = set(initialBoxes)\r\n        q = [i for i in boxes if status[i]]\r\n        for i in q:\r\n            for j in containedBoxes[i]:\r\n                boxes.add(j)\r\n                if status[j]:\r\n                    q.append(j)\r\n            for j in keys[i]:\r\n                if status[j] == 0 and j in boxes:\r\n                    q.append(j)\r\n                status[j] = 1\r\n        return sum(candies[i] for i in q)\r\n```\r\ntime, space: O(n^2), O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1500096870","body":"```python\r\nfrom collections import deque, defaultdict\r\n\r\nclass TreeNode:\r\n    def __init__(self, val, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\nclass Solution:\r\n    def top_view(self, root):\r\n        if not root:\r\n            return []\r\n        hd = defaultdict(list)\r\n        queue = deque([(root, 0)])\r\n        while queue:\r\n            cur, pos = queue.popleft()\r\n            hd[pos].append(cur.val)\r\n            if cur.left:\r\n                queue.append(cur.left, pos - 1)\r\n            if cur.right:\r\n                queue.append(cur.right, pos + 1)\r\n        \r\n        return [hd[pos][0] for pos in sorted(hd.keys())]\r\n```\r\ntime, space: O(nlogn), O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500905234","body":"```python\r\nclass Solution:\r\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\r\n        cost.append(0)\r\n        for i in range(2, len(cost)):\r\n            cost[i] += min(cost[i-2], cost[i-1])\r\n        return cost[-1]\r\n```\r\ntime, space: O(n), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501157618","body":"```python\r\nclass Solution:\r\n    def rob(self, nums: List[int]) -> int:\r\n        if not nums:\r\n            return 0\r\n        if len(nums) == 1:\r\n            return nums[0]\r\n\r\n        dp = [0] * len(nums)\r\n        dp[0] = nums[0]\r\n        dp[1] = max(nums[0], nums[1])\r\n\r\n        for i in range(2, len(nums)):\r\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\r\n\r\n        return dp[-1]\r\n```\r\ntime, space: O(n), O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1502597184","body":"```python\r\nclass Solution:\r\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\r\n    \tm, n = len(text1), len(text2)\r\n    \tdp = [[0] * (n + 1) for _ in range(m + 1)]\r\n    \t\r\n    \tfor i in range(m):\r\n    \t\tfor j in range(n):\r\n    \t\t\tif text1[i] == text2[j]:\r\n    \t\t\t\tdp[i + 1][j + 1] = 1 + dp[i][j]\r\n    \t\t\telse:\r\n    \t\t\t\tdp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])\r\n\r\n    \treturn dp[m][n]\r\n```\r\ntime, space: O(m*n), O(m*n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1504436249","body":"```python\r\nclass Solution:\r\n    def uniquePaths(self, m: int, n: int) -> int:\r\n        row = [1] * n\r\n        for i in range(m - 1):\r\n            new_row = [1] * n\r\n            for j in range(n-2, -1, -1):\r\n                new_row[j] = new_row[j + 1] + row[j]\r\n            row = new_row\r\n        return row[0]\r\n```\r\ntime, space: O(mn), O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1507055708","body":"```python\r\nclass Solution:\r\n  def knightProbability(self, n: int, K: int, r: int, c: int) -> float:\r\n    dirs = [(1, 2), (2, 1), (2, -1), (1, -2),\r\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2)]\r\n\r\n    dp = [[0] * n for _ in range(n)]\r\n    dp[r][c] = 1\r\n\r\n    for _ in range(K):\r\n      newDp = [[0] * n for _ in range(n)]\r\n      for i in range(n):\r\n        for j in range(n):\r\n          for dx, dy in dirs:\r\n            x = i + dx\r\n            y = j + dy\r\n            if 0 <= x < n and 0 <= y < n:\r\n              newDp[i][j] += dp[x][y]\r\n      dp = newDp\r\n\r\n    return sum(map(sum, dp)) / 8**K\r\n```\r\ntime, space: O(kn^2), O(n^2)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509820187","body":"```python\r\nclass Solution:\r\n    def canPartition(self, nums: List[int]) -> bool:\r\n        if sum(nums) % 2:\r\n            return False\r\n        dp = set()\r\n        dp.add(0)\r\n        target = sum(nums) // 2\r\n        for i in range(len(nums) - 1, -1, -1):\r\n            nextDP = set()\r\n            for t in dp:\r\n                if (t + nums[i]) == target:\r\n                    return True\r\n                nextDP.add(t + nums[i])\r\n                nextDP.add(t)\r\n            dp = nextDP\r\n        return True if target in dp else False\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510411137","body":"```python\r\nclass Solution:\r\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\r\n        dp = {}\r\n        def backtrack(i, total):\r\n            if i == len(nums):\r\n                return 1 if total == target else 0\r\n            if (i, total) in dp:\r\n                return dp[(i, total)]\r\n\r\n            dp[(i, total)] = (backtrack(i + 1, total + nums[i]) + backtrack(i + 1, total - nums[i]))\r\n            return dp[(i, total)]\r\n        return backtrack(0, 0)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511638047","body":"```python\r\nclass Solution:\r\n    def coinChange(self, coins: List[int], amount: int) -> int:\r\n        dp = (amount + 1) * [amount + 1]\r\n        dp[0] = 0\r\n        \r\n        for i in range(1, amount + 1):\r\n            for c in coins:\r\n                if i - c >= 0:\r\n                    dp[i] = min(dp[i], 1 + dp[i-c])\r\n        return dp[amount] if dp[amount] != amount + 1 else -1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1512371746","body":"```python\r\nclass Solution:\r\n    def change(self, amount: int, coins: List[int]) -> int:\r\n        dp = [0] * (amount + 1)\r\n        dp[0] = 1\r\n        for i in range(len(coins) -1, -1, -1):\r\n            nextDP = [0] * (amount + 1)\r\n            nextDP[0] = 1\r\n\r\n            for a in range(1, amount + 1):\r\n                nextDP[a] = dp[a]\r\n                if a - coins[i] >= 0:\r\n                    nextDP[a] += nextDP[a - coins[i]]\r\n            dp = nextDP\r\n        return dp[amount]\r\n```\r\ntime, space: O(amount * len(coins)), O(amount)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514116726","body":"```python\r\nclass Solution:\r\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\r\n        g.sort()\r\n        s.sort()\r\n        i, j = 0, 0\r\n        while i < len(g) and j < len(s):\r\n            if s[j] >= g[i]:\r\n                i += 1\r\n                j += 1\r\n            else:\r\n                j += 1\r\n        return i\r\n```\r\nO(nlogn), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516478968","body":"```python\r\nclass Solution:\r\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\r\n        intervals.sort()\r\n        res = 0\r\n        prevEnd = intervals[0][1]\r\n        for s, e in intervals[1:]:\r\n            if s >= prevEnd:\r\n                prevEnd = e\r\n            else:\r\n                res += 1\r\n                prevEnd = min(e, prevEnd)\r\n        return res\r\n```\r\ntime, space: O(nlogn), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517190771","body":"```python\r\nclass Solution:\r\n    def canJump(self, nums: List[int]) -> bool:\r\n        goal = len(nums) - 1\r\n        for i in range(len(nums) - 1, -1, -1):\r\n            if nums[i] + i >= goal:\r\n                goal = i\r\n        return goal == 0\r\n```\r\ntime, space: O(n), O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519095980","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\r\n        if not lists or len(lists) == 0:\r\n            return None\r\n        \r\n        while len(lists) > 1:\r\n            merge = []\r\n            for i in range(0, len(lists), 2):\r\n                l1 = lists[i]\r\n                l2 = lists[i + 1] if (i + 1) < len(lists) else None\r\n                merge.append(self.mergeTwoLists(l1, l2))\r\n            lists = merge\r\n        return lists[0]\r\n                \r\n    def mergeTwoLists(self, l1, l2):\r\n        dummy = ListNode()\r\n        tail = dummy\r\n        while l1 and l2:\r\n            if l1.val < l2.val:\r\n                tail.next = l1\r\n                l1 = l1.next\r\n            else:\r\n                tail.next = l2\r\n                l2 = l2.next\r\n            tail = tail.next\r\n        if l1:\r\n            tail.next = l1\r\n        elif l2:\r\n            tail.next = l2\r\n        return dummy.next\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1519294695","body":"```python\r\nclass Solution:\r\n    def beautifulArray(self, n: int) -> List[int]:\r\n        @lru_cache(None)\r\n        def dp(n):\r\n            if n == 1:\r\n                return [1]\r\n            ans = []\r\n            for a in dp(n - n // 2):\r\n                ans += [a * 2 - 1]\r\n            for b in dp(n // 2):\r\n                ans += [b * 2]\r\n            return ans\r\n        \r\n        return dp(n)\r\n```\r\nO(nlogn), O(n + logn)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1523644875","body":"```python\r\nclass Solution:\r\n    def subsets(self, nums: List[int]) -> List[List[int]]:\r\n        res = []\r\n        subset = []\r\n        def dfs(i):\r\n            if i >= len(nums):\r\n                res.append(subset.copy())\r\n                return\r\n            subset.append(nums[i])\r\n            dfs(i + 1)\r\n            subset.pop()\r\n            dfs(i + 1)\r\n        \r\n        dfs(0)\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1525952198","body":"```python\r\nclass TrieNode:\r\n    def __init__(self):\r\n        self.children = {}\r\n        self.end = False\r\n    \r\nclass Trie:\r\n\r\n    def __init__(self):\r\n        self.root = TrieNode()\r\n\r\n    def insert(self, word: str) -> None:\r\n        cur = self.root\r\n        for w in word:\r\n            if w not in cur.children:\r\n                cur.children[w] = TrieNode()\r\n            cur = cur.children[w]\r\n        cur.end = True\r\n\r\n    def search(self, word: str) -> bool:\r\n        cur = self.root\r\n        for w in word:\r\n            if w not in cur.children:\r\n                return False\r\n            cur = cur.children[w]\r\n        return cur.end\r\n\r\n    def startsWith(self, prefix: str) -> bool:\r\n        cur = self.root\r\n        for p in prefix:\r\n            if p not in cur.children:\r\n                return False\r\n            cur = cur.children[p]\r\n        return True\r\n```","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1529753102","body":"```python\r\nclass Solution(object):\r\n    def minMalwareSpread(self, graph, initial):\r\n        \"\"\"\r\n        :type graph: List[List[int]]\r\n        :type initial: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        def find(x):\r\n            while x != uf[x]:\r\n                uf[x] = uf[uf[x]]\r\n                x = uf[x]\r\n            return uf[x]\r\n\r\n        def union(x, y):\r\n            x_root = find(x)\r\n            y_root = find(y)\r\n            uf[x_root] = y_root\r\n    \r\n        uf = [i for i in range(len(graph))]\r\n        for i in range(len(graph)):\r\n            for j in range(i+1, len(graph)):\r\n                if graph[i][j]:\r\n                    union(i, j)\r\n                    \r\n        lookup, dup = {}, {}\r\n        for i in range(len(graph)):\r\n            root = find(i)\r\n            lookup[root] = lookup.get(root, 0) + 1\r\n            if i in initial:\r\n                dup[root] = dup.get(root, -1) + 1\r\n            \r\n        component_sizes_of_initial = [lookup[find(ini)]-dup[find(ini)] for ini in initial]\r\n        max_component_size = max(component_sizes_of_initial)\r\n        \r\n        res = []\r\n        for i in range(len(initial)):\r\n            if component_sizes_of_initial[i] == max_component_size:\r\n                res.append(initial[i])\r\n        return min(res)\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1535830408","body":"```python\r\nclass Solution:\r\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\r\n        res = []\r\n        candidates.sort()\r\n\r\n        def backtrack(s, target, path):\r\n            if target < 0:\r\n                return\r\n            if target == 0:\r\n                res.append(path[::])\r\n\r\n            for i in range(s, len(candidates)):\r\n                if i > s and candidates[i] == candidates[i - 1]:\r\n                    continue\r\n                path.append(candidates[i])\r\n                backtrack(i + 1, target - candidates[i], path)\r\n                path.pop()\r\n                \r\n        backtrack(0, target, [])\r\n        return res\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null],"enrilwang":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435392513","body":"class MyQueue {\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n\r\n    public MyQueue() {\r\n        inStack = new LinkedList<Integer>();\r\n        outStack = new LinkedList<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n\r\n    private void in2out() {\r\n        while (!inStack.isEmpty()) {\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438574762","body":"{\r\npublic ListNode swapPairs(ListNode head) {\r\n    if(head == null || head.next == null){\r\n        return head;\r\n    }\r\n\r\n    ListNode temp = head.next;\r\n    head.next = swapPairs(temp.next);\r\n    temp.next = head;\r\n    return temp;\r\n}\r\n}","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448255574","body":"public int sumNumbers(TreeNode root) {\r\n        return dfs(root, 0);\r\n    }\r\n\r\n    private int dfs(TreeNode root, int path) {\r\n        if (root == null) return 0;\r\n\r\n        path = path * 10 + root.val;\r\n        if (root.left == null && root.right == null) return path;\r\n\r\n        return dfs(root.left, path) + dfs(root.right, path);\r\n    }","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454689088","body":"class Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        seen = {}\r\n        for index, num in enumerate(nums):\r\n            diff = target - num\r\n            if diff in seen:\r\n                return [seen[diff], index]\r\n            seen[num] = index","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1460034139","body":"class Solution {\r\npublic:\r\n    vector<int> findSubstring(string s, vector<string>& words) {\r\n        vector<int> res;\r\n        int l=words.size()*words[0].size();\r\n        unordered_map<string,int> hashs,hashscur;\r\n        for(string x:words) hashs[x]++;\r\n        for(int i=0;i<s.length()-l+1;i++){\r\n            string curtarget=s.substr(i,l);\r\n            hashscur.clear();\r\n            for(int j=0;j<words.size();j++){\r\n                string subcurtarget=curtarget.substr(j*words[0].size(),words[0].size());\r\n                if(hashs.count(subcurtarget)){\r\n                    hashscur[subcurtarget]++;\r\n                    if(hashscur[subcurtarget]>hashs[subcurtarget]) break;\r\n                }\r\n                else break;\r\n               \r\n                if(j==words.size()-1) res.emplace_back(i);\r\n            }\r\n\r\n        }\r\n        return res;\r\n    }\r\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468322845","body":"class Solution {\r\npublic:\r\n    int findJudge(int n, vector<vector<int>>& trust) {\r\n        map<int,int> trustcnt,trustedcnt;\r\n        int m=trust.size();\r\n        for(int i=0;i<m;i++){\r\n            trustcnt[trust[i][0]-1]++;\r\n            trustedcnt[trust[i][1]-1]++;\r\n        }\r\n        for(int i=0;i<n;i++){\r\n            if(trustedcnt[i]==n-1&&trustcnt[i]==0) return i+1;\r\n        }\r\n\r\n        return -1;\r\n    }\r\n};\r\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476452375","body":" public int minCharacters(String a, String b) {\r\n        int an = a.length();\r\n        int[] aCnt = new int[26];\r\n        for (int i = 0; i < an; i++)\r\n            aCnt[a.charAt(i) - 'a']++;\r\n\r\n        int bn = b.length();\r\n        int[] bCnt = new int[26];\r\n        for (int i = 0; i < bn; i++)\r\n            bCnt[b.charAt(i) - 'a']++;\r\n\r\n        int ans = Integer.MAX_VALUE;\r\n        int aSum = 0;\r\n        int bSum = 0;\r\n        for (int i = 0; i < 25; i++) { // exclude 'z'\r\n            aSum += aCnt[i];\r\n            bSum += bCnt[i];\r\n\r\n            ans = Math.min(\r\n                    // a > b or b > a\r\n                    Math.min(aSum + bn - bSum, bSum + an - aSum),\r\n                    // a == b\r\n                    Math.min(ans, an - aCnt[i] + bn - bCnt[i])\r\n            );\r\n        }\r\n\r\n        ans = Math.min(ans, an - aCnt[25] + bn - bCnt[25]);\r\n\r\n        return ans;\r\n    }","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483751321","body":"class Solution:\r\n    def solve(self, nums):\r\n        nums.sort()\r\n\r\n        def can_light_up(diameter):\r\n            index = bisect(nums, nums[0] + diameter * 3)\r\n            return True if index >= len(nums) else False\r\n\r\n        left = 0\r\n        right = nums[-1] - nums[0]\r\n        while left <= right:\r\n            mid = (left + right) >> 1\r\n            if can_light_up(mid):\r\n                right = mid - 1\r\n            else:\r\n                left = mid + 1\r\n        return left >> 1\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/53#issuecomment-1492977190","body":" public int maxScore(int[] cardPoints, int k) {\r\n        int w = cardPoints.length - k;\r\n        \r\n        int sumW = 0;\r\n        for (int i = 0; i < w; i++) \r\n            sumW += cardPoints[i];\r\n        \r\n        int ans = sumW;\r\n        int sum = sumW; public int maxScore(int[] cardPoints, int k) {\r\n        int w = cardPoints.length - k;\r\n        \r\n        int sumW = 0;\r\n        for (int i = 0; i < w; i++) \r\n            sumW += cardPoints[i];\r\n        \r\n        int ans = sumW;\r\n        int sum = sumW;\r\n        for (int i = w; i < cardPoints.length; i++) {\r\n            sumW -= cardPoints[i - w];\r\n            sumW += cardPoints[i];\r\n            sum += cardPoints[i];\r\n            \r\n            ans = Math.min(ans, sumW);\r\n        }\r\n        \r\n        return sum - ans;\r\n    }\r\n        for (int i = w; i < cardPoints.length; i++) {\r\n            sumW -= cardPoints[i - w];\r\n            sumW += cardPoints[i];\r\n            sum += cardPoints[i];\r\n            \r\n            ans = Math.min(ans, sumW);\r\n        }\r\n        \r\n        return sum - ans;\r\n    }","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495906059","body":"class Solution:\r\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\r\n        self.res = 0\r\n        directions = [[1,0],[-1,0],[0,1],[0,-1]]\r\n\r\n        def inBound(row, col):\r\n            return row >= 0 and col >= 0 and row <len(grid) and col < len(grid[0])\r\n        \r\n        def bfs(row, col, seen):\r\n            island = 0\r\n            qualified = [(row, col)]\r\n            while qualified:\r\n                island += 1\r\n                row, col = qualified.pop(0)\r\n                for dx, dy in directions:\r\n                    newR, newC = row+dx, col+dy\r\n                    if inBound(newR, newC) and grid[newR][newC] == 1 and (newR, newC) not in seen:\r\n                        seen.add((newR, newC))\r\n                        qualified.append((newR, newC))\r\n                        grid[newR][newC] = 2\r\n            return island\r\n        for row in range(len(grid)):\r\n            for col in range(len(grid[0])):\r\n                if grid[row][col] == 1:\r\n                    self.res = max(self.res, bfs(row, col, set([(row, col)])))\r\n        return self.res","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501955916","body":"class Solution {\r\npublic:\r\n    int findNumberOfLIS(vector<int>& nums) {\r\n        // 以nums[i]为结尾的子序列的长度\r\n        vector<int> dp(nums.size(), 1);\r\n        vector<int> ans(nums.size(), 1);\r\n        int max_num = 1;\r\n        for(int i = 0; i < nums.size(); ++i) {\r\n            for(int j = 0; j < i; ++j) {\r\n                if(nums[i] > nums[j]) {\r\n                    if(dp[i] == dp[j] + 1) {\r\n                        ans[i] += ans[j];\r\n                    } else if(dp[i] < dp[j] + 1){\r\n                        dp[i] = dp[j] + 1;\r\n                        ans[i] = ans[j];\r\n                    }\r\n                }\r\n            }\r\n            \r\n            max_num = max(max_num, dp[i]);\r\n        }\r\n\r\n        int count = 0;\r\n        for(int i = 0; i < nums.size(); ++i) {\r\n            if(max_num == dp[i]) {\r\n                count += ans[i];\r\n            }\r\n        }\r\n        return count;\r\n\r\n    }\r\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1508946305","body":"class Solution:\r\n    def canIWin(self, maxi: int, target: int) -> bool:\r\n        if target <= 0 or maxi >= target: return True\r\n        if (1+maxi)*maxi//2 < target: return False\r\n        \r\n        memo = {}\r\n        choices = [i for i in range(1, maxi+1)]\r\n\r\n        def dp(left, subTarget):\r\n            if left[-1] >= subTarget:\r\n                return True\r\n            if tuple(left) in memo:\r\n                return memo[tuple(left)]\r\n            for i in range(len(left)):\r\n                newLeft = left[:i] + left[i+1:]\r\n                if not dp(newLeft, subTarget-left[i]):\r\n                    memo[tuple(left)] = True\r\n                    return True\r\n            memo[tuple(left)] = False\r\n            return False\r\n        return dp(choices, target)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1508953697","body":"class Solution {\r\npublic:\r\n  bool canPartition(vector<int>& nums) {\r\n    int sum = 0;\r\n    for(int e : nums) sum += e;\r\n    if(sum & 1) return false;\r\n    vector<bool> d((sum>>=1)+1, false);//sum/=2\r\n    for(int i = 0 ; i < nums.size() ; i++){\r\n      for(int s = sum ; s >= 0 ; s--/*int s = 0 ; s <= sum ; s++*/){//从后往前，因为前面的元素我们已经求过了(i>0时确实已经求过了，i==0时我们求一遍即可，下面的代码也确实给出了i==0的情况)，可以直接用\r\n        if(!i) d/*[i]*/[s] = (nums[i]==s);//i==0要单独求{ nums[0]一个元素和为s }\r\n        else d/*[i]*/[s] = d/*[i-1]*/[s] || (s-nums[i]>=0 ? d/*[i-1]*/[s-nums[i]] : false);\r\n      }\r\n    }\r\n    return d/*[nums.size()-1]*/[sum];//[0,nums.size()-1]区间和为sum\r\n  }\r\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516526155","body":"class Solution {\r\n    // 首先通过排序，将附近的区间放在一起，设置第0的区间的右边界，\r\n    // 然后根据接下来区间的左边界判断是否在前一序列的右边界里，没重叠：新的end为区间的右边界，重叠，count++,新的end为最小值（为了满足去除的重复区间尽可能小）\r\n    //TC: O(nlogn) ->排序需要的时间 SC: O(1)\r\n    public int eraseOverlapIntervals(int[][] intervals) {\r\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\r\n        int end = intervals[0][1];\r\n        int count = 0;\r\n        for (int i = 1; i < intervals.length; i++) {\r\n            if (intervals[i][0] >= end)\r\n                end = intervals[i][1];\r\n            else {\r\n                count++;\r\n                end = Math.min(end, intervals[i][1]);\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1523501654","body":"class Solution {\r\n    //TC: O(n*2^n) SC: O(n)\r\n    List<List<Integer>> res = new ArrayList<>();\r\n    List<Integer> path = new ArrayList<>();\r\n    int[] nums;\r\n\r\n    public List<List<Integer>> subsets(int[] nums) {\r\n        this.nums = nums;\r\n        backtracking(0);\r\n        return res;\r\n    }\r\n\r\n    private void backtracking(int startIndex) {\r\n        res.add(new ArrayList<>(path));\r\n        for (int i = startIndex; i < nums.length; i++) {\r\n            path.add(nums[i]);\r\n            backtracking(i + 1);\r\n            path.remove(path.size() - 1);\r\n        }\r\n    }\r\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528732279","body":"var multiSearch = function (big, smalls) {\r\n    const res = Array.from(smalls, () => []);\r\n    const trie = {};\r\n    smalls.forEach((str, index) => {\r\n        let node = trie;\r\n        for (let char of str) {\r\n            if (!node[char]) node[char] = {};\r\n            node = node[char];\r\n        }\r\n        node.isWord = true;\r\n        node.index = index;\r\n    });\r\n    for (let i in big) {\r\n        let node = trie;\r\n        for (let inx = i; inx < big.length; inx++) {\r\n            let char = big[inx];\r\n            if (!node[char]) break;\r\n            node = node[char];\r\n            const {isWord, index} = node;\r\n            if (!!isWord) {\r\n                res[index].push(i);\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1536356213","body":"class Solution:\r\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\r\n        candidates.sort()\r\n        vec = []\r\n        n = len(candidates)\r\n        used = [False] * n\r\n        ans = []\r\n        def dfs(vec, start, num, used):\r\n            if num == 0:\r\n                ans.append(vec[:])\r\n                return\r\n            if start >= n or num < 0:\r\n                return\r\n            for i in range(start, n):\r\n                if i >= 1 and candidates[i] == candidates[i-1] and used[i-1] == False:\r\n                    continue\r\n                if used[i] == False:\r\n                    used[i] = True\r\n                    vec.append(candidates[i])\r\n                    dfs(vec, i+1, num-candidates[i], used)\r\n                    used[i] = False\r\n                    vec.pop()\r\n        dfs(vec, 0, target, used)\r\n        return ans","onTime":true},null,null,null,null,null,null,null,null,null,null],"aswrise":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435639529","body":"class MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stack1.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack2)==0:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack2)==0:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        if len(self.stack1)==0 and len(self.stack2)==0:\n            return True\n        else:\n            return False","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1443879327","body":"```\r\nclass Solution:\r\n    def detectCycle(self, head):\r\n        if head == [] or not head:\r\n            return None\r\n        elif not head.next:\r\n            return None\r\n        fast = head.next.next\r\n        slow = head.next\r\n        while fast != slow:\r\n            if not fast or not fast.next:\r\n                return None\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        fast = head\r\n        while fast != slow:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        return fast\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449854186","body":"```\nclass Solution(object):\n    def findBottomLeftValue(self, root):\n        def recursion(nodes):\n            if nodes == [] or nodes == [None]:\n                return nodes\n            else:\n                next_level_nodes = []\n                for node in nodes:\n                    next_level_nodes.append(node.left) if node.left is not None else None\n                    next_level_nodes.append(node.right) if node.right is not None else None\n\n                if next_level_nodes == []:\n                    return nodes[0].val\n                else:\n                    return recursion(next_level_nodes)\n\n        return recursion([root])\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455050503","body":"```\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        d = collections.Counter(nums)\n        res = sorted(d.items(), key=lambda s:s[1], reverse=True)\n        ans = []\n        for (x, n) in res:\n            if k > 0:\n                ans.append(x)\n                k -= 1\n            else:\n                break\n        return ans\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459959398","body":"```\nclass Solution:\n    def findSubstring(self, s, words):\n        if not s or not words:\n            return []\n        words_num = len(words)\n        words_length = len(words[0])\n        str_length = len(s)\n        if words_num * words_length > str_length:\n            return []\n        words_read = {}\n        res = []\n        for i in range(str_length + 1 - words_length * words_num):\n            for key in words:\n                words_read[key] = 0\n            for key in words:\n                words_read[key] += 1\n            flag = True\n            for j in range(i, i + words_length * words_num, words_length):\n                if words_read.get(s[j:j + words_length]) == None or words_read[s[j:j + words_length]] == 0:\n                    flag = False\n                    break\n                else:\n                    words_read[s[j:j + words_length]] -= 1\n            if flag:\n                res.append(i)\n        return res\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467468023","body":"```\nclass Solution:\n    def findJudge(self, n, trust):\n        rec = [[0, 0] for _ in range(n+1)]\n        for s, e in trust:\n            rec[e][0] += 1\n            rec[s][1] += 1\n        ans = -1\n        for i in range(1, n+1):\n            if rec[i][0] == n-1 and rec[i][1] == 0:\n                if ans == -1:\n                    ans = i\n                else:\n                    return -1\n        return ans\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477200133","body":"```\nclass Solution:\n    def sortArray(self, nums):\n        def merge(nums, p, mid, r):\n            temp = []\n            left, right = p, mid + 1\n            \n            while left <= mid and right <= r:\n                if nums[left] <= nums[right]: \n                    temp += [nums[left]]\n                    left += 1\n                else:\n                    temp += [nums[right]]\n                    right += 1\n            if left <= mid:temp += nums[left:mid+1]\n            elif right <= r: temp += nums[right:r+1]\n            nums[p:r+1] = temp\n\n        def sort(nums, p, r):\n            if p >= r: return \n            mid = (p + r)//2\n            sort(nums, p, mid)\n            sort(nums, mid + 1, r)\n            merge(nums, p, mid, r)\n        \n        n = len(nums)\n        sort(nums, 0, n-1)\n        return nums\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484486462","body":"```\ndef nbs(ab, N):\n    [a,b]=ab\n    res=[]\n    if a>0:\n        res=res+[[a-1,b]]\n    if a<=N-2:\n        res=res+[[a+1,b]]\n    if b>0:\n        res=res+[[a,b-1]]\n    if b<=N-2:\n        res=res+[[a,b+1]]\n    return res\n\ndef search(grid, waterlevel):\n    N=len(grid)\n\n    #start at:\n\n    if grid[0][0]<=waterlevel and grid[N-1][N-1]<=waterlevel:\n        base=[[0,0]]  #the list of reachable places.\n    else:\n        return False \n\n    for elem in base:\n        for [a,b] in nbs(elem, N):\n            if grid[a][b]<=waterlevel:\n                if  not [a,b] in base:\n                    if a==N-1 and b==N-1:\n                        return True\n                    else:\n                        base.append([a,b])\n    #print('false: lev=',waterlevel, base)\n    return False    \n                \ndef swim(grid):\n#def swimInWater(self, grid: List[List[int]]) -> int:\n    N=len(grid)\n    if N==1:\n        return grid[0][0]\n\n    if grid[0][0]<= grid[N-1][N-1]:\n        s= grid[0][0]-1\n    else:\n        s=grid[N-1][N-1] -1\n    t=max([max(l) for l in grid])\n    \n\n    #bin search??\n    while t-s>=2:\n        mid = int((s+t)/2)\n        res = search(grid, mid)\n        print(mid,res)\n        if res==True:\n            t=mid\n        else:\n            s=mid\n    return t\n        \nclass Solution:\n    \n                \n\n    def swimInWater(self, grid):\n        return swim(grid)\n\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1493407469","body":"```\nclass Solution:\n    result = 0\n    def track(self, n, cur_row, col, row, obliqueL, obliqueR):\n        for cur_col in range(n):\n            index_obliqueL = n - cur_row + cur_col - 1\n            index_obliqueR = cur_col + cur_row\n            if 1 not in (col[cur_col] | row[cur_row] | \\\n            obliqueL[index_obliqueL] | obliqueR[index_obliqueR]):\n                if cur_row == n - 1:\n                    self.result += 1\n                    return\n                col[cur_col].add(1)\n                row[cur_row].add(1)\n                obliqueL[index_obliqueL].add(1)\n                obliqueR[index_obliqueR].add(1)\n                self.track(n, cur_row + 1, col, row, obliqueL, obliqueR)\n                col[cur_col].remove(1)\n                row[cur_row].remove(1)\n                obliqueL[index_obliqueL].remove(1)\n                obliqueR[index_obliqueR].remove(1)\n\n    def totalNQueens(self, n):\n        if n <= 0:\n            return []\n        col = []\n        row = []\n        obliqueL = []\n        obliqueR = []\n        for k in range(n):\n            col.append(set())\n            row.append(set())\n        for r in range((n - 1) * 2 + 1):\n            obliqueL.append(set())\n            obliqueR.append(set())\n\n        self.track(n, 0, col, row, obliqueL, obliqueR)\n        return self.result\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501380285","body":"```\nclass Solution(object):\n    def findNumberOfLIS(self, nums):\n        N = len(nums)\n        if N <= 1: return N\n        lengths = [0] * N #lengths[i] = longest ending in nums[i]\n        counts = [1] * N #count[i] = number of longest ending in nums[i]\n\n        for j, num in enumerate(nums):\n            for i in xrange(j):\n                if nums[i] < nums[j]:\n                    if lengths[i] >= lengths[j]:\n                        lengths[j] = 1 + lengths[i]\n                        counts[j] = counts[i]\n                    elif lengths[i] + 1 == lengths[j]:\n                        counts[j] += counts[i]\n\n        longest = max(lengths)\n        return sum(c for i, c in enumerate(counts) if lengths[i] == longest)\n\n\n```\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511206642","body":"```\nclass Solution:\n    def coinChange(self, coins, amount):\n        dp=[amount+1 for _ in range(amount+1)]\n        dp[0]=0\n        for i in range(1,amount+1):\n            for j in range(len(coins)):\n                if i>=coins[j]:\n                     dp[i]=min(dp[i],dp[i-coins[j]]+1)\n        return -1 if dp[amount]>amount else dp[amount]\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1518773163","body":"```\nclass Solution:\n    def mergeKLists(self, lists):\n        import heapq\n        dummy = ListNode(0)\n        p = dummy\n        heads = []\n        for idx, node in enumerate(lists):\n            if node:\n                heapq.heappush(heads, (node.val, idx))\n                lists[idx] = lists[idx].next\n        \n        while heads:\n            val, idx = heapq.heappop(heads)\n            node = ListNode(val)\n            p.next = node\n            p = p.next\n            if lists[idx]:\n                node = lists[idx]\n                heapq.heappush(heads, (node.val, idx))\n                lists[idx] = lists[idx].next\n\n        return dummy.next\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1529032031","body":"```\nclass Solution:\n    def findCircleNum(self, M):\n        class Union:\n            def __init__(self, n):\n                self.cnt = n\n                self.parent = [i for i in range(n)]\n                \n            def find(self, p):\n                while p != self.parent[p]:\n                    self.parent[p] = self.parent[self.parent[p]]\n                    p = self.parent[p]\n                return p\n            \n            def union(self, a, b):\n                a_root = self.find(a)\n                b_root = self.find(b)\n                if a_root == b_root: return\n                if a_root < b_root:\n                    self.parent[b_root] = a_root\n                else:\n                    self.parent[a_root] = b_root\n                self.cnt -= 1    \n\n            def get_count(self):\n                return self.cnt\n            \n        ut = Union(len(M))\n        for i in range(len(M)):\n            for j in range(len(M[0])):\n                if M[i][j] == 1:\n                    ut.union(i, j)\n    \n        return ut.get_count()\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aneureka":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435678098","body":"```cpp\r\n#include <stack>\r\n\r\nclass MyQueue {\r\npublic:\r\n    MyQueue() {\r\n    }\r\n    \r\n    void push(int x) {\r\n        in.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if (out.empty()) {\r\n            while (!in.empty()) {\r\n                out.push(in.top());\r\n                in.pop();\r\n            }\r\n        }\r\n        int peek = out.top();\r\n        out.pop();\r\n        return peek;\r\n    }\r\n    \r\n    int peek() {\r\n        if (out.empty()) {\r\n            while (!in.empty()) {\r\n                out.push(in.top());\r\n                in.pop();\r\n            }\r\n        }\r\n        return out.top();\r\n    }\r\n    \r\n    bool empty() {\r\n        return in.empty() && out.empty();\r\n    }\r\nprivate:\r\n    stack<int> in;\r\n    stack<int> out;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445138283","body":"Below is my C++ solution using `std::unordered_map` and `std::list`.\r\nHope it helps ;-)\r\n\r\n```cpp\r\n#include <unordered_map>\r\n#include <list>\r\n\r\nclass LRUCache {\r\npublic:\r\n    LRUCache(int capacity) : capacity(capacity) {}\r\n    \r\n    int get(int key) {\r\n        auto node = m.find(key);\r\n        if (node == m.end()) return -1;\r\n        \r\n        // put the retrieved node to last\r\n        auto itr = node->second;\r\n        int value = itr->second;\r\n        nodes.erase(itr);\r\n        nodes.push_back({key, value});\r\n        m[key] = prev(nodes.end());\r\n        \r\n        return value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        // if key is existed, remove it from map\r\n        if (auto node = m.find(key); node != m.end()) {\r\n            nodes.erase(node->second);\r\n        }\r\n\r\n        // if capacity is reached, remove the first-to-kill node\r\n        if (nodes.size() >= capacity) {\r\n            int key_to_remove = nodes.front().first;\r\n            m.erase(m.find(key_to_remove));\r\n            nodes.pop_front();\r\n        }\r\n\r\n        // add new node\r\n        nodes.push_back({key, value});\r\n        m[key] = prev(nodes.end());\r\n    }\r\nprivate:\r\n    using PII = pair<int, int>;\r\n    unordered_map<int, list<PII>::iterator> m; // store key -> ref to node\r\n    list<PII> nodes; // store node{key, value}\r\n    int capacity;\r\n};\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448270922","body":"```cpp\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        return dfs(root, 0);\n    }\n\n    int dfs(TreeNode* cur, int num) {\n        int next_num = num * 10 + cur->val;\n        if (!cur->left && !cur->right) {\n            return next_num;\n        }\n\n        int res = 0;\n        if (cur->left) res += dfs(cur->left, next_num);\n        if (cur->right) res += dfs(cur->right, next_num);\n        return res;\n    }\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1456398224","body":"```cpp\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int res = 0;\n        for (auto i = 0; i < points.size(); i++) {\n            unordered_map<long, int> dist_count_map;\n            for (auto j = 0; j < points.size(); j++) {\n                if (i == j) continue;\n                dist_count_map[getDist(points[i], points[j])] += 1;\n            }\n            for (auto [dist, count] : dist_count_map) {\n                res += count * (count - 1);\n            }\n        }\n        return res;\n    }\n\n    long getDist(const vector<int>& p1, const vector<int>& p2) {\n        long dx = p1[0] - p2[0];\n        long dy = p1[1] - p2[1];\n        return dx * dx + dy * dy;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ljqchlsw":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435900397","body":"# 思路\nFor two adjacent chunks, the max value of left chunk must be less or equal to the min value of right chunk, if the the min value of right chunk was less than the max value of left chunk, we should merge those two chunks into one, greedy technique to merge chunks to get max chunks! To achieve this, we have to record the max value of the previous chunks and compare them with the current chunk(aka. a single number) so that we can either merge them or append a new chunk, in this case stack is the best data structure to be applied here. We save max values of all chunks with a stack, the final result is the size of this stack!\n\n# 代码\n~~~\npublic int maxChunksToSorted(int[] arr) {\n    Deque<Integer> stack = new ArrayDeque<>();\n    for (int num : arr) {\n        int curMax = num;\n        while (!stack.isEmpty() && stack.peek() > num) {\n            curMax = Math.max(stack.pop(), curMax);\n        }\n        stack.push(curMax);\n    }\n    return stack.size();\n}\n~~~\n# 复杂度\nTime complexity: O(n), space complexity: O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441359476","body":"# 思路\nlen(A) = a + c, len(B) = b + c, 两指针分别从A， B开始遍历A和B， B和A， a + c + b = b + c + a, 会在交点相遇，若c==0, 即无交点时，两指针同时到达null\n# 复杂度\ntime: O(m + n), space O(1)\n# 代码\n~~~\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA;\n        ListNode b = headB;\n\n        while (a != b) {\n            if (a != null) {\n                a = a.next;\n            } else {\n                a = headB;\n            }\n            if (b != null) {\n                b = b.next;\n            } else {\n                b = headA;\n            }\n        }\n\n        return a;\n    }\n~~~","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1450567307","body":"# 思路\ndfs/preorder traversal， 每当当前最大层数改变时更新结果\n\n# 代码\n~~~\nclass Solution {\n    int res = 0;\n    int maxLayer = -1;\n    public int findBottomLeftValue(TreeNode root) {\n        dfs(root, 0);\n        return res;\n    }\n\n    private void dfs(TreeNode root, int curLayer) {\n        if (root == null) {\n            return;\n        }\n        if (curLayer > maxLayer) {\n            maxLayer = curLayer;\n            res = root.val;\n        } \n        dfs(root.left, curLayer + 1);\n        dfs(root.right, curLayer + 1);\n\n    }\n}\n~~~\n\n# 复杂度\nO(n), n为节点数","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jingyuzhou123":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437029993","body":"```javascript\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    let res = cur.next;\n    cur.next = null;\n    return res;\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446266031","body":"```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function (p, q) {\n  if (!p || !q) {\n    return !p && !q;\n  }\n  return (\n    p.val === q.val &&\n    isSameTree(p.left, q.left) &&\n    isSameTree(p.right, q.right)\n  );\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455831659","body":"```\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n    let ans = 0;\n    for (const p of points) {\n        const cnt = new Map();\n        for (const q of points) {\n            const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n            cnt.set(dis, (cnt.get(dis) || 0) + 1);\n        }\n        for (const [_, m] of cnt.entries()) {\n            ans += m * (m - 1);\n        }\n    }\n    return ans;\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466237229","body":"```\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function(nums, k) {\n  let res = [];\n  let maxQ = [];\n  for (let i = 0; i < k; i++) {\n    const num = nums[i];\n    while (maxQ.length && nums[maxQ[maxQ.length - 1]] <= num) {\n      maxQ.pop();\n    }\n    maxQ.push(i);\n  }\n  res.push(nums[maxQ[0]]);\n  for (let i = k; i < nums.length; i++) {\n    const num = nums[i];\n    if (maxQ.length && i - k + 1 > maxQ[0]) {\n      maxQ.shift();\n    }\n    while (maxQ.length && nums[maxQ[maxQ.length - 1]] <= num) {\n      maxQ.pop();\n    }\n    maxQ.push(i);\n    res.push(nums[maxQ[0]]);\n  }\n  return res;\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1476221923","body":"```\n/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\nconst minCharacters = function (a, b) {\n    const offset = \"a\".charCodeAt(0);\n    const lenA = a.length, lenB = b.length;\n    const countA = new Array(26).fill(0), countB = new Array(26).fill(0);\n    for (let c of a) countA[c.charCodeAt(0) - offset]++;\n    for (let c of b) countB[c.charCodeAt(0) - offset]++;\n    let result = Infinity;\n    for (let i = 0; i < 26; i++) {\n        result = Math.min(result, (lenA - (countA[i] || 0)) + (lenB - (countB[i] || 0)));\n\n        if (i === 0) continue;\n        let r1 = 0, r2 = 0;\n        for (let j = 0; j < i; j++) r1 += countA[j] || 0;\n        for (let j = i; j < 26; j++) r1 += countB[j] || 0;\n\n        for (let j = 0; j < i; j++) r2 += countB[j] || 0;\n        for (let j = i; j < 26; j++) r2 += countA[j] || 0;\n        result = Math.min(result, r1, r2);\n    }\n    return result;\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1485069587","body":"```javascript\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar swimInWater = function (grid) {\n    const n = grid.length;\n    let start = 0;\n    let end = n * n - 1;\n\n    let min = 0;\n    while (start <= end) {\n        const mid = Math.floor((start + end) / 2);\n        const res = checkAvalibalePath(grid, mid);\n        if (res) {\n            end = mid - 1;\n            min = mid;\n        } else {\n            start = mid + 1;\n        }\n    }\n    return min;\n};\n\nconst checkAvalibalePath = (grid, t) => {\n    const n = grid.length;\n    const directions = [\n        [0, 1],\n        [0, -1],\n        [1, 0],\n        [-1, 0],\n    ];\n    const visited = new Array(n).fill(false).map(() => new Array(n).fill(false));\n\n    const dfs = (i, j) => {\n        if (visited[i][j] || grid[i][j] > t) {\n            return;\n        }\n\n        visited[i][j] = true;\n        for (const dir of directions) {\n            const dx = i + dir[0];\n            const dy = j + dir[1];\n            if (dx < 0 || dx >= n || dy < 0 || dy >= n) {\n                continue;\n            }\n\n            dfs(dx, dy);\n        }\n    };\n    dfs(0, 0);\n    return visited[n - 1][n - 1];\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494391871","body":"```javascript\n/**\n * @param {number} n\n * @return {number}\n * @param row 当前层\n * @param col 列\n * @param pie 左斜线\n * @param na 右斜线\n */\nconst totalNQueens = function (n) {\n  let res = 0;\n  const dfs = (n, row, col, pie, na) => {\n    if (row >= n) {\n      res++;\n      return;\n    }\n    // 将所有能放置 Q 的位置由 0 变成 1，以便进行后续的位遍历\n    // 也就是得到当前所有的空位\n    let bits = ~(col | pie | na) & ((1 << n) - 1);\n    while (bits) {\n      // 取最低位的1\n      let p = bits & -bits;\n      // 把P位置上放入皇后\n      bits = bits & (bits - 1);\n      // row + 1 搜索下一行可能的位置\n      // col ｜ p 目前所有放置皇后的列\n      // (pie | p) << 1 和 (na | p) >> 1) 与已放置过皇后的位置 位于一条斜线上的位置\n      dfs(n, row + 1, col | p, (pie | p) << 1, (na | p) >> 1);\n    }\n  };\n  dfs(n, 0, 0, 0, 0);\n  return res;\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501746093","body":"```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumberOfLIS = function(nums) {\n    let n = nums.length, maxLen = 0, ans = 0;\n    const dp = new Array(n).fill(0);\n    const cnt = new Array(n).fill(0);\n    for (let i = 0; i < n; ++i) {\n        dp[i] = 1;\n        cnt[i] = 1;\n        for (let j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                if (dp[j] + 1 > dp[i]) {\n                    dp[i] = dp[j] + 1;\n                    cnt[i] = cnt[j]; // 重置计数\n                } else if (dp[j] + 1 === dp[i]) {\n                    cnt[i] += cnt[j];\n                }\n            }\n        }\n        if (dp[i] > maxLen) {\n            maxLen = dp[i];\n            ans = cnt[i]; // 重置计数\n        } else if (dp[i] === maxLen) {\n            ans += cnt[i];\n        }\n    }\n    return ans;\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1511105417","body":"```JavaScript\n/**\n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\nconst coinChange = (coins, amount) => {\n    if(!amount) {\n        return 0;\n    }\n\n    let dp = Array(amount + 1).fill(Infinity);\n    dp[0] = 0;\n\n    for(let i =0; i < coins.length; i++) {\n        for(let j = coins[i]; j <= amount; j++) {\n            dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j]);\n        }\n    }\n\n    return dp[amount] === Infinity ? -1 : dp[amount];\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1519053262","body":"```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nfunction meger(list1, list2) {\n    if(list1 === null) {\n        return list2\n    } else if(list2 === null) {\n        return list1\n    }\n    const pre = new ListNode(0)\n    let current = pre\n    while(list1 !== null && list2 !== null) {\n        if(list1.val < list2.val) {\n            current.next = list1\n            list1 = list1.next\n        } else {\n            current.next = list2\n            list2 = list2.next\n        }\n        current = current.next\n    }\n    if(list1 === null) {\n        current.next = list2\n    } else {\n        current.next = list1\n    }\n    return pre.next\n}\n\nfunction mergeList(lists, left, right) {\n    if(left === right) {\n        return lists[left]\n    }\n    if(left > right) {\n        return null\n    }\n    const mid = Math.floor((left + right) / 2)\n    return meger(mergeList(lists, left, mid), mergeList(lists, mid + 1, right))\n}\n\nvar mergeKLists = function(lists) {\n    const n = lists.length\n    if(n === 0) {\n        return null\n    }\n    return mergeList(lists, 0, n - 1)\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dianlandu":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437064730","body":"**思路**\r\n倒数第 k 个 = 正数第 length - k % length 个\r\n\r\n**代码**\r\n```\r\n//链表长度计算\r\nint getLen(struct ListNode* head){\r\n    struct ListNode* p = head;\r\n    int len = 1;\r\n    while(p->next){\r\n        p = p->next;\r\n        ++len;\r\n    }\r\n    return len;\r\n}\r\n\r\nstruct ListNode* rotateRight(struct ListNode* head, int k){\r\n    if(!head || !head->next){\r\n        return head;\r\n    }\r\n\r\n    int len = getLen(head);\r\n    int gap = len - k % len;  //gap为倒数第几个，从gap处断开，方便后续拼接\r\n    struct ListNode *dummy = malloc(sizeof(struct ListNode)), *p = head, *q = p;\r\n    dummy->next = head;\r\n\r\n    for(int i = 1; i < gap; i++){\r\n        p = p->next;\t//找到倒数第k个的前一个结点，以便于修改操作\r\n    }\r\n    while(q->next){\r\n        q = q->next;    // 走到表尾\r\n    }\r\n    q->next = dummy->next;\t//表尾接到原表头\r\n    dummy->next = p->next;\t//原表头变为倒数第k个结点\r\n    p->next = NULL;\t\t\t//最后元素指空\r\n\r\n    return dummy->next;\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jameswangxin":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437071099","body":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (!head) return nullptr;\n        int len = 0;\n        auto dummy = new ListNode(-1);\n        dummy->next = head;\n        auto p = head;\n        while (p) {\n            len++;\n            p = p->next;\n        }\n        k %= len;\n        if (k == 0) return head;\n        p = head; auto q = head; //p是慢指针，q是快指针\n        while (k--) q = q->next;\n        while (q->next) {\n            p = p->next;\n            q = q->next;\n        }\n        auto temp = dummy->next;\n        dummy->next = p->next;\n        q->next = temp;\n        p->next = nullptr;\n        return dummy->next;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhenxied":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437092380","body":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) {\n            return null;\n        }\n        // ListNode pre = new ListNode(-1, head);\n        ListNode slow = head;\n        ListNode fast = head;\n        for (int i = 0; i < k; i++) {\n            if (fast.next == null) {\n                fast = head;\n            } else {\n                fast = fast.next;\n            }\n        }\n        if (slow == fast) {\n            return head;\n        }\n        while (fast.next != null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        ListNode res = slow.next;\n        slow.next = null;\n        fast.next = head;\n\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445388272","body":"class Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n\n        return Math.max(left, right) + 1;\n    }\n}","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1455049777","body":"class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        HashMap<Integer, Integer> count = new HashMap<Integer, Integer>();\n\n        for (int i : nums) {\n            count.put(i, count.getOrDefault(i, 0) + 1);\n        }\n\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(new Comparator<Integer>() {\n            public int compare(Integer a, Integer b) {\n                return count.get(a) - count.get(b);\n            }\n        });\n\n        for (Integer key : count.keySet()) {\n            if (pq.size() < k) {\n                pq.add(key);\n            } else if (count.get(key) > count.get(pq.peek())) {\n                pq.remove();\n                pq.add(key);\n            }\n        }\n        int[] res = new int[k];\n        for (int i=0; i<k; i++) {\n            res[i] = pq.poll();\n        }\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuozhouzhang":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437172999","body":"\nclass Solution:\n    def rotateRight(self, head, k):\n      \n        dummy = ListNode(0)\n        dummy.next = head\n        if head is None:\n            return None\n        \n        #先数链表有几个节点\n        i = head\n        count = 1\n        while i.next is not None:\n            i = i.next\n            count += 1\n        #抛掉重复的转圈,也算一种算法优化吧\n        k = k%count\n        if (k == 0) or count == 1:\n            return head\n        #把链表头尾连起来\n        i.next = head\n \n        #从dummy开始运动\n        i = dummy\n        #运动到新的链表的头的上一个节点\n        for _ in range(count - k):\n            i = i.next\n \n        j = i.next\n        i.next = None\n        return j","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shin-guid":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437227881","body":"## 代码\n\n```js\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    let res = cur.next;\n    cur.next = null;\n    return res;\n}\n```\n\n## 复杂度\n- 时间复杂度O（n），节点最多只遍历两遍。\n- 空间复杂度O(1)，未使用额外的空间。\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bochengwan":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441452347","body":"### 思路\r\n\r\n两个链表若有空链表，则不可能相交。假设A的相交前的长度为a，B的相交前长度为b，公共长度为c。a+c+b  = b+c+a。\r\n\r\n### 代码\r\n```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if(headA == null || headB == null ) return null;\r\n        ListNode pA = headA;\r\n        ListNode pB = headB;\r\n        while(pA!=pB) {\r\n            pA = pA == null? headB:pA.next;\r\n            pB = pB == null? headA:pB.next;\r\n        }\r\n        return pA;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(m+n)，其中 m,n 为链表A和链表B的长度。\r\n- 空间复杂度：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445283088","body":"### 思路\r\n\r\nDFS\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        return root == null? 0: Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中N为树中点的数量。\r\n- 空间复杂度：O(H)， H为树的高度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1445881414","body":"### 思路\r\nDFS或bfs，随时deep的迭代，比较是否为相同的结构。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null && q == null) return true;\r\n        if(p == null || q == null) return false;\r\n        if(p.val != q.val) return false;\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(min(m,n）)，其中 m和n为两棵树的节点数\r\n- 空间复杂度：O(min(m,n）)，其中 m和n为两棵树的节点数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1448045808","body":"### 思路\r\n\r\nDFS, 递归过程中传递之前的sum\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        return dfs(root, 0);\r\n\r\n    }\r\n\r\n    public int dfs(TreeNode currNode, int prevSum) {\r\n        if (currNode == null) return 0;\r\n        prevSum = prevSum*10 + currNode.val;\r\n        if (currNode.left == null && currNode.right == null) return prevSum;\r\n        \r\n        return dfs(currNode.left, prevSum) + dfs(currNode.right, prevSum);\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为树的节点个数\r\n- 空间复杂度：O(H)， h为树的高度，最差为O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449880417","body":"### 思路\r\n\r\n层序遍历\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution {\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        int answer = root.val;\r\n        Queue<TreeNode> nodeQueue = new LinkedList<TreeNode>();\r\n        nodeQueue.offer(root);\r\n        while(!nodeQueue.isEmpty()) {\r\n            answer = nodeQueue.peek().val;\r\n            int length = nodeQueue.size();\r\n            for(int i = 0; i < length; i++) {\r\n                TreeNode currNode = nodeQueue.poll();\r\n                if(currNode.left != null) nodeQueue.offer(currNode.left);\r\n                if(currNode.right != null) nodeQueue.offer(currNode.right);\r\n            }\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为节点个数。\r\n- 空间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454727735","body":"### 思路\r\n\r\n通过hashmap存储当前值和当前值的index，每次在hashmap找有没有和能为target的数，如果有，则直接输出index的array。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        Map<Integer, Integer> myHashMap = new HashMap<Integer, Integer>();\r\n        for(int i = 0; i < nums.length; i++) {\r\n            int aim = target - nums[i];\r\n            if(myHashMap.containsKey(aim)) {\r\n                return new int[]{myHashMap.get(aim), i};\r\n            }\r\n            myHashMap.put(nums[i], i);\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457844167","body":"### 思路\r\n\r\n滑动窗口，每次有重复的值则更新左端的值\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        if (s.length() == 0) return 0;\r\n        Map<Character, Integer> map = new HashMap<Character, Integer>();\r\n        int max = 0;\r\n        int left = 0;\r\n        for(int i = 0; i < s.length(); i ++){\r\n            if(map.containsKey(s.charAt(i))){\r\n                left = Math.max(left, map.get(s.charAt(i)) + 1);\r\n            }\r\n            map.put(s.charAt(i),i);\r\n            max = Math.max(max,i-left+1);\r\n        }\r\n        return max;\r\n        \r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/31#issuecomment-1463397607","body":"### 思路\r\n快慢指针\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        while (fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为节点个数。\r\n- 空间复杂度：O(1)\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467659865","body":"### 思路\r\n\r\n法官的入度为n-1，出度为0\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\n\r\nclass Solution {\r\n    public int findJudge(int n, int[][] trust) {\r\n        int[] inDegrees = new int[n + 1];\r\n        int[] outDegrees = new int[n + 1];\r\n        for (int[] edge : trust) {\r\n            int x = edge[0], y = edge[1];\r\n            ++inDegrees[y];\r\n            ++outDegrees[x];\r\n        }\r\n        for (int i = 1; i <= n; ++i) {\r\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N+M)，其中 N 为人数，M为trust长度\r\n- 空间复杂度：O(N)\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1471547344","body":"### 思路\r\n拓扑排序\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\n\r\n\r\npublic class Solution {\r\n\r\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\r\n        // 第 1 步：数据预处理，给没有归属于一个组的项目编上组号\r\n        for (int i = 0; i < group.length; i++) {\r\n            if (group[i] == -1) {\r\n                group[i] = m;\r\n                m++;\r\n            }\r\n        }\r\n\r\n        // 第 2 步：实例化组和项目的邻接表\r\n        List<Integer>[] groupAdj = new ArrayList[m];\r\n        List<Integer>[] itemAdj = new ArrayList[n];\r\n        for (int i = 0; i < m; i++) {\r\n            groupAdj[i] = new ArrayList<>();\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            itemAdj[i] = new ArrayList<>();\r\n        }\r\n\r\n        // 第 3 步：建图和统计入度数组\r\n        int[] groupsIndegree = new int[m];\r\n        int[] itemsIndegree = new int[n];\r\n\r\n        int len = group.length;\r\n        for (int i = 0; i < len; i++) {\r\n            int currentGroup = group[i];\r\n            for (int beforeItem : beforeItems.get(i)) {\r\n                int beforeGroup = group[beforeItem];\r\n                if (beforeGroup != currentGroup) {\r\n                    groupAdj[beforeGroup].add(currentGroup);\r\n                    groupsIndegree[currentGroup]++;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            for (Integer item : beforeItems.get(i)) {\r\n                itemAdj[item].add(i);\r\n                itemsIndegree[i]++;\r\n            }\r\n        }\r\n\r\n        // 第 4 步：得到组和项目的拓扑排序结果\r\n        List<Integer> groupsList = topologicalSort(groupAdj, groupsIndegree, m);\r\n        if (groupsList.size() == 0) {\r\n            return new int[0];\r\n        }\r\n        List<Integer> itemsList = topologicalSort(itemAdj, itemsIndegree, n);\r\n        if (itemsList.size() == 0) {\r\n            return new int[0];\r\n        }\r\n\r\n        // 第 5 步：根据项目的拓扑排序结果，项目到组的多对一关系，建立组到项目的一对多关系\r\n        // key：组，value：在同一组的项目列表\r\n        Map<Integer, List<Integer>> groups2Items = new HashMap<>();\r\n        for (Integer item : itemsList) {\r\n            groups2Items.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\r\n        }\r\n\r\n        // 第 6 步：把组的拓扑排序结果替换成为项目的拓扑排序结果\r\n        List<Integer> res = new ArrayList<>();\r\n        for (Integer groupId : groupsList) {\r\n            List<Integer> items = groups2Items.getOrDefault(groupId, new ArrayList<>());\r\n            res.addAll(items);\r\n        }\r\n        return res.stream().mapToInt(Integer::valueOf).toArray();\r\n    }\r\n\r\n    private List<Integer> topologicalSort(List<Integer>[] adj, int[] inDegree, int n) {\r\n        List<Integer> res = new ArrayList<>();\r\n        Queue<Integer> queue = new LinkedList<>();\r\n        for (int i = 0; i < n; i++) {\r\n            if (inDegree[i] == 0) {\r\n                queue.offer(i);\r\n            }\r\n        }\r\n\r\n        while (!queue.isEmpty()) {\r\n            Integer front = queue.poll();\r\n            res.add(front);\r\n            for (int successor : adj[front]) {\r\n                inDegree[successor]--;\r\n                if (inDegree[successor] == 0) {\r\n                    queue.offer(successor);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (res.size() == n) {\r\n            return res;\r\n        }\r\n        return new ArrayList<>();\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(m+n)\r\n- 空间复杂度：O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473517238","body":"### 思路\r\n\r\n模拟\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution {\r\n    public boolean judgeCircle(String moves) {\r\n        int x = 0;\r\n        int y = 0;\r\n        int length = moves.length();\r\n        for(int i = 0; i < length; i++) {\r\n            char move = moves.charAt(i);\r\n            if (move == 'U') {\r\n                y++;\r\n            } else if (move == 'D') {\r\n                y--;\r\n            } else if (move == 'R') {\r\n                x++;\r\n            } else if (move == 'L') {\r\n                x--;\r\n            }\r\n        }\r\n        return x == 0 && y == 0;\r\n\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475165104","body":"### 思路\r\n转变为mins，然后计算\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution {\r\n\r\n    int dayMinutes = 60*24;\r\n\r\n    public int numberOfRounds(String loginTime, String logoutTime) {\r\n        int time1 = getMinutes(loginTime);\r\n        int time2 = getMinutes(logoutTime);\r\n        if (time2 < time1){\r\n            time2 += dayMinutes;\r\n        }\r\n        int x = time1/15;\r\n        x += time1%15 == 0?0:1;\r\n        int y = time2/15;\r\n        return y - x >= 0? y-x : 0;\r\n    }\r\n\r\n    int getMinutes(String timeStr){\r\n        int h1 = timeStr.charAt(0) - '0';\r\n        int h2 = timeStr.charAt(1) - '0';\r\n        int m1 = timeStr.charAt(3) - '0';\r\n        int m2 = timeStr.charAt(4) - '0';\r\n\r\n        return ((h1 * 10 + h2) * 60 + m1 * 10) + m2;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O1)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475789059","body":"### 思路\r\n枚举，分别计算三种方法的值。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution {\r\n    public int minCharacters(String a, String b) {\r\n        int n = a.length(), m = b.length(), ans = 0x3f3f3f3f;\r\n        int[] c1 = new int[26], c2 = new int[26];\r\n        for (char c : a.toCharArray()) c1[c - 'a']++;\r\n        for (char c : b.toCharArray()) c2[c - 'a']++;\r\n        for (int i = 0; i < 26 && ans != 0; i++) {\r\n            // 3\r\n            int ca = n - c1[i], cb = m - c2[i];\r\n            ans = Math.min(ans, ca + cb);\r\n            if (i == 0) continue;\r\n            int r1 = 0, r2 = 0;\r\n            // 1\r\n            for (int j = i; j < 26; j++) r1 += c1[j];\r\n            for (int j = 0; j < i; j++) r1 += c2[j];\r\n            // 2\r\n            for (int j = i; j < 26; j++) r2 += c2[j];\r\n            for (int j = 0; j < i; j++) r2 += c1[j];\r\n            ans = Math.min(ans, Math.min(r1, r2));\r\n        }\r\n        return ans;\r\n    }\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N+M)\r\n- 空间复杂度：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480746374","body":"### 思路\r\n二分法\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\npublic class Solution extends VersionControl {\r\n    public int firstBadVersion(int n) {\r\n        int left = 1, right = n;\r\n        while (left < right) { \r\n            int mid = left + (right - left) / 2;\r\n            if (isBadVersion(mid)) {\r\n                right = mid; \r\n            } else {\r\n                left = mid + 1; \r\n            }\r\n        }\r\n        return left;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(LogN)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486310865","body":"### 思路\r\n滑动窗口\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution {\r\n    public int maxVowels(String s, int k) {\r\n        int n = s.length();\r\n        int vowel_count = 0;\r\n        for (int i = 0; i < k; ++i) {\r\n            vowel_count += isVowel(s.charAt(i));\r\n        }\r\n        int ans = vowel_count;\r\n        for (int i = k; i < n; ++i) {\r\n            vowel_count += isVowel(s.charAt(i)) - isVowel(s.charAt(i - k));\r\n            ans = Math.max(ans, vowel_count);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public int isVowel(char ch) {\r\n        return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ? 1 : 0;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(len(s))\r\n- 空间复杂度：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/52#issuecomment-1491392025","body":"class Solution {\r\n    public int maxVowels(String s, int k) {\r\n        int n = s.length();\r\n        int vowel_count = 0;\r\n        for (int i = 0; i < k; ++i) {\r\n            vowel_count += isVowel(s.charAt(i));\r\n        }\r\n        int ans = vowel_count;\r\n        for (int i = k; i < n; ++i) {\r\n            vowel_count += isVowel(s.charAt(i)) - isVowel(s.charAt(i - k));\r\n            ans = Math.max(ans, vowel_count);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public int isVowel(char ch) {\r\n        return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ? 1 : 0;\r\n    }\r\n}\r\n\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1493478654","body":"```\r\nclass Solution {\r\n    public int totalNQueens(int n) {\r\n        Set<Integer> columns = new HashSet<Integer>();\r\n        Set<Integer> diagonals1 = new HashSet<Integer>();\r\n        Set<Integer> diagonals2 = new HashSet<Integer>();\r\n        return backtrack(n, 0, columns, diagonals1, diagonals2);\r\n    }\r\n\r\n    public int backtrack(int n, int row, Set<Integer> columns, Set<Integer> diagonals1, Set<Integer> diagonals2) {\r\n        if (row == n) {\r\n            return 1;\r\n        } else {\r\n            int count = 0;\r\n            for (int i = 0; i < n; i++) {\r\n                if (columns.contains(i)) {\r\n                    continue;\r\n                }\r\n                int diagonal1 = row - i;\r\n                if (diagonals1.contains(diagonal1)) {\r\n                    continue;\r\n                }\r\n                int diagonal2 = row + i;\r\n                if (diagonals2.contains(diagonal2)) {\r\n                    continue;\r\n                }\r\n                columns.add(i);\r\n                diagonals1.add(diagonal1);\r\n                diagonals2.add(diagonal2);\r\n                count += backtrack(n, row + 1, columns, diagonals1, diagonals2);\r\n                columns.remove(i);\r\n                diagonals1.remove(diagonal1);\r\n                diagonals2.remove(diagonal2);\r\n            }\r\n            return count;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498537503","body":"```\r\nclass Solution:\r\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\r\n        n = len(status)\r\n        can_open = [status[i] == 1 for i in range(n)]\r\n        has_box, used = [False] * n, [False] * n\r\n        \r\n        q = collections.deque()\r\n        ans = 0\r\n        for box in initialBoxes:\r\n            has_box[box] = True\r\n            if can_open[box]:\r\n                q.append(box)\r\n                used[box] = True\r\n                ans += candies[box]\r\n        \r\n        while len(q) > 0:\r\n            big_box = q.popleft()\r\n            for key in keys[big_box]:\r\n                can_open[key] = True\r\n                if not used[key] and has_box[key]:\r\n                    q.append(key)\r\n                    used[key] = True\r\n                    ans += candies[key]\r\n            for box in containedBoxes[big_box]:\r\n                has_box[box] = True\r\n                if not used[box] and can_open[box]:\r\n                    q.append(box)\r\n                    used[box] = True\r\n                    ans += candies[box]\r\n        \r\n        return ans\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kyo-tom":[null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/14#issuecomment-1442854315","body":"### 思路\n\n使用双指针的方法。分别定义两个指针，一个指针为慢指针，步长为 1，另外一个指针为快指针，步长为 2。\n\n两个指针一起从链表头节点 head 出发.\n\n如果链表不存在环，则快指针会先到达链表尾节点，判断是否为尾节点的依据是指针 next 是否为空。\n\n如果链表存在环的话，快慢指针进入环后会一直在环内循环。\n\n由于快指针步长比慢指针大 1，因此在环内快指针最终会追上慢指针，判断追上慢指针的条件就是快指针指向的地址等于慢指针指向的地址。\n\n### 代码\n\n\n```java（此处换成你的语言，比如js，py 等）\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if(head == null) {\n            return false;\n        }\n        ListNode slow = head;\n        ListNode quikly = head;\n        while(quikly!= null && quikly.next != null) {\n            slow = slow.next;\n            quikly = quikly.next.next;\n            if (slow == quikly) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445152490","body":"### 思路\r\n\r\nLRU 采用哈希表 + 双向链表实现。\r\n\r\nLRU 中保存哈希表用来实现 get 的 O(1) 时间复杂度。保存 capacity 用于判断是否达到容量。保存链表的头节点和尾节点用于方便添加和删除。\r\n\r\n哈希表 key 为 输入的 key 值，value 为链表中的节点。\r\n\r\n链表节点储存输入的 key 值和输入的 value 以及前后两个指针。链表储存 key 值的作用是用于当缓存达到最大值后，移除链表尾节点时，同时获得需要移除的哈希表中的 key 值。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass LRUCache {\r\n\r\n    private Map<Integer, Node> index;\r\n    private int capacity;\r\n\r\n    private Node first;\r\n\r\n    private Node last;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        this.index = new HashMap<Integer, Node>(capacity);\r\n    }\r\n\r\n    public int get(int key) {\r\n        if (index.containsKey(key)) {\r\n            Node node = index.get(key);\r\n            if(first != node) {\r\n                if (last == node) {\r\n                    last = node.pre;\r\n                }\r\n                else {\r\n                    node.next.pre = node.pre;\r\n                }\r\n                node.pre.next = node.next;\r\n                first.pre = node;\r\n                node.next = first;\r\n                node.pre = null;\r\n                first = node;\r\n            }\r\n            return node.value;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        if(index.isEmpty()){\r\n            Node node = new Node(key,value);\r\n            first = node;\r\n            last = node;\r\n            index.put(key, node);\r\n        }\r\n        else {\r\n            if(index.containsKey(key)){\r\n                Node node = index.get(key);\r\n                if(node != first) {\r\n                    node.pre.next = node.next;\r\n                    if (node == last) {\r\n                        last = node.pre;\r\n                    }\r\n                    else {\r\n                        node.next.pre = node.pre;\r\n                    }\r\n                    first.pre = node;\r\n                    node.next = first;\r\n                    first = node;\r\n                }\r\n                node.value = value;\r\n            }\r\n            else {\r\n                if (index.size() == capacity) {\r\n                    int lastKey = last.key;\r\n                    if (last != first) {\r\n                        last.pre.next = null;\r\n                        last = last.pre;\r\n                        index.remove(lastKey);\r\n                    }\r\n                    else {\r\n                        index.remove(lastKey);\r\n                        Node node = new Node(key,value);\r\n                        first = node;\r\n                        last = node;\r\n                        index.put(key, node);\r\n                        return;\r\n                    }\r\n                }\r\n                Node node = new Node(key,value);\r\n                first.pre = node;\r\n                node.next = first;\r\n                first = node;\r\n                index.put(key, node);\r\n            }\r\n        }\r\n    }\r\n\r\n    private class Node {\r\n        private Node pre;\r\n        private Node next;\r\n        private int key;\r\n        private int value;\r\n\r\n        public Node(int key, int value){\r\n            this.key = key;\r\n            this.value = value;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445260006","body":"### 思路\n\n遍历整棵树\n\n### 代码\n\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int max;\n\n    public int maxDepth(TreeNode root) {\n        search(root, 0);\n        return max;\n    }\n\n    public void search(TreeNode root, int current){\n        if(root == null){\n            max = max > current ? max : current;\n            return;\n        }\n        search(root.left, current + 1);\n        search(root.right, current + 1);\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446138605","body":"### 思路\n\ndfs 或者 bfs 同时遍历两颗树即可\n\n### 代码\n\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n     public boolean isSameTree(TreeNode p, TreeNode q) {\n        // return dfs(p, q);\n        return bfs(p, q);\n    }\n\n    public boolean dfs(TreeNode p, TreeNode q) {\n        if(p == null && q == null) {\n            return true;\n        }\n        else if(p == null){\n            return false;\n        }\n        else if(q == null){\n            return false;\n        }\n        if (p.val == q.val) {\n            return dfs(p.left, q.left) && dfs(p.right, q.right);\n        }\n        else {\n            return false;\n        }\n    }\n\n    public boolean bfs(TreeNode p, TreeNode q) {\n        Queue<TreeNode> pq = new LinkedList();\n        Queue<TreeNode> qq = new LinkedList();\n        if(p == null && q == null) {\n            return true;\n        }\n        else if(p == null){\n            return false;\n        }\n        else if(q == null){\n            return false;\n        }\n        pq.offer(p);\n        qq.offer(q);\n        while (!pq.isEmpty() && !qq.isEmpty()) {\n            TreeNode a = pq.poll();\n            TreeNode b = qq.poll();\n            if ( a.val == b.val) {\n                if(a.left != null && b.left != null) {\n                    pq.offer(a.left);\n                    qq.offer(b.left);\n                }\n                else if ((a.left == null && b.left != null) \n                            ||  (a.left != null && b.left == null)) {\n                                return false;\n                            }\n                if(a.right != null && b.right != null) {\n                    pq.offer(a.right);\n                    qq.offer(b.right);\n                }\n                else if ((a.right == null && b.right != null) \n                            ||  (a.right != null && b.right == null)) {\n                                return false;\n                            }\n            }\n            else {\n                return false;\n            }\n        }\n        if(pq.isEmpty() && qq.isEmpty()){\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(h)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447513871","body":"### 思路\n\ndfs 遍历\n\n### 代码\n\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n            return getNum(root, 0);\n        }\n\n        // val 为到当前位置的路径上所经历的节点的综合\n        public int getNum(TreeNode root, int val) {\n            if (root.left == null && root.right == null) {\n                return val * 10 + root.val;\n            }\n            if (root.left == null) {\n                return getNum(root.right, val * 10 + root.val);\n            }\n            if (root.right == null) {\n                return getNum(root.left, val * 10 + root.val);\n            }\n            return getNum(root.left, val * 10 + root.val) + getNum(root.right, val * 10 + root.val);\n        }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/19#issuecomment-1449379640","body":"### 思路\n\n要找出最底层的最左边的节点的值。\n分两步考虑：\n1. 找出最底下一层（使用 BFS）\n2. 找出最左边的节点（每层从右往左遍历，自然每层的最后一个节点就是每层最左边的节点）\n\n### 代码\n\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int val = root.val;\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (node.right != null) {\n                queue.offer(node.right);\n            }\n            if (node.left != null) {\n                queue.offer(node.left);\n            }\n            val = node.val;\n        }\n        return val;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n), n 为树的总结点数\n- 空间复杂度：O(q)，q 为每一层的节点树，最差最节点数最多的那层的值","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1452891066","body":"### 思路\n\n通过 DFS 遍历树，在遍历树的时候携带上坐标信息。\n将坐标信息（x,y）和 节点值 val 保存值 Map<Integer, Map<Integer, List<Integer>>> 的数据结构中。\n在遍历完树后对结果进行遍历并整理出最终的结果值。\n\n### 代码\n\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root)  {\n        List<List<Integer>> result = new ArrayList<>();\n        Map<Integer, Map<Integer, List<Integer>>> memo = new HashMap<>();\n        record(root, memo, 0, 0);\n        \n        Set<Integer> columnSet = memo.keySet();\n        Integer[] columns = columnSet.toArray(new Integer[columnSet.size()]);\n        Arrays.sort(columns);\n        for (int i = 0; i < columns.length; i++){\n            int column = columns[i];\n            Map<Integer, List<Integer>> lineData = memo.get(column);\n            Set<Integer> lineSet = lineData.keySet();\n            Integer[] lines = lineSet.toArray(new Integer[lineSet.size()]);\n            Arrays.sort(lines);\n            List<Integer> lineResult = new ArrayList<>();\n            for (int j = 0; j < lines.length; j++) {\n                int line = lines[j];\n                List<Integer> data = lineData.get(line);\n                if (data.size() == 1){\n                    lineResult.addAll(data);\n                }\n                else {\n                    Integer[] colRowArray = data.toArray(new Integer[data.size()]);\n                    Arrays.sort(colRowArray);\n                    for (Integer nodeVal : colRowArray) {\n                        lineResult.add(nodeVal);\n                    }\n                }\n            }\n            result.add(lineResult);\n        }\n        return result;\n    }\n\n    private void record(TreeNode root,Map<Integer, Map<Integer, List<Integer>>> memo, int x, int y){\n\n        Map<Integer, List<Integer>> column = memo.getOrDefault(x, new HashMap<>());\n        List<Integer> line = column.getOrDefault(y, new ArrayList<>());\n        line.add(root.val);\n        column.put(y,line);\n        memo.put(x, column);\n        if(root.left != null) {\n            record(root.left, memo, x-1, y+1);\n        }\n        if(root.right != null) {\n            record(root.right, memo, x+1, y+1);\n        }\n    }\n}\n\n```\n\n**复杂度分析**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454356099","body":"### 思路\n\n1. 将数组中的值与对应的下表储存在 hash 表中。\n\n2. 遍历数据：\n\n\t对于每个数求其与目标数的差值，再去 hash 表中寻找是否存在该差值，若存在即可取出差值的下标。\n\n由于对于答案顺序可以是任意顺序。因此上述两步可以在一次遍历里面去做\n\n### 代码\n\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] result = new int[2];\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i = 0; i< nums.length; i++){\n            int need = target - nums[i];\n            if(map.containsKey(need)) {\n                int targetIndex = map.get(need);\n                if(targetIndex != i) {\n                    result[0] = i;\n                    result[1] = map.get(need);\n                    break;\n                }\n            }\n            else {\n                map.put(nums[i], i);\n            }\n        }\n        return result;\n    }\n}\n\n```\n\n**复杂度分析**\n时间复杂度：O(n)\n空间复杂度：O(n)\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459539843","body":"### 代码\n\n\n```java\nList<Integer> result = new ArrayList();\n        int wordsLength = words.length;\n        int wordLength = words[0].length();\n        int subStringLength = wordsLength * wordLength;\n        if(s.length() < subStringLength) {\n            return result;\n        }\n        int start = 0;\n        Map<String,Integer> map = new HashMap<>();\n        for(int i =0; i < words.length; i++){\n            String sub = words[i];\n            int count = map.getOrDefault(sub, -1);\n            map.put(sub, count+1);\n        }\n        while(start <= s.length() - subStringLength) {\n            Map<String, Integer> innerMap = new HashMap<>(map);\n            int innerStart = start;\n            while (innerStart < start + subStringLength){\n                String sub = s.substring(innerStart, innerStart + wordLength);\n                if(innerMap.containsKey(sub)) {\n                    int count = innerMap.get(sub);\n                    if (count > 0) {\n                        innerMap.put(sub, count - 1);\n                    }\n                    else {\n                        innerMap.remove(sub);\n                    }\n                    innerStart = innerStart + wordLength;\n                }\n                else {\n                    break;\n                }\n            }\n            if(innerMap.isEmpty()){\n                result.add(start);\n            }\n            start ++;\n        }\n        return result;\n    }\n\n```\n\n**复杂度分析**\n时间复杂度：O(nlogn)\n空间复杂度：O(n^2)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464642195","body":"### 思路\n\n双指针遍历数组知道右指针遍历完数组位置。\n左指针的作用主要是用于标记最后一个不同元素的下标\n\n\n### 代码\n\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int l = 0;\n        int r = l+1;\n        while(r < nums.length) {\n            if(nums[l] == nums[r]){\n                r++;\n            }\n            else {\n                l++;\n                nums[l] = nums[r];\n            }\n        }\n        return ++l;\n    }\n}\n\n```\n\n**复杂度分析**\n时间复杂度：O(n)\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465127832","body":"### 思路\n\n\n\n### 代码\n\n\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        if(nums.length == 0){\n            return 0;\n        }\n        int left = -1;\n        int right = nums.length;\n        while(left + 1 != right){\n            int mid = (left + right) / 2;\n            if(nums[mid] > target){\n                right = mid;\n            }\n            else{\n                left = mid;\n            }\n        }\n        return right == 0 ? 0 : (nums[right - 1] < target ? right : right - 1);\n    }\n}\n\n```\n\n**复杂度分析**\n时间复杂度：O(logn)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475256567","body":"class Solution {\npublic:\n    int Time2HourMinute(string time){\n        int hour = time[0]-'0';\n        hour = hour*10 + (time[1]-'0');\n        int minute = time[3] - '0';\n        minute = minute*10 + (time[4]-'0');\n        return hour*60 + minute;\n    }\n    int numberOfRounds(string loginTime, string logoutTime) {\n\n        int start = Time2HourMinute(loginTime);\n        int end = Time2HourMinute(logoutTime);\n\n        if(end<start){\n            end += 24*60;\n        }\n\n        return max(0,(int)floor(end*1.0/15) - (int)ceil(start*1.0/15));\n    }\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1478158443","body":"### 思路\n\n\n\n### 代码\n\n\n```java\nclass Solution {\n    public int mySqrt(int x) {\n        if(x == 0 || x == 1){\n            return x;\n        }\n        int red = -1, blue = x/2;\n        while (red + 1 != blue){\n            int mid = (red + blue)/2;\n            if (isRed(mid+1, x)){\n                red = mid;\n            }\n            else {\n                blue = mid;\n            }\n        }\n        // do something\n        return chose(x, red, blue);\n    }\n\n    public int chose(int target, int red, int blue) {\n        if(red == -1){\n            return -1;\n        }\n        else {\n            return red+1;\n        }\n    }\n\n    public boolean isRed(int num, int target) {\n        return target/num >= num;\n    }\n}\n\n```\n\n**复杂度分析**\n时间复杂度：O(logn)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/44#issuecomment-1480489649","body":"### 思路\n\n题目很简单，但要注意版本取值为 1-2^31，在取中值时会造成 int 溢出\n\n### 代码\n\n\n```java\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        if(n == 1){\n            return 1;\n        }\n        int red = 0;\n        int blue = n+1;\n        while(red + 1 != blue){\n            int mid = ((blue - red) >>> 1) + red;\n            if(!isBadVersion(mid)) {\n                red = mid;\n            }\n            else{\n                blue = mid;\n            }\n        }\n        return blue;\n    }\n}\n\n```\n\n**复杂度分析**\n时间复杂度：O(logn)\n空间复杂度：O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1485007644","body":"### 思路\n\n并查集\n\n### 代码\n\n\n```java\npublic class Solution {\n\n    private int N;\n\n    public static final int[][] DIRECTIONS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    public int swimInWater(int[][] grid) {\n        this.N = grid.length;\n\n        int len = N * N;\n        // 下标：方格的高度，值：对应在方格中的坐标\n        int[] index = new int[len];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                index[grid[i][j]] = getIndex(i, j);\n            }\n        }\n\n        UnionFind unionFind = new UnionFind(len);\n        for (int i = 0; i < len; i++) {\n            int x = index[i] / N;\n            int y = index[i] % N;\n\n            for (int[] direction : DIRECTIONS) {\n                int newX = x + direction[0];\n                int newY = y + direction[1];\n                if (inArea(newX, newY) && grid[newX][newY] <= i) {\n                    unionFind.union(index[i], getIndex(newX, newY));\n                }\n\n                if (unionFind.isConnected(0, len - 1)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    private int getIndex(int x, int y) {\n        return x * N + y;\n    }\n\n    private boolean inArea(int x, int y) {\n        return x >= 0 && x < N && y >= 0 && y < N;\n    }\n\n    private class UnionFind {\n\n        private int[] parent;\n\n        public UnionFind(int n) {\n            this.parent = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n\n        public int root(int x) {\n            while (x != parent[x]) {\n                parent[x] = parent[parent[x]];\n                x = parent[x];\n            }\n            return x;\n        }\n\n        public boolean isConnected(int x, int y) {\n            return root(x) == root(y);\n        }\n\n        public void union(int p, int q) {\n            if (isConnected(p, q)) {\n                return;\n            }\n            parent[root(p)] = root(q);\n        }\n    }\n}\n\n```\n\n**复杂度分析**\n时间复杂度：n^2*O(logn)\n空间复杂度：O(N^2)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494073324","body":"class Solution {\n    public int totalNQueens(int n) {\n        Set<Integer> columns = new HashSet<Integer>();\n        Set<Integer> diagonals1 = new HashSet<Integer>();\n        Set<Integer> diagonals2 = new HashSet<Integer>();\n        return backtrack(n, 0, columns, diagonals1, diagonals2);\n    }\n\n    public int backtrack(int n, int row, Set<Integer> columns, Set<Integer> diagonals1, Set<Integer> diagonals2) {\n        if (row == n) {\n            return 1;\n        } else {\n            int count = 0;\n            for (int i = 0; i < n; i++) {\n                if (columns.contains(i)) {\n                    continue;\n                }\n                int diagonal1 = row - i;\n                if (diagonals1.contains(diagonal1)) {\n                    continue;\n                }\n                int diagonal2 = row + i;\n                if (diagonals2.contains(diagonal2)) {\n                    continue;\n                }\n                columns.add(i);\n                diagonals1.add(diagonal1);\n                diagonals2.add(diagonal2);\n                count += backtrack(n, row + 1, columns, diagonals1, diagonals2);\n                columns.remove(i);\n                diagonals1.remove(diagonal1);\n                diagonals2.remove(diagonal2);\n            }\n            return count;\n        }\n    }\n}\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uratora":[null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/15#issuecomment-1445129990","body":"### 思路\n为使两个函数达到O(1)复杂度，同时使用链表和哈希表\n\n### 代码\n```c++\nstruct ListNodes {\n    ListNodes* prev;\n    ListNodes* next;\n    int key, val;\n    ListNodes(): key(0), val(0), prev(nullptr), next(nullptr){}\n    ListNodes(int _key, int _value): key(_key), val(_value), prev(nullptr), next(nullptr){}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, ListNodes*> hashmap;\n    ListNodes* head;\n    ListNodes* tail;\n    int capacity, size;\n\npublic:\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\n        head = new ListNodes();\n        tail = new ListNodes();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if(!hashmap.count(key))\n            return -1;\n        ListNodes* node = hashmap[key];\n        moveTohead(node);\n        return node->val;\n    }\n    \n    void put(int key, int value) {\n        if(!hashmap.count(key)){\n            ListNodes* node = new ListNodes(key, value);\n            hashmap[key] = node;\n            addTohead(node);\n            ++size;\n            if(size > capacity){\n                ListNodes* removed = removeTail();\n                hashmap.erase(removed->key);\n                --size;\n                delete removed;\n            }\n        }\n        else {\n            ListNodes* node = hashmap[key];\n            node->val = value;\n            moveTohead(node);\n        }\n    }\n\n    void addTohead(ListNodes* node){\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    \n    void removeNode(ListNodes* node){\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void moveTohead(ListNodes* node){\n        removeNode(node);\n        addTohead(node);\n    }\n\n    ListNodes* removeTail(){\n        ListNodes* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};\n```\n\n### 复杂度\n时间:O(1)\n空间:O(N)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454762383","body":"## 代码\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> m;\n        vector<int> ans;\n        for(int i = 0; i < nums.size(); i++){\n            if(m.count(target - nums[i])){\n                ans.push_back(m[target - nums[i]]);\n                ans.push_back(i);\n                break;\n            }\n            m[nums[i]] = i;          \n        }\n        return ans;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464926297","body":"## 代码\n```c++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int i = 1;\n        int j = 1;\n        if(nums.size() == 0)\n            return 0;\n        while(i < nums.size()){\n            if(nums[i] != nums[i - 1]){\n                nums[j++] = nums[i];\n            }\n            ++i;\n        }\n        return j;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guitarys":[null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1445009812","body":"class Solution:\ndef shortestToChar(self, s: str, c: str) -> List[int]:\nres = []\noutput = [0]*len(s)\nfor i in range(len(s)):\nif s[i] == c:\nres.append(i)\nfor i in range(len(s)):\nminV = inf\nfor j in range(len(res)):\nminV = min(minV, abs(res[j]-i))\noutput[i] = minV\nreturn output","onTime":false},null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445257560","body":"class Solution(object):\ndef init(self):\nself.mm = 0\ndef maxDepth(self, root):\n\"\"\"\n:type root: TreeNode\n:rtype: int\n\"\"\"\nself.pre_order(root, 1)\nreturn self.mm\ndef pre_order(self, root, depth):\nif not root:\nreturn 0\nif not root.left and not root.right:\nself.mm = max(depth, self.mm)\n\n    self.pre_order(root.left, depth + 1)\n    self.pre_order(root.right, depth + 1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/17#issuecomment-1446504588","body":"class Solution:\ndef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\nif not p and not q:\nreturn True\n\n    elif not p or not q:\n        return False\n    \n    elif p.val != q.val:\n        return False\n    \n    else:\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/18#issuecomment-1447606082","body":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(root, pre):\n            if root == None:\n                return 0\n            total = pre*10 + root.val\n            if root.left == None and root.right == None:\n                return total\n            else:\n                return dfs(root.left, total) + dfs(root.right, total)\n        return dfs(root, 0)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/22#issuecomment-1452864979","body":"``` python\nclass TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n\nfunction verticalTraversal(root: TreeNode | null): number[][] {\n  const nodes = [];\n\n  const dfs = (node, row, col, nodes) => {\n    if (node === null) {\n      return;\n    }\n    nodes.push([col, row, node.val]);\n    dfs(node.left, row + 1, col - 1, nodes);\n    dfs(node.right, row + 1, col + 1, nodes);\n  };\n\n  dfs(root, 0, 0, nodes);\n  nodes.sort((tuple1, tuple2) => {\n    if (tuple1[0] !== tuple2[0]) {\n      return tuple1[0] - tuple2[0];\n    } else if (tuple1[1] !== tuple2[1]) {\n      return tuple1[1] - tuple2[1];\n    } else {\n      return tuple1[2] - tuple2[2];\n    }\n  });\n\n  const ans: number[][] = [];\n  let lastcol = -Number.MAX_VALUE;\n  for (const tuple of nodes) {\n    let col = tuple[0],\n      row = tuple[1],\n      value = tuple[2];\n    if (col !== lastcol) {\n      lastcol = col;\n      ans.push([]);\n    }\n    ans[ans.length - 1].push(value);\n  }\n  return ans;\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455430134","body":"``` python  class Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans=0\n        for i in points:\n            a={}\n            for j in points:\n                c=(i[0]-j[0])**2+(i[1]-j[1])**2\n                if c not in a:\n                    a[c]=1\n                else:\n                    ans+=a[c]\n                    a[c]+=1\n        return ans*2\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/28#issuecomment-1459287510","body":"```java public List<Integer> findSubstring(String s, String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        List<Integer> result = new ArrayList<>();\n        for(int i=0; i<words.length; i++){\n            map.put(words[i], map.getOrDefault(words[i], 0)+1);\n        }\n\n        int wordLen = words[0].length();\n        int count = words.length;\n        int subLen = wordLen * count;\n\n        for(int i=0; i< s.length()-subLen+1; i++){\n            String str = s.substring(i, i+subLen);\n            //System.out.println(str);\n            Map<String, Integer> strMap = new HashMap<>();\n\n            for(int j=0; j<str.length(); j+=wordLen){\n                String word = str.substring(j,j+wordLen);\n                //System.out.println(word);\n                if(map.get(word) == null){\n                    break;\n                }\n                strMap.put(word, strMap.getOrDefault(word, 0)+1);\n                System.out.println(j);\n                if(strMap.get(word) > map.get(word)){\n                    break;\n                }\n                \n                if(j == subLen - wordLen){\n                    result.add(i);\n                }\n            }\n            \n\n        }\n        return result;\n        \n    } \n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464114801","body":"``` python \ndef removeDuplicates(nums):\n    if not nums:\n        return 0\n    \n    i = 0\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    \n    return i + 1\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1465533326","body":"···python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        cur = 0\n        q  = deque()\n        res = []        \n        while cur<len(nums):\n            while q and  nums[cur]>q[-1]:\n                q.pop()\n            q.append(nums[cur])\n            if cur>=k and nums[cur-k]==q[0]:\n                q.popleft()\n            if cur>=k-1:    \n                res.append(q[0])\n            cur += 1\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1468008972","body":"··· python\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] in = new int[n];\n        int[] out = new int[n];\n        for (int[] t: trust) {\n            in[t[1] - 1]++;\n            out[t[0] - 1]++;\n        }\n        for (int i = 0; i < n; i++) {\n            if (in[i] == n - 1 && out[i] == 0) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n}\n···","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1472741870","body":"class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        # simulation problem\n        # starting (0,0)\n        x = 0\n        y = 0\n        for move in moves:\n            if move == \"U\":\n                y += 1\n            if move == \"D\":\n                y -= 1\n            if move == \"L\":\n                x -= 1\n            if move == \"R\":\n                x += 1\n        return x == 0 and y == 0","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475458703","body":"class Solution:\n    def minCharacters(self, A: str, B: str) -> int:\n        ca = collections.Counter(A)\n        cb = collections.Counter(B)\n        # ca 中严格大于 cb 的最小操作数\n        def greater_cost(ca, cb):\n            ans = float(\"inf\")\n            # 枚举 ca 中的最小值\n            for i in range(1, 26):\n                count = 0\n                # 将 ca 中小于最小值的都进行一次操作\n                for j in range(i):\n                    count += ca[chr(97 + j)]\n                # 将 cb 中大于等于最小值的都进行一次操作（注意这里的等号）\n                for j in range(i, 26):\n                    count += cb[chr(97 + j)]\n                ans = min(ans, count)\n            return ans\n\n        def equal_cost(ca, cb):\n            ans = float(\"inf\")\n            for i in range(26):\n                ans = min(ans, len(A) + len(B) - ca[chr(97 + i)] - cb[chr(97 + i)])\n            return ans\n\n        return min(greater_cost(ca, cb), greater_cost(cb, ca), equal_cost(ca, cb))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/42#issuecomment-1477440793","body":"``` java\nclass Solution {\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        quicksort(nums,0,nums.size()-1);\n        return nums;\n    }\n    void quicksort(vector<int>& nums,int l,int r){\n        if(l>=r) return;\n        int i=l-1,j=r+1;\n        int partval=nums[(i+j)>>1];\n        while(i<j){\n            do i++;while(nums[i]<partval);\n            do j--;while(nums[j]>partval);\n            if(i<j) swap(nums[i],nums[j]);\n        }\n\n        quicksort(nums,l,j);\n        quicksort(nums,j+1,r);\n    }\n};\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/45#issuecomment-1482264685","body":"```python\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        def h(nums):\n            if len(nums) <= 1: return nums, 0\n            mid = len(nums) // 2\n            lArr, lRes, rArr, rRes = *h(nums[:mid]), *h(nums[mid:])\n            res, rIndex = lRes + rRes, 0\n            for n in lArr:\n                while rIndex < len(rArr) and rArr[rIndex] * 2 < n: rIndex += 1\n                res += rIndex\n            return sorted(nums), res \n        return h(nums)[1]\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484444271","body":"class Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        l, r = 0, max([max(vec) for vec in grid])\n        seen = set()\n\n        def test(mid, x, y):\n            if x > len(grid) - 1 or x < 0 or y > len(grid[0]) - 1 or y < 0:\n                return False\n            if grid[x][y] > mid:\n                return False\n            if (x, y) == (len(grid) - 1, len(grid[0]) - 1):\n                return True\n            if (x, y) in seen:\n                return False\n            seen.add((x, y))\n            ans = test(mid, x + 1, y) or test(mid, x - 1,\n                                              y) or test(mid, x, y + 1) or test(mid, x, y - 1)\n            return ans\n        while l <= r:\n            mid = (l + r) // 2\n            if test(mid, 0, 0):\n                r = mid - 1\n            else:\n                l = mid + 1\n            seen = set()\n        return l","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1490209168","body":"class Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        if len(s) < len(p):\n            return []\n\n        p_count, s_count = [0] * 26, [0] * 26\n\n        for ch in p:\n            p_count[ord(ch) - ord('a')] += 1\n        \n        res = []\n        # sliding window on the string s\n        for i in range(len(s)):\n            s_count[ord(s[i]) - ord('a')] += 1  # add\n            if i >= len(p):\n                s_count[ord(s[i - len(p)]) - ord('a')] -= 1  # remove\n            # compare array in the sliding window with the reference array\n            if p_count == s_count:\n                res.append(i - len(p) + 1)\n        \n        return res","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497866048","body":"class Solution:\ndef maxDistance(self, grid: List[List[int]]) -> int:\nr, c = len(grid), len(grid[0])\ndata = list()\nfor i in range(r):\nfor j in range(c):\nif grid[i][j] == 1:\ndata.append((i, j, 0))\n\n    d = [(0,1), (0,-1), (1,0), (-1,0)]\n    res = 0\n    while data:\n        i, j, res = data.pop(0)\n        for xd, yd in d:\n            x, y = i + xd, j + yd\n            if 0 <= x < r and 0 <= y < c and grid[x][y] == 0:\n                grid[x][y] = 1\n                data.append((x, y, res+1))\n                \n    return res if res != 0 else -1","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498490595","body":"class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        ownboxes = set()\n        ownkeys = set()\n        kaiguo = set()\n        res = 0\n        q = deque()\n        for i in initialBoxes:\n            if status[i]:\n                q.append(i)\n                kaiguo.add(i)\n            else:\n                ownboxes.add(i)        \n        while q:\n            curbox = q.popleft() \n            res += candies[curbox]\n            ownkeys.discard(curbox)\n            ownboxes.discard(curbox)\n            \n            for key in keys[curbox]:\n                if key in ownboxes:\n                    if key not in kaiguo:\n                        q.append(key)\n                        kaiguo.add(key)\n                else:\n                    ownkeys.add(key)\n            for box in containedBoxes[curbox]:\n                if status[box]==1 or (box in ownkeys):\n                    if box not in kaiguo:\n                        q.append(box)\n                        kaiguo.add(box)\n                else:\n                    ownboxes.add(box)\n        return res","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501335736","body":"var findNumberOfLIS = function(nums) {\n    const len = new Array(nums.length).fill(1);//len[i]=>nums[i]结尾的最长子序列长度\n    const dp = new Array(nums.length).fill(1);//dp[i]=>nums[i]结尾的最长子序列个数\n    //dp[i] = max(dp[0,i-1 while(num[j]<nums[i-1])])+1\n    for (let i = 1; i < nums.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[j] < nums[i]) {\n                if (len[j] + 1 > len[i]) {\n                    len[i] = len[j] + 1;\n                    dp[i] = dp[j]\n                } else if (len[j] + 1 === len[i]) {\n                    dp[i] += dp[j]\n                }\n            }\n        }\n    }\n    const maxLen = Math.max(...len);\n    let res = 0\n    len.forEach((val, i) => {\n        if (val === maxLen) {\n            res += dp[i]\n        }\n    })\n    return res\n};","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1510747050","body":"``` java\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        int m = coins.size();\n        vector<vector<int>> dp(m + 1, vector<int>(amount + 1, 10001));\n        dp[0][0] = 0;\n        for (int i = 1; i <= m; ++i)\n        {\n            for (int j = 0; j <= amount; ++j)\n            {\n                if (j >= coins[i - 1])\n                {\n                    dp[i][j] = min(dp[i][j - coins[i - 1]] + 1, dp[i - 1][j]);\n                }\n                else\n                {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return dp[m][amount] == 10001 ? -1 : dp[m][amount];\n    }\n}\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514695780","body":"public int findContentChildren(int[] g, int[] s) {\n    Arrays.sort(g);\n    Arrays.sort(s);\n    int i = 0;\n    for (int j = 0; i < g.length && j < s.length; j++) {\n        if (g[i] <= s[j]) {\n            i++;\n        }\n    }\n    return i;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516376244","body":"``` python\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        if (intervals.empty()) {\n            return 0;\n        }\n        \n        sort(intervals.begin(), intervals.end(), [](const auto& u, const auto& v) {\n            return u[1] < v[1];\n        });\n\n        int n = intervals.size();\n        int right = intervals[0][1];\n        int ans = 1;\n        for (int i = 1; i < n; ++i) {\n            if (intervals[i][0] >= right) {\n                ++ans;\n                right = intervals[i][1];\n            }\n        }\n        return n - ans;\n    }\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1519937249","body":"``` python\nclass Solution:\n    def beautifulArray(self, n: int) -> List[int]:\n        memo = {}\n        return self.divide(n, memo)\n    \n    def divide(self, n, memo):\n        if n in memo:\n            return memo[n]        \n        if n == 1:\n            return [1]\n\n        odds = self.divide((n + 1) // 2, memo)\n        evens = self.divide(n // 2, memo)\n\n        left = [2*x-1 for x in odds]\n        right = [2*x for x in evens]\n\n        memo[n] =  left + right\n        return left + right\n\n        # divide\n        # time: (n logn)\n        # space: (n logn)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sosdogecoin":[null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/16#issuecomment-1445340743","body":"思路：\r\n先递归计算出左边和右边子树的最大深度，然后用0（1）时间复杂度计算出这个二叉树的最大深度。\r\n访问到空节点就退出。\r\n\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        else:\r\n            left_h = self.maxDepth(root.left)\r\n            right_h = self.maxDepth(root.right)\r\n            return max(left_h, right_h) + 1\r\n\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(height)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1454343571","body":"思路…暴力解题\npublic int[] twoSum(int[] nums, int target) {\n  for (int i = 0; i < nums.length; i++) {\n    for (int j = i + 1; j < nums.length; j++) {\n      if (nums[j] == target - nums[i]) {\n        return new int[] { i, j };\n      }\n    }\n  }\n  throw new IllegalArgumentException(\"No two sum solution\");\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zol013":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1450740365","body":"''''\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        \n        def dfs(node, string):\n            if not node:\n                string += \"None,\"\n                return string\n            string += str(node.val) + ','\n            string = dfs(node.left, string)\n            string = dfs(node.right, string)\n            \n            return string\n        \n        return dfs(root, '')\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        \n        \n        def dfs(data_list):\n            if data_list[0] == 'None':\n                data_list.pop(0)\n                return None\n            \n            root = TreeNode(int(data_list[0]))\n            data_list.pop(0)\n            root.left = dfs(data_list)\n            root.right = dfs(data_list)\n            return root\n        \n        \n        data_list = data.split(',')\n        return dfs(data_list)\n''''        \n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/23#issuecomment-1453787396","body":"``\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        hashmap = dict()\r\n        for i in range(len(nums)):\r\n            if target - nums[i] in hashmap:\r\n                j = hashmap[target - nums[i]]\r\n                return [i,j]\r\n           hashmap[nums[i]] = i\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/24#issuecomment-1454963401","body":"'''\nclass Solution:\n\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        \n        heap = []\n        count = Counter(nums)\n        \n        for num, freq in count.items():\n            heapq.heappush(heap, (freq, num))\n            if len(heap) >k:\n                heapq.heappop(heap)\n            \n        return [num for freq, num in heap]\n'''","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1456716786","body":"'''\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        ans = 0\n        i = 0\n        hashmap = defaultdict(int)\n        \n        for j in range(len(s)):\n            hashmap[s[j]] += 1\n            if hashmap[s[j]] == 1:\n                ans = max(ans, j - i + 1)\n            else:\n                while hashmap[s[j]] > 1:\n                    hashmap[s[i]] -= 1\n                    i += 1\n        \n        return ans\n'''","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/32#issuecomment-1464075049","body":"```\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        if len(nums) <= 2:\r\n            return len(nums)\r\n        \r\n        slow, fast = 2, 2\r\n        while fast < len(nums):\r\n            if nums[slow - 2] != nums[fast]:\r\n                nums[slow] = nums[fast]\r\n                slow += 1\r\n            fast += 1\r\n        \r\n        return slow\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/33#issuecomment-1465092265","body":"```\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n        \n        while l <= r:\n            mid = (l + r)//2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                r = mid - 1\n            else:\n                l = mid + 1\n        \n        return l\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/35#issuecomment-1467278250","body":"```\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        indegree = [0] * n\n        outdegree = [0] * n\n        for relation in trust:\n            indegree[relation[1] - 1] += 1\n            outdegree[relation[0] - 1] += 1\n        \n        for i in range(n):\n            if indegree[i] == n - 1 and outdegree[i] == 0:\n                return i + 1\n        \n        return -1\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/37#issuecomment-1470755345","body":"```\nclass Solution:\n    def tp_sort(self, items, indegree, neighbors):\n        q = collections.deque([])\n        ans = []\n        for item in items:\n            if indegree[item] == 0:\n                q.append(item)\n        \n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    q.append(neighbor)\n        \n        return ans\n\n    \n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        max_group_id = m\n        \n        for project in range(n):\n            if group[project] == -1:\n                group[project] = max_group_id\n                max_group_id += 1\n        \n        project_indegree = defaultdict(int)\n        group_indegree = defaultdict(int)\n        project_neighbors = defaultdict(list)\n        group_neighbors = defaultdict(list)\n        group_projects = defaultdict(list)\n        \n        for project in range(n):\n            group_projects[group[project]].append(project)\n            \n            for pre in beforeItems[project]:\n                if group[pre] != group[project]:\n                    group_indegree[group[project]] += 1\n                    group_neighbors[group[pre]].append(group[project])\n                else:\n                    project_indegree[project] += 1\n                    project_neighbors[pre].append(project)\n        \n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\n       \n        if len(group_queue) != max_group_id:\n            return []\n        ans = []\n        \n        for group_id in group_queue:\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n            \n            if len(project_queue) != len(group_projects[group_id]):\n                return []\n            \n            ans += project_queue\n        \n        return ans\n        \n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475324691","body":"'''\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        countA = [0] * 26\n        countB = [0] * 26\n        \n        for char in a:\n            countA[ord(char) - ord('a')] += 1\n        for char in b: \n            countB[ord(char) - ord('a')] += 1\n        case3 = len(a) + len(b) - max(countA) - max(countB)\n        \n        case1 = len(a) + len(b)\n        for i in range(1, 26):\n            t = 0\n            for j in range(i, 26):\n                t += countA[j]\n            for j in range(i):\n                t += countB[j]\n            case1 = min(case1, t)\n        \n        case2 = len(a) + len(b) \n        for i in range(1, 26):\n            t = 0\n            for j in range(i, 26):\n                t += countB[j]\n            for j in range(i):\n                t += countA[j]\n            case2 = min(case2, t)\n        \n        return min(case1, case2, case3)\n'''","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479864310","body":"```\nclass Solution:\n    def firstBadVersion(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        l, r = 1, n\n        \n        while l <= r:\n            mid = (l + r)//2\n            if isBadVersion(mid):\n                r = mid - 1\n            else:\n                l = mid + 1\n        \n        return l\n```","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484203518","body":"```\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        '''\n        l, r = 0, max([max(row) for row in grid])\n        seen = set()\n        n = len(grid)\n        def test(mid, x, y):\n            if not (0 <= x < n and 0 <= y < n ):\n                return False\n            if grid[x][y] > mid:\n                return False\n            if x == y == n - 1:\n                return True\n            \n            if (x, y) in seen:\n                return False\n            seen.add((x, y))\n            ans = test(mid, x + 1, y) or test(mid, x - 1, y) or test(mid, x, y - 1) or test(mid, x, y + 1)\n            return ans\n            \n        \n        \n        while l <= r:\n            mid = (l + r) // 2\n            if test(mid, 0, 0):\n                r = mid - 1\n            else:\n                l = mid + 1\n            \n            seen = set()\n        return l\n        '''\n        \n        N = len(grid)\n        seen = {(0, 0)}\n        pq = [(grid[0][0], 0 ,0)]\n        ans = 0\n        \n        while pq:\n            d, r, c = heappop(pq)\n            ans = max(ans, d)\n            if r == c == N - 1:\n                return ans\n            for cr, cc in ((r+1,c),(r-1,c),(r,c-1),(r,c+1)):\n                if 0 <= cr < N and 0 <= cc < N and (cr, cc) not in seen:\n                    heappush(pq, (grid[cr][cc], cr, cc))\n                    seen.add((cr, cc))\n\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/54#issuecomment-1493218335","body":"```\nclass Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        def possible_number(count, minute = False):\n            if count == 0:\n                return [0]\n            if minute:\n                return filter(lambda a:a<60, map(sum, combinations([1,2,4,8,16,32], count)))\n            return filter(lambda a:a<12, map(sum, combinations([1,2,4,8], count)))\n        \n        ans = set()\n        for i in range(min(4, turnedOn + 1)):\n            for a in possible_number(i):\n                for b in possible_number(turnedOn - i, True):\n                    ans.add(str(a)+':'+str(b).rjust(2,\"0\"))\n        return list(ans)\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501038246","body":"```\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) < 2:\n            return nums[0]\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[1], dp[0])\n        for i in range(2, len(nums)):\n            dp[i] = max(nums[i] + dp[i - 2], dp[i - 1])\n        \n        return dp[-1]\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lrwhc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/21#issuecomment-1451788916","body":"class Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return 'None'\n        return str(root.val) + ',' + str(self.serialize(root.left)) + ',' + str(self.serialize(root.right))\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def dfs(dataList):\n            val = dataList.pop(0)\n            if val == 'None':\n                return None\n            \n            root = TreeNode(int(val))\n            root.left = dfs(dataList)\n            root.right = dfs(dataList)\n            return root\n        \n        dataList = data.split(',')\n        return dfs(dataList)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/25#issuecomment-1455984308","body":"def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        n = len(points)\n        for i in range(n):\n            dict_i = collections.defaultdict(int)\n            for j in range(n):\n                if j == i:\n                    continue\n                dist = abs(points[i][0] - points[j][0]) ** 2 + abs(points[i][1] - points[j][1]) ** 2\n                dict_i[dist] += 1\n            for k,v in dict_i.items():\n                ans+=v*(v-1)\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/27#issuecomment-1457840656","body":"```\ndef max_str(s):\n    long = len(s)\n    for i in range(long, 1, -1):\n        j = 0\n        k = j + long\n        while k <= long:\n            if len(set(s[j:k])) == i:\n                return i\n            else:\n                j, k = j + 1, j + long\n    return 1\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/30#issuecomment-1461220426","body":"```\ndef m(s, p):\n  long, count = len(s), 0\n  for i in range(0, long - 1):\n    j, k = count, count + i\n    while k < long:\n        t = sum(s)\n        t1 = sum(s[j:k + 1])\n        if (t - t1) % p == 0:\n            return i + 1\n        else:\n            j += 1\n            k = j + i\n  return -1\n\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/34#issuecomment-1466170784","body":"```\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        if k == 0: return []\r\n        res = []\r\n        for r in range(k, len(nums) + 1):\r\n            res.append(max(nums[r - k: r]))\r\n        return res\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1473341580","body":"```\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        x = y = 0\n        for move in moves:\n            if move == 'R': x += 1\n            if move == 'L': x -= 1\n            if move == 'U': y += 1\n            if move == 'D': y -= 1\n\n        return x == 0 and y == 0\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/41#issuecomment-1475756248","body":"```\ndef minCharacters(a: str, b: str) -> int:\n    a = [ord(i) - 97 for i in a]\n    b = [ord(i) - 97 for i in b]\n    AA = Counter(a)\n    BB = Counter(b)\n    C = AA + BB\n    ans = sum(C.values()) - max(C.values())\n    A = [0] * 26\n    B = [0] * 26\n    for k,v in AA.items():\n        A[k] = v\n    for k,v in BB.items():\n        B[k] = v\n\n    for i in range(1,26):\n        ans = min(ans,sum(A[i:])+sum(B[:i]))\n        ans = min(ans,sum(A[:i])+sum(B[i:]))\n    return ans\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479118726","body":"```\ndef mySqrt(self, x: int) -> int:\n        return int(x ** 0.5)\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484366740","body":"```\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        l, r = 0, max([max(vec) for vec in grid])\n        seen = set()\n\n        def test(mid, x, y):\n            if x > len(grid) - 1 or x < 0 or y > len(grid[0]) - 1 or y < 0:\n                return False\n            if grid[x][y] > mid:\n                return False\n            if (x, y) == (len(grid) - 1, len(grid[0]) - 1):\n                return True\n            if (x, y) in seen:\n                return False\n            seen.add((x, y))\n            ans = test(mid, x + 1, y) or test(mid, x - 1,\n                                              y) or test(mid, x, y + 1) or test(mid, x, y - 1)\n            return ans\n        while l <= r:\n            mid = (l + r) // 2\n            if test(mid, 0, 0):\n                r = mid - 1\n            else:\n                l = mid + 1\n            seen = set()\n        return l\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wwewwt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/38#issuecomment-1472992160","body":"## 思路\n定义初始坐标x=0,y=0；相应的操作对应x，y坐标的增减：  R：x+1 ，L：x-1 ，U：y+1 ，D：y-1\n特殊情况分析：机器人走的步数如果是奇数，则肯定回不到原点，所以可以快速排除这类情况（理论上占一半） \n\n## 复杂度\n时间复杂度O(n)，空间复杂度O(1)\n\n## 代码\n\n``` python\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        if len(moves)%2 == 1:\n            return False\n        \n        x = 0\n        y = 0\n        for i in moves:\n            if i == 'R':\n                x = x + 1\n            elif i == 'L':\n                x = x - 1\n            elif i == 'U':\n                y = y + 1\n            elif i == 'D':\n                y = y -1\n                \n        return x==0 and y==0\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/40#issuecomment-1475292788","body":"## 思路\n按15分钟一个时间段，把一天的时间分成96份\n这样每局游戏的时间的开始时间就变成了1、2、3  .....  96\n起始时间如果是小数，比如1.1，就要向上取整，算成2\n结束时间如果是小数，比如3.3，就要向下取整，算成3\n最后相减就是局数\n\n## 代码\n```python\nimport math\nclass Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        [startHour, startMin] = loginTime.split(\":\")\n        start = (int(startHour) * 60 + int(startMin))/15\n        \n        [logouttHour, logoutMin] = logoutTime.split(\":\")\n        logout = (int(logouttHour) * 60 + int(logoutMin))/15\n        \n        #start向上取整  logout向下取整\n        begin  = int(math.ceil(start))\n        end = int(logout)\n        \n        if start < logout:\n            if end < begin:\n                return 0\n            else:\n                return end - begin\n        \n        \n        \n        #通宵\n        if start > logout:\n            return 96 - begin + end\n```\n\n\n## 复杂度\n\n时间复杂度O(1)        空间复杂度O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/43#issuecomment-1479773143","body":"## 思路\n二分法，循环条件是 l <= r\n\n## 代码\n```\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x < 2:\n            return x\n        \n        l = 1\n        r = x - 1\n        \n        while l<=r:\n            mid = (l + r)//2\n            mid2 = mid*mid\n            if mid2 < x:\n                l = mid + 1\n            elif mid2 > x:\n                r = mid - 1\n            else:\n                return mid\n        \n        return l-1\n```\n##复杂度\n时间复杂度：O(logn) 空间复杂度O（1）","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/48#issuecomment-1484958737","body":"## 思路\r\n模拟水位上升的过程，不断更新所能游到的新位置，直到最后出现了[N-1,N-1]\r\n\r\n## 代码\r\n```\r\nclass Solution:\r\n    def swimInWater(self, grid: List[List[int]]) -> int:\r\n        N = len(grid)\r\n        max = 0\r\n        water_level = grid[0][0]\r\n        #起始位\r\n        lake = []\r\n        lake.append([0,0])\r\n        \r\n        while True:\r\n            i=0\r\n            while i < len(lake):\r\n                #左移动一格\r\n                if lake[i][0] - 1 >= 0:\r\n                    #如果水位小于等于当前点，则可以游过去\r\n                    if grid[lake[i][0] - 1][lake[i][1]] <= water_level and [lake[i][0] - 1, lake[i][1]] not in lake:\r\n                        lake.append([lake[i][0] - 1, lake[i][1]])\r\n\r\n                if lake[i][0] + 1 <= N-1:\r\n                    if grid[lake[i][0] + 1][lake[i][1]] <= water_level and [lake[i][0] + 1, lake[i][1]] not in lake:\r\n                        lake.append([lake[i][0] + 1, lake[i][1]])\r\n\r\n                if lake[i][1] - 1 >= 0:\r\n                    if grid[lake[i][0]][lake[i][1] - 1] <= water_level and [lake[i][0], lake[i][1] - 1] not in lake:\r\n                        lake.append([lake[i][0], lake[i][1] - 1])\r\n\r\n                if lake[i][1] + 1 <= N-1:\r\n                    if grid[lake[i][0]][lake[i][1] + 1] <= water_level and [lake[i][0], lake[i][1] + 1] not in lake:\r\n                        lake.append([lake[i][0], lake[i][1] + 1])\r\n                i+=1\r\n                \r\n            if [N-1,N-1] in lake:\r\n                return water_level\r\n        \r\n            water_level += 1\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(n2) 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/49#issuecomment-1486567300","body":"##思路\n双指针在字符串数组上移动，新增元音字母加1，出局元音字母减一\n\n\n##  代码\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        i=0\n        j=0\n        aeiou_num = 0\n        for j in range(k):\n            if s[j] in ['a','e','i','o','u']:\n                aeiou_num += 1\n        \n        i = 1\n        j +=1\n        max = aeiou_num\n        while j < len(s):\n           \n            if s[i-1] in ['a','e','i','o','u']:\n                aeiou_num -= 1\n                \n            if s[j] in ['a','e','i','o','u']:\n                aeiou_num += 1\n                \n            \n            if aeiou_num > max:\n                max = aeiou_num\n                \n            if max == k:\n                return k\n            \n            i+=1\n            j+=1\n            \n        return max\n```\n\n## 复杂度\n时间复杂度 O(n)，空间复杂度O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/51#issuecomment-1489892015","body":"# 思路\r\n双指针移动，判断字符串是否相等\r\n\r\n# 代码\r\n```\r\nclass Solution:\r\n    def findAnagrams(self, s: str, p: str) -> List[int]:\r\n        if len(s) < len(p):\r\n            return []\r\n        \r\n        #构建字典\r\n        base=dict()\r\n        tmp =dict()\r\n        for s_i in p:\r\n            if s_i in base:\r\n                base[s_i] += 1\r\n            else:\r\n                base[s_i] = 1\r\n                tmp[s_i]  = 0\r\n        \r\n        \r\n        #双指针\r\n        for j in range(len(p)):\r\n            if s[j] in tmp:\r\n                tmp[s[j]] += 1\r\n            \r\n                \r\n        i = 0\r\n        result = []\r\n        \r\n        print(base)\r\n        while j < len(s):\r\n            if base == tmp:\r\n                result.append(i)\r\n            \r\n            i += 1\r\n            j += 1\r\n            #更新tmp\r\n            if j < len(s):\r\n                if s[i - 1] in tmp:\r\n                    tmp[s[i - 1]] -= 1\r\n                \r\n                if s[j] in tmp:\r\n                    tmp[s[j]] += 1\r\n            \r\n        return result\r\n\r\n```\r\n\r\n# 复杂度\r\n时间复杂度 O（n），空间复杂度O（1）","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1499242132","body":"# 思路\n先根据盒子找钥匙，再根据钥匙+找盒子，知道最后盒子没有更新\n\n# 代码\n```\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        n = len(status)\n        can_open = [status[i] == 1 for i in range(n)]\n        has_box, used = [False] * n, [False] * n\n        \n        q = collections.deque()\n        ans = 0\n        for box in initialBoxes:\n            has_box[box] = True\n            if can_open[box]:\n                q.append(box)\n                used[box] = True\n                ans += candies[box]\n        \n        while len(q) > 0:\n            big_box = q.popleft()\n            for key in keys[big_box]:\n                can_open[key] = True\n                if not used[key] and has_box[key]:\n                    q.append(key)\n                    used[key] = True\n                    ans += candies[key]\n            for box in containedBoxes[big_box]:\n                has_box[box] = True\n                if not used[box] and can_open[box]:\n                    q.append(box)\n                    used[box] = True\n                    ans += candies[box]\n        \n        return ans\n\n```\n\n\n# 复杂度\nO(N)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1505506928","body":"# 思路\n因为机器人只能向右或向下移动，所以到每一格的路线条数只能是它上面一格的条数加它左边一格的条数\n\n\n# 代码\n```\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        #二维数组\n \n        l = 0 #行从0开始\n        mat = [] # 定义一个二维数组mat\n        while l < m:\n            r = 0 #列从0开始\n            line = [] #line存储每一行数据\n            while r < n:\n                line.append(0) #装载行数据\n                r = r + 1\n            mat.append(line) #按行装载二维数组\n            l = l + 1\n        \n\n        \n        #初始化行和列\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j ==0:\n                    mat[i][j] = 1\n                else:\n                    mat[i][j] = mat[i-1][j] + mat[i][j-1]\n\n            \n\n        return mat[m-1][n-1] \n```\n\n\n# 复杂度\n时间复杂度O(mn)    空间复杂度O(mn)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyk1337":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/46#issuecomment-1483740380","body":"        if s == goal:\n            return True\n        s, goal = [*s], [*goal]\n        for x in range(len(s)):\n            a = s[0]\n            s.pop(0)\n            s.append(a)\n            if s == goal:\n                return True\n        return False","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyu1131":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/55#issuecomment-1494377838","body":"```c++\nclass Solution {\npublic:\n    int totalNQueens(int n) {\n        vector<vector<int>> grid(n, vector<int>(n, 0)); // n*n的棋盘，放置皇后的格子填充1\n        int res = 0;\n        dfs(grid, 0, res);\n\n        return res;\n    }\n\nprivate:\n    void dfs(vector<vector<int>>& grid, int row_idx, int& res)\n    {\n        if (row_idx >= grid.size()) // 成功到最后，结束\n        {\n            ++res;\n            return;\n        }\n\n        for (int i = 0; i < grid.size(); ++i)\n        {\n            // 对每一行的每一个点做判断，该位置是否能放置皇后\n            bool can_put = judge(grid, row_idx, i);\n            if (can_put)// 能放置\n            {\n                grid[row_idx][i] = 1;\n                dfs(grid, row_idx + 1, res);\n                grid[row_idx][i] = 0; // 回溯\n            }\n        }\n    }\n\n    bool judge(vector<vector<int>>& grid, int i, int j)\n    {\n        // 行不用检查，因为这种写法保证了每一行本来就只会有一个\n        // 检查同一列\n        int n = grid.size();\n        for (int ii = 0; ii < n; ++ii)\n        {\n            if (grid[ii][j] == 1)\n            {\n                return false;\n            }\n        }\n        // 检查左上到右下的对角线\n        int ii = i - 1, jj = j - 1;\n        while (ii >= 0 && jj >= 0)\n        {\n            if (grid[ii][jj] == 1)\n            {\n                return false;\n            }\n            --ii;\n            --jj;\n        }\n        ii = i + 1, jj = j + 1;\n        while (ii < n && jj < n)\n        {\n            if (grid[ii][jj] == 1)\n            {\n                return false;\n            }\n            ++ii;\n            ++jj;\n        }\n\n        // 检查左下到右上对角线\n        ii = i + 1, jj = j - 1;\n        while (ii < n && jj >= 0)\n        {\n            if (grid[ii][jj] == 1)\n            {\n                return false;\n            }\n            ++ii;\n            --jj;\n        }\n        ii = i - 1, jj = j + 1;\n        while (ii >= 0 && jj < n)\n        {\n            if (grid[ii][jj] == 1)\n            {\n                return false;\n            }\n            --ii;\n            ++jj;\n        }\n\n        return true;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495355477","body":"```c++\nclass Solution {\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        // dfs\n        \n        int n = grid.size();\n        int m = grid[0].size();\n        vector<vector<int>> visited(n, vector<int>(m, 0));// 记录是否遍历过\n\n        int max_area = 0;\n        for (int i = 0; i < n; ++i)\n        {\n            for (int j = 0; j < m; ++j)\n            {\n                if (grid[i][j] == 1 && !visited[i][j])\n                {\n                    int tmp_area = 0;\n                    dfs(grid, i, j, visited, tmp_area);\n                    max_area = std::max(max_area, tmp_area);\n                }\n            }\n        }\n\n        return max_area;\n    }\nprivate:\n    void dfs(const vector<vector<int>>& grid, int i, int j, vector<vector<int>>& visited, int& area)\n    {\n        if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || visited[i][j])\n        {\n            return;\n        }\n        if (grid[i][j] == 0) // 海洋\n        {\n            return;\n        }\n\n        // 符合条件\n        ++area;\n        visited[i][j] = 1;\n        \n        // dfs查周围的四个方向\n        dfs(grid, i - 1, j, visited, area);\n        dfs(grid, i + 1, j, visited, area);\n        dfs(grid, i, j - 1, visited, area);\n        dfs(grid, i, j + 1, visited, area);\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1498615729","body":"```c++\nclass Solution {\npublic:\n    int maxCandies(vector<int>& status, vector<int>& candies, vector<vector<int>>& keys, vector<vector<int>>& containedBoxes, vector<int>& initialBoxes) {\n        // bfs\n        if (initialBoxes.empty())\n        {\n            return 0;\n        }\n        int n = status.size();\n\n        vector<int> visited(n, 0);\n        int max_candies = 0;\n        vector<int> valid_keys(n, 0);\n        vector<int> valid_boxes(n, 0); // 下标为1表示拥有\n\n        queue<int> qu;\n        for (auto num : initialBoxes)\n        {\n            qu.push(num);\n            //visited[num] = 1;\n            valid_boxes[num] = 1;// 初始就有的\n        }\n        while (!qu.empty())\n        {\n            auto idx = qu.front();\n            qu.pop();\n            if (visited[idx])\n            {\n                continue;\n            }\n\n            if (valid_boxes[idx] == 1 && (status[idx] == 1 || valid_keys[idx] == 1))\n            {\n                visited[idx] = 1;\n                max_candies += candies[idx];\n\n                // 多了些钥匙\n                for(auto key : keys[idx])\n                {\n                    valid_keys[key] = 1;\n                    qu.push(key);\n                }\n                // 多了些盒子\n                for (auto box : containedBoxes[idx])\n                {\n                    if (!visited[box])\n                    {\n                        valid_boxes[box] = 1;\n                        qu.push(box);\n                    }\n                }\n            }\n        }\n\n        return max_candies;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1499914795","body":"```c++\n// 利用先序dfs+map\nclass Solution {\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        if (!root)\n        {\n            return {};\n        }\n\n        map<int, vector<NodeData>> vertical_node_map; // key是纵坐标，值是该纵坐标上的横坐标和节点值\n        preOrder(root, 0, 0, vertical_node_map);\n        \n        // 排序并输出\n        for (auto& pair : vertical_node_map)\n        {\n            if (!pair.second.empty())\n            {\n                std::sort(pair.second.begin(), pair.second.end(), [](NodeData& n1, NodeData& n2)\n                {\n                    if (n1.row < n2.row)\n                    {\n                        return true;\n                    }\n                    if (n1.row > n2.row)\n                    {\n                        return false;\n                    }\n                    return n1.val < n2.val;\n                });\n            }\n        }\n\n        vector<vector<int>> res;\n        for (auto& pair : vertical_node_map)\n        {\n            if (!pair.second.empty())\n            {\n                vector<int> tmp;\n                for (auto& node : pair.second)\n                {\n                    tmp.push_back(node.val);\n                }\n                res.push_back(std::move(tmp));\n            }\n        }\n\n        return res;\n    }\n\nprivate:\n    struct NodeData\n    {\n        int row;\n        int val;\n    };\n\n    void preOrder(TreeNode* root, int row, int col, map<int, vector<NodeData>>& vertical_node_map)\n    {\n        if (!root)\n        {\n            return;\n        }\n\n        NodeData data{row, root->val};\n        vertical_node_map[col].push_back(std::move(data));\n        preOrder(root->left, row + 1, col - 1, vertical_node_map);\n        preOrder(root->right, row + 1, col + 1, vertical_node_map);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500898438","body":"```c++\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n = cost.size();\n        vector<int> dp(n, 0);\n        for (int i = 2;  i < n; ++i)\n        {\n            dp[i] = std::min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n        }\n\n        return std::min(dp[n - 1] + cost[n - 1], dp[n - 2] + cost[n - 2]);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501082984","body":"```c++\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        if (nums.size() == 1) {\n            return nums[0];\n        }\n        \n        //dp[i]表示抢到第i个房子时最多能掠夺的数量\n        vector<int> dp(nums.size(), 0);\n        dp[0] = nums[0];\n        dp[1] = nums[1] > nums[0] ? nums[1] : nums[0];\n        \n        for (int i = 2; i < nums.size(); i++) {\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\n        }\n        \n        return dp.back();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501835808","body":"```c++\nclass Solution {\npublic:\n    int findNumberOfLIS(vector<int>& nums) {\n        // 直接求个数不好求，因为最长递增子序列的长度都没确定\n        // 那就先求最长递增子序列的长度，再求最大长度的过程中可以累计这个最长长度是由哪些前置来完成的，就可以记录出个数\n        if (nums.empty())\n        {\n            return 0;\n        }\n        int n = nums.size();\n        vector<int> dp(n + 1, 0); // dp[i]表示以i结尾的最长递增子序列长度\n        vector<int> cpy_nums(1, INT_MIN);\n        vector<int> max_cnt_dp(n + 1, 0); // max_cnt_dp[i]表示以i结尾的最大递增子序列的种数\n        max_cnt_dp[0] = 1;\n        for (auto num : nums)\n        {\n            cpy_nums.push_back(num);\n        }\n        // 递推\n        int total_max_length = 0;\n        for (int i = 1; i <= n; ++i)\n        {\n            int max_length = 0;\n            int max_length_cnt = 0;\n            for (int j = 0; j < i; ++j)\n            {\n                if (cpy_nums[i] <= cpy_nums[j]) // 未构成一个升序\n                {\n                    continue;\n                }\n                // 升序\n                int tmp = dp[j] + 1;// dp[i]至少有这个长度\n                if (tmp > max_length) // 最大长度超过已有的\n                {\n                    max_length = tmp;\n                    max_length_cnt = max_cnt_dp[j];\n                    total_max_length = std::max(total_max_length, max_length);\n                    dp[i] = tmp;\n                }\n                else if (tmp == max_length)\n                {\n                    max_length_cnt += max_cnt_dp[j];\n                }\n            }\n            max_cnt_dp[i] = max_length_cnt;\n        }\n\n        int res = 0;\n        for (int i = 0; i <= n; ++i)\n        {\n            if (dp[i] == total_max_length)\n            {\n                res += max_cnt_dp[i];\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1503372984","body":"```c++\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int n = text1.size();\n        int m = text2.size();\n\n        //dp数组\n        vector<vector<int>> dp(n, vector<int>(m, 0)); // dp[i][j]表示test1[0..i]和test2[0...j]的最长公共子序列长度\n        // 初始化\n        dp[0][0] = text1[0] == text2[0] ? 1 : 0;\n        for (int i = 1; i < n; ++i)\n        {\n            if (text1[i] == text2[0])\n            {\n                dp[i][0] = 1;\n            }\n            else\n            {\n                dp[i][0] = dp[i - 1][0];\n            }\n        }\n        for (int i = 1; i < m; ++i)\n        {\n            if (text1[0] == text2[i])\n            {\n                dp[0][i] = 1;\n            }\n            else\n            {\n                dp[0][i] = dp[0][i - 1];\n            }\n        }\n\n        // 递推\n        for (int i = 1; i < n; ++i)\n        {\n            for (int j = 1; j < m; ++j)\n            {\n                if (text1[i] == text2[j]) // 相同时，说明子序列可以在前面的子问题基础上+1\n                {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                }\n                else// 不相同，则取大的\n                {\n                    dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        return dp[n - 1][m - 1];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1504662501","body":"```c++\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        // 动态规划\n        vector<int> dp(n, 1);\n        for (int i = 1; i < m; ++i)\n        {\n            for (int j = 0; j < n; ++j)\n            {\n                if (j == 0)\n                {\n                    dp[j] = 1;\n                }\n                else\n                {\n                    dp[j] = dp[j - 1] + dp[j];\n                }\n            }\n        }\n\n        return dp[n - 1];\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1508111495","body":"```c++\nclass Solution {\npublic:\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (maxChoosableInteger >= desiredTotal)\n        {\n            return true;\n        }\n        if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal)\n        {\n            return false;\n        }\n\n        return dfs(maxChoosableInteger, 0, desiredTotal, 0);\n    }\n\nprivate:\n    bool dfs(int maxChoosableInteger, int usedNumbers/*每一位表示是否被使用过*/, int desiredTotal, int tmp_total)\n    {\n        if (mem_map.find(usedNumbers) == mem_map.end())\n        {\n            int res = false;\n            for (int i = 1; i <= maxChoosableInteger; ++i)\n            {\n                if ((usedNumbers & (1 << i)) == 0) // i还没被用过，&优先级比==低，所以括号不能省\n                {\n                    if (tmp_total + i >= desiredTotal)\n                    {\n                        res = true;\n                        break;\n                    }\n                    // 如果选了i还不能直接赢，就判断一下A这次选了i之后，B会不会输，如果B会输，那就A赢\n                    if (!dfs(maxChoosableInteger, usedNumbers | (1 << i), desiredTotal, tmp_total + i))\n                    {\n                        res = true;\n                        break;\n                    }\n                }\n            }\n            mem_map[usedNumbers] = res;\n        }\n        return mem_map[usedNumbers];\n    }\n\nprivate:\n    unordered_map<int, bool> mem_map;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510063588","body":"```c++\nclass Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        // dp[i][j]表示由前i个数凑成和j的种数\n        // dp[i][j]就等于前i-1个数凑成和为j+nums[i]和j-nums[i]的种数之和\n        // 因为j可能是负数，所以数组下标不合适，改成用map试试\n        int n = nums.size();\n        map<pair<int, int>, int> dp_map1; //(i,j) -> cnt\n        dp_map1[make_pair(1, nums[0])] += 1;\n        dp_map1[make_pair(1, 0 - nums[0])] += 1;\n        map<pair<int, int>, int> dp_map2;\n\n        for (int i = 2; i <= n; ++i)\n        {\n            for (auto& num_cnt : dp_map1)\n            {\n                dp_map2[make_pair(i, num_cnt.first.second + nums[i - 1])] += num_cnt.second;\n                dp_map2[make_pair(i, num_cnt.first.second - nums[i - 1])] += num_cnt.second;\n            }\n            dp_map1 = dp_map2;\n            dp_map2.clear();\n        }\n\n        return dp_map1[make_pair(n, target)];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1510709813","body":"```c++\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        // dp[i][j]表示前i种零钱兑换成面额j的最小种数\n        // 滚动数组优化\n        int n = coins.size();\n        vector<int> dp(amount + 1, amount + 1);\n        dp[0] = 0;\n        \n        for (int i = 1; i <= n; ++i)\n        {\n            for (int j = 1; j <= amount; ++j)\n            {\n                if (j >= coins[i - 1]) //可以选\n                {\n                    // 可以选但不一定非要选，还是要比较\n                    dp[j] = std::min(dp[j], dp[j - coins[i - 1]] + 1);\n                }\n                else\n                {\n                    // 不可以选\n                    dp[j] = dp[j];\n                }\n            }\n        }\n\n        return dp[amount] == amount + 1 ? -1 : dp[amount];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1512978082","body":"```c++\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        vector<int> dp(amount + 1, 0);\n        dp[0] = 1;// 0有一种实现方式\n        for (auto coin : coins)\n        {\n            for (int i = 1; i <= amount; ++i)\n            {\n                if (i >= coin)\n                {\n                    dp[i] += dp[i - coin];\n                }\n            }\n        }\n        return dp[amount];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514616490","body":"```c++\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        // 先排个序\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n\n        // 双指针\n        int child_idx = 0, candy_idx = 0;\n        int n = g.size(), m = s.size();\n        while (child_idx < n && candy_idx < m)\n        {\n            if (s[candy_idx] >= g[child_idx])\n            {\n                candy_idx++;\n                child_idx++;\n            }\n            else\n            {\n                candy_idx++;\n            }\n        }\n\n        return child_idx;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1516317588","body":"```c++\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        // 贪心\n        std::sort(intervals.begin(), intervals.end(), [](vector<int>& v1, vector<int>& v2)\n        { return v1[1] < v2[1]; });\n\n        int ans = 1;\n        int right = intervals[0][1];\n        int n =intervals.size();\n        for (int i = 1; i < n; ++i)\n        {\n            if (intervals[i][0] >= right)\n            {\n                ans++;\n                right = intervals[i][1];\n            }\n        }\n\n        return n - ans;\n    }\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1520076978","body":"```c++\nclass Solution {\npublic:\n    vector<int> beautifulArray(int n) {\n        // 数学性质，挺难想的，记录一下吧\n        // 如果[i, j, k]是漂亮数组，那么[t*i + b, t*j + b, t * k +b]也是漂亮数组\n        vector<vector<int>> dp(n + 1, vector<int>());\n        dp[1] = {1};\n        for (int i = 2; i <= n; ++i)\n        {\n            int left_num = (i + 1) / 2;\n            int right_num = i / 2;\n            for (auto num : dp[left_num])\n            {\n                dp[i].push_back(2 * num - 1);\n            }\n            for (auto num : dp[right_num])\n            {\n                dp[i].push_back(2 * num);\n            }\n        }\n\n        return dp[n];\n    }\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1528929273","body":"```c++\nclass Solution {\npublic:\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        int n = isConnected.size();\n        // 初始化并查集\n        parent_map_.clear();\n        for (int i = 0; i < n; ++i)\n        {\n            parent_map_[i + 1] = i + 1;\n        }\n\n        for (int i = 0; i < n; ++i)\n        {\n            for (int j = i + 1; j < n; ++j)\n            {\n                if (isConnected[i][j] == 1)\n                {\n                    if (find(i + 1) != find(j + 1))\n                    {\n                        union_map(i + 1, j + 1);\n                    }\n                }\n            }\n        }\n\n        set<int> res_set;\n        for (auto& pair : parent_map_)\n        {\n            if (res_set.count(pair.second) == 0)\n            {\n                res_set.insert(pair.second);\n            }\n        }\n\n        return res_set.size();\n    }\n\nprivate:\n    // 并查集\n    int find(int node)\n    {\n        if (parent_map_[node] != node)\n        {\n            parent_map_[node] = find(parent_map_[node]);\n        }\n        return parent_map_[node];\n    }\n\n    void union_map(int node1, int node2)\n    {\n        if (find(node1) == find(node2))\n        {\n            return;\n        }\n        int parent_1 = find(node1);\n        int parent_2 = find(node2);\n        if (parent_1 < parent_2)\n        {\n            parent_map_[parent_2] = parent_1;\n            for (auto& pair : parent_map_)\n            {\n                if (pair.second == parent_2)\n                {\n                    pair.second = parent_1;\n                }\n            }\n        }\n        else\n        {\n            parent_map_[parent_1] = parent_2;\n            for (auto& pair : parent_map_)\n            {\n                if (pair.second == parent_1)\n                {\n                    pair.second = parent_2;\n                }\n            }\n        }\n    }\n\nprivate:\n    map<int, int> parent_map_;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1529503812","body":"```c++\nclass Solution {\npublic:\n    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {\n        // 先并查集找出有几个连通分量\n        parent_map_.clear();\n        int n = graph.size();\n        for (int i = 0; i < n; ++i)\n        {\n            parent_map_[i] = i;\n        }\n        for (int i = 0; i < n; ++i)\n        {\n            for (int j = i + 1; j < n; ++j)\n            {\n                if (graph[i][j] == 1)\n                {\n                    union_map(i, j);\n                }\n            }\n        }\n\n        // 求每个联通分量的个数\n        map<int, int> size_map;\n        for (auto& pair : parent_map_)\n        {\n            size_map[pair.second]++;\n        }\n\n        // 处理initial\n        int m = initial.size();\n        vector<int> visited(n, 0);\n        for(int i = 0; i < m; ++i)\n        {\n            int parent = find(initial[i]);\n            visited[parent]++;\n        }\n        int max_num = -1;\n        int ans = -1;\n        for (int i = 0; i < m; ++i)\n        {\n            int parent = find(initial[i]);\n            if (visited[parent] == 1)\n            {\n                if (size_map[parent] > max_num)\n                {\n                    max_num = size_map[parent];\n                    ans = initial[i];\n                }\n                else if (size_map[parent] == max_num && initial[i] < ans)\n                {\n                    ans = initial[i];\n                }\n               //cout << \"i:\" << i << \",max_num:\" << max_num << endl;\n            }\n        }\n        if (ans == -1)\n        {\n            ans = INT_MAX;\n            for (auto num : initial)\n            {\n                ans = std::min(ans, num);\n            }\n        }\n\n        return ans;\n    }\n\n// 继续练习写并查集\nprivate:\n    int find(int node)\n    {\n        if (node != parent_map_[node])\n        {\n            parent_map_[node] = find(parent_map_[node]);\n        }\n        return parent_map_[node];\n    }\n\n    void union_map(int node1, int node2)\n    {\n        if (find(node1) == find(node2))\n        {\n            return;\n        }\n\n        int parent_1 = find(node1);\n        int parent_2 = find(node2);\n        if (parent_1 < parent_2)\n        {\n            parent_map_[parent_2] = parent_1;\n            // for(auto& pair : parent_map_)\n            // {\n            //     if (pair.second == parent_2)\n            //     {\n            //         pair.second = parent_1;\n            //     }\n            // }\n        }\n        else\n        {\n            parent_map_[parent_1] = parent_2;\n            // for(auto& pair : parent_map_)\n            // {\n            //     if (pair.second == parent_1)\n            //     {\n            //         pair.second = parent_2;\n            //     }\n            // }\n        }\n    }\nprivate:\n    map<int, int> parent_map_;// 并查集的代表map\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1532740739","body":"```c++\nclass Solution {\npublic:\n    TreeNode* pruneTree(TreeNode* root) {\n        // 利用后序，先处理左右子树\n        // 如果左子树全是0，left=null\n        // 如果右子树全是0, right=null\n        bool all_zero = postOrder(root);\n        if (all_zero)\n        {\n            return nullptr;\n        }\n\n        return root;\n    }\n\nprivate:\n    bool postOrder(TreeNode* root)\n    {\n        if (!root)\n        {\n            return true;\n        }\n\n        bool left_all_zero = postOrder(root->left);\n        bool right_all_zero = postOrder(root->right);\n\n        if (left_all_zero)\n        {\n            root->left = nullptr;\n        }\n        if (right_all_zero)\n        {\n            root->right = nullptr;\n        }\n\n        return left_all_zero && right_all_zero && root->val == 0;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1534399628","body":"```c++\nclass Solution {\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        vector<vector<int>> res;\n        vector<int> tmp;\n        // 在回溯的方法最后添加一个start_idx参数，保证在循环中不走回头路，这样就能保证答案不重复了\n        // 不再需要额外使用排序和set来去重，更方便\n        backTrace(candidates, target, tmp, res, 0, 0);\n\n        return res;\n    }\n\nprivate:\n    void backTrace(vector<int>& candidates, int target, vector<int>& tmp, vector<vector<int>>& res, int sum, int start_idx)\n    {\n        if (sum == target)\n        {\n            res.push_back(tmp);\n            return;\n        }\n        if (sum > target)\n        {\n            return;\n        }\n\n        int n = candidates.size();\n        for (int i = start_idx; i < n; ++i)\n        {\n            tmp.push_back(candidates[i]);\n            sum += candidates[i];\n            backTrace(candidates, target, tmp, res, sum, i);\n            sum -= candidates[i];\n            tmp.pop_back();\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1535819020","body":"```c++\nclass Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        set<vector<int>> res_set;\n        vector<int> tmp;\n        sort(candidates.begin(), candidates.end());\n        backTrace(candidates, target, res_set, tmp, 0);\n\n        return vector<vector<int>>(res_set.begin(), res_set.end());\n    }\nprivate:\n    void backTrace(vector<int>& candidates, int target, set<vector<int>>& res_set, vector<int>& tmp, int start_idx)\n    {\n        if (target == 0)\n        {\n            vector<int> tmp_1(tmp);\n            sort(tmp_1.begin(), tmp_1.end());\n            res_set.insert(tmp_1);\n            return;\n        }\n\n        int n = candidates.size();\n        for (int i = start_idx; i < n; ++i)\n        {\n            if (i > start_idx && candidates[i] == candidates[i - 1]) {\n                continue;\n            }\n            if (target >= candidates[i])\n            {\n                tmp.push_back(candidates[i]);\n                backTrace(candidates, target - candidates[i], res_set, tmp, i + 1);\n                tmp.pop_back();\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null],"diana21170648":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/56#issuecomment-1495942386","body":"### 思路\n深度优先遍历\n### py代码\n```\n# 生成一个4行3列的包含 0 和 1 的非空二维数组 grid\ngrid = [[1, 1, 0],\n        [1, 0, 1],\n        [0, 1, 1],\n        [1, 0, 0]]\n\n# 定义DFS函数，用于搜索岛屿面积\ndef dfs(grid, i, j):\n    # 判断当前位置是否越界或者已经搜索过\n    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n        return 0\n    # 将当前位置标记为已搜索\n    grid[i][j] = 0\n    # 继续搜索上下左右四个方向\n    area = 1\n    area += dfs(grid, i-1, j)\n    area += dfs(grid, i+1, j)\n    area += dfs(grid, i, j-1)\n    area += dfs(grid, i, j+1)\n    return area\n\n# 遍历整个二维数组，找到最大的岛屿面积\nmax_area = 0\nfor i in range(len(grid)):\n    for j in range(len(grid[0])):\n        if grid[i][j] == 1:\n            area = dfs(grid, i, j)\n            max_area = max(max_area, area)\n\n# 输出最大的岛屿面积\nprint(max_area)\n\n**复杂度分析**\n- 时间复杂度：O(r*c)\n- 空间复杂度：O(r*c)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/57#issuecomment-1497338398","body":"### 思路\nBFS广度优先搜索算法\n\n### 代码\n```python\n# bfs广度优先搜索算法\n# 定义一个函数，用于找到海洋单元格到最近陆地单元格的最大曼哈顿距离\nfrom turtle import distance\ngrid = [[1, 0, 1],\n        [0, 0, 0],\n        [1, 0, 1]]\n\ndef max_distance(grid):\n    # 定义四个方向的偏移量\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    # 定义一个队列，用于存储陆地单元格\n    queue = []\n    # 将所有陆地单元格加入队列，并将其标记为已访问\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                queue.append((i, j))\n                grid[i][j] = -1\n    # 如果没有陆地单元格或者没有海洋单元格，返回-1\n    if len(queue) == 0 or len(queue) == len(grid) * len(grid[0]):\n        return -1\n    # 定义一个变量，用于记录曼哈顿距离\n    distance = 0\n    # 不断从队列中取出陆地单元格，并将其周围的海洋单元格加入队列\n    while queue:\n        size = len(queue)\n        for i in range(size):\n            x, y = queue.pop(0)\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                # 如果新的位置越界或者已经访问过，跳过\n                if nx < 0 or nx >= len(grid) or ny < 0 or ny >= len(grid[0]) or grid[nx][ny] != 0:\n                    continue\n                # 将新的位置标记为已访问，并将其加入队列\n                grid[nx][ny] = grid[x][y] - 1\n                queue.append((nx, ny))\n        # 每遍历一圈，曼哈顿距离加1\n        distance += 1\n    # 返回曼哈顿距离的最大值\n    return distance\n# 输出地图最大距离\nprint(distance)\n\n\n**复杂度分析**\n- 时间复杂度：O(N^2)，每个点最多被处理一次\n- 空间复杂度：O(N^2)，使用队列，队列最大长度为N^2","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/58#issuecomment-1499062094","body":"### 思路\nBFS\n\n### 代码\n\n\n```python\nclass Solution:\n    def maximum_candies(self, status: list[int], candies: list[int], keys: list[list[int]], containedBoxes: list[list[int]], initialBoxes : list[int]) -> int :\n          boxes = set(initialBoxes)\n          queue = [i for i in boxes if status[i]]\n         for i in queue:\n              for j in containedBoxes[i]:\n                   boxes.add(j)\n                      if status[j]:\n                      queue.append(j)\n                      for j in keys[i]:\n                           if status[j] == 0 and j in boxes:\n                              queue.append(j)\n                           status[j] = 1\n                          return sum(candies[i] for i in queue)\nprint(sum)\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/59#issuecomment-1500262417","body":"### 思路\n哈希表，BFS\n\n### 代码\n```python\nimport collections\nclass Solution:\n    def solve(self,root):\n        q = collections.deque([(root,0)])\n        d={}\n        while q:\n            current,posotion=q.popleft()\n            if posotion  not in d:\n                d[posotion]=current.value\n                if current.left:\n                    q.append(current,posotion-1)\n                if current.right:\n                    q.append(current.right,posotion+1)\n        return list(map(lambda x:x[1],sorted(d.items(),key=lambda x:x[0])))\n\n\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/60#issuecomment-1500895078","body":"### 思路\n动态规划\n\n### 代码\n```python\nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        dp = [0] * (len(cost)+1)\n        dp[0], dp[1] = cost[0], cost[1]\n        for i in range(2, len(cost)+1):\n            dp[i] = min(dp[i-1], dp[i-2]) + (cost[i] if i != len(cost) else 0)\n        return dp[-1]\n\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/61#issuecomment-1501033460","body":"### 思路\n动态规划\n\n### 代码\nclass Solution:\n    def robmaxmoneys(self, robnums:list[int]) -> int:\n\n       # dp=[0]*(len(robnums)+1)\n        if not robnums :\n            return 0\n        length=len(robnums)\n        if length==1:\n            return robnums[0]\n        else:\n            previous=robnums[0]\n            current=max(previous,robnums[1])\n            for i in range(2, length):\n            #dp[i] = max(previous+num[i], current) ,current)\n                previous,current= max(previous+robnums[i], current) ,current\n        #return dp[-1]\n        return current\n\n```python\n（此处撰写代码）\n\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)，只需要保存current和previous","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/62#issuecomment-1501587202","body":"### 思路\n动态规划\n\n### 代码\n```python\nclass Slution:\n    def findnumsofLIS(self,nums:list[int]) -> int:\n        n=len(nums)\n        #dp[i][0]存储最长上升子序列的长度\n        #dp[i][1]存储最长上升子序列的个数\n        dp=[[1,1] for i in range(n)]\n        ans=[1,1]\n        longest=1\n        for i in range(n):\n            for j in  range(i+1,n):\n                #考虑两种情况，一种是字符串更长，一种是字符串一样长，个数需要加一\n                if nums[j]>nums[i]:\n                    if dp[i][0]+1>dp[j][0]:\n                        dp[j][0]=dp[i][0]+1\n                        dp[j][1]=dp[i][1]\n                        longest=max(longest,dp[j][0])\n                    elif dp[i][0]+1==dp[j][0]:\n                        dp[j][1] += dp[i][1]\n                        return sum(dp[i][1] for i in  range(n) if dp[i][0]==longest)\n\n\n**复杂度分析**\n- 时间复杂度：O(N^2)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/63#issuecomment-1503014513","body":"### 思路\n动态规划+数组\n\n```python\nclass Slution:\n    def longestseries(self,text1:str,text2:str)-> int:\n        m,n=len(text1),len(text2)\n        ans=0\n        #定义动态规划的数组\n        dp=[[0 for _ in range(n+1)]for _ in range(m+1)]\n        for i in range (1,m+1):\n            for j in  range (1,n+1):\n                if text1[i-1]==text2[j-1]:\n                    dp[i][j]=dp[i-1][j-1]+1\n                    #判断序列是否更长\n                    ans=max(ans,dp[i][j])\n                else:\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1])\n                    return ans\n\n**复杂度分析**\n- 时间复杂度：O(m*n)，其中 m，n 为数组长度，双重循环\n- 空间复杂度：O(m*n)，相当于二维数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/64#issuecomment-1504526807","body":"### 思路\n二维动态规划，排列组合\n\n```python\nclass Slution:\n    def uniquepaths(self,m:int,n:int)->int:\n        dp=1*[n]\n        for _ in range(1,m):\n            for j in  range(1,n):\n                dp=dp[j-1]\n                return dp[n-1]\n\n\n**复杂度分析**\n- 时间复杂度：O(m*n)，双重循环\n- 空间复杂度：O(n)，只考虑上面和左边的元素","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/65#issuecomment-1506489528","body":"### 思路\n动态规划+三维数组\n\n```python\nclass Slution:\n    def knightprobability(self,n:int,k:int,row:int,column:int)->float:\n        delta=[(-2,1),(-2,-1),(-1,2),(-1,-2),(1,2),(1,-2),(2,-1),(2,1)]\n        dp=[[[0]*(k+1)for _ in  range(n)] for _ in  range(n)]\n        for i in range(n):\n            for j in range(n):\n                dp[i][j][0] = 1\n                for step in range(1,K+1):\n                    for i in range(n):\n                        for j in range(n):\n                            if step==0:\n                                dp[i][j][0]=1\n                            else:\n                                for dx,dy in delta:\n                                    x,y=i+dx,j+dy\n                                    if n>x>=0 and n>y>=0:\n                                        dp[i][j][step]+=dp[i][j][step-1]*0.125\n                                        return dp[row][column][k]\n\n\n**复杂度分析**\n- 时间复杂度：O(kN^2)，其中 N为棋盘的大小。\n- 空间复杂度：O(kN^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/66#issuecomment-1507853719","body":"### 思路\n动态规划+位移运算状态压缩\n\n```python\nclass Slution:\n    def caniwin(self,max:int,total:int)->bool:\n        #第一种特殊情况\n        if max>=total:\n            return True #谁第一个选谁赢\n        #第二种特殊情况\n        if sum(range(max+1))<=total:\n            return False #求和都不会大于给定值，两个人都不可能赢\n    #进行位移运算，状态压缩\n    def dp(self, picked, accelerate, total:int):\n        if accelerate>=total:\n            if picked==(1<<(max+1))-1:\n                return False\n            for n in range(1,max+1):\n                if picked & 1<<n==0:\n                    #如果没有被选择，且会超过total，则现在选择的玩家赢\n                    if not dp(picked| 1<<n,accelerate+n):\n                        return True\n                    return False\n                return dp(0,0)\n\n**复杂度分析**\n- 时间复杂度：O(max*N)，其中 N 为节点数。\n- 空间复杂度：O(2^N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/67#issuecomment-1509824415","body":"### 思路\n动态规划，背包问题，也可用dfs求解\n\n```python\nclass Slution:\n    def equalsubsetsum(self,nums:list[int])->bool:\n        target=sum(nums)//2\n        if target+target != sum(nums):\n            return False\n        dp=[False]*(target+1)\n        dp[0]=True\n        for i in range(1,len(nums)+1):\n            for j in range(target,0,-1):\n                if dp[j] or (j-nums[i-1]>-1 and dp[j-nums[i-1]]):#如果正好在背包里面\n                    dp[j]=True\n                    return dp[-1]\n\n**复杂度分析**\n- 时间复杂度：O(m*n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/68#issuecomment-1510214064","body":"### 思路\n动态规划（背包），滚动数组优化\n\n```python\nclass Slution:\n    def findtargetsumways(self,nums,target)->bool:\n        t=sum(nums)+target\n        if t%2:\n            return 0\n        t=t//2\n        dp=[0]*(t+1)\n        dp[0]=1\n        for i in range(len(nums)):\n            for j in range(t,num[i]-1,-1):\n                dp[j]+=dp[j-nums[i]]\n                return dp[-1]\n\n**复杂度分析**\n- 时间复杂度：O(M*N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/69#issuecomment-1510647183","body":"### 思路\n动态规划，背包，取最小值，则dp、初始化为max_value,dp[0]=0\n\n```python\nclass Solution:\n    def coinschange(self,coins,amount)->int:\n        dp = [amount + 1] * (amount + 1)#取左不取右，amount+1本来就不存在\n        dp[0] = 0\n        # 不满足组合，返回-1\n        if dp[amount]==amount+1 or dp[amount]:\n            return -1\n\n        for i in range(1,amount+1):\n            for j in range(coins):\n                if i>=coins:\n                    dp[i]=min(dp[i],dp[i-j]+1)#总数大于面值，更新最小硬币的值，使得用的硬币数量最少\n                    return dp[amount]#满足最小硬币个数，返回硬币个数\n\n**复杂度分析**\n- 时间复杂度：O(N*amount)，其中 N 为硬币种类。\n- 空间复杂度：O(amount)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1512585303","body":"### 思路\n动态规划，背包，求最大组合数，dp初始化为0，dp[0]=1\n\n```python\nclass Solution:\n    def coinchange2(self,amount,coins)->int:\n        dp=[0]*(amount+1)\n        dp[0]=1\n        for i in range(len(coins)-1,-1,-1):\n            for j in range (1,amount+1):\n\n                if j >= coins[i]:\n                    dp[j]+=dp[j-coins[i]]\n                    return dp[amount]\n\nSolution().coinchange2()\n\n\n**复杂度分析**\n- 时间复杂度：O(nums(coins)*amount)，其中 N 为数组长度。\n- 空间复杂度：O(amount)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514070922","body":"### 思路\n贪心，先用一个饼干遍历最小胃口的孩子，满足不了，更换饼干，满足最小孩子的胃口，换下一个孩子\n\n```python\nclass Solution:\n    def assigncookies(self,gi,Sj)->int:\n        Sj.sort#倒序排列,饼干大小\n        gi.sort#孩子胃口大小\n        S,g=0,0\n        count=0\n\n        while S<len(Sj) :#遍历所有饼干\n            while g<len(gi):#孩子\n                if Sj[S]<gi[g]:#饼干的大小不bu满足最小孩子的胃口\n                    S+=1\n                else:\n                    count+=1\n                    S+=1\n                break\n                g+=1   \n        return count\nSolution().assigncookies([1,2,3],[1,2])\n\n**复杂度分析**\n- 时间复杂度：O(NlogN)，使用了排序。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/72#issuecomment-1515804591","body":"### 思路\n贪心+二分，比较后一个的开始与前一个的结束，如果递增，直接补在后面，如果在中间，插入更长的\n\n```python\nimport bisect\nclass Solution:\n    def lengehofLIS(self,A)->int:\n        d=[]\n        for start,end in range (A):\n            i=bisect.bisect_left(d,end)\n            if i<len(d):\n                d[i]=end\n            elif not d or i<=start:\n                d.append(end)\n        return len(d)\n    def nonoverlappingintervals(self,intervals)->int:\n        n=len(intervals)\n        if n==0:\n            return 0\n        ans=1\n        intervals.sort(key=lambda a:a[0])\n        return n-self.lengehofLIS(intervals)\n\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中使用了排序。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/73#issuecomment-1517174563","body":"### 思路\n贪心，只需要记录和更新所能达到的最大索引，能到达某个位置，证明左边的位置都能到达，尝试怎么样能走的最远，并考虑到达最后位置或者超过最后位置都为真的情况\n\n```python\nfrom typing import List\nclass Solution:\n    def jumpgames(self,A:List[int])->bool:\n        _max=0\n        n=len(A)\n        for i in range (n):\n            if _max<i:\n                return False\n            _max=max(_max,A[i]+i)\n            if _max>=i:\n                return True\n        return _max>=n-1#return 和for对齐，不能和def对齐\nSolution().jumpgames([2,3,1,1,4])\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/74#issuecomment-1518461597","body":"### 思路\n分治\n\n```python\nclass Solution:\n    visited = dict()\n\ndef numTrees(self, n: int) -> int:\n     if nin self. Visited:\n         return self.visited.get(n)\n     if n <= 1:\n        return 1\n     res = 0\n     for iin range(1, n + 1):\n            res += self.numTrees(i - 1) * self.numTrees(n - i)\n      self. Visited[n] = res\n      return res\n\n\n**复杂度分析**\n- 时间复杂度：O(N^2)，。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/75#issuecomment-1518926722","body":"### 思路\n分治，归并排序，链表\n\n```python\nclass Solution:\n        def  mergeKLists(self, lists: List[ListNode]) -> ListNode:\n               n = len(lists)\n\n              # basic cases\n             if lenth == 0:\n                    return None\n            if lenth == 1:\n                  return lists[0]\n            if lenth == 2:\n                 return self.mergeTwoLists(lists[0], lists[1])\n\n         # divide and conqure if not basic cases\n                  mid = n // 2\n                     return self.mergeTwoLists(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:n]))\n\n\n       def  mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n              res = ListNode(0)\n             c1, c2, c3 = l1, l2, res\n             while c1or c2:\n                if c1and c2:\n                if c1.val < c2.val:\n                    c3.next = ListNode(c1.val)\n                    c1 = c1.next\n               else:\n                    c3.next = ListNode(c2.val)\n                    c2 = c2.next\n                   c3 = c3.next\n             elif c1:\n                c3.next = c1\n                break\n            else:\n                c3.next = c2\n               break\n\n          return res.next\n\n\n**复杂度分析**\n- 时间复杂度：O(kn*logk)，其中 N 为数组长度。\n- 空间复杂度：O(logk)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1520018940","body":"### 思路\r\n分治，分为偶数和奇数，再合到一起，奇数=偶数，或者奇数数量比偶数多一个\r\n\r\n```python\r\nfrom typing import List\r\n2\tclass Solution:\r\n3\t    def beautifulArray(self, N: int) -> List[int]:\r\n4\t      \r\n5\t        def dp(n):\r\n6\t            if n == 1:\r\n7\t                return [1]\r\n8\t            ans = []\r\n9\t            # [1,n] 中奇数比偶数多1或一样\r\n10\t            for a in dp(n - n // 2):\r\n11\t                ans += [a * 2 - 1]\r\n12\t            for b in dp(n // 2):\r\n13\t                ans += [b * 2]\r\n14\t            return ans\r\n15\t\r\n16\t        return dp(N)\r\n17\tSolution().beautifulArray(5)\r\n\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(nlogn)，有排序。\r\n- 空间复杂度：O(n+logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/77#issuecomment-1521033145","body":"### 思路\n异或，有1则为1\n\n```python\n#T=O(N)\n14\t#S=0(1)\n15\t\n16\tfrom typing import List\n17\tclass Solution:\n18\t    def singleNumber(self, nums: List[int]) -> List[int]:\n19\t        xor=a=b=0\n20\t        right_bit=1\n21\t        n=len(nums)\n22\t        for i in nums:\n23\t            xor^=i\n24\t        while right_bit & xor==0:\n25\t            right_bit<<=1\n26\t        for i in nums:\n27\t            if right_bit & i:\n28\t                a^=i\n29\t            else:\n30\t                b^=i\n31\t        return [a,b]\n32\t            \n33\t# 替换下方的 xxx 为主函数名， yyy 为测试用例参数开启调试\n34\tSolution().singleNumber([1,2,1,3,2,5])\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/78#issuecomment-1522710621","body":"### 思路\n位运算\n\n```python\nfrom typing import List\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        res,end=[],1<<len(nums)\n        n=len(nums)\n        for sign in range(end):\n            subset=[]\n            for i in range(n):\n                if ((1<<i)&sign) !=0:#用于判断整数的二进制的某一位是否为1\n                   subset.append(nums[i])\n            res.append(subset)\n        return res\nSolution().subsets( [1,2,3])\n\n**复杂度分析**\n- 时间复杂度：O(N*2^N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1524477944","body":"### 思路\n手敲实现前缀树Trie\n\n```python\nclass TrieNode:\n    def __init__(self):\n        self.count=0\n        self.precount=0\n        self.children={}\n\nclass Trie:\n    def __init__(self):\n        self.root=TrieNode()\n\n    def insert(self, word: str) -> None:\n        node=self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch]=TrieNode()\n            node=node.children[ch]\n            node.precount+=1\n        node.count+=1\n\n    def search(self, word: str) -> bool:\n        node=self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node=node.children[ch]\n        return node.count>0\n\n    def startsWith(self, prefix: str) -> bool:\n        node=self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node=node.children[ch]\n        return node.precount>0\n\n**复杂度分析**\n- 时间复杂度：O(1)，创建前缀树。\n- 空间复杂度：O(字符集的长度*单词的总字符数)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1526851692","body":"### 思路\n前缀树\n\n```python\nclass MapSum:\n\n    def __init__(self):\n        self.m={}\n\n    def insert(self, key: str, val: int) -> None:\n        self.m[key]=val\n\n    def sum(self, prefix: str) -> int:\n        count=0\n        for key in self.m:\n            if key.startswith(prefix):\n                count+=self.m[key]\n        return count\n\n**复杂度分析**\n- 时间复杂度：nsert/sum:T=O(n),n为不重复的key的个数\n\n- 空间复杂度：insert:S=O(1),sum:S=O(n*s)，n为目前为止前缀key的个数，s为前缀的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/81#issuecomment-1528695880","body":"### 思路\n前缀树\n\n```python\nclass Trie:\n   def __init__(self, words):\n       self.d = {}\n       for i in range(len(words)):\n           tree = self.d\n           for char in words[i]:\n               if char not in tree:\n                   tree[char] = {}\n               tree = tree[char]\n           tree['end'] = i\n       \n   def search(self, s):\n       tree = self.d\n       res = []\n       for char in s:\n           if char not in tree:\n               return res\n           tree = tree[char]\n           if 'end' in tree:\n               res.append(tree['end'])\n       return res\n\nclass Solution:\n   def multiSearch(self, big: str, smalls: List[str]) -> List[List[int]]:\n       trie = Trie(smalls)\n       res = [[] for _ in range(len(smalls))]\n       for i in range(len(big)):\n           tmp = trie.search(big[i:])\n           for idx in tmp:\n               res[idx].append(i)\n       return res\n\n**复杂度分析**\n- 时间复杂度：T=O(n*k)，n为长句的长度，k为最长单词的长度\n- 空间复杂度：S=O(s)，匹配成功的位置的次数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/82#issuecomment-1528929729","body":"### 思路\n并查集，先搜索，再连接，如根节点不一致，则计数减一\n\n```python\nclass UF:\n    def __init__(self,n)->None:\n        self.parent={i:i for i in range(n)}#使用字典推导式构造一个字典self.parent,键和值都是从0到n-1的整数\n        self.size=n\n\n    def find(self,i):\n        if self.parent[i]!=i:\n            self.parent[i]=self.find(self.parent[i])\n        return self.parent[i]\n\n    def connect(self,i,j):\n        root_i,root_j=self.find(i),self.find(j)\n        if root_i !=root_j:\n            self.size-=1\n            self.parent[root_i]=root_j#把j作为i的根节点\n\nclass Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        n=len(isConnected)\n        uf=UF(n)\n        for i in range(n):\n            for j in range(n):\n\n                if isConnected[i][j]:\n                    uf.connect(i,j)\n        return uf.size\n\n\n**复杂度分析**\n- 时间复杂度：O(NlogN)，使用路径压缩。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/83#issuecomment-1529291191","body":"### 思路\ndfs，并查集也可做\n\n```python\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        def dfs(i):\n            nodes.add(i)\n            for j in range(len(graph[i])):\n                if graph[i][j] and j not in nodes:\n                    dfs(j)\n        rank,initial=collections.defaultdict(list),set(initial)\n        for node in sorted(initial):\n            nodes=set()\n            dfs(node)\n            if nodes&initial=={node}:\n                rank[len(nodes)].append(node)\n        return rank[max(rank)][0] if rank else min(initial)\n\n**复杂度分析**\n- 时间复杂度：O(N^2)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/84#issuecomment-1531191640","body":"### 思路\n并查集或dfs都能做\n\n```python\nclass Solution:\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        root= [i for i in range(n)]\n        def find(p):\n            while p!=root[p]:\n                root[p]=root[root[p]]\n                p=root[p]\n            return p\n        def union(p,q):\n            root[find(p)]=find(q)\n        have=0\n        for connec in connections:\n            a,b=connec\n            if find(a)!=find(b):\n               union(a,b)\n            else:\n                have+=1\n         diff_root=set()\n         for i in range(n):\n            diff_root.add(find(i))\n        return len(diff_root)-1 if have>=len(diff_root)-1 else -1\n\n**复杂度分析**\n- 时间复杂度：T=O(logx)+O（logy），使用了路径压缩\n- 空间复杂度：S=O(n)，网络中的节点个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/85#issuecomment-1532745448","body":"### 思路\n二叉树剪枝\n\n```python\nclass Solution:\n      def pruneTree(self, root):\n           def  containsOne(node):\n                 if not node:return False\n                  left = containsOne(node.left)\n                  right = containsOne(node.right)\n                  if not left: node.left = None\n                  if not right: node.right = None\n                  return node.val == 1or leftor right\n\n       return root  if containsOne(root)else None\n\n**复杂度分析**\n- 时间复杂度：O(H)，其中 H为树的深度\n- 空间复杂度：O(N),N是树节点的个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1533914975","body":"### 思路\n回溯，升序，记录位置\n\n```python\nclass Solution:\n     def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        def backtrack(ans,tempList, candidates, remain, start):\n            if remain < 0:return\n            elif remain == 0:return ans.append(tempList.copy())# 将部分解空间合并到总体的解空间\n   # 枚举所有以 i 为开始的部分解空间\n             for i in range(start, len(candidates)):\n                tempList.append(candidates[i])\n                backtrack(ans, tempList, candidates, remain - candidates[i], i)#  数字可以重复使用\n                tempList.pop()\n\n      ans = [];\n      backtrack(ans, [], candidates, target, 0);\n      return ans;\n\n\n**复杂度分析**\n- 时间复杂度：\n- 空间复杂度：","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/87#issuecomment-1536232510","body":"### 思路\n剪枝排序，需要把重复数字跳过\n\n```python\nclass Solution:\n    def backtrack(self,curc,t,len,cursum,inbegin,path,res):\n        if cursum==t:\n            res.append(path.copy())\n        for index in range(inbegin,len):\n            nextsum=cursum+curc[index]\n            if nextsum>t:\n                break\n            if index>inbegin and curc[index-1]==curc[index]:\n                continue#继续执行剪枝\n            path.append(curc[index])\n            self.backtrack(curc,t,len,nextsum,index+1,path,res)\n            path.pop()          \n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        n=len(candidates)\n        if n==0:\n            return[]\n        candidates.sort()\n        path=[]\n        res=[]\n        self.backtrack(candidates,target,n,0,0,path,res)\n        return res\n\n**复杂度分析**\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/88#issuecomment-1537102017","body":"### 思路\n回溯，考虑重复\n\n```python\nclass Solution:\n     def backtrack(numbers, pre):\n         nonlocal res\n         if len(numbers) <= 1:\n            res.append(pre + numbers)\n            return#numbers列表的长度小于等于1,则将pre和numbers中的元素连接后添加到res列表中,然后返回\n         for key, value in enumerate(numbers):\n            if value not in numbers[:key]:\n                backtrack(numbers[:key] + numbers[key + 1:], pre+[value])\n\n     res = []\n     if not len(nums):return []\n     backtrack(nums, [])\n     return res\n\n**复杂度分析**\n","onTime":true},null,null,null,null,null,null,null,null,null],"61hhh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/70#issuecomment-1513406789","body":"### 思路\ndp问题\n\n### 代码\n```java\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int[] dp = new int[amount+1];\n        dp[0] = 1;\n        for(int coin : coins){\n            for(int i=coin;i<=amount;i++){\n                dp[i]+=dp[i-coin];\n            }\n        }\n        return dp[amount];\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(coins.length * amount)，coins数组长度 * 金额。\n- 空间复杂度：O(amount)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/71#issuecomment-1514470383","body":"### 思路\n双指针 i 和 j 分别遍历两个数组\n### 代码\n```java\npublic int findContentChildren(int[] g, int[] s) {\n    Arrays.sort(g);\n    Arrays.sort(s);\n    int i = 0;\n    for (int j = 0; i < g.length && j < s.length; j++) {\n        if (g[i] <= s[j]) {\n            i++;\n        }\n    }\n    return i;\n}\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/76#issuecomment-1519490471","body":"```java\nclass Solution {\n    public int[] beautifulArray(int n) {\n        List<Integer> res = new ArrayList<>();\n        res.add(1); // 长度为1的漂亮数组是 [1]\n        while (res.size() < n) {\n            List<Integer> tmp = new ArrayList<>();\n            for (int i : res) {\n                if (i * 2 - 1 <= n) { // 将奇数乘以2后减去1，判断是否小于等于n\n                    tmp.add(i * 2 - 1);\n                }\n            }\n            for (int i : res) {\n                if (i * 2 <= n) { // 将偶数乘以2，判断是否小于等于n\n                    tmp.add(i * 2);\n                }\n            }\n            res = tmp; // 更新res\n        }\n        int[] ans = new int[n];\n        for (int i = 0; i < n; ++i) {\n            ans[i] = res.get(i);\n        }\n        return ans;\n    }\n}\n\n```\n**复杂度分析**\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/79#issuecomment-1524595774","body":"### 思路\n通过长度为26的Trie数组保存子节点状态，通过标识isEnd记录子节点是否存在叶子节点的情况\n### 代码\n```java\nclass Trie {\n    private Trie[] children;\n    private boolean isEnd;\n\n    public Trie() {\n        children = new Trie[26];// 子节点数组记录后面字符可能的26种取值\n        isEnd = false;// 根节点默认false\n    }\n\n    public void insert(String word) {\n        Trie node = this;\n\n        for (int i = 0; i < word.length(); i++) {\n            int index = word.charAt(i) - 'a';\n            if (node.children[index] == null) {\n                node.children[index] = new Trie();\n            }\n            node = node.children[index];// 节点下移\n        }\n        node.isEnd = true;// 遍历完后 最后节点设置结束标识为真\n    }\n\n    public boolean search(String word) {\n        Trie lastNode = searchPrefix(word);\n        return lastNode != null && lastNode.isEnd;\n    }\n\n    public boolean startsWith(String prefix) {\n        return searchPrefix(prefix) != null;\n    }\n\n    // 搜索前缀字符串 遍历字符串 如果存在就返回最后一个字符节点 否则返回null\n    private Trie searchPrefix(String prefix) {\n        Trie node = this;\n        for (int i = 0; i < prefix.length(); i++) {\n            int index = prefix.charAt(i) - 'a';\n            if (node.children[index] == null) {\n                return null;\n            }\n            node = node.children[index];\n        }\n        return node;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：创建O(1)，其他O(length)\n- 空间复杂度：O(字符的长度和*26)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/80#issuecomment-1527065490","body":"### 思路\ninsert可以改造trie构造中的插入方法；sum是prefix最后一个字符的val\n### 代码\n```java\nclass MapSum {\n    class Trie {\n        int val = 0;\n        Trie[] next = new Trie[26];\n    }\n\n    Trie root;\n    Map<String, Integer> map;\n\n    public MapSum() {\n        root = new Trie();\n        map = new HashMap<>();\n    }\n    \n    public void insert(String key, int val) {\n        int delta = val - map.getOrDefault(key, 0);\n        map.put(key, val);\n        Trie node = root;\n        for (char c : key.toCharArray()) {\n            if (node.next[c - 'a'] == null) {\n                node.next[c - 'a'] = new Trie();\n            }\n            node = node.next[c - 'a'];\n            node.val += delta;\n        }\n    }\n\n    // 只需要返回prefix最后一个字符的val即可\n    public int sum(String prefix) {\n        Trie node = root;\n        for (char c : prefix.toCharArray()) {\n            if (node.next[c - 'a'] == null) {\n                return 0;\n            }\n            node = node.next[c - 'a'];\n        }\n        return node.val;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：创建O(N)\n- 空间复杂度：O(key最大长度 * map长度)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/86#issuecomment-1534224320","body":"```java\nclass Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        List<Integer> combine = new ArrayList<>();\n        dfs(candidates, target, res, combine, 0);\n        return res;\n    }\n    public void dfs(int[] candidates, int target, List<List<Integer>> res, List<Integer> combine, int idx) {\n        if (idx == candidates.length) {\n            return;\n        }\n        if (target == 0) {\n            res.add(new ArrayList<>(combine));\n            return;\n        }\n        // 跳过当前数\n        dfs(candidates, target, res, combine, idx + 1);\n        // 选择当前数\n        if (target - candidates[idx] >= 0) {\n            combine.add(candidates[idx]);\n            dfs(candidates, target - candidates[idx], res, combine, idx);\n            combine.remove(combine.size() - 1);\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null]}