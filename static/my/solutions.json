{"michaelxi3":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184635948","body":"# Idea\r\nArray Iteration，从后往前进位\r\n# Code\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int index = num.length - 1;\r\n        \r\n        while (index >= 0 || k!=0) {\r\n            \r\n            if (index >= 0) {\r\n                k = num[index] + k;\r\n                index--;\r\n            }\r\n            // k != 0 时都要继续loop！因为有进位的 special case！\r\n            res.addFirst(k % 10);\r\n            k = k / 10;\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185699268","body":"# Idea\r\n> Two Pass, Array Manipulation\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] dist = new int[n];\r\n        // Step_1: Initialization\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) continue;\r\n            dist[i] = Integer.MAX_VALUE;\r\n        }\r\n        // First Pass: Left to Right\r\n        for (int i = 0; i < n-1; i++) {\r\n            if (dist[i] == Integer.MAX_VALUE) continue;\r\n            else dist[i + 1] = Math.min(dist[i+1], dist[i] + 1);\r\n        }\r\n        // Second Pass: Right to Left\r\n        for (int i = n-1; i > 0; i--) {\r\n            dist[i-1] = Math.min(dist[i-1], dist[i] + 1);\r\n        }\r\n        return dist; \r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186251631","body":"# Idea\r\n> Implement as an Array and keep track of maxSize and curSize\r\n# Code\r\n```java\r\nclass CustomStack {\r\n\r\n    private int[] arr;\r\n    private int maxSize;\r\n    private int curSize;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.arr = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n        this.curSize = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (this.curSize >= this.maxSize) {\r\n            return;\r\n        } else {\r\n            arr[curSize] = x;\r\n            curSize++;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (this.curSize <= 0) {\r\n            return -1;\r\n        } else {\r\n            curSize--;\r\n            return arr[curSize];\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if (curSize > 0) {\r\n            for (int i = 0; i < k && i < this.curSize; i++) {\r\n                arr[i] = arr[i] + val;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darknightwriter":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184674932","body":"## 思路\n注意 k 、num数组、以及进位问题即可。\n- Java：数组遍历\n- Python： 字符串偷懒\n\n## 解题\nJava:\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> arr = new LinkedList<>();\n        int index = num.length - 1;\n        int plus = 0;\n        while (k > 0 || plus != 0 || index > -1) {\n            int mod = k % 10 + plus;\n            k /= 10;\n            if (index > -1) {\n                mod += num[index--];\n            }\n            arr.addFirst(mod % 10);\n            plus = mod / 10;\n        }\n        return arr;\n    }\n}\n```\nPython:\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = reduce(lambda x, y: x * 10 + y, num) + k\n        return [0] if n == 0 else [int(i) for i in str(n)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186186080","body":"## 思路\n1. 遍历查询所有s中等于c的下标并保存\n2. 二次遍历并对比该字符到两端的最短距离\n\n## 代码\n```Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ret = new int[s.length()];\n        ArrayList<Integer> index = new ArrayList<>();\n        index.add(-s.length() - 1);\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c){\n                index.add(i);\n            }\n        }\n        index.add(s.length() * 2);\n        int point = 1;\n        for (int i = 0; i < s.length(); i++) {\n            ret[i] = Math.min(i - index.get(point - 1),index.get(point) - i);\n            if (i == index.get(point)){\n                point++;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n## 复杂度\n时间复杂度： O(N)\n空间复杂度： O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"findlayzhou":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184759423","body":"**智商不够，硬解来凑**\n\n----------------------\n\n> 思路：把整数转成数组，同时创建一个长度+1的备用数组防止溢出，各位分别做十进制加法，不溢出则截断数组返回答案。\n\n------------\n\n*代码*\n\n```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\n/**\n * @author boyu\n */\npublic class Solution {\n    static int[] addArrAndInt(int[] nums,int k){\n        ArrayList<Integer> al = new ArrayList<>();\n        do{\n            al.add(k % 10);\n        }while ((k /= 10) > 0);\n        Collections.reverse(al);\n        int[] arr = new int[al.size()];\n        for (int i = 0; i < al.size(); i ++) {\n            arr[i] = al.get(i);\n\n        }\n        return addTwoArr(nums, arr);\n    }\n    static int[] addTwoArr(int[] arr1, int[] arr2){\n        int tag = 0;\n        int t;\n        int ptr1 = arr1.length;\n        int ptr2 = arr2.length;\n        int[] res = new int[Math.max(ptr1, ptr2) + 1];\n        Arrays.fill(res, 0);\n        for (int i = res.length - 1; i >= 0 ; i --) {\n            if(ptr1 < 1 && ptr2 < 1) {\n                res[i] = tag;\n                break;\n            }else if(ptr1 < 1){\n                t = arr2[-- ptr2] ;\n            }else if(ptr2 < 1){\n                t = arr1[-- ptr1] ;\n            }else {\n                t = arr1[-- ptr1] + arr2[-- ptr2];\n            }\n            res[i] = (t + tag) % 10;\n            if (t + tag >= 10){\n                tag = 1;\n            }else {\n                tag = 0;\n            }\n        }\n        if ( res[0] != 1 ){\n            return Arrays.copyOfRange(res, 1, res.length);\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int[] arr= {9, 9, 9};\n        int k = 1;\n        System.out.println(\"{9, 9, 9} + 1 = \" + Arrays.toString(Solution.addArrAndInt(arr, k)));\n    }\n}\n```\n\n--------------\n\n***萌新刚接触算法没思路求大佬们轻喷，后续会努力学习大佬解法，献丑了。***\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185723846","body":"> 思路：对每一个点进行左右遍历，取最小值。\r\n\r\n------------\r\n\r\n代码\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] ans = new int[len];\r\n        Arrays.fill(ans, Integer.MAX_VALUE);\r\n        int t;\r\n        for (int i = 0; i < len; i++) {\r\n            t = i; //扫左边\r\n            while (t >= 0){\r\n                if (s.charAt(t) == c){\r\n                    ans[i] = Math.min(ans[i], Math.abs(i - t));\r\n                }\r\n                t --;\r\n            }\r\n            t = i; //扫右边\r\n            while (t < len){\r\n                if (s.charAt(t) == c){\r\n                    ans[i] = Math.min(ans[i], Math.abs(t - i));\r\n                }\r\n                t ++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuwf":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184788930","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s = \"\"\n        for i in num:\n            s += str(i)\n            \n        answer = int(s) + k\n        \n        return  \"\".join(str(answer))\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186315034","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = deque()\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) == self.maxSize:\n            return\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack: return -1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        stack2 = deque()\n        if k < len(self.stack):\n            for i in range(len(self.stack) - k):\n                stack2.append(self.stack.pop())\n        while self.stack:\n            stack2.append(self.stack.pop() + val)\n        while stack2:\n            self.stack.append(stack2.pop())\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lbc546":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184790165","body":"## Add Entire K to the first column to the right and carry over ```addend // 10``` to the next (left) column\n## Python Solution\n```\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        index = len(num) - 1\n        add = k\n        result = []\n        \n        # Iterate from right end of the array\n        while index >= 0 or add > 0:\n             # Whenever not at the end of the array, add the digit\n             if index >= 0:\n                add += num[index]\n            add, mod = divmod(add, 10)\n            result.insert(0, mod)\n            index -= 1\n        return result\n```\n## Complexity\nTime: O(n)   Space: O(n) where n is the length of the array num","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185890807","body":"## Two Pass\n## Python solution\n```\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        prev = float('-inf')\n        ans = []\n        # left\n        for i in range(len(s)):\n            if s[i] == c:\n                prev = i\n            ans.append(i - prev)\n        # right\n        prev = float('inf')\n        for i in range(len(s)-1, -1, -1):\n            if s[i] == c:\n                prev = i\n            ans[i] = min(ans[i], prev - i)\n        return ans\n```\n## Complexity\nTime: O(n)\nSpace: O(n) where n is the length of array s","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186247118","body":"## OOD with python list\n## Python solution\n```\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n\n        self.maxSize = maxSize\n        self.data = []\n        \n\n    def push(self, x):\n\n        if len(self.data) < self.maxSize:\n            self.data.append(x)\n        else:\n            pass\n        \n\n    def pop(self):\n\n        if len(self.data) == 0:\n            return -1\n        else:\n            return self.data.pop()\n        \n\n    def increment(self, k, val):\n\n        for i in range(min(len(self.data), k)):\n            self.data[i] += val\n    \n```\n## Complexity\n```push()``` O(1)\n```pop()``` O(1)\n```increment``` O(min(n, k))\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zch-bit":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184793730","body":"## Go Solution\r\nAdd the last digit of k to the last element in `num` as `sum`, then drop the last digit of k(k=k/10); eventually, check if k is equal to zero, if not, convert it to a new array and attach the num to the end.\r\n\r\n```go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n\ti := len(num) - 1\r\n\tfor i >= 0 || k > 0 {\r\n\t\tif i > 0 && k > 0 {\r\n\t\t\tsum := num[i] + k%10\r\n\t\t\tnum[i] = sum\r\n\t\t\tk = k / 10  // drop the last element of k\r\n\r\n\t\t\tif sum > 9 {\r\n\t\t\t\tnum[i] = sum % 10\r\n\t\t\t\tk++ //  add carry(1) to k\r\n\t\t\t}\r\n\t\t\ti--\r\n\t\t} else if i >= 0 {\r\n\t\t\tbreak\r\n\t\t} else {\r\n\t\t\tnum = append([]int{k % 10}, num...) \r\n\t\t}\r\n\t}\r\n\r\n\treturn num\r\n}\r\n```\r\n\r\n## Complexity: \r\nTIme: O(n)\r\nSpace: O(n) where m is the max between the length of num and k.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186121758","body":"## Day 2\r\n\r\n1. first loop: Save position of char c\r\n2. second loop: Compute the min distance between char c and other chars\r\n\r\nTime: O(n), space: O(n)\r\n\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n\tvar pos []int\r\n\tfor i, ch := range s {\r\n\t\tif byte(ch) == c {\r\n\t\t\tpos = append(pos, i)\r\n\t\t}\r\n\t}\r\n\tfmt.Printf(\"%v\", pos)\r\n\r\n\tres := []int{}\r\n\tfor i, ch := range s {\r\n\t\tif byte(ch) == c {\r\n\t\t\tres = append(res, 0)\r\n\t\t} else {\r\n\t\t\tmin := math.MaxInt16\r\n\t\t\tfor _, j := range pos {\r\n\t\t\t\tif min > abs(j-i) {\r\n\t\t\t\t\tmin = abs(j - i)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tres = append(res, min)\r\n\t\t}\r\n\t}\r\n\tfmt.Printf(\"%v\", res)\r\n\treturn res\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frankelzeng":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184838625","body":"## Idea\r\nKeep in mind that string is just a list of char, then there is no need to do decimal manipulation but can simply use six-stage conversion: \r\n1. convert int list to char list\r\n2. join char list into singe word\r\n3. convert the single word to int\r\n4. add int with k\r\n5. convert the sum to string\r\n6. map string to int list\r\n## Python Code\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_int = int(\"\".join(map(str, num)))\r\n        re = num_int + k\r\n        return list(map(int, str(re)))\r\n```\r\n## Complexity\r\nSpace: O(N)\r\nTime: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186222897","body":"## Idea\nUse to pointers to track the distance\n## Python Code\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        strlen = len(s)\n        re = [-1 for _ in range(strlen)]\n        idx_li = []\n        for i in range(strlen):\n            if s[i] == c:\n                re[i] = 0\n                idx_li.append(i)\n        le = 0\n        ri = 0\n        for i in range(len(idx_li) + 1):\n            if i == 0:\n                re[:idx_li[0]] = [x for x in range(idx_li[0],0,-1)]\n            elif i == len(idx_li):\n                ran = len(re[idx_li[len(idx_li) - 1]:])\n                re[idx_li[len(idx_li) - 1]:] = [x for x in range(ran)]\n            else:\n                curr = 0\n                le = idx_li[i - 1]\n                ri = idx_li[i]\n                while le <= ri:\n                    re[le] = re[ri] = curr\n                    le += 1\n                    ri -= 1\n                    curr += 1\n        return re\n```\n## Complexity\nSpace: O(N)\nTime: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhaodev":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184887447","body":"**Swift Solution**\r\n\r\n思路：\r\nK作为位数累加然后进位\r\n代码：\r\n```\r\n\r\n    func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] {\r\n        if num.isEmpty { return [] }\r\n        \r\n        var k = k, ans = [Int](), i =  num.count - 1, carry = 0\r\n        while i >= 0 || k > 0 {\r\n            var sum = (i >= 0 ? num[i] : 0) + (k > 0 ? k % 10 : 0) + carry\r\n            ans.append(sum % 10)\r\n            carry = sum / 10\r\n            i -= 1\r\n            k /= 10 \r\n        }\r\n        \r\n        if carry > 0 {\r\n            ans.append(carry)\r\n        }\r\n        \r\n        return Array(ans.reversed())\r\n    }\r\n```\r\n\r\n复杂度：\r\n时间复杂度： O（n）\r\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185867186","body":"思路:\r\n两次遍历： 从左往右，从右往左；用数组分别记录距离C的值，然后取两者之间的最小值\r\n代码:\r\n\r\n```\r\n func shortestToChar(_ s: String, _ c: Character) -> [Int] {\r\n        let arr = Array(s)\r\n        let n = arr.count\r\n        var res = Array(repeating: 0, count:n)\r\n        var prev = Int.min/2\r\n        for (i, char) in arr.enumerated() {\r\n            if char == c {\r\n                prev = i\r\n            }\r\n            res[i] = i - prev\r\n        }\r\n        \r\n        prev = Int.max/2\r\n        \r\n        for (i, char) in arr.enumerated().reversed() {\r\n            if char == c {\r\n                prev = i\r\n            }\r\n            res[i] = min(res[i], prev - i)\r\n        }\r\n        \r\n        return res\r\n    }\r\n```\r\n\r\n复杂度：\r\n时间复杂度： O(n) n是s的长度\r\n空间复杂度: O(n) 其实可以为O（1)，但是Swift里把String转换为Array性能更高","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186418704","body":"思路：\r\n用数组模拟一个栈的Push(add), Pop(remove),然后只修改k个元素的值(inc)\r\n代码:\r\n```\r\nclass CustomStack {\r\n\r\n    let maxSize: Int\r\n    var items: [Int]\r\n    \r\n    init(_ maxSize: Int) {\r\n        self.maxSize = maxSize\r\n        self.items = [Int]()\r\n    }\r\n    \r\n    func push(_ x: Int) {\r\n        guard items.count < maxSize else { return }\r\n        items.append(x)\r\n    }\r\n    \r\n    func pop() -> Int {\r\n        if items.isEmpty { return -1 }\r\n        return items.popLast()!\r\n    }\r\n    \r\n    func increment(_ k: Int, _ val: Int) {\r\n        let maxCount = min(k, items.count)\r\n        for i in 0..<maxCount {\r\n            items[i] += val\r\n        }\r\n    }\r\n}\r\n```\r\n复杂度:\r\n时间复杂度: O(n)\r\n空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joeymoso":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184914351","body":"```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n\r\n        idx = len(num) - 1\r\n        while k > 0 and idx >= 0:\r\n            if num[idx] + k % 10 < 10:\r\n                num[idx] = num[idx] + k % 10\r\n                k //= 10\r\n            else:\r\n                num[idx] = (num[idx] + k % 10) % 10\r\n                k //= 10\r\n                k += 1\r\n            idx -= 1\r\n        while k:\r\n            if idx < 0:\r\n                num = [k % 10] + num\r\n                k //= 10\r\n            else:\r\n                if num[idx] + k % 10 < 10:\r\n                    num[idx] += k % 10\r\n                    k //= 10\r\n                else:\r\n                    num[idx] = 0\r\n                    k //= 10\r\n                    k += 1\r\n                idx -= 1\r\n            \r\n\r\n        return num\r\n```\r\n\r\n* Time: O(n)\r\n* Space: O(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hackbl":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184950463","body":"```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            int curr = k%10 + num[i];\r\n            k /= 10;\r\n            \r\n            if (curr >= 10) {\r\n                k += 1;\r\n            }\r\n            \r\n            res.add(0, curr%10); \r\n        }\r\n        \r\n        while (k > 0) {\r\n            res.add(0, k%10);\r\n            k /= 10;\r\n        }\r\n        \r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n* Time: O(n)\r\n* Space: O(n)\r\n* Where n is Max(num.length, k.length)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185869150","body":"左右遍历\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        int curr = len;\r\n        \r\n        for (int i = 0; i < len; i++) {\r\n            if (s.charAt(i) == c) {\r\n                res[i] = 0;\r\n                curr = i;\r\n            } else {\r\n                res[i] = Math.min(len, Math.abs(i-curr));\r\n            }\r\n        }\r\n        \r\n        for (int i = len-1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                curr = i;\r\n            } else {\r\n                res[i] = Math.min(res[i], Math.abs(curr-i));\r\n            }\r\n            \r\n        }\r\n               \r\n        return res;\r\n    }\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185032289","body":"```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = 0\r\n        num = num[::-1]\r\n        while k:\r\n            mod = k % 10\r\n            k = k//10\r\n            if i < len(num):\r\n                num[i] += mod\r\n            else:\r\n                num.append(mod)\r\n            if num[i] >= 10:\r\n                if i+1 < len(num):\r\n                    num[i+1] += 1\r\n                else:\r\n                    num.append(1)\r\n\r\n                num[i] -= 10\r\n            i+=1\r\n        while i < len(num):\r\n            if num[i] >= 10:\r\n                if i+1 < len(num):\r\n                    num[i+1] += 1\r\n                else:\r\n                    num.append(1)\r\n                num[i] -= 10\r\n                i+=1\r\n            else:\r\n                break\r\n        return num[::-1]\r\n```\r\n一位一位地加并且进位 ripple adder\r\n\r\nTime O(n)\r\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiyishuoshuo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185034114","body":"explanation:\r\ntake K as a carry and use k to extract the lowest digit with K % 10 and update k with k /10 as the next higher digit\r\ncorner case is once the loop ended, if k is still > 0 need to put 1 on the leftmost digit\r\n\r\ncode\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n\r\n        int len = num.length;\r\n        List<Integer> ans = new ArrayList<>();\r\n        \r\n        for(int j = len - 1; j>=0 || k > 0; j--){\r\n            ans.add(0, (j>=0 ? num[j] + k : k) % 10);\r\n            k = (j>=0 ? num[j] + k : k) / 10;\r\n        }\r\n\r\n        return ans;\r\n\r\n    }\r\n}\r\n```\r\n\r\nTime: O(n) since iterate array once\r\nSpace: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186163128","body":"Explanation:\r\nloop through the array twice first from left to right and keep update pos for char c and calculate the potential distance between each character and matching c\r\nthen loop through the same from right to left and then the result should be taking the min of current distance and previous min distance looping from left to right\r\n\r\ncode:\r\n'''\r\npublic int[] shortestToChar(String s, char c) {\r\n        \r\n        int len = s.length(), pos = -2*len ;\r\n        int[] result = new int[len];\r\n        \r\n        // from left to right\r\n        for(int i = 0; i< len; i++){\r\n            if(s.charAt(i) == c) {\r\n                pos = i;\r\n            }\r\n            result[i] = i - pos;\r\n        }\r\n        \r\n        // from right to left\r\n        pos = 2 * len;\r\n        for(int j = len - 1; j>=0; j--){\r\n            if(s.charAt(j) == c){\r\n                pos = j;\r\n            }\r\n            result[j] = Math.min(result[j], pos - j);\r\n        }\r\n        \r\n        return result;\r\n        \r\n    }\r\n'''\r\n\r\nTime: O(n) loop through twice so will be O(2n) but will be treated as O(n)\r\nSpace: O(n) result array with n length\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aouos":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185043729","body":"```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  const len = num.length;\n  const stack = [];\n\n  for (let i = len - 1; i >= 0 || k > 0; i--) {\n    k = k + (num[i] || 0);\n    stack.push(k % 10);\n    k = Math.floor(k / 10);\n  }\n\n  return stack.reverse();\n};\n```\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186120127","body":"## 思路\n左右两次遍历\n\n## 代码\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n  const len = s.length;\n  const ans = new Array(len).fill(10001);\n\n  for (let i = 0; i < len; i++) {\n    if (s[i] === c) {\n      ans[i] = 0;\n    } else {\n      if (i === 0) {\n        continue;\n      }\n      ans[i] = ans[i - 1] + 1;\n    }\n  }\n\n  for (let j = len - 1; j >= 0; j--) {\n    if (j + 1 !== len) {\n      ans[j] = Math.min(ans[j], ans[j + 1] + 1);\n    }\n  }\n\n  return ans;\n};\n```\n\n## 复杂度\n- 时间：O(n)\n- 空间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185062953","body":"```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        import math\r\n        n = max(len(num), int(math.log10(k))+1) + 1\r\n        result = [0] * n\r\n        num = [0] * (n - len(num)) + num\r\n        \r\n        carry = 0\r\n        for i in range(n - 1, -1, -1):\r\n            result[i] = num[i] + k % 10 + carry\r\n            carry = result[i] // 10\r\n            result[i] = result[i] % 10\r\n            k = k // 10\r\n            \r\n        if result[0] == 0:\r\n            return result[1:]\r\n        else:\r\n            return result\r\n```\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185734047","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        left = [float('inf')] * len(s)\n        right = [float(\"inf\")] * len(s)\n        \n        index_left = []\n        index_right = []\n        \n        for idx, ch in enumerate(s):\n            if ch == c:\n                index_left.append(idx)\n                index_right.append(idx)\n        \n        for i in range(len(s)-1, -1, -1):\n            if not index_left:\n                break\n            d = i - index_left[-1]\n            left[i] = d\n            if d == 0:\n                index_left.pop()\n        \n        for i in range(len(s)):\n            if not index_right:\n                break\n            d = index_right[0] - i\n            right[i] = d\n            if d == 0:\n                index_right = index_right[1:]\n                \n        result = []\n        for i in range(len(s)):\n            result.append(min(left[i],right[i]))\n        return result\n```\n时间复杂度：O(n)\n空间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186255230","body":"# Increase every number for the increment operation\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.s = []\n        self.maxSize = maxSize\n    def push(self, x: int) -> None:\n        if len(self.s) < self.maxSize:\n            self.s.append(x)\n    def pop(self) -> int:\n        if not self.s:\n            return -1\n        return self.s.pop()\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.s))):\n            self.s[i] += val\n```\n时间复杂度：O(1) for pop and push, O(n) for increment\n空间复杂度：O(1)\n\n# Increase at pop\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.s = []\n        self.maxSize = maxSize\n    def push(self, x: int) -> None:\n        if len(self.s) < self.maxSize:\n            self.s.append(x)\n    def pop(self) -> int:\n        if not self.s:\n            return -1\n        return self.s.pop()\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.s))):\n            self.s[i] += val\n```\n时间复杂度：O(1)\n空间复杂度：O(len(s))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wengzhouyunfan":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185063354","body":"\n```java\n  // key point : A > 0  add digit by digit\n  // input : int A[], int k     return: int []\n  // A.length <= 10000     T: O(n) < n^2\n  // brute force : \n  //   1) get last digit from k and cur A[i]; \n  //   2) add to array, renew carry and digit; \n  //   3) check carry, return array;\n\t  public int[] addInteger(int[]A, int K){\n\t    LinkedList<Integer> list = new LinkedList<Integer>();\n\t    int curA = A.length - 1;\n\t    int curK = K;\n\t    int carry = 0;\n\t    while(curA >= 0 || curK != 0){\n\t      int sum = curA < 0 ? carry + curK%10 : carry + A[curA] + curK%10;\n\t      int digit = sum % 10;\n\t      carry = sum / 10;\n\t      list.add(digit);  // add to end O(1) \n\t      curK/=10;\n\t      curA--;\n\t    }\n\t    if(carry != 0) list.addFirst(1); // add to head O(1)\n\t    return list.stream().mapToInt(x -> x).toArray(); // can't directly turn into primitive type O(n)\n\t  }\n```\nT: O(n)\nS: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185992291","body":"```java\n// S > 0   shortest dist   DP \n// input : char S[], char C   return int[]\n// A.length <= 10000   O(n) < n^2\n// brute force : \n//\t 1) find every s[i] == target, fill to left and right with dist until reach next target;  \n//\t 2) while finish filling, stop and find next target; \n//\t 3) finish filling and return res;\n//\n// improve:\n//   1) traverse from left to right, get left shortest dist from every target\n//   2) traverse from right to left, get right shortest dist from every target \n//   3) compare left and right and return res;\n\t  public int[] shortestToChar(char[]S, char C){\n\t\t  if(S.length == 1) return new int[] {0};\n\t\t  int[] res = new int[S.length];\n\t\t  Arrays.fill(res, S.length);\n\t\t  for(int i = 0, c = -1; i < S.length; i++){\n\t\t\t  if(S[i] == C) {\n\t\t\t\t  c = i;\n\t\t\t  }\n\t\t\t  if(c != -1) {\n\t\t\t\t  res[i] = i - c;\n\t\t\t  }\n\t\t  }\n\t\t  for(int i = S.length -1, c = -1; i >= 0; i--) {\n\t\t\t  if(S[i] == C) {\n\t\t\t\t  c = i;\n\t\t\t  }\n\t\t\t  if(c != -1) {\n\t\t\t\t  res[i] = Math.min(c - i, res[i]);\n\t\t\t  }\n\t\t  }\n\t\t  return res;\n\t  }\n```\nT:O(n)\nS:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whisht":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185072053","body":"1. 将 num 转为 数字\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        t = 10\r\n        n = len(num)\r\n        res = 0\r\n        for i in range(n):\r\n            res += t**i*num[n-i-1]\r\n        res += k\r\n        print(res)\r\n        out = []\r\n        while res:\r\n            out.append(res%10)\r\n            res = res//10\r\n        return out[::-1]\r\n```\r\n时间复杂度：$O(N)$\r\n空间复杂度：$O(N)$\r\n\r\n2. 逐位相加\r\n>  ![image](https://user-images.githubusercontent.com/16497652/179130663-29ae5da6-b53c-4569-bd7c-327bf30c97e6.png)\r\n> [https://leetcode.cn/problems/add-to-array-form-of-integer/solution/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/](url)\r\n\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = 0\r\n        res = []\r\n        if len(num)<len(str(k)):\r\n            num = [0]*(len(str(k))-len(num))+num\r\n        n = max(len(str(k)),len(num))-1\r\n        while n>=0 or k:\r\n            sums = num[n]+k%10+carry\r\n\r\n            basic = sums%10\r\n            carry = sums//10\r\n            res.insert(0,basic)\r\n\r\n            n -= 1\r\n            k//=10\r\n        if carry:\r\n            res.insert(0,carry)\r\n            return res\r\n        else:\r\n            return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186098194","body":"* 从左到右正序遍历一次字符串 `s`，记录字符串 `s` 中每个字符到左侧字符 `c` 的距离\n* 从右到左逆序遍历一次字符串 `s`，记录字符串 `s` 中每个字符到右侧字符 `c` 的距离\n需要考虑的是最开始没有出现 `c` 时，`c` 的位置该如何处理，要保证使用该位置计算后的距离不会影响最终的结果。\n* 初始化 `s` 中各字符的距离为无穷大（ s 长度）\n* 正序遍历记未出现`c`的位置为 `-1`\n* 逆序遍历记未出现`c`的位置为 `n`\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        res = [n+1]*n\n        idx = -1\n        for i in range(n):  # 左侧 c 位置\n            if s[i]==c:\n                idx = i\n            if idx!=-1:\n                res[i] = i - idx\n        idx = n\n        for i in range(n-1,-1,-1): # 右侧 c 位置\n            if s[i] == c:\n                idx = i\n            if idx!= n:\n                res[i]= min(idx - i,res[i])\n        return res\n        \n```\n## 复杂度\n* 时间复杂度：遍历`s`即可，$O(N)$\n* 空间复杂度： 和`s`等长的结果数组，$O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186423067","body":"``` python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if len(self.stack)>0:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack)<k:\n            self.stack = [i+val for i in self.stack]\n        else:\n            self.stack[:k] = [i+val for i in self.stack[:k]]\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185074522","body":"### 思路\n将list→str→int → result+k → str → list\n\n### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \n        result = int(''.join(map(str, num))) + k\n        \n        return [int(i) for i in str(result)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186187289","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \n        n = len(s)\n        ans = [0] * n\n        idx = -n\n\n        for i, ch in enumerate(s):\n            if ch == c:\n                idx = i\n            ans[i] = i - idx\n\n        idx = 2 * n\n        for i in range(n-1, -1, -1):\n            if s[i] == c:\n                idx = i\n            ans[i] = min(ans[i], idx-i)\n\n        return ans\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzzkains":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185077761","body":"y总说这个是高精度加法\n# 高精度加法\nc++中的高精度加法一般是从低位到高位\n所以需要reverse\n然后正常加就行\n# 代码\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n        for (int & c : num) {\n            k += c;\n            c = k % 10;\n            k /= 10;\n        }\n        while (k) num.push_back(k % 10), k /= 10;\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186107567","body":"# 思路\n左边右边分别求一下最近的值，然后求最小\n# 代码\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> res(n, INT_MAX);\n        for (int i = 0, j = -1; i < n; i ++) {\n            if (s[i] == c) j = i;\n            if (j != -1) res[i] = i - j;\n        }\n        for (int i = n - 1, j = -1; i >= 0; i --) {\n            if (s[i] == c) j = i;\n            if (j != -1) res[i] = min(res[i], j - i);\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186394469","body":"# 思路\n数组模拟栈\n# 代码\n```C++\nclass CustomStack {\npublic:\n    vector<int> stk, inc;\n    int maxsize;\n    \n    CustomStack(int maxSize) {\n        maxsize = maxSize;\n    }\n    \n    void push(int x) {\n        if (stk.size() < maxsize) {\n            stk.push_back(x);\n        }\n        return ;\n    }\n    \n    int pop() {\n        // 考虑数组为空的情况\n        if (stk.size()) {\n            int t = stk.back();\n            stk.pop_back();\n            return t;\n        }\n        return -1;\n    }\n    \n    void increment(int k, int val) {\n        int l = min(k, (int)stk.size());\n        for (int i = 0; i < l; i ++) {\n            stk[i] += val;\n        }\n        return ;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenmengyu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185084170","body":"# 思路\n类似于大数相加，由于可能溢出，所以把两个数转成数组存储，从数组对应的数字低位开始相加，若同位相加大于10，需要进位。\n\n# 代码JS\n```js\nvar addToArrayForm = function(num, k) {\n    let num2 = (k + '').split('')\n    let len = Math.max(num.length, num2.length)\n    let flag = 0 // 进位标志\n    let result = []\n    num.reverse()\n    num2.reverse()\n    for (let i = 0; i < len; i++) {\n        let sum = (num[i] || 0) + (num2[i] || 0) / 1 + flag\n        flag = Math.floor(sum / 10)\n        sum = sum % 10\n        result.push(sum)\n    }\n    if (flag) {\n        result.push(flag)\n    }\n    return result.reverse()\n};\n```\n# 复杂度\n时间复杂度：O(n)  \n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186191642","body":"### 思路\r\n先找出字符c在字符串s中的所有下标数组cArr，然后先遍历字符串s，再遍历数组cArr，获得字符串s中每个字符下标和cArr中值的最小距离。\r\n### 代码\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let len = s.length\r\n    let cArr = []\r\n    let start = 0\r\n    let index, answer = []\r\n    while(~(index = s.indexOf(c, start))) {\r\n        cArr.push(index)\r\n        start = index + 1\r\n    }\r\n    for (let i = 0; i < s.length; i++) {\r\n        let temp\r\n        for (let j = 0; j < cArr.length; j++) {\r\n            if (temp === void 0) {\r\n                temp = Math.abs(i - cArr[j])\r\n            } else {\r\n                temp = Math.min(Math.abs(i - cArr[j]), temp)\r\n            }\r\n        }\r\n        answer.push(temp)\r\n    }\r\n    return answer\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uancen":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185084621","body":"## Idea\n\n首先循环处理num，k提供加数/辅助处理进位\n\n再单独拿出一个循环处理剩下的k，直接加在num头部\n\n## Code\n\n```GO\nfunc reverse(num []int) {\n\tfor i, n := 0, len(num); i < n/2; i++ {\n\t\tnum[i], num[n-1-i] = num[n-1-i], num[i]\n\t}\n}\nfunc addToArrayForm(num []int, k int) []int {\n\tvar res_head []int\n\tvar n int = len(num)\n\ti := n - 1\n\tfor i >= 0 || k > 0 {\n\t\tif i < 0 {\n\t\t\tbreak\n\t\t}\n\t\tsum := num[i] + k%10\n\t\tk /= 10\n\t\tif sum >= 10 {\n\t\t\tsum -= 10\n\t\t\tk++ // add the 10 as 1 to k\n\t\t}\n\t\tnum[i] = sum // 0<=sum<=9\n\t\ti--\n\t}\n\tfor k > 0 {\n\t\tres_head = append(res_head, k%10)\n\t\tk /= 10\n\t}\n\treverse(res_head)\n\tnum = append(res_head, num...)\n\treturn num\n}\n```\n\n## Complexity\n\n* Time O(N)\n* Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186197390","body":"## Idea\n\nres[i] = min(d to left c, d to right c)\n\n* first loop from l to r: record \"c\" as idx and update res[i]=i-idx\n* second loop from r to l: record \"c\" as idx and update res[i]=min(res[i], idx-i) \n\n## Code\n\n```go\nfunc min(a, b int) int {\n\tif a > b {\n\t\treturn b\n\t} else {\n\t\treturn a\n\t}\n}\nfunc shortestToChar(s string, c byte) []int {\n\t// res[i] = min(d to left c, d to right c)\n\tn := len(s)\n\tres := make([]int, n)\n    // -n --> make res[i] = (i + n) large enough for the second round iteration to overwrite it\n\tidx := -10007 \n\tfor i, a := range s {\n\t\tif byte(a) == c {\n\t\t\tidx = i\n\t\t}\n\t\tres[i] = i - idx\n\t}\n    // \n    // 2n --> make (2n - i) large enough for the first iteration record to be min\n\tidx = 20007\n\tfor i := n - 1; i >= 0; i-- {\n\t\tif s[i] == c {\n\t\t\tidx = i\n\t\t}\n\t\tres[i] = min(res[i], idx-i)\n\t}\n\treturn res\n}\n```\n\n## Complexity\n\n* Time O(N)\n* Space O(1) | return not considered ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186371628","body":"## Idea\n\nstk array +  cur --> top\n\nuse diff to implement incrementing \n\n## Code\n\n```go\ntype CustomStack struct {\n\tstk  []int\n\tdiff []int\n\tcur  int\n}\n\nfunc Constructor(maxSize int) CustomStack {\n\treturn CustomStack{\n\t\tcur:  -1,\n\t\tstk:  make([]int, maxSize, maxSize),\n\t\tdiff: make([]int, maxSize, maxSize),\n\t}\n}\n\nfunc (this *CustomStack) Push(x int) {\n\tif this.cur < len(this.stk)-1 {\n\t\tthis.cur++\n\t\tthis.stk[this.cur] = x\n\t}\n}\n\nfunc (this *CustomStack) Pop() int {\n\tif this.cur == -1 {\n\t\treturn -1\n\t}\n\tres := this.stk[this.cur] + this.diff[this.cur]\n\tif this.cur != 0 {\n\t\tthis.diff[this.cur-1] += this.diff[this.cur]\n\t}\n\tthis.diff[this.cur] = 0\n\tthis.cur--\n\treturn res\n}\n\nfunc (this *CustomStack) Increment(k int, val int) {\n\tif this.cur == -1 {\n\t\treturn\n\t}\n\tif k > this.cur+1 {\n\t\tthis.diff[this.cur] += val\n\t} else {\n\t\tthis.diff[k-1] += val\n\t}\n}\n```\n\n## Complexity\n\n* Time O(1)\n* Space O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuomituxedo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185093417","body":"## 思路\r\n1. convert to num to integer\r\n2. add k to integer to get sum\r\n3. convert sum to list of integers\r\n\r\n## 代码 （Python)\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_int = int(''.join(map(str, num)))\r\n        sum = num_int + k\r\n        new_num = []\r\n        for d in str(sum):\r\n            new_num.append(int(d))\r\n        return new_num\r\n```\r\n\r\n时间复杂度： O(n)\r\n空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186098624","body":"## 思路\r\n1. initialize the res array with the largest possible distance：len(s) \r\n2. iterate through the input, if we encounter c, update res for indices < index of latest c and memorize the index of the latest c\r\n3. update res for indices >= index of latest c until we encounter the next c\r\n\r\n## Code\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        last_c = 0\r\n        for i in range(0, len(s)):\r\n            res.append(len(s))\r\n        for i in range(0, len(s)):\r\n            if s[i] == c:\r\n                #update left hand side up to the last seen c\r\n                for j in range (last_c, i):\r\n                    res[j] = min(res[j], i-j)\r\n                last_c = i\r\n                #update right hand side\r\n                for j in range (i, len(s)):\r\n                    res[j] = j - i\r\n                    # stop updating right side if see next c\r\n                    if s[j] == c:\r\n                        continue\r\n        return res\r\n```\r\n\r\n### time complexity: O(n)\r\n### space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186290559","body":"## 思路 (python)\n用list来实现stack\n\n## Code\n\n```python\n\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.n = maxSize\n        self.stack = []\n        self.inc = []\n        \n    def push(self, x: int) -> None:\n        if len(self.stack) == self.n: return\n        self.stack.append(x)\n        return\n        \n\n    def pop(self) -> int:\n        if not self.stack: return -1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(len(self.stack), k)):\n            self.stack[i] += val\n```\n\n## 时间复杂度\npop: O(1) \npush: O(1)\nincrement: O(k), 1<= k <=n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongranherz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185096544","body":"## 思路\n1.将 num和k从后往前相加，两者长度未知，通过 while k!=0 or i>=0 来使长度统一。\n2.每一位的累加和sum放入res中，是否进位通过carry判断。\n3.while完毕后，需要判断carry是否为零。\n\n##  python代码\n``` python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res=[]\n        carry=0\n        i=len(num)-1\n        while k!=0 or i>=0:\n            x=num[i] if i>=0 else 0 \n            y=k%10 if k!=0 else 0\n\n            sum = x+y+carry\n            res.append(sum%10)\n            carry=sum//10\n\n            i-=1\n            k//=10\n        \n        if carry!=0: res.append(carry)\n\n        return res[::-1]\n```\n## 复杂度分析\n设N为数组长度\n时间复杂度： O(max(N，K))\n空间复杂度： O(max(N，K))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186190287","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        res = [n+1]*n\n        idx = -1\n        for i in range(n):  # 左侧 c 位置\n            if s[i]==c:\n                idx = i\n            if idx!=-1:\n                res[i] = i - idx\n        idx = n\n        for i in range(n-1,-1,-1): # 右侧 c 位置\n            if s[i] == c:\n                idx = i\n            if idx!= n:\n                res[i]= min(idx - i,res[i])\n        return res\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186413552","body":"## python代码\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack=[]\n        self.length=0\n        self.maxSize=maxSize\n    def push(self, x: int) -> None:\n        if self.length!=self.maxSize:\n            self.stack.append(x)\n            self.length+=1\n\n    def pop(self) -> int:\n        if self.stack:\n            self.length-=1\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,self.length)):\n            self.stack[i]+=val\n\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gr52":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185097387","body":"/*\r\n思路 \r\n先将数组x遍历,用字符串类型拼接,强制转换与k相加,\r\n在csdn 找到的方法(大佬求解释,不太懂)直接将数值,转换成字符串\r\n*/\r\n//代码\r\nvar x=[1,2,3,4]\r\nvar k=54\r\nfor(var i=0,str='';i<x.length;i++){\r\n        str+=x[i]\r\n}\r\nvar A=Number(str)+k\r\n const converToArray = number => [...`${number}`].map(el => parseInt(el))\r\nconsole.log(converToArray(A) ); \r\n//复杂度：\r\n//时间复杂度： O（n）\r\n//空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186209924","body":"var shortLen = function(s, c) {\r\nvar s2 = Array(s.length).fill(0);\r\nfor (var i = 0; i < s.length; i++) {\r\n                       if (s1[i] === c) {\r\n                       continue;\r\n                       }\r\nfor (let j = i, count1 = 0; j < s.length; j++, count1++) {\r\n                        if (s1[j] === c) {\r\n                        return count1;\r\n                      }\r\n}\r\nfor (let j = s.length, count2 = 0; j >= 0; j--, count2++) {\r\n                      if (s1[j] === c) {\r\n                      return count2;\r\n                        }\r\n}\r\n         s2[i] = Math.min(count1, count2);\r\n}\r\nconsole.log(s2);\r\n}\r\n\r\nvar s = \"loveleetcode\", c = 'e';\r\nconsole.log(shortLen(s, c));\r\n##时间复杂度\r\n空间O(N^2)\r\n时间O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hydelovegood":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185097824","body":"# 整体思路\r\n1. 转换num或转换K，相加后再转换成数组\r\n2. 防止进位问题，可以将数组转换成数字，而后和k相加，再转换成数组\r\n# 代码\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        s, m = 0, 1\r\n        ans = []\r\n        for i in num[::-1]:\r\n            s += i * m\r\n            m *= 10\r\n        s += k\r\n        for i in str(s):\r\n            ans.append(int(i))\r\n        return ans\r\n```\r\n# 复杂度分析\r\n- 时间复杂度On\r\n- 空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186075787","body":"# 思路\n首尾两次遍历\n# 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [0] * n\n\n        idx = -n\n        for i, ch in enumerate(s):\n            if ch == c:\n                idx = i\n            ans[i] = i - idx\n\n        idx = 2 * n\n        for i in range(n - 1, -1, -1):\n            if s[i] == c:\n                idx = i\n            ans[i] = min(ans[i], idx - i)\n        return ans\n```\n# 复杂度分析\n时间复杂度On\n空间复杂度On","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nikojxie":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185098164","body":"## 思路\r\n每次循环，把数组的最后一位pop出来 和 K除10取余的结果相加，如果有进位再加1，K等于K/10取整，再记一下当前进位标记，开始下一次循环，直到 A为空 且 K为0 且 进位标记为false\r\n\r\n## 代码（JS）\r\n```javascript\r\nfunction addToArrayFormOfInteger(A, K) {\r\n  // res存结果，sum是每一位加的结果，addOneFlag是进位标记\r\n  let res = [], sum = 0, addOneFlag = false\r\n  while(A.length || K || addOneFlag) {\r\n    sum = (A.pop() || 0) + K % 10 + addOneFlag\r\n    K && (K = Math.floor(K / 10))\r\n    addOneFlag = sum >= 10\r\n    res.push(sum % 10)\r\n  }\r\n  return res.reverse()\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186092929","body":"## 思路\n遍历每一个字符，在前后同时寻找目标字符，找到了就停止，开始遍历下一个字符\n\n```javascript\nfunction shortestToChar(s, c) {\n  let res = []\n  for (let i = 0; i < s.length; i++) {\n    let count = 0\n    while (i - count >= 0 || count < s.length - i) {\n      if (s[i - count] === c || s[i + count] === c) {\n        res.push(count)\n        break\n      }\n      count ++\n    }\n  }\n  return res\n}\n```\n\n## 复杂度\n- 时间复杂度 O(n^2)\n- 空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fangxianshen":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185100852","body":"##Go解法思路\n```\nfunc addToArrayForm(num []int,k int)(ans []int){\n\tfor i := len(num)-1;i>=0;i--{\n\t\tsum := num[i] + k%10\n\t\tk /= 10\n\t\tif sum >=10{\n\t\t\tk ++\n\t\t\tsum -= 10\n\t\t}\n\t\tans = append(ans,sum)\n\t}\n\tfor ; k>0;k/=10{\n\t\tans = append(ans,k%10)\n\t}\n\treverse(ans)\n\treturn\n}\n\nfunc reverse(num []int){\n\tfor i,n := 0,len(num);i<n/2;i++{\n\t\tnum[i],num[n-1-i] = num[n-1-i],num[i]\n\t}\n}\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jokertzw":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185100878","body":"### 思路\nlist变为str再变为int然后求和后再转化为list\n### 代码\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        sum = int(''.join(map(str, num))) + k\n        return [int(i) for i in str(sum)]\n```\n**复杂度分析**\n- 时间复杂度：O(n) \n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186084611","body":"### 思路\n遍历s，如果在相应位置的字符等于c，则该位置的最短距离一定为0。如果不是c，则重新遍历s，计算离每个c的距离，从中取最小值\n### 代码\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(len(s)):\n            if s[i] == c:\n                res.append(0)\n            else:\n                res.append(min(abs(i - j) for j in range(len(s)) if s[j] == c))\n        return res\n```\n**复杂度分析**\n- 时间复杂度：O(n^2) 这里嵌套了两层for循环\n- 空间复杂度：O(n) n为res长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186393084","body":"### 代码\n```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        self.n = maxSize\n        self.stack = []\n        self.inc = []\n\n\n    def push(self, x):\n        if(len(self.stack) < self.n):\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self):\n        if(len(self.stack) == 0):\n            return -1\n        else:\n            return self.stack.pop() + self.inc.pop()\n\n\n    def increment(self, k, val):\n        for i in range(min(k, len(self.inc))):\n            self.inc[i] += val\n```\n**复杂度分析**\n- 时间复杂度：O(n) \n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyang258":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185102829","body":"```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        int kLength = 0;\n        int kcounter = k;\n        while(kcounter > 0){\n            kcounter /= 10;\n            kLength++;\n        }\n        int numLength = num.length;\n        List<Integer> res = new ArrayList<Integer>();\n        // find num or k whichever has smallest length as counter to loop\n        int counter = kLength > numLength ? numLength : kLength;\n        int carry = 0;\n        // add digit with digit and if exceed 10 then add 1 to carry and remainder to list\n        while(counter > 0){\n            int remainder = k % 10;\n            k /= 10;           \n            int digit = (num[numLength - 1] + remainder + carry) % 10;\n            carry = (num[numLength - 1] + remainder + carry) / 10;\n            // add remainder to each digit\n            res.add(0, digit);\n            counter--;\n            numLength--;\n        }\n        // if k is longer digit, then we add remaining k to list\n        while(k > 0){\n            int remainder = k % 10;\n            k /= 10;\n            int digit = (remainder + carry) % 10;\n            carry = (remainder + carry) / 10;\n            // add remainder to each digit\n            res.add(0, digit);\n        }\n        // if num array is longer, then we add remaining num array to list\n        while(numLength > 0){\n            int digit = (num[numLength - 1] + carry) % 10;\n            carry = (num[numLength - 1] + carry) / 10;\n            res.add(0, digit);\n            numLength--;\n        }\n        // if we have remaining carry, we add carry to list\n        if(carry > 0){\n            res.add(0, carry);\n        }\n        return res;\n    }\n```\n\n  Time Complexity: O(max(N,M)) which N is length of num array and M is digit of k  <br/>\n  Space Complexity: O(max(N, M)) since we need to store the result and it is the longest number between length num array and digit of k <br/>\n## 思路\n#### 我需要把两个数相加，那我就只需要把每个digit的数相加然后除以10，余数就是现在的digit的数，如果超过10就加入carry 加到下一个digit 比如个位上 num array是5，k的个位是6，那最终结果的个位必然是1，我们把多出来的10加到十位数就行，具体可视化参照小学加法列式子","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186091786","body":"#### 思路\n- 先从左往右遍历整个string，遇到和c一样的字母，那它的distance就是0，往右的字母就以左边的这个字母为基准记录距离\n- 然后从右往左遍历整个string，同样道理，遇到和c一样的字母，那它的distance就是0，往左的字母就以这个字母为基准记录距离，但是需要和原本位置的array item比小，小的才是答案\n\n```java\npublic int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] res = new int[n];\n        int prev = Integer.MIN_VALUE / 2;\n        \n        for(int i = 0; i < n; i++){\n            if(s.charAt(i) == c) \n                prev = i;\n            \n            res[i] = i - prev;\n        }\n        \n        prev = Integer.MAX_VALUE / 2;\n        for (int i = n-1; i >= 0; --i) {\n            if (s.charAt(i) == c) \n                prev = i;\n            res[i] = Math.min(res[i], prev - i);\n        }\n\n        return res;\n    }\n```\nTime Complexity: O(N) -- loop through string twice, N is length of string <br/>\nSpace Complexity: O(N) -- we store the answer with an array in length N which is the length of string","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kernelsue":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185108946","body":"```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n\t\tLinkedList<Integer> list = new LinkedList<Integer>();\r\n    \t        int carry = 0;\r\n\t\tint i = num.length-1;\r\n    \twhile(i >= 0||k != 0){\r\n    \t\tif(k == 0 && carry == 0){\r\n    \t\t\tlist.push(num[i]);\r\n    \t\t\ti--;\r\n    \t\t\tcontinue;\r\n\t\t     }\r\n    \t\tint cur = carry + k%10;\r\n\t\tif(i >= 0)  cur += num[i];\r\n\t\tlist.push(cur%10);\r\n\t\tcarry = cur/10;\r\n\t\tk /= 10;\r\n\t\ti--;\r\n\t}\r\n    \tif(carry != 0){\r\n    \t\tlist.push(1);\r\n\t}\r\n    \treturn list;\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186394234","body":"```java\r\nclass CustomStack {\r\n\t     private int[] arr;\r\n\t     private int top;\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top != arr.length-1)\r\n            arr[++top] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top != -1){\r\n            top--;\r\n            return arr[top+1];\r\n        }else  return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int i = 0;\r\n        while(k != 0 && i <= top){\r\n            arr[i++] += val;\r\n            k--;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erikahuang":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185110660","body":"```\r\nclass Solution:\r\n    def listsum1(self, a: list[int], k: int) -> list[int]:\r\n        # 时间和空间复杂度都为O(n)\r\n        carry = 0\r\n        n = max(len(a), len(str(k))+1\r\n        res = [0] * n\r\n        a = [0] * (n-len(a)) + a\r\n\r\n        for i in range(n-1, -1, -1):\r\n            res[i] = a[i] + k % 10 + carry\r\n            carry = res[i] // 10\r\n            res[i] = res[i] % 10\r\n            k = k // 10\r\n\r\n        return res[1:] if res[0] == 0 else res\r\n\r\n    def listsum2(self, a: list[int], k: int) -> list[int]:\r\n        a = \"\".join(map(str,a))\r\n        res = int(a) + k\r\n        return list(map(int, str(res)))\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186078578","body":"## 思路\r\n\r\n> 三指针：slow指针指向目前的字符位置，fast1和fast2指向离s[solw]最近的两个'e'的位置。\r\n\r\n##代码\r\n\r\n```python\r\n#代码\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        from collections import defaultdict\r\n        s = list(s)\r\n        distance = [0]*len(s)\r\n        slow = fast1 = 0\r\n        fast2 = float(\"inf\")\r\n        while slow < len(s):\r\n            while fast1 < len(s) and s[fast1] != c:\r\n                fast1 +=1\r\n            while slow < len(s) and slow <= fast1:\r\n                if fast1 < len(s):\r\n                    distance[slow] = min(abs(fast1-slow), abs(fast2-slow))\r\n                    slow +=1\r\n                else:\r\n                    distance[slow] = abs(fast2-slow)\r\n                    slow +=1\r\n            fast2 = fast1\r\n            fast1 +=1\r\n        return distance\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186370986","body":"## 思路\r\n\r\n> 用list实现栈\r\n\r\n##代码\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        return self.stack.pop() if self.stack else -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i] +=val\r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: push-O(1);pop-O(1);inc-O(n)\r\n> + 空间复杂度:O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuang-mou":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185111126","body":"### 思路\r\n由于k的位数是小于等于A数组位数的，直接利用python转化为字符进行相加\r\n### 代码\r\n```class Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        s =  int(''.join(map(str,num))) + k\r\n        return [int(i) for i in str(s)]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186196104","body":"```\nclass Solution:\n    def shortestToChar(self, S: str, C: str) -> List[int]:\n        \n        return [min(abs(i- j)  for j in [i for i in range(len(S)) if S[i] == C]) for i in range(len(S))]\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iloveqier":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185112285","body":"```\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n    let narr = []\r\n    // k作为每一项都加的东西，余数是要存下的值，除数是下一次要加的东西\r\n    for (let i = num.length - 1; i > -1 || k > 0; i--, k = Math.floor(k / 10)) {\r\n        // 防止num遍历到最头部的时候，k依然有值,需要继续使用\r\n        if (i > -1) {\r\n            k = k + num[i]\r\n        }\r\n        narr.unshift(k % 10)\r\n    }\r\n    return narr\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186096624","body":"```js\nvar shortestToChar = function (s, c) {\n    let res = Array(s.length).fill(Infinity);\n    let cindexs = []\n   for(let i=0;i<s.length;i++){\n       if(s[i]===c) {\n           cindexs.push(i)\n           \n       }\n   }\n   for(let i=0;i<s.length;i++){\n       if(s[i]===c) {\n           res.push(0)\n           continue\n       }\n       for(let ci of cindexs) {\n           let distance = Math.abs(ci-i)\n           //当发现distance开始大于当前res[i]了，说明res[i]已经是最小距离了，后边只会越来越大\n           if(distance>res[i]) break\n           res[i] = distance\n       }\n\n   }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186360684","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.maxSize = maxSize\n    this.curSize = 0\n    this.stack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.curSize < this.maxSize) {\n        this.stack.push(x)\n        this.curSize++\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    if (this.curSize === 0) {\n        return -1\n    }\n    this.curSize--\n    return this.stack.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    this.stack.map((item,i)=>{\n        if(i<k){\n            this.stack[i] += val\n        }\n    })\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185112936","body":"## 思路\n    将数组从后往前加给k k每次取余作为结果 /10参与下一次运算\n## 复杂度\n    时间复杂度 O(max(n,m)) m n 为数组的长度 和k的长度 空间复杂度 O(n)\n## 代码\n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> result = new LinkedList<>();\n        for (int i = num.length - 1; i >= 0; i--) {\n            k += num[i];\n            result.addFirst(k % 10);\n            k /= 10;\n        }\n        while (k > 0) {\n            result.addFirst(k % 10);\n            k /= 10;\n        }\n        return result;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186101492","body":"## 思路 \n     从前到后一次判断c和当前位置的距离 再从后往前判断c和当前位置的距离 取较小的值作为结果\n## 复杂度\n    时间复杂度O(n) 空间复杂度O(n)\n## 代码\n```java\n  public int[] shortestToChar(String s, char c) {\n        char[] ss= s.toCharArray();\n        int[] result = new int[ss.length];\n        int temp = 1-s.length();\n        for(int i=0;i<ss.length;i++){\n            if(c!=ss[i]){\n                result[i] = i-temp;\n            }else{\n                temp = i;\n            }\n        }\n        temp= 0;\n        for(int i=result.length-1;i>=0;i--){\n            if(c!=ss[i]){\n                result[i] = Math.min(Math.abs(temp-i),result[i]);\n            }else{\n                temp = i;\n            }\n        }\n        return result;\n    }\n  ```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185118358","body":"### 思路\r\n按位依次相加\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int>res;\r\n        for(int i=num.size()-1;i>=0 || k>0;i--,k/=10){\r\n            if(i>=0){\r\n                k+=num[i];\r\n            }\r\n            res.push_back(k%10);\r\n        }\r\n        reverse(res.begin(),res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n* 时间复杂度：o(n)\r\n* 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186071498","body":"### 思路\n两次遍历，找到离得最近的C的距离\n### 代码\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int>res;\n        //从前遍历\n        int index=INT_MAX;\n        for(int i=0;i<s.size();i++){\n            if(s[i]==c){\n                index=i;\n            }\n            res.push_back(abs(i-index));\n        }\n        //从后遍历\n        index=INT_MAX;\n        for(int i=s.size()-1;i>=0;i--){\n            if(s[i]==c){\n                index=i;\n            }\n            res[i]=min(res[i],abs(index-i));\n        }\n        return res;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度:o(n)\n* 空间复杂度:o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186377067","body":"### 代码\n```C++\nclass CustomStack {\nprivate:\n    int cap;//最大容量\n    int top;//目前元素栈顶\n    int* arr;//数组指针\npublic:\n    CustomStack(int maxSize) {\n        cap=maxSize;\n        top=-1;\n        arr=new int[cap];\n    }\n    ~CustomStack() {\n        delete [] arr;\n    }\n    \n    void push(int x) {\n        if(top<cap-1){\n            arr[++top]=x;\n        }\n    }\n    \n    int pop() {\n        if(top==-1)return -1;\n        return arr[top--];\n    }\n    \n    void increment(int k, int val) {\n        int board=min(k,top+1);\n        for(int i=0;i<board;i++){\n            arr[i]+=val;\n        }\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ashleyyma6":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185118412","body":"### Idea\n\nInput: an int in array form **num**, an int **k** to add\nOutput: result in array form\n\n1. array to int, add k, int to array\n   ~~2. int k to array, add array~~\n\n### Code\n\n```python\n    def addToArrayForm(self, num, k):\n        # array to int\n        int_res = int(''.join(str(n) for n in num))\n        int_res+=k\n        # int to array\n        res = [int(n) for n in str(int_res)]\n        return res\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)+O(n) = O(n)\n- Space Complexity: O(1)+O(n) = O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186139244","body":"### Idea\n- 1st loop: find all indices of *c*\n- 2nd loop: get abs min for all elements in *s*\n### Code\n```python\ndef shortestToChar(self, s, c):\n        index = []\n        res = [0]*len(s)\n        for i in range(len(s)):\n            if s[i] == c:\n                index.append(i)\n        for i in range(len(s)):\n            if i in index:\n                res[i]=0\n            else:\n                res[i] = min([abs(i-x) for x in index])\n        return res\n```\n\n**Complexity Analysis**\n- Time Complexity: O(n^2)\n- Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186342266","body":"### Idea\n- array with 2 pointers\n- 1 pointer for stack top, help to judge if exceed max size\n- 1 pointer for stack base & increment function, help to judge if empty\n- check max & update base when push/pop\n- increment: compare k with current top index -> decide the number of element to update\n\n### Code\n\n```python\ndef __init__(self, maxSize):\n        self.stack = [0]*maxSize\n        self.max = maxSize-1 # max index\n        self.base = -1\n        self.top = -1\n\n    def push(self, x):\n        if self.top<self.max:\n            if(self.top<0):\n                self.base+=1\n            self.top+=1\n            self.stack[self.top]=x\n        \n    def pop(self):\n        if self.top>=0 :\n            res = self.stack[self.top]\n            self.stack[self.top] = 0\n            self.top-=1\n            if(self.top<0):\n                self.base-=1\n            return res\n        else:\n            return -1\n        \n    def increment(self, k, val):\n        if(self.base>=0):\n            if (self.top+1)>=k:\n                for i in range(k):\n                    self.stack[i]+=val\n            else:\n                for e in range(self.top+1):\n                    self.stack[e]+=val\n\n```\n\n**Complexity Analysis**\n- Time Complexity: \n  - push: O(1)\n  - pop:O(1)\n  - increment: O(n)\n- Space Complexity: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuki-yzy":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185123309","body":"# 思路\n\n将num与k末位相加，加到k上，k中自动进位，只需将k取余放入数组中即可\n\n# 代码\n\n\n```js\nvar addToArrayForm = function(num, k) {\n    let res = []\n    let len = num.length - 1\n    while(len >= 0 || k > 0) {\n        if(len >= 0) {\n            k += num[len]\n            len--\n        }\n        res.push(k % 10)\n        k = parseInt(k / 10)\n    }\n    return res.reverse()\n};\n```\n\n# 复杂度\n\n时间：O(n)\n\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186075915","body":"# 思路\n\n从S[i]位置开始，分别向左和向右进行搜索，取最小距离存到数组中\n\n# 代码\n\n```js\nvar shortestToChar = function (S, C) {\n  var res = Array(S.length).fill(0);\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    let l = i,r = i,min = Infinity;\n    while (l >= 0) {\n      if (S[l] === C) {\n        min = Math.min(min, i - l);\n        break;\n      }\n      l--;\n    }\n    while (r < S.length) {\n      if (S[r] === C) {\n        min = Math.min(min, r - i);\n        break;\n      }\n      r++;\n    }\n    res[i] = min;\n  }\n  return res;\n};\n```\n\n# 复杂度\n\n时间：O(n)\n\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186353755","body":"# 思路\n\n设置最大容量，维护一个stack\n\n# 代码\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.stack =[]\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length >= this.maxSize) {\n        return\n    }\n    this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.stack.length ? this.stack.pop() : -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let len = Math.min(k,this.stack.length)\n    for(let i = 0;i < len;i++) {\n        this.stack[i] += val\n    }\n};\n```\n\n# 复杂度\n\n时间:O(n)\n\n空间:O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpc7":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185132808","body":"### 思路\n一开始没考虑到大数的运算会丢失精度, 还说题目简单;\n参考的题解用了通用的方法\n### 代码 TS\n```ts\n// 一开始没有考虑到大数计算的进度丢失情况, 使用了下面的写法\n// function addToArrayForm(num: number[], k: number): number[] {\n//     const sum: number = Number(num.join('')) + k;\n\n//     return (sum + '').split('').map(item => Number(item));\n// };\n\nvar addToArrayForm = function (num: number[], k: number): number[] {\n    const res = [];\n    const n = num.length;\n\n    // 从低位加到高位, 所以采用从大到小的顺序循环\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n\n        // 需要进位的情况, 将进位加在K上, 便于下一次循环\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    // 考虑nums比较小, K比较大的情况, 循环结束后, K还有值, 例如:111+88888, 需要将他补充回数组\n    while (k > 0) {\n        res.push(k % 10);\n        k = Math.floor(k / 10)\n    }\n    // 不采用反转的话, 每次都需要在数组最前面插值(shift), 时间复杂度高\n    return res.reverse();\n};\n```\n### 复杂度\n时间 O(n)\n空间 O(1) ? 不太确定, 没太搞懂空间复杂度的分析, 求大佬解答","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186154745","body":"## 思路\n先存下所有的c在原数组中的位置; 然后遍历的时候, 对比距离取得最小值\n## 代码 TS\n```ts\nfunction shortestToChar(s: string, c: string): number[] {\n    // 存储匹配字符'c'在原数组中的索引\n    const indexArr: number[] = [];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === c) {\n            indexArr.push(i);\n        }\n    }\n\n    const res = [];\n\n    // 计算s的每一项索引, 与indexArr绝对值, 然后取最小的\n    for (let index = 0; index < s.length; index++) {\n        if (s[index] === c) {\n            res[index] = 0;\n        } else {\n            const indexDistanceArr: number[] = indexArr.map(item => Math.abs(item - index));\n            res[index] = Math.min(...indexDistanceArr);\n        }\n    }\n\n    return res\n};\n```\n## 复杂度\n时间: O(n2)\n空间: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yujian920":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185136875","body":"### 思路\r\n\r\n暴力解法：字符串转换，然后用 BigInt 转换保证大数精度不丢失\r\n### 代码\r\n\r\n\r\n```typescript（此处换成你的语言，比如js，py 等）\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n  return (BigInt(num.join(\"\")) + BigInt(k)).toString().split(\"\").map(item => Number(item))\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，类型转换部分时间复杂度不会算，余下部分应该是 O(2*n)也就是 O(n)\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kiirii4":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185137931","body":"### 思路\n将num[n-1]相加赋值于k，对其结果求余，作为该位的值，k / 10 的结果再和num[n-2]相加，对其结果求余，作为该位的值，以此类推\n\n### 代码\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> vec;\n        int len = num.size();\n        for(int i = len - 1; 0 <= i || k >= 1; i--, k /= 10){\n            if( i >= 0){\n                k += num[i];\n            }\n            vec.push_back(k % 10);\n        }\n        reverse(vec.begin(), vec.end());\n        return vec;\n    }\n};\n```\n### 复杂度分析\n时间：O(max(n,logk) <n为输入数组长度 >\n空间：O(1) 除返回值外，所用空间为常数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186083081","body":"### 思路\n打算遍历string的每个字符，再从每个被指向的字符派出两个指针分别从左右同时遍历至string的边界，若元素与c相等，则将计算相对位置差来赋值。\n### 代码\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> answer(n,-1);\n        for(int i = 0 ; i < n; ++i){\n                if(s[r] == c){\n                    answer[i] = i - l;\n                    break;\n                }\n            }\n            for(int r = i; r < n; ++r){\n                if(s[r] == c && answer[i] != -1){\n                    answer[i] = min(answer[i], r - i);\n                    break;\n                }\n                else if(s[r] == c){\n                    answer[i] = r - i;\n                    break;\n                }\n            }\n        }\n        return answer;\n    }\n};\n```\n### 复杂度分析\n时间：O(n^2)\n空间：O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186395331","body":"## 思路\r\npush和pop操作只是基于数组的限制操作，\r\nincrement操作为了和其他操作一样消耗常数时间，额外维护一个数组储存每一位的增量，在元素被pop出时再添加上\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass CustomStack {\r\npublic:\r\n    vector<int> vec, add;\r\n    int top = -1;\r\n    CustomStack(int maxSize) {\r\n        vec.resize(maxSize);\r\n        add.resize(maxSize);\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top != vec.size() - 1){\r\n            top++;\r\n            vec[top] = x;\r\n        }\r\n    } \r\n    \r\n    int pop() {\r\n        if(top == -1)\r\n            return -1;\r\n        int ret = vec[top] + add[top];\r\n        if(top != 0){\r\n            add[top - 1] += add[top];\r\n        } \r\n        add[top] = 0; \r\n        top--;\r\n        return ret;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int lim = min(k - 1 , top);\r\n        if(lim >= 0)\r\n            add[lim] += val;\r\n        } \r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n## 复杂度分析\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ucashurui":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185141689","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n## 思路\n\n---\n\n从低位按位进行相加，记录进位，前面位置不够了插入新的位。（看了题解还是借助str来偷懒比较方便啊！）\n\n## 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        count = len(num) - 1\n        while k or carry:\n            if count < 0:\n                num.insert(0,0)\n                count = 0\n            single_k = k % 10\n            k //= 10\n            num[count] += single_k + carry\n            carry = num[count] // 10\n            num[count] %= 10\n            count -= 1\n        return num\n```\n\n## 复杂度\n\n---\n\n- ****Time:**** $O(N)$，\n- ***Space:** $O(N)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186122298","body":"[Link to LeetCode Problem](https://leetcode.cn/problems/shortest-distance-to-a-character/submissions/)\n\n## 思路\n\n---\n\n从左和从右分别遍历一遍，找到和目标字符最近的距离\n\n## 代码\n\n---\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        num_char = len(s)\n        answer = [num_char for _ in range(num_char)]\n        # find left closest\n        cur_dist = num_char\n        for i in range(num_char):\n            if s[i] == c: \n                cur_dist = 0\n            else: \n                cur_dist += 1\n            answer[i] = cur_dist\n        # find right closest\n        cur_dist = num_char\n        for i in range(num_char):\n            if s[num_char - 1 - i] == c:\n                cur_dist = 0\n            else:\n                cur_dist += 1\n            answer[num_char - 1 - i] = min(answer[num_char - 1 - i], cur_dist)\n        return answer\n```\n\n## 复杂度分析\n\n---\n\n- ****Time:**** $O(N)$\n- ***Space:** $O(N)$*","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185141987","body":"### Idea\nTake K as a carry and add it to the lowest digit, then update carry, and keep going to higher digit.\n\n\n### Code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int cur = k;\n        int i = num.length - 1;\n        while(i >= 0 || cur > 0) {\n            if(i >= 0) {\n                cur = cur + num[i--];\n            }\n            res.add(cur % 10);\n            cur /= 10; \n        }\n        \n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(max(n, logk)), n is the length of num\n- Space complexity: O(max(n, logk))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186075682","body":"### Idea\nLoop twice on the string S.\nFirst forward pass to find shortest distant to character on left.\nSecond backward pass to find shortest distant to character on right.\n\n\n### Code\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] answer = new int[len];\n        int d = len;\n        for(int i = 0; i < len; i++) {\n            d = s.charAt(i) == c ? 0 : d + 1;\n            answer[i] = d;\n        }\n        \n        d = len;\n        for(int i = len - 1; i >= 0; i--) {\n            d = s.charAt(i) == c ? 0 : d + 1;\n            answer[i] = Math.min(answer[i], d);\n        }\n        \n        return answer;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n), n is the length of string s\n- Space complexity: O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185152522","body":"### 思路\r\n\r\n大数加法的阉割版，将 K 看作是每次加法的进位即可。\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  const { length } = num;\r\n\r\n  let carry = k;\r\n  for (let i = length - 1; i >= 0; i--) {\r\n    const value = (num[i] + carry) % 10;\r\n    carry = Math.floor((num[i] + carry) / 10);\r\n    num[i] = value;\r\n  }\r\n\r\n  while (carry) {\r\n    num.unshift(carry % 10);\r\n    carry = Math.floor(carry / 10);\r\n  }\r\n\r\n  return num;\r\n};\r\n```\r\n\r\n+ 时间复杂度 $O(N + logK)$, N 为传入数据 num 的长度, K 是传入的数字，logK 表示数字K的位数\r\n+ 空间复杂度 $O(N + logK)$, N 为传入数据 num 的长度, K 是传入的数字，logK 表示数字K的位数\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heng518":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185153547","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int len = num.size() - 1;\n        bool flag = true;\n        \n        while(len >= 0 || k > 0)\n        {\n            if(flag)\n            {\n                if(len >= 0)\n                {\n                    k += num[len];\n                    len--;\n                }\n                res.insert(res.begin(), k % 10);\n                k /= 10;\n            \n                if(k == 0)\n                    flag = false;\n            }\n            else\n            {\n                res.insert(res.begin(), num[len]);\n                len--;\n            }\n        }\n        \n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186186039","body":"class Solution {\npublic:\n vector<int> shortestToChar(string s, char c) {\n        vector<int> vec;\n        vector<int> res;\n        \n        for(int i = 0; i < s.size(); i++)\n            if(s[i] == c)\n                vec.push_back(i);\n        \n        for(int i = 0; i < s.size(); i++)\n        {\n            int temp = INT_MAX;\n            for(int j = 0; j < vec.size(); j++)\n            {\n                temp = min(temp, abs(vec[j] - i));\n            }\n            res.push_back(temp);\n        }\n        \n        return res;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185155634","body":"\n## 题目地址()\nhttps://leetcode.cn/problems/add-to-array-form-of-integer/submissions/\n\n## 前置知识\n\n- 数组的遍历，栈\n\n\n\n## 思路\n-逐位相加\n\n\n## 代码\n\n- 语言支持：JavaScript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let result = [];\n    const n = num.length;\n    //数组遍历循环\n    for(let i = n - 1; i>= 0; i--)\n    {\n        let sum = num[i] + k%10 ;\n        k = Math.floor(k/10);\n        if(sum >= 10)\n        {\n            k++;\n            sum -=10;\n        }\n        result.push(sum);\n    }\n    //如果出现num循环后k还有剩余则需要进行下面循环\n    for(;k>0;k = Math.floor(k/10))\n    {\n        result.push(k % 10);\n    }\n    //由于利用栈的push，所以是先进后出，所以应当将其逆序\n    result.reverse();\n    return result;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$，for循环遍历\n- 空间复杂度：$O(n)$，创建新的空间存放结果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186208679","body":"\r\n## 题目地址()\r\n\r\nhttps://leetcode.cn/problems/shortest-distance-to-a-character/submissions/\r\n\r\n\r\n## 前置知识\r\n\r\n- 数组的遍历\r\n\r\n\r\n## 思路\r\n首先从左往右遍历字符串s,记录左边最后一个出现的坐标；\r\n然后从右到左遍历，判断到右侧的c字符的距离是否比到左侧距离小或者左侧没有c字符的字符，则进行替换c字符的坐标；\r\n\r\n## 关键点\r\n\r\n-  如何获取距离最小值\r\n\r\n## 代码\r\n\r\n- 语言支持：Javascript\r\n\r\nJavascript\r\n\r\n```Javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let res = Array(s.length);\r\n\r\n    //贪心法\r\n    //先从左到右遍历\r\n    for(let i = 0 ;i <s.length ; i++)\r\n    {\r\n        if(s[i] === c)\r\n        {\r\n            res[i] = i;\r\n        }else{\r\n            //void 0 == undefined)，如果左侧没有出现过c字符，则为Infinity\r\n            res[i] = (res[i-1] === void 0 ? Infinity : res[i-1]);\r\n        }\r\n    }\r\n    //从右往左遍历\r\n    for(let i = s.length -1; i>= 0;i--)\r\n    {\r\n        //如果左侧没有c字符或者右侧出现的c字符距离更近，就更新\r\n        if(res[i] === Infinity || res[i+1] - i < i- res[i])\r\n        {\r\n            res[i] = res[i+1];\r\n        }\r\n    }\r\n    for(let i = 0 ;i <res.length ; i++){\r\n        res[i] = Math.abs(res[i] - i);\r\n    }\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tlntin":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185157127","body":"1. [题目链接](https://leetcode.cn/problems/add-to-array-form-of-integer/submissions/)\r\n\r\n### 简单理解\r\n- 从低位往高位计算，逢十进一。数组直接从右往左数，而数字的话，每次求10的余数，求完后除10即可。\r\n- 如果数组size不够，那就再首位插入元素1实现进1操作。\r\n- 后面发现可能k比num长。所以还需要把多余的k插入到num中。\r\n- 最后输出结果即可。可以用std::move(num)直接将值移出，防止重复拷贝，节省内存。\r\n\r\n### 最终代码\r\n```bash\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n    // 反向迭代，利用加法进位来计算\r\n    int temp = 0;\r\n    int n = num.size();\r\n    for (int i = 0; i < num.size(); ++i) {\r\n      temp = num[n - i - 1] + k % 10;\r\n      k = k / 10;\r\n      num[n - i - 1] = temp % 10;\r\n      if (temp >= 10) {\r\n        if (n - i - 2 >= 0) {\r\n          num[n - i - 2] += 1;\r\n        } else {\r\n          n += 1;\r\n          num.insert(num.begin(), 1);\r\n        }\r\n      }\r\n    };\r\n    // 补丁，k可能比Num长，需要将k剩余部分插入\r\n    while (k > 0) {\r\n      num.insert(num.begin(), k % 10);\r\n      k = k / 10;\r\n    }\r\n    return std::move(num);\r\n  }\r\n};\r\n\r\n\r\n\r\nint main() {\r\n  std::vector<int> v1 = {1,3,8};\r\n  int data = 955;\r\n  Solution s;\r\n  std::vector<int> v2 = s.addToArrayForm(v1, data);\r\n  for (const int & x: v2) {\r\n    std::cout << x << \" \";\r\n  }\r\n  std::cout << std::endl;\r\n}\r\n```\r\n\r\n### 结果\r\n![image](https://user-images.githubusercontent.com/28218658/179150726-78be3d31-e26a-4c6f-812a-8add0dae6953.png)\r\n\r\n用时：24ms，内存25.8MB。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186080712","body":"- 题目[链接](https://leetcode.cn/problems/shortest-distance-to-a-character/submissions/)\r\n### 解题思路\r\n- 左右两边各遍历一次，分别获取邻接最近值，然后用min函数对比两者谁更小。\r\n- 直接string可以改成cosnt string &,减少数据拷贝。\r\n- 返回还是直接用std::move，减少内存拷贝，直接移动结果。\r\n\r\n\r\n### 代码\r\n```cpp\r\n// Copyright 2022\r\n#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n\r\nusing std::vector;\r\nusing std::string;\r\n\r\nclass Solution {\r\n public:\r\n  vector<int> shortestToChar(const string & s, char c) {\r\n    // 前向遍历，假设c在最后一个位置\r\n    std::vector<int> result(s.size(), 0);\r\n    int index = s.size() - 1;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n      if (s[i] == c) {\r\n        index = i;\r\n      } else {\r\n        result[i] = abs(i - index);\r\n      }\r\n    }\r\n    // 后向遍历，假设c再第一个位置\r\n    index = 0;\r\n    for (int i = s.size() - 1; i >= 0; --i) {\r\n      if (s[i] == c) {\r\n        index = i;\r\n      } else {\r\n        // 此处结果取短距离\r\n        result[i] = std::min(result[i], abs(i - index));\r\n      }\r\n    }\r\n    return std::move(result);\r\n  }\r\n};\r\n\r\n\r\nint main() {\r\n  std::string str(\"loveleetcode\");\r\n  char c1 = 'e';\r\n  Solution s;\r\n  std::vector<int> res = s.shortestToChar(str, c1);\r\n  for (const int & x : res) {\r\n    std::cout << x << \" \";\r\n  }\r\n  std::cout << std::endl;\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n1. 时间复杂度：$O(n)$，一层遍历。\r\n2. 空间复杂度：$O(n)$，因为构建了一个数组，且数组内存无法避免，当然可以用std::move做一些空间优化。\r\n\r\n### 优化思路1：\r\n- 第二次遍历的时候，初始值其实就是上一次的最终索引，并且可以优化一下，将一个n遍历拆分成index右边与左边，去掉abs函数，减少n次if判断。\r\n- 优化后时间复杂度与空间复杂度不变。\r\n\r\n```cpp\r\n// Copyright 2022\r\n#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n\r\nusing std::vector;\r\nusing std::string;\r\n\r\nclass Solution {\r\n public:\r\n  vector<int> shortestToChar(const string & s, char c) {\r\n    // 前向遍历，假设c在最后一个位置\r\n    std::vector<int> result(s.size(), 0);\r\n    int index = s.size() - 1;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n      if (s[i] == c) {\r\n        index = i;\r\n      } else {\r\n        result[i] = abs(i - index);\r\n      }\r\n    }\r\n    // 后向遍历1，此时已经知道了index的初始值, index右边的均大于index\r\n    // 并且不需要判断s[i] == c\r\n    for (int i = s.size() - 1; i > index; --i) {\r\n        // 此处结果取短距离\r\n        result[i] = std::min(result[i], i - index);\r\n      }\r\n    // 后向遍历2，此时i恒小于index\r\n    for (int i = index; i >= 0; --i) {\r\n      if (s[i] == c) {\r\n        index = i;\r\n      } else {\r\n        // 此处结果取短距离\r\n        result[i] = std::min(result[i], index - i);\r\n      }\r\n    }\r\n    return std::move(result);\r\n  }\r\n};\r\n\r\n\r\nint main() {\r\n  std::string str(\"loveleetcode\");\r\n  char c1 = 'e';\r\n  Solution s;\r\n  std::vector<int> res = s.shortestToChar(str, c1);\r\n  for (const int & x : res) {\r\n    std::cout << x << \" \";\r\n  }\r\n  std::cout << std::endl;\r\n}\r\n```\r\n\r\n### 成果\r\n![image](https://user-images.githubusercontent.com/28218658/179337923-38b90c6a-552a-4a13-8e33-e7122dba3a55.png)\r\n\r\n执行用时：0ms(估计是bug)，内存6.6MB。\r\n### 优化思路2：\r\n- 既然后向遍历可以通过拆分来取消abs操作，前向遍历也是可以这么干的。\r\n- 先取index=n-1;并且result[i] = index - i;当出现`s[i] == c`，直接break出来，进行后续循环。\r\n- 后续循环时候，result[i] = i - index。这样abs函数就彻底消除了，又少了n个if，应该能再快一些。\r\n- 暂时就不写代码了，感兴趣的自行测试。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186382804","body":"- 题目[链接](https://leetcode.cn/problems/design-a-stack-with-increment-operation/submissions/)\n\n### 解题思路\n- 就是简单设计一个栈就行了，比较常规的数据结构题目\n- 唯一就是多了一个批量增加栈底n个元素值的功能，需要加一个min操作。\n- 由于max_size固定，所以采用数组做栈，而不是用链表或者动态数组。\n\n### 代码\n```cpp\n// Copyright 2022\n#include <iostream>\n\nclass CustomStack {\n private:\n  int * data;\n  int max_size;\n  int top;\n\n public:\n  explicit CustomStack(int maxSize): max_size(maxSize), top(0) {\n    data = new int[maxSize];\n  }\n  ~CustomStack() {\n    delete [] data;\n  }\n\n  void push(int x) {\n    if (top < max_size) {\n      data[top] = x;\n      ++top;\n    }\n  }\n\n  int pop() {\n    if (top > 0) {\n      --top;\n      return data[top];\n    } else {\n      return -1;\n    }\n  }\n\n  void increment(int k, int val) {\n    k = std::min(k, top);\n    for (int i = 0; i < k; ++i) {\n      data[i] += val;\n    }\n  }\n};\n\n\n\nint main() {\n  CustomStack stack(3);\n  stack.push(1);\n  stack.push(2);\n  std::cout << stack.pop() << std::endl;\n  stack.push(2);\n  stack.push(3);\n  stack.push(4);\n  stack.increment(5, 100);\n  stack.increment(2, 100);\n  std::cout << stack.pop() << std::endl;\n  std::cout << stack.pop() << std::endl;\n  std::cout << stack.pop() << std::endl;\n  std::cout << stack.pop() << std::endl;\n}\n```\n\n\n### 复杂度分析\n|            | push   | pop    | increment |\n| ---------- | ------ | ------ | --------- |\n| 时间复杂度 | $O(1)$ | $O(1)$ | $O(n)$    |\n| 空间复杂度 | $O(1)$ | $O(1)$ | $O(1)$    |\n\n\n\n### 成果\n\n![](https://s2.loli.net/2022/07/17/N4iGqMwluScfeE5.png)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richypang":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185158822","body":"## 代码（注释解析了每一步的思路）\n\nclass Solution:\n\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        #将数组转化为str形式存储\n        temp = \" \"\n        for i in num:\n            temp = temp + str(i)\n        #整数相加\n        number = int(temp) + k\n        result = []\n        for j in str(number):\n            result.append(int(j))\n        return result\n## 复杂度 \n\n时间复杂度 O(n)\n空间复杂度O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186111174","body":"## 思路\n\n>1.先试用一次循环记录下所有c出现的位置并记录在have_c中\n\n>2.再次循环每一个字母，利用其所在的index分别与have_c相减获取其绝对值并记录最小值\n将最小值记录在result中输出\n\n##代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        have_c = []\n        for i in range(len(s)):\n            if s[i] == c:\n                have_c.append(i)\n        print(have_c)\n        result = []\n        for i in range(len(s)):\n            if s[i] == c:\n                result.append(0)\n            else:\n                min = 99999999999\n                for j in range(len(have_c)):\n                    if min > abs(have_c[j] - i):\n                        min = abs(have_c[j] - i)\n                result.append(min)\n        return result\n\n\n```\n\n## 复杂度\n\n> + 时间复杂度: O(n^2)\n> + 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186411631","body":"## 思路\r\n\r\n> 注意push时不超过最大maxsize，pop时stack仍有数字\r\n\r\n##代码\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.max_len = maxSize\r\n        self.current_len = 0\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_len:\r\n            self.stack.append(x)\r\n            self.current_len += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) == 0: return -1\r\n        else:\r\n            self.current_len -= 1\r\n            return self.stack.pop()\r\n\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        less = min(k,len(self.stack))\r\n        for i in range(0,less):\r\n            self.stack[i] += val\r\n\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: pop push 为O(1) increment 为O(n)\r\n> + 空间复杂度: O(maxsize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fenchuiyun":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185161504","body":"### 思路\r\n目标：实现两个大非负整数相加<br>\r\n背景：像整型integer和long的数据都是有数据范围的\r\n\r\n### 代码\r\n```java\r\n    class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n                // 先把k转换为数组\r\n        char[] chars = String.valueOf(k).toCharArray();\r\n        int maxLength = Math.max(num.length,chars.length);\r\n        int minLength = Math.max(num.length,chars.length);\r\n        int tmp = 0;\r\n        int[] result = new int[maxLength + 1];\r\n        for (int offset = 0; offset < minLength; offset++) {\r\n            int numIdx = num.length - 1 - offset;\r\n            int charsIdx = chars.length -1 - offset;\r\n            if (numIdx>=0&&charsIdx>=0){\r\n                int sum = chars[charsIdx]-'0'+num[numIdx]+tmp;\r\n                tmp = sum/10;\r\n                int y = sum%10;\r\n                result[maxLength-offset] = y;\r\n            }else if (numIdx>=0){\r\n                int sum = num[numIdx]+tmp;\r\n                tmp = sum/10;\r\n                int y = sum%10;\r\n                result[maxLength-offset] = y;\r\n            }else {\r\n                int sum = chars[charsIdx]-'0'+tmp;\r\n                tmp = sum/10;\r\n                int y = sum%10;\r\n                result[maxLength-offset] = y;\r\n            }\r\n        }\r\n        if (tmp!=0){\r\n            result[0] = tmp;\r\n        }\r\n        if (result[0]==0){\r\n            return Arrays.stream(result).skip(1).boxed().collect(Collectors.toList());\r\n        }else {\r\n            return Arrays.stream(result).boxed().collect(Collectors.toList());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186156714","body":"### 思路\n- 方法一：暴力破解，对象下标为i的元素，从数组nums中查找离下标i最近且值为target的下标。 \n- 方法二：两次遍历（今日学习到的），一次从左到右的便利，对于下标为i的数据，我们可以得到左边离它最近的位置，通过两次遍历可以解决问题。\n\n```java\n//方法一\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        // 方法一: 暴力算法\n        // 针对i下标的数据，在数组中查询最近的一个\n        char[] chars = s.toCharArray();\n        int[] result = new int[chars.length];\n        for (int i = 0; i < chars.length; i++) {\n            int offset = s.length();\n            result[i] = getLocalOffset(chars,c,i);\n        }\n        return result;\n    }\n\n    private  int getLocalOffset(char[] array, char target, int idx) {\n        char value = array[idx];\n        if (value==target){\n            return 0;\n        }\n        int tmp = 100000;\n        for (int i = 0; i < array.length; i++) {\n            if (array[i]==target&&Math.abs(i-idx)<tmp) {\n                tmp = Math.abs(i-idx);\n            }\n        }\n        return tmp;\n    }\n}\n```\n### 复杂度\n时间复杂度O(n^2)<br>\n空间复杂度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry-lllman":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185162752","body":"### 解题思路:\r\n从低位往高位处理\r\n1. 将 k 与 num[i] 相加, k += num[i]\r\n2. 将 k % 10 后添加到 res 中\r\n3. 每次遍历都将 k /= 10\r\n4. 返回 res\r\n\r\n### case:\r\n1. 注意 k / 10 需要处理浮点数的问题 k = Math.floor(k / 10)\r\n2. 当 i < 0 时（即num遍历完了，k仍有余值）不再需要 k += num[i]\r\n\r\n```ts\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n  const res = []\r\n  const leng = num.length\r\n  for (let i = leng - 1; i >= 0 || k > 0; i--, k = Math.floor(k / 10)) {\r\n    if (i >= 0) {\r\n      k += num[i]\r\n    }\r\n    res.push(k % 10)\r\n  }\r\n  res.reverse()\r\n  return res\r\n};\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186179190","body":"## 解题思路\n从中间往两边查找\n\n## 代码\n```ts\nfunction shortestToChar(s: string, c: string): number[] {\n  const leng = s.length\n  const ans: number[] = new Array(leng)\n  for (let i = 0; i < leng; i++) {\n    for (let j = 0; j < leng; j++) {\n      if (s[i + j] === c || s[i - j] === c) {\n        ans[i] = j\n        break\n      }\n    }\n  }\n  return ans\n};\n```\n\n## 复杂度分析\n时间复杂度：O(n2)，两层循环  \n空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nickyk319":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185163309","body":"### 思路\r\n\r\nSimulate the way we do addition manually.\r\n\r\n1. Iterate array from right to left\r\n2. Do addition between last element and integer K. \r\n3. Every time only keep the last digit of the result, and put it into a list. \r\n4. Forward the rest digits of the result to do summation with the previous element in the array. \r\n5. Repeat the above process until array out of index or the value been set to zero\r\n6. The reverse of the list will be the answer to return.\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n        ArrayList<Integer> ans = new ArrayList<>();\r\n        int curVal = k;\r\n        int i = len - 1;\r\n        while (i >= 0 || curVal > 0) {\r\n            if (i >= 0) {\r\n                curVal += num[i];\r\n            }\r\n            ans.add(curVal % 10);\r\n            curVal /= 10;\r\n            i--;\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为nums数组长度。\r\n- 空间复杂度：O(N)\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186387841","body":"### 思路\n\nUse ArrayList to simulate Stack\n\n### 代码\n\n\n```java\nclass CustomStack {\n    private int size;\n    private ArrayList<Integer> stack = new ArrayList<>();\n    public CustomStack(int maxSize) {\n       size = maxSize; \n    }\n    \n    public void push(int x) {\n        if (stack.size() < size) {\n            stack.add(x);\n        }\n    }\n    \n    public int pop() {\n        if (stack.isEmpty()) {\n            return -1;\n        } else {\n            return stack.remove(stack.size() - 1);\n        }\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i < stack.size(); ++i) {\n            stack.set(i, stack.get(i) + val);\n        }\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：increment is O(N)，push() and pop() are O(1)\n- 空间复杂度：O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"herbertpan":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185163334","body":"### Idea\n每次位移一个\n### Code\n``` \npublic List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new LinkedList<>();\n        //.       0 1 2\n        // num = [2,1,5], k = 1806\n        //            |         \n        //            5.   +     6. => 11 (1 % 1) ==> [1]\n        //           |\n        //           1     +.   0   => 1 + 0 + 1 = 2 ==> 2 % 0 ==> [2, 1]\n        //         |\n        //         2.      +.   8.  => 2 + 8 + 0 = 10 => 0 % 1 ==> [0, 2, 1]\n        //.      |\n        //.      0         +.   1   ==>. 0 + 1 + 1 == > 2 % 0 ==> [2, 0, 2, 1]\n        //      |\n        int bitIndex = num.length - 1;\n        int overFlow = 0;\n        while (k != 0 || bitIndex >= 0 || overFlow != 0) {\n            int valFromNum = bitIndex >= 0 ? num[bitIndex] : 0;\n            int valFromK = k % 10;\n            k = k / 10;\n            int numVal = valFromNum + valFromK + overFlow;\n            overFlow = numVal / 10;\n            ans.add(0, numVal % 10);\n            bitIndex--;\n        }\n        \n        return ans;\n    }\n```\n\n###  complexity\nTime: O(max (N, len(K)));\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186110330","body":"### Algo\n    // s: c xxxx c xxxx c xx c\n    //.     |\n    //.   |.     |\n    // -> 0 1234 0 1234 0 12 0\n    //    0 4321 0 4321 0 21 0 <-\n    //.   0 1221 0 1221 0 11 0\n    //.   xxx c xxx\n    //.   MMM 0 123\n    //.   321 0 MMM\n    // \n    // For any certain index, the closest distance from c, is either the occurence of c before it or after it\n    // so we can go through the array from head to tail, to count the distance from c before it\n    // and do it again from tail to head to count the distance from c after it.\n    // Take the min value as the answer.\n    // To count the distance, whenver met a c, refresh the distance to 0, and every movement plus 1 on the distance, start with distance as Integer.MAX_VALUE\n    \n\n### Code\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        Arrays.fill(ans, Integer.MAX_VALUE);\n        \n        int distance = Integer.MAX_VALUE;\n        for (int i = 0; i < ans.length; i++) {\n            if (s.charAt(i) == c) {\n                distance = 0;\n            } else {\n                distance = distance < Integer.MAX_VALUE ? distance + 1 : distance;\n            }\n            if (distance < ans[i]) {\n                ans[i] = distance;\n            }\n        }\n        distance = Integer.MAX_VALUE;\n        for (int i = ans.length - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                distance = 0;\n            } else {\n                distance = distance < Integer.MAX_VALUE ? distance + 1 : distance;\n            }\n            if (distance < ans[i]) {\n                ans[i] = distance;\n            }\n        }\n        \n        return ans;\n    }\n}\n```\n### Time Complexity\n1. Time: O(n)\n2. Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186360602","body":"### Algo\n//     Since we need to maintain \"random\" access which is not possible with stack/queue/deque\n//     so lets use array to mock a stack, luckily the array size is given.\n    \n//     1. we first init an array with length as maxSize, and maintain a pnt to indicate the next avaible slot\n//        so pnt == 0, means empty; pnt == arr.length means full\n//     2. for each push, check the pnt position; if available, insert into pnt and pnt++\n//     3. same logic for pop, return arr[pnt - 1] and pnt--;\n//     4. increment just start with index 0 till Min(pnt - 1, k);\n    \n### Code\n```java\nclass CustomStack {\n    private int[] arr;\n    private int nextAvailableSlot = 0;          //  |\n    public CustomStack(int maxSize) {           // [y,y,y]\n        arr = new int[maxSize];                 //. 0 1 2\n    }\n    \n    public void push(int x) {                    // [1,2,y]    // [1,2,y]\n        if (nextAvailableSlot < arr.length) {    //      |     //    |\n            arr[nextAvailableSlot] = x;                        //  [1,2,y]\n            nextAvailableSlot++;                               //.      |\n        }                                                      //  [1,2,3]\n    }                                                          //.         |\n    \n    public int pop() {\n        if (nextAvailableSlot != 0) {            // [1,2,y]\n            nextAvailableSlot--;                 //.   |\n            return arr[nextAvailableSlot];       //.   2\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int tillIndex = Math.min(k, nextAvailableSlot );   //  [1,2,3]           [1,2,3]        \n        for (int i = 0; i < tillIndex; i++) {              //.         |                 |\n            arr[i] += val;                                   // tillIndex = 3    tillIndex = min(2,3) = 2\n        }                                                  // [101, 102, 103]    [201, 202, 103]  \n    }\n}\n```\n### Complexity\n1. Time: O(1) for push and pop, O(k) for increment\n2. Space: O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsmmxmm":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185165999","body":"# 基本信息\n\n## 题号&链接\n\n****[989. 数组形式的整数加法](https://leetcode.cn/problems/add-to-array-form-of-integer/)****\n\n## 截图题面\n\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\n\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\n\n# UMPIRE\n\n## **U-nderstand**\n\n- `1 <= num.length <= Math.pow(10,4)`\n\n所以直接转换成integer不太行\n\n- 全都是正整数，不用考虑符号\n\n## **M-atch**\n\n从最后一位开始，一位一位加减，放进list里，然后reverse\n\n## 复杂度\n\n一次遍历 时间O(n)\n\n除结果外没有新增空间，这算O(n)?\n\n# Code\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        // int sum = 0;\n        // for(int i = 0; i < num.length; i++){\n        //     sum = sum * 10 + num[i];\n        // }\n        // sum += k;\n        // \n        // while(sum != 0){\n        //     res.add(sum % 10);\n        //     sum /= 10;\n        // }\n        // Collections.reverse(res);\n        // return res;\n\n        int pointer = num.length - 1;\n        int left = 0;\n        \n        while(pointer >= 0){\n            int temp = num[pointer] + k % 10 + left;\n            left = temp / 10;\n            temp = temp % 10;\n            res.add(temp);\n            k /= 10;\n            pointer--;\n            \n        }\n        while(k > 0){\n            int temp =  k % 10 + left;\n            left = temp / 10;\n            temp = temp % 10;\n            res.add(temp);\n            k /= 10;\n        }\n        if (left == 1){\n            res.add(left);\n        }\n        \n        Collections.reverse(res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186036688","body":"# 基本信息\n\n## 题号&链接\n\n****[821. 字符的最短距离](https://leetcode.cn/problems/shortest-distance-to-a-character/)****\n\n## 截图题面\n\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n# UMPIRE\n\n## **U-nderstand**\n\n- `1 <= s.length <= 104`\n- `s[i]` 和 `c` 均为小写英文字母\n- 题目数据保证 `c` 在 `s` 中至少出现一次\n\n## **M-atch**\n\n滑动窗口\n\n大while：右指针移动：\n\n小while：左指针不满足条件时移动→没和right相等时候：计算最短距离（区分targetChar在前面还是在后面，取最小值）left++，\n\n此时right == left，判断要不要更新preTarget，right++\n\n## **P-lan**\n\n补丁：right已经走完了，left没有：left补全\n\n## 复杂度\n\n时间：2次遍历 O(n)\n\n空间：除结果数组外常数级别新增：O(1)?\n\n# Code\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        int right = 0, left = 0;\n        int preTarget = -10000;\n        int max = 10000;\n        char[] sc = s.toCharArray();\n        while (left <= right && left < res.length && right < res.length){\n            res[right] = max;\n            while(sc[right] == c && left < right){\n                res[left] = Math.min(right - left, left - preTarget);\n                left++;\n            }\n            if(sc[right] == c) {\n                res[right] = 0;\n                preTarget = right;\n            }\n                right ++;\n        }\n        while(left < res.length){\n            res[left] = left - preTarget;\n            left++;\n        }\n        return res;\n    }\n}\n```\n\na","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186367229","body":"# 基本信息\n\n## 题号&链接\n\n****[1381. 设计一个支持增量操作的栈](https://leetcode.cn/problems/design-a-stack-with-increment-operation/)****\n\n## 截图题面\n\n```\n\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n```\n\n# UMPIRE\n\n## **M-atch**\n\n尴尬了，脑子里想着的是用栈做队列或者用队列做栈。\n\n写完看了题解发现可以用数组。\n\n## **P-lan**\n\n```java\nthis.maxSize = maxSize;\n这里我写错了一次\n```\n\n## 复杂度\n\n时间不会写\n\n空间O(maxSize)?\n\n# Code\n\n```java\nclass CustomStack {\n    Deque<Integer> deq;\n    int maxSize;\n\n    public CustomStack(int maxSize) {\n        deq = new ArrayDeque<Integer>();\n        this.maxSize = maxSize;\n\n    }\n    \n    public void push(int x) {\n        //System.out.println(\"deq.size()=:\"+deq.size()+\";maxSize=:\"+maxSize);\n        if(deq.size() < maxSize) {\n            deq.addLast(x);\n        }\n    }\n    \n    public int pop() {\n        if(!deq.isEmpty()){\n            return deq.pollLast();\n        }else{\n            return -1;\n        }\n\n    }\n    \n    public void increment(int k, int val) {\n        Deque<Integer> temp = new ArrayDeque<>();\n        int count = 0;\n        if(deq.size() <= k){\n            while(count < deq.size()){\n                deq.addFirst(deq.pollLast() + val);\n                count++;\n            }\n        }else{\n            while(count < k){\n                temp.addLast(deq.pollFirst() + val);\n                count++;\n            }\n            while(count > 0){\n                deq.addFirst(temp.pollLast());\n                count--;\n            }\n        }\n    }\n}\n```\n\na","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fan-svg":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185167863","body":"### 思路\n从最低位进行相加，大于10则向前一位加一\n### 代码\n``` C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        int sum = 0;\n\n        for(int i = n - 1; i >= 0; --i){\n            sum = num[i] + k % 10;\n            k /= 10;\n            if(sum>=10){\n                ++k;\n            }\n            res.push_back(sum%10);\n        }\n        while(k>0){\n            res.push_back(k%10);\n            k /= 10;\n        }\n\n        reverse(res.begin(),res.end());\n\n        return res;\n    }\n};\n```\n### 复杂度\n时间复杂度：O(max(n,log k))，最大不会超过O(n)\n\n空间复杂度：O(1)。使用的空间为常数\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186204571","body":"### 思路\n先从左往右遍历一遍字符串，记录与目标字符之间距离结果，再从右往左遍历一遍字符串，此时与目标字符之间距离结果需与从左往右的结果进行比较，选择较小的结果的为最终结果\n### 代码\n``` C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.length();\n        vector<int> res(n);\n        int pos = INT_MIN/2;\n        for(int i = 0; i < n; i++){\n            if(s[i]==c){\n                pos = i;\n            }\n            res[i] = i - pos;\n        }\n        pos = INT_MAX/2;\n        for(int i = n - 1; i >= 0; i--){\n            if(s[i] == c){\n                pos = i;\n            }\n            res[i] = min(res[i],pos - i);\n        }\n\n        return res;\n    }\n};\n```\n### 复杂度\n##### 时间复杂度：O(n),n为字符串长度\n##### 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzejia":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185168321","body":"## 思路\n\n+ 一开始想的 数组转化数学位数进行相加  A[i] * Math.pow(10, A.length - i - 1) 结果会出现计算不准确\n+ 采用 两数组从尾部开始相加。 大于 10 进一位; 最后一位相加 大于10 数组尾部 补 1；\n\n## 题解\n```\n// 采用 两数组 对应位数相加 大于 10 进一位; 最后一位相加 大于10 数组尾部 补 1；\nfunction addToArrayForm(A: number[], K: number): number[] { \n    let list = (K+'').split('')\n    let len_A = A.length - 1;\n    let len_K = list.length - 1;\n    let result = <any>[];\n    let n = 0\n    \n    // 两数组存在值 继续执行\n    while (A[len_A] >= 0  || Number(list[len_K]) >= 0) {\n\n        // 位数之和\n        let sum = Number(list[len_K] || 0) + ( A[len_A]?A[len_A] : 0 ) + n;\n\n        // 重置 n\n        n = 0\n        // 位数之和 是否 大于 10\n        if(sum >= 10) n = 1;\n\n        // 余数添加进去\n        result.push(sum%10);\n\n        // 递减\n        len_K--\n        len_A--\n    }\n\n    // 处理最后一位结果 大于 10 \n    if(n === 1) {\n        result.push(1);\n    }\n    \n\n    return result.reverse();\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186212500","body":"## 思路\n左右遍历 取最小值\n## 代码\n```\nfunction shortestToChar(s: string, c: string): number[] {\n  const n = s.length;\n  const result: number[] = [];\n  let ids = s.indexOf(c);\n\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) {\n      ids = i;\n    }\n    result[i] = Math.abs(ids - i);\n  }\n\n  ids = s.lastIndexOf(c);\n\n  for (let i = n - 1; i >= 0; i--) {\n    if (s[i] === c) {\n      ids = i;\n    }\n    result[i] = Math.min(result[i], Math.abs(ids - i));\n  }\n\n  return result;\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186379692","body":"## 思路\n使用数组模拟栈\n## 代码\n```\nclass CustomStack {\n  private _stack: number[] = []; // 栈\n  private _stackSize = -1; // 栈最大长度\n  constructor(maxSize: number) {\n    this._stackSize = maxSize;\n  }\n\n  push(x: number): void {\n    // 不能超过栈最大长度\n    if (this._stack.length === this._stackSize) return;\n    this._stack[this._stack.length] = x;\n  }\n\n  pop(): number {\n    // 栈空返回 -1\n    return this._stack.length === 0 ? -1 : this._stack.pop()!;\n  }\n\n  increment(k: number, val: number): void {\n    for (let i = 0; i < k; i++) {\n      this._stack[i] ? (this._stack[i] += val) : null;\n    }\n  }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunnyyujf":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185170165","body":"#### 代码 \n\n```Python\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i=len(num)-1\n        while k>0:\n            added = num[i]+k\n            num[i]=added%10  # remainder\n            k=added//10    # carry\n            i-=1\n            if i<0 and k>0:\n                num.insert(0,0)\n                i=0\n        return num\n```\n\n#### 复杂度分析\n时间复杂度： O(N)  </br>\n空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186052450","body":"### 思路 \n从左至右遍历s， 得到左边最近c的距离\n从右至左遍历s， 得到右边最近c的距离与左边最近c的距离的较小值\n#### 代码 Python\n\n```Python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        #time O(N) space O(N)\n        res=[float('inf')]*len(s)\n        last_c = float('inf')\n        for i in range(len(s)):\n            if s[i]==c:\n                last_c=i\n            res[i]=abs(last_c-i)\n        \n        for i in range(len(s)-1,-1,-1):\n            if s[i]==c:\n                last_c=i\n            res[i]=min(res[i],abs(last_c-i))\n        return res\n\n\n```\n\n#### 复杂度分析\n时间复杂度：O(N)    </br>\n空间复杂度：O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"phoenixflyingsky":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185170186","body":"### Idea\n\njust add the end of two numbers\n\n### Code\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int len = num.length;\n        int carry = 0;\n        int index = len - 1;\n\n        while(index >= 0 && k > 0) {\n            int temp = k % 10;\n            int total = temp + num[index] + carry;\n\n            //update\n            carry = total / 10;\n            total = total % 10;\n\n            //put the num to res\n            res.add(0, total);\n\n            //update\n            index--;\n            k = k / 10;\n        }\n\n        while(index >= 0) {\n            int total = num[index] + carry;\n\n            //update\n            carry = total / 10;\n            total = total % 10;\n\n            //put the num to res\n            res.add(0, total);\n\n            //update\n            index--;\n        }\n\n        while(k > 0) {\n            int total = k % 10 + carry;\n\n            //update\n            carry = total / 10;\n            total = total % 10;\n\n            //put the num to res\n            res.add(0, total);\n\n            //update\n            k = k / 10;\n        }\n\n        if(carry != 0) {\n            res.add(0, carry);\n        }\n\n        return res;\n\n    }\n}\n\n\n```\n\n**Complexity Analysis**\n- Time Complexity： O(N), N is the longest of the two lengths（num.length & k.length()）\n- Space Complexity： O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186150582","body":"### Idea\r\n- First loop: traverse from left to right to find the nearest c on the left.\r\n- Second loop:  traverse from right to left to find the nearest c on the right.\r\n### Code\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len]; \r\n\r\n        int minNum = Integer.MIN_VALUE / 2; //make sure the num is smaller enough\r\n        int pre = minNum; //the distance of the nearest C on the left\r\n        for(int i = 0; i < len; i++) {\r\n            if(s.charAt(i) == c) {\r\n                pre = i;\r\n            }\r\n\r\n            res[i] = i - pre;//make sure the distance of nearest C on the left\r\n        }\r\n\r\n        int maxNum = Integer.MAX_VALUE / 2; //make sure the num is larger enough\r\n        int later = maxNum; // the distance of the nearest C on the right\r\n        for(int i = len - 1; i >= 0; i--) {\r\n            if(s.charAt(i) == c) {\r\n                later = i;\r\n            }\r\n\r\n            res[i] = Math.min(res[i], (later - i));\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**Complexity Analysis**\r\n- Time Complexity： O(N) \r\n- Space Complexity： O(1) (  The return value is not included in the space complexity.  )\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nehchsuy":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185170845","body":"### 思路\r\n先同时加array和数字\r\n再while loop 只剩下数字或者只剩下数组的情况\r\n\r\n### 代码:\r\n\r\n\r\n\r\n          class Solution:\r\n                  def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n\r\n                       def add(index, k, num):\r\n                           carry = 0\r\n                          while index >= 0 and k:\r\n                              current = k % 10\r\n                              k = k // 10\r\n                              num[index] = num[index] + current + carry\r\n                              carry = 0\r\n                              if num[index] >= 10:\r\n                                  num[index] -= 10\r\n                                  carry = 1\r\n                              index -= 1\r\n                          \r\n                          while index >= 0 and carry:\r\n                              num[index] = num[index] + carry\r\n                              carry = 0\r\n                              if num[index] >= 10:\r\n                                  num[index] -= 10\r\n                                  carry = 1\r\n                              index -= 1\r\n                          \r\n                          k += carry\r\n                          while k:\r\n                              current = k % 10\r\n                              k = k // 10\r\n                              num = [current] + num\r\n                          return num\r\n                              \r\n                      \r\n                     return add(len(num) - 1, k, num)\r\n\r\n### 复杂度:\r\nTime: O(length of number + length of array) or O(N)\r\nSpace: O(length of number + length of array) or O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186082185","body":"### 思路\r\n\r\n先看最左最右是不是和c一样, 是一样设为0\r\n然后左往右, 右往左各遍历一次取上一个数 + 1和本数的最小值\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = [float('inf') for char in s]\r\n        \r\n        if s[0] == c:\r\n            ans[0] = 0\r\n        if s[-1] == c:\r\n            ans[-1] = 0\r\n        \r\n        for i in range(1, len(s)):\r\n            if s[i] == c:\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(ans[i - 1] + 1, ans[i])\r\n                \r\n        for j in range(len(s) - 2, -1, -1):\r\n            if s[j] == c:\r\n                ans[j] = 0\r\n            else:\r\n                ans[j] = min(ans[j + 1] + 1, ans[j])\r\n        \r\n        return ans\r\n```\r\n### 复杂度\r\n时间复杂度 O(2 * 数组size) = O(n)\r\n空间复杂度 答案size O(n)\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186278497","body":"### 思路\n\n正常stack操作, 动态数组更新val\n\n### 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.nums = []\n        self.size = 0\n        self.limit = maxSize\n\n    def push(self, x: int) -> None:\n        if self.size >= self.limit:\n            return\n        self.nums.append(x)\n        self.size += 1\n        return\n\n    def pop(self) -> int:\n        if not self.nums:\n            return -1\n        num = self.nums.pop()\n        self.size -= 1\n        return num\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.size)):\n            self.nums[i] += val\n        return\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### 复杂度分析\n\n时间复杂度: push / pull O(1), 改变增量 O(n)\n\n空间复杂度: O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzyxts":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185188366","body":"### Idea\n\n从后往前加，while loop中更新list&integer\n\n### Code\n\n\n```python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        digit = 0\n        \n        while num or k or digit:\n            n1 = num[-1] if num else 0\n            n2 = k%10\n\n            n = n1+n2+digit\n            \n            res.insert(0, n%10)\n            digit = 1 if n>= 10 else 0\n            \n            num = num[:-1]\n            k = k//10\n                \n        return res\n```\n\n### Complexity\n- Time：O(N)\n- Space：O(N) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185975634","body":"### Idea\n\n- 找出 `==c` 的所有index positions, store in `pos`\n- j 表示 在s中的current index\n- i，k表示在`pos`中，相邻于j的index\n\n### Code\n\n```python3\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pos = []\n        res = []\n        \n        for i in range(len(s)):\n            if s[i] == c:\n                pos.append(i)\n        \n        \n        i,j,k = 0,0,0\n        \n        while j < len(s):\n            if i == len(pos):\n                res.append(abs(pos[i-1]-j))\n                j+=1\n                \n            elif j <= pos[i]:\n                a = abs(pos[i]-j)\n                b = abs(pos[k]-j)\n                res.append(min(a,b))\n                j += 1\n                \n            else:\n                if i != 0:\n                    k+=1\n                i+=1\n\n        return res\n```\n\n### Complexity\n- Time：O(N)\n- Space：O(N) as `res` will extend?","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elainekuo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185190357","body":"### 思路\r\n\r\n逐位相加\r\n\r\n### 代码\r\n\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];\r\n    let len = num.length;\r\n    for(let i=len-1; i>=0;i--){\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if(sum>=10){\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);  \r\n    }\r\n    for(let i =k;i>0;i=Math.floor(i/10)){\r\n        res.push(i % 10)\r\n    }\r\n    res.reverse();\r\n    return res;\r\n\r\n};\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186100713","body":"\n### 思路\n\n先获取字符在字符串中的所有位置，然后遍历算出最小距离\n\n### 代码\n\n\n```js\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let targetS = getCharactorIndex(s,c);\n    let res = [];\n    for(let i=0; i<s.length; i++){\n        let min = Number.MAX_SAFE_INTEGER;\n        for(let j=0;j<targetS.length;j++){\n            min = Math.min(min,Math.abs(targetS[j] - i));\n        }\n        res.push(min);\n    }\nreturn res;\n\n};\n\nconst getCharactorIndex = (s,c) =>{\n    let res = [];\n    let charactorArray = s;\n    let idx = charactorArray.indexOf(c);\n    let num = 0;\n    while(idx != -1){\n        res.push(idx);\n        num++\n        idx = charactorArray.indexOf(c,idx+1);\n    }\n    return res;\n\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n^2)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186371345","body":"\n### 思路\n\n数组实现栈\n\n### 代码\n\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = [];\n    this.n = maxSize;\n\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length >= this.n){\n        return\n    }\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.stack.length>0){\n       return this.stack.pop();\n    }\n    return -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let temp = this.stack.splice(0,k>=this.stack.length?this.stack.length:k);\n    temp = temp.map((item)=>{\n        return item = item + val\n    })\n    this.stack = temp.concat(this.stack);\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ll491119940":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185193124","body":"## 思路\n输入K数字转换成数组，将数组从末位开始，按位相加，考虑进位，最后返回相加后数组\n\n## 代码\n\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let result = [];\n    let arrK = String(k).split('');\n    let flag = 0;\n    num.reverse();\n    arrK.reverse();\n    for(let i = 0; i < num.length || i < arrK.length; i++) {\n        var retNum = (num[i] || 0) + (+arrK[i] || 0) + flag;\n        if (retNum >= 10) {\n            retNum = retNum % 10;\n            flag = 1;\n        } else {\n            flag = 0;\n        }\n        result.push(retNum);\n    }\n\n    if(flag) {\n        result.push(1);\n    }\n    result.reverse();\n    return result\n};\n```\n## 算法复杂度\n\n+ 时间复杂度 O(n)\n+ 空间复杂度 O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186415178","body":"## 思路\n 用数组模拟栈；\n## 代码\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = [];\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    const len = this.stack.length;\n    if(len >= this.maxSize) return;\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(!this.stack.length) return -1;\n    return this.stack.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const minIdx = Math.min(this.stack.length, k)\n    for(let i = 0; i < minIdx; i++) {\n        this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n## 复杂度分析\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"2learnsomething":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185216971","body":"## 思路\n看成是两个数组的求和，然后遍历数组，数字不断做求余和求除操作,进行类似于按位求和操作，注意进位问题即可，最后返回结果的逆序。\n\n## 代码\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        ans = []\n        temp = 0\n        while num or k or temp:\n            sum_k = k % 10\n            if num:\n                n = num.pop()\n            else: n = 0\n            ans.append((n+sum_k+temp)%10)\n            k //=  10\n            temp = (n+sum_k+temp)//10\n        return ans[::-1]\n```\n## 复杂度\n时间复杂度：O(n) \n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186104169","body":"## 思路\n很傻很直白的办法，先遍历一次用数组记录下目标c的位置，然后再遍历一次计算距离c的下标的最小值。属于是暴力求解，当规模更大的时候可能会超时，之后还需要改进\n## 代码\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = []\n        ans = []\n        for i in range(len(s)):\n            if s[i] == c:\n                ans.append(i) \n        for j in range(len(s)):\n            if s[j] == c:\n                res.append(0)\n            else:\n                min_ = min(list(map(lambda x:abs(x-j),ans)))\n                res.append(min_)\n        return res\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186416069","body":"## 思路\n利用python自带的列表进行栈的模拟，对于第三个问题，则采取直白的判断和遍历的方法。\n## 代码\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxsize = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxsize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) <= k:\n            self.stack = list(map(lambda x:x+val,self.stack))\n        else:\n            for i in range(k):\n                self.stack[i] +=val\n```\n## 复杂度\n时间复杂度: O(N)\n\n空间复杂度: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ataraxyadong":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185228684","body":"### 思路\n\n从低位到高位依次拿出`num`的值和`k`相加，将所加之和与10的余数加入到`list`中，直到`k=0`。最后将所得的`list`反转后即可得到。\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int length = num.length;\n        int idxVal;\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < length; i++) {\n            idxVal = num[length - 1 - i];\n            if (k != 0) {\n                list.add((idxVal + k) % 10);\n                k = (idxVal + k) / 10;\n            } else {\n                list.add(idxVal);\n            }\n            if (k != 0 && (length - 1 - i) <= 0) {\n                while (k != 0) {\n                    list.add(k % 10);\n                    k = k / 10;\n                }\n            }\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n```\n\n### 复杂度分析\n\n\\- 时间复杂度：O(N)，其中 `N = array.length`或者是`N = array.length + k的位数`。（不确定）\n\\- 空间复杂度：O(1)，（不确定）\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186173029","body":"### 思路\n\n根据题目的提示**“数组的遍历(正向遍历和反向遍历)”**，分两次遍历数组：\n\n1. 第一次，正向遍历，出现在第一个c前的位置都给`Integer.MAX_VALUE`，出现c的位置赋值为0，其余的位置的先计算出“此位置到它**左边最近的c**的距离”\n2. 第二次，反向遍历，思路大致如上，不同处在于计算出“此位置到它**右边最近的c**的距离”，和“此位置到它**左边最近的c**的距离”相比，取小值即可\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int length = s.length();\n        int[] result = new int[length];\n        int currentIndex = Integer.MAX_VALUE;\n        for (int i = 0; i < length; i++) {\n            if (s.charAt(i) == c) {\n                result[i] = 0;\n                currentIndex = i;\n            } else {\n                result[i] = Math.abs(i - currentIndex);\n            }\n        }\n        for (int i = length - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                currentIndex = i;\n            } else {\n                result[i] = Math.min(Math.abs(i - currentIndex), result[i]);\n            }\n        }\n        return result;\n    }\n}\n```\n\n\n\n**复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为字符串的长度。\n- 空间复杂度：O(N)（不确定）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzasd":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185232708","body":"### 思路\r\n\r\n本来想用`BigInteger`来进行大数计算，然后通过字符串进行数组转换，但是发现 leetcode 无法使用`BigInteger`，所以还是使用数组单项相加即可，主要考虑进位处理，另一个方法就是单位相加，逐一推出相应单位数就行了\r\n\r\n### 代码\r\n\r\n#### 写法一\r\n```java（此处换成你的语言，比如js，py 等）\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n        List<Integer> ans = new ArrayList<>();\r\n        for (int i = len - 1; i >= 0; i--) {\r\n            //数组中单项相加\r\n            int sum = num[i] + k % 10;\r\n            k = k / 10;\r\n            // 判断是否有进位的数\r\n            if (sum >= 10) {\r\n                ++k;\r\n                sum = sum - 10;\r\n            }\r\n            ans.add(sum);\r\n        }\r\n        //不确定是k大还是num代表的数据大，所以要进行两次运算\r\n        for (; k > 0; k /= 10) {\r\n            ans.add(k % 10);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n```\r\n\r\n#### 写法二\r\n```java（此处换成你的语言，比如js，py 等）\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n        List<Integer> ans = new ArrayList<>();\r\n        //简化上一步\r\n        for (int i = len - 1; i >= 0 || k > 0; i--, k /= 10) {\r\n            if (i >= 0) {\r\n                k = num[i] + k;\r\n            }\r\n            ans.add(k % 10);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186191505","body":"### 思路\r\n\r\n使用二次遍历，第一次遍历获取所有命中字符的下表，第二次遍历计算最远距离，获取与上一次的距离最小值即可，注意处理只有一次的情况\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] ans = new int[s.length()];\r\n        List<Integer> cIndex = new ArrayList<>();\r\n        for (int i = 0; i < s.length(); i++) {\r\n            char sChar = s.charAt(i);\r\n            if (sChar == c){\r\n                cIndex.add(i);\r\n            }\r\n        }\r\n        for (int i = 0, j = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c){\r\n                ans[i]=0;\r\n                if (j != cIndex.size() - 1){\r\n                    j++;\r\n                }\r\n                continue;\r\n            }\r\n            if (j >= 1){\r\n                ans[i] = Math.min(Math.abs(cIndex.get(j) - i),Math.abs(cIndex.get(j-1) - i));\r\n            }else {\r\n                ans[i] = Math.abs(cIndex.get(j) - i);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miluowzt":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185236293","body":"# **思路**\r\n从后往前遍历数组，按位与k相加，遇10进1（结果大于10时，进位数1加到下一位进行计算），考虑结果如果存储LinkedList的addFirst或者ArraryList最后翻转。\r\n\r\n# **代码**\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n\r\n        LinkedList<Integer> numList = new LinkedList<Integer>();\r\n        int index = num.length-1;\r\n        while (index>=0||k!=0){\r\n            if(index>=0){\r\n                k=num[index]+k;\r\n                index--;\r\n            }\r\n            numList.addFirst(k%10);\r\n            k=k/10;\r\n        }  \r\n        return numList;\r\n    }\r\n}\r\n\r\n# **复杂度分析**\r\n时间复杂度：O(n)  \r\nwhile 循环运行n次，n为数组长度\r\n空间复杂度：O(n)  \r\n创建的一个空列表，这个列表占用的内存随着while 循环的增加而增加，最大到 n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186223012","body":"# *思路*\n从左往右遍历一次，再从右往左遍历一次，取最小值。\n需要想到的点是开始charAt位置没有数值时，用一个假定的值来表示。\n最开始按照自己的想法写了一个很复杂的，虽然执行了但是时间复杂度是n方。\n# *代码*\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int length=s.length();\n        int [] arr= new int[length];\n        for(int i=0,index=-length;i<length;++i){\n            if(s.charAt(i)==c){\n                index=i;\n            }\n            arr[i]=i-index;\n        }\n        for(int i=length-1,index=2*length;i>=0;--i){\n            if(s.charAt(i)==c){\n                index=i;\n            }\n            arr[i]=Math.min(arr[i],index-i);\n        }\n        return arr;\n    }\n}\n# *复杂度*\n时间复杂度：O(n)，其中n 是字符串 s 的长度。\n空间复杂度：O(1)。返回值不计算成空间复杂度。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maylinglin":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185236729","body":"## 思路\n\n---\n\n把num从list转化成str，再转化成int与k相加，最后返回list形式。\n\n## 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        x = ''.join(map(str, num))\n        sum = int(x) + k\n        return list(map(int, str(sum)))   # [int(i) for i in str(sum)]\n```\n\n## 复杂度\n\n---\n\n- ****Time:**** O(N)\n- ****Space:**** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186194435","body":"## 思路\n\n\n首先从左往右遍历求距离，再从右往左遍历求距离，计算两边距离的最小值。\n\n## 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [n for i in range(n)]\n        dist = n\n        for i in range(n):\n            if s[i] == c:\n                dist = 0\n            else:\n                dist += 1 \n            ans[i] = dist\n        for j in range(n-1, -1, -1):\n            if s[j] == c:\n                dist = 0\n            else:\n                dist += 1\n            ans[j] = min(dist, ans[j])\n        return ans\n```\n\n## 复杂度\n\n\n- ****Time:**** O(N)\n- **Space:** O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weijie-he":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185238518","body":"### 整体思路\n\n模拟真正的加法计算过程\n从后往前依次逐位相加，如果 >=10 则进位\n每次加在 list 末尾，再将 list 反转\n\n### 代码\n\n```java\n    private  List<Integer> leetcodeSolution(int[] num, int k) {\n        List<Integer> result = new ArrayList<>();\n        int len = num.length;\n        for (int i = len - 1;i >= 0;i--){\n            int a = num[i] + k % 10;\n            k /= 10;\n            // 如果和 > 10，需要进位\n            if (a >= 10 ){\n                k++;\n            }\n            result.add(a % 10);\n        }\n\n        // 上面循环做完，是按照数组的长度求的结果，但是 k 可能比数组多很多位，所以还需要一个 while 循环\n        for (; k > 0; k /= 10) {\n            result.add(k % 10);\n        }\n\n        Collections.reverse(result);\n        return result;\n    }\n```\n\n### 复杂度分析\n时间复杂度：O(max(n,log k))，其中 n 为数组的长度。\n空间复杂度：O(1)。除了返回值以外，使用的空间为常数。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brodxie":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185240028","body":"## 思路\r\n\r\n由于num可能很长，不能转int直接相加，模拟计算机的加法\r\n\r\n## 代码\r\n\r\n```python3\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n    \t# space: O(max(M, N))\r\n        res = []\r\n        i = len(num) - 1\r\n        overflow = 0\r\n        # time: O(max(M, N))\r\n        while i >= 0 or k > 0:\r\n            a = num[i] if i >= 0 else 0\r\n            b = k % 10\r\n            c = a + b + overflow\r\n            res.append(c % 10)\r\n            overflow = c // 10\r\n            i -= 1\r\n            k //= 10\r\n        if overflow:\r\n            res.append(overflow)\r\n        # time: O(max(M, N))\r\n        res.reverse()\r\n        return res\r\n```\r\n\r\n## 复杂度分析\r\nM为num.length, N为ceil(log10(k))\r\n\r\n- 时间复杂度: O(Max(M, N))\r\n- 空间复杂度: O(Max(M, N))\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186102244","body":"## 思路\r\n\r\n记录上个c的索引，得到当前字符和c的最小距离。正向反向分表遍历一次，取最小的。\r\n\r\n## 代码\r\n\r\n```python3\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        # space: O(N)\r\n        ans = [float('inf')] * n\r\n        last_c_index = float('-inf')\r\n        # time: O(N)\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                last_c_index = i\r\n            ans[i] = min(ans[i], i - last_c_index)\r\n        last_c_index = float('inf')\r\n        # time: O(N)\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                last_c_index = i\r\n            ans[i] = min(ans[i], last_c_index - i)\r\n        return ans\r\n\r\n```\r\n\r\n## 复杂度分析\r\n\r\nN为s.length\r\n\r\n- 时间复杂度: O(N)\r\n- 空间复杂: O(N)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y525":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185251187","body":"class Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        carry = 0\r\n        i = 1\r\n        n = len(num)\r\n        while n-1 >= 0 or carry != 0 or k != 0:\r\n            if n-1 < 0:\r\n                number = k%10 + carry\r\n            else:\r\n                number = num[n-1] + k%10 + carry\r\n            k = k//10\r\n            carry = number//10\r\n            number = number % 10\r\n            res.append(number)\r\n            n -= 1\r\n        return res[::-1]\r\n\r\nspace complexity O(n) time complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185878663","body":"class Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        answer = []\r\n        for i, v in enumerate(s):\r\n            if v == c:\r\n                res.append(i)\r\n        for i in range(len(s)):\r\n            m = math.inf\r\n            for j in range(len(res)):\r\n                m = min(abs(i-res[j]), m)\r\n            answer.append(m)\r\n        return answer\r\ntime complexity O(n^2) space complexity O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185258544","body":"# LC989. Add to Array-Form of Integer\n## Main Idea\nFirst, it looks like we can convert the array `num` to integer and add it to `k`, but `num.length <= 1E+4` so this approach will cause integer overflow. So we will have to do the addition in array form.\n\nThen the idea is to simulate the entire process, add each digit of `num` and `k` with a `carry` bit. We will terminate the loop when we run out of digits for both `num` and `k` and `carry == 0`.\n\n## Code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int ptr = num.length - 1, carry = 0;\n        List<Integer> ret = new ArrayList<>();\n        while (ptr >= 0 || k > 0 || carry > 0) {\n            int d1 = ptr >= 0 ? num[ptr] : 0;\n            int d2 = k % 10;\n            int sum = d1 + d2 + carry;\n            ret.add(sum % 10);\n            ptr--;\n            k /= 10;\n            carry = sum >= 10 ? 1 : 0;\n        }\n        \n        Collections.reverse(ret);\n        return ret;\n    }\n}\n```\n\n## Complexity Analysis\nTime: `O(2*max(N, log(K)))`\n* Given a number `K`, its length will be `O(log_{2}(K))`, the time complexity depends on the length of `N` and `K`, whichever is longer.\n* Notice we want to insert digits at the end of the array and then reverse it after we finish the addition (reverse takes `O(res.size())`). If we insert at the head of array, then it will take `O(n^2)` of time.\n\nSpace: `O(1)`, as we didn't use additional spaces except the return array.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186129158","body":"```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length(), count = Integer.MAX_VALUE;\n        int[] ret = new int[n];\n        Arrays.fill(ret, Integer.MAX_VALUE);\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                count = 0;\n            }\n            ret[i] = Math.min(ret[i], count);\n            if (count != Integer.MAX_VALUE)\n                count++;\n        }\n        \n        count = Integer.MAX_VALUE;\n        for (int i = n - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                count = 0;\n            }\n            \n            ret[i] = Math.min(ret[i], count);\n            if (count != Integer.MAX_VALUE)\n                count++;\n        }\n        \n        return ret;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185259516","body":"- Time: $O(N)$, N is $max(num.size(), ceil(log(k)))$\n- Space: $O(1)$, no extra space is used apart from the output array.\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        res.reserve(num.size());\n        int p = num.size() - 1;\n\n        while (p >= 0 || k > 0) {\n            if (p >= 0) k += num[p--];\n            res.push_back(k % 10);\n            k /= 10;\n        }\n\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186111046","body":"- Time: $O(N)$\n- Space: $O(1)$\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> res(n, n);\n        \n        if (s[0] == c) res[0] = 0;\n\n        for (int i = 1; i < n; i++)\n            res[i] = s[i] == c ? 0 : res[i - 1] + 1;\n\n        for (int i = n - 2; i >= 0; i--)\n            res[i] = min(res[i], res[i + 1] + 1);\n\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186387195","body":"- Time: `push` $O(1)$, `pop` $O(1)$, `increment` $O(1)$\r\n- Space: $O(N)$, N is maxSize\r\n\r\n```cpp\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : capacity_(maxSize) {\r\n        inc_ = vector<int>(capacity_, 0);\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top_ == capacity_ - 1) return;\r\n        stk_.push(x);\r\n        top_++;\r\n    }\r\n    \r\n    int pop() {\r\n        if (top_ == -1) return -1;\r\n\r\n        int x = stk_.top(); stk_.pop();\r\n        x += inc_[top_];\r\n\r\n        if (top_ > 0) \r\n            inc_[top_ - 1] += inc_[top_];\r\n        inc_[top_--] = 0;\r\n\r\n        return x;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        k = min(k - 1, top_);\r\n        if (k > -1) inc_[k] += val;\r\n    }\r\nprivate:\r\n    int capacity_;\r\n    int top_ = -1;\r\n    stack<int> stk_;\r\n    vector<int> inc_;\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mirrors-cl":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185287919","body":"思路\r\n按照 正常的手写加法的逻辑做的只是好像机器化了，感觉自己好弱\r\ncode\r\n```\r\nvar addToArrayForm = function(num, k) {\r\nconst res = [] \r\nvar str = k.toString();\r\nvar arr = str.split(\"\")\r\narr = arr.map(Number)\r\nlet carry = 0;\r\nlet l1 = num.length -1\r\nlet l2 = arr.length -1\r\nwhile(l1>=0 || l2>=0){\r\n    let x = l1 < 0 ? 0 : num[l1]\r\n    let y = l2 < 0 ? 0 : arr[l2]\r\n    let sum = x + y + carry\r\n    res.push(sum % 10)\r\n    carry = Math.floor(sum/10)\r\n    l1--\r\n    l2--\r\n}\r\nif(carry != 0 )res.push(carry)\r\nreturn res.reverse()\r\n\r\n};\r\n```\r\n复杂程度\r\n 还没学会怎么算基础有些差","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185331610","body":"## 题目描述\nhttps://leetcode.cn/problems/add-to-array-form-of-integer/\n\n## 解题思路\n\n###逐位相加，记录进位\n\n\n####难点\n1. 数字怎么按位拆分\n   * **数字不用拆分**\n    * **num[i] + k % 10 先相加再%10**\n2. 数组和数字位数不同时怎么处理\n   * 开始打算取位数最多的，其实只用对没加完的数字单独处理\n3. 进位处理\n    * 加到数字上\n    \n####js代码\n```javascript\n  var addToArrayForm = function(num, k) {\n  const res = []\n    \n  for(let i = num.length - 1; i>=0; i--) {\n      let sum = num[i] + k % 10\n      k = Math.floor(k / 10)\n      if (sum > 9) {\n        k++\n        res.push(sum % 10)\n      } else {\n        res.push(sum)\n      }\n  }\n  while(k) {\n      res.push(k%10)\n      k = Math.floor(k/10)\n  }\n  return res.reverse()\n  \n};\n```\n####复杂度\n* 时间复杂度 O(max(num.length, log k))\n* 空间复杂度 O(1)\n\n## 加法模版\n```\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\n\nwhile ( A 没完 || B 没完)\nA 的当前位\nB 的当前位\n\n    和 = A 的当前位 + B 的当前位 + 进位carry\n\n    当前位 = 和 % 10;\n    进位 = 和 / 10;\n\n判断还有进位吗\n```\n\n\n\n     \n  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186165018","body":"## 题目描述\nhttps://leetcode.cn/problems/shortest-distance-to-a-character/\n## 解题思路\n\n记录字符c出现的下标，遍历比较最短距离\n\n\n###我的暴力解法（👎👎👎\n\n####js代码\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n        let indexList = []\n        let res = []\n        for(let i = 0; i < s.length; i++) {\n            if (s[i] === c) {\n                indexList.push(i)\n                res[i] = 0\n            }\n        }\n        let k = 0\n        for(let i = 0; i < s.length; i++) {\n            if(!indexList.includes(i)) {\n                while(k+1 < indexList.length && Math.abs( indexList[k] - i) > Math.abs(indexList[k+1] - i)) {\n                    k += 1\n                }\n                res[i] =  Math.abs( indexList[k] - i)\n            }\n        }\n        return res\n    };\n```\n####复杂度\n* 时间复杂度 O(n)\n* 空间复杂度 O(1)\n\n###官方题解\n\n- 双向遍历\n- 问题可以转换成，对s的每个下标i，求 \\\n    s[i]  到其左侧最近的字符 cc 的距离\\\n    s[i]  其右侧最近的字符 cc 的距离 \\\n  这两者的最小值。\n  \n####难点：\n在开始遍历的时候，不知道第一个等于目标字符的index在哪，为了简化逻辑，我们可以用 -n 或 2n 表示，这里 n 是 s 的长度。\n确保每一位到index的距离 >= n\n取n的话从右遍历，最小距离为1\n\n####js代码\n```javascript\nvar shortestToChar = function(s, c) {\n    let n = s.length\n    let res = new Array(n).fill(0)\n    for(let i = 0, index = 2*n; i < s.length; i++) {\n        if (s[i] === c) {\n            index = i\n        } else {\n            res[i] = Math.abs(i - index)\n        }\n    }\n    \n    for(let i = s.length - 1,index = 2*n; i >= 0; i--) {\n       if (s[i] === c) {\n           index = i\n       } else {\n           res[i] = Math.min(res[i], Math.abs(i - index))\n       }\n    }\n    return res\n};\n```\n####复杂度\n* 时间复杂度 O(n)\n* 空间复杂度 O(1)\n\n\n\n     \n  \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jakkiabc":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185338763","body":"自己用进位遍历的方法没跑出来，待会再想想= =\r\n暂时用  list→str→int 来计算sum 最后再转换回list \r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n=int(''.join([str(x)for x in num]))\r\n        sum=n+k\r\n        return list(map(int,str(sum)))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186190071","body":"先找到相同元素的位置，然后分别向左向右遍历找到min最小距离\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n=len(s)\r\n        start=[0 if a==c else n for a in s]\r\n        for i in range(1,n):\r\n            start[i]=min(start[i],start[i-1]+1)\r\nfor i in range(n-2,-1,-1):\r\n            start[i]=min(start[i],start[i+1]+1)\r\n        return start","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyoneday":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185356088","body":"## 思路\r\n\r\n0 <= K <= 10000，可直接加 1，不需要大数相加\r\n\r\n## 代码 js\r\n\r\n```js\r\nvar addToArrayForm = function (num, K) {\r\n    const len = num.length || 0;\r\n    let numK = K;\r\n    const result = [];\r\n\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        const a = num[i];\r\n        const b = numK % 10;\r\n       \r\n        let total = a + b;\r\n        numK = total >= 10 ? parseInt(numK / 10) + 1 : parseInt(numK / 10);\r\n        result[i] = total % 10;\r\n    }\r\n    while (numK > 0) {\r\n        result.unshift(numK % 10);\r\n        numK = parseInt(numK / 10);\r\n    }\r\n\r\n    return result;\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度: O(n)\r\n空间复杂度: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186194360","body":"## 思路\r\n\r\n从左向右遍历，记录字符右侧的距离；从右向左遍历，获取字符左侧的距离和之前距离的较小值。\r\n\r\n## 代码 js\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n  const tempArr = [];\r\n  const len = s.length;\r\n  let idx = -1;\r\n  for (let i = 0; i < len; i++) {\r\n    if (s[i] === c) {\r\n      idx = i;\r\n      tempArr[i] = 0;\r\n    } else if (idx === -1) {\r\n      tempArr[i] = Infinity;\r\n    } else {\r\n      tempArr[i] = i - idx;\r\n    }\r\n  }\r\n\r\n  idx = Infinity;\r\n  for (let i = len - 1; i > -1; i--) {\r\n    const val = tempArr[i];\r\n\r\n    if (s[i] === c) {\r\n      idx = i;\r\n    } else if (val > idx - i) {\r\n      tempArr[i] = idx - i ;\r\n    }\r\n  }\r\n\r\n  return tempArr;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chouqin99":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185362278","body":"思路:想把数组直接转成int，然后用加法加完了，再转换回来，但是貌似不是题目要的\r\ncode：\r\n`\r\n  #!/usr/bin/env python\r\n  \"\"\"add\"\"\"\r\n  \r\n  import os\r\n  from os import sys, path\r\n  \r\n  class Add(object):\r\n  \r\n      def list2str(self, inlist):\r\n          outstr = \"\"\r\n          for i in inlist:\r\n              outstri = ''.join(str(i))\r\n              outstr = outstr + outstri\r\n          return outstr\r\n\r\n      def add(self, x, k):\r\n          str_x = self.list2str(x)\r\n          str_k = self.list2str(k)\r\n          addint = int(str_x) + int(str_k)\r\n          return addint\r\n\r\n      def str2list(self, instr):\r\n          outlist = list(instr)\r\n          return outlist\r\n\r\n      def main(self, x, k):\r\n          addint = self.add(x, k)\r\n          outlist = self.str2list(str(addint))\r\n          print outlist\r\n\r\n  if __name__ == '__main__':\r\n      x = [1,1,0,0]\r\n      k = [3,4]\r\n      r = Add()\r\n      r.main(x,k)\r\n\r\n`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186216992","body":"## 思路\r\n  学习官方解题方式\r\n##代码\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        n = len(s)\r\n        res = [0 if s[i] == c else None for i in range(n)]\r\n\r\n        for i in range(1, n):\r\n            if res[i] != 0 and res[i - 1] is not None:\r\n                res[i] = res[i - 1] + 1\r\n\r\n        for i in range(n - 2, -1, -1):\r\n            if res[i] is None or res[i + 1] + 1 < res[i]:\r\n                res[i] = res[i + 1] + 1\r\n        return res\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaogeg111":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185368348","body":"解题思路\n\n- 整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\n  例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\n\n解题代码\n\n    int* addToArrayForm(int* num, int numSize, int k, int* returnSize){\n        int ksize = 0;//预设k的位数为0\n        int ktmp = k;\n        while(ktmp)      //得到k的位数\n        {\n            ksize++;\n            ktmp /= 10;\n        }\n        int size = numSize > ksize ? numSize + 1 : ksize + 1;   //开辟一个多+1位置的数组，防止有进位\n    \n        int* a = (int*)malloc(size*sizeof(int));\n    \n        int end = numSize - 1;//创建一个下标指向num数组的最后一个元素 \n        int carry = 0;\n        int i = 0;\n        while(end >= 0 || k > 0)   //2个有1个没有遍历完\n        {\n            if(end >= 0)\n            {\n                a[i] = carry + num[end] + k % 10;\n            }//num[end]为数组的最后一个元素 k%10 为k的最后一位\n            else\n            {\n                a[i] = carry + k % 10;\n            }\n    \n            if(a[i] >= 10)\n            {\n                a[i] = a[i] - 10;\n                carry = 1;//有进位\n            }\n            else\n            {\n                carry = 0;//carry=1表示进位为，0表示不进位\n            }\n            k /= 10;\n            end--;\n            i++;\n        }\n        if(carry == 1)\n        {\n            a[i++] = 1;\n        }\n    \n        int left = 0;\n        int right = i - 1;\n        while(left < right)\n        {\n            int tmp = a[left];\n            a[left] = a[right];\n            a[right] = tmp;\n            left++;\n            right--;\n        }//数组逆序\n    \n        *returnSize = i;\n        return a;\n    \n    }\n\n时间复杂度\n\nO（n^2)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186159638","body":"### 题目描述\n\n````\n```\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\n\n示例 1:\n\n输入: S = \"loveleetcode\", C = 'e'\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\n说明:\n\n- 字符串 S 的长度范围为 [1, 10000]。\n- C 是一个单字符，且保证是字符串 S 里的字符。\n- S 和 C 中的所有字母均为小写字母。\n\n```\n````\n\n### 解题思路\n\n1. 从左到右遍历i，找出下标i到离它左侧最近的字符c的距离\n2. 从右到左遍历i，找出下标i到离它右侧最近的字符c的距离\n3. 比较1和2得出最短距离。找到速度最快的距离\n\n### 解题代码\n\n```c\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint *shortestToChar(char *s, char c, int *returnSize)\n{\n    int i, index;\n    int len = strlen(s);\n    int *p = (int *)malloc(len * sizeof(int));\n    if (p == NULL) {\n        return NULL;\n    }\n    memset(p, 0, len * sizeof(int));\n\n    // 从左到右遍历i，找出下标i到离它左侧最近的字符c的距离\n    index = -len; // 初始为-len，第一次遍历时，可能没有找到\n    for (i = 0; i < len; i++) {\n        if (s[i] == c) {\n            index = i; // 更新index\n        }\n        p[i] = i - index; // 求出距离\n    }\n\n    // 从右到左遍历i，找出下标i到离它右侧最近的字符c的距离\n    index = 2 * len; // 初始为2*len，第一次遍历时，可能没有找到\n    for (i = len - 1; i >= 0; i--) {\n        if (s[i] == c) {\n            index = i; // 更新index\n        }\n        p[i] = fmin(p[i], index - i); // 求出距离，并比较得出最短距离\n    }\n\n    *returnSize = len;\n    return p;\n}\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185371267","body":"## Idea\r\niterate through the num array, add each digit to k , add the rightmost digit into the result list\r\n## Code\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int len = num.length;\r\n        for (int i = len-1; i >= 0; i--) {\r\n            k += num[i];\r\n            res.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        while (k > 0) {\r\n            res.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(n)\r\nSpace:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185991579","body":"##  Idea\r\nIterate from left to right, and then iterate from right to left\r\n## Code\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] str = s.toCharArray();\r\n        int n = str.length;\r\n        int[] res = new int[n];\r\n        Arrays.fill(res, Integer.MAX_VALUE);\r\n        for (int i = 0; i < n; i++) {\r\n            if (str[i] == c) {\r\n                res[i] = 0;\r\n            }\r\n            if (i < n-1 && res[i] != Integer.MAX_VALUE) {\r\n               res[i+1] = Math.min(res[i]+1, res[i+1]); \r\n            }\r\n        }\r\n        for (int i = n-1; i > 0; i-- ) {\r\n            if (res[i] != Integer.MAX_VALUE) {\r\n                res[i-1] = Math.min(res[i-1], res[i]+1);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n## Complexity\r\ntime: O(n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186350565","body":"## Idea\r\nImplement with an array and keep track of current position. For increment, use an offset array and an int instead of incrementing all bottom k elements.\r\n## Code\r\n```\r\nclass CustomStack {\r\n    int[] stack;\r\n    int[] offset;\r\n    int cur;\r\n    int diff;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        offset = new int[maxSize];\r\n        cur = 0;\r\n        diff = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (cur == stack.length) return;\r\n        if (cur > 0) {\r\n            offset[cur-1] += diff;\r\n        }\r\n        diff = 0;\r\n        stack[cur] = x;\r\n        offset[cur] = 0;\r\n        cur++;\r\n    }\r\n    \r\n    public int pop() {\r\n        if (cur == 0) return -1;\r\n        int res = stack[cur-1];\r\n        diff += offset[cur-1];\r\n        cur--;\r\n        return res+diff;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if (cur == 0) return;\r\n        int min = Math.min(k , cur);\r\n        offset[min-1] += val;\r\n    }\r\n    \r\n}\r\n```\r\n## Complexity\r\nTime: push O(1) , pop O(1), increment O(1)\r\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ye2222":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185386008","body":"## Code\n```c++\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    int n = num.size();\n    int count = n-1;\n    vector<int> res;\n    // 因为可能不是相同位数操作，所以要确保每一位都参加运算\n    while(count >= 0 || k != 0) {\n        // 对k进行操作比较方便，进行加法运行时会遵循加减法原则\n        if(count >= 0) {\n            k += num[count];\n            count--;\n        }\n        res.insert(res.begin(), k%10);\n        k /= 10;\n    }\n    return res;\n}\n```\n## 复杂度\n- 时间复杂度：O(n) \n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186052432","body":"## 思路\n正向遍历，给字符c右边的字符赋值距离，遇到另一个字符c停止；反向遍历，计算距离，同样遇到另一个字符c停止，距离取最小值\n## Code\n```c++\nvector<int> shortestToChar(string s, char c) {\n    int n = s.size();\n    vector<int> res;\n    for(int i = 0; i < n; i++) res.push_back(100001);\n    // 正向遍历\n    for(int i = 0; i < n; i++) {\n        if(s[i] == c) {\n            res[i] = 0;\n            for(int j = i + 1; j < n; j++) {\n                if(s[j] != c) res[j] = j - i;\n                else break; \n            }\n        }\n    }\n    // 反向遍历\n    for(int i = n - 1; i >= 0; i--) {\n        if(s[i] == c) {\n            for(int j = i - 1; j >= 0; j--) {\n                if(s[j] != c) {\n                    int dis = i - j;\n                    if(res[j] > dis) res[j] = dis;\n                } \n                else break;\n            }\n        }\n    }\n    return res;\n}\n```\n## 复杂度\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uyplayer":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185419128","body":"## 思路\r\n\r\n每次遍历最后一个元素和k加起来，如果大于10的话 进行近位\r\n\r\n## 代码\r\n``` go\r\n\r\nfunc addToArrayForm(num []int, k int) (ans []int) {\r\n\r\n    // 每次遍历提取最后一个元素\r\n    for i:=len(num)-1;i>=0;i-- {\r\n        // 最后一个元素和k加起来\r\n        sum := num[i] + k\r\n        k = k / 10\r\n        // 判断sum是否大于10\r\n        if sum > 10 {\r\n            k ++\r\n            sum = sum - 10\r\n        }\r\n        ans = append(ans, sum)\r\n\r\n    }\r\n\r\n    for ; k > 0; k /= 10 {\r\n        ans = append(ans, k%10)\r\n    }\r\n    reverse(ans)\r\n    return\r\n   \r\n}\r\n\r\n// 反转\r\nfunc reverse(num []int) {\r\n    for i, n := 0, len(num); i < n/2; i++ {\r\n        num[i], num[n-1-i] = num[n-1-i], num[i]\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度：O(max(n,logk))，其中 n 为数组的长度。\r\n\r\n- 空间复杂度：O(1) ，除了返回值以外，使用的空间为常数。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186211992","body":"## LC 821. 字符的最短距离\r\n[Leetcode连接](https://leetcode.cn/problems/shortest-distance-to-a-character/)\r\n\r\n- [额外数组记录下标](#solution1)\r\n\r\n### <span id=\"solution1\">额外数组记录下标</span>\r\n\r\n- 首先用额外的数组来保存目标字符在给定字符串的下边\r\n- 遍历给定字符串下边和上面保存的目标字符的下边，计算它们两个的距离，取最小的距离\r\n- 结果保存到另一个额外的数组\r\n\r\n### Golang 代码\r\n\r\n``` go\r\n\r\n\r\nimport \"math\"\r\nimport \"fmt\"\r\nfunc shortestToChar(s string, c byte) []int {\r\n\r\n\r\n    // 选贤获取e的下边\r\n    e := make([]int,0)\r\n    for i:=0;i<len(s);i++{\r\n        if s[i] == c {\r\n           e = append(e,i) \r\n        }\r\n\r\n    }\r\n    fmt.Println(e)\r\n    // 结果\r\n    result := make([]int,0)\r\n\r\n    for i:=0;i<len(s);i++{\r\n        min := 99999999\r\n        for j:=0;j<len(e);j++{\r\n            // fmt.Println(math.Abs(float64(e[j]-j)))\r\n            distance := int(math.Abs(float64(e[j]-i)))\r\n            fmt.Println(distance)\r\n            if distance < min {\r\n                min =  distance\r\n            }\r\n        }\r\n        fmt.Println(min)\r\n        result = append(result,min)\r\n\r\n    }\r\n\r\n    return result\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guixian001":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185422953","body":"### 思路\n\n常规思路\n先将给的数值转成数值，然后和给的 k 进行相加，再将其转换成数组\n\n### 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num_length = len(num)\n        sum = 0\n        for index, i in enumerate(num):\n            sum += i * 10 ** (num_length - index  - 1)\n        sum += k\n        return [int(i) for i in str(sum)]\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186223257","body":"### 思路\n\n分别计算数组位置中左侧和后侧的最近距离，然后最它们中的最小值作为当前 index 的数字。\n\n### 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [n+1] * n\n\n        c_index = -1\n        for index, char in enumerate(s):\n            if char == c:\n                c_index = index\n            if c_index != -1:\n                ans[index] = index - c_index \n\n        c_index = -1\n        for i in range(n-1, -1, -1):\n            if s[i] == c:\n                c_index = i\n            if c_index != -1:\n                ans[i] = min(ans[i], c_index - i)\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185423747","body":"### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        temp = 0\n        for i in range(len(num)-1,-1,-1):\n            num[i], temp = (temp+num[i]+k%10)%10, (temp+num[i]+k%10)//10\n            k = k//10\n        l = []\n        n = []\n        k += temp\n        while k:\n            l.append(k%10)\n            k//=10\n        while l:\n            n.append(l.pop())\n        return n+num\n```\n### 复杂度分析\n时间复杂度：O（n）  \n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186139183","body":"### 思路\n首先遍历字符串找到给定字符的所有位置，然后再遍历字符串，比较每个字符和给定字符所有位置之间的距离，取最小的距离\n\n### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        s_list = list(s)\n        temp = []\n        for i in range(len(s_list)):\n            if s_list[i] == c:\n                temp.append(i)\n        answer = []\n        for i in range(len(s_list)):\n            temp2 = []\n            for j in range(len(temp)):\n                m = abs(i - temp[j])\n                temp2.append(m)\n            answer.append(min(temp2))\n        return answer\n```\n\n**复杂度分析**  \n时间复杂度：O（n*k），n为字符串长度，k为给定字符在字符串中出现的次数  \n空间复杂度：O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junzmer":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185423785","body":"### **思路**\r\n简单直接版\r\n\r\n1. 先把数组转成数字\r\n2. 相加\r\n3. 把数字转成数组，先除10求余数，然后除10求商，结果做个反转\r\n\r\n### **代码**\r\n\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        num_sum = 0\r\n        num = num[::-1]\r\n        num_length = len(num)\r\n        for i in range(num_length):\r\n            num_sum += (10 ** i) * num[i]\r\n        all_sum = num_sum + k\r\n        result = []\r\n        while all_sum > 0:\r\n            mod = all_sum % 10\r\n            all_sum = all_sum // 10\r\n            result.append(mod)\r\n        return result[::-1]\r\n```\r\n\r\n### **复杂度**\r\n\r\n- 时间复杂度O(N) N数组长度\r\n- 空间复杂度O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hx-code":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185455662","body":"var addToArrayForm = function(num, k) {\n    let res = [];\n    let len = num.length;\n    for(let i=len-1; i>=0;i--){\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if(sum>=10){\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);  \n    }\n    for(let i =k;i>0;i=Math.floor(i/10)){\n        res.push(i % 10)\n    }\n    res.reverse();\n    return res;\n\n};\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"admu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185460667","body":"**思路**  \r\n一开始只能用list转数字相加方式，后来参考了进位方法：  \r\n1.1 循环判断条件当 k 和 列表都为空时候终止  \r\n1.2 取余方式每次去k的末尾值与列表末尾值进行相加，同时记录进位的值  \r\n\r\n**代码**  \r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        res = []\r\n        carry = 0 \r\n        if len(str(k))>len(num):\r\n            num = [0]*(len(str(k))-len(num))+num\r\n        n = len(num)-1 \r\n        while n>=0 and k>=0:\r\n            i = num[n]\r\n            kk = k%10 \r\n            res.append((i+k+carry)%10)\r\n            carry = (i+kk+carry)//10 \r\n            n -= 1\r\n            k = (k-kk)//10 \r\n        if carry!=0: res.append(carry)\r\n        return res[::-1]\r\n```\r\n\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(n)  \r\n1.2 空间复杂度 O(1)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186109783","body":"**思路**  \r\n1.1 一开始用暴力求解时间复杂度都是O(cn)空间复杂度O(cn)  \r\n1.2 看了题解进行优化,借助-n和2n进行双向搜索，秒啊  \r\n\r\n**代码**\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        ans = [0] * n\r\n\r\n        idx = -n\r\n        for i, ch in enumerate(s):\r\n            if ch == c:\r\n                idx = i\r\n            ans[i] = i - idx\r\n        idx = 2 * n\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            ans[i] = min(ans[i], idx - i)\r\n        return ans\r\n```\r\n\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(n)  \r\n1.2 空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxiaomm":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185468498","body":"## 思路\n\n1. Add two numbers from right to left, column by column, and record the carry.\n2. If carry > 0, add it to the next column.\n3. Add the result to the first position of the result list.\n4. Implement the loop until all digit in two numbers has been calculated, or carry = 0;\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int i = num.length - 1, carry = 0;\n        while (i >= 0 || k > 0 || carry > 0) {\n            int val1 = i < 0 ? 0 : num[i--];\n            int val2 = k % 10;\n            int sum = val1 + val2 + carry;\n            carry = sum / 10;\n            res.add(0, sum % 10);\n            k = k / 10;\n        }\n        return res;\n    }\n}\n```\n\nTime complexity: O(n), n is the greater length of the two numbers.\nSpace complexity: O(1), not include the space of output array.\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186159091","body":"\n# Link\n\nhttps://leetcode.com/problems/shortest-distance-to-a-character/\n\n## Idea_1\n\n1. Traverse the string for two times;\n2. Firstly, when going from left to right, we record the distance from index i to their last/previous target character(first target on their left): ```i - prev```;\n3. Secondly, when going from right to left, we record the distance form index i to their right previous target(first target on their right), and compared with original value in the array;\n4. Update the minimum distance of every node;\n\n\n## Code_1\n\n```java\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int n = S.length(), pos = -n, res[] = new int[n];\n        // 距离最左边的e的距离\n        for (int i = 0; i < n; ++i) {\n            if (S.charAt(i) == C) pos = i;\n            res[i] = i - pos;\n        }\n        // 倒序: 距离最右边的e的距离与之比较\n        for (int i = pos - 1; i >= 0; --i) {\n            if (S.charAt(i) == C)  pos = i;\n            res[i] = Math.min(res[i], pos - i);\n        }\n        return res;\n    }\n}\n```\n\n## Idea_2\n\n1. Use two pointer: ```slow``` and ```fast```.\n2. After finding the first target with ```fast``` on the right, write the distance of nodes on its left into the array, and store the index of this target as ```prev```.\n3. Continue the above step, compare the distance from the nodes to the previous target node and the next target node, update the array.\n\n\n\n## Code_2\n\n```java\nclass Solution {\n    // two pointer\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int i = 0, j = 0, prev = -1;;\n        while (i < len) {\n            // 找到右边的第一个e\n            while (j < len && s.charAt(j) != c )\n                j++;\n            if (j == len) break;    // 右边没有e了\n            \n            // 比较右边的e和左边的e哪个远\n            while (i <= j){\n                res[i] = Math.min(j-i, (prev==-1 ? len : i-prev));\n                i++;\n            }\n            prev = j++; // 记录前一个e的位置\n        }\n        // 若数组没填充完, 则填充, 距离左边e的距离即是结果\n        while (i < len) \n            res[i] = (prev==-1 ? i : i++ -prev);    \n        \n        return res;\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: O(n), n is the length of the string.  \nSpace complexity: O(n), the length of output array.\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pgquestions":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185484818","body":"## 思路\r\n\r\n1、创建一个链表数组用来存放结果  \r\n2、把数组和数字相同位数的值进行相加。直到全部计算完  \r\n3、每次计算完的数字添加在数组头部  \r\n\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> arr = new LinkedList<>();\r\n        int index = num.length - 1;\r\n        int temp = 0;\r\n        while (index >= 0 || k > 0 || temp > 0) {\r\n            int temp_data = k % 10 + temp;\r\n            k = k / 10;\r\n            if (index >= 0) {\r\n                temp_data += num[index];\r\n                index--;\r\n            }\r\n            arr.addFirst(temp_data % 10);\r\n            temp = temp_data / 10;\r\n        }\r\n        return arr;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185682411","body":"## 思路\r\n\r\n先从左往右进行遍历。  \r\n然后从右往左遍历，记录最小的值\r\n\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        // 从左往右遍历\r\n        for (int i = 0, index = -n; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = i - index;\r\n\r\n        }\r\n        \r\n        // 从右往左遍历\r\n        for (int i = n - 1, index = 2 * n; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = Math.min(res[i], index - i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eldinzhou":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185485651","body":"```go\nfunc addToArrayForm(num []int, k int) (ans []int) {\n    for i := len(num) - 1; i >= 0; i-- {\n        sum := num[i] + k%10\n        k /= 10\n        if sum >= 10 {\n            k++\n            sum -= 10\n        }\n        ans = append(ans, sum)\n    }\n    for ; k > 0; k /= 10 {\n        ans = append(ans, k%10)\n    }\n    reverse(ans)\n    return\n}\n\nfunc reverse(num []int) {\n    for i, n := 0, len(num); i < n/2; i++ {\n        num[i], num[n-1-i] = num[n-1-i], num[i]\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangwenzhe":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185496245","body":"### 思路\n\n本来一开始想直接使用 JavaScript 的 api 的：\n1. 计算 sum 数组的值\n2. 把值和 k 相加\n3. 把值通过 `String(number).split('').map(n => Number(n))` 转换回数组\n\n出现的问题是 `IEEE754` 编码的数字会出现精度丢失的问题\n\n所以还是老老实实的使用逐位相加的方法\n\n1. 把数组中的位置从高到底相加\n2. 如果结果大于 10 的话，把进位 1 加入下一位的计算\n\n### 代码\n\n```js\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (let k; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(n)\n* 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186141162","body":"### 思路\n\n* 把 c 在 s 字符串的位置放在一个新开辟的数组里\n* 遍历 s 字符串，把结束输入到数组中\n\n### 代码\n\n```js\nvar shortestToChar = function(s, c) {\n  const sArr = s.split('');\n  const cIndexArr = [];\n  sArr.forEach((i, index) => {\n    if (i === c) {\n      cIndexArr.push(index);\n    }\n  });\n  const res = Array(s.length).fill(Infinity);\n  sArr.forEach((i, index) => {\n    if (i === c) {\n      res[index] = 0;\n      return;\n    }\n    for (const cIndex of cIndexArr) {\n      const dis = Math.abs(cIndex - index);\n      if (dis >= res[index]) {\n        break;\n      }\n      res[index] = dis;\n    }\n  });\n  return res;\n};\n```\n\n### 复杂度\n\n* 时间复杂度 O(N^2)\n* 空间复杂度 O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnwu6688":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185508439","body":"# 989.Add to Array-Form of Integer\n\n**思路:**\n\n自己想的思路和leetcode上高赞答案差不多，但是实现起来，发现他的更优雅，果断使用他的实现思路。优雅，真的太优雅了！！！\n1. 不要用for循环，因为你不知道num,k那个长度更长，如果一开始将k转为数组来比较长度就太不优雅了！！！所以用while()\n2. 用LinkedList不要用ArrayList因为底层为链表实现的LinkedList可以头插\n3. 数组的每一位都与K整体相加，除10就是K的最新值参与下一次遍历，不用考虑进位问题\n4. 把数组相加的问题转化为对最新值处理问题，不用考虑长度和位数\n\n```java\npublic class AddToArrayFormOfInteger {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len = num.length;\n        int lastNum = k;\n        int i = len - 1;\n        LinkedList<Integer> result = new LinkedList<>();\n        while (i >= 0 || lastNum > 0) {\n            if (i >= 0)\n                lastNum += num[i];\n            //取模加入到数组\n            result.addFirst(lastNum % 10);\n            //更新最新值\n            lastNum /= 10;\n            i--;\n        }\n        return result;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186078726","body":"# 821. Shortest Distance to a Character\n\n**思路：**\n最无脑的思路\n1. 记录c的下标存入数组\n2. 遍历相减取最小绝对值\n\n```java\npublic int[] shortestToChar(String s, char c) {\n        char[] chars = s.toCharArray();\n        ArrayList<Integer> index = new ArrayList<>();\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == c){\n                index.add(i);\n            }\n\n        }\n        int[] ret = new int[chars.length];\n        int minAbs = 0;\n        for (int i = 0; i < chars.length; i++) {\n            for (int j = 0; j < index.size(); j++) {\n                if (j ==0){\n                    //再次初始化\n                    minAbs = Math.abs(index.get(j) - i);\n                    continue;\n                }\n                minAbs = Math.min(Math.abs(index.get(j) - i), minAbs);\n\n            }\n            ret[i] = minAbs;\n\n        }\n        return ret;\n\n    }\n```\n>时间复杂度： O(n^2)\n> \n>空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomtao626":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185520837","body":"## 思路\r\n\r\n> + k作为位数累加,进位\r\n\r\n##代码\r\n\r\n```go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n\ti := len(num) - 1\r\n\tfor i >= 0 || k > 0 {\r\n\t\tif i > 0 && k > 0 {\r\n\t\t\tsum := num[i] + k%10\r\n\t\t\tnum[i] = sum\r\n\t\t\tk = k / 10  // drop the last element of k\r\n\r\n\t\t\tif sum > 9 {\r\n\t\t\t\tnum[i] = sum % 10\r\n\t\t\t\tk++ //  add carry(1) to k\r\n\t\t\t}\r\n\t\t\ti--\r\n\t\t} else if i >= 0 {\r\n\t\t\tbreak\r\n\t\t} else {\r\n\t\t\tnum = append([]int{k % 10}, num...)\r\n\t\t}\r\n\t}\r\n\r\n\treturn num\r\n}   \r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186214965","body":"## 思路\r\n\r\n> + 两次遍历-即求s[i]到c左右最近距离的最小值\r\n\r\n## 代码\r\n\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    n := len(s)\r\n    ans := make([]int, n)\r\n\r\n    idx := -n\r\n    for i, ch := range s {\r\n        if byte(ch) == c {\r\n            idx = i\r\n        }\r\n        ans[i] = i - idx\r\n    }\r\n\r\n    idx = n * 2\r\n    for i := n - 1; i >= 0; i-- {\r\n        if s[i] == c {\r\n            idx = i\r\n        }\r\n        ans[i] = min(ans[i], idx-i)\r\n    }\r\n    return ans\r\n}\r\n\r\nfunc min(a, b int) int {\r\n    if a > b {\r\n        return b\r\n    }\r\n    return a\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n> + 时间复杂度：O(n)\r\n> + 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aiweng1981":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185533265","body":"#Python 3\n#Idea:对将其从列表变字符串，再变整型，完成加法，再将结果变成字符串，最后字符串换成列表。\ndef day1(A,K):\n    A0 = []\n    for i in A:\n        A0.append(str(i))\n    A1 = \"\".join(A0)\n    a1 = int(A1)\n    sm = a1 + K\n    sm1 = str(sm)\n    sm2 = []\n    for j in sm1:\n        sm2.append(int(j))\n    return sm2\nA = [1,2,0,0]\nK = 304\nday1(A,K)\n#Complexity\n#Time: O(N)\n#Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186165511","body":"## 思路\n\n> + 思路描述: 看的答案，先学习一下；后来发现自己的思路和答案差不多，但是不会写，哈哈！\n\n##代码\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n\n        n = len(s)\n        ans = [0] * n\n\n        idx = -n\n        for i, ch in enumerate(s):\n            if ch == c:\n                idx = i\n            ans[i] = i - idx\n\n        idx = 2 * n\n        for i in range(n - 1, -1, -1):\n            if s[i] == c:\n                idx = i\n            ans[i] = min(ans[i], idx - i)\n        return ans\n```python\n#代码\n\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(N)\n> + 空间复杂度:  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186384452","body":"## 思路\n\n> + 思路描述:这个题目比较懵，先打卡，慢慢琢磨！\n\n##代码\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.c = maxSize\n        self.s = []\n\n    def push(self, x: int) -> None:\n        if len(self.s) < self.c:\n            self.s.append(x)\n\n    def pop(self) -> int:\n        if self.s:\n            return self.s.pop()\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.s))):\n            self.s[i] += val\n\n```python\n#代码\n\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(N)\n> + 空间复杂度:  O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richard-lime":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185549904","body":"### 思路\r\n用数组进行累加\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        for(int i = num.size() - 1; i > -1; i--){\r\n            num[i] += k % 10;\r\n            k = k / 10;\r\n        }\r\n        while(k > 0){\r\n            num.insert(num.begin(), k % 10);\r\n            k /= 10;\r\n        }\r\n        int j = num.size() - 1;\r\n        while(j > 0){\r\n            if(num[j] >= 10){\r\n                num[j] -= 10;\r\n                num[j - 1]++;\r\n            }     \r\n            j--;\r\n        }\r\n        if(num[0] >= 10){\r\n            num[0] -= 10;\r\n            num.insert(num.begin(), 1);\r\n        }\r\n        return num;\r\n    }\r\n};\r\n\r\n```\r\n**复杂度分析**\r\n- 时间复杂度O(n)\r\n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186216657","body":"# 思路\n蛮力\n# 代码\n```c++\nvector<int> shortestToChar(string s, char c) {\n        vector<int> ans;\n        vector<int> re;\n        for(int i = 0; i < s.length(); i++){\n            if(s[i] == c){\n                re.push_back(i);\n            }\n        }\n        int count = 0;\n        while(count < s.length()){\n            int min = INT_MAX;\n            for(int i = 0; i < re.size(); i++){\n                if(min > abs(re[i] - count)){\n                    min = abs(re[i] - count);\n                }\n            }\n            ans.push_back(min);\n            count++;\n        }\n        return ans;\n    }\n```\n**复杂度**\n- 时间O(n2)\n- 空间O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acoada":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185584460","body":"## 思路\n\n```raw\nres = []\nwhile (A or B):\n    a = A 当前位\n    b = B 当前位\n    \n    sum = a + b + 进位\n    \n    进位, 当前位 = divmod(sum, 10)\n    res.insert(0, 当前位)\n\n如果还有非 0 进位， res.insert(0, carry)\n```\n\n## 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        idx, sum_, carry = len(num) -1, 0, 0\n        while idx >= 0 or k != 0:\n            a = num[idx] if idx >= 0 else 0\n            b = k % 10 if k else 0\n\n            sum_ = a + b + carry\n            carry, curr = divmod(sum_, 10)\n            idx -= 1\n            k //= 10\n            res.insert(0, curr)\n        if carry:\n            res.insert(0, carry)\n        return res\n```\n\n## 复杂度\n\n- Time: O(N)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186206414","body":"## 思路\n\n1. 找到所有 `s` 中 `c` 的坐标\n2. 对于 `s` 中的每个元素都计算和所有 `c` 的坐标的距离\n\n## 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [None for _ in range(len(s))]\n        c_idxes = [idx for idx, i in enumerate(s) if i == c]\n\n        for idx, i in enumerate(s):\n            res[idx] = min( abs(idx - c_idx) for c_idx in c_idxes)\n        \n        return res\n```\n\n## 复杂度\n\n- Time: O(N)\n- Space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duanyaqi":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185585215","body":"# Day 1. [989. 数组形式的整数加法](https://leetcode.cn/problems/add-to-array-form-of-integer/)\r\n## 思路\r\n加法有以下公式：\r\n\r\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10   \r\n\r\n直接遍历相加即可，保存 carry，最后有 carry 额外加 1，从小到大加，最后保存的结果要翻转\r\n- 动态数组遍历数组\r\n- int 数字 `%10` 取最低位，`/10` 为了遍历下一个最低位\r\n\r\n```c++\r\nvector<int> addToArrayForm(vector<int>& num, int k) {\r\n    int carry = 0; \r\n    vector<int> res;\r\n    \r\n    // 遍历数组，进行加\r\n    for (int i = num.size() - 1; i >= 0; --i) {\r\n        int kn = k % 10;\r\n        k /= 10;\r\n\r\n        int sumn = kn + num[i] + carry;  //关键公式!!!\r\n\r\n        res.push_back(sumn % 10);\r\n        if (sumn >= 10) {\r\n            carry = 1;\r\n        } else {\r\n            carry = 0;\r\n        }\r\n    }\r\n\r\n    // 如果 k 还没处理完，继续处理 k\r\n    while (k > 0) {\r\n        int kn = k % 10;\r\n        k /= 10;\r\n\r\n        int sumn = kn + carry; //关键公式!!! 此时 num[i] 已经是 0 了\r\n\r\n        res.push_back(sumn % 10);\r\n        if (sumn >= 10) {\r\n            carry = 1;\r\n        } else {\r\n            carry = 0;\r\n        }\r\n    }\r\n\r\n    if (carry == 1) res.push_back(1);\r\n    reverse(res.begin(), res.end());\r\n\r\n    return res;\r\n}\r\n```\r\n> + 时间复杂度: O(max(n,logk))\r\n> + 空间复杂度: O(1)，常数级别，只有res\r\n\r\n\r\n## 优化\r\n\r\n发现两个循环其实是一样的，可以放在一起处理\r\n\r\n```c++\r\nvector<int> addToArrayForm(vector<int>& num, int k) {\r\n    int carry = 0;\r\n        \r\n    vector<int> res;\r\n    int i = num.size() - 1;\r\n    // 放到一起处理, 如果有一个变成 0, sumn 这里就相当于 + 0\r\n    while (i >= 0 || k > 0) {\r\n        int a = i < 0 ? 0 : num[i];\r\n        int kn = k == 0 ? 0 : k % 10;\r\n        k /= 10;\r\n\r\n        int sumn = a + kn + carry;\r\n\r\n        res.push_back(sumn % 10);\r\n        if (sumn >= 10) {\r\n            carry = 1;\r\n        } else {\r\n            carry = 0;\r\n        }\r\n        i--;\r\n    }\r\n\r\n    // 如果有进位\r\n    if (carry == 1) res.push_back(1);\r\n    reverse(res.begin(), res.end());\r\n\r\n    return res;\r\n}\r\n```\r\n\r\n没变化\r\n> + 时间复杂度: O(max(n,logk))\r\n> + 空间复杂度: O(1)，常数级别，只有res\r\n\r\n\r\n## 模板\r\n\r\n加法模板\r\n```c++\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\nend\r\n\r\n判断还有进位吗\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186090818","body":"# Day 2. [821. 字符的最短距离](https://leetcode.cn/problems/shortest-distance-to-a-character/)\r\n## 思路\r\n\r\n暴力\r\n\r\n- 找出来所有字符c的位置\r\n- 每个位置都与s的每个字符计算距离, 更新最小值\r\n\r\n```c++\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> res(s.size(), 0x3f3f3f3f);\r\n\r\n    vector<int> cset;\r\n\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) \r\n            cset.push_back(i);\r\n    }\r\n\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        for (int j = 0; j < cset.size(); ++j) {\r\n            res[i] = min(res[i], abs(i - cset[j]));\r\n        }\r\n    }\r\n\r\n    return res;\r\n}\r\n```\r\n> + 时间复杂度: O(mn), m是c的个数, n 是s的长度\r\n> + 空间复杂度: O(m + n)\r\n\r\n\r\n## 优化\r\n\r\nbfs + 判断 (主要好久没写bfs了, 练练手)\r\n\r\n\r\n```c++\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> res(s.size(), 0x3f3f3f3f);\r\n\r\n    queue<int> q;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) {\r\n            q.push(i);\r\n        }\r\n    }\r\n\r\n    while (q.size()) {\r\n        int idx = q.front(); q.pop();\r\n\r\n        for (int i = 0; i < s.size(); ++i) {\r\n            int dis = abs(i - idx);\r\n            if (res[i] > dis) {\r\n                res[i] = dis;\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n    return res;\r\n}\r\n```\r\n\r\n\r\n> + 时间复杂度: O(mn)\r\n> + 空间复杂度: O(m + n)\r\n\r\n\r\n## 模板\r\n\r\nbfs 迭代模板\r\n```c++\r\nqueue<int> q;\r\n// q.push(i);\r\nwhile (q.size()) {\r\n    int idx = q.front(); q.pop();\r\n\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        int dis = abs(i - idx);\r\n        if (res[i] > dis) {\r\n            res[i] = dis;\r\n            //q.push(i);\r\n        }\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185589950","body":"# 思路\r\n\r\n```\r\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\r\n\r\n```\r\n\r\n# 代码\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& A, int K) {\r\n        int a_len = A.size() - 1, sum = 0, carry = 0;\r\n        vector<int> res;\r\n        while (a_len >= 0 || K != 0) {\r\n            int x = a_len >= 0 ? A[a_len] : 0;\r\n            int y = K != 0 ? K % 10 : 0;\r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            sum %= 10;\r\n            K /= 10;\r\n            a_len--;\r\n            res.push_back(sum);\r\n        }\r\n        if (carry != 0)\r\n            res.push_back(carry);\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n# 复杂度\r\n+ 时间复杂度：O(n);\r\n+ 空间复杂度：O(1);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225771","body":"# 思路\r\n```\r\n记录下c的索引，然后每个字符挨个求最小值\r\n```\r\n\r\n# 代码\r\n```\r\nvector<int> shortestToChar(string &s, char c) {\r\n        vector<int> index;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s[i] == c) {\r\n                index.push_back(i);\r\n            }\r\n        }\r\n        vector<int> res;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s[i] == c)\r\n                res.push_back(0);\r\n            else {\r\n                int min_index = s.length();\r\n                for (int j = 0; j < index.size(); j++) {\r\n                    int deterval = index[j] - i >= 0 ? index[j] - i : i - index[j];\r\n                    if (deterval < min_index)\r\n                        min_index = deterval;\r\n                }\r\n                res.push_back(min_index);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n# 复杂度\r\n+ 空间：O(N)\r\n+ 时间：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaiykk":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185593642","body":"## 思路\n\n> + 思路描述\n倒着过一遍num，和k逐位相加。\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        idx = len(num) - 1\n        while k or idx > -1:\n            cur = k % 10 + num[idx] if idx >= 0 else k % 10\n            k //= 10\n            if cur >= 10:\n                k += 1\n                cur = cur % 10\n            res.append(cur)\n            idx -= 1\n        res.reverse()\n        return res\n```\n\n## 复杂度\n\n> + 时间复杂度: O(N)\n> + 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186180673","body":"## 思路\n\n> + 思路描述\n正向和负向各计算一次，每次一个指针找c一个指针指向尚未计算的元素\n\n```python\n#代码\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [len(s)] * len(s)\n        i = 0\n        for j in range(len(s)):\n            if s[j] == c:\n                while i <= j:\n                    res[i] = min(res[i], j - i)\n                    i += 1\n        i = len(s) - 1\n        for j in range(len(s)-1, -1, -1):\n            if s[j] == c:\n                while i >= j:\n                    res[i] = min(res[i], i - j)\n                    i -= 1\n        return res\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(n)\n> + 空间复杂度:  O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cachezhou0617":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185598055","body":"## 思路\r\n\r\n> + 参考题解后解答，回去查看讲义和类似题目 巩固之\r\n\r\n##代码\r\n\r\n```java\r\npublic List<Integer> addToArrayForm(int[] A, int K) {\r\n    List<Integer> res = new ArrayList<>();\r\n    int carry = 0;\r\n    int l1 = A.length - 1;\r\n    while (l1 >= 0 || K != 0) {\r\n        int x = l1 < 0 ? 0 : A[l1];\r\n        int y = K == 0 ? 0 : K % 10;\r\n\r\n        int sum = x + y + carry;\r\n        res.add(sum % 10);\r\n        carry = sum / 10;\r\n\r\n        l1--;\r\n        K = K / 10;\r\n    }\r\n    if (carry != 0) res.add(carry);\r\n    Collections.reverse(res);\r\n    return res;\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225705","body":"### 思路\r\n\r\n双向遍历，记录最小的值\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        // 从左往右遍历\r\n        for (int i = 0, index = -n; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = i - index;\r\n\r\n        }\r\n        \r\n        // 从右往左遍历\r\n        for (int i = n - 1, index = 2 * n; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = Math.min(res[i], index - i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangtuo1999":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185599809","body":"## 思路\r\n把 k 转换成数组，再将 num 和 k 两个数组反转。双指针，从头到尾依次将余数插入结果数组中。\r\n\r\n## 代码\r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  const num1 = num.reverse();\r\n  const num2 = k\r\n    .toString()\r\n    .split(\"\")\r\n    .map((item) => parseInt(item))\r\n    .reverse();\r\n  const result = [];\r\n  let m = 0;\r\n  let n = 0;\r\n  let extra = 0;\r\n  while (m < num1.length && n < num2.length) {\r\n    const sum = num1[m++] + num2[n++] + extra;\r\n    extra = sum > 9 ? 1 : 0;\r\n    result.push(sum % 10);\r\n  }\r\n  while (m < num1.length) {\r\n    const sum = num1[m++] + extra;\r\n    extra = sum > 9 ? 1 : 0;\r\n    result.push(sum % 10);\r\n  }\r\n  while (n < num2.length) {\r\n    const sum = num2[n++] + extra;\r\n    extra = sum > 9 ? 1 : 0;\r\n    result.push(sum % 10);\r\n  }\r\n  if (extra) {\r\n    result.push(1);\r\n  }\r\n  return result.reverse();\r\n};\r\n```\r\n## 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186218481","body":"```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n  const result = [];\r\n  for (let i = 0; i < s.length; i++) {\r\n    for (let j = 0; j < s.length; j++) {\r\n      if (s[j] === c) {\r\n        result[i] = Math.abs(i - j);\r\n        break;\r\n      }\r\n    }\r\n    for (let j = s.length - 1; j >= 0; j--) {\r\n      if (s[j] === c && Math.abs(i - j) < result[i]) {\r\n        result[i] = Math.abs(i - j);\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cytrue":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185613290","body":"           public List<Integer> addToArrayForm(int[] num, int k) {\n\n        List<Integer> res=new ArryList<Integer>();\n        int n=num.length;\n        for(int i=n-1;i>=0;--i)\n        {\n            int sum=num[i] + k % 10;//如果K=123这个数，那K % 10 取出来的是个数的余数，即把3取出来\n            K / =10;//相当于K=K/10；就是123除于10并取整返回，那就是往前进一位，返3去掉，返回12值给下一次用\n            if(sum>=10)//如果sum得出来的值大于10\n            {\n                k++;//把进位的值放在k上，即k进一位，加1\n                sum-=10;//把相加的值减掉进位\n            }\n            res.add(sum);\n        }\n        //如果num的位数小于K的位数，那还需要多一步处理K剩下的数\n        for(; k > 0;k / =10)//每次循环K的前进一位，如果小于0则表示已经没有数可以进位了\n        {\n            res.add(k % 10 ); //把K的余数取出来返回\n        }\n\n        Collections.reverse(res);\n        return res;\n\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186173222","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n=s.length();\n        int[] ans=new int[n];\n        for(int i=0,idx=-n;i<n;++i)\n        {\n            //第一层循环，从左往右找，主要是先找到值，更新找到值的后面偏移量，idx的初始值无所谓\n            if(s.charAt(i)==c)\n            {\n                idx=i;\n            }\n            ans[i]=i-idx;\n        }\n    //开始第二层循环,从右往左找\n      for(int i=n-1,idx=2*n;i>=0;--i)\n        {\n            if(s.charAt(i)==c)\n            {\n                idx=i;\n            }\n            ans[i]=Math.min(ans[i],idx-i);\n\n        }\n        return ans;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186413613","body":"//定义这个类，必须要有弹出和增加数据的接口\r\n//新增一个限制的数，还控制数量的增加，每次增和弹出栈的时候，先弹出数组的那个数，限制再减一\r\n\r\n class customerStack2{\r\n\r\n    int[] stack;\r\n    int top;\r\n\r\n    public customerStack2(int maxSize)\r\n    {\r\n    stack=new int[maxSize];\r\n    top =-1;\r\n    }\r\n\r\n    //新增一个数\r\n    public void push(int x)\r\n    {\r\n        if(top!=stack.length-1)\r\n\r\n        {\r\n            top++;\r\n            stack[top]=x;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    // 弹出一个数\r\n    public   int pop()\r\n    {\r\n\r\n        if (top==-1)\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        --top;\r\n        return stack[top+1];\r\n\r\n    }\r\n\r\n    //在每个数据上面增加一个数字\r\n    public void increment(int k,int x)\r\n    {\r\n\r\n        int max=Math.min(k, top+1);\r\n        for(int i=0;i<max;i++)\r\n        {\r\n         \r\n            stack[i] +=x;\r\n        }\r\n\r\n\r\n    }\r\n\r\n }","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyryan-web":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185615180","body":"```ts\nfunction addToArrayForm(num: number[], k: number): number[] {\n    const res: number[] = []\n\n    // 从数组的最右边开始计算，来模拟数字相加操作\n    const len = num.length\n\n    for (let i = len - 1; i >= 0; --i) {\n        let carry = num[i] + k % 10\n\n        k = Math.floor(k / 10)\n\n        if (carry >= 10) {\n            k++\n            carry = carry - 10\n        }\n\n        res.push(carry)\n    }\n\n    while (k > 0) {\n        res.push(k % 10)\n        k = Math.floor(k / 10)\n    }\n\n    res.reverse()\n\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186207697","body":"```ts\n/**\n * 正反遍历:\n * 思路为正反两个方向都遍历一次数据，然后取两次数组每个下表比较的最小值即可\n */\nfunction shortestToChar(s: string, c: string): number[] {\n    const n = s.length\n\n    /** 先定义一个跟 s 长度一样的数组去存储值 */\n    const answer: number[] = new Array(n).fill(0)\n\n    // 正向遍历\n    for (let i = 0, j = -n; i < n; i++) {\n        if (s[i] === c) {\n            j = i\n        }\n\n        // 计算每个下标到 \"c\" 字符串的距离\n        answer[i] = i - j\n\n    }\n\n    // 反向遍历\n    for (let i = n - 1, j = 2 * n; i >= 0; i--) {\n        if (s[i] === c) {\n            j = i\n        }\n\n        answer[i] = Math.min(answer[i], j - i)\n\n    }\n\n    return answer\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186416013","body":"```ts\nclass CustomStack {\n    protected stack!: number[]\n    protected top!: number\n\n    constructor(maxSize: number) {\n        this.stack = new Array(maxSize)\n        this.top = -1\n    }\n\n    push(x: number): void {\n        // 只要是不超过栈的最大长度\n        if (this.top !== this.stack.length - 1) {\n            this.top++\n            this.stack[this.top] = x\n        }\n    }\n\n    pop(): number {\n        // 判断为空的栈\n        if (this.top === -1) {\n            return -1\n        }\n        this.top--\n        return this.stack[this.top + 1]\n    }\n\n    increment(k: number, val: number): void {\n        const limit = Math.min(k, this.top + 1)\n        for (let i = 0; i < limit; i++) {\n            this.stack[i] = this.stack[i] + val\n        }\n    }\n}\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185615532","body":"### **思路：加法问题**\n\n倒着过一遍num，和k逐位相加。\n\n1. k的位数：用取mod和地板除可以直接把k用掉的位置扔掉，同时如果要进位，直接进位到k上即可。是一种比较便捷的方式。\n2. 一开始想用先初始化n长度的list存储结果，但是其实list长度很难定，所以可以直接用reverse，reverse复杂度是O(n)\n3. 注意会有k长度比num大的情况的！并不都是k长度小于n，所以要考虑遍历完还有k或者carry的情况\n    \n\n### **代码**\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        res = []\n        for i in range(len(num)-1, -1, -1):\n            cur_n = num[i]\n            cur_add = k % 10\n            add_n = cur_n + cur_add + carry\n            res.append(add_n % 10)\n            carry = add_n // 10\n            k //= 10\n        while k or carry:\n            cur_add = k % 10\n            add_n = cur_add + carry\n            res.append(add_n % 10)\n            carry = add_n // 10\n            k //= 10\n        res.reverse()\n        return res\n\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(min(n,k)) reverse复杂度是O(n) 所以是n长度和k长度最小值\n- 空间复杂度：O(1) 没有额外空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186173638","body":"## **思路: 正反双指针**\n\n正向和负向各计算一次，每次一个指针找c一个指针指向尚未计算的元素\n\n### **代码**\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [len(s)] * len(s)\n        i = 0\n        for j in range(len(s)): # j是右指针，右指针碰到c的话，就开始计算左指针\n            if s[j] == c:\n                while i <= j:\n                    res[i] = min(res[i], j-i)\n                    i += 1\n        i = len(s) - 1\n        for j in range(len(s)-1, -1, -1):\n            if s[j] == c:\n                while i >= j:\n                    res[i] = min(res[i], i-j)\n                    i -= 1\n        return res\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(2n) n是s长度\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185624746","body":"#### 解题思路\n  1. 低位到高位逐位将数字加在一起\n  2. 若加法的结果大于等于 1010，把进位的 11 加入到下一位的计算中\n#### 代码实现\n\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度: O(max(n,logk), 其中 nn 为数组的长度\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186215661","body":"#### 解题思路\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 C。\n- 如果只在一个方向找到，直接计算字符距离。\n- 如果两个方向都找到，取两个距离的最小值\n\n#### 代码实现\n\n```\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  const res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185628129","body":"### 思路\n新建一个数组，长度为num和k的长度的最大值，从num和k的末尾开始相加，得到的值赋值到新数组中，注意进位。\n\n### 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n  let size = Math.max(num.length, (k + '').length);\n  let res = new Array(size);\n  let j = num.length - 1;\n  for (let i = res.length - 1; i >= 0; i--) {\n    let sum = k % 10;\n    if (j >= 0) sum += num[j];\n    if (res[i]) sum += res[i];\n    if (i === 0) {\n      res[i] = sum;\n    } else {\n      res[i] = sum % 10;\n      res[i - 1] = Math.floor(sum / 10);\n    }\n    k = Math.floor(k / 10);\n    j--;\n  }\n  if (res[0] >= 10) {\n    let s = res[0];\n    res[0] = s % 10;\n    res.unshift(Math.floor(s /10));\n  }\n  return res;\n};\n```\n\n### 复杂度\n* time: O(n)\n* space: O(n)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186381448","body":"```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.arr = [];\n  this.maxSize = maxSize;\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.arr.length < this.maxSize) this.arr.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if (this.arr.length === 0) return -1;\n  else return this.arr.pop();\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  for (let i = 0; i < k; i++) {\n    if (i >= this.arr.length) break;\n    this.arr[i] += val;\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n/**\n * 栈\n * time: O(n)\n * space: O(n)\n*/\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnxizhao":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185630005","body":"## 思路\r\n遍历数组，从后向前加；随时更新进位变量;\r\n最后需要注意进位是否为1\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        if(k == 0) {\r\n            return Arrays.stream(num).boxed().collect(Collectors.toList());\r\n        }\r\n        StringBuffer sb = new StringBuffer();\r\n        List<Integer> res = new ArrayList<>();\r\n        int n = num.length;\r\n        int carry = 0;\r\n        int ans = 0;\r\n        int i = n - 1;\r\n        while(i >= 0 || k != 0) {\r\n            int x = i >= 0 ? num[i] : 0;\r\n            int y =  k != 0 ? k % 10 : 0;\r\n            int sum = x + y + carry;\r\n            carry = sum / 10;\r\n            ans = sum % 10;\r\n            i--;\r\n            res.add(0, ans);\r\n            k /= 10;\r\n        }\r\n        \r\n        if(carry != 0) {\r\n            res.add(0, carry);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186207847","body":"## 思路\r\n0，双指针：i 进行字符串遍历，j 进行目标字符位置的固定；\r\n1，从左向右遍历，记录每个字符与其左边的目标字符的距离；\r\n2，再从右向左遍历，记录每个字符与其右边出现的目标字符的距离，与结果数组中的取小值；\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        if(s == null || s.length() == 0) {\r\n            return new int[0];\r\n        }\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        Arrays.fill(res, n + 1);\r\n        // j 记录左侧第一个 c 的坐标\r\n        for(int i = 0, j = -1; i < n; i++) {\r\n            if(s.charAt(i) == c) {\r\n                j = i;\r\n            }\r\n            if(j != -1) {\r\n                res[i] = i - j;\r\n            }\r\n        }\r\n        // 从右向左遍历，j 为第一个 c 的坐标\r\n        for(int i = n - 1, j = -1; i >= 0; i--) {\r\n            if(s.charAt(i) == c) {\r\n                j = i;\r\n            }\r\n            if(j != -1) {\r\n                res[i] = Math.min(res[i], j - i);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"incipe-win":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185631706","body":"## 思路\r\n把 `k` 的每一位转换成一个 vector，然后进行两个 vector 相加即可。\r\n## 代码\r\n````cpp\r\nclass Solution {\r\nprivate:\r\n    vector<int> addTwo(vector<int> &num1, vector<int> &num2) {\r\n        // [1, 2, 0, 0] + [3, 4]\r\n        int size1 = num1.size() - 1, size2 = num2.size() - 1;\r\n        vector<int> ans;\r\n        int carry = 0;\r\n        while (size1 >= 0 || size2 >= 0) {\r\n            int x1 = size1 >= 0 ? num1[size1] : 0;\r\n            int x2 = size2 >= 0 ? num2[size2] : 0;\r\n            int sum = x1 + x2 + carry;\r\n            carry = sum / 10;\r\n            sum %= 10;\r\n            ans.emplace_back(sum);\r\n            --size1;\r\n            --size2;\r\n        }\r\n        if (carry) {\r\n            ans.emplace_back(carry);\r\n        }\r\n        reverse(ans.begin(), ans.end());\r\n        return ans;\r\n    }\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> num1;\r\n        while (k) {\r\n            num1.emplace_back(k % 10);\r\n            k /= 10;\r\n        }\r\n        reverse(num1.begin(), num1.end());\r\n        return addTwo(num, num1);\r\n    }\r\n};\r\n````\r\n## 时空复杂度\r\n时间复杂度：$O(n)$\r\n空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185717663","body":"## 思路\n暴力法，直接记录所有结果的给定字符的位置，遍历一遍字符串，取距离最小的值\n## 代码\n````cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> ans;\n        vector<int> tmp;\n        int size = s.size();\n        for (int i = 0; i < size; ++i) {\n            if (s[i] == c) {\n                tmp.emplace_back(i);\n            }\n        }\n        int cnt = 0;\n        for (int i = 0; i < size; ++i) {\n            int minn = INT_MAX;\n            for (int j = 0; j < (int)tmp.size(); ++j) {\n                minn = min(minn, abs(tmp[j] - i));\n            }\n            ans.emplace_back(minn);\n        }\n        return ans;\n    }\n};\n````\n## 时空复杂度\n时间复杂度：$O(n \\times k)$ <br />\n空间复杂度：$O(k)$ <br />\nk为字符的个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186235143","body":"## 思路\r\n利用数组模拟栈的 `push`, `pop` 操作，最后的 `increment` 直接把数组前 `k` 个加上 `val` 即可。\r\n## 代码\r\nC++\r\n````cpp\r\nclass CustomStack {\r\nprivate:\r\n    vector<int> vec;\r\n    int cnt;\r\n    int maxSize;\r\npublic:\r\n    CustomStack(int _maxSize) {\r\n        cnt = 0;\r\n        maxSize = _maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (cnt < maxSize) {\r\n            vec.emplace_back(x);\r\n            ++cnt;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (cnt == 0) {\r\n            return -1;\r\n        }\r\n        int ret = vec[cnt - 1];\r\n        vec.pop_back();\r\n        --cnt;\r\n        return ret;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        if (cnt < k) {\r\n            k = cnt;\r\n        }\r\n        for (int i = 0; i < k; ++i) {\r\n            vec[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n````\r\nPython\r\n````python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.cnt = 0\r\n        self.vec = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.maxSize:\r\n            self.vec.append(x)\r\n            self.cnt += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt == 0:\r\n            return -1\r\n        self.cnt -= 1\r\n        return self.vec.pop(-1)\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k > self.cnt:\r\n            k = self.cnt\r\n        for i in range(k):\r\n            self.vec[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n````\r\n## 时空复杂度\r\n时间复杂度：$O(k)$\r\n空间复杂度：$O(maxSize)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"revisegoal":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185633040","body":"## 进位处理\n从低位往高位相加，并处理进位，可以用k同时存储进位信息，每次迭代有 k = (num[i] + k) / 10\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int len = num.length;\n        for (int i = len - 1; i >= 0; i--) {\n            res.add(0, (num[i] + k) % 10);\n            k = (num[i] + k) / 10;\n        }\n        while (k != 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n        return res;\n    }\n}\n```\n\n```go\nfunc addToArrayForm(num []int, k int) []int {\n    res := make([]int, 0)\n    for i := len(num) - 1; i >= 0; i-- {\n        res = append(res, (num[i] + k) % 10)\n        k = (num[i] + k) / 10\n    }\n    for k != 0 {\n        res = append(res, k % 10)\n        k /= 10\n    }\n    for i, j := 0, len(res) - 1; i < j; i, j = i + 1, j - 1 {\n        res[i], res[j] = res[j], res[i]\n    }\n    return res\n}\n```\n- time: O(max(len(num), digit(k))，时间复杂度是和的长度n，是num和k最大的那个（可能会是max(len(num), digit(k)) + C，不过大O表示法忽略常数项C，可以不做讨论）\n- space: O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185703099","body":"## 遍历\n左右遍历数组\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int pre = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE;\n        for (int i = len - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = Math.min(res[i], pre - i);\n        }\n        return res;\n    }\n}\n```\n```go\nfunc shortestToChar(s string, c byte) []int {\n    const (\n        INT_MAX = int(^uint(0) >> 1)\n        INT_MIN = ^INT_MAX\n    )\n    res := make([]int, 0)\n    pre := INT_MIN / 2\n    for i := 0; i < len(s); i++ {\n        if s[i] == c {\n            pre = i\n        }\n        res = append(res, i - pre)\n    }\n    pre = INT_MAX\n    for i := len(s) - 1; i >= 0; i-- {\n        if s[i] == c {\n            pre = i\n        }\n        tmp := pre - i\n        if tmp < res[i] {\n            res[i] = tmp\n        }  \n    }\n    return res\n}\n```\n- time: O(n)\n- space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckysq999":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185637894","body":"### 思路\n两数相加\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\n\n### 代码\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        List<Integer> res = new LinkedList<>();//LinkedList比ArrayList快\n        int i = n - 1, sum = 0, carry = 0, x = 0, y = 0;\n        while (i >= 0 || k != 0) {\n            x = i >= 0 ? num[i] : 0;\n            y = k >= 0 ? k % 10 : 0;\n            sum = x + y + carry;\n            carry = sum / 10;\n            i--;\n            k = k / 10;\n            res.add(0, sum % 10);\n        }\n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186193656","body":"### 思路\ntask：求当前下标字符到指定字符的最近距离\n\naction:\n需要两次遍历 \n\n对 s 的每个下标 i，求 \n\n从最左边开始，找到 s[i] 左侧最近的字符c的下标，并计算 s[i] 到其下标的距离\n\n从最右边开始，找到 s[i] 右侧最近的字符c的下标，并计算 s[i] 到其下标的距离\n\n### 代码\n\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n=s.length();\n        int[] answer=new int[n];\n\n        for(int i=0, index=-n;i<n;i++)\n        {\n            if(s.charAt(i)==c) index=i;\n            answer[i]=i-index;\n        }\n\n        for(int i=n-1, index=2*n-1;i>=0;i--)\n        {\n            if(s.charAt(i)==c) index=i;\n            answer[i]=Math.min(answer[i],index-i);\n        }\n        return answer;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dereklisdr":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185638851","body":"/* 思路 */\n- 两个数相加：从个位数相加(从右向左) 考虑进位 一个一个加入ArrayList入List首位\n\n/* 代码 Java */\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = num.length-1; i >= 0; i--) {\n            int current = k%10 + num[i];\n            k /= 10;\n            \n            if (current >= 10) {\n                k += 1;\n            }\n            \n            result.add(0, current%10);\n        }\n        \n        while (k > 0) {\n            result.add(0, k%10);\n            k /= 10;\n        }\n        \n        return result;\n    }\n}\n\n/* 时间和空间分析\nTime  : O(n) - 一次循环\nSpace : O(n) - 两数相加的位数\n*/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186218643","body":"/* Idea\n- loop 1(left to right): compare the index with the first closet left c\n- loop 2(right to left): compare the index with the first closet right c\n- compare two loop indexs, and take the min value\n*/\n\n/* Code Java */\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < len; ++i) {\n            if (s.charAt(i) == c) prev = i;\n            res[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = len-1; i >= 0; --i) {\n            if (s.charAt(i) == c) prev = i;\n            res[i] = Math.min(res[i], prev - i);\n        }\n\n        return res;\n    }\n}\n\n/* Complexity Analysis\nTime  : O(n) : 2 n loops\nSpace : O(n) : return n int array\n*/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186313748","body":"/* Idea\n-  Use int[] to simulate stack.\n*/\n\n/* Code Java */\nclass CustomStack {\n    private int[] items;\n    // size: count of current items occupied; pointer to next item.\n    private int size = 0;\n\n    public CustomStack(int maxSize) {\n        items = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (size == items.length)\n            return;\n        items[size++] = x;\n    }\n\n    public int pop() {\n        if (size == 0)\n            return -1;\n        return items[--size];\n    }\n\n    public void increment(int k, int val) {\n        for (int i = 0; i < Math.min(k, size); i++) {\n            items[i] += val;\n        }\n    }\n}\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n/* Complexity Analysis\nTime Complexity : O(n)\nspase Complexity: O(maxSize)\n*/","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"perfqi":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185644120","body":"常规思路：1.数组和数字相互转换；2.两数组逐位相加\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mryao1":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185647007","body":"```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> sum = new ArrayList<Integer>();\n        int length = num.length;\n        num[length - 1] += k;\n        for (int i = length - 1; i > 0; i--) {\n            int curNum = num[i];\n            if (curNum > 9) {\n                num[i - 1] += curNum / 10;\n                num[i] %= 10;\n            }\n            sum.add(num[i]);\n        }\n        do {\n            sum.add(num[0] % 10);\n            num[0] /= 10;\n        } while (num[0] > 0);\n        Collections.reverse(sum);\n        return sum;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"likeyousmile":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185652987","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        nstr = ''.join(map(str,num))\n        n = int(nstr)\n        res = n + k\n        return list(map(int,str(res)))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhg1992":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185656280","body":"```go\nfunc addToArrayForm(num []int, k int) []int {\n\tvar ans []int\n\tfor i := len(num) - 1; i >= 0; i-- {\n\t\tsum := num[i] + k%10\n\t\tk /= 10\n\t\tif sum >= 10 {\n\t\t\tk++\n\t\t\tsum -= 10\n\t\t}\n\t\tans = append(ans, sum)\n\t}\n\tfor ; k > 0; k /= 10 {\n\t\tans = append(ans, k%10)\n\t}\n\treverse(ans)\n\treturn ans\n}\nfunc reverse(num []int) {\n\tfor i, n := 0, len(num); i < n/2; i++ {\n\t\tnum[i], num[n-1-i] = num[n-1-i], num[i]\n\t}\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liquanluo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185658739","body":"```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int increase = 0;\n        reverse(num.begin(), num.end());\n        int pos = 0;\n        vector<int> result;\n        while (k > 0 || pos < num.size() || increase > 0 ) {\n            auto digit = k % 10;\n            auto num_digit = pos < num.size() ? num[pos] : 0;\n            auto new_val = num_digit + digit + increase;\n            increase = new_val / 10;\n            new_val = new_val % 10;\n            result.push_back(new_val);\n            \n            ++pos;\n            k = k / 10;\n            // cout << new_val << endl;\n        }\n        \n        // cout << result.size() << endl;\n        reverse(result.begin(), result.end());\n        return result;\n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186213458","body":"### Solution:\n- 1. Initialize a result vector which has the same size as string, all the value is INF, [INF, INF....]  O(n)\n- 2. Find the c in the string, and mark the corresponding position as 0 [INF,..0... 0....INF]  O(n)\n- 3. Then for each c, update's left and right value incrementally, until it hits the boundary of the vector or 0 O(n)\n- Time complexity O(n)\n### Code:\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> results(s.size(), INT_MAX);\n        for (int i = 0; i < s.size(); ++i ) {\n            if (s[i] == c) {\n                results[i] = 0;\n            }\n        }\n        \n        for (int i = 0; i < s.size(); ++i ) {\n            if (results[i] == 0) {\n                update_left(results, i);\n                update_right(results, i);\n            }\n        }\n    \n        return results;\n    }\n    \n    \n    void update_left(vector<int>& results, int idx) {\n        auto distance = 0;\n        while (idx > 0) {\n            --idx;\n            ++distance;\n            if (distance < results[idx]) {\n                results[idx] = distance;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    \n    void update_right(vector<int>& results, int idx) {\n        auto distance = 0;\n        while (idx < results.size() - 1) {\n            ++idx;\n            ++distance;\n            if (distance < results[idx]) {\n                results[idx] = distance;\n            }\n            else {\n                break;\n            }\n            \n        }\n    }\n    \n    \n};\n\n```\n\n**complexity analysis**\n- Time：O(N)，\n- Space：O(1)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aq666888":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185658990","body":"### 解题思路\n\n​\t将数组的每一位倒序取出然后和k进行相加，确保k每次是个位数。\n\n​\t当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\n\n​\t注意，AB两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在前面。\n\n​\t最后反转数组\n\n### 代码实现\n\n```java\nclass Solution {\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> res = new ArrayList<Integer>();  \n    int carry=0; //判断进位\n    int i=num.length -1; //判断数组里的整数是否遍历结束\n    // 可以用 LinkeList，或者 ArrayList 往后加，最后反转\n\n    while (i >= 0 || k!= 0) { \n        int x = i>= 0 ? num[i]: 0;\n        int y = k!= 0 ? k % 10 : 0;\n                    \n        int sum = x + y + carry;\n        res.add(sum % 10);\n        carry =sum/10;\n        i--;\n        k=k/10;\n    }\n        if(carry !=0)res.add(carry);\n        Collections.reverse(res);\n        return res;\n       \n\t}\n}    \n```\n\n\n\n### 复杂度：\n\n```md\n时间复杂度 : O(min(n,k)) \n空间复杂度: O(n)\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186211456","body":"\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n\n int length=s.length();\n        List<Integer> list=new ArrayList<Integer>();\n        int[] res=new int[length];\n        for(int i=0;i<length;i++)\n        {\n            if(s.charAt(i)==c)\n            {\n                list.add(i);\n            }\n        }\n        int i=0;\n        int j=0;\n        while(i<length)\n        {\n            int min=Math.abs(list.get(j)-i);\n            while(j<list.size())\n            {\n                if(min>Math.abs(list.get(j)-i))\n                {\n                    min=Math.abs(list.get(j)-i);\n                }\n                j++;\n            }\n            res[i]=min;\n            j=0;\n            i++;\n        }\n        return res;\n\n    }\n}\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samlu-ecnu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185660112","body":"### 思路\n\n数字还原后相加，再转换为数字列表。\n\n### 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        degit = 0\n        for d in num:\n            degit *= 10\n            degit += d\n        # print(degit)\n        k += degit\n        # print(k)\n\n        res = []\n        while k != 0:\n            res.append(k % 10)\n            # print(res)\n            k //= 10\n        return res[::-1]\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186223951","body":"### 思路\n\n遍历一遍字符串，得到`id_list`存储相等的索引，并且置返回数组`ans`对应位置为0；再次遍历数组，对于每个不相等的字符位置计算`id_list`中，与之最近的索引距离，并记录在返回数组`ans`对应位置。\n\n### 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = [-1] * len(s)\n        id_list = []\n        for i in range(len(s)):\n            if s[i] == c:\n                ans[i] = 0\n                id_list.append(i)\n        for i, ch in enumerate(s):\n            if ch != c:\n                min_dst = len(s)\n                for idx in id_list:\n                    min_dst = min(min_dst, abs(i - idx))\n                ans[i] = min_dst\n                \n        return ans\n```\n\n### 复杂度\n\n时间复杂度：$O(n^2)$\n\n空间复杂度：$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongxiangxiang":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185660258","body":"## 思路\r\n将num和k都转成数组（增加了额外空间，呜呜～～）并倒序，每个元素因此相加，若大于等于10，下一次相加另外再加1\r\n\r\n## 代码\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    let arr1 = num.reverse()\r\n    let arr2 = String(k).split('').reverse().map(item => Number(item))\r\n    let i = 0\r\n    let arr = []\r\n    let extra = 0\r\n    while(i < arr1.length || i < arr2.length) {\r\n        let sum = (arr1[i] || 0) + (arr2[i] || 0) + extra\r\n        if (sum >= 10) {\r\n            arr.push(sum - 10)\r\n            extra = 1\r\n        } else {\r\n            arr.push(sum)\r\n            extra = 0\r\n        }\r\n        i++\r\n    }\r\n    if (extra === 1) {\r\n        arr.push(1)\r\n    }\r\n    \r\n    return arr.reverse()\r\n};\r\n```\r\n\r\n## 复杂度\r\n时间：O(n), 数组的reverse不知道复杂度多少\r\n空间：O(n),","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hatorimain":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185660712","body":"## 思路\n这题如果用链表做可以通过使用addFirst这个方法来降低复杂度，参考了leetcode 讨论区java的solution。\n将k加上数组的每位，然后mod10，得到的值放在linkedlist里。\n然后将k /= 10后将这个值加到下一位。\n\n## 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> res = new LinkedList<>();\n        int len = num.length - 1;\n        while(len >= 0 || k != 0){\n            if(len >= 0)  k += num[len--];\n            res.addFirst(k % 10);\n            k = k /10;\n        }\n        \n        return res;\n    }\n}\n```\n\n## 复杂度\n时间复杂度： O(max(n, log10(k)))\n空间复杂度：O(max(n, log10(k)))\n\n时间复杂度不是数组的长度就是log10k，空间复杂度是因为我们需要开新的空间来把结果存到linkedlist里面。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186210190","body":"## 思路\n直接参考了力扣的最优解，用一个数组储存结果。\n最近的c的索引先设成无穷小。\n先从左边扫描一次数组比较每个index和最近的c的index的距离。然后存进数组对应的index。\n最近的c的索引设成无穷大。\n再从右边扫描一次数组比较每个index和最近的c的index的距离，然后与之前的数组的值比较，取小的那个。\n\n## 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int prev = Integer.MIN_VALUE / 2;\n        int[] ans = new int[n];\n        for(int i = 0; i < n; i++) {\n            if(s.charAt(i) == c) prev = i;\n            ans[i] = i - prev;\n        }\n        \n        prev = Integer.MAX_VALUE / 2;\n        for(int i = n - 1; i >= 0; i--) {\n            if(s.charAt(i) == c) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n        return ans;\n    }\n}\n```\n\n## 复杂度\n- 时间复杂度： O(N)\n因为就是遍历了两遍数组\n- 空间复杂度：O(N)\n创建了一个跟原来n一样长度的数组来储存结果。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"neado":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185661466","body":"### 思路\n\n最后一个元素开始遍历，遍历到最后一个元素若是索引到了尽头，而还有进位就依据 || k>0逻辑再次运算一遍\n维护一个相加数k\n并存储计算之后的结果\n最后返回结果数组\n### 代码\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n=num.length;\n        LinkedList<Integer> res=new LinkedList<>();\n        for(int i=n-1;i>-1|| k>0;i--){\n            if(i>-1 ){\n                k=k+num[i];\n            }\n            Integer r=k%10;\n            res.addFirst(r);\n            k=k/10;\n        }\n        return res;\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度(Time)：O(N)\n- 空间复杂度(Space)：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225868","body":"## 思路\n先遍历字符，存下标\n再bfs\n## 代码\n```java\nclass Solution {\n    int[] dirs = new int[]{-1, 1};\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] res = new int[n];\n\n        //填入-1 ，用于判断是否目标字符\n        Arrays.fill(res, -1);\n\n        Deque<Integer> d = new ArrayDeque<>();\n\n        //目标字符 入队，结果数组置为0\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                d.addLast(i);\n                res[i] = 0;\n            }\n        }\n        //bfs 遍历数据，从左到右，遍历目标字符下标\n        while (!d.isEmpty()) {\n            int t = d.pollFirst();\n            //前后搜索\n            for (int dir : dirs) {\n                //移动后下标\n                int index = t + dir;\n                //只处理非目标字符\n                if (index >= 0 && index < n && res[index] == -1) {\n                    //无论向哪个方向移动，距离都会加1\n                    res[index] = res[t] + 1;\n                    d.addLast(index);\n                }\n            }\n        }\n        return res;\n    }\n}\n\n```\n## 复杂度分析\n时间复杂度： O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaojunjun1110":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185663624","body":"#  思路\r\n从后往前累加，有很多边界要处理，参考了官方题解\r\n# Code\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int len = num.length;\r\n        int sum;\r\n        for(int i = len - 1; i >= 0; i--){\r\n            sum = num[i] + k % 10;\r\n            k = k /10;\r\n            if(sum >= 10){\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n       for (; k > 0; k /= 10) {\r\n           res.add(k % 10);\r\n       }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186210463","body":"## 思路\r\n\r\n> + 暴力法，分别左右遍历取最小,看题解原来双向遍历就好了。。。\r\n\r\n##代码\r\n\r\n```java\r\n#代码\r\n\r\n```class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int j, k;\r\n        int res[] = new int[s.length()];\r\n        for(int i = 0; i < s.length(); i++){\r\n            j = i -1;\r\n            k = i + 1;\r\n            int minLen = Integer.MAX_VALUE;\r\n            if(s.charAt(i) == c){\r\n                res[i] = 0;\r\n            } else {\r\n                while(j >= 0 || k < s.length()){\r\n                    if(j >= 0 && s.charAt(j) == c){\r\n                        minLen = Math.min(minLen, i - j);\r\n                    }\r\n                    if(k < s.length() && s.charAt(k) == c){\r\n                        minLen = Math.min(minLen, k - i);\r\n                    }\r\n                    j--;\r\n                    k++;\r\n                }\r\n                res[i] = minLen;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n2)\r\n> + 空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wxleah":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185664303","body":"### 思路\r\n1. 将整数加到数组最后一位即个位，取余作为个位\r\n2. 加和结果的整除结果进位，加到数组下一位\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        n = len(num)\r\n        i = n - 1\r\n        while i >= 0 or k > 0:\r\n            if i >= 0:\r\n                k += num[i]\r\n            res.append(k % 10)\r\n            i -= 1\r\n            k //= 10\r\n        res.reverse()\r\n        return res\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(max(n, logk)，其中 n 为数组长度。（k有logk位数）\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186211008","body":"## 题目\r\n[821](https://leetcode.cn/problems/shortest-distance-to-a-character/)\r\nGiven a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\r\n\r\nThe distance between two indices i and j is abs(i - j), where abs is the absolute value function.\r\n\r\n## 左右分别找\r\n### 思路\r\n?\r\n**_左边最近_**----从左往右遍历, 当找到字符时, 更新字符位置loc, 字符位置在遍历到的位置i左边, distance = i-loc\r\n**_右边最近_**----从右往左遍历, 字符位置loc在遍历到的位置i右边, distance = loc-i\r\n**_比大小_**----将更小的值存到结果里\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n =len(s)\r\n        res = [] \r\n\r\n        # 从左往右, 距离为i-loc\r\n        loc = - n # 若左边未找到c, 确保距离>=n\r\n        for i, ch in enumerate(s) :\r\n            if ch == c:\r\n                loc = i\r\n            res.append(i - loc)\r\n        \r\n        # 从右往左, 距离为loc-i\r\n        loc = 2*n # 若右边未找到c, 确保距离>=n\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                loc = i\r\n            res[i] = min(loc - i, res[i])\r\n        \r\n        return res\r\n```\r\n\r\n### 复杂度分析\r\n?\r\n- 时间复杂度：O(n)，其中 n 为数组长度。遍历两遍\r\n- 空间复杂度：O(1) \r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunl1ght":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185665340","body":"# 思路\n\n遍历数组，每次都让数组的最后一位和数字的个位求和，代码如下：\n\n- 时间复杂度O(N)，\n\n- 空间复杂度O(N)\n\n# 代码\n```Java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        List<Integer> res = new ArrayList<>();\n        int i = A.length - 1, sum = 0, carry = 0;\n        // 循环遍历数组A，每次都将数组末尾和数字K的个位进行求和\n        while (i >= 0 || K != 0) {  \n            int x = i >= 0 ? A[i]: 0;\n            int y = K != 0 ? K % 10 : 0;\n            sum = x + y + carry;\n            carry = sum / 10;\n            K /= 10;\n            i--;\n            res.add(0, sum % 10);\n        }\n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186213449","body":"## 思路\n先统计字符串s中出现的c的位置存入一列表，再将字符串各位置与列表中值依次对比，比较得出最小的存入输出数组中。\n\n## 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] chs = s.toCharArray();\n        int[] res = new int[chs.length];\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < chs.length; i++) {\n            if (chs[i] == c){\n                list.add(i);\n            }\n        }\n        for (int i = 0; i < chs.length; i++) {\n            int min = Integer.MAX_VALUE;\n            for (int j = 0; j < list.size(); j++) {\n                if (Math.abs(i - list.get(j)) < min) {\n                    min = Math.abs(i - list.get(j));\n                } \n            }\n            res[i] = min;\n        }\n        return res;\n    }\n}\n```\n## 复杂度\n- 时间复杂度O(N^2)\n- 空间复杂度O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kerrhl":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185667597","body":"### 思路\n参考了做的，倒着取取每个位数相加，单独考虑进位（没太看懂那种三个放在一起加的）\n\n### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        ans = []\n        \n        for i in range(len(num)-1, -1, -1):\n            all = num[i] + k % 10\n            k = k // 10\n            if all >= 10:\n                k = k + 1\n            ans.append(all % 10)\n            \n        while k > 0:\n            ans.append(k % 10)\n            k = k // 10\n        return ans[::-1]\n```\n### 复杂度\n时间复杂度: O(n)\n\n空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185667727","body":"## 思路\r\n倒叙无脑加整数k\r\n## 代码\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = 0\r\n        length = len(num)\r\n        carry = k\r\n        while(carry>0):\r\n            if i < length:\r\n                sum = num[-i-1] + carry\r\n                num[-i-1] = sum % 10\r\n                carry = sum // 10\r\n            else:\r\n                num = [carry%10] + num\r\n                carry = carry // 10\r\n            i+=1\r\n        return num\r\n```\r\n### 时间复杂度: O(n)\r\n### 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186197767","body":"```python3\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = r = 0\r\n        n = len(s)\r\n        res = [n] * n\r\n        flag = False  \r\n        while r <= n - 1:\r\n            if s[r] == c:\r\n                res[r] = 0\r\n                while l <= r:\r\n                    res[l] = min(res[l], r - l)\r\n                    l += 1\r\n                r += 1\r\n                flag = True\r\n            else:\r\n                if flag:\r\n                    res[r] = res[r-1] + 1\r\n                r += 1\r\n        return res\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185668901","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        l = len(num)\r\n        list_num = 0\r\n        for i in range(l):\r\n            list_num = list_num + num[i]*10^(l-(i-1))\r\n            print(num[i]*10^(l-(i-1)))\r\n        list2_num = list_num + k\r\n        str1 = str(list2_num)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186216337","body":"### Code\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        l = len(s)\n        cIndex = []\n        for i in range(l):\n            if s[i] == c:\n                cIndex.append(i)\n        lenlist = [[] for i in range(l)]\n        for index, j in enumerate(s):\n            if j == c:\n                lenlist[index] = 0\n            else:\n                short = l\n                for k in range(len(cIndex)):\n                    short = min(short, abs(index-cIndex[k]))\n                lenlist[index] = short\n        return lenlist\n\n```\n### 复杂度\n- 时间：O(l*k), l是s的长度，k是c的出现的次数\n- 空间：O(l)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c1f2h3":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185673058","body":"# 思路\n\n写了一下，提交不对，应该是数据溢出了，直接变为两个数相加的办法不太行\n考虑一种做法，将其变为 num 数组中的元素依次与 k 相加，第一步先末位与 k 相加，结果对 10 取余与下一位相加，当前位置保留对 10 取余\n最后考虑是否有溢出位，然后添加到 0 位置上\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186212302","body":"# 数组的遍历\n根据题意，单词中任一字符与目标字符 target 距离的最小值必然为其与前 1 个 target 和后一个 target 中较小的存在  \n因此通过简化题意，可以前后各遍历一次求解  \n第一次从左至右，目标是找到距离左边 target 的最小距离\n第二次从右至左，目标是找到距离右边 target 的最小距离\n\n代码如下：\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] dist = new int[len];\n        Arrays.fill(dist, len+1);\n        for(int i=0, j=-1; i<len; ++i){\n            if(s.charAt(i)==c) j=i;\n            if(j!=-1) dist[i]= i-j;\n        }\n        for(int i=len-1, j=-1; i>=0; i--){\n            if(s.charAt(i)==c) j=i;\n            if(j!=-1) dist[i] = Math.min(dist[i], j-i);\n        }\n        return dist;\n    }\n}\n```\n时间复杂度：遍历两次数组，故为 O(N) \n空间复杂度：辅助空间使用数组长度为单词长度，故为 O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dlm001128":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185673085","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> tmp;\n        while(k){\n            tmp.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(num.begin(), num.end());\n        vector<int> res;\n        int t = 0;\n        int i = 0, j = 0;\n        for(; i < num.size() && j < tmp.size(); i++, j++){\n            res.push_back((num[i] + tmp[j] + t) % 10);\n            t = (num[i] + tmp[j] + t) / 10;\n        }\n        while(i < num.size()){\n            res.push_back((num[i] + t) % 10);\n            t = (num[i] + t) / 10;\n            i++;\n        }\n        while(j < tmp.size()){\n            res.push_back((tmp[j] + t) % 10);\n            t = (tmp[j] + t) / 10;\n            j++;\n        }\n        if(1 == t){\n            res.push_back(t);\n        }\n        int n = res.size() - 1;\n        while(0 == res[n--]){\n            res.pop_back();\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxy94":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185673838","body":"## 思路\r\n从低位到高位相加， 利用carry进位\r\n\r\n## 代码\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        carry = 0\r\n        for i in range(len(num) - 1, -1, -1):\r\n            num[i], carry = (carry + num[i] + k % 10) % 10, (carry + num[i] + k % 10) // 10\r\n            k //= 10\r\n        B = []\r\n        carry = carry + k\r\n        while carry:\r\n            B = [(carry) % 10] + B\r\n            carry //= 10\r\n        return B + num\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度： O(n)\r\n空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186224694","body":"## 思路\n贪心算法：先从左往右，再从右往左，最后计算最短距离。\n\n## 代码\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        res = [0 if s[i] == c else None for i in range(n)]\n\n        for i in range(1, n):\n            if res[i] != 0 and res[i - 1] is not None:\n                res[i] = res[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if res[i] is None or res[i + 1] + 1 < res[i]:\n                res[i] = res[i + 1] + 1\n        return res\n```\n\n## 复杂度分析\n时间：O(n)\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186358345","body":"## 思路\n第一反应是直观实现，看了题解发现可以用前缀和实现\n## 代码\n``` python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.max = maxSize\n        self.stack = []\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack) < self.max:\n            self.stack.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack.pop()\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        for i in range(min(len(self.stack),k)):\n            self.stack[i] += val\n```\n\n## 复杂度分析\n时间：O(1)\n空间：O(1)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185674070","body":"```typescript\nfunction addToArrayForm(num: number[], k: number): number[] {\n\n    let pow = 0;\n    let val = 0;\n    let result = []\n\n    for(let i = num.length-1; i >= 0; i++){\n        val += num[i] * Math.pow(10,pow);\n    }\n\n    val+=k;\n    \n    for(let i = 0; i < num.length -1; i++){\n        result.push(val / (Math.pow(10, num.length)));\n        num.shift();\n    }\n\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186212745","body":"```typescript\nfunction shortestToChar(s: string, c: string): number[] {\n\n  let cSet = new Set();\n  let result: number[] = [];\n\n  for (let index = 0; index < s.length; index++) {\n    const str = s[index];\n    if (str === c) {\n      cSet.add(index);\n    }\n  }\n\n  for (let index = 0; index < s.length; index++) {\n    let position = s.length;\n    cSet.forEach((ind) => {\n      if (Math.abs(Number(ind)-index) < position) {\n        position = Math.abs(Number(ind)-index);\n      }\n    })\n    result.push(position);\n  }\n\n  return result;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185675036","body":"```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        i = len(num) - 1\r\n        c = 0\r\n        while i >= 0 or k != 0:\r\n            a = num[i] if i >= 0 else 0\r\n            b = k % 10\r\n            sum = a + b + c\r\n            c   = sum // 10\r\n            res.append(sum % 10)\r\n            i = i - 1\r\n            k = k // 10\r\n        if c != 0:\r\n            res.append(c)\r\n        return res[::-1]\r\n```\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186219163","body":"```python\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        n = len(S)\r\n        res = [0 if c == C else n for c in S]\r\n        for i in range(1, n):\r\n           res[i] = min(res[i], res[i - 1] + 1)\r\n        for i in range(n - 2, -1, -1):\r\n            res[i] = min(res[i], res[i + 1] + 1)\r\n        return res\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyqqq22":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185675275","body":"### 思路\r\n逆序遍历数组进行相加，有两种情况：\r\n1. num数组长度大于k位数；遍历完num后k为0，相加结果一致\r\n2. num数组长度小于k位数；遍历完后k不为0，则继续将k剩余数字逐个加上\r\n\r\n注意进位，若需要进位则在k前进一位后加一\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        res=[]\r\n        for i in range(len(num)):\r\n            sum=num[-i-1]+k%10\r\n            k/=10\r\n            if sum>=10:\r\n                k+=1\r\n                sum-=10\r\n            res.append(sum)\r\n        while k:\r\n            res.append(k%10)\r\n            k/=10\r\n        return res[::-1]\r\n```\r\n### 复杂度分析\r\n时间复杂度: O(max(n,k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185758533","body":"### 思路\r\n两次遍历，分别寻找字符与左边c字符的最小距离和与右边c字符的最小距离，取两者最小值\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n=len(s)\r\n        res=[n]*n\r\n        cidex=-n\r\n        for i,ch in enumerate(s):\r\n            if ch==c:\r\n                cidex=i\r\n            res[i]=i-cidex\r\n        cidex=n\r\n        for i in range(-1,-len(s)-1,-1):\r\n            if s[i]==c:\r\n                cidex=i\r\n            res[i]=min(res[i],cidex-i)\r\n        return res\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)，n为字符串s的长度\r\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185677632","body":"# 【Day 1】989. 数组形式的整数加法\n\n## 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n\n## 复杂度\n**时间复杂度**：O(max(n,log k))，其中n为数组的长度\n\n**空间复杂度**：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225383","body":"# 【Day 2】821. 字符的最短距离\n\n## 代码\n\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.length();\n        vector<int> ans(n);\n\n        for (int i = 0, idx = -n; i < n; ++i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = min(ans[i], idx - i);\n        }\n        return ans;\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elon-lau":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185677997","body":"## 思路\n\n> + 思路描述\n\n##代码\n\n```python\n#代码\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        temp = \"\"\n        for i in num:\n            temp += str(i)\n        temp = int(temp) + k\n        print([i for i in str(temp)])\n        return [int(i) for i in str(temp)]\n```\n\n## 复杂度\n\n> + 时间复杂度: O(n)\n> + 空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186222102","body":"## 思路\n\n> + 思路描述\n\n##代码\n\n```python\n#代码\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        temp_list = []\n        for i in range(len(s)):\n            temp_int = 0\n            while True:\n                if i - temp_int >= 0:\n                    if s[i-temp_int] == c:\n                        break\n                if i + temp_int <= len(s) - 1:\n                    if s[i+temp_int] == c:\n                        break\n                temp_int += 1\n            temp_list.append(temp_int)\n        return temp_list\n```\n\n## 复杂度\n\n> + 时间复杂度: O(n^2)\n> + 空间复杂度: O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nowkizzz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185679498","body":"var addToArrayForm = function(num, k) {\n    const res = [];\n    const nLen = num.length;\n    for (let i = nLen  - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsgtgyb":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185681120","body":"### 思路\n考虑到数组长度过长，不能进行累加后转换，采取逐位累加的方式，数组末尾累加之k上，取余。本人采取的是arraylist，参考答案后改为linkedlist\n### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n       int j = k;\n        int i = num.length -1;\n        LinkedList list = new LinkedList();\n        while (i >= 0 || j > 0) {\n            if (i>=0) {\n                j = j + num[i];\n            }\n            list.addFirst(j%10);\n            j = j / 10;\n            i--;\n        }\n        return list;\n    }\n}\n```\n### 复杂度分析\n时间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"irenia111":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185681843","body":"var addToArrayForm = function(A, K) {\n        const res = [];\n        const n = A.length;\n        for (let i = n - 1; i >= 0; --i) {\n        let sum = A[i] + K % 10;\n        K = Math.floor(K / 10);\n        if (sum >= 10) {\n          K++;\n            sum -= 10;\n        }\n        res.push(sum);\n      }\n        for (; K > 0; K = Math.floor(K / 10)) {\n        res.push(K % 10);\n      }\n        res.reverse();\n        return res;\n      };","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186188832","body":"```\r\nvar shortestToChar = function(S, C) {\r\n    let res = [];\r\n    const sArr = S.split('');\r\n    for(let i=0;i<sArr.length;i++){\r\n        let leftArr;\r\n        let rightArr;\r\n        const curChar = sArr[i];\r\n        if(curChar === C){\r\n            res.push(0)\r\n        }else{\r\n            leftArr = sArr.slice(0, i).reverse();\r\n            rightArr = sArr.slice(i+1);\r\n            const leftDis = leftArr.indexOf(C) + 1;\r\n            const rightDis = rightArr.indexOf(C) + 1;\r\n            if(leftDis === 0){\r\n                res.push(rightDis)\r\n            }\r\n            if(rightDis === 0){\r\n                res.push(leftDis);\r\n            }\r\n            if(leftDis > 0 && rightDis > 0){\r\n                res.push(Math.min(leftDis, rightDis));\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suiyi8760":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185684032","body":"正向思维的暴力解法，reverse和k的分解方式还可以优化，没时间了先交卷\n```typescript\nfunction addToArrayForm(num: number[], k: number): number[] {\n    const numArrReverse = num.reverse()\n    const kArrReverse = String(k).split('').map(item=>Number(item)).reverse()\n    let needCarry:boolean = false\n    const mapObject = (numArrReverse.length>kArrReverse.length?numArrReverse:kArrReverse)\n    return mapObject.reduce<number[]>((pre,cur,index)=>{\n       const sum = (numArrReverse[index]??0)+(kArrReverse[index]??0)+(needCarry?1:0)\n       console.log(sum)\n       if(sum>=10) {\n           needCarry = true\n       } else{\n           needCarry = false\n       }\n        return [...pre,sum%10,...(mapObject.length-1===index&&needCarry?[1]:[])]\n    },[]).reverse()\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225083","body":"```typescript\nfunction shortestToChar(s: string, c: string): number[] {\n    const stringLength = s.length\n    const returnArr:number[] = new Array(stringLength).fill(0)\n    for(let i = 0,cPos = -stringLength;i<stringLength;i++){\n        if(s[i]===c){\n            cPos = i\n        }\n        returnArr[i] = i - cPos\n    }\n    console.log(returnArr)\n    for(let j = stringLength - 1,cPosRight = 2*stringLength;j>=0;j--){\n        if(s[j]===c){\n            cPosRight = j\n        }\n        returnArr[j] = Math.min(returnArr[j],cPosRight - j)\n    }\n    console.log(returnArr)\n    return returnArr\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saltychess":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185691220","body":"思路\n---\n1、从末尾逐位取数向前做加法  \n2、设置一个变量FLAG标识是否有进位，若有则设置FLAG=1，反之为0    \n3、注意k和num长度边界值的判断  \n\n代码\n---\n``` JAVA\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len=num.length-1;\n        int flag=0,tmp_k=0,tmp_num=0,sum=0;\n        List<Integer> res=new ArrayList<Integer>();\n        while(k>0||len>=0){\n            tmp_num = len>=0?num[len]:0;\n            tmp_k = k>0?k:0;\n            sum=flag+tmp_num+(tmp_k%10);\n            if(sum>=10){\n                flag=1;\n                sum=sum%10;\n            }else {\n                flag = 0;\n            }\n            k=k>0?k/10:0;\n            len--;\n            res.add(0,sum);\n        }\n        if(flag==1){\n            res.add(0,flag);\n        }\n        return res;\n    }\n}\n```\n复杂度\n---\n时间复杂度：O（n）  \n空间复杂度：O（n）","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186138233","body":"思路\n---  \n1、从左从右各循环一次，从左循环时找第i个字符左边最近的c，从右循环时找第i个字符右边最近的c  \n2、res记录最短距离并输出\n\n```Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        if (s.length()==1) return new int[]{0};\n        int[] res =new int[s.length()];\n        Arrays.fill(res,s.length()+1);\n        for(int i=0,index=-1;i<s.length();i++){\n            if(s.charAt(i)==c) index=i;\n            if(index!=-1) res[i]=i-index;\n        }\n        for(int i=s.length()-1,index=-1;i>=0;i--){\n            if(s.charAt(i)==c) index=i;\n            if(index!=-1) res[i]=Math.min(res[i],index-i);\n        }\n        return res;\n    }\n}\n```\n复杂度分析\n---\n时间复杂度：O（n）  \n空间复杂度：O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rabbit2010520":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185806802","body":"# Idea\n###### Traverse S from left to the right and find shortest distance from each element  in S to C.\n###### Traverse S from right to the left and find shortest distance  rom each element  in S to C.\n###### Then find the minimum value.\n\n# Code\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int [] arr = new int[len];\n        for(int i = 0, index = -len; i < len; i++){\n            if(s.charAt(i) == c){\n                index = i;\n            }\n            arr[i] = i - index;\n        }\n        \n        for(int i = len-1, index = 2 * len; i >= 0; i--){\n            if(s.charAt(i) == c){\n                index = i;\n            }\n            arr[i] = Math.min(arr[i], index - i);\n        }\n        return arr;\n    }\n}\n```\n# Complexity\n###### Time complexity: O(N)\n###### Space complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186024434","body":"## 用pointer记住前一个值和后一个值，求min\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pre,nex,k = -1,-1,0\n        ans = [None] * len(s)\n        \n        while k < len(s) and s[k] != c:  k+=1\n        nex = k\n        \n        for i in range(len(s)):\n            if pre == -1:\n                dis = nex -i\n            elif nex == -1:\n                dis = i - pre\n            else:\n                dis = min((nex -i),(i-pre))\n            ans[i] = dis\n            \n            if s[i] ==c:\n                pre = nex\n                k = i+1\n                while k < len(s) and s[k] !=c: k+=1\n                nex = k\n                if nex == len(s): nex = -1\n                \n        return ans\n```\n## 复杂度：\n时间：On\n空间：On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186385024","body":"'''\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n        self.inc = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if not self.stack: return -1\n        if len(self.stack) >=2:\n            self.inc[-2] += self.inc[-1]\n        \n        return self.stack.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k,len(self.stack))-1] += val\n        \n\n\n\n'''\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yopming":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186049958","body":"### 思路\n双向遍历。一个character离c最近距离只有两种情况，要么到左边的c，要么到右边的c。第一次遍历得出来每个character与其左边的c的距离（若出现在c之前，距离为s.size()）；第二次遍历得出来每个character与其右边的c的距离，取较小的那个。\n\n### 代码\n```lang-c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n      std::vector<int> distances(s.size());\n      if (s.size() <= 0) {\n        return distances;\n      }\n      \n      int len = s.size();\n      int curr = len;\n      \n      // left traversal\n      for (int i = 0; i < s.size(); i++) {\n        if (s[i] == c) {\n          curr = i;\n          distances[i] = 0;\n        } else {\n          distances[i] = std::min(len, std::abs(i - curr));\n        }\n      }\n      \n      // right traversal\n      for (int i = s.size() - 1; i >= 0; i--) {\n        if (s[i] == c) {\n          curr = i;\n        } else {\n          distances[i] = std::min(distances[i], std::abs(i - curr));\n        }\n      }\n      \n      return distances;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n) in which n is the size of string s.\n- 空间复杂度：O(1) if the return vector is not counted.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186258412","body":"### 思路\r\n使用vector来存储数据，使用单独一个变量来存储stack的size。\r\npush的时候，先检查当前vector的size是否小于stack size limit。然后把要插入的数放在vector的尾部。\r\npop的时候，先检查当前vector是否为空，返回-1如果为空。先暂存vector的back()，然后pop_back()，接着返回暂存的back()值，也就是stack后进先出（后进的数在vector尾部）。\r\nincrement的for循环要检查两个边界，一个是k，一个是vector的大小。\r\n\r\n### 代码\r\n```c++\r\nclass CustomStack {\r\nprivate:\r\n  std::vector<int> arr;\r\n  int stack_limit_;\r\n\r\npublic:\r\n    CustomStack(int maxSize) {\r\n      this->stack_limit_ = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n      if (arr.size() < this->stack_limit_) {\r\n        arr.push_back(x);\r\n      }\r\n    }\r\n    \r\n    int pop() {\r\n      if (arr.size() <= 0) {\r\n        return -1;\r\n      }\r\n      int back = arr.back();\r\n      arr.pop_back();\r\n      return back;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n      for (int i = 0; i < k; i++) {\r\n        if (i == arr.size()) {\r\n          break;\r\n        }\r\n        \r\n        arr[i] += val;\r\n      }\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：Constructor $O(1)$, push $O(1)$, pop() $O(1)$, increment $O(k)$ in which k stands for the number of elements need to increase.\r\n- 空间复杂度：One vector and one int used，therefore $O(n)$ in which $n$ stands for stack size.","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckytwj":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186080707","body":"##  思路\n### 扫描字符串字符 遇到等于c的 计算并设置c左边的距离 res[left],\n### 同时设置c右边的距离(在遇到下一个c之前的)res[right]\n### 取最短距离\n```Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        \n        int[] res = new int[s.length()];\n        Arrays.fill(res,Integer.MAX_VALUE);\n        int start = 0;\n        for(int i = 0;i<s.length();i++){\n            if(s.charAt(i)==c){\n                res[i]=0;\n                int left = i-1;\n                while(left>=start){\n                    res[left]=Math.min(Math.abs(i-left),res[left]);\n                    left--;\n                }\n                int right = i+1;\n                while(right<s.length()&&s.charAt(right)!=c){\n                    res[right]=Math.abs(right-i);\n                    right++;\n                }                \n                start=i+1;\n            }\n                \n        }\n        return res;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186388835","body":"#### 思路\n##### 数组实现\n```Java\nclass CustomStack {\n    int maxSize;  //定值\n    int size;\n    int[] arr;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        size = 0;        \n        arr = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (size > 0 && size >= maxSize) return;\n        arr[size++]=x;\n    }\n\n    public int pop() {\n        if (size > 0) {\n            int t = arr[size-1];\n            arr[size-1]=0;\n            size--;\n            return t;\n        }\n        return -1;\n    }\n\n    public void increment(int k, int val) {\n        for(int i = 0;i<size && i<k; i++){\n            arr[i]=arr[i]+val;\n        }\n    }\n}\n```\n复杂度 increment时间O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzz607":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186102380","body":"# 思路 \n暴力求解，先找出所有的c在s中的索引，然后依次计算s中每个字符与c的距离  \n\n# 代码\n```Go\nfunc shortestToChar(s string, c byte) []int {\n\tvar cIdx []int\n\tvar ret []int\n\n\tinitCIdx := func() {\n\t\tfor i := 0; i < len(s); i++ {\n\t\t\tif s[i] == c {\n\t\t\t\tcIdx = append(cIdx, i)\n\t\t\t}\n\t\t}\n\t}\n\n\tgetDistance := func(idx int) int {\n\t\tmin := math.MaxInt32\n\t\tfor _, ii := range cIdx {\n\t\t\ttmp := int(math.Abs(float64(ii - idx)))\n\t\t\tif tmp < min {\n\t\t\t\tmin = tmp\n\t\t\t}\n\t\t}\n\t\treturn min\n\t}\n\n\tinitCIdx()\n\tfor i := 0; i < len(s); i++ {\n\t\tret = append(ret, getDistance(i))\n\t}\n\n\treturn ret\n}\n``` \n\n# 复杂度\n- 时间复杂度：O(NK)，K为c在s中的个数，N为s的长度  \n- 空间复杂度：O(K)，K为c在s中的个数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoulufeng":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186121556","body":"# Day02\r\n---\r\n## \tSolution1\r\n---\r\n### 使用语言 Python\r\n---\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        index_list = []\r\n        for index, value in enumerate(s):\r\n            if value == c:\r\n                index_list.append(index)\r\n        # print(index_list)\r\n        distance_list = []\r\n        for index, value in enumerate(s):\r\n            temp_list = []\r\n            for i in index_list:\r\n                temp_list.append(abs(index - i))\r\n            # print(temp_list)\r\n            distance_list.append(min(temp_list))\r\n            # print(distance_list)\r\n        return distance_list\r\n```\r\n时间复杂度：O(n^2)\r\n空间复杂度：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186390157","body":"# Day03\r\n---\r\n## 使用语言： Python\r\n---\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.a_list = [] * self.maxSize\r\n        self.numPop = 0\r\n        self.len_a = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        self.len_a = len(self.a_list)\r\n        if self.len_a < self.maxSize:\r\n            self.a_list.append(x)\r\n\r\n    def pop(self) -> int:\r\n        self.len_a = len(self.a_list)\r\n        if len(self.a_list) == 0:\r\n            return -1\r\n        return self.a_list.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        self.len_a = len(self.a_list)\r\n        if k > self.len_a:\r\n            for i in range(self.len_a):\r\n                self.a_list[i] += val\r\n        else:\r\n            for i in range(k):\r\n                self.a_list[i] += val\r\n```\r\n---\r\n时间复杂度：$O(n)$\r\n空间复杂度：$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxoojs":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186160050","body":"## 代码\n---\n```\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n*/\nvar shortestToChar = function(s, c) {\n    let len = s.length,\n        answer = new Array(len),\n        i = 0,\n        pre = -Infinity;\n\n    while (i < len) {\n        if (s[i] === c) {\n            answer[i] = 0;\n            pre = i;\n        } else {\n            let nextIdx = s.indexOf(c, i);\n            if (~nextIdx) {\n                while (i <= nextIdx) {\n                    answer[i] = Math.min(i - pre, nextIdx - i);\n                    ++i;\n                }\n                --i;\n                pre = i;\n            } else {\n                answer[i] = i - pre;\n            }\n        }\n        ++i;\n    }\n\n    return answer;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okkband":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1186183254","body":"```CPP\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int n = num.size();\r\n        vector<int> res;\r\n        for(int i=n-1; i>=0; i--){\r\n            int sum = num[i]  + k % 10;\r\n            k = k / 10;\r\n            if (sum >= 10){\r\n                k++;\r\n            }\r\n            res.push_back(sum % 10);\r\n        }\r\n        for(;k>0; k/=10){\r\n            res.push_back(k%10);\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n#### 时间复杂度：O(n)\r\n#### 空间复杂度： O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186169287","body":"```CPP\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.size();\r\n        vector<int> ret;\r\n        int pre_idx = -10000;\r\n        for(int i=0; i<n; i++){\r\n            if (s[i] == c){\r\n                pre_idx = i;\r\n            }\r\n            ret.push_back(i - pre_idx);\r\n        }\r\n        pre_idx = 10001;\r\n        for (int i=n-1; i>=0; i--){\r\n            if (s[i] == c){\r\n                pre_idx = i;\r\n            }\r\n            ret[i] = min(pre_idx - i, ret[i]);\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n```\r\n### 时间复杂度：O(N);\r\n### 空间复杂度：O(1);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186270513","body":"```CPP\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stk;\r\n    vector<int> add;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        stk.resize(maxSize);\r\n        add = vector<int> (maxSize, 0);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top!=stk.size()-1){\r\n            top++;\r\n            stk[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1){\r\n            return -1;\r\n        } \r\n        int ret = stk[top] + add[top];\r\n        if (top != 0){\r\n            add[top-1] += add[top];\r\n        }\r\n        add[top] = 0;\r\n        top--;\r\n        return ret;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int num = min(k-1, top);\r\n        if (num >= 0){\r\n            add[num] += val;\r\n        }\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wyz999":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186177862","body":"### 思路\r\n先从左到右遍历，记录左侧到最近c的距离\r\n\r\n从右到左，1，记录从右侧到最近c的距离,2，比较两个距离，取最小值\r\n\r\n### 代码\r\n\r\n```golang\r\nfunc shortestToChar(s string, c byte) []int {\r\n    n:=len(s)\r\n    num :=make([]int, n)\r\n    idx:=-n\r\n    // 从左到右\r\n  for k,v:=range s{\r\n      if byte(v)==c{\r\n        idx=k\r\n      }\r\n    num[k]=k-idx\r\n  }\r\n    // 从右到左\r\n   idx=2*n\r\n  for i:=n-1;i>=0;i--{\r\n    if  s[i]== c{\r\n      idx=i\r\n    }\r\n    num[i]=min(num[i],idx-i)\r\n  }\r\n  return num\r\n}\r\n\r\nfunc min(a,b int) int{\r\n  if a>b {\r\n    return b\r\n  }\r\n  return a\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186396294","body":"### 思路\r\n用切片模拟栈操作\r\n\r\n### 代码\r\n```golang\r\n\r\ntype CustomStack struct {\r\n    maxSize int\r\n    stackLen int\r\n    val []int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    var num []int\r\n    customStack:=CustomStack{\r\n        maxSize: maxSize,\r\n        stackLen: 0,\r\n        val: num,\r\n    }\r\n    return  customStack\r\n    \r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if this.maxSize>this.stackLen{\r\n        // this.val[this.stackLen]=x\r\n      this.val= append(this.val,x)\r\n        this.stackLen++\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n    if this.stackLen==0{\r\n        return -1\r\n    }\r\n    last:=this.val[this.stackLen-1]\r\n    this.val=this.val[:this.stackLen-1]\r\n     this.stackLen--\r\n    return last\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    if k>=this.stackLen{\r\n        k=this.stackLen\r\n    }\r\n    for i:=0;i<k;i++{\r\n        this.val[i]+=val\r\n    }\r\n}\r\n\r\n```\r\n### 时空复杂度\r\n- 时间复杂度: push,pop 为O(1)\r\n- 空间复杂度：O(k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hacker90":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186181472","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.length();\n        vector<int> ans(n);\n\n        for (int i = 0, idx = -n; i < n; ++i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = min(ans[i], idx - i);\n        }\n        return ans;\n    }\n};\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ricjli":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186183393","body":"### Two times iteration:\n\niterate the string from left will calculate the distance to target `c` from the left. \n\niterate the string from right will calculate the distance to target `c` from the right. \n\nthen for each index, we have two lengths, then we can take the minimum value — this is the answer\n\n<aside>\n💡 **Default value for the distance:** \nwe need to set default value to -n, so that in this case, at the first left iteration, when we didn’t come across a target `character`. we can set the distance to `(i-n)` this is large enough for the second round iteration to overwrite it.\n\n</aside>\n\n<aside>\n💡 **Optimization:**\n in the second round iteration. we can start from the first round latest target index, \nsince there’s no target occurred after this index.\n\n</aside>\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length(); \n        int targetIndex = -n; \n        int [] res = new int [n];\n        for(int i = 0; i< n; i++){\n            if(s.charAt(i) == c){\n                targetIndex = i;\n            }\n            res[i] =  i - targetIndex;\n        }\n        for(int i = targetIndex; i >= 0 ; i--){\n            if(s.charAt(i) == c){\n                targetIndex = i;\n            }\n            res[i] = Math.min(res[i], Math.abs(i - targetIndex));\n        }\n        return res;\n    }\n}\n```\n\n### Complexity Analysis:\n\nTime : O(n)\n\nspace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luhaoling":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1186189241","body":"解题\r\n\r\n## Idea:\r\n\r\n引入BigInteger类，相加转化为list。\r\n\r\n## Code:\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> result=new ArrayList<>();\r\n        String s=\"\";\r\n       for(int i=0;i<num.length;i++){\r\n           s+=num[i];\r\n       }\r\n       java.math.BigInteger a=new java.math.BigInteger(s);\r\n       java.math.BigInteger b=new java.math.BigInteger(String.valueOf(k));\r\n       java.math.BigInteger c;\r\n        c=a.add(b);\r\n        String d=String.valueOf(c);\r\n        for (int i=0;i<d.length();i++){\r\n            result.add(Integer.valueOf(d.charAt(i))-48);\r\n        }\r\n        return result;\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186188719","body":"Idea\r\n\r\n```\r\n从左到右和从右到左进行两次遍历计算各元素到目标字符的距离。\r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len=s.length();\r\n        int[] result=new int[len];\r\n        for(int i=0;i<len;i++){\r\n            result[i]=Integer.MAX_VALUE;\r\n        }\r\n        for (int i=0;i<len;i++){\r\n            if(s.charAt(i)==c){\r\n                for (int j=0;j<len;j++){\r\n                    if (Math.abs(i-j)<result[j]){\r\n                        result[j]=Math.abs(i-j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (int i=len-1;i>0;i--){\r\n            if (s.charAt(i)==c){\r\n                for(int j=len-1;j>0;j--){\r\n                    if (Math.abs(i-j)<result[j]){\r\n                        result[j]=Math.abs(i-j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186206888","body":"```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\n// two pointers (i: read pointer; j: write pointer)\r\n// 1. when i points to c, handle all elements between i -> j\r\n//      i - j < j - lastJ ? i - j : j - lastJ\r\n//      if (j === i) lastJ = j;\r\n// 2. if c is not the last element of s, add the rest of elements for res (there is no fore j, only back j)\r\n//      while (res.length !== s.length) { res.push(res.length - lastJ); }\r\n\r\nvar shortestToChar = function(s, c) {\r\n    if (s.length === 1) return [0];\r\n    let res = [];\r\n    let j = 0;\r\n    let lastJ = null;\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            while (j <= i) {\r\n                res[j] = lastJ === null || (i - j < j - lastJ) ? i - j : j - lastJ;\r\n                if (j === i) lastJ = j;\r\n                j++;\r\n            }\r\n        }\r\n    }\r\n    while (res.length !== s.length) {\r\n        res.push(res.length - lastJ);\r\n    }\r\n    return res;\r\n};\r\n```\r\nT: O(N)   \r\nS: O(1)   ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gelxgx":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185772596","body":"### 思路\r\n在js里，直接先将数组合并为字符串，然后转化为数字进行相加\r\n避免精度丢失，查了一下可以使用BigInt方式解决\r\n相加完毕后，再转化为字符串，切分为数组\r\n\r\n### 代码\r\n``` javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let str = num.join('')\r\n    let count = BigInt(str) + BigInt(k)\r\n    let res = count.toString().split('')\r\n    return res\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186213182","body":"### 思路\n通过循环，遍历两次\n### 代码\n\n\n```javascript\nvar shortestToChar = function(s, c) {\n    const n=s.length;\n    const ans=new Array(n).fill(0);\n    for(let i=0,idx=-n;i<n;i++){\n        if(s[i]==c){\n            idx=i;\n        }\n        ans[i]=i-idx;\n    }\n    for(let i=n-1,idx=2*n;i>=0;--i){\n        if(s[i]==c){\n            idx=i;\n        }\n        ans[i]=Math.min(ans[i],idx-i);\n    }\n    return ans;\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186218926","body":"## 思路\n贪心法，最接近的值要么在左边，要么在右边\n## 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        int[] left = new int[s.length()];\n        int[] right = new int[s.length()];\n        left[0] = s.charAt(0) == c ? 0:Integer.MAX_VALUE-s.length();\n        for(int i = 1; i < s.length(); i++) {\n            if(s.charAt(i) == c)\n                left[i] = 0;\n            else\n                left[i] = left[i-1]+1;\n        }\n        right[s.length()-1] = s.charAt(s.length()-1) == c?0:Integer.MAX_VALUE-s.length();\n        for(int i = s.length()-2; i>=0;i--) {\n            if(s.charAt(i) == c)\n                right[i] = 0;\n            else\n                right[i] = right[i+1]+1;\n        }\n        for(int i = 0; i < left.length;i++)\n            ans[i] = Math.min(left[i],right[i]);\n        return ans;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186219318","body":"‘’‘\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int position = -n;\n        int[] res = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                position = i;   \n            }\n            res[i] = i - position;\n        }\n        for (int i = position - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                position = i;   \n            }\n            res[i] = Math.min(res[i], position - i);\n        }\n        return res;\n    }\n}\n’‘’","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lsunxh":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186219816","body":"# Time: O(N), space O(N)\n        res = [len(s) for i in s]\n        leftC = -1\n        for i in range(len(s)):\n            if s[i] == c:\n                leftC = i\n            if leftC != -1:\n                res[i] = i - leftC\n        rightC = -1\n        for i in range(len(s)-1, -1, -1):\n            if s[i] == c:\n                rightC = i\n            if rightC != -1:\n                res[i] = min(res[i], rightC - i)\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186387091","body":"Code:\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxSize = maxSize\n        self.stack = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack) < self.maxSize:\n            self.stack = self.stack + [x]\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.stack == []:\n            return -1\n        else:\n            return self.stack.pop(len(self.stack)-1)\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        changeRange = min(len(self.stack), k)\n        for i in range(changeRange):","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lanceli424":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186221215","body":"## 代码\n```\nfunction shortestToChar(s: string, c: string): number[] {\n    let result: number[] = [];\n    if (s.length === 0 || c.length === 0) {\n        return result;\n    }\n    let strArray = Array.from(s);\n    let indexs: number[] = [];\n    strArray.forEach((element, index) => {\n        if (element === c) {\n            indexs.push(index);\n        }\n    });\n    for (let i = 0; i <= indexs[0]; i++) {\n        result.push(indexs[0] - i);\n    }\n    for (let i = 0; i <= indexs.length - 2; i++) {\n        let start = indexs[i];\n        let end = indexs[i + 1];\n        for (let i = start + 1; i <= end; i++) {\n            let distance = Math.min(i - start, end - i);\n            result.push(distance);\n        }\n    }\n    for (let i = indexs[indexs.length - 1] + 1; i < strArray.length; i++) {\n        result.push(i - indexs[indexs.length - 1]);\n    }\n    return result;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qycoder":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225472","body":"### 思路\n求\ns[i]s[i] 到其左侧最近的字符 c 的距离\ns[i]s[i] 到其右侧最近的字符 c 的距离\n两者的最小值\n### 代码\n···\nconst shortestToChar = function(s, c) {\n    const n = s.length;\n    const ans = new Array(n).fill(0);\n\n    for (let i = 0, idx = -n; i < n; ++i) {\n        if (s[i] === c) {\n            idx = i;\n        }\n        ans[i] = i - idx;\n    }\n\n    for (let i = n - 1, idx = 2 * n; i >= 0; --i) {\n        if (s[i] == c) {\n            idx = i;\n        }\n        ans[i] = Math.min(ans[i], idx - i);\n    }\n    return ans;\n};\n···\n## 复杂度分析\n时间复杂度： O(n)\n空间复杂度：O(1)\n### \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qilin88":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186383345","body":"`/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.stack = [];\r\n    this.max = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if(this.stack.length < this.max){\r\n      this.stack.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n   return this.stack.pop() ?? -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    k = this.stack.length > k ? k : this.stack.length;\r\n    for(let i = 0; i < k; i++){\r\n        this.stack[i] += val\r\n    }\r\n};\r\n\r\n`\r\n# 复杂度\r\n## 时间复杂度：\r\n- push O(1)\r\n- pop O(1)\r\n- inc O(n)\r\n- 空间复杂度：O(n)\r\n- push O(1)\r\n- pop O(1)\r\n- inc O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengheng-yun":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186424382","body":"##### 想法\r\n1. 设计一个大小为`MaxSize`大小的栈，因为固定大小，想到了用数组表示\r\n2. 进栈，要比较当前栈是否栈满；因此，如何判断当前栈的元素个数\r\n3. 出栈，要比较当前栈是否栈空；\r\n4. 不论进栈还是出栈，都要比较当前栈顶元素的索引值，因此，可以设计一个标志位，当作实例变量。在每次进行比较时，用`++top`或者`top--`可以指向当前的栈顶。\r\n##### 代码\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1; \r\n\r\n    }    \r\n    public void push(int x) {\r\n        //判断当前栈空间的长度\r\n        if(top!=stack.length-1){\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }    \r\n    public int pop() {\r\n        if(top != -1){\r\n            int element = stack[top];\r\n            top--;\r\n            return element;\r\n        }else return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(top<k){\r\n            for(int i=0; i<=top; i++){\r\n                stack[i]+=val;\r\n            }\r\n        }else{\r\n            for(int i=0; i<k; i++){\r\n                stack[i]+=val;\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}