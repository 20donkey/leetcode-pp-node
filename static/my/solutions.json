{"577961141":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085986299","body":"## 题目思路\n解法一：假如，需要计算的数组为[1,2,3]和数字1095；首先向1095取余（以10），那么得到5再和数组3相加，得到8，将结果加入到新的数组；再将1095向下取整，再取余，得到9，在和数组的2相加，会发现得到的结果超过了10，那么就要将结果减10后加入新的数组，109还需要加一。重复以上步骤即可。\n\n解法二： 假如，需要计算的数组为[1,2,3]和数字1095；我们可以直接向1095加上数组的末尾的数，即1095+3然后取余，得到8，加入到新的数组中去，一直重复这个步骤即可。\n\n## 题目的题解code\n解法1：\n```PHP\nclass Solution {\n\n    /**\n     * @param Integer[] $num\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function addToArrayForm($num, $k) {\n        $res = [];\n        for ($i = count($num) -1; $i >=0; $i--) {\n            $remainder = $k % 10;\n            $addVal = $remainder + $num[$i];\n\n            if ($addVal >= 10) {\n                $addVal = $addVal % 10;\n                $k = floor($k /10) + 1;\n            }else {\n                $k = floor($k /10);\n            }\n            $res[] = $addVal;\n        }\n        while($k) {\n            $res[] = $k % 10;\n            $k = floor($k /10);\n        }\n        return array_reverse($res);\n    }\n}\n```\n\n解法2：\n```PHP\nclass Solution {\n\n    /**\n     * @param Integer[] $num\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function addToArrayForm($num, $k) {\n        $res = [];\n        for ($i = count($num) -1; $i >=0; $i--) {\n            $k = $num[$i] + $k;\n            $res[] = $k % 10;\n            $k = floor($k / 10);\n        }\n        while($k) {\n            $res[] = $k % 10;\n            $k = floor($k /10);\n        }\n        return array_reverse($res);\n    }\n}\n```\n\n## 时间和空间复杂度\n时间复杂度：O(max(n,logk)),其中n为数组的长度，k为数值的长度\n空间复杂度：O(1),除了返回值之外，其余全是常数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1973719588":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085541708","body":"思路：将int型的数字变为str字符串型的就很好处理了\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        i = ''\r\n        for x in num:\r\n            i = i + str(x)\r\n        numi = int(i)\r\n        xx = numi + k\r\n        ls = []\r\n        for s in str(xx):\r\n            ls.append(int(s))\r\n\r\n        return ls\r\n```\r\n\r\n空间复杂度：O(n)\r\n时间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zacherycao":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085303351","body":"## Idea\nScan the array from end to begin. Use an extra variable to record the carry number.\n\n## Code\n```python 3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = k\n        for i in range(len(num) - 1, -1, -1):\n            total = (num[i] + carry)\n            carry = total // 10\n            A = total % 10\n            num[i] = A\n        if carry:\n            return [int(i) for i in str(carry)] + num\n        return num\n                \n```\n\n## Complexity:\nTime: O(N). N = max(len(num), len(k))\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freedom0123":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085327382","body":"> 实现思路\n\n实际上就是一个模拟人工加法的过程\n\n> 复杂度分析\n1. 时间复杂度：O(n)\n2. 空间复杂度：O(n)\n\n> 代码实现\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        List<Integer> ans = new ArrayList<>();\n        num[n-1] += k;\n        int t  = 0;// 用 t 来表示进位 \n        for(int i = n - 1; i >=0 ; i--) {\n            // 比如说 now = 11， ans 的当前位就是 1，进位为 10\n            int now = num[i] + t; // 当前位 + 进位之后的结果\n            ans.add(now % 10);// ans 中当前位的结果是 now 的个位\n            t = now / 10; // 进位就是 除了个位 以上的为\n        }\n        if(t > 0){\n            while(t != 0) {\n                ans.add(t % 10);\n                t /= 10;\n            }\n        }\n        Collections.reverse(ans); \n        return ans;\n    }\n}\n\n```\n> [高精度加法](https://www.acwing.com/problem/content/description/793/)\n> Acwing\n\n```markdown\n给定两个正整数（不含前导 0），计算它们的和。\n\n # 输入格式\n \n共两行，每行包含一个整数。\n\n # 输出格式\n共一行，包含所求的和。\n\n# 数据范围\n1≤ 整数长度 ≤100000\n```\n\n```c\n#include<iostream>\n#include<cstring>\n#include<vector> \nusing namespace std;\nvector<int> add(vector<int> A,vector<int> B) {\n    if(A.size() < B.size()) return add(B,A);\n    vector<int> C;\n    int t = 0;// 表示进位\n    for(int i = 0 ;i < A.size(); i++) {\n        t += A[i];\n        if(i < B.size()) t+= B[i];\n        C.push_back(t % 10);\n        t /= 10;\n    }\n    if(t > 0) {\n        while(t !=0 ) C.push_back(t % 10), t/=10;\n    }\n    return C;\n    \n}\nint main() {\n    string a,b;\n    vector<int> A,B;\n    cin>>a>>b;\n    for(int i = a.size()-1; i >=0 ;--i) {\n        A.push_back(a[i] - '0');\n    }\n    for(int i = b.size() - 1; i >= 0; --i) {\n        B.push_back(b[i] - '0');\n    }\n    auto C = add(A,B);\n    for(int i = C.size() - 1; i >= 0; i--){\n        cout<<C[i];\n    }\n    return 0;\n    \n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086474703","body":"[原题链接](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n> 算法一\n1. 时间复杂度为：O(n ^ 2)\n2. 思路：暴力枚举，对于每个位置都向左右两个方向进行搜索，判断每个位置上的字符是否是c，如果是，进行相应的计算即可\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        for(int i = 0; i < n; i++){\n            int left = i;\n            int right = i+1;\n            int res  = Integer.MAX_VALUE;\n            while(left >= 0) {\n                if(s.charAt(left) == c) res = Math.min(res, Math.abs(i - left));\n                left --;\n            }\n            while(right < n) {\n                if(s.charAt(right) == c) res = Math.min(res, Math.abs(i - right));\n                right ++;\n            }\n            ans[i] = res;\n        }\n        return ans;\n    }\n}\n```\n> 算法二\n \n\n  - 时间复杂度：O(n)\n-  思路： 在算法一中，对于每个位置我们都要向左 和向右搜索距离这个位置最近的c，这种算法的时间复杂度很高，并且在做很多无用功。对于每个位置，我们如果说知道了他的前一位，距离最近的c    的位置，我们就不需要每个位置都进行枚举\n-  通过这种思想，我们只需要向左扫一遍，记住每个位置上，左边距离它最近的c的距离；在向右扫一遍，记住每个位置上，右边距离它最近的c的位置，就行。\n- 这里pre 除以2 的目的是为了，防止越界 \n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        int pre = Integer.MIN_VALUE / 2;\n        for(int i = 0; i < n; i++) {\n            if(s.charAt(i) == c) {\n                pre = i;\n            }\n            ans[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE / 2;\n        for(int i = n -1; i >= 0; i--) {\n            if(s.charAt(i) == c) {\n                pre = i;\n            }\n            ans[i] = Math.min(ans[i],pre- i);\n        }\n        return ans;\n\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tonylee017":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085338085","body":"#### 思路\n\n直接把k加到num[i]上，保留个位数在num[i]，k取为其他位数。\n\n#### 代码实现\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t\ti = len(num)-1\n        while k:\n            num[i] += k\n            k, num[i] = num[i]//10, num[i]%10\n            i -= 1\n            if i<0 and k:\n                num.insert(0,0)\n                i = 0 \n        return num\n```\n#### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youxucoding":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085341434","body":"### 思路\r\n\r\n模拟加法，类似链表两数相加那题，所以我使用的LinkedList。\r\n\r\n\r\n### 代码实现\r\n```java \r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int vaild = 0;\r\n        int i = num.length-1;\r\n        while(i >= 0 || k > 0){\r\n            int cur = 0;\r\n            if(i < 0){\r\n                cur = (k % 10) + vaild;\r\n            }else if(k == 0){\r\n                cur = num[i] + vaild;\r\n            }else{\r\n                cur = num[i] + (k % 10) +vaild;\r\n            }\r\n            vaild = cur/10;\r\n            cur = cur % 10;\r\n            k = k / 10;\r\n            i--;\r\n            res.addFirst(cur);\r\n        }\r\n        if(vaild > 0){\r\n            res.addFirst(vaild);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度O(n)\r\n- 空间复杂度O(n)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forestie9":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085353261","body":"### Idea\nConvert int item in list to get the first value, and add up with k. Then convert the final value to item in a list.\n\n### Code\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s = ''.join([str(i) for i in num])\n        summ = str(int(s) + k)\n        return [int(i) for i in summ]\n```\n### Complexity\nTime O(n) <br>\nSpace O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"houmk1212":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085369488","body":"# 思路\n用数组模拟加法运算，注意进位和数组的长度。\n\n# 代码\npublic class ClockIn20220401 {\n    public static void main(String[] args) {\n  \n    }\n\n    public static void swap(int[] nums, int i, int j) {\n        if (i != j) {\n            nums[i] = nums[i] ^ nums[j];\n            nums[j] = nums[i] ^ nums[j];\n            nums[i] = nums[i] ^ nums[j];\n        }\n    }\n    public static int[] solution(int[] nums, int k) {\n        int upper = 0;\n        int exp = 1;\n        int n = nums.length;\n        int kLeng = 0;\n        // 先找最大的范围\n        for (int e = 1; k / e > 0; e *= 10) {\n            kLeng ++;\n        }\n        int maxLeng = Math.max(n , kLeng);\n        int[] result = new int[maxLeng + 1];\n        int i = 0;\n        int j = n-1;\n        while (i < n / 2) {\n            swap(nums, i , j);\n            i ++;\n            j --;\n        }\n        i = 0;\n        while (i < maxLeng || upper == 1) {\n            int left = i < n ? nums[i] : 0;\n            int right = k / exp > 0 ? (k / exp) % 10 : 0;\n            result[i] = (left + right + upper) % 10;\n            upper = left + right + upper >= 10 ? 1 : 0;\n            exp *= 10;\n            i ++;\n        }\n        int[] ans = new int[i];\n        int p = 0;\n        for (int q = i - 1; q >= 0; q--) {\n            ans[p ++] = result[q];\n        }\n        return ans;\n    }\n}\n\n# 复杂度\n时间复杂度: O(n + e)   n是数组的长度， e是k的位数;\n\n空间复杂度：O(max(n,e))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086508946","body":"# 思路\r\n因为是找左右侧距离目标字符的最短距离，想到类似单调栈的找右侧最小或者最大值的做法。左侧的目标字符的下表可以用一个变量存，右侧的目标距离可以用单调栈来得到。当目标元素入栈时，弹出所有栈中非目标字符，并得到他们的结果。\r\n# 代码\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        int[] ans = new int[s.length()];\r\n        int pre = - 1;\r\n        for (int i = 0 ; i < s.length(); i ++) {\r\n            if (s.charAt(i) == c) {\r\n                while (!stack.isEmpty() && s.charAt(stack.peek()) != c) {\r\n                    int p = stack.pop();\r\n                    ans[p] = pre >= 0 ? Math.min(Math.abs(p - i) , Math.abs(p - pre)) : Math.abs(p - i);\r\n                }\r\n                pre = i;\r\n            }\r\n            stack.push(i);\r\n        }\r\n        while (!stack.isEmpty()) {\r\n            int p = stack.pop();\r\n            ans[p] = s.charAt(p) == c ? 0 : Math.abs(p - pre);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n# 复杂度\r\n时间复杂度： 每个字符串s中的字符都要入栈一次，出栈一次，所以时间复杂度是O（N）， N是字符串的长度。\r\n空间复杂度：栈的大小，是O（N）。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kelving-611":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085375480","body":"### 思路\n\n思路1: 把A转化成数字. 再跟K求和. 最后把输出结果转化成数组. (这种方法感觉没什么意思, 就是来回调用几个函数)\n思路2: 双指针. 从A, K的\"尾巴\"开始, 从后往前移动, 然后每次把得到的和放进数组里(不要忘记carry). 返回数组颠倒过来之后的结果. 注意: 时刻要注意carry. 如果双指针最后走到头, 还需要考虑carry的情况. \n\n### 代码\n\n思路2\n```python\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        carry = 0\n        i, j = len(A) - 1, len(str(K)) - 1\n        res = []\n\n        while i >= 0 or j >= 0: \n            val_1 = A[i] if i >= 0 else 0\n            val_2 = int(str(K)[j]) if j >= 0 else 0\n            i -= 1\n            j -= 1\n            val = val_1 + val_2 + carry\n            carry = val // 10\n            val %= 10\n            res.append(val)\n\n        if carry: \n            res.append(carry)\n        return res[::-1]\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(max(len(A), len(str(K)))) 也就是 O(A, str(K)之间较长的长度)\n- 空间复杂度：O(max(len(A), len(str(K)))) . 由于算法不是原地算法, 所以需要重新开辟空间. \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lqyt2012":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085378454","body":"## 思路\n将数组转换成整数，然后与整数K做加法，之后再转换成数组返回\n## 代码\n```python\nclass Solution:\n    def add_array_with_num(self, num: List[int], k: int) -> List[int]:\n        sum = 0\n        digit = 1\n        for i in range(len(num)-1, -1, -1):\n            sum += num[i]*digit\n            digit *= 10\n        sum += k\n        result = [0]*len(str(sum))\n        for i in range(len(result)-1, -1, -1):\n            result[i] = sum % 10\n            sum //= 10\n        return result\n```\n## 复杂度分析\n空间复杂度：O(N)  \n时间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yz3516":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085380660","body":"### **思路**\r\n把k当做carry，从后往前遍历，每次加k的个位数值进res的头部并更新k；\r\n\r\n### **代码**\r\n```java\r\n    public List<Integer> addToArrayForm(int[] nums, int k) {\r\n        List res = new LinkedList<>();\r\n        for (int i = nums.length - 1; i >= 0 || k > 0; --i) { //这里可以用三元运算符简化；\r\n\t        if(i >= 0){\r\n\t\t\tres.add(0, (nums[i] + k) % 10);\r\n\t\t\tk = (nums[i] + k) / 10;\r\n\t\t} else {\r\n\t\t\tres.add(0, k % 10);\r\n\t\t\tk /= 10;\r\n\t\t}   \r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n### **复杂度**\r\nTime: O(n), n is the length of nums;\r\nSpace: O(n), the res List uses extra space ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086526568","body":"### 思路\n先从左边往右扫，记录每个字符离C的距离；\n然后从右边往左扫，如果比第一次扫的距离小则替换掉，这样最后剩下的就是每个字符距离C最短的距离；\n\n### 代码\n```java\n        int[] result = new int[S.length()];\n        int currDist = S.length(); \n        for (int i = 0; i < S.length(); ++i) {\n            currDist = S.charAt(i) == C ? 0 : currDist + 1;\n            result[i] = currDist;\n        }\n\n        currDist = S.length();\n        for (int i = S.length() - 1; i >= 0; --i) {\n            currDist = S.charAt(i) == C ? 0 : currDist + 1;\n            result[i] = Math.min(result[i], currDist);\n        }\n        return result;\n    }\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)， N 为数组长度;\n- 空间复杂度：O(N)，创建了新的array result;","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yongxi-zhou":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085383015","body":"## 思路 \n把num转换成整数后加上k，再转换成数组\n\n## 代码\n    class Solution(object):\n        def addToArrayForm(self, num, k):\n            \"\"\"\n            :type num: List[int]\n            :type k: int\n            :rtype: List[int]\n            \"\"\"\n            temp = 0\n            for item in num:\n                temp = temp * 10 + item\n            res = []\n            sumNum = temp + k\n            while sumNum != 0:\n                last = sumNum % 10\n                sumNum //= 10\n                res.insert(0, last)\n            return res\n## 复杂度\ntime O(max(num和k的长度))\nspace O(max(num和k的长度))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085387672","body":"### 思路\n将k加到最后一位，取余放在当前位，接着/10继续向前加\n### 代码\n``` c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n       //将K加到最后一位，依次向前\n       vector<int> res;\n       for(int i=num.size()-1;i>=0 || k>0;i--,k/=10){\n           //if(i>=0){\n           //    int sum=num[i]+k;\n           //    res.push_back(sum%10);\n           //}\n           //else{\n           //    res.push_back(k%10);\n          // }\n          //上面这一段还是没想清楚\n          if(i>=0){\n              k+=num[i];\n          }\n          res.push_back(k%10);\n       }\n       reverse(res.begin(),res.end());\n       return res;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：O（n）遍历一遍数组\n* 空间复杂度：O（n），建立了数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086537714","body":"### 思路\n两次遍历，从左到右更新一遍，从右到左更新一遍\n### 代码\n``` C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int>res(s.size());\n        //方法二，只遍历两次，先从左到右，再从右到左\n        int prev=INT_MAX/2;//防止越界，所以除以2\n        for(int i=0;i<s.size();i++){\n            if(s[i]==c){\n                prev=i;\n            }\n            res[i]=i-prev;\n        }\n        prev=INT_MAX/2;\n        for(int i=s.size()-1;i>=0;i--){\n            if(s[i]==c){\n                prev=i;\n            }\n            res[i]=min(abs(res[i]),prev-i);\n        }\n    return res;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：O（n）\n* 空间复杂度：O（n）\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kite-fly6618":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085387840","body":"### 思路： \n模拟加法，从后往前逐位相加\n\n### 代码：\n```js\nvar addToArrayForm = function(num, k) {\n    let res = []\n    let len = num.length\n    for (let i = len-1;i>=0;i--) {\n        let sum = num[i] + k%10\n        k = Math.floor(k/10)\n        if (sum >=10) {\n            k++\n            sum = sum-10\n        }\n        res.unshift(sum)\n    }\n    // k > 0 往数组上继续添加高位\n    while(k>0) {\n        res.unshift(k%10)\n        k = Math.floor(k/10)\n    }\n    return res\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085396374","body":"### 思路\r\n\r\n从最后一位开始模拟加法进位计算， 注意不可以直接转化成数字相加会溢出 - Integer\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> result = new ArrayList<>();\r\n        int len = num.length - 1;\r\n        //先将最后一位加入list，此时list为倒序\r\n        int sum = num[len] + k;\r\n        result.add(sum % 10);\r\n        int carry = sum / 10;\r\n        \r\n        //从倒数第二位开始循环\r\n        for(int i = len - 1; i >= 0; i --) {\r\n            sum = num[i] + carry;\r\n            result.add(sum % 10);\r\n            carry = sum / 10;\r\n        }\r\n        \r\n        //如果carry还有进位\r\n        while(carry > 0) {\r\n            result.add(carry % 10);\r\n            carry /= 10;\r\n        }\r\n        \r\n        //反转数组\r\n        Collections.reverse(result);\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(max(N, log k))，其中 N 为数组num长度。\r\n- 空间复杂度：O(max(N, log k)), 储存结果的新数组\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"venchyluo":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085407589","body":"从尾到头 一位一位计算。 可以另开list 倒叙存 ｜｜ 直接修改原数组，多位的从头插入。\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        # brute force, convert to int then to list\r\n        carry, i = 0, len(num) -1\r\n        while carry or i >= 0 or k:\r\n            temp = (num[i] if i >= 0 else 0) + (k % 10 if k else 0) +  carry            \r\n            carry = temp // 10\r\n            \r\n            if i >= 0:\r\n                num[i] = temp % 10\r\n            else:\r\n                num.insert(0,temp % 10)\r\n            \r\n            k //= 10\r\n            i -= 1\r\n\r\n        return num\r\n```\r\ntime complexity: O(N)   \r\nspace complexity: O(N) （不考虑返回值，额外使用O(1))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ballerjay":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085407797","body":"### 解题思路\n\n默认人工计算的过程，k与数组最后一位相加，然后k去掉个位的数字；然后k与倒数第二位相加，也就是十位，然后去掉十位的数组；依次循环。。。\n\n还有一些特殊的情况就是数组循环结束之后，k还存在值，所以需要继续往res中添加\n\n\n\n```JavaScript\nfunction solution(num,k) {\n  // 默认人工计算的过程，k与数组最后一位相加，然后k去掉个位的数字；然后k与倒数第二位相加，也就是十位，然后去掉十位的数组；依次循环。。。\n  // 还有一些特殊的情况就是数组循环结束之后，k还存在值，所以需要继续往res中添加\n  const res = []\n  const len = num.length\n  for(let i = len - 1;i >= 0 || k > 0;i --, k = Math.floor(k / 10)) {\n    if(i >= 0) {\n      k += num[i]\n    }\n    res.unshift(k % 10)\n  }\n  return res\n}\n```\n\n### 时间复杂度\n\nO(max(n,k)),n为数组的长度,k为数字的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"magua-hub":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085412418","body":"思路\n模拟加法，本质上是以到高精度加法。先把数组翻转，从最后一位开始加，最后在翻转过来\n\n代码实现\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n\n        for(auto& x : num) {\n            k += x;\n            x = k % 10;\n            k /= 10;\n        }\n\n        while(k) num.push_back(k % 10), k /= 10;\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\n```\n复杂度分析:\n\n时间复杂度O(n)\n\n空间复杂度O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085420206","body":"```c\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* addToArrayForm(int* num, int numSize, int k, int* returnSize){\n    int resLen = fmax(numSize + 1, 5); // k 的取值范围 [1, 10^4]，加上进位最多是 5 位数\n    int* res = malloc(sizeof(int) * resLen);\n    int r, w;\n\n    w = resLen - 1;\n    r = numSize - 1;\n\n    while (k || r >= 0) {\n        if (r >= 0) k += num[r--];\n        res[w--] = k % 10;\n        k /= 10;\n    }\n\n    int realStart = w + 1;\n    *returnSize = resLen - realStart;\n    return res + realStart;\n}\n```\n- ****Time:**** $O(max(N,logk))$\n- ***Space:** $O(1)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086484326","body":"```c\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* shortestToChar(char * s, char c, int* returnSize) {\n    int len = strlen(s);\n    int* res = malloc(sizeof(int) * len);\n\n    res[0] = s[0] == c ? 0 : len;\n\n    for (int i = 1; i < len; ++i)\n        res[i] = s[i] == c ? 0 : res[i - 1] + 1;\n\n    for (int i = len - 2; i >= 0; --i)\n        res[i] = fmin(res[i], res[i + 1] + 1);\n\n    *returnSize = len;\n    return res;\n}\n```\n\n- ****Time:**** $O(N)$，N 是 S 的长度。\n- ****Space:**** $O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dzwhh":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085428758","body":"### 思路\n逐位相加,当数组不为空或者k不为0，从末位数字开始，加k当前位(k%10)+进位(carry初始是0),加和后push到开辟的数组去同时只push当前位，循环结束最后判断一次是否还有进位，如果有再push一次，最后反转数组得到最终结果\n\n### 关键点\n- 处理当前位是 num % 10\n- 处理进位是 num / 10\n- 需要判断数组是空，或者k是0的情况\n\n### 代码\n- js版本\n```js\nconst addToArrayForm = (num, k) => {\n  let res = []; // 最终输出结果数组\n  let carry = 0; // 标记进位\n  let tail = num.length - 1; // 数组末位元素，代表各个位的数字\n  let sum = 0; // 各个位加和的结果\n\n  while(tail >= 0 || k != 0) {\n    let x = tail >= 0 ? num[tail] : 0;\n    let y = k != 0 ? k % 10 : 0;\n    sum = x + y + carry; //num数组当前位+k当前位+进位\n    res.push(sum % 10); //sum 可能有进位 取模 10 剔除掉进位数字\n    tail--; //数组向前挪动\n    k = Math.floor(k/10);  // k向高位数字挪动\n    carry = Math.floor(sum / 10); //记录进位数字\n  }\n  if(carry === 1)\n    res.push(carry); //最后一次加和如果有进位最后的1push到数组\n  return res.reverse(); // 从后往前添加的数组，需要反转得到最终结果\n}\n\n```\n### 复杂度分析\n时间复杂度: O(max(n,k))\n空间复杂度: O(max(n,k))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lyuliangliu":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085434802","body":"\n### 思路\nAdding from rear to front until both num and k are exhausted.\n### Code\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int carry = 0;\n        List<Integer> result = new LinkedList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0) {\n            int digitFromK = k % 10;\n            int currentDigit = digitFromK + (i >= 0 ? num[i] : 0) + carry;\n            if (currentDigit >= 10) {\n                carry = 1;\n                currentDigit -= 10;\n            } else {\n                carry = 0;\n            }\n            result.add(0, currentDigit);\n            k /= 10;\n            i--;\n        }\n        if (carry == 1) {\n            result.add(0, 1);\n        }\n        return result;\n    }\n}\n```\n### 复杂度\n* Time: O(N) \n* Space: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086543333","body":"### Idea\n* Go forward: record the distance between each letter and the latest c in its left;\n* Go backward: update the distance if a letter is closer to the latest c in its right\n### Code\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        int lastIndexC = Integer.MAX_VALUE;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                ans[i] = 0;\n                lastIndexC = i;\n            } else if (lastIndexC == Integer.MAX_VALUE) {\n                ans[i] = Integer.MAX_VALUE;\n            } else {\n                ans[i] = i - lastIndexC;\n            }\n        }\n        lastIndexC = Integer.MAX_VALUE;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                lastIndexC = i;\n            } else if (lastIndexC - i < ans[i]) {\n                ans[i] = lastIndexC - i;\n            }\n        }\n        return ans;\n    }\n}\n```\n### Complexity\n* Time: 2N\n* Space: N","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawyuan97":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085443568","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\r\n\r\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\r\n\r\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：num = [1,2,0,0], k = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：num = [2,7,4], k = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：num = [2,1,5], k = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= num.length <= 104\r\n0 <= num[i] <= 9\r\nnum 不包含任何前导零，除了零本身\r\n1 <= k <= 104\r\n```\r\n\r\n## 前置知识\r\n\r\n数组 取模 取余 列表相加\r\n\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  见代码\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = 0\r\n        # 从低位到高位进行加法\r\n        # 判断是否需要进位\r\n        # 如果num比k大 就可以结束了\r\n        for i in range(len(num)-1,-1,-1):\r\n            num[i],carry  = (num[i] + k%10 + carry)%10,(num[i] + k%10 + carry)//10\r\n            k //= 10\r\n        # 如果num比k小 考虑继续进位\r\n        high = []\r\n        k = k + carry\r\n        if k:\r\n            high = [int(i) for i in str(k)]\r\n        return high + num\r\n        \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086516918","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n窗口的左右边界\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n将字符c作为窗口的边界 每次记录窗口的左右边界 然后开始计算距离\r\n\r\n## 关键点\r\n\r\n-  如何确定第一个窗口？\\\r\n  由于第一个窗口可能不存在左边界，因此先从索引位置0开始判断左边界是否存在，如果不存在可以将左边界置为n，那么第一个窗口可以不考虑左边界\r\n- 如何更换窗口？\\\r\n  随着对字符串的遍历，一定会遍历到窗口右边界，那么新窗口的左边界就是当前索引i\r\n- 如何使用字符串查找函数？ \\\r\n  s.find(c,beg=i,end=n)，该函数会从字符串s中查找字符c，然后beg表示开始的索引，end表示结束的索引（左闭右开）；如果找不到返回-1\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        \"\"\"寻找距离最近的字符的长度 \r\n\r\n        Args:\r\n            s(str):字符串\r\n            c(str):字符\r\n        \r\n        Returns:\r\n            ans(List[int]):返回结果列表\r\n\r\n        \"\"\"\r\n        n = len(s)\r\n        ans = [0] * n\r\n        \r\n        # 寻找左边界 如果没有左边界 那么直接将左边界设置为字符串长度\r\n        l = 0 if s[0] == c else n\r\n        # 从索引位置1开始搜索字符c\r\n        r = s.find(c,1) \r\n\r\n        for i in range(n):\r\n            # 取距离两个边界的最小距离\r\n            ans[i] = min(abs(i-l),abs(r-i))\r\n            # 考虑移动边界的问题\r\n            if i == r:\r\n                l = i\r\n                r = s.find(c,i+1)\r\n        return ans\r\n        \r\n\r\n\r\n        \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085447103","body":"## 思路\n    将数组的最后一位加到k上，然后k对10取余，得到的结果放到linkedList的第一位。数组长度不足时则只操作k。直到k小于0并且数组遍历结束。\n## 复杂度分析\n    时间复杂度O(n) 空间复杂度O(n)\n## 代码\n```\npublic List<Integer> addToArrayForm2(int[] num, int k) {\n    LinkedList<Integer> ans = new LinkedList<>();\n    int i = num.length - 1;\n    while (k >= 1 || i >= 0) {\n        if (i >= 0) {\n            k += num[i];\n        }\n        i--;\n        ans.addFirst(k % 10);\n        k /= 10;\n    }\n    return ans;\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085449145","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\n\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\n\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\n\n \n\n示例 1：\n\n输入：num = [1,2,0,0], k = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：num = [2,7,4], k = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：num = [2,1,5], k = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n \n\n提示：\n\n1 <= num.length <= 104\n0 <= num[i] <= 9\nnum 不包含任何前导零，除了零本身\n1 <= k <= 104\n```\n\n## 前置知识\n\n- 数组遍历、逐位相加的方法\n\n\n## 思路\n1、数组输出，需要通过for循环将数组输出\n2、将数组和整数依次相加，整数获取位数上的数可通过依次进行求余运算\n\n## 关键点\n\n-  熟悉整数获取位数上的方法\n- 熟悉数组的API，push（）、reverse（）\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let res = [];\n    let n = num.length;\n    for(let i = n -1; i >= 0; i--)\n    {\n        let sum = num[i] + k%10;\n        k = Math.floor(k/10);\n        if(sum>=10)\n        {\n            k++;\n            sum = sum -10;\n        }\n        res.push(sum);\n    }\n    for(;k>0;k = Math.floor(k/10))\n    {\n        res.push(k%10);\n    }\n    res.reverse();\n    return res;\n\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$，\n- 空间复杂度：$O(1)$，没有额外增加空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085454092","body":"### 思路\n\n- 将整型列表拼接为字符串后，再转为int型与k相加\n- 将相加后的结果转为字符串后遍历，生成整型列表\n\n### 代码\n\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num = int(\"\".join(list(map(str, num))))\n        return [int(i) for i in str(num + k)]\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maggiexie00":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085454513","body":"### 思路\r\n\r\n从尾部开始，原地更新num中的数值，k处理完则break\r\n\r\n***把k当作carry\r\n***题目已知num长度最多10^4，k最多5位数，若开辟新数组，则极大增加时间复杂度（遍历num），因而选择原地更新num数组，最坏情况是进行6次操作。\r\n*** key point 是k处理完就停止，无需遍历num。\r\n\r\n### 代码\r\n\r\n\r\n    def addToArrayForm(self, num, k) :\r\n\r\n        p=len(num)-1\r\n        while p>-1 and k!=0:\r\n            tmp=num[p]+k%10\r\n            num[p]=tmp%10\r\n            k=k//10+tmp//10\r\n            p-=1    \r\n\r\n        while k:\r\n            num=[k%10]+num\r\n            k//=10\r\n\r\n        return num\r\n\r\n### 复杂度\r\n空间复杂度 O(1)\r\n时间复杂度 O(N）其中N为k的位数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bigboom666":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085464204","body":"## 思路\n低位往高位加。\n进位放到k里处理。\n## code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> resultSta = new ArrayList<>();\n        \n        //进位放到k里处理\n        for(int i=num.length-1; i>=0;i--){\n\n            int sum =  num[i] +k%10;\n            k = k/10;\n\n            if(sum >= 10){\n                k++;\n                sum -= 10;\n            }\n\n\n            resultSta.add(sum);\n        }\n\n        while(k!=0){\n            resultSta.add(k%10);\n            k = k/10;\n        }\n\n        Collections.reverse(resultSta);\n        return resultSta;\n    }\n}\n```\n\n## 复杂度\n时间：o(n+k)\n控件：o(n+k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carrieyqzhang":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085470672","body":"### 思路\r\n从个位数求两数之和，carry= 1 如果sum大于10.\r\nsum % 10 得到的结果就是当位数的值\r\nwhile 结束loop如果num[]里没有元素，而且k 等于0\r\n\r\n### 代码\r\n\r\n```java\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int carry = 0;\r\n        int l1 = num.length -1;\r\n        while (l1 >= 0 || k != 0){\r\n            int a = l1 < 0 ? 0 : num[l1]; //get last element in num[]\r\n            int b = k <= 0 ? 0 : k % 10; //get last digit in k            \r\n            int sum = a + b + carry;\r\n            res.add(0, sum % 10);\r\n            carry = sum / 10;\r\n            \r\n            l1--;\r\n            k /= 10;\r\n        }\r\n        if (carry != 0) res.add(0,carry);\r\n    \r\n        return res;     \r\n    }\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"l-sui":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085485310","body":"/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let len = num.length-1;\n    while(len>=0&&k>0){\n        const sum = k+num[len]\n        num[len] = sum%10\n        k=~~(sum/10)\n        len--\n    }\n    if(k>0) return [...k.toString().split(''),...num]\n    return num\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xil324":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085491089","body":"思路: 先把数组转换为正数,然后再把两个数相加，最后再把得到的整数转换为数组。 时间复杂度o(n), 空间复杂度O(n) , n取决于num 和结果数组的最大值。 \r\n```\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        number = self.convert_array_to_integer(num);\r\n        print(number)\r\n        sum_two_numbers = number + k\r\n        res = [];\r\n        while sum_two_numbers >= 10:\r\n            res.append(sum_two_numbers % 10);\r\n            sum_two_numbers = sum_two_numbers // 10; \r\n        res.append(sum_two_numbers)\r\n        return res[::-1]; \r\n        \r\n            \r\n    \r\n    def convert_array_to_integer (self, arr):\r\n        result = 0;\r\n        for i in range(len(arr)):\r\n            if arr[i] == '0': \r\n                result - result * 10;\r\n            else:\r\n                result = result * 10 + arr[i]; \r\n            \r\n        return result; \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086540900","body":"```\r\nclass Solution(object):\r\n    #数组的遍历(正向遍历和反向遍历)\r\n    #思路： 遍历两次，每次遍历，更新target到i的距离， 取两次遍历的最小值，也就是查看，左右target哪一个离i更近，更新result（返回数组）\r\n    #result[target] = 0\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        \r\n        result = [float('inf')] * len(s); \r\n        target = -len(s);\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                target = i; \r\n            result[i] = min(result[i], abs(target-i)); \r\n        for i in range(len(s)-1, -1,-1):\r\n            if s[i] == c:\r\n                target = i; \r\n            result[i] = min(result[i], abs(target-i));\r\n        return result;\r\n```\r\n时间复杂度： o(n)\r\n空间复杂度： o(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nineis7":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085491869","body":"/* 求和的方法始终会溢出，故不可采取\r\n        size_t sum = 0, max_size = num.size();\r\n        // get the sum\r\n        for(int i(0); i < max_size; ++i)\r\n            // sum += num[i] * pow(10, max_size-i-1);\r\n            sum  = sum * 10 + num[i];\r\n        sum += k;\r\n        // int count(1), level(0);\r\n        // while(sum % count) {\r\n        //     level++;\r\n        //     count *= 10;\r\n        // }\r\n        // vector<int> tmp_vec[level];\r\n        // int i(0);\r\n        // while(level){\r\n        //     tmp_vec.push_back(sum / power(10, level-1));\r\n            \r\n        //     --level;\r\n        // }\r\n\r\n        // 对于数值的位的操作有：移位操作，不过基于十进制的移位可能需要重新设计；\r\n        // 转化为string类型；\r\n        // 通过for循环取余或除提取\r\n\r\n        string str_sum = to_string(sum);  //将int型转化为string，从而可以单独操作每一位；\r\n        const size_t length = str_sum.size();\r\n        vector<int> tmp_vec;\r\n        for(int i(0); i < length; ++i)\r\n            tmp_vec.push_back(str_sum[i]-48);\r\n\r\n        return tmp_vec;\r\n        */\r\n\r\n        string str_k = to_string(k);\r\n        size_t length_num = num.size();\r\n        size_t length_k = str_k.size();\r\n        int i = length_num-1;\r\n        int j = length_k-1;\r\n        int carry = 0;\r\n        while((i+1) && (j+1)){\r\n            num[i] = num[i] + str_k[j] - 48 + carry;\r\n            carry = 0;\r\n            if(num[i] >= 10){\r\n                carry = 1;\r\n                num[i] %= 10;\r\n            }\r\n            --i;\r\n            --j;\r\n        }\r\n\r\n        if(carry){\r\n            \r\n        }\r\n    }\r\n\r\n只能说 尝试了相加的方法，但是用了size_t后还是溢出，又采取了逐位相加，结果在判断上理解还是不够到位，对情况的分析很卡。最后没忍住看了官方题解，那么这题也就作废了。留此记录。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pfyyh":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085499940","body":"### 思路\r\n\r\n模拟加法\r\n\r\n按照低位求和，大于等于十则进一。\r\n\r\n\r\n\r\n存储结构，使用的是LinkedList。底层是链表结构，往链表头插入元素。低位先进入链表，高位最后。减少一次反转\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //以num数组为基准\r\n        LinkedList<Integer> deque = new LinkedList<>();\r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            //计算当前位\r\n            int value = num[i] + k % 10;\r\n            //丢弃最低位\r\n            k /= 10;\r\n            //如果结果大于10，k进1\r\n            if (value >= 10) {\r\n                k += 1;\r\n                value -= 10;\r\n            }\r\n            deque.addFirst(value);\r\n        }\r\n        //如果数组用完了，将K剩下的高位放进去\r\n        for (; k > 0; k /= 10) {\r\n            deque.addFirst(k % 10);\r\n        }\r\n        return deque;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(max(N+M,N))，其中 N 为数组长度,M=K长度-N长度。\r\n- 空间复杂度：O(max(N+M,N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"judyzhou95":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085515819","body":"```python\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \n        p = len(num) - 1\n        while k:\n            k += num[p]            \n            v = k % 10    \n            num[p] = v\n            \n            k //=10\n            p -= 1\n        \n            if p < 0:\n                break\n        \n        while k:\n            v = k % 10\n            num = [v] + num\n            k //= 10\n        \n        return num\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhiyuanpeng":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085517916","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num[-1] += k\r\n        for i in range(len(num)-1, -1, -1):\r\n            carry, num[i] =divmod(num[i], 10)\r\n            if i:\r\n                num[i-1] += carry \r\n        if carry:\r\n            num = [int(i) for i in str(carry)] + num\r\n        return num\r\n```\r\nspace `O(M+N)` time `O(N)`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"davont":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085528745","body":"## 代码\n```js\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086470126","body":"## 代码\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const sArr = s.split('');\r\n    const keyArr = [];\r\n    const ans = [];\r\n    for (let i = 0; i < sArr.length; i++) {\r\n        const ele = sArr[i];\r\n        if(ele === c){\r\n            keyArr.push(i);\r\n        }\r\n    }\r\n    for (let i = 0; i < sArr.length; i++) {\r\n        const ele = sArr[i];\r\n        let minLen = sArr.length;\r\n        for (let j = 0; j < keyArr.length; j++) {\r\n            const keyEle = keyArr[j];\r\n            minLen = Math.min(minLen,Math.abs(keyEle - i));\r\n        }\r\n        ans.push(minLen);\r\n    }\r\n    return ans;\r\n\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085530541","body":"## 思路\n1. 比较intuitive的想法就是先转换成字符串-> 数字+k ->字符串 \n2.  \n## 代码\n1. \n’‘’\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n                \n        int_str = ''\n\n        for i in num:\n            int_str += str(i)\n        \n        int_str = str(int(int_str) + k)\n\n        res=[int(i) for i in int_str]\n\n        return res\n‘’‘\n## 复杂度分析\n1. Time complexity: On; Space complexity On.","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuyingliu2021":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085533007","body":"三种方法\n```\n暴力\n时间复杂度O(n)\n空间复杂度O(n)\n先把k转为字符串 然后转成int 和k相加再慢慢转回来\n```\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        return list(map(int,str(int(''.join(map(str,num))) + k)))\n```\n\n```\n模拟\n时间复杂度O(n)\n空间复杂度O(n)\n模板真好用hh\n```\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        lstk = list(int(i) for i in str(k))\n        i = len(num) -1\n        j = len(lstk) -1\n        carry = 0\n        \n        res = []\n        while i >=0 or j >=0:\n            x = num[i] if i >=0 else 0\n            y = lstk[j] if j >=0 else 0\n            \n            sum = x + y + carry  \n            \n            keep = sum % 10\n            carry = sum // 10\n    \n            res.append(keep)\n               \n            i = i -1\n            j = j -1\n            \n        if carry != 0:\n            res.append(carry)\n        return res[::-1]\n```\n\n```\n把k加进去 这个和模拟差不多 \n看了别人的答案 感觉也不错\n```\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n        while k:\n            num[i] += k\n            k, num[i] = num[i] // 10, num[i] % 10\n            i -= 1\n\n            if i < 0 and k:\n                num.insert(0,0)\n                i = 0\n        return num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086542553","body":"两种方法\r\n```\r\n暴力\r\n把s中和c相等的index取出来 之后一个个和s中的index相减 max(abs(差))\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n```\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        lst = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                lst.append(i)\r\n        res= []\r\n        for i in range(len(s)):\r\n            dis = [] \r\n            for j in lst:\r\n                dis.append(abs(i-j))\r\n            res.append(min(dis)) \r\n        return res \r\n```\r\n\r\n```\r\n一个指针\r\n当满足两个条件p+=1\r\n1. p还没有走完\r\n2. i 到  p 的绝对距离 > 到p + 1的绝对距离\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)\r\n\r\n```\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        p = 0\r\n        lst = list(i for i in range(len(s)) if s[i] == c)\r\n\r\n        for i, j in enumerate(s):\r\n            if p < len(lst) -1 and abs(lst[p] -i) > abs((lst[p+1]) -i):\r\n                p+=1\r\n            res.append(abs(lst[p]-i))\r\n            \r\n        return res\r\n        \r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"futurefields":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085538554","body":"Idea:high precision addition\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n    reverse(num.begin(), num.end());\n        for(auto&t : num){\n            k+= t;\n            t= k % 10;\n            k/= 10;\n        }\n        while(k) num.push_back(k % 10), k/= 10;\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\nSpace O(n) Time O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wwang4768":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085550862","body":"***Idea***  \nTo convert the int k to string, and then can leverage math functions to add. Finally converting the result back to list. However this is very brute force. \n\n***Code***\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \n        numInt = int(''.join((str(i) for i in num)))\n       \n        temp = numInt + k\n        result = [int(j) for j in str(temp)]\n        \n        return result\n```\n\n***Complexity***  \nTime: O(n)  \nMemory usage: O(n) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085553826","body":"- ### 思路\n\t- 将数组转换成字符串，然后转换成整数\n\t- 然后做加法\n\t- 然后再将结果转换成数组\n- ### Code\n\t  ```python\t  \t  \n              class Solution:\n\t  \t      def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t  \t          str1 = ''.join([str(x) for x in num])\n\t  \t          number = int(str1)\n\t  \t          newNumber = number + k\n\t  \t          newList = list(map(int,str(newNumber)))\n\t  \t          return newList\n\t  ```\n- ### 复杂度\n\t- 时间复杂度 O(n)\n\t- 空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo660":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085579178","body":"* ### 思路\n\n最开始想着将num数组变为数字，再加K，但是数组的长度最大为1w，变量接收不了这么大的数。\n\n最后用数组从后向前遍历，加上k的值，注意进位与整除。\n\n* ### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        for (int i=num.size()-1; i>=0 ;i--){\n            int temp = 0;\n            temp = (num[i] + k)%10;\n            k = (num[i] + k)/10;\n            res.insert(res.begin(), temp);\n        }\n        while (0 != k){\n            res.insert(res.begin(), k%10);\n            k /= 10;\n        }\n        return res;\n    }\n};\n```\n\n* ### 复杂度\n    * 时间复杂度O(max(n,c)) n为num的长度，c为k的位数\n    * 空间复杂度O(max(n,c)) n为num的长度，c为k的位数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086519518","body":"### 思路\n先从左向右遍历，再从右向左遍历取最小值\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> answer(s.size());\n        int pre = INT32_MIN/2;\n        for (int i = 0; i < s.size() ; i++){\n            if (s[i] == c) pre = i;\n            answer[i] = i - pre;\n        }\n        pre = INT32_MAX;\n        for (int i = s.size()-1 ; i >= 0 ; i--){\n            if (s[i] == c) pre = i;\n            if (answer[i] > (pre - i))\n                answer[i] = pre - i;\n        }\n        return answer;\n    }\n};\n```\n### 复杂度\n* 时间复杂度 O(n)\n* 空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085584434","body":"## 思路\n将数组转换成整数，然后与整数K做加法，之后再转换成数组返回\n## 代码\nclass Solution:\n    def add_array_with_num(self, num: List[int], k: int) -> List[int]:\n        sum = 0\n        digit = 1\n        for i in range(len(num)-1, -1, -1):\n            sum += num[i]*digit\n            digit *= 10\n        sum += k\n        result = [0]*len(str(sum))\n        for i in range(len(result)-1, -1, -1):\n            result[i] = sum % 10\n            sum //= 10\n        return result\n## 复杂度分析\n空间复杂度：O(N) 时间复杂度：O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bolunzhang2021":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085594873","body":"```\r\nimport java.util.*;\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n      List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10) {\r\n                k++;\r\n                sum =sum% 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n空间复杂度：O(N) 时间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wychmod":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085602602","body":"### 思路\n大体上是先将数组遍历一遍，将其转换为数字，然后与k相加，再将数字转换为数组\n### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sum = ''.join([str(n) for i, n in enumerate(num)])\n        sum = int(sum) + k\n        return [int(i) for i in str(sum)]\n```\n### 时间复杂度\n空间复杂度：O(n) 在将数字转换为数组的时候创建了数组\n\n时间复杂度：O(n) 遍历了有限次的数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086544108","body":"### 思路\n（比较暴力）先把所有的e找出来下标放入数组中，然后将原数组的每一个点与所有e的下标对比取最小的那个。\n### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        el = []\n        for i, n in enumerate(s):\n            if n == c:\n                el.append(i)\n        res = [0]*len(s)\n        for i in range(len(s)):\n            less = abs(i-el[0])\n            for j in el:\n                less = min(abs(i-j), less)\n            res[i] = less\n        return res\n```\n### 复杂度分析\n时间复杂度：O(n*目标字符在数组中出现的次数)\n\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085608090","body":"\n### 题目：\n\n【Day 1】989. 数组形式的整数加法 \n\n[力扣地址：989](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n### 思路：\n\n用的 python 语言\n\n- 用 c 作为进位记录值，用当前的 num 作为结果数组\n- 当 num 和 k 都没有结束的时候，进行 num[i] + 个位数 + 进位值\n- 当 k 没有结束的时候，进行将 k 剩下的转为 数组进行想加\n- 当 num 没有结束的时候，将当前的 i 和进位值加起来然后前面数组保留\n- 当 进位值 还未归 0 的时候，将 进位值增加到 数组最前面\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        c = 0  #进位\n        i = len(num) - 1 #数组位置\n\n       # 当num没结束 and k 没结束\n        while(k and i > -1):\n            n = num[i] + (k % 10) + c \n            k //= 10\n            c = n // 10\n            num[i] = n % 10\n            i = i - 1\n        \n        # 当 k 没有结束的时候\n        while(k): \n            num = [(k % 10 +c)%10] + num \n            c = (k % 10 +c) // 10   \n            k = k // 10 \n           \n        # 当 数组没有结束的时候\n        while(i > -1):\n            n = c + num[i]\n            c = n // 10\n            num[i] = n % 10\n            i = i - 1  \n        # 当进位没有结束的时候\n        while(c):\n            num = [c] + num \n            c = 0\n\n        return num\n```\n\n\n\n### 时间复杂度：O（N）\n\n### 空间复杂度：O（N）\n\n反思：我可太笨了，思维不够缜密，最终还是写出垃圾冗长的代码，还得再学习一下...","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tensorstart":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085612304","body":"### 思路\n类似于第二题，按位倒叙相加，注意进位\n\n### 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n    res=[];\n    l=num.length;\n    for (let i = l-1; i >=0 ; i--) {\n        let pos_num=0;\n        pos_num=num[i]+k%10;\n        k=Math.floor(k/10);\n        if (pos_num>=10){\n            pos_num-=10;\n            k+=1;\n        }\n        res.push(pos_num);\n    }\n    while (k){\n        res.push(k%10);\n        k=Math.floor(k/10);\n    }\n    res.reverse();\n    return res;\n};\n\n```\n**复杂度分析**\n- 时间复杂度：$O(k,n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"physicshi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085682784","body":"## 思路\n按位求和，用flag保存进位，加到下一轮\n## 代码\n```js\nvar addToArrayForm = function (num, k) {\n  const res = [];\n  let order = num.length - 1;\n  // 进位\n  let flag = 0;\n  while (order >= 0 || k != 0) {\n    let x = order >= 0 ? num[order] : 0;\n    let y = k != 0 ? k % 10 : 0;\n    let sum = x + y + flag;\n    // 保存余数\n    res.push(sum % 10);\n    flag = Math.floor(sum / 10);\n    k = Math.floor(k / 10);\n    order--;\n  }\n  if (flag) res.push(flag);\n  return res.reverse();\n};\n```\n## 复杂度\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"m908":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085689040","body":"### 思路\n从后往前遍历数组，按位与K相加\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> result;\n        for(int i = num.size() - 1; i >= 0; i--)\n        {\n            int curNumber = num[i] + k % 10;\n            k /= 10;\n            if(curNumber >= 10)\n            {\n                curNumber -= 10;\n                k += 1;\n            }\n            result.push_back(curNumber);\n        }\n        \n        for (; k > 0; k /= 10) {\n            result.push_back(k % 10);\n        }\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n```\n### 复杂度\n- 时间复杂度：O(max(n,logk))\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"astrking":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085691561","body":"思路\n\n    二者从低位相加，满10进位即可\n\n代码\n\n    class Solution {\n        public List<Integer> addToArrayForm(int[] num, int k) {\n            List<Integer> res = new ArrayList<Integer>();\n            int n = num.length;\n            for (int i = n - 1; i >= 0; --i) {\n                int sum = num[i] + k % 10;\n                k /= 10;\n                if (sum >= 10) {\n                    k++;\n                    sum -= 10;\n                }\n                res.add(sum);\n            }\n            for (; k > 0; k /= 10) {\n                res.add(k % 10);\n            }\n            Collections.reverse(res);\n            return res;\n        }\n    }\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085696335","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 思路\n\n- 从后向前逐位相加\n\n## 关键点\n\n-  不能直接把num转成数字相加，数字过大时会越界被截取\n-  考虑进位\n-  考虑k的长度大于num\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let add = k\n    for (let i=num.length-1;i>=0;i--) {\n        if(!add) {\n          break;\n        }\n        let sum = num[i] + add%10\n        add = Math.floor(add/10)\n        if (sum >= 10) {\n            add++\n            num[i] = sum%10\n        } else {\n          num[i] = sum\n        }\n    }\n    while(add > 0) {\n        num.unshift(add%10)\n        add = Math.floor(add/10)\n    }\n    return num\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"timmmyang":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085699745","body":"## 思路\r\n从低位相加，`num`结束后继续判断`k`即可。\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        carry = 0\r\n        for digit in num[::-1]:\r\n            if k > 0:\r\n                add = k % 10\r\n                k = k // 10\r\n                digit = digit + add + carry\r\n                carry = digit // 10\r\n                res.append(digit%10)\r\n            else:\r\n                digit += carry\r\n                carry = digit // 10\r\n                res.append(digit%10)\r\n        if k > 0:\r\n            while k > 0:\r\n                add = k % 10\r\n                k = k // 10\r\n                digit = add + carry\r\n                carry = digit // 10\r\n                res.append(digit%10)\r\n        if carry == 1:\r\n            res.append(1)\r\n        return res[::-1]\r\n```\r\n## 复杂度\r\n时间：O(n)，n为数组长度\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086534623","body":"### 思路\r\n\r\n正反两次遍历，分别记录当前字符是`c`的index，初始值使用`inf`。第二次遍历时比较存入最小值。\r\n\r\n### 代码\r\n\r\n```Python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        idx = -float('inf')\r\n        res = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                idx = i\r\n            res.append(i - idx)\r\n        idx = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            res[i] = min(res[i], idx - i)\r\n        return res \r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(n)，n为`s`长度\r\n\r\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085702964","body":"## 思路\r\n转换为字符串后再进行处理\r\n![image](https://user-images.githubusercontent.com/30134501/161241442-d66bc6e2-aaee-41a4-ba25-072de0f524be.png)\r\n\r\n## 代码（python）\r\n\r\n```python\r\nclass Solution:\r\n  def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n      return list(map(int, list(str(int(''.join(list(map(str, num))))+k))))\r\n```\r\n**复杂度分析**\r\n- 时间复杂度： O(n) , n 为数组长度。\r\n- 空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086539562","body":"## 思路\r\n暴力解法，遍历找到index；将`answer`里的值设置很大，循环`range(0, len(s))`+循环`index`，作差求绝对值，跟`answer[i]`比较大小\r\n\r\n## 代码 （python3）\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        index = [i for i,si in enumerate(s) if si==c]\r\n        answer = [len(s)]*len(s)\r\n        for i in range(0, len(s)):\r\n            for j in index:\r\n                if abs(i-j)<answer[i]:\r\n                    answer[i] = abs(i-j) \r\n        return answer\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度： O(n^2)， n为`s`长度, 套了两个循环\r\n- 空间复杂度： O(n)，n为`answer`数组长度\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yinhaoti":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085717791","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \"\"\"\n        Idea:\n            case1: len(num) > len(str(k)):\n                add two digital -> get result & carry\n                left move 1 digital of k\n            case2: len(num) < len(str(k)):\n                k += carry\n                while: add k to new array / convert k to array\n        Topic: Array enumerate\n        TC: O(N + max(0, (K-N)^2)\n        SC: O(max(1,K-N))\n        \"\"\"\n        carry = 0\n        for i in range(len(num) - 1, -1, -1):\n            add_result = carry + num[i] + k % 10\n            num[i] = add_result % 10\n            carry = add_result // 10\n            k = k // 10\n        \n        re = []\n        k = k + carry\n        while k:\n            re.insert(0, k % 10)\n            k = k // 10\n        \n        return re + num\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085768414","body":"## 思路\n新建一个数组，长度为num和k的长度的最大值，从num和k的末尾开始相加，得到的值赋值到新数组中，注意进位。\n\n## 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n  let size = Math.max(num.length, (k + '').length);\n  let res = new Array(size);\n  let j = num.length - 1;\n  for (let i = res.length - 1; i >= 0; i--) {\n    let sum = k % 10;\n    if (j >= 0) sum += num[j];\n    if (res[i]) sum += res[i];\n    if (i === 0) {\n      res[i] = sum;\n    } else {\n      res[i] = sum % 10;\n      res[i - 1] = Math.floor(sum / 10);\n    }\n    k = Math.floor(k / 10);\n    j--;\n  }\n  if (res[0] >= 10) {\n    let s = res[0];\n    res[0] = s % 10;\n    res.unshift(Math.floor(s /10));\n  }\n  return res;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sallyrubyjade":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085802765","body":"### 思路\n从数组最后一位开始遍历，并取出k的个位数进行相加，再对k进行除10处理来保证每次取出的都是最末位，然后对判断相加数是否大于10，是的话要进一位（记得把这个进位带进下一次数组循环里），把相加数的个位数放在要返回数组的开头。最后判断k或者进位是否处理干净，因为可能k的位数比num数组长度大，进行循环，直到k为0。\n\n### 代码\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let ans = [];\n    let carry = 0;\n    for (let i = num.length - 1; i >= 0; i--) {\n        let temp = num[i] + (k % 10) + carry;\n        k = Math.floor(k / 10);\n        if (temp >= 10) {\n            temp = temp % 10;\n            carry = 1;\n        }else {\n            carry = 0;\n        }\n        ans.unshift(temp);\n    }\n\n    while (carry != 0 || k > 0){\n        let temp = carry + (k % 10);\n        k = Math.floor(k / 10);\n        if (temp >= 10) {\n            temp = temp % 10;\n            carry = 1;\n        }else {\n            carry = 0;\n        }\n        ans.unshift(temp);\n    }\n\n    return ans;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"meemx":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085804058","body":"### 思路\r\n从最低位（num数组最后一位开始），逐位相加\r\n\r\n### 代码\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        length = len(num)\r\n        result = []\r\n\r\n        for i in range(length - 1, -1, -1):\r\n            sum = num[i] + k % 10\r\n            k = k // 10\r\n            if sum >= 10:\r\n                k = k + sum // 10\r\n                sum = sum % 10\r\n            result.append(sum)\r\n\r\n        # 若A长度小于整数K\r\n        while k > 0:\r\n            sum = k % 10\r\n            k = k // 10\r\n            result.append(sum)\r\n\r\n        # 逆序输出\r\n        return result[::-1]\r\n```\r\n\r\n### 复杂度分析\r\n- 时间：O(n)\r\n- 空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moonlee001":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085808810","body":"## 思路\n将k转化为数组，利用双指针倒序相加。\n## 代码\nvar addToArrayForm = function(num, k) {\n    const arrK = k.toString().split('');\n    const n = num.length;\n    const m = arrK.length;\n    let p1 = n - 1, p2 = m - 1;\n    let res = [];\n    let carry = 0;\n    while (p1 >= 0 || p2 >= 0) {\n        const num1 = p1 < 0 ? 0 : num[p1];\n        const num2 = p2 < 0 ? 0 : arrK[p2] - 0;\n        const sum = num1 + num2 + carry;\n        const mode = sum % 10;\n        carry = Math.floor(sum / 10);\n        res.unshift(mode);\n        p1--;\n        p2--;\n    }\n    if (carry) {\n        res.unshift(carry);\n    }\n    return res;\n};\n\n## 复杂度\n时间：O(n)\n空间： O(m) m为数字个数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gzgzgzgzgzgz":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085811348","body":"# 思路\r\n先将数组转换成数字 再将结果转换为数组\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sum = 0\r\n        digit = 1\r\n        for i in num[::-1]:\r\n            sum += i * digit\r\n            digit *= 10\r\n        sum += k\r\n        res = []\r\n        while sum:\r\n            res.append(sum % 10)\r\n            sum = sum // 10\r\n        return res[::-1]\r\n        \r\n```\r\n# 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086538280","body":"# 思路\r\n先正序遍历 再倒着遍历一遍 \r\n# 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        idx = -float(\"inf\")\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                idx = i \r\n            # i - 负无穷 = 正无穷\r\n            res.append(i - idx)\r\n        idx = float(\"inf\")\r\n        for i in range(len(s) - 1, -1 , -1):\r\n            if s[i] == c:\r\n                idx = i \r\n            res[i] = min(idx - i, res[i])\r\n        return res\r\n```\r\n# 时间复杂度\r\n时间：0(n)\r\n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"momomoi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085818993","body":"**思路** \r\n把num列表数据合并为数字和k相加然后再拆分还原\r\n\r\n**时间复杂度** \r\n单循环O(N)\r\n\r\n**代码实现**\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n       cmt_num = ''.join((str(i) for i in num))\r\n       add_sum = int(cmt_num) + k\r\n       split_sum = [int(l) for l in str(add_sum)]\r\n       return split_sum\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085860307","body":"#### 解题思路\n  1. 低位到高位逐位将数字加在一起\n  2. 若加法的结果大于等于 1010，把进位的 11 加入到下一位的计算中\n#### 代码实现\n\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度: O(max(n,logk), 其中 nn 为数组的长度\n- 空间复杂度: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"quieter2018":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085861308","body":"**思路**\r\n从num的个位开始与k逐个相加，与10相除，余数为当前位的数值，商为下次循环的k，求完后再倒序即可。\r\n\r\n**代码实现**\r\n```C++\r\nclass Solution {\r\n  public:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> out;\r\n        int sum = 0;\r\n        for(int i = num.size()-1; i >= 0 || k > 0; i--) {\r\n            if(i >= 0){\r\n                sum = k + num[i];\r\n                out.push_back(sum % 10);\r\n                k = sum /10;\r\n            }else{\r\n                out.push_back(k % 10);\r\n                k = k /10;\r\n            }\r\n        }\r\n        reverse(out.begin(),out.end());\r\n        return out;\r\n    }\r\n};\r\n```\r\n**复杂度分析**\r\n时间复杂度：O(max(n,k))  n：num的数据长度；k：k的数据长度\r\n空间复杂度：同上","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhulin1110":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085873537","body":"## 题目\n数组形式的整数加法\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n## 思路\n首先想到的是将数组转换成数，再和K相加，但会发生内存溢出的情况。\n- **改进** \n从个位数开始考虑，依次与 k 相加，（和 % 10） 存入输出数组 ，（和 / 10）取出进位位（更新后的k包含进位）。最后考虑 k 超出数组长度的部分，依次加到输出数组里即可。\n## 代码(JavaScript)\n```JavaScript\nvar addToArrayForm = function(num, k) {\n    var res = [];\n    for (let i = num.length - 1; i >= 0; i--) {\n        res.push((num[i] + k) % 10);  //个位数存入数组\n        k = Math.floor((num[i] + k) / 10);  //更新k, 进位位包含在k中\n    }\n    // 对超出数组长度的 k 进行处理\n    while (k > 0) {\n        res.push(k % 10);\n        k = Math.floor(k / 10);\n    }\n    return res.reverse();\n};\n```\n## 复杂度\n- 时间复杂度\n> O(n) ，for循环遍历数组长度n，后面的可以忽略不计\n- 空间复杂度\n> O(n) ， 创建一个新的数组res存放结果，后面有循环但是没有分配新的内存空间\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lizimu0709":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085873737","body":"- 思路\r\n当前位 = (A 的当前位 + B 的当前位 + 进位) % 10\r\nAB两数都加完后判断进位 , 进位不为 0 加在前面。\r\n\r\n- 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] res, int K) {\r\n        List<Integer> Arr = new ArrayList<>();\r\n        int n = res.length;\r\n        int i = n-1;\r\n        int carry = 0;\r\n        int sum = 0;\r\n        while(i >= 0 || K != 0){\r\n            int x = i >= 0 ? res[i] : 0;\r\n            int y = K >= 0 ? K%10 : 0;\r\n            sum = x + y +carry;\r\n            carry = sum / 10;\r\n            K = K / 10;\r\n             --i;\r\n             Arr.add(0,sum%10);\r\n        }\r\n        if(carry != 0)\r\n            Arr.add(0,carry);\r\n        return Arr;\r\n    }\r\n}\r\n```\r\n\r\n- 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085898822","body":"## Idea\r\nIterate through the number array backwards. Add each element to k, remove the last digit from k and add it to the list.\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new ArrayList<>();\r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            k += num[i];\r\n            list.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        while (k > 0) {\r\n            list.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(list);\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086368202","body":"## Idea\r\nIterate through the string for 3 times. Locate all occurrences of c in the first iteration. Update distance based on distance on the left side in the second iteration and update distance based on distance on the right side in the third iteration.\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] str = s.toCharArray();\r\n        int[] ans = new int[str.length];\r\n        Arrays.fill(ans, Integer.MAX_VALUE);\r\n        for (int i = 0; i < str.length; i++) {\r\n            if (str[i] == c) {\r\n                ans[i] = 0;\r\n            }\r\n        }\r\n        \r\n        for (int i = 0; i < str.length - 1; i++) {\r\n            if (ans[i] != Integer.MAX_VALUE) {\r\n                ans[i+1] = Math.min(ans[i] + 1, ans[i+1]);\r\n            }\r\n        }\r\n        \r\n        for (int i = str.length-1; i > 0; i--) {\r\n            if (ans[i] != Integer.MAX_VALUE) {\r\n                ans[i-1] = Math.min(ans[i] + 1, ans[i-1]);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiayuhui231":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085901627","body":"## 题目\n数组形式的整数加法\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/submissions/\n## 思路\n   - 由于直接循环将数组取出来相加长度可能会超出，所以按倒序取出数组，依次相加取余放进数组\n   - 可能会出现加完后k值为个位数的情况，所以多加个判断，将剩余数也加入数组\n## C++代码\n``` class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n        int t = k, idx=0;\n        vector<int> ans;\n        while(t)\n        {\n            if(idx<num.size()) t+=num[idx++];\n            ans.push_back(t%10);\n            t /= 10;\n        }\n        while(idx<num.size()) ans.push_back(num[idx++]);\n        reverse(ans.begin(), ans.end());\n        return ans;\n\n    }\n};\n```\n## 复杂度\n     时间：O(n）\n     空间：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085906678","body":"# Plan:\r\n```\r\niterate from end of num, last digit of k, insert to the head of the linkedlist, update carry, curSum\r\n\r\nedge cases: k is longer, num is longer, carry == 1 in the end\r\n```\r\n\r\n# Code:\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> sum = new LinkedList<>();\r\n        int numIndex = num.length - 1;\r\n        int curSum = 0, carry = 0;\r\n        \r\n        while (numIndex >= 0) {\r\n            curSum = num[numIndex] + k % 10 + carry;\r\n            carry = curSum / 10;\r\n            curSum %= 10;\r\n            sum.addFirst(curSum);\r\n            k /= 10;\r\n            numIndex--;\r\n        }\r\n        \r\n        while (k > 0) {\r\n            curSum = k % 10 + carry;\r\n            carry = curSum / 10;\r\n            curSum %= 10;\r\n            sum.addFirst(curSum);\r\n            k /= 10;\r\n        }\r\n        \r\n        if (carry == 1) sum.addFirst(carry);\r\n        return sum;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity:\r\n```\r\nTime: O(max(num.length, log_10_k))\r\nSpace: O(max(num.length, log_10_k)) for the linkedlist\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086537211","body":"# Plan & Complexity: \n\n```\nIt is guaranteed that c occurs at least once in s.\n1 <= s.length <= 10^4\n\ns = \"loveleetcode\", c = \"e\"\n\nl o v e l e e t c o d e\nm m m 0 1 0 0 1 2 3 4 0\n3 2 1 0 1 0 0 1 2 2 1 0\n\nidea: two traversals, left-> right, right -> left\n\nTime: O(s.length())\nSpace: O(s.length()) for the distances array\n```\n\n# Code:\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] distances = new int[s.length()];\n        int toCompare = Integer.MAX_VALUE;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                distances[i] = 0;\n                toCompare = i;\n            } else {\n                distances[i] = Math.abs(toCompare - i);\n            }\n        }\n        \n        \n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                distances[i] = 0;\n                toCompare = i;\n            } else {\n                distances[i] = Math.min(distances[i], Math.abs(toCompare - i));\n            }\n        }\n        \n        return distances;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bin214":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085914856","body":"####思路\n\n按位取出数字k，依次加到数组A内，需注意产生的进位，如果数组首位仍有进位，则数组首部加一位\n\n\n\n#### 代码\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> ans = new ArrayList<>();\n    int n = num.length;\n    int sum = 0, flag = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        sum = (k % 10) + num[i] + flag;\n        k = k / 10;\n        if (sum >= 10) {\n            sum = sum % 10;\n            flag = 1;\n        } else {\n            flag = 0;\n        }\n        ans.add(sum);\n    }\n    while (k != 0){\n        ans.add(k % 10 + flag);\n        k = k / 10;\n        if(flag != 0) flag = 0;\n    }\n    if(flag != 0)\n        ans.add(1);\n    Collections.reverse(ans);\n    return ans;\n}\n```\n\n\n\n#### 复杂度分析\n\n时间复杂度：O(m + n)\n\n空间复杂度：O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oision-hub":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085926377","body":"### 思路\n逐位相加，若大于10则进位。\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> result;\n        int len = num.size();\n        for (int i = len - 1; i >= 0; i--) {\n            int temp = num[i] + k % 10;\n            k = k / 10;\n            if (temp >= 10) {\n                k += 1;\n                temp = temp % 10;\n            }\n            result.push_back(temp);\n        }\n        while (k != 0) {\n            result.push_back(k % 10);\n            k = k / 10;\n        }\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n```\n### 复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangsizhongbin":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085927113","body":"func addToArrayForm(num []int, k int) []int {\n    for i := len(num) - 1; i >= 0; i-- {\n        num[i] += k % 10\n        k /= 10\n\n        // if overflow\n        if num[i] > 9 {\n            k++\n            num[i] -= 10\n        }\n    }\n\n    // if k length more than num length\n    for k > 0 {\n        num = append([]int{k % 10}, num...)\n        k /= 10\n    }\n\n    return num\n\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhishinaigai":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085936068","body":"### 思路\r\n浅抄一手答案\r\n\r\n### 代码\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector <int> ans;\r\n        int len=num.size();\r\n        \r\n        for(int i=len-1;i>=0;i--){\r\n            int s=num[i]+k%10;\r\n            k/=10;\r\n            if(s>=10){\r\n                k++;\r\n                s-=10;\r\n            }\r\n            ans.push_back(s);\r\n        }\r\n        while(k>0){\r\n            ans.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(ans.begin(),ans.end());\r\n        return ans;\r\n    }\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jasonhe-wq":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085938194","body":"思路：将列表中的数转化为整数，与k相加，再转化为可迭代对象，加入数组输出\n代码：\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s=''.join(str(i) for i in num)\n        n = str(eval(s)+k)\n        l = []\n        for i in n:\n            l.append(eval(i))\n        return l\n        \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085938263","body":"## 989. Add to Array-Form of Integer\n### 1. 思路\n- 基础思考点：transform a number to an int array\n```C\n// 代码实现\nvar array = [];\nvar k = 123;\nwhile (k >= 1) {\n  array.push(Math.floor(k % 10));\n  k /= 10;\n}\n// array: [1, 2, 3]\n```\n拓展上述代码，思路变为：\n> k 或 num 还有剩余位数时，resultArray 不断添加剩余数位\n### 2. 细节处理\n- 相加的结果会进位（这里我用了 num 来存储进位数据）\n  - 如果 num 数组还有数字，给数组的最后一位+1\n  - 如果 num 数组没有数字了，将数组的最后一位赋为 1\n- num 代表的数字，其位数和 k 的位数不一致\n  - 判断一下，确保 getK 和 getN 不会越位\n\n### 3. 复杂度\n- 时间：O(n)  \n  - while 的长度为 max(k的位数，num的位数);  \n  - while 内部涉及的数组操作:     \narray.pop(), array.push(), array[i] =，三者的时间复杂度为 O(1)\n- 空间：O(n)\n  - 新开了一个数组，O(n)\n\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nconst addToArrayForm = (num, k) => {\n  let temp = 0;\n  const resultArray = [];\n  while (k >= 1 || num.length) {\n    temp = getK(Math.floor(k % 10)) + getN(num);\n    resultArray.push(handleTemp(temp, num));\n\n    temp = 0;\n    k /= 10;\n  }\n  return resultArray.reverse();\n};\n\nconst getK = (kNum) => kNum >= 1 ? kNum : 0;\nconst getN = (num) => num.length ? num.pop() : 0;\nconst handleTemp = (temp, num) => {\n  if (temp >= 10) {\n    temp -= 10;\n    if (num.length) {\n      num[num.length - 1] += 1;\n    } else {\n      num[0] = 1;\n    }\n  }\n  return temp;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086504869","body":"821. Shortest Distance to a Character\n### 1. 思路\n- 基础思路\n  - 求数组中两个元素 i, j 的距离: i - j\n- 拓展\n  - 求 i 到左右两边 j、h 的最短距离  \n### 2. 细节\n  - j 的位置未知：\n    - 开一个线性数据结构，记录 j 的位置\n  - 离 i 最近的元素不一定是 j，i 可能还有左相邻、且距离更近的元素 h：\n    - 求最短距离时，比较 Math.min(Math.abs(i - j), Math.abs(i - h))\n  - i - j、i - h，索引不应越界  \n### 3. 复杂度\n- 时间：O(n)\n  - 遍历 s，且遍历内部无 O(n) 及以上层级的操作\n- 空间：O(n)\n  - 新开了 resultArr 数组\n\n```javascript\nvar shortestToChar = function(s, c) {\n  const cHash = new Array(s.length).fill(0);\n  let cHashStart = 0;\n  const resultArr = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) {\n      cHash[cHashStart] = i;\n      cHashStart++;\n      resultArr[i] = 0;\n    }\n  }\n  cHashStart = 0;\n  cHashPrev = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (i !== cHash[cHashStart]) {\n      cHashPrev = cHashStart > 0 ? cHashStart - 1 : 0;\n      const shortestGap = Math.min(\n        Math.abs(cHash[cHashPrev] - i),\n        Math.abs(cHash[cHashStart] - i)\n      );\n      resultArr[i] = shortestGap;\n    } else {\n      cHashStart++;\n    }\n  }\n  return resultArr;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"divingcub":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085938282","body":"## Idea\r\nBackward iteration, 考虑位进.\r\n\r\n## Code \r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> sum = new ArrayList<Integer>();\r\n        int length = num.length;\r\n        num[length - 1] += k;\r\n        for (int i = length - 1; i > 0; i--) {\r\n            int curNum = num[i];\r\n            if (curNum > 9) {\r\n                num[i - 1] += curNum / 10;\r\n                num[i] %= 10;\r\n            }\r\n            sum.add(num[i]);\r\n        }\r\n        do {\r\n            sum.add(num[0] % 10);\r\n            num[0] /= 10;\r\n        } while (num[0] > 0);\r\n        Collections.reverse(sum);\r\n        return sum;\r\n    }\r\n}\r\n\r\n## Complexity\r\nTime:O(n)\r\nSpace: O(1)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaru-zhang":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085944030","body":"# 思路\r\n- 由于直接循环将数组取出来相加长度可能会超出，所以按倒序取出数组，依次相加取余放进数组\r\n- 可能会出现加完后k值为个位数的情况，所以多加个判断，将剩余数也加入数组\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        n = len(A)\r\n        ans = []\r\n\r\n        for i in range(n-1, -1, -1):\r\n            total = A[i] + K % 10\r\n\r\n            K //= 10\r\n            \r\n            if total >= 10:\r\n                #当前位相加结果大于 10 时，进位 1 加入下一位计算\r\n                K += 1\r\n\r\n            ans.append(total % 10)\r\n            \r\n        # 这里考虑数组 A 的长度小于整数 K 位数个数的情况\r\n        while K > 0:\r\n            ans.append(K % 10)\r\n            K //= 10\r\n        # 因为添加进来是由低位往高位，输出时进行逆序输出\r\n        return ans[::-1]\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cshowww":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085951022","body":"## 代码\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int n = num.length;\n        for(int i=n-1;i>=0;i--){\n            int sum = k%10 + num[i];\n            k = k/10;\n            if(sum >= 10){\n                sum = sum-10;\n                k++;\n            }\n            res.add(0,sum);\n        }\n\n        while(k > 0){\n            res.add(0,k%10);\n            k = k/10;\n        }\n        return res;\n    }\n}\n```\n\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kesucaso":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085955510","body":"#思路\n\nnum数组中的每个数字与k中的对应位置的数字相加，然后如果对应位置相加大于10，则进位到高位的位置上去。\n\n#代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        ans = []\n        for i in range(len(num)-1,-1,-1):\n            n = num[i]+k%10\n            k=k//10\n            if n>=10:\n                ans.append(n%10)\n                k+=1\n            else:\n                ans.append(n)\n        while k>=1:\n            ans.append(k%10)\n            k=k//10\n        return ans[::-1]\n```\n\n#复杂度分析\n\n时间复杂度：O(n) （遍历数组）\n\n空间复杂度：O(n) （返回的数组大小）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"testeducative":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085957096","body":"```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int tmp = 0;\n        for(int i = num.size() - 1; i >= 0; i--){\n            tmp = num[i] + k % 10;\n            k /= 10;\n            if(tmp >= 10){\n                tmp = tmp % 10;\n                k++;\n            }\n            res.push_back(tmp);\n        }\n\n        for( ; k > 0; k/=10){\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hzhengzhi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085962315","body":"##思路\r\nnum从后向前进行运行，每次都用k和对应位置上数字进行相加，若相加结果大于10，则携带进位前往下一位。\r\n如果num结束后，k中仍然剩余部分数字，直接进行求余即可。\r\n```\r\n public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans= new ArrayList<>();\r\n        for(int i=num.length-1;i>=0;i--)\r\n        {\r\n            ans.add(0,(num[i]+k)%10);\r\n            k=(k+num[i])/10;\r\n        }\r\n        while(k!=0)\r\n        {\r\n            ans.add(0,k%10);\r\n            k=k/10;\r\n        }\r\n        return ans;\r\n    }\r\n```\r\n##复杂度\r\n时间复杂度O(n)\r\n空间复杂度O(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rzhao010":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085969554","body":"**Thoughts**\nAdding up by digits.\nIn the array, we start from the last element.\nFor the integer k, each time we use the last digit (k % 10),\nif the sum is bigger than 9, add 1 to k(so we don't need another var to record it).\nAfter the loop, deal with the case k > 0 (maybe k is too big or we have addup).\n\n**Code**\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum > 9) {\n               k += 1;\n               sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n**Time Complexity**\nTime: O(N), one for loop\nSpace: O(1), use one arraylist as result","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086529915","body":"**Thoughts**\n1. Get all indices of c, go through s to compare i with indices of c\n2. Traverse s from left side and right side, record the last index of c , so `i - prev` and `prev - i` is the distance for each traverse, at last compare and select the smaller one\n\n**Code**\n```jave\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        ArrayList<Integer> list = new ArrayList<>();\n        int[] res = new int[n];\n        int p = 0; \n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                list.add(i);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p < list.size() - 1 && Math.abs(list.get(p) - i) > Math.abs(list.get(p + 1) - i)) {\n                p++;\n            }\n            res[i] = Math.abs(list.get(p) - i);\n        }\n        return res;\n    }\n```\n**Time Complexity**\n* Time: O(n)\n* Space: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"antmup":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085970492","body":"### 思路\n1、首先将数组转换为对应的数字；\n2、将两个数字相加；\n3、将最终的数字拆解为数组；\n\n### 代码\n\n``` js\nfunction intSumOfArray(initNumArray, Addend) {\n  // 第一步\n  const initNum = +initNumArray.join('');\n\n  // 第二步\n  const tempSum = String(initNum + Addend);\n  console.log(tempSum, 'tempSum');\n  // 第三步\n  return  tempSum.split('').map(Number);\n}\n\nconsole.log(intSumOfArray([1, 2, 0, 0], 34));\nconsole.log(intSumOfArray([2, 7, 4], 181));\nconsole.log(intSumOfArray([2, 1, 5], 806));\n\n```\n\n** 复杂度分析 **\n- 时间复杂度：O(n)，\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jax-van":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085972190","body":"## idea\n从低位往高位相加，并处理进位，可以用k同时存储进位信息，每次迭代有 k = (num[i] + k) / 10\n## code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int len = num.length;\n        for (int i = len - 1; i >= 0; i--) {\n            res.add(0, (num[i] + k) % 10);\n            k = (num[i] + k) / 10;\n        }\n        while (k != 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n        return res;\n    }\n}\n```\n## complexity\n- time: O(max(len(num), digit(k))\n- space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"webcoder-hk":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085977131","body":"```python\r\n# 都转成整数相加，再转成数组\r\nfrom typing import *\r\nfrom functools import reduce\r\n\r\ndef solution(a:List[int], b:int)->List[int]:\r\n    x = reduce(lambda x,y:x*10+y, a)\r\n    x += b\r\n    result = []\r\n    r = x%10\r\n    x //= 10\r\n    while x or r:\r\n        result.append(r)\r\n        r = x%10\r\n        x //= 10\r\n    result.reverse()\r\n    return result\r\n```\r\ntime: O(n)\r\nspace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bluerui":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085981416","body":"# Problem [989. Add to Array-Form of Integer](https://leetcode.com/problems/add-to-array-form-of-integer/)\n## Algorithm\n1. Add *k* to each digit of num from the lowest digit.\n2. Then *k%10* is saved to result as the new digit, and *k/10* is used as the new *k* for next digit.\n3. The drawback of this method is if *k* is very close to MAX_VALUE (within 10), then there could be overflow.\n\n## Complexity\n* Time complexity: O(max(num.length, logK))\n* Space complexity: O(max(num.length, logK))\n\n## Code\nLanguage: Java\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> result = new ArrayList<>();\n    int cur = k;\n    int i = num.length - 1;\n    while (i >= 0 || cur > 0) {\n        if (i >= 0) {\n            cur += num[i];\n        }\n        result.add(cur % 10);\n        cur /= 10;\n        i--;\n    }\n    Collections.reverse(result);\n    return result;\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mrorz0914":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086000216","body":" public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans= new ArrayList<>();\n        for(int i=num.length-1;i>=0;i--)\n        {\n            ans.add(0,(num[i]+k)%10);\n            k=(k+num[i])/10;\n        }\n        while(k!=0)\n        {\n            ans.add(0,k%10);\n            k=k/10;\n        }\n        return ans;\n    }\n##复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duantao74520":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086000316","body":"### 思路：\n\n小学加法，大于10进一，从个位开始加，将结果塞到数组，最终返回数组时，翻转一下数组。\n\n例如【2,1,5】 与 806\n\n1. 遍历数组，初始化进位为0\n\n   5 + 8 + 0 = 11 ，塞1， 进位1。\n\n   1 + 0 + 1 = 2    ，塞2， 进位0\n\n   2 + 8 + 0 = 10  ，塞0， 进位1\n\n   关键在遍历完数组后，k 有可能为0 ，但是进位可能为1.\n\n2. 特殊处理以上情况\n\n   k += 进位\n\n   这样的话，k为0 ，构造成1， k非0，刚好可以进位\n\n3. 遍历剩余的k，每次除10\n\n### 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> ret_vec;\n        int up = 0;\n        // 遍历num\n        for (int pos = num.size() - 1 ; pos >= 0; pos--) {\n            int a = num[pos];\n            int b = k % 10;\n            k = k / 10;\n            ret_vec.emplace_back((a + b + up) % 10);\n            up = (a + b + up) /10;\n        }\n        k = k + up; // 防止有进位 k 还等于0的情况\n        while (k > 0) {\n            ret_vec.emplace_back(k % 10 );\n            k = k /10;\n        }\n         std::reverse(ret_vec.begin(), ret_vec.end());\n         return ret_vec;\n    }\n};\n```\n\n### 复杂度：\n\n1. 空间复杂度 O(1)\n\n2. 时间复杂度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"omegalzx":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086006617","body":"~~~java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int[] num2 = convertNumToArray(k);\n        List<Integer> result = new ArrayList<>();\n        int i = num.length - 1;\n        int j = num2.length - 1;\n        int carry = 0;\n        while (i >= 0 || j >= 0) {\n            int sum = carry;\n            if (i >= 0) {\n                sum += num[i];\n            }\n            if (j >= 0) {\n                sum += num2[j];\n            }\n            result.add(sum % 10);\n            carry = sum / 10;\n            i--;\n            j--;\n        }\n        if (carry > 0) {\n            result.add(carry);\n        }\n        Collections.reverse(result);\n        return result;\n    }\n\n\n    private int[] convertNumToArray(int num) {\n        List<Integer> result = new LinkedList<>();\n        while (num > 0) {\n            result.add(num % 10);\n            num /= 10;\n        }\n        Collections.reverse(result);\n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}\n~~~\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"vivixu-qiqi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086007071","body":"```\r\nvar addToArrayForm = function(num, k) {\r\n    let sum = k;\r\n    let index = num.length - 1;\r\n    let result = '';\r\n    let resultArr = [];\r\n    while(index >= 0 || sum > 0) {\r\n        if(index >= 0) {\r\n            sum += num[index];\r\n        }\r\n        result += sum % 10;\r\n        sum = Math.floor(sum / 10);\r\n        index--;\r\n    }\r\n    for(let i = result.length - 1; i >= 0; i--) {\r\n        resultArr.push(+result[i]);\r\n    }\r\n    return resultArr;\r\n};\r\n```\r\nTime Complexity：O(max(n,logk))\r\nSpace Complexity：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kwdfw":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086007092","body":"Day1\n\n[989、数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n#javascript\n## 思路\n1、类似现实中的加法题，取数组和数字的对应位相加并加上进位\n\n2、若相加和大于9，则用carry记录下进位为1\n\n3、算完一直就输入到数组中一位\n\n4、不断循环，从最后一位一直到第一位\n\n5、反转数组\n\n#### 处理特殊示例\n1、相加的结果比原来的位数多一位，如990+100=1090，需要在循环结束后单独判断再加一位\n\n2、数组的位数比数字的位数少，如0+23，按照循环会造成数组越界，需要加判断条件，越界就将值置为0\n## 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n    let carry=0//记录进位\n    let ru=[]//最终返回的数组\n    let i=num.length-1//循环计数器\n    let result//每一位的结果\n    while(i>-1||k!=0){//||条件保证任意位数的情况下都可以进入循环\n        const x= i>=0? num[i]:0//解决数组和数字位数不同的问题\n        const y=k!=0 ? k%10:0\n        result=x+y+carry//得到某位的值\n        if(result>9){//若大于9，则保留进位，并输入到数组中\n            carry=1\n            ru.push(result%10)\n        }\n        else{//若小于等于9，则不保留进位，并输入到数组中\n            carry=0\n            ru.push(result)\n        }\n        k=Math.floor(k/10)//下取整，有时会自动进位\n        i--//推进循环\n    }\n    if(carry==1) ru.push(1)//解决相加结果比原来多一位\n    return ru.reverse()//反转数组\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mozro0327":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086012990","body":"### lc989 数组形式的整数加法\n\n#### 解法一\n\n##### 思路\n\n+ 先将数组翻转\n+ 在将 k 全部加在数组最后一位上\n+ 计算数组最后一位的进位，并作为下一次运算的 k\n+ 直到 k 为 0 且 数组遍历完成\n+ 最后将数组重新翻转\n\n##### 代码实现\n\n~~~ c++\nclass Solution1 {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len = num.size();\n        reverse(num.begin(), num.end());\n\n        for (int i = 0; i < len; i++) {\n            num[i] += k;\n            k = num[i] / 10;\n            num[i] %= 10;\n        }\n\n        while (k > 0) {\n            num.push_back(k % 10);\n            k /= 10;\n        }\n\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\n~~~\n\n##### 复杂度\n\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(1)\n\n\n\n#### 解法二\n\n##### 思路\n\n+ 将数组和 k 逐位相加\n+ 计算进位，并加在 k 的下一位上\n+ 直到 k 为 0 且数组遍历完成\n\n##### 代码实现\n\n~~~ c++\nclass Solution2 {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len = num.size();\n        vector<int> result;\n\n        for (int i = len - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum > 9) {\n                k++;\n                sum -= 10;\n            }\n            result.push_back(sum);\n        }\n        while (k > 0) {\n            result.push_back(k % 10);\n            k /= 10;\n        }\n\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n~~~\n\n##### 复杂度\n\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christ36":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086018719","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n       List<Integer> res= new ArrayList<Integer>();\n       Integer n = num.length;\n       for(int i = n-1 ;i>=0||k>0;--i,k/=10)\n       {\n           if(i>=0)\n           {\n               k+=num[i];\n           }\n           res.add(k%10);\n       }\n       Collections.reverse(res);\n        return res;\n    }\n}\n\n思路：将整个加数 k 加入数组表示的数的最低位。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086021602","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sums = 0\n        for i,j in enumerate(num):\n            sums += j*10**(len(num)-i-1)\n        sums += k\n        ans = []\n        while sums:\n            temp = sums %10\n            sums = sums//10\n            ans.insert(0,temp)\n        return ans\n            \n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086548738","body":"```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        dic = []\n        for i,j in enumerate(s):\n            if j == c:\n                dic.append(i)\n        ans = []\n        \n        for i in range(len(s)):\n            temp = []\n            for j in dic:\n                temp.append(abs(j-i))\n            ans.append(min(temp))\n        return ans\n```\n                \n            ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lskong":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086022222","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& A, int K) {\n\n        vector<int> res;\n        res.reserve(A.size() + 5);\n\n        int i = A.size() - 1;\n        int carry = 0;\n\n        while (i >= 0 || K > 0)\n        {\n            int n1 = i >= 0 ? A.at(i) : 0;\n            int n2 = K > 0 ? K % 10 : 0;\n            int sum = n1 + n2 + carry;\n            carry = sum / 10;\n            res.push_back(sum % 10);\n            --i;\n            K /= 10;\n        }\n\n        if (carry)\n        {\n            res.push_back(1);\n        }\n\n        reverse(res.begin(), res.end());\n\n        return res;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mapo0102":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086022435","body":"思路：\n创建一个链表，获取数组长度\n逆序从最低位开始，进行链表的加和。\n完成加和后，判断k值是否完成，如果未完成，继续向链表头部加k值，然后k/10，消耗尽k的所有位数。\n\n代码：\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> res = new LinkedList<>();\n        int n = num.length;\n\n        for (int i = n - 1; i >= 0 ; i--) {\n            int sum = k%10 + num[i];\n            k = k / 10;\n            if(sum >= 10){\n                sum -= 10;\n                k++;\n            }\n            res.add(0,sum);\n        }\n        while(k>0){\n            res.add(0,k%10);\n            k=k/10;\n        }\n        return res;\n    }\n\n    }\n\n\n复杂度：\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiradaone":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086024431","body":"### 思路\n\n数组num转换为字符串与k相加后再转换为List\n\n### 代码\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        tostr = ''.join([str(i) for i in num])\n        res = str(int(tostr)+ k)\n        reslist = [int(i) for i in res]\n        return reslist\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，其中 n 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oneline-wsq":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086026979","body":"### 思路\n\n将num数组计算为一个数，然后再与k相加，最后再返回数组。\n\n### 代码\n\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n\n        sum1=0\n        n=len(num)\n        for i in range(n):\n            sum1=sum1+pow(10,n-i-1)*num[i]\n\n        sum2=sum1+k\n\n        return [int(x) for x in str(sum2)]\n```\n\n### 复杂度分析\n\nTime: O(n)\n\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuguang520-lab":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086037440","body":"##思路\n模拟加法运算，注意将数组反转\n\n##code\n```cpp\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {//判断是否有进位\n                k++;\n                sum -= 10;\n            }\n            res.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.push_back(k % 10);//判断k是否比数组的长度要长\n        }\n        reverse(res.begin(), res.end());\n        return res;\n```\n##复杂度分析\n- 实践复杂度O(n)\n- 空间复杂度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086037807","body":"# 思路：两次遍历，两次转换\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        array_num = 0\n        for i in range(n):\n            array_num += num[i] * (10 ** (n-i-1))\n        total = array_num + k\n        ans = []\n        for s in str(total):\n            ans.append(int(s))\n        return ans \n```\n时间复杂度:O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bruceleeqaq":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086039762","body":"思路:  模拟加法，先将数组转换成数字 再将结果转换为数组\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t\ti = len(num)-1\n        while k:\n            num[i] += k\n            k, num[i] = num[i]//10, num[i]%10\n            i -= 1\n            if i<0 and k:\n                num.insert(0,0)\n                i = 0 \n        return num\n\n\n复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zenwangzy":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086041856","body":"## 思路\n从最低位想相加开始计算起\n\n\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n## 复杂度\ntime O(N)\nspace O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liyubin117":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086054479","body":"思路在注释里\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        // 初始化参数\n        List<Integer> res = new ArrayList<Integer>();\n        int n = A.length;\n\n        // 1. 从后往前逐位相加\n        for(int i = n - 1;i >= 0;i--){\n            // 1.1 逐位相加\n            int sum = A[i] + K % 10;         // 每次重置sum\n            K /= 10;    \n            // 1.2 处理两位相加 进位的情况\n            if(sum >= 10){\n                K++;                        // 进位到K的末尾\n                sum -= 10;                  // 进位清掉\n            }\n            // 1.2 当前相加的结果 添加到结果集\n            res.add(sum);\n        }\n\n        // 2. K的数字长度大于数组的数字长度\n        for(;K > 0;K /= 10){                // 每次K左移一位\n            res.add(K % 10);                // 添加到结果集\n        }\n\n        // 3. 将结果集翻转即是所求答案\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n复杂度\n空间：O(N)\n时间：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"houyanlu":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086055675","body":"### 思路\n\n从最低位开始跟k的个位相加，大于10则进一位，\n\n\n### 代码\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> result;\n        int n = num.size();\n\n        // 从个位开始跟k的个位相加，大于10则进一位\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            result.push_back(sum);\n        }\n\n        // 最后剩下的k， 说明k是比原数组很大很大，应该是放在加和后的高位\n        for (; k > 0; k /= 10) {\n            result.push_back(k % 10);\n        }\n\n        std::reverse(result.begin(), result.end());\n\n        return result;\n    }\n};\n\n**复杂度分析**\n- 时间复杂度：O(N)，一次遍历\n- 空间复杂度：O(N) 同等大小的一个vector","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086056841","body":"### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n\t\tList<Integer> result = new ArrayList<>();\n\t\tfor(int i = num.length - 1; i >= 0; i--) {\n\t\t\tint temp = (num[i] + k) % 10;\n\t\t\tk = (k + num[i])/10;\n\t\t\tresult.add(temp);\n\t\t}\n\t\twhile(k!=0) {\n\t\t\tresult.add(k%10);\n\t\t\tk = k/10;\n\t\t}\n\t\tCollections.reverse(result);\n\t\treturn result;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"w-will":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086057669","body":"## Idea:\nGo through the num array, accumulate the sum of each digits. Then sum with k and convert into a list.\n\n## Code:\n'''\n\n\tclass Solution:\n\t\tdef addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t\t\tsumArr = 0\n\t\t\tfor i, e in enumerate(num[::-1]):\n\t\t\t\tsumArr += e if i == 0 else e * (10 ** i)\n\n\t\treturn map(int, list(str(sumArr + k)))\n'''\n\nTime: O(n)\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hohojii":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086058735","body":"##思路\n逐位相加\n##代码\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n##复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxjo":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086060234","body":"## 思路\nnum与k从右向左逐位相加，遇到进位则加到下一位上\n\n## 代码\n```\nvar addToArrayForm = function(num, k) {\n    let res = [];\n    for(let i = num.length - 1; i >= 0; i--){\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if(sum >= 10){\n            sum -= 10;\n            k += 1;\n        }\n        res.push(sum);\n    }\n    //解决k位数大于数组长度\n    while(k > 0){\n        res.push(k % 10);\n        k = Math.floor(k / 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n## 复杂度分析\n时间复杂度： O(max(num.length, lgk))  \n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ha0cheng":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086068703","body":"思路：\r\n实现数组形式的加法，逐位相加，保存进位\r\n\r\n代码：\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        Next= 0\r\n        p = len(num)- 1\r\n        while p>=0:\r\n            x = num[p]+k%10+Next\r\n            num[p] = x%10\r\n            Next = x//10\r\n\r\n            k//=10\r\n            p-=1\r\n            if k==0 and Next ==0:\r\n                break\r\n\r\n        while k>0 or Next>0:\r\n            x = k%10+Next\r\n            num.insert(0,x%10)\r\n            Next = x//10\r\n            k//=10\r\n        return num\r\n```\r\n\r\n\r\n\r\n复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086159354","body":"思路：\r\n遍历两遍，第一遍确定字符的位置，第二遍确定距离每个字符位置最近的字符区间，输出结果\r\n\r\n代码：\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        P = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n              P.append(i)\r\n        r = []\r\n        left = 0\r\n        for i in range(len(P)):\r\n            if i==len(P)-1:\r\n                right = len(s)-1\r\n            else:\r\n                right = (P[i]+P[i+1]-1)//2\r\n            j = P[i] - left \r\n            while j>0:\r\n                r.append(j)\r\n                j-=1\r\n            while j<=right-P[i]:\r\n                r.append(j)\r\n                j+=1\r\n        \r\n            left = right+1\r\n        \r\n        return r\r\n```\r\n时间复杂度：需要遍历两遍，每次均是原字符数组的长度，所以复杂度为O(N)\r\n空间复杂度：需要一个空间来存储字符位置，最坏情况下是N，复杂度为O(N)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joewx21":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086071168","body":"### 思路\n\n将k加到num的低位，大于10就取余留下个位，整除取出个位得到进位，每位循环直到最高位并且 k 为0或者i<0。如果 i 小于0，数字长度加一，再循环上过程。\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int i = num.size() - 1;\n        while(k > 0){\n            num[i] += k;\n            k = num[i] / 10;\n            num[i--] %= 10;\n            if(i < 0 && k > 0){\n                num.insert(num.begin(), 0);\n                i = 0;\n            }\n        }\n        return num;\n    }\n};\n```\n\n**复杂度分析**\n\\- 时间复杂度：O(n)\n\\- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zetavi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086072595","body":"## 思路\n\n从Num数组的**右侧开始往左遍历**数组,将遍历到的数**直接与K相加**,相加的结果取**最低位**插入到List输出链表的**头部**\n\n## 语言\n\nJava\n\n## 代码\n\n```java\npublic class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new LinkedList<>();\n        int i;\n        for (i = num.length - 1; k > 0 || i >= 0; k /= 10, i--) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            list.add(0, k % 10);\n        }\n        return list;\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:\t$O(max(num.length(),logK))$\n\n​\t\t\t\t\t\t\t时间复杂度跟输入Num的长度和K的位数有关,又因为List的插入时间复杂度为$O(1)$所以插入可以忽略不计.\n\n- 额外空间复杂度: $O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086074254","body":"### Idea\r\nLet carry = k; Add k with each digit of num form right to left, \r\nput units digit into res, update carry \r\nreverse res\r\n\r\n### Code\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int i = num.length - 1;\r\n        int carry = k;\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        while (i >= 0 || carry > 0) {\r\n            if (i >= 0) {\r\n                carry += num[i];\r\n            }\r\n            res.add(carry % 10);\r\n            carry /= 10;\r\n            i--;\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### Complexity\r\nTime: O(N)  N refers to the length of num. (reach each element once) \r\nSpace: O(1)  (no extra space except result)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raingolee":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086081768","body":"### 思路\n从低位开始（从右到左），两个位置的数相加，如果超过10，则增加一个标记位，下一个位置的数字相加之后加一，因为是不等长的，所以存在相同位置的数字为空时候则设置为0，切不需要设置标记位。\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"all-sunday":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086082274","body":"### 思路\n遍历数组，把k加到最后一个元素num[n]，把num[n]对10取余的余数加到结果res数组，对10取整后的结果重新赋给k；\n\n循环上一步操作倒数第二个元素，直至数组遍历完或k值不大于0，则把剩下的数组元素或k加到res数组;\n\n最后反转数组即可。\n\n\n### 代码\n\n\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        while(true){\n                if(n>0 && k>0){\n                    num[--n] += k;\n                    res.add(num[n] % 10);\n                    k = num[n] / 10;\n                }else if(n>0){\n                    res.add(num[--n]);\n                    \n                }else if(k>0){\n                    res.add(k%10);\n                    k /= 10;\n                    \n                }else{\n                    break;\n                }    \n\n            }\n            Collections.reverse(res);\n            return res;\n        }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(max(n,k))，其中 n 为数组长度，k为k的位数。\n- 空间复杂度：O(max(n,k))，开辟了新数组\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brainlds":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086082862","body":"public List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> result = new ArrayList<>();\n    int cur = k;\n    int i = num.length - 1;\n    while (i >= 0 || cur > 0) {\n        if (i >= 0) {\n            cur += num[i];\n        }\n        result.add(cur % 10);\n        cur /= 10;\n        i--;\n    }\n    Collections.reverse(result);\n    return result;\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinjin680":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086083587","body":"## 思路\n\n- 直接把k加到A中\n\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& A, int K) {\n        int i = A.size()-1;\n        while(K > 0){\n            A[i] += K;\n            K = A[i] / 10;\n            A[i--] %= 10;\n            \n            if(i < 0 && K > 0){\n                A.insert(A.begin(),0);\n                i = 0;\n            }\n        }\n        \n        return A;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hulichao":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086084672","body":"思路\n遍历数组，把k加到最后一个元素num[n]，把num[n]对10取余的余数加到结果res数组，对10取整后的结果重新赋给k；\n\n循环上一步操作倒数第二个元素，直至数组遍历完或k值不大于0，则把剩下的数组元素或k加到res数组;\n\n最后反转数组即可。\n\n代码\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        while(true){\n                if(n>0 && k>0){\n                    num[--n] += k;\n                    res.add(num[n] % 10);\n                    k = num[n] / 10;\n                }else if(n>0){\n                    res.add(num[--n]);\n                    \n                }else if(k>0){\n                    res.add(k%10);\n                    k /= 10;\n                    \n                }else{\n                    break;\n                }    \n\n            }\n            Collections.reverse(res);\n            return res;\n        }\n}\n复杂度分析\n\n时间复杂度：O(max(n,k))，其中 n 为数组长度，k为k的位数。\n空间复杂度：O(max(n,k))，开辟了新数组","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shin-guid":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086085454","body":"## 思路\r\n将A、K格式化为数组，反转，从低位开始相加，一直到最高位，注意处理进位\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const numArr = num.reverse();\r\n    const kArr = String(k).split('').reverse().map(Number);\r\n\r\n    let result = [];\r\n    let i = 0;\r\n    let curr = 0;\r\n    let carry = 0;\r\n    while(i < numArr.length || i < kArr.length || carry > 0) {\r\n        sum = (numArr[i] || 0) + (kArr[i] || 0) + carry;\r\n        curr = sum % 10;\r\n        carry = parseInt(sum / 10);\r\n        result[i] = curr;\r\n        i++;\r\n    }\r\n    return result.reverse();\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度O(N)\r\n- 空间复杂度O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086101381","body":"var addToArrayForm = function (num, k) {\r\n    let k_array = [];\r\n    let length_cal = 0;\r\n    let cal_array = [];\r\n    while (k > 0) {\r\n        let yu = k % 10;\r\n        k_array.unshift(yu);\r\n        k = (k - yu) / 10;\r\n    }\r\n\r\n    if (k_array.length < num.length) {\r\n        length_cal = num.length;\r\n        const len = k_array.length\r\n        for (let index = 0; index < length_cal - len; index++) {\r\n            k_array.unshift(0);\r\n        }\r\n    } else {\r\n        length_cal = k_array.length;\r\n        const len = num.length\r\n        for (let index = 0; index < length_cal - len; index++) {\r\n            num.unshift(0);\r\n        }\r\n    }\r\n\r\n    for (let index = 0; index < length_cal; index++) {\r\n        const m = num.pop();\r\n        const n = k_array.pop();\r\n        if (m + n >= 10) {\r\n            cal_array.unshift((m + n) % 10);\r\n            k_array[k_array.length - 1] = k_array[k_array.length - 1] + 1;\r\n            if (index === length_cal - 1) {\r\n                cal_array.unshift(1);\r\n            }\r\n        } else {\r\n            cal_array.unshift(m + n)\r\n        }\r\n    }\r\n\r\n    return cal_array;\r\n};\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nancychien":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086268399","body":"思路：\r\n1. 找出目標 index 位置並 save to a target list\r\n2. loop through 原來的字串和target list 並計算最小距離\r\n`\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        target = []\r\n        output = []\r\n\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                target.append(i)\r\n\r\n        for i in range(len(s)):\r\n            output.append(min(abs(i-x) for x in target))\r\n\r\n        return output\r\n`\r\n\r\nTime complexity: O(n^2)\r\nSpace complexity:O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lannyx":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086420045","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()]; //create new array to store answer\r\n        int dummy = Integer.MIN_VALUE/2; // initiate a variable as the min value to store \r\n\r\n        for(int i = 0; i < s.length(); i++){\r\n            if(s.charAt(i) == c) dummy = i;\r\n            res[i] = i - dummy;\r\n        }\r\n\r\n        dummy = Integer.MAX_VALUE;\r\n        for(int i = s.length() - 1; i >= 0; i--){\r\n            if(s.charAt(i) == c) dummy = i;\r\n            res[i] = Math.min(res[i], dummy - i);\r\n        }\r\n        return res;\r\n\r\n    }\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pureryudo":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086506715","body":"### 思路\n\n进行两次遍历\n\n使用prev记录上一次出现的c的位置，初始值设为极小的负数。\n\n第一次从左到右遍历，记录当前位置i到prev的绝对值。\n\n第二次从右到左遍历，记录当前位置i到prev的绝对值，并与第一次遍历的结果取min存入结果数组，\n\n### 代码\n\n```java\npublic int[] shortestToChar(String s, char c) {\n    int[] result = new int[s.length()];\n    char[] chars = s.toCharArray();\n    /*记录当前遍历中上一个c出现的位置\n        初始值设置为极小的负数用于在比较时获得正确的值*/\n    int prev = Integer.MIN_VALUE/2;\n    /*第一次遍历 从左到右 记录与上一个c的距离*/\n    for (int i = 0; i < chars.length; i++){\n        //还没有出现过c\n        if (chars[i] == c){\n            prev = i;\n        }\n        result[i] = Math.abs(i-prev);\n    }\n    /*第二次遍历 从右到左 记录与上一个c的距离*/\n    prev = -1;\n    for (int i = chars.length-1; i >= 0; i--){\n        if (chars[i] == c){\n            prev = i;\n        }\n        result[i] = Math.min(result[i],Math.abs(prev-i));\n    }\n    return result;\n}\n```\n\n### 复杂度分析\n\n时间复杂度：O(N) N为数组长度\n\n额外空间复杂度：O(N) 新建了一个长度为N的数组用于存放结果","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}