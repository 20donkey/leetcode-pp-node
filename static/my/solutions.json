{"372354984":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916976831","body":"### 思路\n\n从末位相加，取余留下尾数，剩下部分与下一位相加，直至 k 和 num 都用完\n\n### 代码\n\n```js\nconst addToArrayForm = function (num, k) {\n  const res = []\n  const n = num.length\n  for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\n    if (i >= 0) {\n      k += num[i]\n    }\n    res.push(k % 10)\n  }\n  res.reverse()\n  return res\n}\n\n```\n### 复杂度\n\n- 时间复杂度:O(Max(n,logk))\n- 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917430288","body":"### 思路\r\n\r\n- 首先要取得目标字符串的位置数组A\r\n- 遍历原目标字符串\r\n  - A数组只有一个，直接计算位置\r\n  - 否则计算前A数组两位中谁位置最近\r\n    - 判断A数组已经计算到第二位时，去掉第一位\r\n\r\n### 代码\r\n\r\n``` js\r\nlet shortestToChar = function(s, c) {\r\n  s = s.split('')\r\n  let cIdx = s.reduce((pre, item, idx) => {\r\n    if (item === c)pre.push(idx)\r\n    return pre\r\n  }, [])\r\n\r\n  let answer = []\r\n  s.reduce((pre, i, idx) => {\r\n    if (pre.length === 1) {\r\n      answer.push(Math.abs(pre[0] - idx))\r\n    } else {\r\n      answer.push(Math.min(Math.abs(pre[0] - idx), Math.abs(pre[1] - idx)))\r\n      if (idx >= pre[1])pre.shift()\r\n    }\r\n    return pre\r\n  }, cIdx)\r\n  return answer\r\n}\r\n\r\n```\r\n时间：n*k, n为字符串s的长度，k为c在s中出现的次数\r\n空间：k\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917661727","body":"### 思路\n用数组模拟\n\n### 代码\n\n```js\n\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.stack.length >= this.maxSize) {\n        return;\n    }\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    return this.stack.length > 0 ? this.stack.pop() : -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    let length = Math.min(k, this.stack.length);\n    for (let i = 0; i < length; i++) {\n        this.stack[i] += val;\n    }\n};\n\n```\n\n### 复杂度\n\n- 时间复杂度：O(1)push pop, O(n)inc\n- 空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"965682575":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916838838","body":"#### 思路\r\n\r\n​\t从数组的最后一位及k的个位开始计算，carry变量表示进位，将每次计算的sum值放入新的数组中，最后将数组倒置。\r\n\r\n​\t**注意**：两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在数组中\r\n\r\n#### 代码\r\n\r\n``` c++\r\npublic:\r\n\r\n vector<int> addToArrayForm(vector<int>& A, int K) {\r\n\r\n\tvector<int> res;\r\n\tint i = A.size() - 1;\r\n\tint carry = 0;\r\n\tint sum = 0;\r\n\t\r\n\twhile (i > -1 || K != 0) {\r\n        int x = i > -1 ? A[i] : 0;\r\n        int y = K != 0 ? (K % 10) : 0;\r\n        sum = x + y + carry;\r\n\r\n        carry = sum / 10;\r\n        sum %= 10;\r\n        i--;\r\n        K /= 10;\r\n        res.push_back(sum);\r\n    }\r\n\r\n\tif (carry) {\r\n\t\tres.push_back(carry);\r\n\t}\r\n\r\n\treverse(res.begin(), res.end());\r\n\treturn res;\r\n  }\r\n\r\n};\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：O(max(N, log k))\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ruohai0925":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916226878","body":"## 思路\r\n\r\n从个位开始加，用carry表示进位\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n# from typing import List\r\nfrom collections import deque\r\nclass Solution:\r\n    def addToArrayForm(self, A, K):\r\n        if K == 0:\r\n            return A\r\n\r\n        i = len(A) - 1\r\n        carry = 0\r\n\r\n        # d = []\r\n        d = deque()\r\n\r\n        while i >= 0 and K > 0:\r\n            temp = A[i] + carry + K % 10\r\n            #d.insert(0, temp % 10)\r\n            d.appendleft(temp % 10)\r\n            carry = temp // 10\r\n            K = K // 10\r\n            i -= 1\r\n\r\n        while i < 0 and K > 0:\r\n            temp = K % 10 + carry\r\n            #d.insert(0, temp % 10)\r\n            d.appendleft(temp % 10)\r\n            carry = temp // 10\r\n            K = K // 10\r\n\r\n        while i >= 0:\r\n            temp = A[i] + carry\r\n            #d.insert(0, temp % 10)\r\n            d.appendleft(temp % 10)\r\n            carry = temp // 10\r\n            i -= 1\r\n\r\n        if carry > 0:\r\n            #d.insert(0, carry)\r\n            d.appendleft(carry)\r\n\r\n        #return d\r\n        return list(d)\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917105068","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  正反遍历\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        n = len(S)\r\n        dis = 10001\r\n        res = []\r\n        for i in range(0, n):\r\n            if S[i] == C:\r\n                dis = 0\r\n            res.append(dis)\r\n            dis += 1\r\n\r\n        dis = 10001\r\n        for i in range(n - 1, -1, -1):\r\n            if S[i] == C:\r\n                dis = 0\r\n            res[i] = min(res[i], dis)\r\n            dis += 1\r\n        return res\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917499666","body":"\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.items = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.items) < self.maxSize:\r\n            self.items.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.items == []:\r\n            return -1\r\n        else:\r\n            # length = len(self.items)\r\n            # items_top = self.items[length - 1]\r\n            return self.items.pop()\r\n            # return items_top\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.items))):\r\n            self.items[i] += val\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\nTime and Space Complexity\r\nTime: O(1) for push and pop, O(Math.min(k, top + 1)) for increment\r\nSpace: O(MaxSize)\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917695283","body":"\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':  # 处理>10的数字\r\n                multi = multi * 10 + int(c)\r\n            else:\r\n                res += c\r\n        return res\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\nO(N)，循环体会从头到尾遍历s.length();\r\nO(N)，要维护一个栈；\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ImSingee":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916251691","body":"```rust\r\nimpl Solution {\r\n    pub fn add_to_array_form(num: Vec<i32>, mut k: i32) -> Vec<i32> {\r\n        let mut result = Vec::new();\r\n        for i in (0..num.len()).rev() {\r\n            result.push({\r\n                let result = num[i] + k;\r\n                let x = result % 10;\r\n                k = result / 10;\r\n                x\r\n            })\r\n        }\r\n\r\n        while k > 0 {\r\n            result.push({\r\n                let x = k % 10;\r\n                k = k / 10;\r\n                x\r\n            })\r\n        }\r\n\r\n        result.reverse();\r\n        result\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度 O(len(num)) [logk约等于1 忽略] \r\n额外空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917026640","body":"```go\r\nfunc min(a, b int) int {\r\n    if a < b { return a } else { return b}\r\n}\r\n\r\nfunc shortestToChar(s string, c byte) []int {\r\n    result := make([]int, len(s))\r\n\r\n    left := -20000\r\n    for i := 0; i < len(s); i++ {\r\n        cc := s[i]\r\n\r\n        if cc == c {\r\n            left = i\r\n        }\r\n\r\n        result[i] = i - left\r\n    }\r\n\r\n    right := 20000\r\n    for i := len(s) - 1; i >= 0; i-- {\r\n        cc := s[i]\r\n\r\n        if cc == c {\r\n            right = i\r\n        }\r\n\r\n        result[i] = min(right - i, result[i])\r\n    }\r\n\r\n\r\n    return result\r\n}\r\n```\r\n\r\n时间复杂度 O(len(s))\r\n额外空间复杂度 O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917430600","body":"### 解法一：BF\r\n\r\nincrement 的时间复杂度 O(k)\r\n\r\n```rust\r\nstruct CustomStack {\r\n    elements: Vec<i32>,\r\n    maxSize: usize,\r\n}\r\n\r\nimpl CustomStack {\r\n    fn new(maxSize: i32) -> Self {\r\n        CustomStack{\r\n            elements: Vec::new(),\r\n            maxSize: maxSize as usize,\r\n        }\r\n    }\r\n    \r\n    fn push(&mut self, x: i32) {\r\n        if self.elements.len() < self.maxSize {\r\n            self.elements.push(x)\r\n        }\r\n    }\r\n    \r\n    fn pop(&mut self) -> i32 {\r\n        self.elements.pop().unwrap_or(-1)\r\n    }\r\n    \r\n    fn increment(&mut self, k: i32, val: i32) {\r\n        let k = std::cmp::min(k as usize, self.elements.len());\r\n        \r\n        for i in 0..k {\r\n            *(self.elements.get_mut(i).unwrap()) += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 解法二：前缀和思想\r\n\r\nincrement 的时间复杂度 O(1)\r\n\r\n```rust\r\nstruct CustomStack {\r\n    elements: Vec<i32>,\r\n    increments: Vec<i32>,\r\n    maxSize: usize,\r\n}\r\n\r\nimpl CustomStack {\r\n    fn new(maxSize: i32) -> Self {\r\n        CustomStack{\r\n            elements: Vec::new(),\r\n            increments: Vec::new(),\r\n            maxSize: maxSize as usize,\r\n        }\r\n    }\r\n    \r\n    fn push(&mut self, x: i32) {\r\n        if self.elements.len() < self.maxSize {\r\n            self.elements.push(x);\r\n            self.increments.push(0);\r\n        }\r\n    }\r\n    \r\n    fn pop(&mut self) -> i32 {\r\n        if let Some(inc) = self.increments.pop() {\r\n            if !self.increments.is_empty() {\r\n                *(self.increments.last_mut().unwrap()) += inc;\r\n            }\r\n\r\n            self.elements.pop().unwrap() + inc\r\n        } else {\r\n            -1\r\n        }\r\n    }\r\n    \r\n    fn increment(&mut self, k: i32, val: i32) {\r\n        if !self.increments.is_empty() {\r\n            let k = std::cmp::min(k as usize, self.increments.len());\r\n            self.increments[k - 1] += val;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917662104","body":"简单粗暴利用栈完成\r\n\r\n```rust\r\nimpl Solution {\r\n    pub fn decode_string(s: String) -> String {\r\n        let mut result = \"\".to_string();\r\n        let mut numbers: Vec<usize> = Vec::new();\r\n        let mut letters: Vec<String> = Vec::new();\r\n\r\n        let mut i = 0;\r\n        while i < s.len() {\r\n            let c = s.bytes().nth(i).unwrap() as char;\r\n\r\n            if c.is_ascii_alphabetic() {\r\n                let s = Solution::scan_letter(&s, &mut i);\r\n\r\n                if let Some(last) = letters.last_mut() {\r\n                    *last += &s;\r\n                } else {\r\n                    result += &s;\r\n                }\r\n                \r\n                continue;\r\n            }\r\n\r\n            if c.is_ascii_digit() {\r\n                let n = Solution::scan_number(&s, &mut i);\r\n                numbers.push(n);\r\n                continue;\r\n            }\r\n\r\n            if c == '[' {\r\n                letters.push(\"\".to_string());\r\n                i += 1;\r\n                continue;\r\n            }\r\n\r\n            if c == ']' {\r\n                let part = letters.pop().unwrap().repeat(numbers.pop().unwrap());\r\n\r\n                if let Some(last) = letters.last_mut() {\r\n                    *last += &part;\r\n                } else {\r\n                    result += &part;\r\n                }\r\n                \r\n                i += 1;\r\n                continue;\r\n            }\r\n\r\n            panic!(\"unknown char {}\", c);\r\n        }\r\n\r\n        result\r\n    }\r\n\r\n    fn scan_letter(s: &str, i: &mut usize) -> String {\r\n        let mut result = \"\".to_string();\r\n\r\n        while *i < s.len() {\r\n            let c = s.bytes().nth(*i).unwrap() as char;\r\n\r\n            if c.is_ascii_alphabetic() {\r\n                result.push(c);\r\n                *i += 1;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        result\r\n    }\r\n\r\n    fn scan_number(s: &str, i: &mut usize) -> usize {\r\n        let mut result = 0;\r\n\r\n        while *i < s.len() {\r\n            let c = s.bytes().nth(*i).unwrap() as char;\r\n\r\n            if let Some(n) = c.to_digit(10) {\r\n                result = 10 * result + (n as usize);\r\n                *i += 1;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        result\r\n    }\r\n}\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/11208082/132994383-2cd05f26-0253-4de8-999a-dbdf6cf5a588.png)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lilyzhaoyilu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916253690","body":"### 思路\r\n按照官方题解\r\n\r\n### CPP代码\r\n```Cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int n = num.size();\r\n        for(int i = n - 1; i >= 0; --i){\r\n            int curSum = num[i] + k % 10;\r\n            k /= 10;\r\n            if(curSum >= 10){\r\n                k++;\r\n                curSum -=10;\r\n            }\r\n            res.push_back(curSum);\r\n        }\r\n        while(k > 0){\r\n            res.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n + logk + resLength)，其中 n 为数组的长度；resLength是res这个vector的长度，来自于reverse的时间消耗\r\n- 空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917310692","body":"#### 思路 \r\nIterate twice: from the left and from the right. While interating, keep track of the distance between the current char to the target char. In the response vector, update the distance if the current distance is smaller. Simiar to Dijkstra.\r\n\r\n#### 代码 CPP\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        //明天就能和城仔打游戏了哦耶(＾－＾)V\r\n        //res has to have a placeholder to use index\r\n        vector<int> res(s.size(), s.size() + 1);\r\n        int targetDistance = s.size() + 1;\r\n        //iterate through the left side\r\n        for(int i = 0; i < s.size(); i++){\r\n            \r\n            if(s[i] == c){\r\n                targetDistance = 0;\r\n            }else{\r\n                targetDistance++;\r\n            }\r\n\r\n            if(res[i] > targetDistance){\r\n                res[i] = targetDistance;\r\n            }\r\n        }\r\n\r\n        targetDistance = s.size() + 1;\r\n\r\n        //iterate through the right side\r\n        for(int i = s.size() - 1; i >= 0; i--){\r\n            \r\n            if(s[i] == c){\r\n                targetDistance = 0;\r\n            }else{\r\n                targetDistance++;\r\n            }\r\n            if(res[i] > targetDistance){\r\n                res[i] = targetDistance;\r\n            }\r\n\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n时间复杂度：O(n) n is the length of s    \r\n空间复杂度：O(1) constants","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917549437","body":"今天是跟城仔和Fleta打游戏所以并不想好好写题的一天，啊打游戏真开心~\n官方题解\n```cpp\nclass CustomStack {\npublic:\n    vector<int> stack, add;\n    int top;\n    CustomStack(int maxSize) {\n        stack.resize(maxSize);\n        add.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top != stack.size() - 1){\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    int pop() {\n        if(top == -1){\n            return -1;\n        }\n        int ret = stack[top] + add[top];\n        if(top != 0){\n            add[top - 1] += add[top];\n        }\n        add[top] = 0;\n        --top;\n        return ret;\n\n    }\n    \n    void increment(int k, int val) {\n        int lim = min(k - 1, top);\n        if(lim >= 0){\n            add[lim] += val;\n        }\n    }\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Dana-Dai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916255452","body":"## 思路\n直接对数组操作，但要注意进位，尤其是K > A的情况，要在数组开头插入以进位\n\n## 语言\ncpp\n\n## 代码\n···\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        //把K直接加到数组num上\n        int len = num.size() - 1;\n        while (k > 0) {\n            num[len] += k;\n            k = num[len] / 10;\n            num[len] %= 10;\n            len --;\n\n            if (len < 0 && k > 0) {\n                num.insert(num.begin(), 0);\n                len = 0;\n            }\n        }\n        return num;\n    }\n};\n```\n## 复杂度分析\n时间复杂度：$O（N）$即需要遍历一遍数组，故为N\n空间复杂度：$O（1）$不需要额外开辟空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917348700","body":"# 中心拓展法\n## 思路\n遍历字符串s，以字符串每个节点为中心，向两边遍历，更新距离\n## 代码\n~~~\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        //中心拓展法，以每个节点为中心，分别相前向后遍历\n        int len = s.length();\n        vector<int> answer(len);\n\n        for (int i = 0; i < len; i ++) {\n            if (s[i] == c) continue;\n            int l = i, r = i;\n            int dist = 0;\n\n            while (l >= 0 || r <= len - 1) {\n                if (s[l] == c) {\n                    dist = i - l;\n                    break;\n                }\n\n                if (s[r] == c) {\n                    dist = r - i;\n                    break;\n                }\n\n                if (l > 0) l --;\n                if (r < len - 1) r ++;\n            }\n            answer[i] = dist;\n        }\n\n        return answer;\n    }\n};\n~~~\n时间复杂度：O（N^2）遍历两遍数组\n\n# 左右搜索法\n## 思路\n从左到右更新一遍距离，遇到c即为0，从右向左更新一遍距离，遇到对每个节点的距离进行覆盖\n## 代码\n~~~\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int len = s.length();\n        vector<int> dist(len, len);\n        //从左向右遍历，遇到c即为0，不断更新距离\n        for (int i = 0; i < len; i ++) {\n            if (s[i] == c) dist[i] = 0;\n            else if (i > 0) dist[i] = dist[i - 1] + 1;\n        }\n\n        //从右向左遍历，再次更新距离\n        for (int i = len - 1; i >= 0; i --) {\n            if (dist[i] == len || (i < len - 1 && dist[i + 1] + 1 < dist[i]))\n                dist[i] = dist[i + 1] + 1;\n        }\n\n        return dist;\n    }\n};\n~~~\n时间复杂度：O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917439877","body":"## 思路\n用数组实现\n## 代码\n~~~\nclass CustomStack {\nprivate:\n    int ans[1000];\n    int size;\n    int top;\npublic:\n    CustomStack(int maxSize) {\n        size = maxSize;\n        top = 0;\n    }\n    \n    void push(int x) {\n        if (top < size) \n            ans[top ++] = x;\n    }\n    \n    int pop() {\n        if (top > 0) return ans[-- top];\n        else return -1;\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0, num = min(k, top); i < num; i ++)\n            ans[i] += val;\n    }\n};\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917764935","body":"~~~\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res = \"\";\n        stack<string> strs;\n        stack<int> nums;\n        int num = 0;\n        for (int i = 0; i < s.size(); i ++) {\n            if (s[i] >= '0' && s[i] <= '9')\n                num = s[i] - '0' + num * 10;\n            else if (s[i] == '[') {\n                nums.push(num);\n                num = 0;\n                strs.push(res);\n                res = \"\";\n            }\n            else if (s[i] >= 'a' && s[i] <= 'z') \n                res = res + s[i];\n            else {\n                int cur = nums.top();\n                nums.pop();\n                for (int i = 0; i < cur; i ++) \n                    strs.top() += res;\n                res = strs.top();\n                strs.pop();\n            }\n        }\n        return res;\n    }\n};\n~~~\n时间复杂度和空间复杂度均要遍历一遍s，即O（N）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"last-Battle":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916257585","body":"## 思路\n\n## 关键点\n\n-  从个位开始往前面推算，每计算一位就放入vector结果中，并通过carry维护进位，最后再反转\n- 注意数组下标和k的位数要保证有效，防止越界\n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int carry = 0, len = num.size() - 1;\n        int tmparr = 0, tmpk = 0, sum = 0;\n        int i = len;\n        while (i >= 0 || k != 0) {\n            tmparr = 0;\n            tmpk = 0;\n            if (k != 0) {\n                tmpk = k % 10;\n                k /= 10;\n            }\n            if (i >= 0) {\n                tmparr = num[i];\n                --i;\n            }\n\n            sum = tmparr + tmpk + carry;\n            carry = sum / 10;\n            res.emplace_back(sum % 10);    \n        }\n        \n        if (carry) {\n            res.emplace_back(carry);\n        }\n\n        reverse(res.begin(), res.end());\n\n        return res;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917416457","body":"## 思路\n\n## 关键点\n\n-  双指针，每个下标分别往前后两个方向遍历直到找到第一个期待的c为止，找不到就认为距离最大\n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> res(s.length(), 0);\n        for (int i = 0; i < s.length(); ++i) {\n            int start = i - 1, end = i + 1;\n            int ts = INT_MAX, te = INT_MAX;\n            if (s[i] == c) {\n                res[i] = 0;\n            } else {\n                while (start >= 0 && s[start] != c) {\n                    --start;\n                }\n                ts = start < 0 ? ts : abs(i - start);\n\n                while (end < s.length() && s[end] != c) {\n                    ++end;\n                }\n                te = end >= s.length() ? te : abs(i - end);\n\n                res[i] = min(ts, te);\n            }\n        }\n\n        return res;\n    }\n};\n\n```\n\n\n## 复杂度分析\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917434217","body":"## 思路\n\n## 关键点\n\n-  使用一个辅助栈进行模拟操作\n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        size = maxSize;\n    }\n    \n    void push(int x) {\n        if (realst.size() < size) {\n            realst.push(x);\n        }\n    }\n    \n    int pop() {\n        if (realst.empty()) {\n            return -1;\n        }\n\n        auto res = realst.top();\n        realst.pop();\n        return res;\n    }\n    \n    void increment(int k, int val) {\n        while (realst.size() > k) {\n            helperst.push(realst.top());\n            realst.pop();\n        }\n\n        while (!realst.empty()) {\n            helperst.push(realst.top() + val);\n            realst.pop();\n        }\n\n        while (!helperst.empty()) {\n            realst.push(helperst.top());\n            helperst.pop();\n        }\n    }\n\nprivate:\n    int size;\n    stack<int> realst;\n    stack<int> helperst;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n\n```\n\n\n## 复杂度分析\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mm12344":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916262628","body":"## 思路\r\n简单数值解法\r\n## 代码\r\n\r\n```py3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        x = 0\r\n        ans=[]\r\n        if len(num)==1 and num[0]==0 and k==0: return[0]\r\n        for i in num:\r\n            x = x*10 + i\r\n        x = x + k\r\n        while x!=0:\r\n            ans.append(x%10)\r\n            x=x//10\r\n        return ans[::-1]\r\n```\r\n\r\n## 复杂度\r\n时间：O(2n)\r\n空间：O(ans)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917430027","body":"## 思路\r\n\r\n思路一 找到每一个c的位置，构成一个数组cIdx\r\n遍历字符串，每个下标i处在数组内容中找一个离i最近的数，并返回i-数的绝对值 min(abs(i*len(cidx)-cI’d))\r\n\r\n## 代码\r\n```py3\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        cidx= [i for i in range(len(s)) if s[i]==c]\r\n        return [min(abs(i-j) for j in cidx) for i in range(len(s))]\r\n```\r\n## 复杂度\r\n时间：n*k, n为字符串s的长度，k为c在s中出现的次数\r\n空间：k","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917661759","body":"## 代码\r\n```py3\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n        self.delta = []\r\n        self.len = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.len < self.maxSize:\r\n            self.stack.append(x)\r\n            self.delta.append(0)\r\n            self.len += 1\r\n\r\n    def pop(self) -> int:\r\n        if not self.len:\r\n            return -1\r\n        self.len -= 1\r\n        a = self.stack.pop()\r\n        d = self.delta.pop()\r\n        if self.len:\r\n            self.delta[-1] += d\r\n        return a + d\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if not self.len:\r\n            return\r\n        if self.len < k:\r\n            self.delta[-1] += val\r\n        else:\r\n            self.delta[k - 1] += val\r\n```\r\n\r\n## 复杂度\r\n时间o1\r\n空间o(maxsize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzehan123":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916267006","body":"\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> ans = new LinkedList<>();\n        int temp=0;\n        for (int i = num.length-1; i >=0 ; i--) {\n            temp = k%10;\n            k/=10;\n            if (temp+num[i]>=10){\n                k++;\n                ans.addFirst((temp+num[i])%10);\n            }else {\n                ans.addFirst(temp+num[i]);\n            }\n            if (i==0){\n                while (k>0){\n                    temp = k%10;\n                    k/=10;\n                    ans.addFirst(temp);\n                }\n            }\n        }\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(max(n,logk))$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917310599","body":"\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\npublic int[] shortestToChar(String s, char c) {\n        int l = Integer.MIN_VALUE + s.length() + 1;\n        int r = s.indexOf(c);\n        int[] res = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            if (i <=  r){\n                res[i] = Math.min(i - l, r - i);\n            }else {\n                l = r;\n                r = s.indexOf(c, l + 1) == -1 ? Integer.MAX_VALUE : s.indexOf(c, l + 1);\n                res[i] = Math.min(i - l, r - i);\n            }\n        }\n        return res;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917445738","body":"\n## 思路\n\n数组模拟\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass CustomStack {\n\n    int[] data;\n    int head;\n\n    public CustomStack(int maxSize) {\n\n        data = new int[maxSize];\n        head = -1;\n    }\n    \n    public void push(int x) {\n\n        if (head == data.length - 1)\n            return;\n            \n        data[++head] = x;\n    }\n    \n    public int pop() {\n\n        if (head == -1)\n            return -1;\n\n        return data[head--];\n    }\n    \n    public void increment(int k, int val) {\n\n        for (int i = 0; i < Math.min(k, head + 1); i++)\n            data[i] += val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917703878","body":"\n\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    int index = 0;\n    public String decodeString(String s) {\n        // write your code here\n        if (s.length() == 0) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        int repeat = 0;\n\n        while (index < s.length()) {\n            char c = s.charAt(index);\n            if (c == '[') {\n                index++;\n                String sub = decodeString(s);\n                for (int i = 0; i < repeat; i++) {\n                    sb.append(sub);\n                }\n                repeat = 0;\n                index++;\n            } else if (c == ']') {\n                return sb.toString();\n            } else if (Character.isDigit(c)) {\n                repeat = repeat * 10 + c - '0';\n                index++;\n            } else {\n                sb.append(c);\n                index++;\n            }\n        }\n\n        return sb.toString();\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erik7777777":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916274001","body":"## 思路 \n从低位往高位顺着加\n### 代码 ： java\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        int carry = 0;\n        List<Integer> res = new ArrayList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0) {\n            int cur = (i >= 0 ? num[i] : 0) + (k > 0 ? k % 10 : 0) + carry;\n            k = k > 0 ? k / 10 : 0;\n            i = i >= 0 ? i - 1 : -1;\n            carry = cur / 10;\n            cur = cur % 10;\n            res.add(cur);\n        }\n        if (carry == 1) res.add(carry);\n        Collections.reverse(res);\n        return res;\n    }\n```\n\n### 复杂度分析\n - 时间复杂度：O(n)，其中 n 为数组的长度\n - 空间复杂度：O(1)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yachtcoder":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916275711","body":"\n从低到高递归处理每一位以及前面的进位\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num = num[::-1]\n        k = [int(x) for x in str(k)][::-1]\n        ret = []\n        def add1(l1, l2, carry, idx):\n            nonlocal ret\n            if carry == 0 and idx >= len(l1) and idx >= len(l2): return\n            n1 = 0 if idx >= len(l1) else l1[idx]\n            n2 = 0 if idx >= len(l2) else l2[idx]\n            ret.append((n1+n2+carry) % 10)\n            carry = (n1+n2+carry)//10\n            add1(l1, l2, carry, idx+1)\n        add1(num, k, 0, 0)\n        return ret[::-1]\n```\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917022162","body":"两次遍历 左到右然后右到左\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n\r\n        ans = [0]*len(s)\r\n        lastc = float('inf')\r\n        for i, ch in enumerate(s):\r\n            if ch == c:\r\n                ans[i] = 0\r\n                lastc = i\r\n            else:\r\n                ans[i] = abs(lastc - i)\r\n        for i in range(len(s)-1, -1, -1):\r\n            ch = s[i]\r\n            if ch == c:\r\n                ans[i] = 0\r\n                lastc = i\r\n            else:\r\n                ans[i] = min(ans[i], abs(lastc - i))\r\n        return ans\r\n```\r\nTime: O(n)\r\nSpace: Constant with O(n) for answer","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917477476","body":"Use a deque to pop and append from the left side. And a helper stack to temporarily hold the *k* popped item.\nTime O(n) for inc, O(1) for push/pop\nSpace O(n)\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.stack = deque()\n        self.max = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        return self.stack.pop() if self.stack else -1\n\n    def increment(self, k: int, val: int) -> None:\n        helper = []\n        while k > 0 and self.stack:\n            helper.append(self.stack.popleft())\n            k -= 1\n        while helper:\n            self.stack.appendleft(helper.pop()+val)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917682104","body":"Use a stack to process every pair of brackets. \nTokenization is a bit hacky. Processing each char might be more concise.\nTime: O(n^2) because even though each char is processed once, manipulating the string is O(n) each time.\nSpace: O(n)\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        toks = []\n        s = list(s)\n        for i in range(1, len(s)):\n            prev = s[i-1]\n            if prev[-1].isalpha() != s[i][0].isalpha():\n                s[i]= \" \"+s[i]\n        s = ''.join(s).replace(\"[\", \" [ \").replace(\"]\", \" ] \")\n        for t in s.split():\n            if t == \"]\":\n                st = \"\"\n                n = 0\n                while stack:\n                    c = stack.pop()\n                    if c == \"[\": break\n                    st = c+st\n                n = int(stack.pop())\n                stack.append(st*n)\n            else:\n                stack.append(t)\n        return ''.join(stack)\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chang-you":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916277083","body":"## 代码\r\nJava:\r\n\r\n```java\r\n// Space = O(n) / O(1) 数组/k长度\r\n// Time = O(Math.max(n, log(k)) / O(1): num或k长度中较大的\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //用LinkedList不断从头将位数和加入index 0\r\n        List<Integer> res = new LinkedList<>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            //从末尾往前扫，加和取余的值\r\n            res.add(0, (num[i] + k) % 10);\r\n            //更新k存进位carry\r\n            k = (num[i] + k) / 10;\r\n        }\r\n        \r\n        // post-possing: 处理k位数大于num的情况剩下的部分\r\n        // Time = O(log(k))\r\n        while (k > 0) {\r\n            res.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n##  复杂度分析\r\nSpace = O(n) / O(1) ：数组/k长度\r\n\r\nTime = O(Math.max(n, log(k)) / O(1): num或k长度中较大的","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917052225","body":"## 思路\r\n\r\n我们要找到左右最短距离，所以从左右两边都要分别遍历一遍，比较更新取二者较小值。\r\n\r\n## 关键点 \r\npos初始值的initialize。  \r\n由于我们要取最小值，所以要取一个较大数的初始值，  \r\n因为`res[i] = i - pos`，所以pos如果initialize为Integer MIN_VALUE, i-Integer MIN_VALUE会越界。  \r\n如果取Integer MAX_VALUE，最小值始终会是这个。  \r\n所以我们取数组长度的最大值稍大的即可，即-s.length();\r\n\r\n## 代码\r\nJava\r\n```java\r\n// Time = O(n)\r\n// Space = O(n)\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int n = S.length();\r\n        int[] res = new int[n];\r\n        int pos = -n;\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S.charAt(i) == C) {\r\n                pos = i;\r\n            }\r\n            res[i] = i - pos;\r\n        }\r\n\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (S.charAt(i) == C) {\r\n                pos = i;\r\n            }\r\n            res[i] = Math.min(res[i], Math.abs(i - pos));\r\n        }\r\n\r\n        return res;\r\n\r\n    }\r\n}\r\n```\r\n## 复杂度\r\nTime=O(n) 左右两个for loop \r\n\r\nSpace=O(n) 开辟String长度的数组。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917484844","body":"## 思路\n数组模拟栈 \n\n## Java代码\n\n```java\nclass CustomStack {\n    int max;\n    int[] increStack;\n    int idx;\n    \n    public CustomStack(int maxSize) {\n        increStack = new int[maxSize];\n        max = maxSize;\n        idx = 0;\n    }\n    \n    public void push(int x) {\n        if (idx == max) {\n            return;\n        } \n        increStack[idx++] = x;\n    }\n    \n    public int pop() {\n        if (idx == 0) {\n            return -1;\n        }\n        return increStack[--idx];\n    }\n    \n    public void increment(int k, int val) {\n        k = Math.min(k, idx);\n        for(int i = 0; i < k; i++) {\n            increStack[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\n## 复杂度\nSpace: O(n)   \nTime: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917712493","body":"## 思路\n递归模型\n每次递归遇到\"]“终止，ans记录返回的string, end 记录s的终止位置。\n\n## java code\n```java\nclass Solution {\n    public String decodeString(String s) {\n        char[] str = s.toCharArray();\n\t\treturn process(str, 0).ans;\n\t}\n\n\tpublic static class Info {\n\t\tpublic String ans;\n\t\tpublic int end;\n\n\t\tpublic Info(String a, int e) {\n\t\t\tans = a;\n\t\t\tend = e; // 哪个位置停\n\t\t}\n\t}\n\n\t// s[i....]  何时停？遇到   ']'  或者遇到 s的终止位置，停止\n\t// 返回Info (包含ans(返回的string) 和 end(算到了哪))\n\tpublic static Info process(char[] s, int i) {\n\t\tStringBuilder ans = new StringBuilder();\n\t\tint times = 0;\n\t\twhile (i < s.length && s[i] != ']') {\n\t\t\tif ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z')) {\n\t\t\t\tans.append(s[i++]);\n\t\t\t} else if (s[i] >= '0' && s[i] <= '9') {\n                //遇到数字 更新times\n\t\t\t\ttimes = times * 10 + s[i++] - '0';\n\t\t\t} else { // str[index] = '['\n\t\t\t\tInfo next = process(s, i + 1);\n\t\t\t\tans.append(timesString(times, next.ans));\n\t\t\t\ttimes = 0;\n\t\t\t\ti = next.end + 1;\n\t\t\t}\n\t\t}\n\t\treturn new Info(ans.toString(), i);\n\t}\n\n\tpublic static String timesString(int times, String str) {\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor (int i = 0; i < times; i++) {\n\t\t\tans.append(str);\n\t\t}\n\t\treturn ans.toString();\n\t}\n}\n\n```\n\n## 复杂度\nTime = O(n)  \nSpace = O(n)  \nn为String长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mmboxmm":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916278377","body":"## 思路\nAddition from right to left\n\n## 代码\n\n```Kotlin\nfun addToArrayForm(num: IntArray, k: Int): List<Int> {\n  val res = mutableListOf<Int>()\n  var carry = 0\n  var index = num.size - 1\n  var tmp = k\n\n  while (index >= 0 || tmp > 0 || carry > 0) {\n    var sum = carry\n    if (index >= 0) sum += num[index--]\n    if (tmp > 0) sum += tmp % 10\n\n    res.add(sum % 10)\n\n    carry = sum / 10\n    tmp /= 10\n  }\n  return res.reversed()\n}\n```\n\n## 复杂度分析\n- Time：O(len(num))\n- Space：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917097521","body":"## 思路\nScan the string twice, from left and from right. Update the min.\n\n## 代码\n\n```Kotlin\nfun shortestToChar(s: String, c: Char): IntArray {\n  val res = IntArray(s.length) { s.length }\n  var last = -1\n  for ((index, ch) in s.withIndex()) {\n    if (ch == c) {\n      last = index\n      res[index] = 0\n    } else if (last != -1) {\n      res[index] = index - last\n    }\n  }\n\n  last = -1\n  for (index in res.size - 1 downTo 0) {\n    if (res[index] == 0) {\n      last = index\n    } else if (last != -1) {\n      res[index] = minOf(res[index], last - index)\n    }\n  }\n  return res\n}\n```\n\n## 复杂度\n- Time: O(n)\n- Space: O(1), no extra space.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917448490","body":"## 思路\nArrayList is always better than LinkedList\n\n## 代码\n\n```Kotlin\nclass CustomStack(private val maxSize: Int) {\n  private val list = mutableListOf<Int>()\n\n  fun push(x: Int) {\n    if (list.size < maxSize) list.add(x)\n  }\n\n  fun pop(): Int = list.removeLastOrNull() ?: -1\n\n  fun increment(k: Int, v: Int) = (0 until minOf(list.size, k)).forEach {\n    list[it] += v\n  }\n}\n```\n## 复杂度分析\n- push/pop: O(1)\n- inc: O(min(k, size))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917717449","body":"## 思路\n分为四种类型，数字，字符串，[ 和 ]。 前三种压栈，最后一个出栈。感觉很笨，需要学习一下！\n\n## 代码\n```Kotlin\nfun decodeString(s: String): String {\n  if (s.isBlank()) return s\n\n  val stack = ArrayDeque<String>()\n  var i = 0\n  while (i < s.length) {\n    if (s[i].isDigit()) {\n      val start = i\n      while (++i < s.length && s[i].isDigit()) {\n      }\n      stack.addLast(s.substring(start, i))\n    } else if (s[i].isLetter()) {\n      val start = i\n      while (++i < s.length && s[i].isLetter()) {\n      }\n      stack.addLast(s.substring(start, i))\n    } else if (s[i] == '[') {\n      stack.addLast(\"[\")\n      i++\n    } else {\n      val sb = StringBuilder()\n      while (stack.isNotEmpty() && stack.last() != \"[\") {\n        sb.insert(0, stack.removeLast())\n      }\n      stack.removeLast()\n      val freq = stack.removeLast().toInt()\n      stack.addLast(sb.repeat(freq))\n      i++\n    }\n  }\n  val res = StringBuilder()\n  while (stack.isNotEmpty()) {\n    res.insert(0, stack.removeLast())\n  }\n  return res.toString()\n}\n```\n\n## 复杂度分析\n- Time: O(len(s))\n- Space: O(len(s))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangwiitao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916281347","body":"#### JS\n\n```js\nvar addToArrayForm = function (num, k) {\n    const ret = [];\n    let i = num.length - 1, carry = 0;\n    while (i >= 0 || k != 0) {\n        let x = i >= 0 ? num[i] : 0;\n        let y = k !== 0 ? k % 10 : 0;\n\n        const sum = x + y + carry;\n\n        ret.push(sum % 10);\n        carry = Math.floor(sum / 10);\n\n        i--;\n        k = Math.floor(k / 10);\n    }\n    if (carry) {\n        ret.push(carry);\n    }\n    return ret.reverse();\n};\n```\n#### 复杂度分析\n- 时间复杂度：O（n），再具体不会了\n- 空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917418388","body":"#### 思路\n遍历每个字符，从两边扩散，计算最小的值\n\n#### 代码\n\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n    const newArr = Array(s.length).fill(0);\n\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === c) continue;\n        let l = i;\n        let r = i;\n        let distance = Infinity;\n        while (l >= 0) {\n            if (s[l] === c) {\n                distance = Math.min(distance, i - l);\n                break;\n            }\n            l--\n        }\n        while (r < s.length) {\n            if (s[r] === c) {\n                distance = Math.min(distance, r - i);\n                break;\n            }\n            r++;\n        }\n        newArr[i] = distance;\n    }\n    return newArr;\n};\n\n```\n\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917438071","body":"#### 思路\n用数组模拟\n#### 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.stack.length >= this.maxSize) {\n        return;\n    }\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    return this.stack.length > 0 ? this.stack.pop() : -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    let length = Math.min(k, this.stack.length);\n    for (let i = 0; i < length; i++) {\n        this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n- 时间复杂度：O(1)push pop, O(n)inc\n- 空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916284826","body":"# LC989. Add to Array-Form of Integer\r\n## Main Idea\r\nFirst, it looks like we can convert the array `num` to integer and add it to `k`, but `num.length <= 1E+4` so this approach will cause integer overflow. So we will have to do the addition in array form.\r\n\r\nThen the idea is to simulate the entire process, add each digit of `num` and `k` with a `carry` bit. We will terminate the loop when we run out of digits for both `num` and `k` and `carry == 0`.\r\n\r\n## Code\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n = num.length, carry = 0, i = n - 1;\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        while (i >= 0 || k > 0 || carry > 0) {\r\n            int kDigit = k % 10;\r\n            k /= 10;\r\n            int sum = i >= 0 ? carry + kDigit + num[i] : carry + kDigit;\r\n            res.add(sum % 10);\r\n            carry = sum >= 10 ? 1 : 0;\r\n            --i;\r\n        }\r\n      \r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity Analysis\r\nTime: `O(max(N, log(K)))`\r\n* Given a number `K`, its length will be `log_{2}(K)`, the time complexity depends on the length of `N` and `K`, whichever is longer.\r\n* Notice we want to insert digits at the end of the array and then reverse it after we finish the addition. If we insert at the head of array, then it will take `O(n^2)` of time.\r\n\r\nSpace: `O(1)`, as we didn't use additional spaces except the return array.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917026412","body":"# LC821. Shortest Distance to a Character\n## Main Idea\n### One Scan with Two Pointers\nWe use `prev` array to record the previous appearance of `c` and `next` array to record the next for each character in the string. \n\nFor the first character, initialize its `prev[0]` to be infinity. Then for each character `s[i]`, if `s[i] == c`, then `prev[i] = 0`, else, `prev[i] = prev[i - 1] + 1`, notice if `prev[i - 1] == Integer.MAX_VALUE`, we don't need to add 1 so it won't cause integer overflow.\n\nSimilar logic for `next` array.\n\nThen for each character, `res[i] = min{prev[i], next[i]}`.\n\nAlso we can use two pointers to acheive our goal with one scan.\n\n## Code\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] next = new int[n], prev = new int[n], res = new int[n];\n        for (int i = 0; i < n; ++i) {\n            int j = n - 1 - i;\n            if (i == 0) {\n                prev[i] = s.charAt(i) == c ? 0 : Integer.MAX_VALUE;\n                next[j] = s.charAt(j) == c ? 0 : Integer.MAX_VALUE;\n            } else {\n                prev[i] = s.charAt(i) == c ? 0 : prev[i - 1] == Integer.MAX_VALUE ? prev[i - 1] : prev[i - 1] + 1;\n                next[j] = s.charAt(j) == c ? 0 : next[j + 1] == Integer.MAX_VALUE ? next[j + 1] : next[j + 1] + 1;\n\n                if (i >= j) {\n                    res[i] = Math.min(prev[i], next[i]);\n                    res[j] = Math.min(prev[j], next[j]);\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n## Complexity Analysis\nTime: `O(n)`\nSpace: `O(n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917430931","body":"# LC1381. Design a Stack With Increment Operation\r\n## Main Idea\r\nA stack can be implemented with an array, but usually we only have access to stack top due to encapsulation, while we can actually access/modify any elements in the array internally.\r\n\r\nWe can implement the stack API with `array`:\r\n* `push()`: append at the end of array (`O(1)`)\r\n* `pop()`: remove the end of array (`O(1)`)\r\n* `increment()`: use a for loop to increment `array[0:k]` (`O(k)`).\r\n\r\n### Optimization. Range Update with Difference Array && Lazy Evaluation\r\nNotice the time complexity of `increment()` is too high due to range update, and we can use a difference array to optimize it.\r\n\r\nAlso we don't really care about the values of elements until we `pop` them, so we can evaluate them when we pop them out of the stack.\r\n\r\n## Code\r\n```java\r\nclass CustomStack {\r\n    private List<Integer> array;\r\n    private List<Integer> diff;\r\n    private int cap;\r\n    private int size;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        array = new ArrayList<>();\r\n        diff = new ArrayList<>();\r\n        cap = maxSize;\r\n        size = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (size >= cap) {\r\n            return;\r\n        }\r\n        ++size;\r\n        array.add(x);\r\n        diff.add(0);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (size == 0) {\r\n            return -1;\r\n        }\r\n        int num = array.remove(size - 1);\r\n        int d = diff.remove(size - 1);\r\n        --size;\r\n        if (size > 0)\r\n            diff.set(size - 1, diff.get(size - 1) + d);\r\n        return num + d;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int idx = Math.min(k, size) - 1;\r\n        if (idx >= 0)\r\n            diff.set(idx, diff.get(idx) + val);\r\n    }\r\n}\r\n```\r\n## Complexity Analysis\r\nTime: `O(1)` for all operations\r\n\r\nSpace: `O(n)` as we used 2 arrays.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917696390","body":"# LC394. Decode String\r\n## Method 1. Recursion\r\n### Main Idea\r\nFirst, I think we can use recursion to handle nested cases like `3[a2[bc]]`, where we can decode `2[bc]` first, and we get `3[abcbc]`, which is the same problem with different size.\r\n\r\n**Algorithm**\r\n\r\nWe need a global variable `index` to indicate which index are we currently processing.\r\n* Base case: if there are no brackets, we just return the string itself.\r\n* When we see a digit, we convert it to number `cnt`, increment `index` to skip the `[`, and pass the string to recursive call.\r\n* When we see a `]`, we can return from this recursive call.\r\n\r\n### Code\r\n```java\r\nclass Solution {\r\n    private int index = 0;\r\n    public String decodeString(String s) {\r\n        StringBuilder sb = new StringBuilder();\r\n        int n = s.length();\r\n        while (index < n && s.charAt(index) != ']') {\r\n            char c = s.charAt(index);\r\n            if (Character.isDigit(c)) {\r\n                int cnt = 0;\r\n                while (Character.isDigit(s.charAt(index))) {\r\n                    cnt = cnt * 10 + s.charAt(index) - '0';\r\n                    ++index;\r\n                }\r\n                ++index;\r\n                String str = decodeString(s);\r\n                for (int i = 0; i < cnt; ++i) {\r\n                    sb.append(str);\r\n                }\r\n            } else {\r\n                sb.append(c);\r\n            }\r\n            ++index;\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n### Complexity Analysis\r\nTime: `O(S)`, where `S` is the length of the decoded string.\r\n\r\nSpace: `O(s)`, where `s` is the length of the input string, as the space complexity depends on the depth of recursive calls, and we can have at most `s` nested brackets.\r\n## Method 2. Stack\r\n### Main Idea\r\nWe can also use stack to solve problems of parentheses matching, in this problem, we will push everything to the stack until we see a `]`, then we pop things from the stack until we found its matching `[`. And we can decode the string, and push the decoded string back to the stack.\r\n### Code\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        int n = s.length();\r\n        Deque<Character> stack = new ArrayDeque<>();\r\n        for (int i = 0; i < n; ++i) {\r\n            char c = s.charAt(i);\r\n            if (c != ']') {\r\n                stack.push(c);\r\n            } else {\r\n                List<Character> list = new ArrayList<>();\r\n                while (stack.peek() != '[') {\r\n                    list.add(stack.pop());\r\n                }\r\n                stack.pop();\r\n\r\n                int cnt = 0, base = 1;\r\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\r\n                    int digit = stack.pop() - '0';\r\n                    cnt += (digit * base);\r\n                    base *= 10;\r\n                }\r\n\r\n                for (int l = 0; l < cnt; ++l) {\r\n                    for (int j = list.size() - 1; j >= 0; --j) {\r\n                        stack.push(list.get(j));\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        StringBuilder sb = new StringBuilder();\r\n        while (!stack.isEmpty()) {\r\n            sb.append(stack.pop());\r\n        }\r\n\r\n        sb.reverse();\r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n### Complexity Analysis\r\nTime: `O(S)`, where `S` is the length of the decoded string.\r\n\r\nSpace: `O(S)`, since we use a stack to store all the characters.","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ai2095":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916293322","body":"## LC 989 Add to Array-Form of Integer\n\nhttps://leetcode.com/problems/add-to-array-form-of-integer/\n\n### Topics  \n\n- Array\n- Math\n\n### Similar Questions\n\nMedium\n- https://leetcode.com/problems/add-two-numbers/\n\nEasy\n- https://leetcode.com/problems/plus-one/\n- https://leetcode.com/problems/add-binary/\n- https://leetcode.com/problems/add-strings/\n\n\n### 思路 \nAdd the number K to the array from right to left.\n\n#### 代码 Python\n\n```Python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carrier = 0\n        num_len = len(num)\n        i = num_len -1\n        # Add all matching digit        \n        while i >= 0 and k > 0:\n            cur_k, k = k%10, k//10\n            t_carrier = (num[i] + cur_k + carrier) // 10\n            num[i] = (num[i] + cur_k + carrier) % 10\n            carrier = t_carrier\n            i -= 1\n        \n        # Check whether num or k is left\n        if i >= 0:\n            while i >= 0:\n                t_carrier = (num[i] + carrier) // 10\n                num[i] = (num[i] + carrier) % 10\n                carrier = t_carrier\n                if carrier == 0:\n                    break\n                i -= 1\n            \n        if k > 0:\n            while k > 0:\n                cur_k, k = k%10, k//10\n                t_carrier = (cur_k + carrier) // 10\n                num = [(cur_k + carrier) % 10] + num\n                carrier = t_carrier\n\n        # Deal with carrier\n        if carrier > 0:\n            return [carrier] + num\n        else:\n            return num\n            \n\n```\n\n#### 复杂度分析\n\n时间复杂度：O(N) </br>\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917052674","body":"## LC 821 Shortest Distance to a Character\n\nhttps://leetcode.com/problems/shortest-distance-to-a-character/\n\n### Topics  \n\n- Array\n- String\n\n### Similar Questions\nHard\n- https://leetcode.com/problems/shortest-common-supersequence/\n\nMedium\n- https://leetcode.com/problems/find-k-length-substrings-with-no-repeated-characters/\n- https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/\n\nEasy\n- \n\n\n### 思路 \n1. Find all c ocurrences and save them into one list.\n2. Update the corresponding position in res to 0\n3. Update other elements in the result list\n\n#### 代码 Python\n\n```Python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # Helper function to update other elements.\n        def update_res(index):\n            # Update the lower part\n            i = index\n            while i > 0 and res[i] + 1 < res[i-1]:\n                res[i-1] = res[i] + 1\n                i -= 1\n            j = index\n            while j < len(res) - 1 and res[j] + 1 < res[j+1]:\n                res[j+1] = res[j] + 1\n                j +=1\n                \n        res = [float(\"inf\")]*len(s)\n        # Find all c ocurrences and save them into one list.\n        # Update the corresponding position in res to 0\n        c_l = []\n        for i, e in enumerate(s):\n            if e == c:\n                c_l.append(i)\n                res[i] = 0\n        \n        # Update other elements in the result list\n        for idx in c_l:\n            update_res(idx)\n    \n        return res\n\n```\n\n#### 复杂度分析\n\n时间复杂度：O(N) </br>\n空间复杂度：O(N) N is the # of occurrence of c in s.\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917439651","body":"## LC1381. Design a Stack With Increment Operation\r\n\r\nhttps://leetcode.com/problems/design-a-stack-with-increment-operation/\r\n\r\n### Topics  \r\n\r\n- Stack\r\n\r\n### Similar Questions\r\nHard\r\n- https://leetcode.com/problems/distribute-repeating-integers/\r\n- https://leetcode.com/problems/closest-room/\r\n\r\nMedium\r\n- https://leetcode.com/problems/range-sum-of-sorted-subarray-sums/\r\n\r\n\r\n\r\n### 思路 \r\nUse a list and check the size.\r\n\r\n#### 代码 Python\r\n\r\n```Python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        \r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        return self.stack.pop() if len(self.stack) > 0 else -1\r\n            \r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i] += val\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：push: O(1), pop: O(1), increment: O(k) </br>\r\n空间复杂度：O(N) \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917760614","body":"## LC394. Decode String\n\nhttps://leetcode.com/problems/decode-string/\n\n### Topics  \n\n- Stack\n- String\n\n### Similar Questions\nHard\n- https://leetcode.com/problems/number-of-atoms/\n- https://leetcode.com/problems/encode-string-with-shortest-length/\n\nMedium\n- https://leetcode.com/problems/brace-expansion/\n\nEasy\n- \n\n\n### 思路 \nScan s from left to right.\nWhen \"[\", Use stack to store processed string and num.\nWhen \"]\", pop processed string and num , and concatenate the new string.\n\n#### 代码 Python\n\n```Python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        num, string, stack = 0, \"\", []\n        for c in s:\n            if c.isdigit():\n                num = num*10 + int(c)\n            elif c == \"[\":\n                stack.append(string)\n                stack.append(num)\n                string = \"\"\n                num = 0\n            elif c.isalpha():\n                string += c\n            elif c == \"]\":\n                pre_num = stack.pop()\n                pre_string = stack.pop()\n                string = pre_string + pre_num * string\n        return string\n\n```\n\n#### 复杂度分析\n\n时间复杂度：O(N) </br>\n空间复杂度：O(N) \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanglr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916293869","body":"## 思路\r\n\r\n双指针 + 进位加法逻辑\r\n\r\n双指针, 让两个数的末位对齐, 两个指针 i, j均从各自字符串的末尾开始走。\r\n\r\n定义一个数组来存放结果, 一个int值carry来记录每位的进位值, 初始值设为0。\r\n算当前位置的数时, sum = a[i] + b[j] + carry, 每趟都要记得更新carry的值。\r\n\r\n循环结束时, 由于低位的数字字符先加到了结果字符串中, 最后还需要 reverse 一次, 让位置恢复正常。\r\n\r\n\r\n\r\n## 代码\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& A, int k) {\r\n        if (k == 0) return A;\r\n        vector<int> res;\r\n        int n = A.size();\r\n        // 对位相加\r\n        int carry = 0;\r\n        int sum = 0;      \r\n        int i = n - 1; \r\n        while (k > 0 || i >= 0)\r\n        {\r\n            sum = carry + (k % 10);\r\n            if (i >= 0) // 保证访问A[i]前不越界\r\n                sum += A[i];\r\n\r\n            carry = (sum <= 9) ? 0 : 1;\r\n            res.push_back(sum % 10);            \r\n            k = k / 10;\r\n            \r\n            i--;\r\n        }\r\n        if (carry == 1) res.push_back(1);\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n\r\n代码已上传到: [leetcode-ac/91algo - github.com](https://github.com/yanglr/leetcode-ac/tree/master/91algo)\r\n\r\n\r\n\r\n## 复杂度分析 \r\n\r\n- 时间复杂度：O(max(n, k))，其中 n 为数组长度, k为数K的长度。\r\n- 空间复杂度：O(n), 主要是结果数组用的空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917028429","body":"## 思路\r\n\r\n**题意**: 计算 `abs[i] = indexGap(i, 最近的字符c)`, 1 <= s.length <= 10^4\r\n输出 `abs[i]`的数组\r\n\r\n### 解法: 双指针 中心扩展\r\n\r\n使用一个结果数组 gaps[]\r\n\r\n将string s转为字符数组，然后从前往后遍历。\r\n循环变量记作i, 对于每一趟: \r\n如果当前字符就是要搜索的字符c, 距离记为 0，否则分别向左、向右找最近的字符c。\r\n向左找, 找到第一个字符c, 将指针i与之的index之差记作leftDistance。\r\n向右找, 找到第一个字符c, 将指针i与之的index之差记作rightDistance。\r\n取两者的较小值。\r\n\r\n依次填充 gaps[i] 的值即可。\r\n\r\n\r\n## 代码\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> gaps(s.size());\r\n        vector<char> chars(s.begin(), s.end());\r\n\r\n        for (int i = 0; i < chars.size(); i++)\r\n        {\r\n            // 如果当前字符就是要搜索的字符c, 距离为 0\r\n            if (chars[i] == c) gaps[i] = 0;\r\n            else /* 否则分别向左、向右找最近的字符c */\r\n            {\r\n                int leftDistance = INT_MAX, rightDistance = INT_MAX;\r\n                for (int left = i; left >= 0; left--)\r\n                {\r\n                    if (chars[left] == c) // 向左找, 找到第一个\r\n                    {\r\n                        leftDistance = i - left;\r\n                        break;\r\n                    }\r\n                }\r\n                for (int right = i; right < chars.size(); right++) // 向右找, 找到第一个\r\n                {\r\n                    if (chars[right] == c)\r\n                    {\r\n                        rightDistance = right - i;\r\n                        break;\r\n                    }\r\n                }\r\n                gaps[i] = min(leftDistance, rightDistance);\r\n            }\r\n        }\r\n\r\n        return gaps;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n代码已同步上传到: [leetcode-ac/91algo - github.com](https://github.com/yanglr/leetcode-ac/tree/master/91algo)\r\n\r\n\r\n\r\n## 复杂度分析 \r\n\r\n- 时间复杂度：O(n^2)，其中 n 为字符串长度。\r\n- 空间复杂度：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917431784","body":"## 思路\r\n根据题目标签，用栈试试\r\n\r\n### 用栈实现\r\n\r\n用数组模拟栈操作。\r\n对于increment操作，求和即可。\r\n\r\n\r\n## 代码\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stack;\r\n    int size;\r\n\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize);\r\n        size = 0;\r\n    }\r\n\r\n    void push(int x) {\r\n        if (size < stack.size())\r\n        {\r\n            stack[size] = x;\r\n            size++;            \r\n        }\r\n    }\r\n\r\n    int pop() {\r\n        int res = -1;\r\n        if (size > 0)\r\n        {\r\n            size--;\r\n            res = stack[size];\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    void increment(int k, int val) {\r\n        for (int i = 0; i < min(k, size); i++)\r\n            stack[i] += val;\r\n    }\r\n};\r\n```\r\n\r\n代码已上传到: [leetcode-ac/91algo - github.com](https://github.com/yanglr/leetcode-ac/tree/master/91algo)\r\n\r\n## 复杂度分析\r\n\r\n- **时间复杂度**:  O(k)\r\n插入和弹出为O(1)，累加操作需要遍历 O(k)个元素。\r\n\r\n- **空间复杂度**\r\n需要额外 O(maxSize)的栈空间。\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917667105","body":"## 思路\r\n\r\n规律:\r\n对于每一个小段, 如果有n层配对的中括号, 那么它的格式是:\r\n`n[xxx]`\r\n\r\n如果出现次数是1, 那么它的格式是:\r\nxxx,\r\n1和`[]`直接不写, 和原串相同.\r\n\r\n如果存在多层中括号, 则需要使用**栈**或**递归**的方式解决。\r\n\r\n## 栈\r\n\r\n使用两个stack (后面直接将deque用作stack, 性能更好),\r\n一个stack存放重复出现的次数。\r\n另一个stack存储扫描到的字符串。\r\n将结果字符串记作resStr。\r\n\r\n\r\n\r\n## 代码\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        deque<int> numStack;\r\n        deque<string> strStack;\r\n        string resStr;\r\n\r\n        int n = s.size();\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            char ch = s[i];\r\n            if (isdigit(ch))\r\n            {\r\n                int digit = ch - '0';\r\n                while (i < n - 1 && isdigit(s[i + 1]))\r\n                {\r\n                    digit = digit * 10 + s[i + 1] - '0';\r\n                    i++;\r\n                }\r\n                numStack.push_front(digit);\r\n            }\r\n            else if (ch == '[')\r\n            {\r\n                strStack.push_front(resStr);\r\n                resStr.clear();\r\n            }\r\n            else if (ch == ']')\r\n            {\r\n                string tmp = strStack.front();\r\n                strStack.pop_front();\r\n                int repeatCount = numStack.front();\r\n                numStack.pop_front();\r\n                for (int j = 0; j < repeatCount; j++)\r\n                    tmp.append(resStr);\r\n\r\n                resStr = tmp;\r\n            }\r\n            else resStr.push_back(ch);  // 直接取出来放进结果字符串中\r\n        }\r\n        return resStr;\r\n    }\r\n};\r\n```\r\n\r\n\r\n代码已上传到: [leetcode-ac/91algo - github.com](https://github.com/yanglr/leetcode-ac/tree/master/91algo)\r\n\r\n\r\n\r\n## 复杂度分析 \r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZiyangZ":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916314383","body":"- Talk about how to make an easy problem complicated:\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int size = Math.max(num.length, String.valueOf(k).length());\n        int dif = size - num.length; \n        int[] ans = new int[size];\n        int carry = 0;\n        for (int i = ans.length - 1; i >= 0; i--) {\n            int n = (i - dif) < 0 ? 0:num[i - dif];\n            int m = k % 10;\n            k = k / 10;\n            ans[i] = (n + m + carry) % 10;\n            carry = (n + m + carry) / 10;\n        }\n        \n        List<Integer> list = new ArrayList<>();\n        if (carry == 1) list.add(1);\n        for (int i: ans) list.add(i);\n        \n        return list;\n    }\n}\n```\n\n- So turns out all we need to do is adding digits from the last position and reverse the list.\n- Time and space O(max(n, m)) where n is the length of num and m is the number of digits in k.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917038224","body":"- Time and space O(n).\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        List<Integer> index = new ArrayList<>();\n        index.add(Integer.MAX_VALUE);\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) index.add(i);\n        }\n        index.add(Integer.MAX_VALUE);\n        \n        int[] ans = new int[s.length()];\n        int i = 1;\n        for (int j = 0; j < s.length(); j++) {\n            ans[j] = Math.min(Math.abs(j - index.get(i)), Math.abs(j - index.get(i - 1)));\n            if (j == index.get(i)) i++;\n        }\n        \n        return ans;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917714370","body":"- Time O(maxCount * n) where maxCount is the maximum value of integer in s and n is the length of s.\n- Space O(n).\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder ans = new StringBuilder();\n        int count = 0;\n        Stack<Integer> countStack = new Stack<>();\n        Stack<StringBuilder> stringStack = new Stack<>();\n        for (char c: s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                if (countStack.isEmpty()) ans.append(c);\n                else {\n                    stringStack.push(stringStack.pop().append(c));\n                }\n            }\n            if (Character.isDigit(c)) {\n                count = 10 * count + c - '0';\n            }\n            if (c == '[') {\n                countStack.push(count);\n                count = 0;\n                stringStack.push(new StringBuilder());\n            }\n            if (c == ']') {\n                int n = countStack.pop();\n                StringBuilder sb = stringStack.pop();\n                if (countStack.size() == 0) {\n                    for (int i = 0; i < n; i++) {\n                        ans.append(sb);\n                    }\n                } else {\n                    StringBuilder cur = stringStack.pop();\n                    for (int i = 0; i < n; i++) {\n                        cur.append(sb);\n                    }\n                    stringStack.push(cur);\n                }\n            }\n        }\n        return ans.toString();\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cicihou":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916314749","body":"``` python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        res = []\r\n        for i in num:\r\n            res.append(str(i))\r\n        res = str(int(''.join(res)) + k)\r\n        res = [int(i) for i in res]\r\n        return res\r\n        \r\n```\r\n\r\n\r\ntime: O(n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917058171","body":"``` python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        c_position = [i for i in range(len(s)) if s[i] == c]\n        return [min([abs(c-i) for c in c_position]) for i in range(len(s))]\n```\ntime: O(len(s) * len(c))\nspace: O(len(c))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917517660","body":"class CustomStack:\r\n\r\n    def __init__(self, maxSize):\r\n        self.n = maxSize\r\n        self.stack = []\r\n        self.inc = []\r\n\r\n    def push(self, x):\r\n        if len(self.inc) < self.n:\r\n            self.stack.append(x)\r\n            self.inc.append(0)\r\n\r\n    def pop(self):\r\n        if not self.inc: return -1\r\n        if len(self.inc) > 1:\r\n            self.inc[-2] += self.inc[-1]\r\n        return self.stack.pop() + self.inc.pop()\r\n\r\n    def increment(self, k, val):\r\n        if self.inc:\r\n            self.inc[min(k, len(self.inc)) - 1] += val\r\n        \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917673177","body":"``` python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        ''' stack '''\r\n        stack = []\r\n        for i in s:\r\n            if i == ']':\r\n                volume = ''\r\n                tmp = ''\r\n                while stack[-1] != '[':\r\n                    val = stack.pop()\r\n                    tmp = val + tmp\r\n                stack.pop()\r\n                while stack and stack[-1].isdigit():\r\n                    a = stack.pop()\r\n                    volume = a + volume\r\n                stack.append(int(volume) * tmp)\r\n            else:\r\n                stack.append(i)\r\n        return ''.join(stack)\r\n```\r\n\r\n时间：最坏情况 O(n^2)\r\n空间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shixinlovey1314":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916315048","body":"# ***Title:989. Add to Array-Form of Integer***\n\n## ***Question Reference*** [LeetCode](https://leetcode.com/problems/add-to-array-form-of-integer/)\n\n## ***Solution***\n1. Revert the array, so that we only need to manipulate the end of the array.\n2. Extract the lowest digit of K and add into the array ascendingly. \n3. After each addition, if the item at the given index excceds 10, then only keep the lowest digit part and add 1 to the next item in the array (Watch out the array boundary and expand the array by 1 if needed..\n4. After processed K, check if there still exist delta > 0, if so keep on repeating the process similar to step 2 until delta equals 0.\n5. Revert the array back.\n\n## ***Code***\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int index = 0;\n        int delta = 0;\n        \n        std::reverse(num.begin(), num.end());\n        \n        while (k > 0) {\n            delta += k % 10 + num[index];\n            k /= 10;\n            \n            num[index++] = delta % 10;\n            delta /= 10;\n            \n            if (index == num.size() && (k > 0 || delta > 0))\n                num.push_back(0);\n        }\n        \n        while (delta > 0) {\n            delta += num[index];\n            num[index++] = delta % 10;\n            delta /= 10;\n            \n            if (index == num.size() && (delta > 0))\n                num.push_back(0);\n        }\n            \n        std::reverse(num.begin(), num.end());\n        \n        return num;\n    }\n};\n\n```\n\n## ***Complexity***\n### ***Time Complexity and Explaination***\nO(max(N, M)), N is the size of the array, while M is the size of the virtual array form of K, which is logarithm of base 10 -> log10(K).\n\n### ***Space Complexity and Explaination***\nO(1) since we reuse the input array and didn't need any extra space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917319452","body":"# ***Title: 821. Shortest Distance to a Character***\n\n## ***Question Reference*** [LeetCode](https://leetcode.com/problems/shortest-distance-to-a-character/)\n\n## ***Solution***\nStore all the indices of c in an array called helper_array, then traverse the original array and compare the indices with helper_array, to update the distance.\nSince the indices in helper_array will be in assend order, we can use 2 pointers, one points to the orginal array (po) and the other points to the helper array(ph), keep on moving the po, but only moves the ph when po > helper_array[ph], and each time compare the po with ph -1 and ph and use the smaller value to update the output array.\n## ***Code***\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> helper_array;\n        vector<int> dis(s.length(), INT_MAX);\n        \n        for (int i = 0; i < s.length(); i++) {\n            if (s[i] == c) {\n                helper_array.push_back(i); \n            }\n        }\n        \n        for (int i = 0, j = 0; i < s.length() && j < helper_array.size(); i++) {\n            if (i > helper_array[j] && j < helper_array.size() - 1) j++;\n            \n            if (i < helper_array[j]) {\n                // compare with j - 1.\n                dis[i] = j == 0? INT_MAX : i - helper_array[j - 1];\n                // compare with j.\n                dis[i] = min(dis[i], helper_array[j] - i);\n            } else if (i > helper_array[j]) {\n                // compare with j + 1\n                dis[i] = j == helper_array.size() - 1? INT_MAX : helper_array[j + 1] - i;\n                // compare with j\n                dis[i] = min(dis[i], i - helper_array[j]);\n            } else {\n                dis[i] = 0;\n            }\n            \n        }\n        \n        return dis;\n    }\n};\n\n```\n\n## ***Complexity***\n### ***Time Complexity and Explaination***\nO(n), we first iterated the orginal array to setup the helper_array which takes O(n) time.\nDuring comparasion, since we will visit each item in the original array for 1 once, and each vistit we would compare with most 2 items from helper_array, which take O(2n)\nTotal time complexity is O(n) + O(2n) = O(n)\n\n### ***Space Complexity and Explaination***\nO(n) for the helper_array, and in the worst case, the helper_array will have the same size as the original array.\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917541883","body":"# ***Title:1381. Design a Stack With Increment Operation***\n\n## ***Question Reference*** [LeetCode](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n\n## ***Solution***\nWe can use an array to implement the stack, use an index to track the top of the stack.\nArray supports random access, so it is very easy to do inc, and for push and pop, we just need to change the tracking index accordingly.\n## ***Code***\n```C++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        dataStore = vector<int> (maxSize);\n        topIndex = 0;\n        size = maxSize;\n    }\n    \n    void push(int x) {\n        if (topIndex == size)\n            return;\n        dataStore[topIndex++] = x;\n    }\n    \n    int pop() {\n        if (topIndex == 0)\n            return -1;\n        return dataStore[--topIndex];\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i < k && i < topIndex; i++)\n            dataStore[i] += val;\n    }\n    \nprivate:\n    vector <int> dataStore;\n    int topIndex;\n    int size;\n};\n\n```\n\n## ***Complexity***\n### ***Time Complexity and Explaination***\nCustomStack(int maxSize) takes O(1), since we can allocate the array with 1 opereation.\nPush and pop both takes O(1), since we just need to manipulate the tracking index.\nInc takes O(k), which k is the number of items that we want to increment.\n\n### ***Space Complexity and Explaination***\nO(n), which n is the maxSize that passes in.\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917815080","body":"# ***Title:394. Decode String***\n\n## ***Question Reference*** [LeetCode](https://leetcode.com/problems/decode-string/)\n\n## ***Solution***\nNaturally, we can think of using stack to solve this problem, we start push to then stack when we see a digit and start pop the stack when we see the ']', untill we see the '\\['  at that point we save all the chars between '\\[' and ']' into a temp string, we then popup the digit from the stack and add them into the result.\nthe only issue is when the encoded string itself is enbeded with another encoded string.\nTo solve this, we can so a small modification to the stack, after we decode the string using the stack, we check if the stack is NULL,\n\n## ***Code***\n```C++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string result;\n        stack<char> encodingStack;\n        bool isPush = false;\n        \n        for (char c : s) {\n            if (isdigit(c) || (isPush && c != ']')) {\n                isPush = true;\n                encodingStack.push(c);\n            } else if (c == ']') {\n                isPush = false;\n                \n                string tmp;\n                while (!encodingStack.empty() && encodingStack.top() != '[') {\n                    tmp.push_back(encodingStack.top());\n                    encodingStack.pop();\n                }\n                // pop out '['\n                encodingStack.pop();\n                reverse(tmp.begin(), tmp.end());\n                \n                \n                string numStr;\n                \n                while (!encodingStack.empty() && isdigit(encodingStack.top())) {\n                    numStr.push_back(encodingStack.top());\n                    encodingStack.pop();\n                }\n                \n                reverse(numStr.begin(), numStr.end());             \n                \n                // pop out num\n                int num = stoi(numStr);\n                \n                string addition;\n                for (int i = 0; i < num; i++) {\n                    addition.append(tmp);\n                }\n                \n                if (encodingStack.empty())\n                    result.append(addition);\n                else {\n                    for (char ch : addition)\n                        encodingStack.push(ch);\n                    isPush = true;\n                }\n                \n            } else {\n                result.push_back(c);\n            }\n        }\n        \n        return result;\n    }\n};\n```\n\n## ***Complexity***\n### ***Time Complexity and Explaination***\nO((maxK to the power of countK)* n): countK is the maximum nested level and maxK is the maximum value of K.\n### ***Space Complexity and Explaination***\nO((maxK to the power of countK)* n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pangjiadai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916317988","body":"## 思路\r\n### 模版\r\n\r\n```\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n\r\n### 代码\r\n- 语言： Python3\r\n\r\n```python\r\nfrom collections import deque\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = len(num) -1\r\n        res = []\r\n        carry = 0\r\n\r\n        while i >=0 or k != 0:\r\n            if i >= 0:\r\n                curr_num = num[i]\r\n            else:\r\n                curr_num = 0\r\n            if k != 0:\r\n                curr_k = k % 10 \r\n            else:\r\n                curr_k = 0\r\n\r\n            total = curr_num + curr_k + carry\r\n            curr_total = total % 10\r\n            carry = total // 10\r\n            res.append(curr_total)\r\n            i -= 1\r\n            k = k // 10\r\n\r\n        if carry != 0:\r\n            res.append(carry)\r\n\r\n        return res[::-1]\r\n```\r\n\r\n### 复杂度：\r\n- 时间复杂度：$O(n)$ 遍历\r\n- 空间复杂度：$O(n)$ 新创立了一个ans list","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917211204","body":"## 思路和复杂度\n- 暴力：遍历两遍，先遍历一遍记录下target的index -> index_list，再遍历第二遍得到最小值\n- 可以优化的地方：遍历第二遍: \n1. 可以遍历index_list记录最小值 O(n^2); \n2. 可以用一个指针标记最近的target O(N)\n\n## Python3\n```Python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # 两遍遍历\n        index_list = []\n        ans = []\n        min_distance = len(s)\n        for index, char in enumerate(s):\n            if char == c:\n                index_list.append(index)\n\n        for index, char in enumerate(s):\n            for i in range(0, len(index_list)):\n                distance = abs(index-index_list[i])\n                min_distance = min(distance, min_distance)\n                if i == len(index_list) -1:\n                    ans.append(min_distance)\n                    min_distance = len(s)\n\n        return ans\n```\n\n\n\n\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917475437","body":"## 思路\n栈: append(), pop()来实现\n\n## Python3 \n```Python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack == []:\n            return -1\n        else:\n            num = self.stack.pop()\n            return num\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len (self.stack))):\n                self.stack[i] += val\n```\n\n## 复杂度\n时间：\n- push, pop: O(1)\n- increment: O(k)\n\n空间：O(n) \n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917728082","body":"## 思路\n要点：有点类似于左括号、右括号用stack来解决的题目\n- stack = [(str, num)]  用一个string参数来记录目前的string, 用num记录目前的number, 遇到“[”时入栈，遇到“]”出栈\n- 直接用str = top[0] + str[1] * str来输出更新的string\n- 如果是多位数，则num需要考虑进位\n\n## Python3\n```Python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = [] # stack = [(str, num)] 遇到“[”时入栈，遇到“]”出栈\n        str = \"\"\n        num = 0\n\n        for char in s:\n            if char.isdigit():\n                num = num * 10 + int(char) #如果是多位数，要考虑进位*10\n            elif char == '[':\n                stack.append((str, num))\n                str = \"\"\n                num = 0\n            elif char == ']':\n                top = stack.pop()\n                str = top[0] + str*top[1]\n            else:\n                str += char\n        \n        return str\n```\n\n## 复杂度：\ntime O(n), space O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luojiamun":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916322388","body":"### 思路\n\nDeque, Array遍历；\n\n注意题目要求，1 <= A.length <= 10000，所以直接做加法是不可能的。\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int pos = 0;\n        int carry = 0;\n        Deque<Integer> res = new LinkedList<>();\n        while(pos < num.length || k >= Math.pow(10, pos) || carry > 0){\n            int fromNum = pos < num.length?num[num.length - 1 - pos]:0;\n            int fromK = (k / (int)Math.pow(10, pos)) % 10;\n            int sum = fromNum + fromK + carry;\n            res.addFirst(sum % 10);\n            carry = sum > 9?1:0;\n            pos++;\n        }\n                \n        return new ArrayList<>(res);\n    }\n}\n```\n\n### 复杂度\n\nO(MAX(num.length, Integer.valueOf(k).toString.length()))\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917160920","body":"### 思路\r\nArray遍历\r\n\r\n两次遍历\r\n- 第一次从左到右，遇到c，将其右边的依次从1-m编号；直到遇到下一个c，重复编号过程。（第一个c左边为未编号状态）\r\n- 第二次从右到左，遇到c，将其左边当前编号与预计编号比较并取min；第二次编号并会将第一个c左边的编号完成。\r\n\r\nStack\r\n将s遍历一次\r\n- 如果当前为c，\r\n    - pop站内元素，并依次按距离递增编号；直到栈空或栈顶为c；当前位置编号0；将当前位置压入栈\r\n- 如果当前不为c\r\n    - 如果栈顶为c，那么当前位置编号1\r\n    - 否则当前位置编号为前一个位置编号+1；\r\n    - 将当前位置index 压入栈；\r\n\r\n\r\n### 代码\r\n```java\r\n//array遍历\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int pre = Integer.MIN_VALUE / 2;\r\n        int[] res = new int[s.length()];\r\n        for(int i = 0;i < s.length();i++){\r\n            if(s.charAt(i) == c) pre = i;\r\n            res[i] = i - pre;\r\n        }\r\n        \r\n        pre = Integer.MAX_VALUE;\r\n        for(int i = s.length() - 1;i >= 0;i--){\r\n            if(s.charAt(i) == c) pre = i;\r\n            res[i] = Math.min(res[i], pre - i);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n\r\n//stack\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        int[] res = new int[s.length()];\r\n        stack.add(0);\r\n        for(int i = 0;i < s.length();i++){\r\n            if(s.charAt(i) == c){\r\n                int pos = 0;\r\n                while(!stack.isEmpty() && s.charAt(stack.peek()) != c){\r\n                    int cur = stack.pop();\r\n                    \r\n                    res[cur] = res[cur] == 0?++pos:Math.min(++pos, res[cur]);\r\n                }\r\n                res[i] = 0;\r\n                stack.add(i);\r\n            } else {\r\n                if(!stack.isEmpty() && s.charAt(stack.peek()) == c){\r\n                    res[i] = 1;\r\n                } else if(i > 0 && res[i-1] != 0) {\r\n                    res[i] = res[i-1] + 1;\r\n                }\r\n                stack.add(i);\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\nArray遍历\r\nO(s.length());\r\nO(1)\r\n\r\nStack\r\nO(s.length())\r\nO(N),维护一个栈。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917448932","body":"### 思路\r\n\r\n用array模拟stack的操作。比较特别的是increment这个方法，将栈底的k个元素递增val。\r\n\r\n基本的push和pop的操作通过记录index来实现就好。increment这个方法则可以通过`两种`方式.\r\n\r\n- 不使用额外空间的基础上，用loop update栈底部的k个值；\r\n- 使用额外的array，存储increment value，然后pop时与原始值求和；\r\n- 在递增array中，变量以\"内卷\"的方式存储，即只更新第k个值，共所有的前k个值更新所用。这样操作的目的是为了避免循环赋值；\r\n\r\n\r\n### 代码\r\n```java\r\n//loop for increment\r\nclass CustomStack {\r\n    int[] store;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.store = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top < store.length - 1){\r\n            store[++top] = x;    \r\n        }\r\n        \r\n    }\r\n    \r\n    public int pop() {\r\n        if(top >= 0){\r\n            return store[top--];\r\n        } else {\r\n            return -1;\r\n        }\r\n        \r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(top == -1) return;\r\n        int count = k;\r\n        int cur = 0;\r\n        while(count > 0 && cur <= top){\r\n            store[cur] += val;\r\n            count--;\r\n            cur++;\r\n        }\r\n    }\r\n}\r\n\r\n//array for increment\r\nclass CustomStack {\r\n    int[] store;\r\n    int[] incre;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.store = new int[maxSize];\r\n        this.incre = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top < store.length - 1){\r\n            store[++top] = x;    \r\n        }\r\n        \r\n    }\r\n    \r\n    public int pop() {\r\n        if(top < 0) return -1;\r\n        int sum = store[top] + incre[top];\r\n        if(top == 0) {\r\n            incre[top] = 0;\r\n            top--;\r\n            return sum;\r\n        }\r\n        incre[top - 1] += incre[top];\r\n        incre[top] = 0;\r\n        top--;\r\n        return sum;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(top == -1) return;\r\n        if(k > top + 1) k = top + 1;\r\n        incre[k - 1] += val;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\nloop for increment\r\npop, push复杂度O(1), increment复杂度O(K);\r\nO(1)，不包括用于模拟的array；\r\n\r\narray for increment\r\npop, push, increment都是O(1)；\r\n在原本模拟stack的array基础上，额外付出O(N)提供存储incre的array。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917688530","body":"### 思路\r\n\r\nstack, string\r\n\r\n这题的主要考点\r\n\r\n- 利用栈，在遇到右括号`]`时pop进行运算，运算完成后push回到stack；\r\n    - 这个技巧可以说用的蛮多，类似的技巧在1381也用到过；\r\n    - `字符` * `数字` = `新字符`；这里字符和数字可以分别存在两个栈，也可以存在一个栈，判断条件不同；\r\n\r\n需要注意的地方\r\n\r\n- 因为用的是栈，所以每次pop之后，得到的String顺序是反的，数字也是反的，得reverse；\r\n- 注意每次数字部分都需要reverse再做repeat操作；但字符只需要最后对res做reverse操作，如果在循环体就对字符做reverse，比较容易混淆；\r\n- String操作，要避免`str = str + \"abc\"`或`str = \"abc\" + str`这类操作，因为它们是O(N)的；虽然每次操作的N不是很大，但最坏的情况可以和s.length()一样，最终导致O(N^2);\r\n- 用StringBuilder.append来做，是O(1)的。而且可以很方便的使用reverse()方法。\r\n\r\n\r\n\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<String> stack = new Stack<>();\r\n        \r\n        for(int i = 0;i < s.length();i++){\r\n            if(s.charAt(i) == ']'){\r\n                //get chars inside []\r\n                StringBuilder s_sb = new StringBuilder();\r\n                while(!stack.isEmpty() && !stack.peek().equals(\"[\")){\r\n                    s_sb.append(stack.pop());\r\n                }\r\n                stack.pop();//for '['\r\n                \r\n                //get numeric multiplier\r\n                StringBuilder n_sb = new StringBuilder();\r\n                while(!stack.isEmpty() && stack.peek().charAt(0) <= '9' && stack.peek().charAt(0) >= '0'){\r\n                    n_sb.append(stack.pop());\r\n                }\r\n                \r\n                stack.add(s_sb.toString().repeat(Integer.valueOf(n_sb.reverse().toString())));\r\n            } else {\r\n                stack.add(String.valueOf(s.charAt(i)));\r\n            }\r\n        }\r\n        \r\n        StringBuilder resb = new StringBuilder();\r\n        while(!stack.isEmpty()){\r\n            resb.append(stack.pop());\r\n        }\r\n        return resb.reverse().toString();\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\nO(N)，循环体会从头到尾遍历s.length();\r\nO(N)，要维护一个栈；\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yiwchen":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916330275","body":"思路：\nadd with carry\n\nPython:\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        n = len(num)\n        while(n > 0 or k > 0):\n            if n > 0:\n                k += num[n - 1]\n            k, r = divmod(k, 10)\n            res.append(r)\n            n -= 1\n        return res[::-1]\n```\nC++:\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        int sum;\n        for (int i = n - 1; i >=0; --i){\n            \n            /*Calculation of current digit*/\n            \n            sum = num[i] + k % 10;\n            k /= 10;\n            \n            /*Add the carry to k if there is any*/\n            \n            if (sum >= 10){\n                k++;\n                sum -= 10;\n            }\n            \n            /*Append the sum to the end*/\n            \n            res.push_back(sum);\n        }\n        \n        /* Append the rest of k to the end if k is bigger than n*/\n        \n        for (k = k; k > 0; k/= 10){\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n复杂度分析:\n\n时间复杂度：O(len(A) + len(str(k)) + len(res)) = O(max(len(A), len(str(k))))\n空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qixuan-code":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916334960","body":"[LC 989. Add to Array-Form of Integer](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n**思路**\n- 把num list转化成数字\n- 数字和k相加\n- 相加的和转化成list\n\n**python代码**\n```class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        true_number = 0\n        result = []\n        if k == 0 and len(num) == 1:\n            return num\n        for i in range(n):\n            true_number = true_number + num[i]*10**(n-i-1)\n\n        add_up = true_number + k\n        while add_up:\n            result.append(add_up%10)\n            add_up = add_up//10\n\n        return result[::-1]\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917085339","body":"[821. Shortest Distance to a Character](https://leetcode.com/problems/shortest-distance-to-a-character/)\n\n**comment**\nRuntime: 146 ms beat 5%\n\n**python代码**\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        temp = []\n        res = []\n        for i in range(len(s)):\n            if s[i] == c:\n                temp.append(i)\n        \n        for j in range(len(s)):\n            a = [abs(x-j) for x in temp]\n            res.append(min(a))\n            \n        return res\n```\n**复杂度分析**\n- 时间复杂度：O(N^2+N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917650395","body":"[LC 1381. Design a Stack With Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n\n\n\n**python代码**\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.size = maxSize\n        self.stk = []\n        self.current_position = 0\n\n    def push(self, x: int) -> None:\n        if self.current_position < self.size:\n            self.stk.append(x)\n            self.current_position +=1\n\n    def pop(self) -> int:\n        if self.current_position == 0:\n            return -1\n        self.current_position -=1\n        return self.stk.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,self.current_position)):\n            self.stk[i] += val\n```\n\n**复杂度分析**\n- 时间复杂度：O(k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JiangyanLiNEU":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916335257","body":"### Two ideas hit me when I saw this problem.\n* convert array num to integer --> add k to the integer --> convert new integer to array --> return this array\n* Use k as carry on number, and keep adding it to the elements in num until k is 0. Note that, we might  need to insert elements into num array.\n\n### Here is my implement:\n* #### Convert idea ( Runtime = O( len(num) ), Space = O( len(num) ) )\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        # convert array num into string version\n        num_string = ''\n        for n in num:\n            num_string += str(n)\n\n        # add num and k, and convert it to string version\n        num_add_k_string = str(int(num_string) + k)\n\n        # convert result into array of int version\n        toReturn = [ int(i) for i in num_add_k_string ]\n        return toReturn\n```\n\n* #### carry k idea ( Runtime = O( len(num) ), Space = O(1) )\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        # add k into the last digit of num, and check if there should be a carryOn number\n        num[-1] += k\n        if num[-1] < 10:\n            return num\n        # if no carryOn number, then just return num, otherwise, we keep adding carry on into previous digit and update carryOn\n        carryOn = num[-1]//10\n        num[-1] = num[-1]%10\n        index = -2\n        while carryOn != 0:\n            # when there are enough digits for us to add\n            if index >= -len(num):\n                num[index] += carryOn\n            # we need to insert new digit at the beginning of the array\n            else:\n                num.insert(0, carryOn)\n            carryOn = num[index] // 10\n            num[index] %= 10\n            index -= 1\n        return num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917119307","body":"#### Two ideas\n##### Straightforward way (Runtime = O(n), Space = O(n))\n* I get all the index of letter c in s\n* CASE1,  any letter before the first c letter, the distance will be (c_index - letter_index) \n* CASE2, any letter in between two c letters, we need to find the middle point. The distance will be (letter_index-c_index) and then after middle point, it will be (c_index-letter_index) \n* CASE3, any letter after the last c letter, the distance will be (letter_index - last_c_index)\n\n##### forward and backward update (Runtime = O(n), Space = O(n))\n* Iterate from left to right, the distance is always the distance to the right nearest letter c\n* Iterate from right to left, update the distance to be the minimum distance of current one and distance to the left nearest letter c\n\n#### Implement straightforward idea\n``` python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        # get all the location of letter c\n        c_location = [i for i in range(len(s)) if s[i]==c\n        result = []\n        #case 1\n        for i in range(c_location[0]+1):\n            result.append(c_location[0]-i)\n        #case 2\n        while len(c_location) >= 2:\n            popStart = c_location.pop(0)\n            endAt = c_location[0]\n            index = popStart + 1\n            while index <= (endAt+popStart)//2:\n                result.append(index-popStart)\n                index += 1\n            while index <= endAt:\n                result.append(endAt-index)\n                index+=1 \n        #case 3\n        for i in range(c_location[0]+1,len(s)):\n            result.append(i-c_location[0])\n        return result\n```\n\n#### Implement smarter idea\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        result = [float('inf') for i in s]\n        last_c = -float('inf')\n        for i in range(len(s)):\n            if s[i] == c:\n                last_c = i\n                result[i] = i-last_c\n            else:\n                result[i] = i-last_c\n        last_c = float('inf')\n        for i in range(len(s)-1, -1,-1):\n            if s[i] == c:\n                last_c = i\n            result[i] = min(result[i], last_c - i)\n        return result \n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917453838","body":"#### follow the instructions and it is easy to implement\n```python\nclass CustomStack(object):\n    def __init__(self, maxSize):\n        self.stack = []\n        self.limit = maxSize\n        self.length = 0\n\n    def push(self, x):\n        if self.length < self.limit:\n            self.stack.append(x)\n            self.length += 1\n\n    def pop(self):\n        if self.length == 0:\n            return -1\n        else:\n            num = self.stack.pop()\n            self.length -= 1\n            return num\n\n    def increment(self, k, val):\n        for i in range(min(k,self.length)):\n            self.stack[i] += val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917685897","body":"#### Idea\nI use stack to solve this problem. The main idea is:\n* an array called left to store all the elements we saw//processed\n* when we see a number element, we check if this digit belong to a greater number (for examplt, if we got '0' and the last element in left is '3', so obviously, we make it to '30'), if so, we add this one to the previous on in left array, otherwise we append this number into left array\n* when we see [ elements, we record its index in an array called firstpart.\n* when we see ] elements, we need to find its match [ part in firstpart array. then we know, the number is right before the [ elements and the segments needed to be repeated is after [ elements. Then we process this segment and append it to the left array. In the meantime, we need to update the index, so we can keep track of the location of [.\n\n####Implement ( Runtime=O(n), space=(n))\n```python\nclass Solution(object):\n    def decodeString(self, s):\n        def process(time, array):\n            seg = ''.join(array)\n            return seg*time\n    \n        result = ''\n        \n        firstpart = []\n        left = []\n        index = -1\n        while s:\n            cur = s[0]\n            s = s[1:]\n            \n            if left and left[-1].isnumeric() and cur.isnumeric():\n                left[-1] += cur\n            else:\n                left.append(cur)\n                index += 1\n                if cur == '[':\n                    firstpart.append(index)\n                elif cur == ']':\n                    match = firstpart.pop()\n                    time = int(left[match-1])\n                    seg = left[match+1:index]\n                    index = match-2+1\n                    left = left[:match-1]\n                    left.append(process(time, seg))\n        return ''.join(left)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZT4188":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916338863","body":"思路：\n历遍数组\n\nPython:\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        K = list(map(int,str(K)))\n        \n        res = []\n        i,j = len(A)-1,len(K)-1\n        carry = 0\n\n        while i >= 0 and j >= 0:\n            res.append(A[i] + K[j] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            i -= 1\n            j -= 1\n        while i >= 0:\n            res.append(A[i] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            i -= 1\n        while j >= 0:\n            res.append(K[j] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            j -= 1\n\n        if carry:\n            res.append(1)\n\n        return res[::-1]\n\n时间复杂度：O(N+max(0,K−N) \n空间复杂度：O(1)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917407266","body":"class Solution(object):\n    def shortestToChar(self, S, C):\n        prev = float('-inf')\n        ans = []\n        for i, x in enumerate(S):\n            if x == C: prev = i\n            ans.append(i - prev)\n\n        prev = float('inf')\n        for i in xrange(len(S) - 1, -1, -1):\n            if S[i] == C: prev = i\n            ans[i] = min(ans[i], prev - i)\n\n        return ans\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Jackielj":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916352332","body":"### LC 989. Add to Array-Form of Integer\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new LinkedList<>();\n        int i = num.length - 1;\n        int carry = 0;\n        while (i >= 0 || k > 0 || carry > 0) {\n            int fromNum = i >= 0 ? num[i] : 0;\n            int fromK = k % 10;\n            int val = fromNum + fromK + carry;\n            list.add(0, val % 10);\n            carry = val > 9 ? 1 : 0;\n            k = k / 10;\n            i--;\n        }\n        return list;\n    }\n}\n\n```\n### 时空复杂度：\n时间：O(Math.max(len(num), len(k.toString()))\n\n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Daniel-Zheng":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916354433","body":"### 思路\r\n从末位开始，向vector里添加各对应位置数字与进位之和。如原数组里各位置已加完，则需处理K中剩余数字与进位之和。\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int carry = 0;\r\n        vector<int> res;\r\n        for (int i = num.size() - 1; i >= 0; i--) {\r\n            res.push_back((carry + num[i] + k % 10) % 10);\r\n            carry = (carry + num[i] + k % 10) / 10;\r\n            k /= 10;\r\n        }\r\n        carry = carry + k;\r\n        while (carry) {\r\n            res.push_back(carry % 10);\r\n            carry /= 10;\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N + logN + Max(0, K - N)^2)，N为数组A的长度，K为K的长度。 \r\n- 空间复杂度：O(Max(1, K - N))，N为数组A的长度，K为K的长度。 ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917313085","body":"### 思路\n找到C的左边界和右边界，计算边界内的字符到每个边界的值。\n\n### 代码(C++)\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> res;\n        int n = s.size() - 1;\n        int left = s[0] == c ? 0 : n;\n        int right = s.find(c, 1);\n        \n        for (int i = 0; i <= n; i++) {\n            res.push_back(min(abs(i - left), abs(i - right)));\n            if (i == right) {\n                left = right;\n                right = s.find(c, right + 1);\n            }\n        }\n        return res;\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(N)，N为S的长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917560532","body":"### 思路\n用Vector来模拟Stack\n\n### 代码(C++)\n```C++\nclass CustomStack {\npublic:\n    vector<int> res;\n    int count = 0;\n    int size;\n    \n    CustomStack(int maxSize) {\n        res.resize(maxSize);\n        size = maxSize;\n    }\n    \n    void push(int x) {\n        if (count == size) return;\n        res[count++] = x;\n    }\n    \n    int pop() {\n        if (count == 0) return -1;\n        return res[--count];\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i < min(count, k); i++) res[i] += val;\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(min(K, Count))\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916360004","body":"# 思路\r\n从后往前加，直到没有为止\r\n\r\n# 代码(Python3)\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = 0\r\n        add1 = 0\r\n        add2 = 0\r\n        stop1Flag = False\r\n        stop2Flag = False\r\n        \r\n        resultStack = []\r\n        \r\n        k_int = list(map(int,str(k)))\r\n        \r\n        index = -1\r\n        while(True):\r\n            try:\r\n                add1 = num[index]                \r\n            except:\r\n                stop1Flag = True\r\n                add1 = 0\r\n                \r\n            try:\r\n                add2 = k_int[index]\r\n            except:\r\n                stop2Flag = True\r\n                add2 = 0\r\n            \r\n            index -= 1\r\n            \r\n            if(stop1Flag and stop2Flag):\r\n                if carry != 0:\r\n                    resultStack.append(carry)\r\n                break\r\n            else:\r\n                resultStack.append((add1 + add2 + carry)%10)\r\n                carry = (add1 + add2 + carry)//10\r\n        return (list(resultStack[::-1])\r\n```\r\n# 复杂度分析\r\n时间复杂度：O(N + Max(0, K - N)^2)，N为数组A的长度，K为K的长度。\r\n空间复杂度：O(Max(1, K + N))，N为数组A的长度，K为K的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917127990","body":"# 思路\n计算出c的所有位置，让s中的每个字符的位置相减，去最小值\n\n# 代码\n```python3\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        index = 0\n        locations = []\n        for idx, letter in enumerate(s):\n            if letter == c:\n                locations.append(idx)\n                \n        indexes = range(len(s))\n        difference = [ abs(x - locations[0]) for x in indexes]\n        \n        for i in range(1,len(locations)):\n            difference = [ min(difference[x] , abs(x - locations[i])) for x in indexes]\n            \n        return difference\n```\n\n# 复杂度\nTime: O(n*k)\nSpace: O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917466321","body":"# 思路\nstack内容用array来存储\n\n# 代码\n```python3\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.currentStack = []\n\n    def push(self, x: int) -> None:\n        if(len(self.currentStack) < self.maxSize):\n            self.currentStack.append(x)\n\n    def pop(self) -> int:\n        if(len(self.currentStack) > 0):\n            return self.currentStack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k , len(self.currentStack))):\n            self.currentStack[i] += val   \n```\n\n# 复杂度\n## 时间复杂度\npush : O(1)\n\npop :   O(1)\n\nincrement : min(O(K), O(N));\n## 空间复杂度\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917820784","body":"# 思路\n遇到[就把前面的字符串和数字压入stack,存储当前[]内的字符，直到遇见]，则弹出stack，把重复次数的当前字符增加在前字符后面\n\n# 代码\n```python3\nclass Solution:\n    def decodeString(self, s: str) -> str:        \n        k_number = 0        \n        resultString = \"\"        \n        decoded_string = []        \n        for char in s:\n            if char.isnumeric():\n                k_number = 10 * k_number + int(char)\n            elif char == \"[\":\n                decoded_string.append(resultString)\n                decoded_string.append(k_number)\n                k_number = 0\n                resultString = \"\"\n            elif char == \"]\":\n                current_k = decoded_string.pop() \n                currentString = decoded_string.pop()\n                resultString = currentString + current_k * resultString\n                \n            else:\n                resultString += char\n        return resultString\n```\n\n# 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"RonghuanYou":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916378066","body":"按照加法的运算顺序从后往前遍历，r是余数，也就是做完加法后的当前位的值\nk是除去最后一位的值\n结束循环，如果k>0，就要一直处理最后的carry，就是k%10放入output array\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sumArr = []\n        for i in range(len(num) - 1, -1, -1):\n            r = (num[i] + k) % 10\n            k = (num[i] + k) // 10\n            sumArr.append(r)\n            \n        while k > 0:\n            sumArr.append(k % 10)\n            k = k // 10\n        return sumArr[::-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917355278","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        shortest_dis_arr = [len(s)] * len(s)\n        for i in range(len(s)):\n            if s[i] == c:\n                shortest_dis_arr[i] = 0\n        \n        for i in range(1, len(s)):\n            shortest_dis_arr[i] = min(shortest_dis_arr[i], shortest_dis_arr[i-1]+1)\n       \n        for i in range(len(s) - 2, -1, -1):\n            shortest_dis_arr[i] = min(shortest_dis_arr[i], shortest_dis_arr[i+1]+1)\n\n        return shortest_dis_arr\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917448503","body":"```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        return self.stack.pop() if len(self.stack) > 0 else -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range (min(k, len(self.stack))):\n            self.stack[i] += val\n        \n\n# time complexity: \n# push(), pop(): O(1), increment(): O(min(k, n))\n# space complexity: O(N) N is max size\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pophy":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916379125","body":"## Java代码\r\n\r\n```java\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        Stack<Integer> stack = new Stack<>();\r\n        int borrow = 0;\r\n        int i = num.length - 1;\r\n\r\n        while (k != 0 || i >= 0 || borrow != 0) {\r\n            int currentNumber;\r\n           if (i >= 0 && k != 0) {\r\n                currentNumber = num[i] + k % 10;\r\n           } else if (i >=0) {\r\n               currentNumber = num[i];\r\n           } else {\r\n               currentNumber = k % 10;\r\n           }\r\n            stack.add((currentNumber + borrow) % 10);\r\n            borrow = (currentNumber + borrow) / 10;\r\n            k = k / 10;\r\n            i--;\r\n        }\r\n\r\n        while (!stack.isEmpty()) {\r\n            res.add(stack.pop());\r\n        }\r\n        return res;\r\n    } \r\n```\r\n\r\n## 时间复杂度\r\n\r\nO(n)\r\n\r\n## 空间复杂度\r\n\r\nO(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917164588","body":"### 思路\r\n\r\n- 暴力解\r\n  - 从前遍历字符串中每一个char 到 target的距离， O(N^2)\r\n- 优化解\r\n  - 首先遍历字符串 找到target在字符串中的位置 并记录在index queue中\r\n  - 设置两个指针 pre = MIN_VALUE 和 next = queue.peek()， 分别代表target在字符串中出现的前一个和后一个位置\r\n  - 再次遍历字符串 当前距离 = Math.min(i-pre,  next -i)\r\n  - 果current Index == queue.peek(), pre = currentIndex, queue.poll()\r\n\r\n### Java Code\r\n\r\n```java\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        Queue<Integer> indexQueue = new LinkedList();\r\n        for (int i=0; i<s.toCharArray().length;i++) {\r\n            if (s.charAt(i) == c) {\r\n                indexQueue.add(i);\r\n            }\r\n        }\r\n        int pre = -1;\r\n        for (int i=0; i<s.toCharArray().length;i++) {\r\n            int next = indexQueue.peek();\r\n            res[i] = pre < 0 ? Math.abs(next-i) : Math.min(Math.abs(i-pre),Math.abs(next-i));\r\n            if (i == indexQueue.peek() && indexQueue.size() > 1) {\r\n                pre = indexQueue.peek();\r\n                indexQueue.poll();\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n### 时间 & 空间 复杂度\r\n\r\n- O(n)\r\n- O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917469345","body":"## 思路\n\n**核心： lazy evaluation**\n\n- 直到pop的时候 才处理增量问题\n\n- 利用额外的list来记录所有的增量\n- pop的时候 查询该位置的增量数据 + 原始数据\n\n## Java Code\n\n```java\nclass CustomStack {\n\n    int MAX_SIZE;\n    Stack<Integer> stack;\n    int[] increment;\n\n    public CustomStack(int maxSize) {\n        MAX_SIZE = maxSize;\n        //default to 0\n        increment = new int[2000];\n        stack = new Stack<>();\n    }\n\n    public void push(int x) {\n        if (stack.size() >= MAX_SIZE) {\n            return;\n        }\n        stack.push(x);\n    }\n\n    public int pop() {\n        if (stack.isEmpty()) {\n            return -1;\n        }\n        int incrementValue = increment[stack.size() - 1];\n        //reset increment\n        increment[stack.size() - 1] = 0;\n        return stack.pop() + incrementValue;\n    }\n\n    public void increment(int k, int val) {\n        int incrementSize = Math.min(k,stack.size());\n        for (int i = 0; i < incrementSize; i++) {\n            increment[i] = increment[i] + val;\n        }\n    }\n}\n\n\n```\n\n## 时间复杂度\n\n### push/pop\n\n- O(1)\n\n### increment\n\n- O(k)\n\n### 空间复杂度\n\n- O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917705204","body":"## 思路\n\n- 利用两个stack，stringStack / counterStack\n- 遍历表达式 当前字符记为c， index i\n  - 如果 c 是数字\n    - c 的下一位也是数字， 则一直向后拓展到 j, subString(i,j)转为数字 压入counterStack\n  - 如果c == '[' 表示 subString开始，向stringStack中压入空串 “”\n  - 如果是c == ']' 表示sub string结束\n    - counterStack弹出counter数值\n    - stringStack弹出当前substring\n    - 循环counter次substring, 压回stringStack\n  - 非[ / ] 表示当前字符为substing中的一个 stringStack .push(stringStack.pop() + c)\n- 最后stringStack中的string就是答案\n\n## Java code\n\n```java\n    public String decodeString(String s) {\n        Stack<String> stringStack = new Stack();\n        Stack<Integer> counterStack = new Stack();\n        stringStack.push(\"\");\n        //starting index\n        int i = 0;\n        while (i < s.length()) {\n            Character c = s.charAt(i);\n            //match number\n            if (c >= '0' && c <= '9') {\n                int j = i + 1;\n                while (s.charAt(j) >= '0' && s.charAt(j) <= '9') {\n                    j++;\n                }\n                counterStack.push(Integer.parseInt(s.substring(i, j)));\n                i = j;\n            } else {\n                //match string\n                if (c == '[') {\n                    stringStack.push(\"\");\n                } else if (c == ']') {\n                    int counter = counterStack.pop();\n                    StringBuilder sb = new StringBuilder();\n                    String subString = stringStack.pop();\n                    for (int k = 0; k < counter; k++) {\n                        sb.append(subString);\n                    }\n                    stringStack.push(stringStack.pop() + sb);\n                } else {\n                    stringStack.push(stringStack.pop() + c);\n                }\n                i++;\n            }\n        }\n        return stringStack.pop();\n    }\n```\n\n## 时间复杂度 & 空间复杂度\n\n- 时间\n  - O(n)\n- 空间\n  - O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ninghuang456":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916390741","body":"JAVA code:\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int carry = 0;\r\n        int index = A.length - 1;\r\n        while(K > 0 || index >= 0){\r\n            int curK = K % 10;\r\n            int curA = index >= 0 ? A[index]: 0;\r\n            int curDigitSum = curK + curA + carry;\r\n            int toBeAdded = curDigitSum % 10;\r\n            carry = curDigitSum / 10;\r\n            index --;\r\n            K /= 10;\r\n            res.addFirst(toBeAdded);\r\n        }\r\n        if(carry != 0){\r\n            res.addFirst(1);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\nTime: O(n);\r\nSpace: O(n);\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zol013":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916408530","body":"Python 3 code:\r\n     \r\n    class Solution:\r\n         def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n              if num[0] == 0 and k == 0:\r\n                 return [0]\r\n              inputnum = 0\r\n              for number in num:\r\n                   inputnum = inputnum * 10 + number\r\n              summ = inputnum + k \r\n              res = []\r\n              while summ > 0:\r\n                      digit = summ % 10\r\n                      res.append(digit)\r\n                      summ = summ // 10\r\n              return res[::-1]\r\n\r\nTime Complexity: O(n) because we run through the given array one time\r\nSpace Complexit: O(n) because we created a new array res to record the sum","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917213167","body":"two pointers: for each character in the string we initialize two points L and R before and after the current character. Then we decrease the left pointer and increase the right pointer until the target character is found on the left side and right side of the current character. Then we record the minimum of the two distances. \r\nPython 3 code: \r\n\r\n    class Solution:\r\n         def shortestToChar(self, s: str, c: str) -> List[int]:\r\n               ans = []\r\n               for i in range(len(s)):\r\n                    left_val = len(s)\r\n                    right_val = len(s)\r\n                    if s[i] == c:\r\n                       ans.append(0)\r\n                       continue\r\n                    l , r = i - 1, i + 1\r\n                    while r <= len(s)-1:\r\n                             if s[r] == c:\r\n                                right_val = r - i\r\n                                break\r\n                             else:\r\n                                   r += 1\r\n                    while l >= 0:\r\n                             if s[l] == c:\r\n                               left_val = i - l\r\n                               break\r\n                             else:\r\n                                   l -= 1\r\n                   ans.append(min(left_val, right_val))\r\n               return ans\r\nTime complexity O(n^2) we scan through the string twice.\r\nSpace Complexity O(n) we record the distances in an list 'ans'","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917477332","body":"Python 3 code:\r\n            \r\n    class CustomStack:\r\n    \r\n            def __init__(self, maxSize: int):\r\n                  self.stack = [-10]* maxSize\r\n                  self.cur_pt = -1\r\n            def push(self, x: int) -> None:\r\n                  if self.stack[-1] == -10:\r\n                     self.stack[self.cur_pt + 1] = x\r\n                     self.cur_pt += 1\r\n            def pop(self) -> int:\r\n                  if self.cur_pt != -1:\r\n                     pop_val = self.stack[self.cur_pt]\r\n                     self.stack[self.cur_pt] = -10\r\n                     self.cur_pt -= 1\r\n                     return pop_val\r\n                  else:\r\n                      return -1\r\n\r\n            def increment(self, k: int, val: int) -> None:\r\n                  cur_size = min(self.cur_pt + 1, k)\r\n                  for i in range(cur_size):\r\n                       self.stack[i] += val\r\n\r\n\r\nTime Complexity: pop, push: O(1) \r\n                             increment: O(n) in worst case\r\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917820830","body":"Python 3 code:\r\n\r\n      class Solution:\r\n           def decodeString(self, s: str) -> str:\r\n                  stack = []\r\n                  for char in s:\r\n                       if char != ']':\r\n                           stack.append(char)\r\n                        else:\r\n                             cur_str = ''\r\n                             itr_iter = ''\r\n                             while stack and stack[-1] != '[':\r\n                                   cur_str = stack.pop() + cur_str\r\n                                    stack.pop()\r\n                              while stack and stack[-1].isdigit():\r\n                                   str_iter = stack.pop() + str_iter\r\n                                   int_iter = int(str_iter)\r\n                               stack.append(cur_str * int_iter)\r\n                  return ''.join(stack)\r\nTime complexity: O(N) N = length of decoded string\r\nSpace Complexity: O(N)\r\n        ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qyw-wqy":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916408891","body":"## 代码\nJava:\n```\n public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        int i = num.length-1;\n        int carry = k;\n        while (i >= 0 || carry > 0) {\n            int n = i >= 0 ? num[i--] : 0;\n            carry += n;\n            list.add(carry % 10);\n            carry /= 10;\n        }\n        \n        Collections.reverse(list);\n        return list;\n    }\n```\nTime：O(n)     \nSpace：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917565819","body":"## 代码\r\n\r\n用一个数组来记录累计累加的值\r\n```\r\nclass CustomStack {\r\n    int[] inc;\r\n    Deque<Integer> stack;\r\n    int maxSize;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        this.inc = new int[maxSize];\r\n        this.stack = new ArrayDeque<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (stack.size() == maxSize) return;\r\n        stack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (stack.isEmpty()) return -1;\r\n        int index = stack.size() - 1;\r\n        if (index > 0) inc[index - 1] += inc[index];\r\n        int val = stack.pop() + inc[index];\r\n        inc[index] = 0;\r\n        return val;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int index = Math.min(k - 1, stack.size() - 1);\r\n        if (index < 0) return;\r\n        inc[index] += val;\r\n    }\r\n}\r\n```\r\n复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917738072","body":"## 代码\nJava:\n```\nclass Solution {\n    int i = 0;\n    public String decodeString(String s) {\n        StringBuilder sb = new StringBuilder();\n        while (i < s.length()) {\n            if (Character.isDigit(s.charAt(i))) {\n                int num = 0;\n                while (i < s.length() && Character.isDigit(s.charAt(i))) {\n                    num = num * 10 + s.charAt(i++) - '0';\n                }\n                i++; //skip '['\n                String next = decodeString(s);\n                while (num-- > 0) sb.append(next);\n            } else if (s.charAt(i) == ']') {\n                i++; // skip '['\n                return sb.toString();\n            } else {\n                sb.append(s.charAt(i++));\n            }\n        }\n        \n        return sb.toString();\n    }\n}\n```\nComplexity: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skinnyh":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916409263","body":"# Solution1\n\nUse while loop to add K to num digit by digit. Maintain the carry and end the loop when carry is 0 and all digits from K has been added. Note that inserting to the list head is not efficient.\n\n# Code\n\n```python\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry, idx = 0, len(num) - 1\n        while k > 0 or carry > 0:\n            digit = k % 10\n            k = k // 10\n            if idx < 0:\n                num.insert(0, 0)\n                i = 0\n            else:\n                i = idx\n            tmp = num[i] + digit + carry\n            num[i] = tmp % 10\n            carry = tmp // 10\n            idx -= 1\n        return num\n```\n\nTime complexity: O(N + max(0, K - N)^2), K is length of k and N is length of num\n\nSpace complexity: O(max(1, K - N))\n\n# Solution2\n\nCreate another result array and always append the digit sum to the result end to avoid insert to head. Reverse the result list before return. The while loop end condition will also need to check if it has traversed all the num list.\n\n# Code\n\n```python\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry, idx = 0, len(num) - 1\n        res = []\n        while idx >= 0 or k > 0 or carry > 0:\n            digit = k % 10\n            k = k // 10\n            n = num[idx] if idx >= 0 else 0\n            res.append((n + digit + carry) % 10)\n            carry = (n + digit + carry) // 10\n            idx -= 1\n        return reversed(res)\n```\n\nTime complexity: O(N)\n\nSpace complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917162074","body":"# Note\n\nRecord the occurrence of char c in a list c_idx. Then use two pointers i and p to iterate S and c_idx. For each i, compare the distance with p and p+1 until find the closest p.\n\nThe space complexity can be improved. Instead of saving the c positions, we can scan the S twice from **left to right and from right to left**. So that each char will be able to compare to the closest C on its left and right.\n\n# Solution1\n\n```python\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res, c_idx = [], []\n        for i, ch in enumerate(s):\n            if ch == c:\n                c_idx.append(i)\n        p = 0\n        for i in range(len(s)):\n            while (p < len(c_idx) - 1 and abs(c_idx[p + 1] - i) < abs(c_idx[p] - i)):\n                p += 1\n            res.append(abs(c_idx[p] - i))\n        return res\n```\n\nTime complexity: O(2N + K) where N is the length of s and K is occurrence count of c.\n\nSpace complexity: O(K) to save the char occurrence positions.\n\n# Solution2\n\n```python\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n, c_idx = len(s), float('-inf')\n        res = [n] * n\n        for i in range(n):\n            if s[i] == c: c_idx = i\n            res[i] = min(res[i], abs(i - c_idx))\n        for i in range(n)[::-1]:\n            if s[i] == c: c_idx = i\n            res[i] = min(res[i], abs(i - c_idx))\n        return res\n```\n\nTime complexity: O(2N) where N = len(s)\n\nSpace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917662219","body":"# Note\n\n- Naive method to implement inc() by adding val to first k elements will take O(k) time.\n- Since we only get number from stack with the pop() method, we can use lazy increment idea. Let inc[i] means for all elements stack[0] ~ stack[i], we should plus inc[i] when popped from the stack. After we pop a number from stack,  inc[i-1]+=inc[i]. Thus inc() becomes O(1)\n\n# Solution\n\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.max_size = maxSize\n        self.list = []\n        # inc[i] means for all elements stack[0] ~ stack[i],\n        # we should plus inc[i] when popped from the stack.\n        self.inc = []\n\n    def push(self, x: int) -> None:\n        if len(self.list) < self.max_size:\n            self.list.append(x)\n            self.inc.append(0)\n        \n    def pop(self) -> int:\n        if not self.list:\n            return -1\n        if len(self.inc) > 1:\n            self.inc[-2] += self.inc[-1]\n        return self.list.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k, len(self.inc)) - 1] += val\n```\n\nTime complexity: O(1)\n\nSpace complexity: O(N) N is the max_size","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leo173701":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916409706","body":"很笨的办法， 请忽略  \n时间复杂度 o(n),\n空间复杂度o(n)\n\n  `def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        n = len(num)\n        temp = 0\n        for i in range(n):\n            temp +=num[i]* (10**(n-1-i))     \n        b = temp + k\n        res = []\n        while b>9:\n            d = b%10\n            b = b//10\n            res.append(d)\n        res.append(b)\n        res.reverse()        \n        return res`\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917050689","body":"思路：维护一个滑动窗口[left, right]，不断调整窗口的位置\r\n          left=right\r\n          right = new location\r\n\r\n1. 第一遍遍历, 统计所在的位置temp\r\n2. 如果temp只有一个元素， 那就直接再遍历一次，直接返回结果res\r\n3. 如果temp 有2个及其以上元素，那就用滑动窗口\r\n时间复杂度： O(n)\r\n空间复杂度： O(n)\r\n\r\n`    Python3 :\r\ndef shortestToChar(self, s: str, c: str) -> List[int]:\r\n\r\n        temp = []\r\n        for i in range(len(s)):\r\n            if c==s[i]:\r\n                 temp.append(i)\r\n        res = [-1 for _ in range(len(s))]\r\n        # print(temp)\r\n        if len(temp)==1:\r\n            res = [abs(i-temp[0]) for i in range(len(s))]\r\n            return res\r\n        left = temp[0]\r\n        right = temp[1]\r\n        j=1\r\n        for i in range(len(s)):\r\n            if i<=temp[0]:\r\n                res[i] = temp[0]-i\r\n                continue\r\n            elif i>=temp[-1]:\r\n                res[i]=i-temp[-1]\r\n            elif i==left:\r\n                    res[i]=0\r\n            elif i==right:\r\n                res[i]=0\r\n                if j<(len(temp)-1):\r\n                    left = right\r\n                    j+=1\r\n                    right = temp[j]\r\n                    # print(\"now it's time to shift window, new left=\",left,\" right=\",right)\r\n            else:\r\n                res[i] = min(abs(i-left), abs(right-i))\r\n                # print(\"i is inside the window\")\r\n                # print(\"     i = \",i,\",res[i]=\",res[i])\r\n                # print(\"          left = \",left)\r\n                # print(\"          right = \",right)\r\n        return res`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kidexp":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916420802","body":"## Thinking\nassume  num length is n, k has m digits\n\nTake [1,2,3]+999 as an example\n\nFirst convert [1,2,3] into 123 which takes O(m)\n\nThen add 123 with 999 = 1122, which takes O(1)\n\nFinally convert 1122 to [1,1,2,2] which is O(max(m,n)+1)  = O(max(m,n)\n\n\n## Code\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        m = 0\n        for digit in num:\n            m = m * 10 + digit\n        sum_ = m + k\n        result = []\n        while sum_:\n            result.append(sum_ % 10)\n            sum_ //= 10\n        return result[::-1] if result else [0]\n\n```\n\n## Complexity\nTime: O(n)+O(1)+O(max(m,n) = O(m+n)\n\nSpace Complexity: O(max(m,n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917107545","body":"## Thoughts\nassume s length is n\n\ntake S = \"loveleetcode\", C = 'e' as an example\n\nfirst we compute the position of C in S, we can get T  [3,5,6,11], O(n), if S only contains chars of C then T will have same length as S.\n\nthen we can use one pointer (c_index) to indicate which position of C in S we are referring to \nwe iterate through S with index i, each time we will only compare at the position of current char in S with two positions in T, (c_index, and c_index+1), and chose the minimal difference \nWhenever s[I] is equal to next position in T, we will update c_index\n\nthe whole two pointers approach takes at most 2n which is O(n)\n\n## code \n```python\nfrom typing import List\n\n\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        positions = [i for i in range(len(s)) if s[i] == c]\n        c_index = 0\n        results = []\n        for i in range(len(s)):\n            if c_index < len(positions) - 1 and i == positions[c_index + 1]:\n                c_index += 1\n            if c_index == len(positions) - 1:\n                results.append(abs(i - positions[c_index]))\n            else:\n                results.append(\n                    min(abs(i - positions[c_index]), abs(positions[c_index + 1] - i))\n                )\n        return results\n\n```\n\n## Complexity\nTime complexity: O(n) \n\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917433569","body":"## thoughts\r\na straight forward solution is to have a stack, then push and pop is just reusing stack push and pop, which is O(1)\r\n\r\n when increment, we can do the increment  whenever we call increment and starts from the k, which makes increment O(k)\r\n\r\nA better solution is that  we can reuse lazy execution since increment is only done for the bottom k elements and there is no random delete/inserts, we can keep an inc array, whenever there is an increment operation, we just update inc[k] with val added to it. For push, we can append 0 to inc to make inc same size as stack, for pop, we need update pop last element of inc and add it to the new last element.\r\n\r\nFor the lazy execution solution, all operation will be O(1)\r\n\r\n```python\r\nclass CustomStack:\r\n    \"\"\"\r\n    O(k) increment\r\n    \"\"\"\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.max_size = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            return self.stack.pop()\r\n        return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i] += val\r\n\r\n\r\nclass CustomStack:\r\n    \"\"\"\r\n    O(1) increment\r\n    \"\"\"\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.max_size = maxSize\r\n        self.inc = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n            self.inc.append(0)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            if len(self.stack) > 1:\r\n                self.inc[-2] += self.inc[-1]\r\n            return self.stack.pop() + self.inc.pop()\r\n        return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.stack:\r\n            self.inc[min(k, len(self.stack)) - 1] += val\r\n```\r\n\r\n## Complexity:\r\n* time complexity: push/pop/increment O(1)\r\n* space complexity: O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917732631","body":"## thoughts\nvery typical stack problem,  we can iterate through the string, \n1. each time we face a digit, we keep adding the digit to the stack \n2. each time we face other char  that ']' we just append to stack \n3. each time we face ']' pop until ''[ to get string, then get num and multiple num with string and append to stack\nfinally we will have join all strings in stack and return it \n\n## code\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        \"\"\"\n        simplified version\n        \"\"\"\n        stack = []\n        i = 0\n        for i in range(len(s)):\n            if s[i].isdigit():\n                if stack and type(stack[-1]) is int:\n                    stack[-1] = stack[-1] * 10 + int(s[i])\n                else:\n                    stack.append(int(s[i]))\n            elif s[i] == \"]\":\n                temp_str = \"\"\n                while stack and stack[-1] != \"[\":\n                    temp_str = stack.pop() + temp_str\n                if stack and stack[-1] == \"[\":\n                    stack.pop()\n                if stack and type(stack[-1]) is int:\n                    repeat_num = stack.pop()\n                    stack.append(temp_str * repeat_num)\n            else:\n                stack.append(s[i])\n        return \"\".join(stack)\n\n```\n## complexity\ntime complexity : O(n)\nspace complexity: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"falconruo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916424749","body":"**思路:**\r\n1. 数组num的第1个元素num[0]表示整数的最高位数字, 第n个元素num[n - 1]代表整数的个位数字\r\n2. 新的整数的每一位数字由三个部分决定：num[i], 整数k的当前位(k % 10), 进位(carry)->sum = val + k % 10 + carry\r\n\r\n**复杂度分析:**\r\n- 时间复杂度: O(max(N, lgk))，N为数组num的长度, k为给定整数k\r\n- 空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int n = num.size() - 1;\r\n        vector<int> res;\r\n        int carry = 0, val = 0, sum = 0;\r\n        while (n >= 0 || k != 0) {\r\n            val = (n >= 0) ? num[n] : 0;\r\n            sum = val + k % 10 + carry;\r\n            res.push_back(sum % 10);\r\n            carry = sum / 10;\r\n            k /= 10;\r\n            n--;\r\n        }\r\n\r\n        if (carry)\r\n            res.push_back(carry);\r\n        \r\n        reverse(res.begin(), res.end());\r\n\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917118118","body":"**思路:**\r\n\r\n。从左到右依次遍历字符串S，比较每个字符与字符C的最短距离并存放到返回数组res中\r\n。从右到左依次遍历字符串S，比较每个字符与字符C的最短距离并与之前存放在数组res中的距离取小值\r\n\r\n**复杂度分析:**\r\n\r\n时间复杂度: O(n), n为字符串s的长度\r\n空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n\r\n```C++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> res(n, n - 1);\r\n\r\n        int idx = n - 1;\r\n        for (int i = 0; i < n; ++i) {\r\n            if (s[i] == c)\r\n                idx = i;\r\n            res[i] = min(res[i], abs(idx - i));\r\n        }\r\n\r\n        idx = 0;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            if (s[i] == c)\r\n                idx = i;\r\n            res[i] = min(res[i], abs(idx - i));\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917452191","body":"**思路:**\r\n1. 使用一个数组vector来模拟栈, 使用一个变量size表示栈的容量maxSize\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(k), k为给定长度, 其中push/pop: O(1)\r\n2. 空间复杂度: O(n), n为maxSize\r\n\r\n**代码(C++):**\r\n```C++\r\n语言： cpp\r\n\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        size = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (st.size() >= size) return;\r\n        st.push_back(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if (st.size() == 0) return -1;\r\n        int val = st.back();\r\n        st.pop_back();\r\n        return (val);\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int idx = (k <= st.size()) ? k : st.size();\r\n\r\n        for (int i = 0; i < idx; ++i)\r\n            st[i] += val;\r\n    }\r\nprivate:\r\n    int size;\r\n    vector<int> st;\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917712710","body":"**思路:**\r\n1. 使用辅助栈存放：\r\n- repeat次数\r\n- 临时子串\r\n- 子串\"[\"\r\n2. 遇到']', 连续出栈直至栈顶元素为\"[\", 将所有的字符串拼接在一起，存放在一个字符串tmp\r\n3. 将栈顶元素\"[\"出栈\r\n4. 继续取栈顶元素，此字符串为repeat次数k，将字符串tmp重复k次，存入新的子串ns并入栈\r\n5. 循环完毕依次将栈st的子串取出，按照顺序插入返回字符串res\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(m), m为给定字符串s长度\r\n2. 空间复杂度: O(n), n为decoded string长度\r\n\r\n**代码(C++):**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res = \"\";\r\n        stack<string> st;\r\n        int n = s.length();\r\n\r\n        for (int i = 0; i < n; ++i) {\r\n            string tmp = \"\";\r\n            if (isalpha(s[i])) {\r\n                while (isalpha(s[i])) {\r\n                    tmp += s[i];\r\n                    ++i;\r\n                }\r\n                --i;\r\n                st.push(tmp);\r\n            } else if (isdigit(s[i])) {\r\n                while (isdigit(s[i])) {\r\n                    tmp += s[i];\r\n                    ++i;\r\n                }\r\n                --i;\r\n                st.push(tmp);\r\n            } else if (s[i] == '[') {\r\n                tmp += s[i];\r\n                st.push(tmp);\r\n            } else if (s[i] == ']') {\r\n                while (st.top() != \"[\") { // add other alpha string into new\r\n                    tmp.insert(0, st.top());\r\n                    st.pop();\r\n                }\r\n                st.pop(); // \"[\"\r\n\r\n                int k = stoi(st.top()); // k\r\n                st.pop();\r\n\r\n                string ns = \"\";\r\n                while (k--) // expand substring tmp by k times\r\n                    ns += tmp;\r\n                st.push(ns);\r\n            }\r\n        }\r\n\r\n        while (!st.empty()) {\r\n            res.insert(0, st.top());\r\n            st.pop();\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"florenzliu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916425383","body":"**Explanation**\r\n\r\n- Convert k to its array-form. \r\n- Add the array-forms of num and k by digit from the end to the beginning and save it in the result array. \r\n- Reverse the array-form of the result. \r\n\r\nUse the quotient and remainder divided by 10: set the current position as the remainder and update the quotient for the next position.\r\n\r\n**Python**\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        newK = []\r\n        for i in str(k):\r\n            newK.append(int(i))\r\n        \r\n        result = []\r\n        i, j = len(num)-1, len(newK)-1\r\n        quotient, remainder = 0, 0\r\n        while i >= 0 or j >= 0:\r\n            currI = num[i] if i >= 0 else 0\r\n            currJ = newK[j] if j >= 0 else 0\r\n            curr = currI + currJ + quotient\r\n            result.append(curr % 10)\r\n            quotient = curr // 10\r\n            i -= 1\r\n            j -= 1\r\n            \r\n        if quotient != 0:\r\n            result.append(quotient)\r\n        return result[::-1]\r\n```\r\n\r\n**Complexity**\r\n\r\n- Time Complexity: ```O(max(N, logk))``` where N is the length of the ```num``` array.\r\n- Space Complexity: ```O(max(N, logk))``` \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917364782","body":"**Explanation**\n- Traverse from left. Find the shortest distance to a character from the left.\n- Traverse from right. Find the shortest distance to a character from the right.\n- Take the minimum of the two values to create the final answer \n\n**Python**\n\n```python\nclass Solution:\n    def shortestToChar(self, S: str, C: str) -> List[int]:\n        result = [math.inf for _ in range(len(S))]\n        \n        # traverse from left\n        curr = -math.inf\n        for i in range(len(S)):\n            if S[i] == C:\n                curr = i\n            result[i] = i - curr\n            \n        # traverse from right\n        curr = math.inf\n        for i in range(len(S)-1, -1, -1):\n            if S[i] == C:\n                curr = i\n            result[i] = min(curr-i, result[i])\n            \n        return result\n```\n\n**Complexity**\n\n- Time Complexity: ```O(N)``` where ```N``` is the length of the string ```S```.\n- Space Complexity: ```O(N)``` \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917552803","body":"**Explanation**\n- Use a list as a stack. Use count to keep a record of the number of elements in the stack. Use maxSize to remember max size.\n- ```push```: if stack has not reached maxSize, add the element to the end of the stack and update the count by +1.\n- ```pop```: if stack is not empty, pop the last element of the stack and update the count by -1. Otherwise, return -1\n- ```increment```: add ```val``` to the first k elements or the whole stack (if count < k)\n\n**Python**\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.count = 0\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if self.count < self.maxSize:\n            self.stack.append(x)\n            self.count += 1\n\n    def pop(self) -> int:\n        if self.count > 0:\n            self.count -= 1\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.count)):\n            self.stack[i] = self.stack[i] + val\n            \n        return result\n```\n\n**Complexity**\n\n- Time Complexity: ```O(1)``` for push and pop operations;  ```O(min(k, count))``` for increment operations where ```count``` is the length of the stack.\n- Space Complexity: ```O(1)``` \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916426832","body":"## Ripple Adder\r\nSimilar to the implementation of ripple adder, The adder will add numbers at the same position, output the sum of the current position, and pass the carry to the next bit.\r\n \r\n## Python\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], k: int) -> List[int]:\r\n        curSum = 0\r\n        carry = 0\r\n\r\n        # This can be achieved through continuing division, but I am lazy\r\n        if not A:\r\n            return [int(i) for i in str(k)]\r\n        elif not k:\r\n            return A\r\n\r\n        K = [int(i) for i in str(k)]\r\n        LA = len(A)-1\r\n        LK = len(K)-1\r\n\r\n        if LA <= LK:\r\n            target = K\r\n            idx = LK\r\n        else:\r\n            target = A\r\n            idx = LA\r\n        while LA >= 0 and LK >= 0:\r\n            curSum = A[LA] + K[LK] + carry\r\n            if curSum < 10:\r\n                target[idx] = curSum\r\n                carry = 0\r\n            else:\r\n                carry = curSum //10\r\n                target[idx] = curSum % 10\r\n            LA-=1\r\n            LK-=1\r\n            idx-=1\r\n        if LK != LA:\r\n            while idx >=0:\r\n                curSum = target[idx] + carry\r\n                if curSum < 10:\r\n                    target[idx] = curSum\r\n                    carry = 0\r\n                else:\r\n                    carry = curSum // 10\r\n                    target[idx] = curSum%10\r\n                idx-=1\r\n        if carry > 0:\r\n            target[0:0] = [carry]\r\n        return target\r\n```\r\n\r\nTime Complexity: O(max(K,A))\r\nSpace Complexity: O(max(K,A))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917027536","body":"## Thought\r\nTraverse the array twice, one time we traverse from left to right, the second time we traverse from the back. In the first iteration, we record a temporary variable for the index where `s[i] == c`, then we can know all the distance of a character with a `c` character behind it.  Then in the opposite direction, we determine if a `c`  on the left side or on the right side is the closest for it.\r\n\r\n## python\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        N = len(s)\r\n        ans = [100000] * N\r\n        closeLoc = -100000\r\n        for i in range(N):\r\n            if s[i] == c:\r\n                closeLoc = i\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(i-closeLoc, ans[i])\r\n        \r\n        closeLoc = 100000\r\n        for i in range(N-1, -1, -1):\r\n            if s[i] == c:\r\n                closeLoc = i\r\n            else:\r\n                ans[i] = min(closeLoc-i, ans[i])\r\n        \r\n        return and\r\n```\r\nTime Complexity: O(n)\r\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917451093","body":"## Thought\r\n模拟题\r\n## Python\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.size = 0\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.maxSize:\r\n            self.stack.append(x)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.size:\r\n            self.size -=1\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n    def increment(self, k: int, val: int) -> None:\r\n        k = min(k,self.size)\r\n        for i in range(k):\r\n            self.stack[i] += val\r\n```\r\n\r\nTime Complexity: push, pop: O(1) increment: O(min(k,size))\r\nSpace Complexity: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917777695","body":"## Thought\r\n这道题因为有“[”“]”, 所以我第一时间想到的是用stack（LIFO）。 我们能遍历整个字符串来看如何处理每个字符\r\n1. 如果当前字符为任意数字，我们便能添加当前数字进入一个叫`count `的字符串内\r\n2. 如果当前字符为任意字母，我们便能添加当前字母进入以及个叫`ans`的字符串内\r\n3. 如果当前字符为\"[\"，我们便需要把当前`count`和`ans`入栈，这里入栈是因为`ans`代表了当前'['外层我们想要的字符串，count则表示`[`内层需要重复的次数。入栈后当前`ans`和`count`清空\r\n4. 如果当前字符为\"]\", 我们则出栈得到\"[\" 之前的原ans+重复次数，让`ans`更新为原ans+重复次数*`ans`\r\n\r\n##Python\r\n```Python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        ans = \"\"\r\n        count = \"\"\r\n\r\n        for char in s:\r\n            if \"0\" <= char <= \"9\":\r\n                count += char\r\n            elif \"a\" <= char <= \"z\":\r\n                ans += char\r\n            elif char == \"]\":\r\n                pair = stack.pop()\r\n                ans = pair[1]+ int(pair[0])*ans\r\n                #count = \"\"\r\n            elif char == \"[\":\r\n                stack.append((count, ans))\r\n                count = \"\"\r\n                ans = \"\"\r\n        return ans\r\n``` \r\nTime Complexity: O(n) 遍历整个字符串\r\nSpace complexity: O(n) 最多有可能创建一个 n 长度的stack","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZhuMengCheng":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916429301","body":"思路:\r\n从末尾相加后截取末尾存储进位,, 测试用例: [2,1,5]  806  \r\n 比如806和5相加等于811 ,保存末尾1,\r\n继续相加为81+1=82. 保存2 类推,\r\n 8会和下一个2相加为10,  \r\n整个数组的值变成[10,2,1] 截取10的情况,可能计算次数超过数组长度.需要添加额外条件判断计算次数\r\n`/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let res = []\r\n    // k>0 如果遇到合为10需要多一次计算 ,查询条件不能限制为只有num数组的长度\r\n    for(let i = num.length-1 ;i>=0 || k > 0;--i){\r\n        // 大于0的位数直接相加后取余数进位\r\n        if(i >= 0){\r\n            k += num[i]\r\n        }\r\n        res.push(k % 10)\r\n        // 计算是否有等于10 或者大于0的情况,在执行下次进位\r\n        k  =   (k - k  % 10) / 10\r\n    }\r\n    return res.reverse()\r\n}`\r\n\r\n时间复杂度：O(max(n,log k))\r\n空间复杂度:  O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917405227","body":"思路: \n首先第一次循环找到所有目标元素的下标,第二次循环从头再次循环找到所有非目标元素和目标元素的下标差值.取绝对值并循环.因为索引数组indexList的值一直在增加.找到索引大于非目标元素下标的差值.循环IndexList并计算出最小值.\n```javascript\nvar shortestToChar = function(str, target) {\n    const indexList = []\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] == target) {\n            indexList.push(i)\n        }\n    }\n    const result = Array.from(str.length).fill('-1')\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] == target) {\n            result.push(0)\n            continue;\n        }\n        for (let k = 0; k < indexList.length; k++) {\n            const targetIndex = Math.abs(indexList[k] - i);\n            if (targetIndex >= result[i]) break;\n            result[i] = targetIndex;\n        }\n    }\n    return result\n};\n```\n时间复杂度:O(str*Target)\n空间复杂度:O(Target)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917795142","body":"# 思路两个栈存储倍数和需要翻倍的字符.判断[]位置翻倍存储当前字符..翻倍所有字符后拼接返回完整字符\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n    let num = 0;\n    let numStock = []\n    let resultStock = []\n    let result = ''\n    for (let str in s) {\n        if (!isNaN(s[str])) {\n            num = num * 10 + Number(s[str])\n        } else if (s[str] == '[') {\n            resultStock.push(result);\n            result = '';\n            numStock.push(num)\n            num = 0;\n        } else if (s[str] == ']') {\n            let copyNum = numStock.pop();\n            result = resultStock.pop() + result.repeat(copyNum);\n        } else {\n            result += s[str]\n        }\n    }\n    return result\n};\nconsole.log(decodeString('3[a]2[bc]'))\n```\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Lllouiselao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916434574","body":"[989. Add to Array-Form of Integer](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n#### 想法：最brutal way： traverse list->str->int->list \n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        str_turple = ''\n        for i in num:\n            str_turple += str(i)\n\n        str_int = int(str_turple) + k\n        int_str = str(str_int)\n\n        output = []\n        for n in int_str:\n            output.append(int(n))\n        return output\n```\n#### complexcity O(n^2) ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917574208","body":"[1381. Design a Stack With Increment Operation](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\r\n#### 想法：设计一个栈 用list的方式来实现 \r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack_len = 0\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.stack_len < self.maxSize:\r\n            self.stack.append(x)\r\n            self.stack_len +=1\r\n\r\n    def pop(self) -> int:\r\n        if self.stack_len == 0:\r\n            return -1\r\n        else:\r\n            self.stack_len -= 1\r\n            item = self.stack[self.stack_len]\r\n            del self.stack[self.stack_len]\r\n            return item\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(self.stack_len):\r\n            if i < k:\r\n                self.stack[i] = self.stack[i] + val\r\n            else:\r\n                return\r\n```\r\n\r\n#### complexcity pop:O(1) Push:O(1) increment:O(min(k, stack_len))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chen445":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916452724","body":"### 思路: \n\nFirst, we should convert k to list and iterate from back of the list. If the sum of two digits at the same position plus carry is greater than 10, then we set the carry to 1. The modulo of the sum is the result at that position. \n\n### 代码：\n```\n  def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        k=[int(x) for x in str(k)]\n        i=len(num)-1\n        j=len(k)-1\n        carry=0\n        result=deque([])\n        while i>=0 or j>=0:\n            a=num[i] if i >=0 else 0 \n            b=k[j] if j>=0 else 0\n            s=a+b+carry\n            carry=s//10\n            result.appendleft(s%10)\n            i-=1\n            j-=1\n        if carry != 0:\n            result.appendleft(carry)\n        return result\n```\n**复杂度分析**\n\nTime Complexity: O(n) n is the largest length of two numbers\n\nSpace Complexity: O(n) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917311617","body":"### 思路\r\nBefore the loop we need two variables prev(keep track the most recent index of c ) and j (everything before j in s has been calculated). We iterate from 0 to the end, if we found current index is c, we keep calculating min distance until j reach current index. We also update the prev.  \r\n\r\n### 代码\r\n```\r\ndef shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result=[-1]*len(s)\r\n        j=0\r\n        prev=None\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                while j<=i:\r\n                    if prev is not None:\r\n                        min_dis = abs(prev-j)\r\n                    else:\r\n                        min_dis = float('inf')\r\n                    min_dis=min(abs(j-i),min_dis)\r\n                    result[j]=min_dis\r\n                    j+=1\r\n                prev=i\r\n        while j < len(s):\r\n            result[j]=abs(prev-j)\r\n            j+=1\r\n        return result \r\n```\r\n### 复杂度\r\nTime: O(n) n is the length of s\r\nSpace: O(1) \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917546048","body":"### 思路\nusing array to implement stack\n\n### 代码\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack=[]\n        self.size_limit=maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.size_limit:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        return -1\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n ```    \n***复杂度***\n\nT: O(1)\n\nS: O(n) n is the length of stack","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917820792","body":"### 思路\r\n\r\nusing stack to keep track result, iterate each element into stack, if you see \"]\", start to pop until you see the \"[\".\r\n### 代码\r\n``` python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack=[]\r\n        for e in s:\r\n            if e==\"]\":\r\n                temp=[]\r\n                while stack[-1] != \"[\":\r\n                    temp.append(stack.pop())\r\n                stack.pop()\r\n                count=0\r\n                order=1\r\n                while stack and stack[-1].isnumeric():\r\n                    count+=int(stack.pop())*order\r\n                    order*=10\r\n                for i in range (count):\r\n                    stack.extend(temp[::-1])\r\n            else:\r\n                stack.append(e)\r\n        return \"\".join(stack)\r\n            \r\n```\r\n\r\n### 复杂度\r\nT: O(n)\r\nS: O(n) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JachinM":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916481597","body":"## Java\n#### 解题思路\n+ 整型数组开始与k相应的位上的数字相加（从个位开始，整型数组的个位是num[num.length-1]），并将每位上相加的结果添加到一个整型的Array数组中。\n+ 这里需要注意如果相对应位置上的数相加大于10时，我们应该有进位操作，即 让k+1，number-10（ps：这里的number代表整型数组与k的相应位置上的数相加后得到的结果）\n+ 最后如果k>0,这说明最高位上有进位，最后得到的数组少最高位，我们应该再把k的每个位置的数取出来加入到数组中。\n+ 由于低数位先加入我们最终得到的Array数组中，所以我们需要翻转一下得到的数组，在java中可以调用Collections.reverse()函数来实现。\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len = num.length;\n        List<Integer> resultList = new ArrayList<>();\n        int sum =0;\n        for(int i=len-1;i>=0;i--){\n            sum = num[i]+k%10;\n            k=k/10;\n            if(sum>=10){\n                k++;\n                sum-=10;\n            }\n            resultList.add(sum);\n        }\n        while(k>0){\n            resultList.add(k%10);\n            k=k/10;\n        }\n        Collections.reverse(resultList);\n        return resultList;\n    }\n}\n```\n#### 时间复杂度\nO(n)\n#### 空间复杂度\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917427381","body":"## Java\n#### 解题思路\n先把目标字符c的位置存储起来，然后遍历目标字符串的每个字符，计算每个字符与数组里存储的目标字符串的索引值的差值选出最小的存储到结果数组中。\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] result = new int[s.length()];\n        char[] ch = s.toCharArray();\n        List<Integer> index = new ArrayList<>();\n        for(int i=0;i<s.length();i++){\n            if(ch[i]==c){\n                index.add(i);\n            }\n        }\n        for(int i=0;i<s.length();i++){\n            int min=abs(i,index.get(0));\n            for(int j=1;j<index.size();j++){\n                int temp = abs(i,index.get(j));\n                \n                if(min>temp){\n                    min=temp;\n                }\n            }\n            result[i]=min;\n        }\n        return result;\n    }\n    public int abs(int a,int b){\n        int result = a-b;\n        return (result<0)?-result:result;\n    }\n}\n```\n\n#### 时间复杂度\nO(n<sup>2</sup>)\n#### 空间复杂度\nO(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyalei1026":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916481742","body":"### 思路\r\n convert a list of integers into a number\r\n update this number by adding k \r\n convert back the result into a list of integers\r\n### 代码\r\n```\r\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_str = \"\"\r\n        for n in num:\r\n            num_str += str(n)\r\n        output = []\r\n        for n in str(int(num_str) + k):\r\n            output.append(int(n))\r\n        return output\r\n```\r\n**复杂度分析**\r\nTime Complexity：O(n)\r\nSpace Complexity：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangzz2015":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916499894","body":"\n\n\n## 思路\n- 把K按照位转换成vector。则求解方法和求解两个vector 数相加相同，从后往前遍历。注意carry。时间复杂度 k的位数N，A的位数位M, O(N) + O(max(N,M)) 空间复杂度为 O(N + max(N,M)) \n\n\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        \n        vector<int> veck;  \n        while(k)\n        {\n            veck.push_back(k%10);\n            k =k /10; \n        }\n        bool next = false; \n        int left =num.size()-1; \n        int right =0; \n        vector<int> ret; \n        while(left>=0 && right < veck.size())\n        {\n            int sum = num[left] + veck[right] + (next? 1:0);\n            if(sum/10)\n                next = true; \n            else\n                next = false; \n            sum = sum%10; \n            ret.push_back(sum);    \n            left--; \n            right++; \n        }\n        while(left>=0)\n        {\n            int sum = num[left] + (next? 1:0); \n            if(sum/10)\n                next = true; \n            else\n                next = false; \n            sum = sum%10; \n            ret.push_back(sum);    \n            left--;                 \n        }\n        while(right < veck.size())\n        {\n            int sum = veck[right] + (next? 1 : 0);\n            if(sum/10)\n                next = true; \n            else\n                next = false; \n            sum = sum%10; \n            ret.push_back(sum);    \n            right++;             \n        }\n        if(next)\n            ret.push_back(1);\n        reverse(ret.begin(), ret.end());\n        return ret;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917122923","body":"## 思路\n- 最短距离，使用BFS。第一次遍历找到所有c的字符，放入queue。并设置初始化距离0。下面通过BFS遍历，一层一层设置其他字符的距离。复杂度O(N) + O(N)。空间复杂度O(N)。需要使用队列记录节点。\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        \n        //  method 1 use queue and bft. \n        queue<int> que; \n        vector<int> ret(s.size(), INT_MAX); \n        for(int i=0; i<s.size(); i++)\n        {\n            if(s[i]==c)\n            {\n                ret[i]=0; \n                que.push(i);\n            }\n        }\n        while(que.size())\n        {\n            int topVal = que.front();\n            que.pop();\n            for(int i=-1; i<=1; i=i+2)\n            {\n                int newIndex = topVal +i; \n                if(newIndex<0 || newIndex>=s.size()) // skip; \n                    continue;                \n                if(ret[topVal]+1 < ret[newIndex])\n                {\n                    que.push(newIndex);\n                    ret[newIndex]=ret[topVal]+1;\n                }\n            }\n        }        \n        return ret; \n        \n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917453403","body":"## 思路\n- 关键如何 inc 增加val。另外使用一个栈sum来存储increment val。当出栈时候，把sum加上，并传给下一个top。另外使用vector 来模拟栈。时间复杂度为O(1)，空间复杂度为O(N)。\nC++ Code:\n\n```c++\n\nclass CustomStack {\npublic:\n    vector<int> stack;\n    vector<int> sum; \n    int imaxSize=0; \n    CustomStack(int maxSize) {\n        stack.reserve(maxSize);\n        imaxSize = maxSize;\n        sum.reserve(maxSize);\n    }\n    \n    void push(int x) {\n        if(stack.size()<imaxSize)\n        {\n            stack.push_back(x);\n            sum.push_back(0);\n        }\n    }\n    \n    int pop() {\n        if(stack.size())\n        {\n            int val = stack.back(); \n            int inc = sum.back(); \n            stack.pop_back();\n            sum.pop_back(); \n            if(sum.size())\n            {\n                sum[sum.size()-1] += inc;\n            }\n            return val + inc; \n                \n        }\n        else\n            return -1; \n        \n        \n    }\n    \n    void increment(int k, int val) {\n        int index = min(k,int(sum.size()))-1; \n        \n        if(index>=0)\n          sum[index] +=val; \n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917690879","body":"## 思路\n- 括号匹配问题，使用递归或者栈的办法，和处理计算器的括号处理类似，使用递归办法，递归需要输入，start的位置，对应[后面的位置，输出需要两个内容，1个对应[]内的字符串，另外也需要传出，当前结束的位置，所以采用引用办法返回start，递归完成，后面继续处理下一个。碰到[ 进入递归，碰到 ]返回string，另外要注意num 清零。\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    string decodeString(string s) {\n        \n        int start =0; \n        return helper(s, start); \n    }\n    \n    \n    string helper(string& s, int& start)\n    {\n        int num =0; \n        string ret;\n        for(; start < s.size(); start++)\n        {\n            if(s[start]-'0'>=0 && s[start]-'0'<=9) // is digital\n            {\n                num = num*10 + (s[start] - '0' );\n            }\n            else if(s[start]=='[')\n            {\n                start++;  \n                string oneWord = helper(s, start);\n                for(int i=0; i< num; i++)\n                {\n                    ret +=oneWord; \n                }\n                num =0;                 \n            }\n            else if(s[start] == ']')\n            {\n                return ret;\n            }\n            else // charater. \n            {\n                ret.push_back(s[start]); \n            }\n            \n        }  \n        return ret;\n        \n    }\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tongxw":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916507442","body":"### 思路\r\n\r\nwhile num[i]存在 或者 k不为0:\r\n    当前位sum = 进位 + nums[i](如果存在) + k mod 10 (如果k不为0)；\r\n    倒序遍历num，同时k = k /10;\r\n    进位 carry = sum / 10;\r\n    当前位 digit = sum mod 10;\r\n    输出数组记录digit;\r\n如果最后一位有进位，添加到输出数组中;\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    i = num.length - 1;\r\n    carry = 0;\r\n    ans = [];\r\n    while(i >= 0 || k != 0) {\r\n      sum = carry;\r\n      if (i >= 0) {\r\n        sum += num[i];\r\n        i--;\r\n      }\r\n      if (k != 0) {\r\n        sum += k % 10;\r\n        k = Math.floor(k / 10);\r\n      }\r\n\r\n      carry = Math.floor(sum / 10);\r\n      ans.unshift(sum % 10);\r\n    }\r\n\r\n    if (carry > 0) {\r\n      ans.unshift(carry);\r\n    }\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。 k <= 10^4 不计\r\n- 空间复杂度：O(N)，其中 N 为数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917253566","body":"### 思路\r\n正序遍历，计算每个位置到左侧指定字符的最短距离；\r\n倒序遍历，计算每个位置到右侧指定字符的最短距离；\r\n取最小值。\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  let ans = new Array(s.length);\r\n  let count = s.length;\r\n  for (let i=0; i<s.length; i++) {\r\n    count = s[i] === c ? 0 : count + 1;\r\n    ans[i] = count;\r\n  }\r\n\r\n  count = s.length;\r\n  for (let i=s.length-1; i>=0; i--) {\r\n    count = s[i] === c ? 0 : count + 1;\r\n    ans[i] = Math.min(ans[i], count);\r\n  }\r\n\r\n  return ans;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(s.length)\r\n- 空间复杂度：O(s.length)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917494101","body":"## 思路\r\n用数组记录增量值，数组大小是maxSize\r\n出栈时，需要把栈顶元素加上应的增量值返回。\r\n同时要维护增量值数组：把栈顶对应的增量值加到栈顶的下一个元素上，并把对应的栈顶位置清空。\r\n\r\n## 代码\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = [];\r\n  this.increments = new Array(maxSize).fill(0);\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.stack.length < this.maxSize) {\r\n    this.stack.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  let size = this.stack.length;\r\n  if (size === 0) {\r\n    return -1;\r\n  } else {\r\n    let val = this.increments[size - 1];\r\n    this.increments[size - 1] = 0;\r\n    if (size - 2 >= 0) {\r\n      this.increments[size - 2] += val;\r\n    }\r\n\r\n    return this.stack.pop() + val;\r\n  }\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let size = Math.min(this.stack.length, k);\r\n  this.increments[size - 1] += val;\r\n};\r\n```\r\n\r\n*TC: O(1)*\r\n*SC: O(maxSize)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917756044","body":"## 思路\r\n类似括号匹配，遍历字符串，\r\n如果是数字，就计算当前数字；\r\n如果是字符，入栈；\r\n如果是左括号，先把当前计算好的数字入栈，再把左括号入栈；\r\n如果是右括号，先把栈顶字符串依次出栈并拼接起来，直到碰到左括号。左括号出栈后，栈顶是重复次数，根据次数展开当前字符串后入栈。\r\n遍历结束后把栈内所有已解码完成的字符串拼接起来。\r\n\r\n## 代码\r\n```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  let stack = [];\r\n\r\n  let num = 0;\r\n  for (let i=0; i<s.length; i++) {\r\n    if (s[i] >= '0' && s[i] <= '9') {\r\n      num = num * 10 + (s[i] - '0');\r\n    } else if (s[i] === '[') {\r\n      stack.push(num);\r\n      num = 0;\r\n      stack.push(s[i]);\r\n    } else if (s[i] === ']') {\r\n      let str = '';\r\n      while (stack[stack.length - 1] !== '[') {\r\n        str = stack.pop() + str;\r\n      }\r\n      stack.pop(); // '['\r\n\r\n      let temp = '';\r\n      let repeat = stack.pop();\r\n      while (repeat > 0) {\r\n        temp += str;\r\n        repeat--;\r\n      }\r\n      stack.push(temp);\r\n    } else {\r\n      // chars\r\n      stack.push(s[i]);\r\n    }\r\n  }\r\n\r\n  let ans = '';\r\n  while (stack.length !== 0) {\r\n    ans = stack.pop() + ans;\r\n  }\r\n\r\n  return ans;\r\n};\r\n```\r\n\r\n*TC: O(ans.length)*\r\n*SC: O(ans.length)*","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okbug":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916511474","body":"JS 占坑\r\n其实可以用力扣第二题（两数之和） 类似的解法\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];\r\n    for (let i = num.length - 1; i >= 0 || k > 0; i--) {\r\n\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n\r\n        res.push(k % 10); // 当时个位上的数\r\n        k = (k - k % 10) / 10;\r\n    }\r\n\r\n    return res.reverse();\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917402316","body":"```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> res(n, INT_MAX);\n        for (int i = 0, j = -1; i < n; i++) {\n            if (s[i] == c) j = i;\n            if (j != -1) res[i] = i - j;\n        }\n        for (int i = n - 1, j = -1; i >= 0; i--) {\n            if (s[i] == c) j = i;\n            if (j != -1) res[i] = min(res[i], j - i);\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917627382","body":"```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\n\r\n/**\r\n * @return {number}\r\n */\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\n\r\nclass CustomStack extends Array {\r\n    constructor(maxSize) {\r\n        super();\r\n        this.max = maxSize || 0;\r\n        this.q = [];\r\n    }\r\n\r\n    push(x) {\r\n        let len = this.q.length;\r\n        if (len >= this.max) return;\r\n        this.q.push(x)\r\n    }\r\n\r\n    pop() {\r\n        if (this.q.length > 0) return this.q.pop();\r\n        return -1;\r\n    }\r\n\r\n    increment(k, val) {\r\n        let len = Math.min(k, this.q.length);\r\n        for (let i = 0; i < len; i++) {\r\n            this.q[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n利用数组的push和pop方法直接实现","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yan0327":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916531466","body":"思路：\n1.数组从个位开始[即从后往前计数]，用一个sum保存位和[加数+被加数+低位进位],一个pre保存进位\n重新设置一个输出数组out。\n2.数组从后往前遍历，每位与k%10相加、与低位进位相加，获得sum 。 sum%10加入数组，sum/10为进\n位值，运算完记得把k/10.\n3.若数组跑完k还有值或进位有值，则再跑一遍循环处理完剩余的数据\n4.最后对整个数组首尾交换即可\n代码：\n```Go\nfunc largestRectangleArea(heights []int) int {\n    stack := []int{}\n    N := len(heights)\n    st, result := make([]int,N+2), 0\n    for i:=0; i< N+2;i++{\n        if i == 0 || i == N+1{\n            st[i] = 0\n        }else{\n            st[i] = heights[i-1]\n        }\n    }\n    for i:=0; i < N+2;i++{\n        for len(stack) > 0 &&st[i] < st[stack[len(stack)-1]]{\n            mid := stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n            w := i - stack[len(stack)-1] - 1\n            h := st[mid]\n            result = max(result, w*h)\n        }\n            stack = append(stack, i)\n    }\n    return result\n}\n\nfunc max(x, y int) int{\n    if x > y{\n        return x\n    }else{\n        return y\n    }\n}\n```\n时间复杂度：O(n)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917318416","body":"首先生成一个N长度的数组output，并且对每个值赋值len（s）【N为字符串s的长度】,然后从数组前后分别遍历一次。\r\n从前往后时，先判断字符是否等于目标字符，若相等则数组output置0.对于不相等的字符再次判断，若字符串位于首位，则置为len（s）。接下来，每位的取值为该数组左边一位的取值加1:output[i] = output[i-1] + 1\r\n从后往前时，从倒数第二位开始判断。当该值大于等于len（s）说明该数的左边没有特定字符 或 此时的取值大于 该值右边一位的数值+1【取左右目标字符的距离最小值】，则取 该值右边一位的数值+1\r\n\r\n关键边界条件两个：\r\n1.从左往右遍历的0位，他的取值没有上一位进行参考\r\n2.有右往左的遍历n-1位，他的取值没有下一位进行参考\r\n\r\n```Go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    output := make([]int,len(s), len(s))\r\n    for i:=0; i< len(s); i++{\r\n        if(s[i] == c) {\r\n            output[i] = 0\r\n        }else{\r\n            if i==0 {\r\n                output[i] = len(s)\r\n            }else{\r\n               output[i] = output[i-1] + 1\r\n            }\r\n        }\r\n    }\r\n\r\n    for i:=len(s)-2;i >= 0;i--{\r\n        if (output[i] >= len(s) || output[i] > output[i+1] + 1){\r\n            output[i] = output[i+1] + 1\r\n        }\r\n    }\r\n    return output\r\n}\r\n```\r\n复杂度分析\r\n时间复杂度O（n）\r\n空间复杂度O（n）\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917514422","body":"type CustomStack struct {\n    stack []int\n    max int\n}\n\n\nfunc Constructor(maxSize int) CustomStack {\n    return CustomStack{make([]int, 0), maxSize}\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n    if len(this.stack) < this.max{\n        this.stack = append(this.stack, x)\n    }\n}\n\n\nfunc (this *CustomStack) Pop() int {\n    if len(this.stack) == 0 {\n        return -1\n    }\n    out := this.stack[len(this.stack)-1]\n    this.stack = this.stack[:len(this.stack)-1]\n    return out\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n    if k > len(this.stack){\n        k = len(this.stack)\n    }\n    for i:=0; i < k; i++{\n        this.stack[i] += val\n    }\n}\n\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * obj := Constructor(maxSize);\n * obj.Push(x);\n * param_2 := obj.Pop();\n * obj.Increment(k,val);\n */","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenming-cao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916534184","body":"### 解题思路\n因为数组num的长度太大，会越界，所以每一数位单独运算。把k先用字符串方法转换为各个数位的数组。用`carry`记录进位，每一个对应数位进行加法运算，结果存到链表头部。注意循环结束后再查看一下最终进位`carry`是否为0，不为0的话存到链表中。\n\n### 代码（java）\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        String str = String.valueOf(k); // Convert k to string, can also use Integer.toString(k)\n        String[] elements = str.split(\"\"); // Get individual digits as String format\n        int klen = elements.length;\n\n        int carry = 0;\n        LinkedList<Integer> result = new LinkedList<>();\n        int nlen = num.length;\n        int length = nlen > klen ? nlen : klen;\n\n        for (int i = 0; i < length; i++) {\n            int knum = i < klen ? Integer.parseInt(elements[klen - 1 - i]) : 0;\n            int cur = nlen - 1 - i;\n            int n = i < nlen ? num[cur] : 0;\n            result.addFirst((n + knum + carry) % 10);\n            carry = (n + knum + carry) / 10;\n        }\n\n        if (carry != 0) result.addFirst(carry);       \n        return result;\n    }\n}\n```\n\n**复杂度分析**\n\n令n为nums数组长度，字符串数组的长度为logk\n- 时间复杂度：O(max(n, logk)), 两个数组长度的最大值（最终循环次数）\n- 空间复杂度：O(n), 创建链表储存结果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917266221","body":"### 解题思路\n遍历两次字符串：第一次正向遍历，计算每个字符和前面出现的特殊字符的最近距离；第二次反向遍历，计算每个字符和后面出现的特殊字符的最近距离。两次遍历过程中，把最短距离写入整数数组中。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int length = s.length();\n        int[] res = new int[length]; // create int array with size of the length of string\n        Arrays.fill(res, length); // initialize the array and fill with the length of string (the distance between two characters is always smaller than the length of string)\n\n        int idx = 0;\n        // traverse the array, and update the distance\n        for (int i = s.indexOf(c); i < length; i++) {\n            if (s.charAt(i) == c) idx = i;\n            if (Math.abs(idx - i) < res[i]) res[i] = Math.abs(idx - i);\n        }\n        // traverse the array in reverse order, and update the distance\n        for (int j = s.lastIndexOf(c); j >= 0; j--) {\n            if (s.charAt(j) == c) idx = j;\n            if (Math.abs(idx - j) < res[j]) res[j] = Math.abs(idx - j);\n        }\n\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n\n令n为字符串长度\n- 时间复杂度：O(n)，循环运行次数\n- 空间复杂度：O(n)，建立了整数数组储存结果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917435398","body":"### 解题思路\n用数组来实现栈，再设置两个变量`maxSize`和`currentSize`分别记录数组最大长度和当前长度，用来快速判断栈是否已满，并且快速查找栈顶元素。\n\n### 代码\n\n```java\nclass CustomStack {\n\n    private int[] stack;\n    private int maxSize;\n    private int currentSize = 0;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (currentSize < maxSize) {\n            stack[currentSize] = x;\n            currentSize++; // remember to update currentSize\n        }\n    }\n    \n    public int pop() {\n        if (currentSize == 0) return -1;\n        currentSize--; // remember to update currentSize\n        return stack[currentSize];\n    }\n    \n    public void increment(int k, int val) {\n        int n = k < currentSize ? k : currentSize;\n        for (int i = 0; i < n; i++) {\n            stack[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\n**复杂度分析**\n- 时间复杂度：push和pop操作O(1)，increment操作O(k)\n- 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917677317","body":"### 解题思路\n用栈来解决。重复的部分满足格式`k[encoded_string]`，先将除`]`外的字符入栈，遇到`]`说明重复的部分出现，先出栈字母，再出栈`[`，最后出栈数字。根据数字将重复部分重新入栈。最后出栈所有字符获得字符串即为结果。\n\n### 代码\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n\n        for (char c: s.toCharArray()) {\n            if (c != ']') {\n                stack.push(c); // push characters into stack if it is not ']'\n            }\n            else {\n                StringBuilder sb = new StringBuilder();\n\t\t// get the repeated characters\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\n                    sb.insert(0, stack.pop());\n                }\n\n                String sub = sb.toString();\n\t\t// pop '[' from stack\n                stack.pop();\n\n                sb = new StringBuilder();\n\t\t// get the repeated times\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\n                    sb.insert(0, stack.pop());\n                }\n\n                int count = Integer.parseInt(sb.toString());\n\t\t// push the repeated characters back into stack\n                while (count > 0) {\n                    for (char element: sub.toCharArray()) {\n                        stack.push(element);\n                    }\n                    count--;\n                }\n            }\n        }\n\n        StringBuilder res = new StringBuilder();\n        while (!stack.isEmpty()) {\n            res.insert(0, stack.pop());\n        }\n\n        return res.toString();\n    }\n}\n```\n\n**复杂度分析**\n\n令字符串长度为n\n- 时间复杂度：O(n)，需要遍历字符串\n- 空间复杂度：O(n)，创建栈储存字符","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZJP1483469269":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916534668","body":"#### 思路\n对数组与k进行按位加 保留进位位，并与下一位的k和数组相加 最后判断k是否加完，若没有则直接加进队列\n#### 代码\n    class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len = num.length;\n        int c=0;\n        int a=0;\n        LinkedList<Integer> ans = new LinkedList<>();\n        for(int i=len-1;i>=0;i--){\n            a = (num[i] + k%10 + c )%10;\n            c = (num[i] + k%10 + c)/10;\n            k = k/10;\n            ans.addFirst(a);\n        }\n        if(c!=0){\n            k=k+c;\n        }\n        if(k!=0){\n            while(k!=0){\n                ans.addFirst(k%10);\n                k/=10; \n            }\n        }\n        return ans;\n    }\n}; \n\n####复杂度分析\n时间复杂度：O(n) n为数组长度\n空间复杂度：O(n) n为数组长度\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917319847","body":"#### 思路\n对字符串从左到右遍历一次，对于c字符右侧的非c字符，在对应的数组中加1，然后对字符串从右到左遍历一次，对于c字符左侧的非c字符，在对应的数组中减1并与第一次遍历得到的数据进行比较取较小值填入数组。\n\n#### 代码\n    class Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int p =s.indexOf(c),q=s.lastIndexOf(c);\n        for(int i=p;i<len-1;i++){\n            res[i+1]=res[i]+1;\n            if(s.charAt(i+1)==c)\n                res[i+1]=0;\n        }\n        for(int i=q;i>0;i--){\n           \n            if(res[i-1]!=0)\n                res[i-1]=res[i]+1<res[i-1] ? res[i]+1 : res[i-1];\n            else\n                res[i-1]=res[i]+1;   \n            if(s.charAt(i-1)==c){\n                res[i-1]=0;\n            } \n\n        }\n        return res;\n    }\n    }   \n#### 复杂度分析\n时间复杂度：O(N）\n空间复杂度：O(N)N为字符串长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917534456","body":"#### 思路\n采用数组实现栈的操作，top一直指向栈顶，若栈为空top=-1\n#### 代码\n    class CustomStack {\n    int[] stack;\n    int top=-1;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top=-1;\n    }\n    \n    public void push(int x) {\n        if(top<stack.length-1){\n            stack[++top]=x;\n        }\n    }\n    \n    public int pop() {\n        if(top>=0){\n            return stack[top--];\n        }\n        else return -1;\n    }\n    \n    public void increment(int k, int val) {\n        if(top<k){\n            for(int i=0;i<=top;i++){\n                stack[i]+=val;\n            }\n        }\n        else{\n            for(int i=0;i<k;i++){\n                stack[i]+=val;\n            }\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n#### 复杂度分析\n入栈：时间复杂度O(1)\n出栈：时间复杂度O(1)\nincrement：时间复杂度O(min(k,stack.length))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mozro0327":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916536901","body":"## 思路\r\n\r\n+ 当前位 = 数字A + 数字B + 进位\r\n+ 利用 k 作为进位和数字B的和\r\n\r\n## 代码\r\n\r\n~~~ cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> result;\r\n        int size = num.size(), sum = 0;\r\n        for (int i = size - 1; i >= 0 || k > 0; i--, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            result.push_back(k % 10);\r\n        }\r\n        reverse(result.begin(), result.end());\r\n        return result;\r\n    }\r\n};\r\n\r\n~~~\r\n\r\n## 复杂度分析\r\n\r\n+ 空间复杂度 `O(n)`\r\n+ 时间复杂度`O(max(n, logk))`\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917361461","body":"## 思路\r\n\r\n+ 由于 c 在 s 中出现的位置不会改变，可以将 c 的位置存储起来\r\n+ 挨个遍历 s 中的字符，寻找出最近的 c，并将其写入结果 vector 中\r\n\r\n## 代码\r\n\r\n~~~ cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int size = s.size();\r\n        vector<int> result(size, size);\r\n        vector<int> indexs;\r\n        for (int i = 0; i < size; i++) {\r\n            if (s[i] == c) {\r\n            indexs.push_back(i);\r\n            }\r\n        }\r\n        for (int i = 0; i < size; i++) {\r\n            if (s[i] == c) {\r\n            result[i] = 0;\r\n            continue;\r\n            }\r\n            for (int j = 0; j < indexs.size(); j++) {\r\n            int dist = abs(i - indexs[j]);\r\n            if (dist > result[i]) {\r\n                break;\r\n            }\r\n            result[i] = dist;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};\r\n~~~\r\n\r\n## 时空复杂度\r\n\r\n+ 时间复杂度：`O(n * indexs.size())`\r\n+ 空间复杂度：`O(indexs.size())`\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917627610","body":"## 思路\r\n\r\n+ 利用 `vector` 实现一个栈\r\n+ 用模拟法实现增量操作\r\n\r\n## 代码\r\n\r\n~~~ cpp\r\nclass CustomStack {\r\npublic:\r\n    vector<int>nums;\r\n    int top;\r\n\r\n    CustomStack(int maxSize) {\r\n        nums.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top != nums.size() - 1) {\r\n            top++;\r\n            nums[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        int tmp = nums[top];\r\n        top--;\r\n        return tmp;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int lim = min(k, top + 1);\r\n        for (int i = 0; i < lim; ++i) {\r\n            nums[i] += val;\r\n        }\r\n    }\r\n};\r\n~~~\r\n\r\n## 复杂度分析\r\n\r\n+ 时间复杂度\r\n  1. `O(1)`\r\n  2. `O(1)`\r\n  3. `O(n)`\r\n+ 空间复杂度\r\n  + `O(n)`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916539064","body":"## 989. Add to Array-Form of Integer\n\nThe **array-form** of an integer `num` is an array representing its digits in left to right order.\n\n- For example, for `num = 1321`, the array form is `[1,3,2,1]`.\n\nGiven `num`, the **array-form** of an integer, and an integer `k`, return *the **array-form** of the integer* `num + k`.\n\n**Example 1:**\n\n```\nInput: num = [1,2,0,0], k = 34\nOutput: [1,2,3,4]\nExplanation: 1200 + 34 = 1234\n```\n\n## Note\n\n1. O(n), O(n), `n is max(n.length,k.digitsNum)`\n   1. **From right to left**, pick the digits from the num array and k to construct the result array; Reverse the result array when returning.\n   2. CurrentValue is comprised of value from num, k and carry;Keep running the loop **as long as there is a value in num, k or carry**;\n2. Problems:\n   1. The num array could be too big to perform normal addition which leads to a totally wrong answer. \n   2. The summation of num array could be less than k which means that we may run out of the num array first.\n   3. Never forget carry.\n   4. The division in JS won’t give you an Int, please use `Math.floor()`.\n\n```js\nvar addToArrayForm = function(num, k) {\n    let res=[];\n    let carry=0;\n    let rightIndex=num.length-1;\n    \n    while(rightIndex>=0 || k>0 || carry>0){\n        let currentSum=rightIndex>=0?num[rightIndex]+carry+ k%10:carry+ k%10;\n        k=Math.floor(k/10);\n        carry=Math.floor(currentSum/10)\n        res.push(currentSum%10);\n        rightIndex--;\n    }\n  \n    return res.reverse();\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917348991","body":"## 821. Shortest Distance to a Character\n\nGiven a string `s` and a character `c` that occurs in `s`, return *an array of integers* `answer` *where* `answer.length == s.length` *and* `answer[i]` *is the **distance**from index* `i` *to the **closest** occurrence of character* `c` *in* `s`.\n\nThe **distance** between two indices `i` and `j` is `abs(i - j)`, where `abs` is the absolute value function.\n\n**Example 2:**\n\n```\nInput: s = \"aaab\", c = \"b\"\nOutput: [3,2,1,0]\n```\n\n## Note\n\n1. O(n*m), O(m+n), n is the length of the string, m is the occurrence of c. \n   1. Iterate the string s to get all the indices of c\n   2. Iterate the string s again to fill the result array by comparing current index with all the indices in Step 1 to get a minimal.\n\n```js\nvar shortestToChar = function(s, c) {\n    let indicesOfC=[];\n    let res=[];\n    \n    for(let i=0;i<s.length;i++){\n        if(s[i]===c) indicesOfC.push(i);\n    }\n    \n    for(let j=0;j<s.length;j++){\n        let currDistance=s.length;\n        for(let k of indicesOfC){\n            currDistance=Math.min(currDistance,Math.abs(j-k));\n        }\n        res.push(currDistance);\n    }\n    \n    return res;\n};\n```\n\n2. O(n), O(n), n is the length of the string.\n   1. Use a prev index to remember to previous occurring index of c.\n   2. Add the distance of prev and to res array.\n   3. Loop the string reversely, change the res array if there is a minimal.\n\n```js\nvar shortestToChar = function(s, c) {\n    let res=[];\n    let prev=Infinity;\n    \n    for(let i=0;i<s.length;i++){\n        if(s[i]===c) prev=i;\n        res[i]=Math.abs(prev-i);\n    }\n    \n    prev=Infinity;\n    for(let j=s.length-1;j>=0;j--){\n        if(s[j]===c) prev=j;\n        res[j]=Math.min(res[j],Math.abs(prev-j));\n    }\n    \n    return res;\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917495154","body":"## 1381. Design a Stack With Increment Operation\n\nDesign a stack which supports the following operations.\n\nImplement the `CustomStack` class:\n\n- `CustomStack(int maxSize)` Initializes the object with `maxSize` which is the maximum number of elements in the stack or do nothing if the stack reached the `maxSize`.\n- `void push(int x)` Adds `x` to the top of the stack if the stack hasn't reached the `maxSize`.\n- `int pop()` Pops and returns the top of stack or **-1** if the stack is empty.\n- `void inc(int k, int val)` Increments the bottom `k` elements of the stack by `val`. If there are less than `k` elements in the stack, just increment all the elements in the stack.\n\n## Note\n\n1. Push O(1), Pop O(1), Increment O(n), n is min(this.size,k);\n2. Space Complexity: O(n)\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize=maxSize;\n    this.size=0;\n    this.stack=[];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.size!==this.maxSize){\n        this.stack.push(x);\n        this.size++;\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.size===0) return -1;\n    this.size--;\n    return this.stack.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i=Math.min(k-1,this.size-1);i>=0;i--){\n        this.stack[i]+=val;\n    }\n};\n\n/** \n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"NorthSeacoder":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916540032","body":"```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n    const res = [];\n    let carry = 0;\n    num.reverse();\n    const strK = String(k).split('').reverse().join('');\n    const maxLen = Math.max(num.length, strK.length)\n    for (let index = 0; index < maxLen; index++) {\n        let value = Number(strK[index] ? strK[index] : 0) + (num[index] ? num[index] : 0) + carry;\n        if (value >= 10) {\n            value %= 10;\n            carry = 1\n        } else {\n            carry = 0\n\n        }\n        res.push(value);\n    }\n    if (carry) res.push(carry)\n    return res.reverse()\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917312078","body":"```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n    const res = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        const dis = getDis(i, s, c);\r\n        res.push(dis)\r\n    }\r\n    return res\r\n};\r\nconst getDis = (i, s, c) => {\r\n    let l = i, r = i, dis = Infinity;\r\n    if (s[i] === c) return 0;\r\n    while (l >= 0) {\r\n        if (s[l] === c) {\r\n            dis = Math.min(dis, i - l);\r\n            break;\r\n        }\r\n        l--;\r\n    }\r\n    while (r < s.length) {\r\n        if (s[r] === c) {\r\n            dis = Math.min(dis, r - i);\r\n            break;\r\n        }\r\n        r++;\r\n    }\r\n    return dis\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917640513","body":"```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.list = []\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.list.length < this.maxSize) {\n        this.list.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    const item = this.list.pop()\n    return item ?? -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    for (let i = 0; i < k && i < this.list.length; i++) {\n        this.list[i] += val\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laurallalala":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916541347","body":"### 代码\n```\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        num_k = []\n        while k > 0:\n            num_k.insert(0, k%10)\n            k = k // 10\n        l, lk = len(num), len(num_k)\n        if l < lk:\n            num, num_k = num_k, num\n            l, lk = lk, l\n        carry = 0\n        for i in range(max(l, lk)):\n            s = carry\n            l_idx, lk_idx = l-i-1, lk-i-1\n            s += num[l_idx]\n            if lk_idx >= 0:\n                s += num_k[lk_idx]\n            if s >= 10:\n                carry = s // 10\n                s = s % 10\n            else:\n                carry = 0\n            num[l_idx] = s\n        if carry > 0:\n            num.insert(0, carry)\n        return num\n```\n### 复杂度分析\n* 时间复杂度O(N)\n* 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917327549","body":"### 代码\n```\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        res = [0]*n\n        carry = -1\n        for i in range(n):\n            if s[i] == c:\n                carry = i\n                res[i] = i\n            else:\n                res[i] = carry\n        carry = -1\n        for i in range(n-1, -1, -1):\n            if s[i] == c:\n                carry = i\n                res[i] = 0\n            else:\n                if res[i] == -1 and carry != -1:\n                    res[i] = abs(carry-i)\n                elif res[i] != -1 and carry == -1:\n                    res[i] = abs(res[i]-i)\n                else:\n                    res[i] = min(abs(res[i]-i), abs(carry-i))\n        return res\n                   \n```\n### 复杂度\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917537886","body":"### 代码\n```\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.list = []\n        self.maxSize = maxSize\n        self.size = 0\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if self.size+1 <= self.maxSize:\n            self.list.append(x)\n            self.size += 1\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.size > 0:\n            res = self.list[-1]\n            self.list.pop()\n            self.size -= 1\n            return res\n        else:\n            return -1\n        \n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        tmp = []\n        while self.list:\n            tmp.append(self.list[-1])\n            self.list.pop()\n        for i in range(k):\n            if not tmp:\n                break\n            self.list.append(tmp[-1] + val)\n            tmp.pop()\n        while tmp:\n            self.list.append(tmp[-1])\n            tmp.pop()\n```\n### 复杂度分析\n* 时间复杂度\npush O(1)\npop O(1)\nincr O(n)\n* 空间复杂度\npush O(1)\npop O(1)\nincr O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917724388","body":"### 代码\n```\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        for c in s:\n            if c != \"]\":\n                stack.append(c)\n            else:\n                last = stack[-1]\n                cut = \"\"\n                while last != \"[\":\n                    stack.pop()\n                    cut = last + cut\n                    last = stack[-1]\n                stack.pop()\n                last = stack[-1]\n                digits = \"\"\n                while last.isdigit():\n                    stack.pop()\n                    digits = last + digits\n                    if not stack:\n                        break\n                    last = stack[-1]\n                stack.append(int(digits)*cut)\n        return ''.join(stack)\n```\n### 复杂度\n* 时间复杂度：O(n)\n* 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingliufilms":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916548236","body":"##  当前的问题：\r\n\r\n### 题目 run 的时候被 accept 了，但是 submit 的时候说是答案是错的。新手不知道该怎么改进。先把卡打了再说。如果有大佬看到，可以指点迷津吗？谢谢。我会继续改进。\r\n\r\n##  思路: \r\n\r\n- 先把当前 array 中转 string 再转回 integer, numInt；\r\n- 把 numInt 和 k 加起来成和, sum；\r\n- 利用 sum 除以 10 的余数来加入到新 array 的尾部\r\n\r\n## 代码 Javascript \r\n\r\n```\r\nconst addToArrayForm = function(num, k) {\r\n    const numInt = parseInt(num.join(''));\r\n    let sum = numInt + k;\r\n    const resultArray = [];\r\n    while (sum >= 0) {\r\n           let el = sum % 10 ;\r\n           sum = Math.floor(sum / 10);\r\n           resultArray.splice(0, 0, el);\r\n           }\r\n    return resultArray;\r\n```\r\n\r\n##  复杂度分析\r\n\r\n时间与空间均为 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917193739","body":"# link: \r\nhttps://leetcode.com/problems/shortest-distance-to-a-character/\r\n\r\n# 知识弱点：\r\n\r\n- nested for loops (eg. i & j): how it works is that 到 i 某一个 index, 遍历一遍 j 的所有 indices,然后再移到 i 的下一个 index\r\n\r\n## （抄）思路 （没有自己做出来，看的别人的答案）:\r\n\r\n- 先把 c 找出来，把 c 的 indices 存入数组；\r\n- 遍历整个数组，每一个 index 与 c 对应的 index 求绝对值到差， 来找到每一个 index 与最近一个 c 的 距离；\r\n- 把这些距离存入新的空数组\r\n\r\n## 代码 Javascript\r\n\r\n```javascript\r\nconst shortestToChar = function (s, c) {\r\n  const indices = [];\r\n  const distances = [];\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) {\r\n      indices.push(i);\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    let min = Number.MAX_SAFE_INTEGER;\r\n    for (let j = 0; j < indices.length; j++) {\r\n      let distance = Math.abs(indices[j] - i);\r\n      if (distance < min) {\r\n        min = distance;\r\n      }\r\n    }\r\n    distances.push(min);\r\n  }\r\n\r\n  return distances;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n时间 O(n2)\r\n\r\n空间 不会算\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917518259","body":"# link:\r\n\r\nhttps://leetcode.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 思路:\r\n\r\n- 创建一个 obj, key 为 array（stack) 值为空， key 为 maxSize 值为 argument maxSize\r\n- push: 如果已是 maxSize，直接 return; 不然到话，push x;\r\n- pop: 如果 stack 为空，直接 return; 否则，pop 的 top 的值\r\n- increment: 取 stack 的长度与 k 的最小值， 遍历这个最小值长度的bottom stack, increment val\r\n\r\n## 代码 Javascript\r\n\r\n```javascript\r\nconst CustomStack = function (maxSize) {\r\n  this.arr = [];\r\n  this.maxSize = maxSize;\r\n};\r\n\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.arr.length === this.maxSize) return;\r\n  this.arr.push(x);\r\n};\r\n\r\nCustomStack.prototype.pop = function () {\r\n  if (this.arr.length === 0) return -1;\r\n  return this.arr.pop();\r\n};\r\n\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (let i = 0; i < Math.min(this.arr.length, k); i++) {\r\n    this.arr[i] += val;\r\n  }\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n时间 o(n)\r\n空间 o(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jin03041209":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916558714","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> list = new LinkedList<>();\n        int i = num.length-1;\n        while(i>=0||k>0){\n            if(i>=0){\n                k +=num[i];\n            }\n            list.addFirst(k%10);\n            k /= 10;\n            i--;\n        }\n        return list;\n    }\n}\n复杂度分析：\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"agentzzz":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916559464","body":"两个思路：\n\n1.将数组元素转化为数字，然后数字相加，返回数组【但是，数字表示范围容易超限】\n\n2.按位相加\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        long long n = 0;\n        for (int i = 0; i < num.size(); ++i)\n        {\n            n = n * 10 + num[i];\n        }\n        n += k;\n        vector<int>res;\n        if(n==0) return {0};\n        while (n != 0)\n        {\n            res.push_back(n % 10);\n            n /= 10;\n        }\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```\n\n超出数字表示范围\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        \n        int i = num.size()-1;\n        vector<int>res;\n        while(i>=0)\n        {\n            int temp = num[i] + k;\n            res.push_back(temp%10);\n            k = temp/10;\n            i--;\n        }\n        while(k>0) {\n\t\t\tres.push_back(k%10);\n\t\t\tk/=10;\n\t\t}\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```\n\n时间复杂度O（N）\n\n空间复杂度O（N）\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917382729","body":"```C++\nclass Solution {\npublic:\n\tvector<int> shortestToChar(string s, char c) {\n\t\tvector<int> res;\n        res.resize(s.size());\n\t\tint temp = INT_MIN / 2;\n\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\tif (s[i] == c) temp = i;\n\t\t\tres[i] = i - temp;\n\t\t}\n\t\ttemp = INT_MAX / 2;\n\t\tfor (int i = s.size() - 1; i >= 0; i--) {\n\t\t\tif (s[i] == c) temp = i;\n\t\t\tres[i] = min(temp - i, res[i]);\n\t\t}\n\t\treturn res;\n\n\t}\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917543601","body":"用数组实现增量栈\r\n\r\n```C++\r\nclass CustomStack {\r\npublic:\r\n    vector<int>mem;\r\n    int _size;\r\n    \r\n    CustomStack(int maxSize) {\r\n        this->_size = maxSize;\r\n    }\r\n\r\n    void push(int x) {\r\n        if (mem.size() < _size) mem.push_back(x);\r\n    }\r\n\r\n    int pop() {\r\n        if (mem.empty()) return -1;\r\n        else {           \r\n            int ret = mem.back();\r\n            mem.pop_back();\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    void increment(int k, int val) {\r\n        if (k > mem.size()) {\r\n            for (int i = 0; i < mem.size(); i++) {\r\n                mem[i] += val;\r\n            }\r\n        }\r\n        else {\r\n            for (int i = 0; i < k; i++) {\r\n                mem[i] += val;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916559576","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\r\n\r\n## S1: 逐位相加\r\n\r\n将数字逐位相加，从低位到高位。\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> ans;\r\n        int i = num.size() - 1;\r\n        int carry = 0;\r\n        while (i >= 0 || k > 0 || carry > 0) {\r\n            int a = i >= 0 ? num[i--] : 0;\r\n            int b = k > 0 ? k % 10 : 0;\r\n            k /= 10;\r\n            int sum = a + b + carry;\r\n            ans.push_back(sum % 10);\r\n            carry = sum / 10;\r\n        }\r\n        reverse(ans.begin(), ans.end());\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n- ****Time:**** $O(max(N,logk))$，N 是 num 的长度，logk 是 k 的位数。进行逐位相加以及最后 reverse 数组的时间分别都是 $O(max(N,logk))$。\r\n- ***Space:** $O(1)$，*除返回值外，使用的是常数空间。\r\n\r\n## S2: 相加\r\n\r\n将 k 从低位到高位直接加到数组的每一位。\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> ans;\r\n        int i = num.size() - 1;\r\n        while (i >= 0 || k > 0) {\r\n            k += i >= 0 ? num[i--] : 0;\r\n            ans.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n        reverse(ans.begin(), ans.end());\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n- ****Time:**** $O(max(N,logk))$\r\n- ***Space:** $O(1)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917374959","body":"# 821.字符的最短距离\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n- [821.字符的最短距离](#821字符的最短距离)\n  - [题目描述](#题目描述)\n  - [解法 1：中心扩展法](#解法-1中心扩展法)\n    - [思路](#思路)\n    - [复杂度分析](#复杂度分析)\n    - [代码 (JS/C++)](#代码-jsc)\n  - [解法 2：空间换时间](#解法-2空间换时间)\n    - [思路](#思路-1)\n    - [复杂度分析](#复杂度分析-1)\n    - [代码 (JS/C++)](#代码-jsc-1)\n  - [解法 3：贪心](#解法-3贪心)\n    - [思路](#思路-2)\n    - [复杂度分析](#复杂度分析-2)\n    - [代码 (JS/C++/Python)](#代码-jscpython)\n  - [解法 4：窗口](#解法-4窗口)\n    - [思路](#思路-3)\n    - [复杂度分析](#复杂度分析-3)\n    - [代码 (JS/C++/Python)](#代码-jscpython-1)\n\n## 题目描述\n\n```\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\n\n示例 1:\n\n输入: S = \"loveleetcode\", C = 'e'\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\n说明:\n\n字符串 S 的长度范围为 [1, 10000]。\nC 是一个单字符，且保证是字符串 S 里的字符。\nS 和 C 中的所有字母均为小写字母。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n```\n\n## 解法 1：中心扩展法\n\n### 思路\n\n这是最符合直觉的思路，对每个字符分别进行如下处理：\n\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 `C`。\n- 只在一个方向找到的话，直接计算字符距离。\n- 两个方向都找到的话，取两个距离的最小值。\n\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_0.png)\n\n### 复杂度分析\n\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\n- 空间复杂度：$O(1)$。\n\n### 代码 (JS/C++)\n\nJavaScript Code\n\n```js\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  // 结果数组 res\n  var res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    // 如果当前是目标字符，就什么都不用做\n    if (S[i] === C) continue;\n\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n\nC++ Code\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        vector<int> res(S.length());\n\n        for (int i = 0; i < S.length(); i++) {\n            if (S[i] == C) continue;\n\n            int left = i;\n            int right = i;\n            int dist = 0;\n\n            while (left >= 0 || right <= S.length() - 1) {\n                if (S[left] == C) {\n                    dist = i - left;\n                    break;\n                }\n                if (S[right] == C) {\n                    dist = right - i;\n                    break;\n                }\n\n                if (left > 0) left--;\n                if (right < S.length() - 1) right++;\n            }\n\n            res[i] = dist;\n        }\n\n        return res;\n    }\n};\n```\n\n## 解法 2：空间换时间\n\n### 思路\n\n空间换时间是编程中很常见的一种 trade-off (反过来，时间换空间也是)。\n\n因为目标字符 `C` 在 `S` 中的位置是不变的，所以我们可以提前将 `C` 的所有下标记录在一个数组 `cIndices` 中。\n\n然后遍历字符串 `S` 中的每个字符，到 `cIndices` 中找到距离当前位置最近的下标，计算距离。\n\n### 复杂度分析\n\n- 时间复杂度：$O(N*K)$，N 是 S 的长度，K 是字符 `C` 在字符串中出现的次数，$K <= N$。\n- 空间复杂度：$O(K)$，K 为字符 `C` 出现的次数，这是记录字符 `C` 出现下标的辅助数组消耗的空间。\n\n### 代码 (JS/C++)\n\nJavaScript Code\n\n```js\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  // 记录 C 字符在 S 字符串中出现的所有下标\n  var cIndices = [];\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) cIndices.push(i);\n  }\n\n  // 结果数组 res\n  var res = Array(S.length).fill(Infinity);\n\n  for (let i = 0; i < S.length; i++) {\n    // 目标字符，距离是 0\n    if (S[i] === C) {\n      res[i] = 0;\n      continue;\n    }\n\n    // 非目标字符，到下标数组中找最近的下标\n    for (const cIndex of cIndices) {\n      const dist = Math.abs(cIndex - i);\n\n      // 小小剪枝一下\n      // 注：因为 cIndices 中的下标是递增的，后面的 dist 也会越来越大，可以排除\n      if (dist >= res[i]) break;\n\n      res[i] = dist;\n    }\n  }\n  return res;\n};\n```\n\nC++ Code\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        int n = S.length();\n        vector<int> c_indices;\n        // Initialize a vector of size n with default value n.\n        vector<int> res(n, n);\n\n        for (int i = 0; i < n; i++) {\n            if (S[i] == C) c_indices.push_back(i);\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (S[i] == C) {\n                res[i] = 0;\n                continue;\n            }\n\n            for (int j = 0; j < c_indices.size(); j++) {\n                int dist = abs(c_indices[j] - i);\n                if (dist > res[i]) break;\n                res[i] = dist;\n            }\n        }\n\n        return res;\n    }\n};\n```\n\n## 解法 3：贪心\n\n### 思路\n\n其实对于每个字符来说，它只关心离它最近的那个 `C` 字符，其他的它都不管。所以这里还可以用贪心的思路：\n\n1. 先 `从左往右` 遍历字符串 `S`，用一个数组 left 记录每个字符 `左侧` 出现的最后一个 `C` 字符的下标；\n2. 再 `从右往左` 遍历字符串 `S`，用一个数组 right 记录每个字符 `右侧` 出现的最后一个 `C` 字符的下标；\n3. 然后同时遍历这两个数组，计算距离最小值。\n\n**优化 1**\n\n再多想一步，其实第二个数组并不需要。因为对于左右两侧的 `C` 字符，我们也只关心其中距离更近的那一个，所以第二次遍历的时候可以看情况覆盖掉第一个数组的值：\n\n1. 字符左侧没有出现过 `C` 字符\n2. `i - left` > `right - i` (i 为当前字符下标，left 为字符左侧最近的 `C` 下标，right 为字符右侧最近的 `C` 下标)\n\n如果出现以上两种情况，就可以进行覆盖，最后再遍历一次数组计算距离。\n\n**优化 2**\n\n如果我们是直接记录 `C` 与当前字符的距离，而不是记录 `C` 的下标，还可以省掉最后一次遍历计算距离的过程。\n\n### 复杂度分析\n\n- 时间复杂度：$O(N)$，N 是 S 的长度。\n- 空间复杂度：$O(1)$。\n\n### 代码 (JS/C++/Python)\n\nJavaScript Code\n\n```js\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  var res = Array(S.length);\n\n  // 第一次遍历：从左往右\n  // 找到出现在左侧的 C 字符的最后下标\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) res[i] = i;\n    // 如果左侧没有出现 C 字符的话，用 Infinity 进行标记\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1];\n  }\n\n  // 第二次遍历：从右往左\n  // 找出现在右侧的 C 字符的最后下标\n  // 如果左侧没有出现过 C 字符，或者右侧出现的 C 字符距离更近，就更新 res[i]\n  for (let i = S.length - 1; i >= 0; i--) {\n    if (res[i] === Infinity || res[i + 1] - i < i - res[i]) res[i] = res[i + 1];\n  }\n\n  // 计算距离\n  for (let i = 0; i < res.length; i++) {\n    res[i] = Math.abs(res[i] - i);\n  }\n  return res;\n};\n```\n\n**直接计算距离：**\n\nJavaScript Code\n\n```js\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  var res = Array(S.length);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) res[i] = 0;\n    // 记录距离：res[i - 1] + 1\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1] + 1;\n  }\n\n  for (let i = S.length - 1; i >= 0; i--) {\n    // 更新距离：res[i + 1] + 1\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1;\n  }\n\n  return res;\n};\n```\n\nC++ Code\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        int n = S.length();\n        vector<int> dist(n, n);\n\n        for (int i = 0; i < n; i++) {\n            if (S[i] == C) dist[i] = 0;\n            else if (i > 0) dist[i] = dist[i - 1] + 1;\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (dist[i] == n\n                || (i < n - 1 && dist[i + 1] + 1 < dist[i]))\n                    dist[i] = dist[i + 1] + 1;\n        }\n\n        return dist;\n    }\n};\n```\n\nPython Code\n\n```py\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        res = [0 if s[i] == c else None for i in range(n)]\n\n        for i in range(1, n):\n            if res[i] != 0 and res[i - 1] is not None:\n                res[i] = res[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if res[i] is None or res[i + 1] + 1 < res[i]:\n                res[i] = res[i + 1] + 1\n        return res\n```\n\n## 解法 4：窗口\n\n### 思路\n\n把 `C` 看成分界线，将 `S` 划分成一个个窗口。然后对每个窗口进行遍历，分别计算每个字符到窗口边界的距离最小值。\n\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_1.png)\n\n### 复杂度分析\n\n- 时间复杂度：$O(N)$，N 是 S 的长度。\n- 空间复杂度：$O(1)$。\n\n### 代码 (JS/C++/Python)\n\nJavaScript Code\n\n```js\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  // 窗口左边界，如果没有就初始化为 Infinity，初始化为 S.length 也可以\n  let l = S[0] === C ? 0 : Infinity,\n    // 窗口右边界\n    r = S.indexOf(C, 1);\n\n  const res = Array(S.length);\n\n  for (let i = 0; i < S.length; i++) {\n    // 计算字符到当前窗口左右边界的最小距离\n    res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\n\n    // 遍历完了当前窗口的字符后，将整个窗口右移\n    if (i === r) {\n      l = r;\n      r = S.indexOf(C, l + 1);\n    }\n  }\n\n  return res;\n};\n```\n\nC++ Code\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        int n = S.length();\n\n        int l = S[0] == C ? 0 : n;\n        int r = S.find(C, 1);\n\n        vector<int> dist(n);\n\n        for (int i = 0; i < n; i++) {\n            dist[i] = min(abs(i - l), abs(r - i));\n            if (i == r) {\n                l = r;\n                r = S.find(C, r + 1);\n            }\n        }\n\n        return dist;\n    }\n};\n```\n\nPython Code\n\n```py\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        res = [0 for _ in range(n)]\n\n        l = 0 if s[0] == c else n\n        r = s.find(c, 1)\n\n        for i in range(n):\n            res[i] = min(abs(i - l), abs(r - i))\n            if i == r:\n                l = r\n                r = s.find(c, l + 1)\n        return res\n```\n\n更多题解可以访问：[https://github.com/suukii/91-days-algorithm](https://github.com/suukii/91-days-algorithm)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917538656","body":"# 1381.设计一个支持增量操作的栈\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n- [1381.设计一个支持增量操作的栈](#1381dot设计一个支持增量操作的栈)\n  - [题目描述](#题目描述)\n  - [方法 1: 用数组或链表模拟栈](#方法-1-用数组或链表模拟栈)\n    - [数组](#数组)\n    - [复杂度分析](#复杂度分析)\n    - [链表](#链表)\n    - [复杂度分析](#复杂度分析-1)\n    - [代码](#代码)\n  - [方法 2: 空间换时间](#方法-2-空间换时间)\n    - [图解](#图解)\n    - [复杂度分析](#复杂度分析-2)\n    - [代码](#代码-1)\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n \n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1);                          // 栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n \n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/design-a-stack-with-increment-operation\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n```\n\n## 方法 1: 用数组或链表模拟栈\n\n### 数组\n\n使用数组来模拟栈，可以实现时间复杂度 $O(1)$ 的 `push` 和 `pop`，和 $O(k)$ 的 `inc`，剩下的就跟着题目描述来实现就好了。\n\n-   当栈元素个数等于 `maxSize` 时不允许继续入栈；\n-   当栈为空时，出栈操作返回 -1；\n-   增量操作时，当栈元素多于 `k` 个，将栈底的 k 个元素都加 `val`，栈元素少于 `k` 个时将所有元素都加上 `val`。\n\n### 复杂度分析\n\n-   时间复杂度：`push` 和 `pop` 是 $O(1)$，`inc` 是 $O(k)$。\n-   空间复杂度：$O(maxSize)$。\n\n### 链表\n\n也可以使用链表来模拟栈，入栈出栈都只操作 `head`，也能实现时间复杂度 $O(1)$ 的 `push` 和 `pop` 操作，但 `inc` 操作的话，由于找到从链表尾端开始的第 `k` 个元素 (可以用双指针来找) 的时间复杂度是 $O(n)$，然后将链表尾端的 `k` 个元素进行增量操作的时间复杂度是 $O(k)$，所以增量操作总的时间复杂度是 $O(n+k)$。\n\n### 复杂度分析\n\n-   时间复杂度：`push` 和 `pop` 是 $O(1)$，`inc` 是 $O(n+k)$。\n-   空间复杂度：$O(maxSize)$。\n\n### 代码\n\nJavaScript Code\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.list = [];\n    this.maxSize = maxSize;\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.list.length < this.maxSize) {\n        this.list.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    const item = this.list.pop();\n    return item === void 0 ? -1 : item;\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    for (let i = 0; i < k && i < this.list.length; i++) {\n        this.list[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\nPython Code\n\n```py\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.list = []\n        self.maxSize = maxSize\n\n    def size(self):\n        return len(self.list)\n\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if self.size() < self.maxSize:\n            self.list.append(x)\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return -1 if self.size() == 0 else self.list.pop()\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        size = k if k < self.size() else self.size()\n        for i in range(0, size):\n            self.list[i] += val\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## 方法 2: 空间换时间\n\n其实我们只在出栈时才关心元素的值，所以在增量操作的时候，可以不用去更新栈内的元素，而是用一个 hashMap 来记录第几个元素需要增加多少。出栈时，检查当前元素的下标是否在 hashMap 中有记录，有的话就加上增量再出栈。这样我们就得到了时间复杂度 $O(1)$ 的增量操作，不过代价就是额外的 $O(N)$ 空间。\n\n### 图解\n\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/custom_stack.png)\n\n### 复杂度分析\n\n-   时间复杂度：`push`, `pop` 和 `inc` 都是 $O(1)$。\n-   空间复杂度：$O(maxSize)$，模拟栈的数组和哈希表的空间都是 $O(maxSize)$\n\n### 代码\n\nJavaScript Code\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.list = [];\n    this.maxSize = maxSize;\n    this.hashMap = {};\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nCustomStack.prototype._setInc = function (key, value) {\n    if (!(key in this.hashMap)) {\n        this.hashMap[key] = 0;\n    }\n    this.hashMap[key] += value;\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nCustomStack.prototype._getInc = function (key) {\n    return this.hashMap[key] || 0;\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype._size = function () {\n    return this.list.length;\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this._size() < this.maxSize) {\n        this.list.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    const top = this._size() - 1;\n    const inc = this._getInc(top);\n\n    let item = this.list.pop();\n    if (item === void 0) {\n        return -1;\n    }\n\n    item += inc;\n    const newTop = top - 1;\n    this._setInc(newTop, inc);\n    this.hashMap[top] = 0;\n    return item;\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    const size = this._size();\n    k = k < size ? k - 1 : size - 1;\n    this._setInc(k, val);\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bingyingchu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916561783","body":"```\r\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]: \r\n        # if k is 0, do an early return\r\n        if k == 0:\r\n            return num\r\n        # convert the array into an integer\r\n        temp = 0\r\n        for i in range(len(num)):\r\n            temp = temp * 10 + num[i]\r\n        # get the updated integer\r\n        temp = temp + k\r\n        # convert it back to an array by appending digits of the integer backwards to the result array\r\n        result = []\r\n        while temp > 0:\r\n            result.append(temp%10)\r\n            temp = temp // 10\r\n        return result[::-1]\r\n\r\n\r\ntime: O(n) - n is the length of num\r\nspace: O(n)\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917512096","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.s = []\r\n        self.size = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.s) < self.size:\r\n            self.s.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.s) == 0:\r\n            return -1\r\n        else:\r\n            return self.s.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(k):\r\n            if i < len(self.s):\r\n                self.s[i] += val\r\n\r\nTime: O(1) for push and pop, O(min(k, s)) where s is the size of the stack\r\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SunStrongChina":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916563357","body":"> # 989. 数组形式的整数加法\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n> \r\n> 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n> \r\n>  \r\n> \r\n> 示例 1：\r\n> \r\n> 输入：A = [1,2,0,0], K = 34\r\n> 输出：[1,2,3,4]\r\n> 解释：1200 + 34 = 1234\r\n> 示例 2：\r\n> \r\n> 输入：A = [2,7,4], K = 181\r\n> 输出：[4,5,5]\r\n> 解释：274 + 181 = 455\r\n> 示例 3：\r\n> \r\n> 输入：A = [2,1,5], K = 806\r\n> 输出：[1,0,2,1]\r\n> 解释：215 + 806 = 1021\r\n> 示例 4：\r\n> \r\n> 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n> 输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n> 解释：9999999999 + 1 = 10000000000\r\n>  \r\n> \r\n> 提示：\r\n> \r\n> 1 <= A.length <= 10000\r\n> 0 <= A[i] <= 9\r\n> 0 <= K <= 10000\r\n> 如果 A.length > 1，那么 A[0] != 0\r\n> ```\r\n\r\n### 官方求解方法\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        result1=[]\r\n        for i in range(len(num)-1,-1,-1):\r\n            r1=num[i]+k%10\r\n\r\n            remain1=k//10+r1//10\r\n            if r1>=10:\r\n                r1=r1%10\r\n            result1.insert(0,r1)\r\n            k=remain1\r\n        if k>0:\r\n            while k:\r\n                result1.insert(0,k%10)\r\n                k=(k-k%10)//10\r\n        return result1\r\n```\r\n时间复杂度:O(N)\r\n空间复杂度:O(N)\r\n### 字符串求解\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        str1=''\r\n        for num1 in num:\r\n            str1+=str(num1)\r\n        result1=int(str1)+k\r\n        return [int(s1) for s1 in str(result1)]\r\n```\r\n时间复杂度:O(N)\r\n空间复杂度:O(N)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917370321","body":"> # 821. 字符的最短距离\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历(正向遍历和反向遍历)\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n> \r\n> 示例 1:\r\n> \r\n> 输入: S = \"loveleetcode\", C = 'e'\r\n> 输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n> 说明:\r\n> \r\n> - 字符串 S 的长度范围为 [1, 10000]。\r\n> - C 是一个单字符，且保证是字符串 S 里的字符。\r\n> - S 和 C 中的所有字母均为小写字母。\r\n> ```\r\n解法一：字符串中每一个字符，都从左右两边找，哪个先找到目标字符，就返回距离\r\n\r\npython\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        #字符搜索法\r\n        def searchTargetStr(s,i,c):\r\n            if s[i]==c:#是的话直接返回\r\n                return 0\r\n            if i>0:#定义左右搜索起始边界\r\n                left=i-1\r\n            else:\r\n                left=i\r\n            if i<len(s)-1:\r\n                right=i+1\r\n            else:\r\n                right=len(s)-1\r\n            while left>=0 or right<=len(s)-1:#同时从左和从右开始搜索，那一个先到，哪一个就是最短距离，直接返回即可\r\n                if left>=0:\r\n                    if s[left]==c:\r\n                        return i-left\r\n                    else:\r\n                        left-=1\r\n                if right<=len(s)-1:\r\n                    if s[right]==c:\r\n                        return right-i\r\n                    else:\r\n\r\n                        right+=1\r\n        results=[]\r\n        for i in range(len(s)):#搜索每一个字符\r\n            dis=searchTargetStr(s,i,c)\r\n            results.append(dis)\r\n        return results\r\n```\r\n时间复杂度：O(nlog(n))\r\n空间复杂度：O(n)\r\n\r\n\r\n解法二：\r\n先记录目标字符的位置，然后对于每一字符，寻找离它最近的目标字符，计算其距离\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        dict1=[]\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                dict1.append(i)\r\n        #\r\n        \r\n        results=[]\r\n        for i in range(len(s)):\r\n            res=len(s)*2+1\r\n            for v1 in dict1:\r\n                if abs(i-v1)<abs(i-res):\r\n                    res=v1\r\n            results.append(abs(res-i))\r\n        return results\r\n```\r\n时间复杂度：O(n*n)\r\n空间复杂度：O(n)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917537083","body":"> # 1381. 设计一个支持增量操作的栈\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n> \r\n> ## 前置知识\r\n> * 栈\r\n> * 前缀和\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 请你设计一个支持下述操作的栈。\r\n> \r\n> 实现自定义栈类 CustomStack ：\r\n> \r\n> CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\n> void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\n> int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\n> void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n> \r\n> \r\n> 示例：\r\n> \r\n> 输入：\r\n> [\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n> [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n> 输出：\r\n> [null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n> 解释：\r\n> CustomStack customStack = new CustomStack(3); // 栈是空的 []\r\n> customStack.push(1); // 栈变为 [1]\r\n> customStack.push(2); // 栈变为 [1, 2]\r\n> customStack.pop(); // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\n> customStack.push(2); // 栈变为 [1, 2]\r\n> customStack.push(3); // 栈变为 [1, 2, 3]\r\n> customStack.push(4); // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\n> customStack.increment(5, 100); // 栈变为 [101, 102, 103]\r\n> customStack.increment(2, 100); // 栈变为 [201, 202, 103]\r\n> customStack.pop(); // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\n> customStack.pop(); // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\n> customStack.pop(); // 返回 201 --> 返回栈顶值 201，栈变为 []\r\n> customStack.pop(); // 返回 -1 --> 栈为空，返回 -1\r\n> \r\n> \r\n> 提示：\r\n> \r\n> 1 <= maxSize <= 1000\r\n> 1 <= x <= 1000\r\n> 1 <= k <= 1000\r\n> 0 <= val <= 100\r\n> 每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n> ```\r\n#用一个数组记录栈操作的对应所加值\r\n每当需要弹出的时候，再加上那个需要加的值即可，然后同时更新下一个位置的附加值\r\n\r\n\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.add=[]\r\n        self.maxSize=maxSize\r\n        self.values=[]\r\n        self.count=0\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.count<self.maxSize:\r\n            self.count+=1\r\n            self.values.append(x)\r\n            self.add.append(0)\r\n        \r\n\r\n\r\n    def pop(self) -> int:\r\n        #栈弹出操作\r\n        if self.count<=0:\r\n            return -1\r\n        \r\n        topAdd=self.add.pop()\r\n        self.count-=1\r\n        if self.count>=1 and topAdd!=0:\r\n            self.add[-1]+=topAdd\r\n\r\n        return self.values.pop()+topAdd\r\n        \r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        minValue=k\r\n        if self.count>0:\r\n            if minValue>=self.count:\r\n                self.add[self.count-1]+=val\r\n            else:\r\n                self.add[minValue-1]+=val\r\n```\r\n   \r\n时间复杂度：O(1)，所有操作均为0(1)\r\n空间复杂度：O(n)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917762117","body":"> # 394. 字符串解码\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/decode-string/\r\n> \r\n> ## 前置知识\r\n> * 栈\r\n> * 括号匹配\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个经过编码的字符串，返回它解码后的字符串。\r\n> \r\n> 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n> \r\n> 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n> \r\n> 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n> \r\n>  \r\n> \r\n> 示例 1：\r\n> \r\n> 输入：s = \"3[a]2[bc]\"\r\n> 输出：\"aaabcbc\"\r\n> 示例 2：\r\n> \r\n> 输入：s = \"3[a2[c]]\"\r\n> 输出：\"accaccacc\"\r\n> 示例 3：\r\n> \r\n> 输入：s = \"2[abc]3[cd]ef\"\r\n> 输出：\"abcabccdcdcdef\"\r\n> 示例 4：\r\n> \r\n> 输入：s = \"abc3[cd]xyz\"\r\n> 输出：\"abccdcdcdxyz\"\r\n> ```\r\n解题思路：\r\n碰到']'就开始退栈，知道退栈字符为'['为止\r\n然后开始数字退栈，直到下一个数字不再是字符为止，最后提取该段解析结果，进栈\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        l=0\r\n        str_array=[]\r\n        while l<len(s):\r\n            str_array.append(s[l])\r\n\r\n            if s[l]==']':\r\n                str1=''\r\n                s2=str_array.pop()\r\n                while s2!='[':\r\n                    s2=str_array.pop()\r\n                    if s2!='[':\r\n                        str1=s2+str1\r\n                        \r\n                numStr=''\r\n                while len(str_array)>=1 and str_array[-1] in '01213456789':\r\n                    numStr=str_array.pop()+numStr\r\n                str_array.append(str1*int(numStr))\r\n            l+=1\r\n        return ''.join(str_array)\r\n                \r\n```\r\n时间复杂度：O(N)\r\n空间复杂度: O(N)            \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuyangqiQAQ":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916566326","body":"### 一位一位相加即可\n````java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int x = 0;\n        LinkedList<Integer> list = new LinkedList<>();\n        for (int i = 0; i < num.length; i++) {\n            int num1 = num[num.length - i - 1];\n            int num2 = k % 10;\n            k /= 10;\n            int sum = num1 + num2 + x;\n            if(sum >= 10) {\n                sum = sum - 10;\n                x = 1;\n            }else {\n                x = 0;\n            }\n            list.addFirst(sum);\n        }\n        while (k > 0 || x == 1) {\n            int num1 = k % 10 + x;\n            k /= 10;\n            if(num1 >= 10) {\n                num1 -= 10;\n                x = 1;\n            }else {\n                x = 0;\n            }\n            list.addFirst(num1);\n        }\n\n        return list;\n    }\n}\n````\n### 复杂度分析\n时间复杂度: O(max(n, logk))\n空间复杂度: O(max(n, logk)) 存储需要返回的结果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917345699","body":"### 开始没理解思路只能暴力破解\n````java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] nums = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            int left = i;\n            int right = i;\n            while (left >= 0 || right <s.length()) {\n                if(left >= 0) {\n                    if(s.charAt(left) == c) {\n                        nums[i] = Math.abs(i - left);\n                        break;\n                    }\n                    left--;\n                }\n                if(right < s.length()) {\n                    if(s.charAt(right) == c) {\n                        nums[i] = Math.abs(i - right);\n                        break;\n                    }\n                    right++;\n                }\n            }\n        }\n        return nums;\n    }\n}\n````\n\n### 两次for循环\n````java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] nums = new int[s.length()];\n        int pre = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < s.length(); i++) {\n            if(s.charAt(i) == c) pre = i;\n            nums[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE / 2;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if(s.charAt(i) == c) pre = i;\n            nums[i] = Math.min(nums[i], pre - i);\n        }\n        return nums;\n    }\n}\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917613990","body":"````java\nclass CustomStack {\n\n    int[] nums;\n\n    int first = 0;\n\n    int count = 0;\n\n    public CustomStack(int maxSize) {\n        nums = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(count == nums.length) {\n            return;\n        }\n        if(first == nums.length - 1) {\n            first = 0;\n        }else {\n            first++;\n        }\n        nums[first] = x;\n        count++;\n    }\n    \n    public int pop() {\n        if(count == 0) {\n            return -1;\n        }\n        int res = nums[first];\n        if(first == 0) {\n            first = nums.length - 1;\n        }else {\n            first--;\n        }\n        count--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        if(count == 0) {\n            return;\n        }\n        if(k > nums.length) {\n            k = nums.length;\n        }\n        int index = first;\n        //找到栈底指针\n        for (int i = 0; i < count - 1; i++) {\n            if(index == 0) {\n                index = nums.length - 1;\n            }else {\n                index--;\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            nums[index] += val;\n            if(index == nums.length - 1) {\n                index = 0;\n            }else {\n                index++;\n            }\n        }\n    }\n}\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917766185","body":"````java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder strBud = new StringBuilder();\n        Stack<Character> stack = new Stack<>();\n        for (int i = 0; i < s.length(); i++) {\n            if(s.charAt(i) == ']') {\n                StringBuilder str = new StringBuilder();\n                while (true) {\n                    char c = stack.pop();\n                    if(c == '[') break;\n                    else str.append(c);\n                }\n                int k = 0;\n                //计算k\n                int a = 1;\n                while (!stack.isEmpty() && stack.peek() >= '0' && stack.peek() <= '9') {\n                    k += a * (stack.pop() - '0');\n                    a *= 10;\n                }\n                String s1 = str.toString();\n                for (int j = 0; j < k; j++) {\n                    for (int l = s1.length() - 1; l >= 0; l--) {\n                        stack.push(s1.charAt(l));\n                    }\n                }\n            }else {\n                stack.push(s.charAt(i));\n            }\n        }\n        while (!stack.isEmpty()) {\n            strBud.append(stack.pop());\n        }\n        return strBud.reverse().toString();\n    }\n}\n````\n### 时间复杂度:O(n) n为字符串长度，因为拼接时时间复杂度会变成O(k * n)。但总的复杂度o(n)\n### 空间复杂度:O(n) n为字符串长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"newbeenoob":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916566437","body":"## 思路\r\n\r\n---\r\n\r\n从数组末尾（个位）开始，逐位相加，并计算进位，因为是从低位开始计算，每次结果都要添加到结果数组的头部\r\n\r\n## 代码：JavaScript\r\n\r\n---\r\n\r\n```JavaScript\r\nvar addToArrayForm = function(num, k) {\r\n    const ans = [];\r\n    let carry = 0;\r\n    let cur;\r\n    let Addres;\r\n    let item;\r\n    let pos = num.length - 1;\r\n    do {\r\n        cur = k % 10;\r\n        k = ~~(k / 10); // ~~ 用于下取整\r\n        item = num[pos] ?? 0;\r\n        Addres = (cur + carry + item) % 10;\r\n        carry = ~~((cur + carry + item) / 10);\r\n        ans.unshift(Addres);\r\n        --pos;\r\n    } while( (k || carry) || pos >= 0)\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n---\r\n\r\n- 时间复杂度： `O(n + logk)`  n 为输入数组长度，k为非负整数大小\r\n\r\n- 额外空间复杂度： `O(1)`  \r\n\r\n## 标签\r\n\r\n---\r\n\r\n`数组` , `模拟`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917321008","body":"## 思路\n\n---\n\n好多大佬都已经写出最优解了，这里想探究其他的 （更麻烦的😂做法) ，套的通用的BFS模板..\n\n## 代码：JavaScript\n\n---\n\n```JavaScript\nvar shortestToChar = function(s, target) {\n    \n    // BFS 模板\n    const dist = new Array(s.length).fill(Infinity);\n    const q = [];\n\n    for(let i = 0 ; i < s.length ; ++i) {\n        if (s[i] === target) {\n            dist[i] = 0;\n            q.push(i);\n        }\n    }\n\n    while(q.length){\n        const sz = q.length;\n        for(let _ = 0 ; _ < sz ; ++_) {\n            const head = q.shift();\n            if (dist[head] !== target) {\n                if (head + 1 < dist.length && dist[head + 1] > dist[head] + 1) {\n                    dist[head + 1] = dist[head] + 1;\n                    q.push(head + 1);\n                }\n                if (head - 1 >= 0 && dist[head - 1] > dist[head] + 1) {\n                     dist[head - 1] = dist[head] + 1\n                     q.push(head - 1)\n                }\n            }; \n        }\n    }\n\n    return dist;\n};\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度： `O(n^2)` \n\n- 额外空间复杂度： `O(n)`  开了一个队列\n\n## 标签\n\n---\n\n`字符串` , `广度优先遍历`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917601494","body":"## 思路1 - 直观思维，数组模拟栈，直接遍历加入增量\n\n```JavaScript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.topPointer = -1;\n    this.stack = new Array(maxSize).fill(0);\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.topPointer === this.maxSize - 1) return;\n    this.topPointer++;\n    this.stack[this.topPointer] = x;\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.topPointer === -1) return -1;\n    const ret = this.stack[this.topPointer];\n    this.topPointer--;\n    return ret;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const len = this.getSize();\n\n    for(let i = 0 ; i < len && i < k ; ++i ) {\n        this.stack[i] += val;\n    }\n};\n\nCustomStack.prototype.getSize = function() {\n    return this.topPointer + 1;\n}\n```\n\n\n\n\n\n## 思路2 - 惰性计算增量\n\n```JavaScript\n// 这个思路的核心在于惰性计算增量，也就是等弹出的时候才会计算增量\n// 维护一个增量表，记录栈中对应元素应有的增量\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.topPointer = -1;\n    this.stack = new Array(maxSize).fill(0);\n    this.incTable = new Array(maxSize).fill(0);\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.topPointer === this.maxSize - 1) return;\n    this.topPointer++;\n    this.stack[this.topPointer] = x;\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.topPointer === -1) return -1;\n    const inc = this.incTable[this.topPointer];\n    if(this.topPointer > 0 && inc > 0) this.incTable[this.topPointer - 1] += inc;\n\n    const ret = this.stack[this.topPointer] + inc;\n    this.incTable[this.topPointer] = 0; // 弹出的元素需要消除对应位置的增量\n    this.topPointer--;\n    return ret;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const curSize = this.getSize();\n    curSize > k ? this.incTable[k-1] += val : this.incTable[curSize - 1] += val;\n};\n\nCustomStack.prototype.getSize = function() {\n    return this.topPointer + 1;\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samaritan1998":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916568209","body":"### 思路：\n\n和链表相加一样，while后面的条件是 || 然后循环里面再去判断\n\n### 代码：\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n=len(num)\n        i=n-1\n        res=[]\n        carry=0\n        while i>=0 or k!=0  or carry:\n            temp=0\n            if(i>=0):\n                temp+=num[i]\n                i-=1\n            if(k!=0):\n                temp+=k%10\n                k//=10\n                \n            res.append((temp+carry)%10)\n            carry=(temp+carry)//10\n        return res[::-1]\n```\n\n### 时间复杂度\n\nO(max（n，log(k)）) n为数组长度\n\n拓展一下链表加法\n\n```python\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        p=ListNode(0)\n        head=p\n        carry=0\n        while (l1 or l2 or carry):\n            if l1:\n                carry+=l1.val\n                l1=l1.next\n            if l2:\n                carry+=l2.val\n                l2=l2.next\n            p.next=ListNode(carry%10)\n            p=p.next\n            carry=carry//10\n        return head.next\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917634523","body":"``` python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ginnydyy":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916568816","body":"## Problem\nhttps://leetcode.com/problems/add-to-array-form-of-integer/\n\n## Notes\n- Cannot solve the problem by converting `num` to int then do the addition and convert it back to int array. Because `1 <= num.length <= 104` and Integer.MAX_VALUE is smaller than that, the conversion or addition will cause overflow.\n- When doing addition, need to consider when the sum is larger than `9`, need to do the `k++` and `sum -= 10` to carry `1`, after `k /= 10`.\n- The length of `num` may be shorter than the length of `k`, the first loop condition should use the length of `num`. Use the second loop to convert the remain of `k`.\n- The length of `num` may be longer than the length of `k`, since `k%10` and `k/10` will be always 0 after `k` becomes 0, so it's ok to use the length of `num` in the first loop.\n- The original length of ArrayList is `10`, and the solution can always add the new digit at index 0 of the List, perhaps using LinkedList as the returned List would have better performance.\n\n## Solution\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new LinkedList<>();\n        for(int i = num.length - 1; i >= 0; i--){\n            int sum = num[i] + k%10;\n             k /= 10;\n            if(sum > 9){\n                k++;\n                sum -= 10;\n            }\n            result.add(0, sum);\n        }\n        while(k > 0){\n            result.add(0, k%10);\n            k /= 10;\n        }\n        return result;\n    }\n}\n```\n\n## Complexity\n- Time: The solution processes each element of `num` and each digit of `k`. So it's O(max(n, `the number of digits of k`)). And the `the number of digits of k` is `logk` (https://brilliant.org/wiki/finding-digits-of-a-number/). So it's O(max(n, logk)) (n is the length of `num`).\n- Space: Except the returned List, the extra space used is O(1).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917334085","body":"## Problem\nhttps://leetcode.com/problems/shortest-distance-to-a-character/\n\n## Notes\n- Scan the input array from left to right, set the distance between each element and the previous seen char `c` to the result array (`pos - i`).\n- Start from index `0`, the initial value of `pos` (the index of the last seen char `c`) is `-n` (`n` is the lenght of input array), so the distance of the elements scanned before the first seen char `c` would be an int greater than `n`. Thus, when scanning from right to left, the new distance would be shorter than it and be adopted.\n- Scan the input array from right to left, the new distance between each element and the previous seen char `c` (`i - pos`) is compared to the current distance, update it with the shorter one.\n- Start from index `pos - 1`, because the distance of the elements on the right side of `pos` won't be updated.\n\n## Solution\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int pos = -n;\n        int[] result = new int[n];\n        for(int i = 0; i < n; i++){\n            if(s.charAt(i) == c){\n                pos = i;\n            }\n            result[i] = i - pos;\n        }\n        for(int i = pos - 1; i >= 0; i--){\n            if(s.charAt(i) == c){\n                pos = i;\n            }\n            result[i] = Math.min(result[i], pos - i);\n        }\n        \n        return result;\n    }\n}\n```\n\n## Complexity\n- Time: Scan twice. O(n).\n- Space: The returned array. O(n).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917549800","body":"## Problem\nhttps://leetcode.com/problems/design-a-stack-with-increment-operation/\n\n## Notes\n- Design a stack backed by an array.\n- Initialize the array using the `maxSize` (constructor parameter). Use the `size` to record the actual number of elements in the stack.\n- `push`/`pop` elements to/from the end of the array (the right side).\n\n## Solution\n```java\nclass CustomStack {\n    private int[] array;\n    private int size = 0;\n\n    public CustomStack(int maxSize) {\n        array = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(size < array.length){\n            array[size] = x;\n            size++;\n        }\n    }\n    \n    public int pop() {\n        if(size == 0){\n            return -1;\n        }\n        int result = array[size - 1];\n        size--;\n        return result;\n    }\n    \n    public void increment(int k, int val) {\n        if(size == 0){\n            return;\n        }\n        int count = Math.min(k, size);\n        for(int i = 0; i < count; i++){\n            array[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\n## Complexity\n- Time: push: O(1); pop: O(1); increment: O(min(k, n)) (n is the number of elements in the stack).\n- Space: O(maxSize) for the backed array. O(1) for extra space.","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"GemZq":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916569778","body":"### 代码\n```python \nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        A_list = [str(i) for i in num ]\n        A_number = int(''.join(A_list))\n        result_number = A_number + k\n        result = [int(i) for i in str(result_number)]\n        return result\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlemoon-zh":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916571164","body":"## day 1\n\n简单粗暴的解法：\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = 0\n        for number in num:\n            n = n * 10 + number\n        return [int(ch) for ch in str(k + n)]\n```\n复杂度：`O(n)`\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917428451","body":"## day 2\n\n两次扫的做法，每次维护一个last表示最近一次看见的目标字符位置，时间复杂度为`O(n)`：\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [float('inf')] * len(s)\n        last = None\n        \n        for i in range(len(s)):\n            if s[i] == c:\n                last = i\n                res[i] = 0\n            \n            elif last != None:\n                res[i] = abs(last-i)\n        \n        last = None\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c:\n                last = i\n            elif last != None:\n                res[i] = min(res[i], abs(last-i))\n        return res\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917702341","body":"## day 4\n\n[Leetcode 394 Decode String](https://leetcode.com/problems/decode-string/)\n\n这题还是有些难度的，用到了stack，其实也是一种递归的思维，因为递归就是栈。然后再根据题目要求，写出满足的逻辑即可。\n\n由于题目说明了，所有的格式都是规范的，不会出现`3a`这种情况，所以我们只要按照规则做就行了。\n\n- 遇到数字时，将其压入数字栈中；\n- 遇到`[`和其他字母时，压入符号栈中；\n- 遇到`]`时，表示我们可以进行一个字符串拼接了；\n    - 拼接的字符串来自符号栈中，不断出栈，直到遇到第一个`[`，表示当前的字符串完毕；\n    - 接着从数字栈中弹出一个元素，表示将刚才的字符串重复若干遍；\n    - 再将重复过的字符串压入符号栈中，继续上述过程；\n\n最后符号栈中的各个字符串都是并列的关系，比如`4[a]3[cd]`，最终的结果是 `['aaaa', 'cdcdcd']`，使用join函数将它们拼接到一起就可以了。\n\n代码如下：\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        i = 0\n        num = []\n        ch = []\n\n        while i < len(s):\n            if s[i].isdigit():\n                n = 0\n                while s[i].isdigit():\n                    n = n * 10 + int(s[i])\n                    i += 1\n                num.append(n)\n            elif s[i] == ']':\n                ss = []\n                while ch[-1] != '[':\n                    ss.insert(0, ch.pop(-1))\n                ch.pop(-1)\n                ch.append(''.join(ss) * num.pop(-1))\n                i += 1\n            else:\n                ch.append(s[i])\n                i += 1\n                \n        # print(ch)\n        return ''.join(ch)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xbhog":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916571254","body":"# 989.数组形式的整数加法\n\n## 思路：\n\n首先的思路是：\n\n1. 遍历数组整合成整数\n2. 与k值相加\n\n刚开始前三个测试样例平安无事，从测4后开始疯狂溢出。\n\n把int 改成Long，短暂解决，测96后，又开始了一轮溢出.....\n\n解决方式：\n\n数组的最后一位与k的最后一位相加，注意进位量。\n\n思考缺点：\n\n1. 对数据不敏感\n2. 思考不完整\n3. 读题不明确就上手做\n\n## 代码段：\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int n = num.length;\n        for(int i = n-1; i >= 0; i--){\n            //数组最后一个与k的最后一位相加\n            int sum = num[i]+k%10;\n            k /= 10;\n            if(sum >= 10){\n                sum -=10;\n                //进位设置\n                k++;\n            }\n            res.add(sum);\n        }\n        //防止k的位数大于num\n        for(;k >0; k/=10){\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n## 复杂度分析：\n\n无嵌套,除返回值以外，操作空间为O(1)\n\n- 时间复杂度 O(N)\n- 空间复杂度 O(1)\n\n如果解释有所错误，欢迎朋友指正，感谢！\n\n## ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917322785","body":"# 821. 字符的最短距离\n\n## 思路：\n\n两层循环，i,j表示两个指针，设置一个临时变量，在遍历数组时，找到i-j的最小值更新。\n\n## 代码段：\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        List<Integer> list = new ArrayList<>();\n        char[] ch = s.toCharArray();\n        int n = ch.length;\n    \n        for(int i = 0; i < n; i++){\n            int t = Integer.MAX_VALUE;\n            if(ch[i] == c){\n                list.add(0);\n                continue;\n            }\n            for(int j = 0; j < n; j++){\n                if(ch[j] == c){\n                    int temp = Math.abs(i-j);\n                    if(temp < t) t = temp;;\n                }\n            }\n            list.add(t);\n        }\n        int[] res = new int[list.size()];\n        int cnt = 0;\n        for(int i : list){\n            res[cnt++] = i;\n        }\n        return res;\n    }\n}\n```\n\n## 复杂度分析：\n\n时间复杂度：O(n^2)\n\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917535093","body":"# [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n## 思路：\n\n开始使用的Deque来实现，后来发现在increment函数中实现有些麻烦。\n\n又转成数组实现：\n\n**简单的使用模板**\n\n```\n// tt表示栈顶\nint stk[N], tt = 0;\n\n// 向栈顶插入一个数\nstk[ ++ tt] = x;\n\n// 从栈顶弹出一个数\ntt -- ;\n\n// 栈顶的值\nstk[tt];\n\n// 判断栈是否为空\nif (tt > 0)\n{\n\n}\n```\n\n## Java代码段：\n\n```java\nclass CustomStack {\n    static int[] stk;\n    static int tt;\n    public CustomStack(int maxSize) {\n        tt = -1;\n        stk = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(tt < stk.length-1){\n            stk[++tt] = x;\n        }\n    }\n    \n    public int pop() {\n        if(tt == -1) return -1;\n        tt--;\n        return stk[tt+1];\n    }\n    \n    public void increment(int k, int val) {\n        if(stk.length < k){\n            for(int i = 0; i < stk.length; i++){\n                stk[i] += val;\n            }\n        }else{\n            for(int i = 0; i < k; i++){\n                stk[i] += val;\n            }\n        }\n        \n    }\n}\n```\n\n## 复杂度分析：\n\n时间复杂度：push、pop 为O(1),inc为O(N);\n\n空间复杂度：O(maxSize);","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"st2yang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916573727","body":"## 思路\r\n- k 添加到末尾\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        n = len(num)\r\n        res = []\r\n\r\n        i = n - 1\r\n        while i >= 0 or k > 0:\r\n            if i >= 0:\r\n                k += num[i]\r\n            res.append(k % 10)\r\n            i -= 1\r\n            k //= 10\r\n        \r\n        return res[::-1]\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(n)\r\n- 空间: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917053954","body":"## 思路\r\n- 数组正反向遍历\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        res = [inf] * n\r\n\r\n        l = -inf\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                l = i\r\n            res[i] = i - l\r\n        \r\n        r = inf\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                r = i\r\n            res[i] = min(r - i, res[i])\r\n        \r\n        return res\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(n)\r\n- 空间: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917544977","body":"## 思路\r\n- 数组\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.data = []\r\n        self.cnt = 0\r\n        self.max_size = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.max_size:\r\n            self.data.append(x)\r\n            self.cnt += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt > 0:\r\n            self.cnt -= 1\r\n            return self.data.pop()\r\n        return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(k, self.cnt)):\r\n            self.data[i] += val\r\n```\r\n\r\n## 复杂度\r\n- 时间: push O(1), pop O(1), increment O(k)\r\n- 空间: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917807393","body":"## 思路\r\n- stack\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n\r\n        for c in s:\r\n            if c == ']':\r\n                stri = \"\"\r\n                cnt = \"\"\r\n                while stack and stack[-1] != '[':\r\n                    stri = stack.pop() + stri\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    cnt = stack.pop() + cnt\r\n                stack.append(stri * int(cnt))\r\n            else:\r\n                stack.append(c)\r\n\r\n        return \"\".join(stack)\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(n)\r\n- 空间: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiezhengyun":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916575375","body":"# 思路\n- 把k转数组，变成两个数组相加\n- 生成res数组。长度要比num 和 kArr 最大长度 + 1\n- 个位数相加，添加到res 数组\n- 判断进位carry，返回结果\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  var l1 = num.length - 1;\n  var kArr = String(k).split('');\n  var l2 = kArr.length - 1;\n  var resLen = (l1 > l2 ? l1 : l2) + 1;\n  var res = new Array(resLen + 1).fill(0);\n  var carry = 0;\n\n  while (l1 > -1 || l2 > -1) {\n    var val1 = l1 > -1 ? num[l1] : 0;\n    var val2 = l2 > -1 ? kArr[l2] : 0;\n\n    var sum = val1 + Number(val2) + carry;\n    var carry = Math.floor(sum / 10);\n    res[resLen] = Math.floor(sum % 10);\n\n    resLen--;\n    if (l1 > -1) l1--;\n    if (l2 > -1) l2--;\n  }\n\n  if (carry) {\n    res[resLen] = carry;\n  } else {\n    res.shift();\n  }\n  return res;\n};\n```\n# 复杂度分析\nN是数组nums的长度，K是数字k的长度\n- 时间复杂度  O(max(N,K) + shift) shift 是数组删除第一个元素\n- 空间复杂度 O(max(N,K)+1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917373358","body":"# 821. 字符的最短距离\n\n# 思路\n- 计算字符串 s 中每个字符 向左 或 向右 距离 c 的距离;\n- 通过两次便利分别找出 向左，向右的距离，取最小值\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n  var res = new Array(s.length - 1);\n  //prev 上一个 c 出现的位置\n  // i 元素 向左查找， prev初始设为 -10001，因为s.length 最大值为 10000(因为第一个元素如果不是c，那第一个元素距离左边的c距离是无的，用一个极大值来表示)\n  // 此时res 存 向左查找遇到 c 的距离\n  var prev = -10001;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) prev = i;\n    res[i] = i - prev;\n  }\n  // 接着 算出 数组每一位 向右，遇到c 的距离\n  // prev = 10001\n  // 此时 res[i]，取向左和向右的最小值\n  prev = 10001;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s[i] === c) prev = i;\n    res[i] = Math.min(res[i], prev - i);\n  }\n  return res;\n};\n```\n\n# 复杂度\n- 时间复杂度 O(N) ,遍历2次数组\n- 空间复杂度，除返回的数组外，O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917541225","body":"```js\nclass CustomStack {\n  constructor(maxSize) {\n    this.maxSize = maxSize;\n    this.arr = [];\n  }\n\n  push(x) {\n    if (this.arr.length >= this.maxSize) return;\n    this.arr.push(x);\n  }\n\n  pop() {\n    if (this.arr.length > 0) {\n      return this.arr.pop();\n    }\n    return -1;\n  }\n\n  increment(k, val) {\n    var min = Math.min(k, this.arr.length);\n    for (var i = 0; i < min; i++) {\n      this.arr[i] = this.arr[i] + val;\n    }\n  }\n}\n```\n## 复杂度\n- 时间复杂度: increment  O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kofzhang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916575768","body":"### 思路\n列表转成数值，加上k，然后倒着一位一位加到列表，然后反转列表\n### 代码（Python3）\n```python\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        inta = 0\n        for i in A:\n            inta = inta*10 + i\n        inta = inta+K\n        res = []\n        while inta!=0:\n            res.append(inta%10)\n            inta//=10\n        if not res:\n            res.append(0)\n        return res[::-1]\n```\n### 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917412218","body":"### 思路\r\n先把所有目标字符位置标记，然后再走一遍，取近的距离\r\n### 代码（Python3）\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = []\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                l.append(i)\r\n        k = 0\r\n        res = []\r\n        for i in range(len(s)):\r\n            if k!=len(l)-1 and abs(i-l[k])>abs(i-l[k+1]):\r\n                k += 1\r\n            res.append(abs(i-l[k]))\r\n        return res\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917649977","body":"### 思路\r\n保存数据的同时保存增量，可以利用空间换时间，缩小时间复杂度\r\n### 代码（Python3）\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack)<self.maxSize:\r\n            self.stack.append([x,0])\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            x,val = self.stack.pop()\r\n            if self.stack:\r\n                self.stack[-1][1]+=val\r\n            return x+val\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if not self.stack:\r\n            return\r\n        if len(self.stack)<=k:\r\n            self.stack[-1][1]+=val\r\n        else:\r\n            self.stack[k-1][1]+=val\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917748878","body":"### 思路\r\n用栈存储\r\n倒序遍历字符串，遇到数值的下一个字符，处理字符串。\r\n### 代码（Python3）\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack=[]\r\n        flag = False\r\n        for c in s[::-1]+\"/\":\r\n            \r\n            if c.isdigit():\r\n                flag = True\r\n            if flag and not c.isdigit():    \r\n                flag = False            \r\n                temp = []\r\n                while True:\r\n                    t = stack.pop()\r\n                    if t!=\"]\":\r\n                        temp.append(t)\r\n                    else:\r\n                        break\r\n                temp = \"\".join(temp).split(\"[\")\r\n                stack.append(int(temp[0])*temp[1])\r\n            stack.append(c)\r\n        stack.pop()\r\n        return \"\".join(stack[::-1])\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Toms-BigData":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916577408","body":"# 思路\n将数组中的数字转化为字符拼接成字符串，将字符串转化为int类型与K相加后再次转化为字符串，通过list()和map()函数将字符串拆分成int数组\n# 代码：Python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num_str = \"\".join('%s' %id for id in num)\n        num_data = str(int(num_str) + k)\n        return list(map(int,num_data))\n# 时间复杂度\n时间复杂度为O(n)\n空间复杂度为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917330247","body":"# 821. 字符的最短距离\n## 思路：\n建立一个长度等同于s的值全为float('inf')的数组，一个记录上次出现c位置的变量，循环遍历s。\n当第一次出现c时，将所有字符到该字符的距离存入数组。\n当s中再次出现c时，比较从上一个c出现后，后一位的距离到该位置的距离哪个近（因为在上一个位置出现c之前的字符的距离一定小于后面出现c的距离）更新数组\n## Python3代码：\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        distance_list = [float('inf') for _ in range(len(s))]\n        last_char_position = -1\n        for i in range(len(s)):\n            if s[i] == c:\n                for j in range(last_char_position+1,len(distance_list)):\n                    distance_list[j] = abs(j-i) if abs(j-i) < distance_list[j] else distance_list[j]\n        return distance_list\n## 复杂度分析\n时间复杂度：O(N^2)\n\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ymkymk":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916579966","body":"# **思路**\n\n从低位开始相加，大于10就进位\n\n# **代码**\n\n``\n\n```\npublic class Solution {\n\n    public List<Integer> addToArrayForm(int[] num, int k){\n        List<Integer> res = new ArrayList<Integer>();\n        int len = num.length;\n        for (int i = len - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10){\n                //进一位\n                k++;\n                //减去10才是需要的数\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n\n        /**\n         * 如果k位数比数组多\n         */\n        for(; k > 0; k /= 10){\n            res.add(k % 10);\n        }\n\n        //链表反转\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n\n\n# **复杂度分析**\n\n时间复杂度：O(max(n, logk))，如果n>k，那么复杂度就是O(n)，如果k比n大，那么复杂度就是O(logk)\n\n空间复杂度：O(1)，每次使用的空间都为常数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917333047","body":"# **思路**\n\n左右开弓，计算数组左右两边哪个值小就取哪个，先从左边开始计算得到一个数组，然后再从右边遍历，取最小值\n\n# **代码**\n\n``\n\n```\npublic class Solution {\n\n    public int[] shortestToChar(String s, char c){\n        int len = s.length();\n        int[] ans = new int[len];\n        //因为s.length <= 10 *10 *10 *10\n        int prev = - 10 *10 *10 *10;\n\n        for (int i = 0; i < len; ++i) {\n            if (s.charAt(i) == c) {\n                prev = i;\n            }\n            ans[i] = i - prev;\n        }\n\n        prev = 10 *10 *10 *10;\n        for (int i = len-1; i >= 0; --i) {\n            if (s.charAt(i) == c) {\n                prev = i;\n            }\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n```\n\n\n\n# **复杂度分析**\n\n时间复杂度：O(n)，需要左右遍历，一共两次\n\n空间复杂度：O(n)，new了一个ans数组出来，这个数据占用的大小为n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917534771","body":"# **思路**\n\nincrement并不直接将val加到栈中，而是先记录k和val，等到pop时再加入\n\n# **代码**\n\n``\n\n```\npublic class CustomStack {\n\n\n    private int size;\n    private int[] increment;\n    private int[] stack;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        increment = new int[maxSize+1];\n        size = 0;\n    }\n\n    public void push(int x) {\n       if (size == stack.length){\n           return;\n       }\n\n       stack[size++] = x;\n    }\n\n    public int pop() {\n        if (size == 0) {\n            return -1;\n        }\n\n        int ret = stack[size - 1];\n        if (increment[size] != 0){\n            ret += increment[size];\n            increment[size - 1] += increment[size];\n            increment[size] = 0;\n        }\n        size--;\n        return ret;\n    }\n\n    public void increment(int k, int val) {\n        increment[Math.min(k, size)] += val;\n    }\n}\n```\n\n\n\n# **复杂度分析**\n\n时间复杂度：O(1)\n空间复杂度：O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HackBL":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916580190","body":"```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new LinkedList();\r\n        \r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            k += num[i];\r\n            list.add(0, k%10);\r\n            k /= 10;\r\n        }\r\n        \r\n        while (k > 0) {\r\n            list.add(0, k%10);\r\n            k /= 10;\r\n        }\r\n        \r\n        return list;\r\n    }\r\n}\r\n```\r\n* 时间复杂度: O(Max(n, k))\r\n* 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917156860","body":"* 正反向遍历\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int k = -s.length();\r\n        \r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) \r\n                k = i;\r\n            \r\n            res[i] = i - k;\r\n        }\r\n        \r\n        for (int i = k; i >= 0; i--) {\r\n            if (s.charAt(i) == c)\r\n                k = i;\r\n            res[i] = Math.min(res[i], k-i);\r\n        }\r\n        \r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n* Time: O(n)\r\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917481827","body":"* LinkedList构建Stack\r\n```\r\nclass CustomStack {\r\n    Node head;\r\n    int maxSize;\r\n    int size;\r\n    int[] inc;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        this.head = null;\r\n        this.maxSize = maxSize;\r\n        this.size = 0;\r\n        this.inc = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (size < maxSize) {\r\n            Node node = new Node(x);\r\n            node.next = head;\r\n            head = node;\r\n            size++;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (size == 0) return -1;\r\n        int cur = head.val;\r\n        head = head.next;\r\n        int i = --size;\r\n        \r\n        if (i >= 1)\r\n            inc[i-1] += inc[i];\r\n        \r\n        \r\n        cur += inc[i];\r\n        inc[i] = 0;\r\n        \r\n        return cur;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int i = Math.min(size, k) - 1;\r\n        if (i < 0) return;\r\n        inc[i] += val;\r\n    }\r\n    \r\n    class Node{\r\n        Node next;\r\n        int val;\r\n        \r\n        public Node(int val) {\r\n            this.val = val;\r\n        }\r\n    }\r\n}\r\n```\r\n* Time: O(1) for all operations\r\n* Space O(n)\r\n* 空间换时间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917699649","body":"* Stack判断括号\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Deque<StringBuilder> strStack = new LinkedList<>();\r\n        Deque<Integer> intStack = new LinkedList<>();\r\n        StringBuilder sb = new StringBuilder();\r\n        int k = 0;\r\n        \r\n        for (char c: s.toCharArray()) {\r\n            if (Character.isDigit(c)) {\r\n                k = k * 10 + (c - '0');\r\n            } else if (c == '[') {\r\n                strStack.push(sb);\r\n                intStack.push(k);\r\n                \r\n                sb = new StringBuilder();\r\n                k = 0;\r\n            } else if (c == ']') {\r\n                StringBuilder tmp = sb;\r\n                sb = strStack.pop();\r\n                \r\n                for (int i = intStack.pop(); i > 0; i--)\r\n                    sb.append(tmp);\r\n            } else {\r\n                sb.append(c);\r\n            }\r\n        }\r\n        \r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n* Time: O(maxK*n) such as k[string]\r\n* Space: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"TimmmYang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916580399","body":"## 思路\n从低到高逐位相加。如果k的位数比X多，就继续执行一遍。可以把两个循环合并，给结果单开一个list逆序返回。\n## 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        for i in range(len(num) - 1, -1, -1):\n            summ = num[i] + k % 10 + carry\n            k //= 10\n            carry = 0\n            if summ >= 10:\n                carry = 1\n                summ -= 10\n            num[i] = summ\n        if carry == 1 and k == 0:\n            num.insert(0, 1)\n            return num\n        while k != 0:\n            summ = k % 10 + carry\n            k //= 10\n            carry = 0\n            if summ >= 10:\n                carry = 1\n                summ -= 10\n            num.insert(0, summ)\n        if carry == 1:\n            num.insert(0, 1)\n        return num\n```\n## 复杂度\n时间：O(max(n, log(k)))，n为num长度\n\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917351996","body":"# 方法一\r\n## 思路\r\n第一反应的做法，两次遍历，使用额外列表存含有c的index。这样出现了循环嵌套，虽然可以通过但是不够优秀\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        record = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                record.append(i)\r\n        for i in range(len(s)):\r\n            d = len(s)\r\n            for idx in record:\r\n                d = min(abs(i - idx), d)\r\n            res.append(d)\r\n        return res\r\n```\r\n\r\n## 复杂度\r\n时间：O(N^2)\r\n空间：O(N)\r\nN为s长度\r\n\r\n# 方法二\r\n## 思路\r\n使用正反两次遍历，每次存该位置元素离最左（右）边目标的距离，两者取最小值即为答案。\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        idx = float('-inf')\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                idx = i\r\n            res.append(i - idx)\r\n        idx = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            res[i] = (min(res[i], idx - i))\r\n        return res\r\n```\r\n### 复杂度\r\n时间：O(N)\r\n空间：O(N)\r\nN为s长度\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917593338","body":"## 思路\r\n普通的直接数组increment方法时间复杂度为O(min(k,len(stack))，不够优秀。使用空间换时间，增加一个add列表存增量，pop的时候加上增量即可。\r\n## 代码\r\n```python\r\nclass CustomStack:\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0] * maxSize\r\n        self.add = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) - 1 != self.top:\r\n            self.top += 1\r\n            self.stack[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        res = self.stack[self.top] + self.add[self.top]\r\n        if self.top != 0:\r\n            self.add[self.top - 1] += self.add[self.top]\r\n        self.add[self.top] = 0\r\n        self.top -= 1\r\n        return res\r\n        \r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k - 1, self.top)\r\n        if lim >= 0:\r\n            self.add[lim] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n\r\n## 复杂度\r\n时间: 全部为O(1)\r\n空间: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917788183","body":"## 思路\r\n结果需要从括号内向外逐层解开，使用栈可以达到我们的目标。最后在栈内的字符串都是解好的字符串，连起来返回即可。\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                mul = ''\r\n                tmp = ''\r\n                while stack and stack[-1] != '[':\r\n                    tmp = stack.pop() + tmp. # 在前面pop后面就不用翻转了\r\n                stack.pop()\r\n                while stack and stack[-1].isdigit():\r\n                    mul = stack.pop() + mul\r\n                tmp = tmp * int(mul)\r\n                stack.append(tmp)\r\n            else:\r\n                stack.append(c)\r\n        return ''.join(stack)\r\n```\r\n\r\n## 复杂度\r\n时间：O(N)，N为s长度\r\n空间：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AnhTom2000":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916581198","body":"## 思路\r\n遍历数组并且拆分k进行诸位相加，过程中注意如果两者的和超过了个位数，需要累计进位。\r\n## Java\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> list = new LinkedList<>();\r\n        int i = num.length - 1;\r\n        while( i >= 0 || k > 0){\r\n          if( i >= 0){\r\n          int sum = num[i] + k % 10;\r\n          k/=10;\r\n          if(sum >=10){\r\n            k++;\r\n            sum-=10;\r\n          }\r\n          list.addFirst(sum);\r\n          i--; \r\n        }else {\r\n          list.addFirst(k%10);\r\n          k/=10;\r\n        }\r\n      }\r\n        return list;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n时间复杂度：`O(n+logk)`,n为数组长度\r\n空间复杂度：`O(max(n,k))`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917326031","body":"## 思路\n\n- 正向遍历一遍，每次遇到目标字符就标记，然后计算非目标字符的距离\n\n- 反向遍历一遍，同上述做法，计算与正向遍历结果最小值更新数组\n\n## 代码\n\n```Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n      int len = s.length();\n      int res[] = new int[len];\n      int now = Integer.MAX_VALUE;\n      for(int i = 0; i < len; i++){\n        char target = s.charAt(i);\n        if(target == c) now = i;\n        res[i] = Math.abs( i - now);\n      }\n\n      int lNow = Integer.MAX_VALUE;\n      for(int j = len - 1; j >=0;j--){\n        char target = s.charAt(j);\n        if(target == c) lNow = j;\n        res[j] = Math.min(res[j],Math.abs(lNow - j));\n      }\n      return res;\n    }\n}\n```\n\n## 复杂度分析\n\n时间复杂度 : `O(n)`,n为字符串长度\n\n空间复杂度 : `O(n)`\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917544924","body":"## 思路\n\n使用数组模拟栈，用一个变量 size来记录当前栈顶的位置。\n\n- 对于 push 操作，首先判断当前元素的个数是否达到上限，如果没有达到，就把 size 后移一个位置并添加一个元素。\n\n- 对于 pop 操作，首先判断当前栈是否为空，非空返回栈顶元素并将 size 前移一位，否则返回 −1。\n\n- 对于 inc 操作，直接对栈底的最多 k 个元素加上 val。\n\n## 代码\n\n```Java\nclass CustomStack {\n   private int stack[];\n   private int maxSize;\n   private int size;\n    public CustomStack(int maxSize) {\n      this.maxSize = maxSize;\n      this.size = -1;\n      this.stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n      if(isFull()) return; \n      this.stack[++this.size] = x;\n    }\n    \n    public int pop() {\n      if(isEmpty()) return -1;\n      int res = this.stack[this.size];\n      this.size--;\n      return res;\n    }\n    \n    public void increment(int k, int val) {\n       for(int i = 0;i <=this.size && i < k;i++){\n         this.stack[i]+=val;\n       }\n    }\n\n    private boolean isFull(){\n      return this.size == this.maxSize-1;\n    }\n\n    private boolean isEmpty(){\n      return this.size == -1;\n    }\n}\n```\n\n## 复杂度分析\n\n时间复杂度 : `O(n)`,栈大小，push操作和poo操作的复杂度为`O(1)`\n\n空间复杂度 : `O(maxSize)`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"15691894985":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916582098","body":"day  01  989　　数组形式的整数加法\r\n\r\n- 思路：\r\n  1. 遍历数组，取出合成整数\r\n  2. 合成整数与Ｋ求和\r\n  3. 把求和后的整数再反向分解为数组\r\n\r\n- 代码段：\r\n```python\r\n  def add_to_array(arrya,k):\r\n       n = len(arrya)\r\n       x=0\r\n       y =[]\r\n      for i in range(n):\r\n          x = x+ arrya[i] * 10**(n-i-1)\r\n       x = x +k\r\n       if len(x)>n:\r\n          for i in range(len(x)):\r\n              y.append( x//(10**(len(x)-i-1)))\r\n              x = x -y[i]*(10**(len(x)-i-1))\r\n       else:\r\n          for i in range(n):\r\n              y.append( x//(10**(n-i-1)))\r\n              x = x -y[i]*(10**(n-i-1))\r\n      return y\r\n  \r\n\r\n\r\n- 复杂度分析\r\n  1. 时间复杂度 O(N)\r\n  2. 空间复杂度O(1)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917327328","body":"思路：\n\n1.先遍历记录字符c出现的位置。\n\n2.遍历字符S，找到目标字符最近的解\n```python\n    def  distance_character(self,S:str,C:str)->list[int]:\n        x =[]\n        SY = S\n        res = [1000000 for i in range (len(S))]\n        while S.rfind(C)!=-1:\n            x.append(S.rfind(C))\n            S = S[:x[-1]]\n        # 目标字符\n        x.reverse()\n        for i in range(len(SY)):\n            if SY[i]==C:\n                res[i]= 0\n        # 非目标字符，找最近\n            for index in x:\n                dist = abs(index-i)\n                if dist>res[i]: #因为计算了与第一个字符的距离后，只要后面一个比之前的距离大那么后面的都会大\n                    break\n                res[i] = dist\n        return dist\n\n\n\n复杂度分析\n\n- 时间复杂度分析 O（n*k）n是字符串长度，k是字符C出现在字符串内的次数\n- 空间复杂度O（k） k是字符C出现在字符串内的次数\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917541695","body":"思路一：用一个数组去操作increment。push和pop判断边界 记录一个当前栈长\n```python\n    class CustomStack:   #根据题目描述解法\n        def __init__(self, maxSize):\n            self.n = maxSize\n            self.stack = [] #其中元素\n            self.inc = 0 #当前长度\n        def push(self,x):#入栈操作\n            if self.inc<self.n:\n                self.stack.append(x)\n                self.inc += 1\n        def pop(self):\n            if self.inc==0:return -1\n            self.inc -= 1\n            return self.stack.pop()\n        def increment(self,k,val):\n            for i in range(0, min(k,len(self.inc))):\n                self.stack[i] += val\n\n复杂度分析：\n\n时间复杂度：push和pop都为O(1)  increment 为O(min(k,inc))\n\n空间复杂度：返回值O(1)\n\n方法二：前缀和解法\n- 思路，空间换时间，单独将Increment操作结合到pop里\n- incremnet信息，优化记录当前栈长度inc，同时pop减小increment数组的开销\n    class CustomStack:   #前缀合解法\n        def __init__(self, maxSize):\n            self.n = maxSize\n            self.stack = [] #其中元素\n            self.inc = 0 #当前长度\n            self.incrementals = []\n        def push(self, x):  # 入栈操作\n            if self.inc< self.n:\n                self.stack.append(x)\n                self.incrementals.append(0)\n                self.inc += 1\n        def pop(self):\n            if self.inc == 0: return -1\n            self.inc -= 1\n            if self.inc >=1:\n                self.incrementals[self.inc-2] += self.incrementals[self.inc-1]\n            ans = self.stack.pop() + self.incrementals.pop()\n            self.incrementals[self.inc-1] = 0\n            self.inc -= 1\n            return ans\n    \n        def increment(self, k, val):\n            if self.inc:\n                self.incrementals[min(self.inc,k)-1] += val\n\n复杂度分析:\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(inc)      维护一个大小inc的数组  inc < maxSize\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917803468","body":"9.13  day3   394.字符串解码\n\n思路：\n\n-  解码的过程是以找到成对的括弧，重复中间的字符。括弧可用先进后出特性的栈表示\n\n- 遍历S中的字符，如果不是']'重复压栈操作，如果是']'时，说明括弧匹配时候，只要栈最后一位不为'['时，继续取出刚入栈的，作为重复字符串，并执行出栈。在判断栈中倒末是否为数字，是数字则进行数字与重复字符的运算，并添加到栈中。\n```python\n    def decode_string(s):\n        stack = []\n        for c in s :\n            if c == ']':\n                repeatStr = ''\n                repeatCount = ''\n                while stack and stack[-1]!='[':   #括弧匹配时候把重复的字符取出来\n                    repeatStr = stack.pop()+ repeatStr #取出来的字符就出栈\n                stack.pop()  #把'['也出栈\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop()+repeatCount   #判断是否数值时候把数字取出来，数字出栈\n                stack.append(int(repeatCount) *repeatStr)  #按数字重复字符，并加到append\n            else:\n                stack.append(c)  #没有遇到]前持续压栈\n        return \"\".join(stack)   #把stack重新拼接\n\n复杂度分析：\n\n- 时间复杂度：O(N) 一个遍历操作，字符串的长度\n- 空间复杂度：O(N)  记录解码后的字符串所需要的空间\n\n \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MonkofEast":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916582275","body":"# Algo\n1. Loop the array in a reversing way.\n   1. **Add current int directly to the current loc**\n   2. **Cal quo and res. Save quo as new int to next iter; save res as current item**\n   > (Optional) Leave the loop if no int should be added\n2. Attach the rest of quo in front of the array\n   >**DO remember to split out the quo since quo might not be single-digit**\n\n# Code\n```py\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # there is a same question for linked list\n        \n        # xrange(start, stop[not included], step) is not a list but a generator\n        for i in range(len(num) - 1, -1, -1):\n            # if reach the highest digit, if still have k, save and add\n            # else, just keep adding\n            num[i] += k\n            # carry along\n            k, num[i] = divmod(num[i], 10)\n            # no carry, leave\n            if not k: break\n        \n        # use map to broadcast for corners like \"[0], 100\"\n        # map(func, iterable), return an iterator\n        if k: num = list(map(int, str(k))) + num\n        return num\n```\n\n# Comp\n> T: O(N)\n> \n>S: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917096987","body":"# 821. Shortest Distance to a Character\n> [Click Me](https://leetcode.com/problems/shortest-distance-to-a-character/)\n## Algo\n0. Greedy\n1. Loop from lft, find the dis to cloest 'c' on the lft\n   > **Should init a float('-inf') for first non 'c's**\n2. Loop from lft, fint the dis to cloest 'c' on the rgt\n   > **Should init a float('-inf') for first non 'c's**\n4. Save the min() from 1 & 2\n   >Can be integrated into stp-2\n\n## Code\n```py\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # greedy\n        # init a res list \n        res = []\n        \n        # save previous loc of 'c', use '-inf' for the first non 'c's\n        prev = float('-inf') # S: O(1)\n        \n        # start from left, cal the distance of cloest 'c' on the left, record\n        for i in range(len(s)):\n            if s[i] == c:\n                prev = i\n                res.append(0)\n                continue\n            res.append(i - prev)\n            \n        # reset prev for the first non 'c's\n        prev = float('inf')\n        \n        # start from right, cal the distanc of cloest 'c' on the right, record\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c:\n                prev = i\n                continue\n            res[i] = min(res[i], prev - i)\n        return res\n```\n\n## Comp\n### T: O(N)\n### S: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917505444","body":"# 1381. Design a Stack With Increment Operation\n> [Click Me](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n## Algo\n1. Use an extra increment list. inc[i] means stack[0]~stack[i] should be incremented by inc[i]\n2. When popping, use the suminc[top] and stack[top]\n    1. Passing accumulationg when poping\n4. for func increment(), just mani self.inc\n\n## Code\n```py\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        # space for time\n        self.inc = []\n\n    def push(self, x: int) -> None:\n        if len(self.inc) < self.maxSize:            \n            self.stack.append(x)\n            # each item in inc represents the increment of stack[0] ~ stack[1]\n            # thus, the number of non-zero items == number of calling increment() before any pop\n            # [0, 0, 0, 3, 0, 0, 1, 3, 2]\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        # empty stack\n        if not self.stack: return -1\n        # accumulate the increments if there are previous increment\n        if len(self.inc) > 1: self.inc[-2] += self.inc[-1]\n        return self.stack.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        # adjust self.inc[] to indicate increment\n        if self.inc: self.inc[min(k, len(self.inc)) - 1] += val\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## Comp\n### T: O(1) for push/pop/inc\n### S: O(N) stack + inc","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917697358","body":"# 394. Decode String\n> [Click Me](https://leetcode.com/problems/decode-string/)\n## Algo\n1. Consider innermost decoding, stack is good\n2. new a stack for final output\n3. new a list for temp saving decode\n4. travel through the original str\n    1. if not ']', continue\n    2. if ']', stop, decode\n\n## Code\n```py\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        # the key here is to consider cases like jksd19[dsl]fion3[acc2[d]]\n        # this nested pattern should be decode from innermost str\n        # so stack is good for this task\n        # KEY!!!: ']' on the top of stack is the starting point to decode\n        \n        stack = []\n        decodeList = []\n        \n        # travel the ori str\n        for i in range(len(s)):\n            # if not , travel\n            if s[i] != ']':\n                stack.append(s[i])\n            # if ']', stop, start decoding\n            else:\n                while stack[-1] != '[': decodeList.insert(0, stack.pop())\n                stack.pop() # delete '['\n                # find the multi times\n                times, multi = 0, 1\n                while stack and stack[-1].isnumeric():\n                    times += multi*int(stack.pop())\n                    multi *= 10\n                stack = stack + decodeList*times\n                decodeList.clear()\n        \n        # (str).join(list): return a str\n        return \"\".join(stack)\n```\n\n## Comp\n### T: O(N)\n### S: O(max(decoded-list))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916583583","body":"## 思路\n\n通过算盘模拟大数加法\n\n```js\n/**\n * @param {number[]} A\n * @param {number} K\n * @return {number[]}\n */\nvar addToArrayForm = function (A, K) {\n  // K 也转换为数组\n  K = K.toString().split('').map(v => +v)\n\n  // 保证A的长度 > K的长度\n  if (A.length < K.length) {\n    [A, K] = [K, A]\n  }\n\n  A.reverse()\n  K.reverse()\n\n\n  let carry = 0\n  for (let i = 0; i < A.length; i++) {\n    // A 长度大于 K, K[i] 可能越界\n    let b = K[i] === undefined ? 0 : K[i]\n    let curSum = A[i] + b + carry\n    A[i] = curSum % 10\n    carry = Math.floor(curSum / 10)\n  }\n\n  // 处理最后的进位\n  if (carry) {\n    A.push(carry)\n  }\n\n  return A.reverse()\n};\n```\n\n+ 时间复杂度: $O(max(n, m)), n 为数组A的长度, m 为数字K转字符后的长度\n+ 空间复杂度: $O(m)$, m 为数字K转字符后的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xj-yan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916584126","body":"# 思路\n从右向左遍历数组，并依次取k的最低位进行相加，如果结果大于10，则需要进位。\n\n# Java\n\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        boolean isCarried = false;\n        List<Integer> list = new ArrayList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0 || isCarried){\n            if (i >= 0 && k == 0 && !isCarried){\n                list.add(num[i]);\n                i--;\n                continue;\n            }\n            int val = (i >= 0 ? num[i--] : 0) + k % 10 + (isCarried ? 1 : 0);\n            if (val >= 10) {\n                val %= 10;\n                isCarried = true;\n            }else isCarried = false;\n            list.add(val);\n            k /= 10;\n            \n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n\n```\n\n# 复杂度分析\n\n时间复杂度：O(max(n, log k)),  n为数组长度\n空间复杂的：O(1) 如果不考虑输出结果占用的空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917425010","body":"# IDEA (JAVA)\r\n\r\n1. 初始化输出数组里的所有元素为10001（根据题目给出的constraints）\r\n2. 如果该index对应的string里的character为c，则把输出数组里的该index对应的数值设为Integer.MAX_VALUE.\r\n3.  设置一个Integer变量prev, 初始值设为null，第一遍从左往右扫数组，如果prev不为null，且该index不为Integer.MAX_VALUE, 则更新输出数组的值为Math.abs(prev - index)， 如果该index为Integer.MAX_VALUE, 则更新prev的数值为当前index。\r\n4. 重新把prev设为null，再第二遍从右往左扫，如果prev不为null，且该index不为Integer.MAX_VALUE, 且Math.abs(prev - index)小于当前index的数值，则更新输出数组的值为Math.abs(prev - index)，如果该index为Integer.MAX_VALUE, 则更新prev的数值为当前index，且该index对应的元素值设为0。\r\n```java\r\n    class Solution {\r\n        public int[] shortestToChar(String s, char c) {\r\n            int[] result = new int[s.length()];\r\n            \r\n            Arrays.fill(result, 10001);\r\n            for (int i = 0; i < result.length; i++){\r\n                if (s.charAt(i) == c) result[i] = Integer.MAX_VALUE;\r\n            }\r\n            \r\n            Integer prev = null;\r\n            for (int i = 0; i < result.length; i++){\r\n                if (prev != null && result[i] != Integer.MAX_VALUE){\r\n                    result[i] = Math.abs(prev - i);\r\n                }else if (result[i] == Integer.MAX_VALUE) prev = i;\r\n            }\r\n            \r\n            prev = null;\r\n            for (int i = result.length - 1; i >= 0; i--){\r\n                if (prev != null && result[i] != Integer.MAX_VALUE){\r\n                    result[i] = Math.min(result[i], Math.abs(prev - i));\r\n                }else if (result[i] == Integer.MAX_VALUE){\r\n                    prev = i;\r\n                    result[i] = 0;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n```\r\n\r\n# 复杂度分析\r\nTime Complexity: O(n)\r\nSpace Complexity: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917659369","body":"  Using the array to implement the stack with increment operation.\n\n```java\nclass CustomStack {\n\n    private int[] array;\n    private int index, capacity;\n    \n    public CustomStack(int maxSize) {\n        array = new int[maxSize];\n        index = -1;\n        capacity = maxSize;\n    }\n    \n    public void push(int x) {\n        if (index == capacity - 1) return;\n        array[++index] = x;\n    }\n    \n    public int pop() {\n        if (index == -1) return -1;\n        return array[index--];\n    }\n    \n    public void increment(int k, int val) {\n        k = Math.min(k - 1, index);\n        for (int i = 0; i <= k; i++){\n            array[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\nTime Complexity: push - O(1), pop - O(1), increment - O(k)\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917778658","body":"# Code\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<String> stack = new Stack<>();\n        Stack<Integer> numStack = new Stack<>();\n        \n        StringBuilder res = new StringBuilder();\n        int num = 0;\n        for (int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (Character.isDigit(c)){\n                num = num * 10 + c - '0';\n            }else if (c == '['){\n                numStack.push(num);\n                num = 0;\n                stack.push(res.toString());\n                res = new StringBuilder();\n            }else if(c == ']'){\n                StringBuilder tmp = new StringBuilder(stack.pop());\n                int rep = numStack.pop();\n                for (int k = 0; k < rep; k++){\n                    tmp.append(res);\n                }\n                res = tmp;\n            }else {\n                res.append(c);\n            }\n        }\n        return res.toString();\n    }\n}\n```\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ychen8777":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916584445","body":"### 思路\n一开始看到 1 <= num.length <= 10^4 ，理解成 num 所代表的数最大为 10^4，就用了把 num 转成整数，加上 k, 再转回 arrayform 的方法，结果 num 很长的test case应该是出现overflow了\n而实际上 k 才是最大值比较小的参数，于是，从个位开始一位一位加，形成 arraylist，再反转\n\n### Java\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        \n        List<Integer> arrayForm = new ArrayList<>();\n        \n        int p = num.length - 1;\n        while (p >= 0 || k > 0) {\n            if (p >= 0) {\n                k += num[p];\n            }\n            \n            arrayForm.add(k % 10);\n            k = k / 10;\n            p--;\n        }\n        \n        Collections.reverse(arrayForm);\n        return arrayForm;\n   }\n}\n```\n### 复杂度\ntime: O(max(num的长度，k的位数))\nspace: O(max(num的长度，k的位数))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917329843","body":"### 思路\n由左向右遍历，记录 c 在 S[i] 左边时的最小距离 \\\n由右向左遍历，记录 S[i] 与 C 的最小距离 (C可能在左，也可能在右）\n\n###代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] result = new int[n];\n        int prev = Integer.MIN_VALUE / 2;\n        \n        // calculate distance from left\n        for (int i = 0; i < n; i ++) {\n            if (s.charAt(i) == c) {\n                prev = i;\n            }\n            result[i] = i - prev;\n        }\n        \n        // calculate min distance\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = n - 1; i >= 0; i --) {\n            if (s.charAt(i) == c){\n                prev = i;\n            }\n            result[i] = Math.min(result[i], prev - i);\n        }\n        \n        return result;\n    }\n}\n```\n###复杂度\n时间、空间: O(S.length())","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917515934","body":"### 思路\n用 int[] 模拟stack \\\npush 时要检查有没有剩余空间 \\\npop 时要检查stack是否为空 \\\nincrement 时要注意 k 和 现有数量\n\n### 代码\n```java\nclass CustomStack {\n    private int[] stack;\n    private int top;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.top = -1;\n        \n    }\n    \n    public void push(int x) {\n        if (top < stack.length - 1 ) {\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top >= 0) {\n            int result = stack[top];\n            top--;\n            return result;\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top+1);\n        for (int i = 0; i < limit; i++) {\n            stack[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\n### 复杂度\n时间: push, pop O(1), increment O(k) \\\n空间: O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"L-SUI":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916585903","body":"思路：字符串相加，大位数相加，从后往前算\r\njs\r\n\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lilixikun":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916586596","body":"## 思路如下\n数组从末尾、数字从个位开始依次累加、最好记得要注意头是否是 1\n## 代码如下\n```js\n  let len = num.length,\n    add = 0,\n    res = [];\n  while (len >= 0 || k > 0) {\n    const num1 = k % 10 || 0;\n    const num2 = num.length ? num.pop() : 0;\n    let sum = num1 + num2 + add;\n    if (sum > 9) {\n      sum %= 10;\n      add = 1;\n    } else add = 0;\n    res.unshift(sum);\n    len--;\n    k = parseInt(k / 10);\n  }\n  if (add) res.unshift(add);\n  return res\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917565276","body":"## 用JS数组来实现自定义栈类\n\n```js\nvar CustomStack = function(maxSize) {\n    this.size = 0;\n    this.list = [];\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.size<this.maxSize){\n        this.list.push(x)\n        this.size++\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.size==0) return -1\n    const num = this.list.pop();\n    this.size--\n    return num\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i=0;i<k&&i<this.size;i++){\n        this.list[i]+=val\n    }\n};\n\n```\n## 复杂度\n- 时间复杂度： push、pop、increment 都是 O（1）\n- 空间复杂度：开辟了数组、O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Zhang6260":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916586641","body":"## JAVA版本\n\n## 思路：\n\n从数组的最后一位，当然数组的数+进位数，余数就是当前该位置的数，除以10的商便是进位数。（最后遍历完数组还有判断，进位数是否为0的情况，例如为:arr【9,9,9,9】，K为1的情况）\n\n## 代码\n\n> ```\n>    public static int[]fun(int[]arr,int K){\n>    LinkedList<Integer> list=new LinkedList<>();\n>     for(int i=arr.length-1;i>=0;i--){\n>         int temp=arr[i]+K;\n>         if(temp>=10){\n>\n>             list.add(0,temp%10);\n>             K=temp/10;\n>         }else {\n>             list.add(0,temp);\n>             K=0;\n>         }\n>     }\n>     while (K>0){\n>         list.add(K%10);\n>         K=K/10;\n>     }\n>     int[]res=new int[list.size()];\n>     for(int i=0;i<list.size();i++){\n>         res[i]=list.get(i);\n>     }\n>\n>     return  res;\n> }\n> ```\n\n__时间复杂度__：O(N)\n\n__空间复杂度__：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917323419","body":"## JAVA版本\n\n## 思路：\n\n分二次遍历数组，从头到的方式进行遍历，找距离每个位置上到该位置最近的左边C的的距离并记录到数组，同理从右到左的方式，找距离每个位置最右边的距离并记录到数组，最后再进行一次遍历，取每次取左右遍历的最小值。\n\n> ```\n> package Ti_911;\n>\n> public class ti_911_2 {\n>     public static void main(String[] args) {\n>         String S=\"loveleetcode\";\n>         char c='e';\n>         int []arr_a=new int[S.length()];\n>         int []arr_b=new int[S.length()];\n>         int count=0;\n>         int isfage=1;\n>         for(int i=0;i<arr_a.length;i++){\n>             if(isfage==1&&S.charAt(i)!=c){\n>                 arr_a[i]=Integer.MAX_VALUE;\n>             }else if(S.charAt(i)==c){\n>                 isfage=0;\n>                 arr_a[i]=0;\n>                 count=0;\n>             }else {\n>                 count++;\n>                 arr_a[i]=count;\n>             }\n>         }\n>         isfage=1;\n>         for(int i=arr_a.length-1;i>=0;i--){\n>             if(isfage==1&&S.charAt(i)!=c){\n>                 arr_b[i]=Integer.MAX_VALUE;\n>             }else if(S.charAt(i)==c){\n>                 isfage=0;\n>                 arr_b[i]=0;\n>                 count=0;\n>             }else {\n>                 count++;\n>                 arr_b[i]=count;\n>             }\n>         }\n>         int []res=new int[S.length()];\n>         for(int i=0;i<arr_a.length;i++){\n>             res[i]=Math.min(arr_a[i],arr_b[i]);\n>             System.out.print(res[i]+\" \");\n>         }\n>     }\n> }\n>\n> ```\n\n__时间复杂度__：O(N)\n\n__空间复杂度__：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917579134","body":"## JAVA版本\n\n## 思路：\n\n用一个数组+一个指针来完成。数组进行实际的存储，入栈则存入数据，并把指针+1，出栈就反之。注意：入栈的时候，需要对是否达到最大存储进行判断，出栈需要对栈是否为空进行判断。\n\n> ```\n> class CustomStack {\n>     int arr[];//用来实际进行存储\n>     int Max_length;  //最大的长度\n>     int index; //当前的位置\n>     public CustomStack(int maxSize) {\n>         arr=new int[maxSize];\n>         Max_length=maxSize;\n>         index=0;\n>     }\n>     public void push(int x) {\n>         if(index<Max_length){\n>             arr[index++]=x;\n>         }\n>     }\n>     public int pop() {\n>         if(index>0){\n>              index=index-1;\n>             return arr[index];\n>         }\n>         return -1;\n>     }\n>     public void increment(int k, int val) {\n>         for(int i=0;i<k;i++){\n>             if(i<index){\n>                 arr[i]+=val;\n>             }\n>         }\n>     }\n> }\n>\n> ```\n\n__时间复杂度__：O(1)\n\n__空间复杂度__：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JK1452470209":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916587656","body":"**思路**\r\n从个位往后相加(处理进位情况)并存进list中，最后将list反转\r\n**Java**\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ret = new ArrayList<Integer>();\r\n        for (int i = num.length - 1; i >= 0; i--){\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10){\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            ret.add(sum);\r\n        }\r\n        //k>num.length情况\r\n        for (;k > 0;k /= 10){\r\n            ret.add(k % 10);\r\n        }\r\n        Collections.reverse(ret);\r\n        return ret;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度 :O(max(num.length,k))\r\n\r\n- 空间复杂度 :O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917357526","body":"思路\r\n\r\n常规思路将字符串转为char数组然后对其遍历，遇到指定字符则填充0，没有遇到则开启双指针对其扫描\r\n\r\n代码\r\n\r\n    class Solution {\r\n        public int[] shortestToChar(String s, char c) {\r\n            char[] chars = s.toCharArray();\r\n            int[] ints = new int[s.length()];\r\n            for (int i = 0; i < chars.length; i++) {\r\n                int index1 = 0,index2 = 0;\r\n                boolean flag1 = false,flag2 = false;\r\n                if (chars[i] == c){\r\n                    ints[i] = 0;\r\n                }else {\r\n                    //往前找\r\n                    for (int j = i - 1; j >= 0; j--) {\r\n                        index1++;\r\n                        if (chars[j] == c){\r\n                            flag1 = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    //往后找\r\n                    for (int j = i + 1; j < chars.length; j++) {\r\n                        index2++;\r\n                        if (chars[j] == c){\r\n                            flag2 = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (flag1 && flag2){\r\n                        ints[i] = Math.min(index1,index2);\r\n                        continue;\r\n                    }\r\n                    if (flag1){\r\n                        ints[i] = index1;\r\n                    }\r\n                    if (flag2){\r\n                        ints[i] = index2;\r\n                    }\r\n                }\r\n            }\r\n            return ints;\r\n        }\r\n    }\r\n\r\n复杂度\r\n\r\n时间复杂度：O(N) 对数组扫描俩遍\r\n\r\n空间复杂度：O(N) 使用俩个数组\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917545006","body":"思路\r\n\r\n要满足inc方法的需求，需要借助数组这种有下标的进行操作，进而可以想到用数组实现简易版栈的功能\r\n\r\n代码\r\n\r\n    class CustomStack {\r\n    \r\n        private int[] arr;\r\n        private int index;\r\n        public CustomStack(int maxSize) {\r\n            this.arr = new int[maxSize];\r\n        }\r\n    \r\n        public void push(int x) {\r\n            if (this.arr.length > index){\r\n                arr[index++] = x;\r\n            }\r\n        }\r\n    \r\n        public int pop() {\r\n            if (index != 0){\r\n                return arr[--index];\r\n            }else {\r\n                return -1;\r\n            }\r\n        }\r\n    \r\n        public void increment(int k, int val) {\r\n            if (index >= k){\r\n                for (int i = 0; i < k; i++) {\r\n                    arr[i] = arr[i] + val;\r\n                }\r\n            }else {\r\n                for (int i = 0; i < arr.length; i++) {\r\n                    arr[i] = arr[i] + val;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n复杂度\r\n\r\n时间复杂度：inc方法为O(k） 其他为O(1)\r\n\r\n空间复杂度：O(maxSize)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917811022","body":"**思路**\n\n使用字符栈与数字栈，遇到 **[** 就进栈 遇到 **]** 就出栈，出栈时将字符栈，数字栈同时出栈并运算。还需要考虑数字的进位问题 ret变量缓存着从栈底弹出字符串总和，并且有将字符串压入栈底的作用\n\n**代码**\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<String> stacks = new Stack<>();\n        Stack<Integer> nums = new Stack<>();\n        String ret = \"\";\n        int num = 0;\n        for (char c : s.toCharArray()){\n            if ('0' <= c && c <= '9'){\n                num=num*10+c-'0';\n            }else if('a' <= c && c <= 'z'){\n                ret += c;\n            }else if (c == '['){\n                stacks.push(ret);\n                nums.push(num);\n                ret = \"\";\n                num = 0;\n            }else {\n                Integer cur = nums.pop();\n                String stackTemp = stacks.pop();\n                for (int i = 0; i < cur; i++) {\n                    stackTemp += ret;\n                }\n                ret = stackTemp;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n**复杂度**\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"peteruixi":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916589529","body":"### 思路\n\n先算出总和 再转换成列表\n\n### 代码\n\n```python\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        temp = 0\n        for i in num:\n            temp = temp*10+i\n        temp += k\n        res = []\n        for i in str(temp):\n            res.append(int(i))\n        return res\n```\n\n### 复杂度\n\n- 时间复杂度: O(2N)\n- 空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917324737","body":"### 思路\n\n前后扫描各一次, 找出最小的差距\n\n### 代码\n\n```python\ndef shortestToChar(self, s: str, c: str) -> List[int]:\n        N = len(s)\n        res = [0 for _ in range (N)]\n        index = float('-inf')\n        for i in range(N):\n            if s[i] ==c:\n                index = i\n            res[i] = abs(index-i)\n        for i in range(N-1,-1,-1):\n            if s[i] ==c:\n                index = i\n            res[i] = min(res[i],abs(index-i))\n        return res\n```\n\n### 复杂度分析\n\n- 时间复杂度: $O(2N)$\n- 空间复杂度: $O(N)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917637136","body":"### 思路\n\n利用self.size记录最大限制, append的时候检查条件\n\nincrement利用while loop\n\n### 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.size = maxSize\n        self.stack = []\n\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.size:\n            self.stack.append(x)\n\n\n    def pop(self) -> int:\n        if len(self.stack):\n            return self.stack.pop()\n        else:\n            return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        i = 0\n        while i < k and i<len(self.stack):\n            self.stack[i]+=val\n            i+=1\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度: \n  - `add` , `pop`: O(1)\n  - `increment`: O(K)\n- 空间复杂度: \n  - O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user1689":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590008","body":"## 思路\n模拟竖式加法\n\n## python3\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        # 将k转化成数组\n        num2 = []\n        strK = str(k)\n        for element in strK:\n            num2.append(element)\n        \n        # 直接相加 \n        res = []\n        addCarry = 0\n        i, j = len(num) - 1, len(num2) - 1\n        while i >= 0 and j >= 0:\n            sum_ = num[i] + int(num2[j]) + addCarry\n            digit = sum_ % 10\n            addCarry = sum_ // 10\n            res.append(digit)\n            i -= 1\n            j -= 1\n\n        # 如果多出digit另外处理\n        while i >= 0:\n            sum_ = num[i] + addCarry\n            digit = sum_ % 10\n            addCarry = sum_ // 10\n            res.append(digit)\n            i -= 1\n        \n        # 如果多出digit另外处理\n        while j >= 0:\n            sum_ = int(num2[j]) + addCarry\n            digit = sum_ % 10\n            addCarry = sum_ // 10\n            res.append(digit)\n            j -= 1\n\n        # 如果有进位 则加1\n        if addCarry:\n            res.append(1)\n        \n        # 因为append的原因，最后得反转\n        return res[::-1]\n\n        # print(res)\n```\n## 复杂度分析\n* time max(n, logk) n为数组长度\n* space n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917317466","body":"## 思路\n最小数组\n\n## python3\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # 思路一 最小数组\n        # 因为最近的c无非在字母的左边或者右边\n        # 两次遍历 \n        # 第一次从左往右维护prev为c的idx然后求出每个坐标到此prev的距离\n        # 第二此从右往左维护prev 与第一次的值作对比 将较小的存入\n\n        ans = []\n        # 若它左边没有c字母，则idx减去-inf等于inf，配对后面取min\n        prev = float('-inf')\n        # 从前往后 看每个单词与它左边离它最近的c的距离是多少\n        for idx, char in enumerate(s):\n            if char == c:\n                prev = idx\n            ans.append(idx - prev)\n        \n        prev = float('inf')\n        # 从后往前 看每个单词与它右边离它最近的c的距离是多少\n        for idx in range(len(s) - 1,  -1, -1):\n            if s[idx] == c:\n                prev = idx\n            ans[idx] = min(ans[idx], prev - idx)\n        return ans\n```\n## 复杂度分析\n* time n n为s长度\n* space n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917536367","body":"## 题目\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n## 思路\n* 思路一brute force\n* 思路二前缀和优化\n\n## python\n```python\n# 思路一\nclass CustomStack:\n    # time n\n    # space n\n    def __init__(self, maxSize: int):\n        self.stack = list()\n        self.maxSize = maxSize\n        self.size = 0\n\n    def push(self, x: int) -> None:\n        if self.size == self.maxSize:\n            return\n        else:\n            self.size += 1\n            self.stack.append(x)\n            \n    def pop(self) -> int:\n        if self.size > 0:\n            self.size -= 1\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if self.size <= k:\n            for i in range(0, self.size):\n                self.stack[i] += val\n        else:\n            for i in range(0, k):\n                self.stack[i] += val\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n\n# 思路二\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = list()\n        self.maxSize = maxSize\n        self.size = 0\n        self.increments = list()\n\n    def push(self, x: int) -> None:\n        if self.size == self.maxSize:\n            return\n        else:\n            self.size += 1\n            self.stack.append(x)\n            # 加0备用\n            self.increments.append(0)\n            \n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n        self.size -= 1\n        # 由于先减size 所以当长度为2时 判断却size为1，但此时还是需要进行转移的\n        # 所以选择使用>=1\n        if self.size >= 1:\n            self.increments[-2] += self.increments[-1]\n        return self.stack.pop() + self.increments.pop()\n        \n    def increment(self, k: int, val: int) -> None:\n        # 如果存在 \n        if self.increments:\n            # 底层k个元素增1即为 index为 0 到 (k -1)的元素\n            # 为了符合题意(k - 1)与size取小\n            # += 是为了当多次调用increment时 值不会被覆盖\n            self.increments[min(k - 1, self.size - 1)] += val\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## 复杂度分析\n* time 1\n* space n\n\n## 相关题目","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xieyj17":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590188","body":"# 1. 模拟加法逻辑\r\n\r\n把 `num` 和 `k` 都转换成array， 然后逆序从最后一位开始相加，如果大于10 就向下一位进1\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        # res stores the final solution\r\n        res = []\r\n        # reverse order of num\r\n        num = num[::-1]\r\n        # convert k to an arry and reverse the order\r\n        sk = [int(i) for i in str(k)]\r\n        sk = sk[::-1]\r\n\t\t# padding 0s to the shorter array\r\n        if len(num) >= len(sk):\r\n            sk = sk + [0]*(len(num) - len(sk))\r\n        else:\r\n            num = num + [0]*(len(sk) - len(num))\r\n\t\t# t stores the result of floor division \r\n        t = 0\r\n     \r\n        for i in range(len(num)):\r\n            n = num[i]\r\n            k = sk[i]\r\n            # add residual to the final solution\r\n            res = res + [(n+k+t) % 10]\r\n            t = (n+k+t) // 10\r\n            \r\n        # if the last addition results a modulo > 0, add to the end of res\r\n        if t > 0:\r\n            res = res + [1]\r\n        return res[::-1]\r\n```\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度： O(n)\r\n\r\n# 2. Why bother ¯\\\\_(ツ)_/¯\r\n\r\n使用python 内置函数，把 `num` 转换成 int\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sn = [str(i) for i in num]\r\n        sn = int(''.join(sn))\r\n        res = str(sn+k)\r\n        res = [int(i) for i in res]\r\n        return res\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917260187","body":"Step 1. 找到s 中所有c 在的位置\n\nStep 2. 如果两个c 中间的间隔为d 并且 d % 2 == 0， 那个它们离最近的c 的距离就是1,2,...,d//2, d//2, ..., 2, 1,如果d 是奇数那么距离就是 1,2,...,d//2, d//2+1,  d//2,  ..., 2, 1\n\nStep 3. 两端分别处理一下\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        def gen_interval(k):\n            if k%2 != 0:\n                l = k//2 + 1\n                return [i for i in range(1, l)] + [i for i in range(l, 0, -1)]\n            else:\n                l = k//2\n                return [i for i in range(1, l+1)] + [i for i in range(l, 0, -1)]\n\n        locs = []\n        for i in range(len(s)):\n            if s[i] == c:\n                locs.append(i)\n        if len(locs) == 0:\n            res = [i for i in range(locs[0],-1,-1)] + [i for i in range(len(s)-1-locs[0])]\n        else:\n            diffs = [locs[i+1] - locs[i] - 1 for i in range(len(locs)-1)]\n            res = [i for i in range(locs[0],0,-1)]\n            for d in diffs:\n                res += ([0] + gen_interval(d))\n            res += [i for i in range(len(s)-locs[-1])]\n        return res\n```\n\nTime: O(n)\n\nSpace: O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917482375","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.list = []\n        self.maxSize = maxSize\n        \n\n    def push(self, x: int) -> None:\n        if len(self.list) < self.maxSize:\n            self.list = [x] + self.list       \n        \n\n    def pop(self) -> int:\n        if self.list:\n            r = self.list[0]\n            self.list = self.list[1:]\n            return r\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.list) <= k:\n            self.list = [i + val for i in self.list]\n        else:\n            for i in range(k):\n                self.list[-1-i] = self.list[-1-i] + val\n            \n```\n\n按照要求用最基本的方式实现，nothing fancy\n\n\n\nTime: O(1) for push and pop, O(k) for increment\n\nSpace: N/A","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917683180","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        curr_num = 0\n        curr_string = ''\n        for c in s:\n            if c == '[':\n                stack.append(curr_string)\n                stack.append(curr_num)\n                curr_string = ''\n                curr_num = 0\n            elif c == ']':\n                num = stack.pop()\n                prev_string = stack.pop()\n                curr_string = prev_string + num*curr_string\n            elif c.isdigit():\n                curr_num = curr_num*10 + int(c)\n            else:\n                curr_string += c\n        return curr_string\n```\n\n看了半天还是不会做，然后看了leetcode 的答案模仿着写了一遍，大概有点懂了\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shamworld":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590720","body":"# 思路\n从末尾遍历num，取出值和k%10的余相加，然后把k除以10取余，这个时候就判断a的值是不是大于等于10，如果是，就处理a的值和k++，把处理的a放入数组，这里要判断k的边界，如果num循环完了，k还有值，那么就处理k，在加入数组中，最后把数组反转\n```js\nvar addToArrayForm = function (num, k) {\n    let m, res = [];\n    for (let i = num.length - 1; i >= 0; i--) {\n        m = num[i] + k % 10;//取末尾和k除以10的余相加\n        k = Math.floor(k / 10);\n        if (m >= 10) {\n            k++;//相加最大也是19 所以k+1就行\n            m = m - 10;//拿到当前位的值\n        }\n        res.push(m);\n    }\n    //k的长度大于num的长度的情况\n    while (k != 0) {\n        res.push(k % 10);\n        k = Math.floor(k / 10);\n    }\n    return res.reverse();\n};\n```\n# 复杂度分析\n- 时间复杂度:O(max(num.length,k))\n- 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917321998","body":"## 思路\r\n先找到c所在的位置的所有下标，然后遍历判断\r\n## 代码\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let arr = [];\r\n    let result = [];\r\n    for(let i = 0;i < s.length; i++){  \r\n        if(s[i]===c){\r\n            arr.push(i)\r\n        }\r\n    }\r\n    for(let i = 0;i < s.length; i++){\r\n        if(s[i]===c){\r\n            result[i] = 0;\r\n            continue\r\n        }\r\n        \r\n        for(let index of arr){\r\n            let res = Math.abs(index-i);\r\n            console.log(result)\r\n            if(res>=result[i]) break;\r\n            result[i] = res;\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n## 复杂度分析\r\n- 时间复杂度:O(n^2)\r\n- 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917606373","body":"## 思路\n用一个数组维护栈，通过pop()和push()来操作\n## 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stackList = [];\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stackList.length>=this.maxSize) return null;\n    this.stackList.push(x); \n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    \n    if(this.stackList.length==0) return -1;\n    return this.stackList.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(k<this.stackList.length){\n        for(let i = 0; i < k; i++){\n            this.stackList[i] += val\n        }\n    }else{\n        for(let i = 0; i < this.stackList.length; i++){\n            this.stackList[i] += val\n        }\n    }\n};\n\n```\n## 复杂度分析\n- 时间复杂度:pop,push为O(1)，increment为O(k)\n- 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917780048","body":"## 思路\n通过两个数组维护数字栈和字符串栈\n## 代码\n```js\nvar decodeString = function (s) {\n    let numList = [];//存放数字\n    let numStr = '';//存放数字长度\n    let stackList = [];//存放字符串\n    let str = '';//存放括号里面的字符串\n    let result = '';//返回值\n    for (let i = 0; i < s.length; i++) {\n        const n = s.charAt(i);\n        if (n >= 0 && n <= 9) {\n            numStr += n;\n        } else if (n === '[') {//这时说明前面数字，字符串已经匹配完了\n            numList.push(numStr);\n            stackList.push(str);\n            numStr = '';\n            str = '';\n        } else if (n === ']') {\n            const num = numList.pop();\n            let t = '';\n            for (let j = 0; j < num; j++) {\n                t += str;\n            }\n            //已经计算了一个闭环，就要判断stackList中还存不存在字符串，存在就加，例如：3[a2[c]]=>3[acc]\n            let temp = stackList.length > 0 ? stackList.pop() : '';\n            str = temp + t;\n            //如果当前数字数组中没有数据了，那就说明当前位置已经没有可以重复的字符串了，直接加入到返回值里面\n            if (numList.length === 0) {\n                result += str;\n                str = '';\n            }\n        } else {\n            //如果当前数字数组中没有数据了，那就说明当前位置已经没有可以重复的字符串了，直接加入到返回值里面\n            if (numList.length === 0) {\n                result += n;\n            } else {\n                str += n;\n            }\n        }\n    }\n\n    return result;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"learning-go123":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590825","body":"## 思路\n在原有num上操作数据，进位在num前面插入数据\n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\nfunc addToArrayForm(num []int, k int) []int {\n    for i:=len(num)-1;i>=0;i--{\n        val := num[i] + k %10\n        k /= 10\n\n        num[i] = val % 10\n        if val > 9 {\n            if i - 1 >= 0 {\n                num[i-1] += 1\n            } else {\n                num =  append([]int{1}, num...)\n                i++\n            }\n        } \n    }\n\n    for k !=0 {\n        num =  append([]int{k%10}, num...)\n        k /= 10\n    }\n\n    return num\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917315087","body":"\n## 思路\n找到c数据，在回溯找到前面并修改比当前数据大的值双100%\n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\nfunc shortestToChar(s string, c byte) []int {\n\tres := make([]int, len(s))\n\tres[0] = 10000\n\tfor i, value := range s {\n\t\tif i != 0 {\n\t\t\tres[i] = res[i-1]+1\n\t\t}\n\t\tif byte(value) == c {\n\t\t\tres[i] = 0\n\t\t\tfor j:= i-1;j>=0;j-- {\n\t\t\t\tif res[j] < i - j {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tres[j] = i - j\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917568773","body":"## 思路\n初始化一个maxsize大小的数组，一个pos定位当前使用的位置\n对pos操作，实现快速访问\n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\ntype CustomStack struct {\n\tmaxSize int\n\tpos int\n\ts []int\n}\n\nfunc Constructor(maxSize int) CustomStack {\n\treturn CustomStack{\n\t\tmaxSize: maxSize,\n\t\tpos:  -1,\n\t\ts : make([]int, maxSize),\n\t}\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n\tif this.pos+1 >= this.maxSize {\n\t\treturn\n\t}\n\tthis.pos++\n\tthis.s[this.pos] = x\n}\n\n\nfunc (this *CustomStack) Pop() int {\n\tif this.pos >= 0 {\n\t\tval := this.s[this.pos]\n\t\tthis.pos--\n\t\treturn val\n\t}\n\treturn -1\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n\tif this.pos <= -1 {\n\t\treturn\n\t}\n\tfor i:=0;i<this.maxSize;i++ {\n\t\tif i>=k {\n\t\t\tbreak\n\t\t}\n\t\tthis.s[i]+=val\n\t}\n}\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a244629128":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590955","body":"```javascript\nvar addToArrayForm = function(A, K) {\n    //start from the last Index\n    let flag = A.length - 1\n    //if k <=0 jump out the loop\n    while(K) {\n        // if flag < 0 mean we still have carry left and K is not zero yet\n        if(flag < 0) {\n            //put the carray to the front\n            A.unshift(K % 10)\n        } else {\n            // k plus the last index value\n            K += A[flag]\n            // update the last index value by K % 10,if k is bigger than 9 we only take the units digit(个位数）\n            A[flag] = K % 10\n            //flag mins one for each loop\n            flag--;\n        \n        }\n        \n        K = Math.floor(K / 10)\n        \n    }\n    return A\n}\n// time O(n);\n//space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917049882","body":"<h1>思路</h1>\n两次遍历，第一次从左到右把最近距离更新到res array\n第二次 从右到左遍历，然后把第二次得到的最短距离和第一次相比取最小值\n更新 res array\n\n```javascript\nvar shortestToChar = function(s, c) {\n    //两个循环，设prev 为 INFINITY\n    //第一个循环从左到右，每次在s找到 c 这个字符 就更新 prev = i（c 这个字符的INDEX）\n    // 然后让最近更新的 c 字符 Index 和 当前 字符 INDEX 相减 取绝对值（因为从左到右，不取绝对值会得到负数）\n    let prev = Infinity;\n    let res = [];\n    for(let i =0; i<s.length;i++){\n        if(s[i] === c){\n            prev = i;\n        }\n        res[i] = Math.abs(prev-i);\n    }\n    //第一次循环之后 res 里面的结果，当前数值还没完全正确\n// I I I 0 1 0 0 1 2 3 4  ，I = Infinity\n    \n    // reset prev to INFINITY\n    prev = Infinity;\n    // 第二次循环从右到左， 跟第一次循环步骤一样\n    for(let j = s.length-1; j>=0; j--){\n        if(s[j] === c){\n            prev = j;\n        }\n        // 不同的地方是这里 对比第一次循环和第二次循环得到的值，然后取最小值更新res\n        res[j] = Math.min(res[j],prev-j);\n    }\n    return res;\n};\n\n//time O(n)\n// space O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917479802","body":"<h1>思路</h1>\r\n用额外array存相加的数字，pop的时候才把两个数字相加，就不用遍历数组把每个数字相加\r\n<h1>代码</h1>\r\njavascript\r\n\r\n```javascript\r\n//time O(1)\r\n//space O(n) extra space\r\n\r\nvar CustomStack = function(maxSize) {\r\n    this.size = maxSize;\r\n    this.sum = new Array(maxSize).fill(0);\r\n    this.values = [];\r\n};\r\n\r\n\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.values.length <this.size){\r\n        this.values.push(x);\r\n    } \r\n};\r\n\r\n\r\nCustomStack.prototype.pop = function() {\r\n   if(this.values.length){\r\n       let lastElementIndex = this.values.length-1;\r\n       let SumPosition = this.sum[lastElementIndex];\r\n       if(lastElementIndex>0){\r\n           this.sum[lastElementIndex-1]+= this.sum[lastElementIndex] \r\n       }\r\n        this.sum[lastElementIndex] = 0;\r\n       return this.values.pop() + SumPosition;\r\n   }\r\n    return -1;\r\n};\r\n\r\n\r\nCustomStack.prototype.increment = function(k, val) {\r\n   let sumIndex = Math.min(this.values.length,k)-1;\r\n    this.sum[sumIndex]+= val;\r\n};\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917706602","body":"<h1>思路</h1>\n\n假如给的string是 \"abc10[cd]xyz\" \n\nstack 用来暂时保存 prevString 和 currNum\n\ncurrString保存字母\n\ncurrNum保存数字\n\n有四种情况\n\n   1.当前char是字母： 直接加到currString里面\n\n​    2.当前char是数字：  直接加到currNum里面，（line 20） 还有一个 currNum*10 是为了应对如果数字是more than 1 digit 的情况。 例如 \"10[cd]\" 这个string需要10个‘cd’重复 ，如果没有currNum *10， currNum 遇到第一个数字的时候会加一 currNum=1，遇到第二个数字0会加零 currNum+0= 1+0=1，得到的数字并不正确。 如果加上currNum*10 ，currNum 遇到第一个数字的时候会加一 currNum=1，遇到第二个数字0会把currNum先乘以10 再加零， currNum*10+0= 1x10+0=10;\n\n   3.当前char 是 '[' ： 如果遇到 [ 我们就把currsString push 到 stack， stack 里面的 string 就会变成 prevString因为马上要遇到下一个 new string，当前数字也push 到 stack，然后currString ， currNum reset 准备保存将要遇到的 new string 和 new number  \n\n4. 当前char 是 ’] ‘:   遇到 ’]‘ 就代表当前string已经结束了，所以我们把 需要重复的数字从stack pop 出来 然后 repeat 当前sring 再 拼接上 prevString\n\n```javascript\n//javascript\n\nvar decodeString = function(s) {\n    let stack = [];\n    let currString = \"\";\n    let currNum = 0;\n    \n    for(let i =0; i<s.length;i++){\n        let currChar = s[i]\n        if(currChar === \"[\"){\n            stack.push(currString);\n            stack.push(currNum);\n            //reset currString\n            currString = \"\";\n            //reset currNum\n            currNum = 0;\n        }else if(currChar === \"]\"){\n            let prevNum = stack.pop();\n            let prevString  = stack.pop();\n            currString= prevString + currString.repeat(prevNum);\n        }else if(currChar>= \"0\" && currChar <= \"9\"){\n            currNum = currNum*10 + Number(currChar);\n        }else{\n            currString+=currChar;\n        }\n    }\n    return currString;\n};\n//TIME O(n) not sure\n// space O(n) not sure\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhousibao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916592720","body":"```ts\nfunction addToArrayForm(arr: number[], k: number): number[] {\n    let n = arr.length - 1\n    const list = []\n    while( n >= 0 || k){\n        k += (arr[n] || 0)\n        list.push(k%10)\n        k = Math.floor(k/10)\n        n--\n    }\n    return list.reverse()\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917535816","body":"### TypeScript\r\n\r\n```ts\r\nclass CustomStack {\r\n    max:number\r\n    stack:number[]\r\n    constructor(maxSize: number) {\r\n        this.max = maxSize\r\n        this.stack = []\r\n    }\r\n\r\n    push(x: number): void {\r\n        if(this.stack.length < this.max){\r\n            this.stack.push(x)\r\n        }\r\n    }\r\n\r\n    pop(): number {\r\n        if(this.stack.length){\r\n            return this.stack.pop()\r\n        }\r\n        return -1\r\n    }\r\n\r\n    increment(k: number, val: number): void {\r\n        const maxNum = Math.min(k,this.stack.length)\r\n        for(let i = 0; i < maxNum; i++) {\r\n            this.stack[i] += val \r\n        }\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917809337","body":"## ts\n```ts\nfunction decodeString(s: string): string {\n    const stack = []\n    let str = ''\n    let num = ''\n    for(const i of s){\n        if(!isNaN(+i)){\n            num += i\n        } else if( i === '['){\n            stack.push(+num)\n            num = ''\n            stack.push(i)\n        } else if( i === ']'){\n            str = ''\n            while( stack[stack.length - 1] !== '['){\n                // 注意顺序\n                str = stack.pop() + str\n            }\n            // stack[stack.length - 1] === '['\n            stack.pop()\n            stack.push(str.repeat(stack.pop()))\n        } else {\n            stack.push(i)\n        }\n    }\n    return stack.join('');\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"RocJeMaintiendrai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916592795","body":"## 题目\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/submissions/\n## 思路\n从最低位开始两两相加，如果计算结果大于10，需要进一位，在高一位的计算中加1。需要注意的是k是有可能比num的位数多，不要忽略这种情况。还有就是不能将num转为integer与k相加后再转为数组形式，因为可能会越界。\n## 代码\n``` java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n\t\tfinal int len = num.length;\n\t\tfor(int i = len - 1; i >= 0; i--) {\n\t\t\tint sum = num[i] + k % 10;\n\t\t\tk /= 10;\n\t\t\tif(sum >= 10) {\n\t\t\t\tk++;\n\t\t\t\tsum -= 10;\n\t\t\t}\t\n\t\t\tres.add(0, sum);\n\t\t}\n\t\tfor(; k > 0; k /= 10) {\n\t\t\tres.add(0, k % 10);\n\t\t}\n\t\treturn res;\n    }\n}\n```\n## 复杂度分析\n#### 时间复杂度\nn为num的长度，k为k的长度，如果k比n小，则时间复杂度为O(n),如果k的长度大于n，则复杂度应为O(k),所以时间复杂度应为O(max(n, k)).\n#### 空间复杂度\n除result外没有开辟新的空间，因此复杂度应为O(1).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917349744","body":"## 思路\n新建一个和s长度相同的array，全部填充上最大的长度可能即为s.length（） - 1， 然后遍历s，当遇到c时使用双指针向左右两边扫，初始一个offset变量为0，指针移动一次就加一，如果在array对应的idx的数大于当前offset，则代表该字母离当前c更近，更新为当前的offset。\n## 代码\n``` java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        final int len = s.length();\n        int[] res = new int[len];\n        Arrays.fill(res, len - 1);\n        for(int i = 0; i < len; i++) {\n            if(s.charAt(i) == c) {\n                int left = i;\n                int leftOffset = 0;\n                while(left >= 0 && res[left] > leftOffset) {\n                    res[left--] = leftOffset++;\n                }\n                int right = i + 1;\n                int rightOffset = 1;\n                while(right < len && res[right] > rightOffset) {\n                    res[right++] = rightOffset++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n## 复杂度分析\n### 时间复杂度\nO(N^2)\n### 空间复杂度\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917504383","body":"## 题目\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n## 思路\n使用空间换时间的方法，类似于堆中的延缓计算，多创建一个数组increament[]，每当调用increment方法时，将value加到该数组中，当pop时查看increment的value是否为0，如果不为0，加上该值再返回，将increament数组该位的值减一变为0.\n## 代码\n``` java\nclass CustomStack {\n    private int[] stack;\n    private int[] increment;\n    private int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        increment = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top != stack.length - 1) {\n            stack[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top == -1) {\n            return -1;\n        }\n        int topValue = stack[top];\n        if(increment[top] != 0) {\n            topValue += increment[top];\n            increment[top] = 0;\n        }\n        top--;\n        return topValue;\n    }\n    \n    public void increment(int k, int val) {\n        int number = Math.min(k, top + 1);\n        for(int i = 0; i < number; i++) {\n            increment[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n## 复杂度分析\n### 时间复杂度\nO（1） for all operaions.\n### 空间复杂度\nO(maxSize) 创建了额外的数组\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917801689","body":"## 题目\nhttps://leetcode-cn.com/problems/decode-string/\n## 思路\n该问题需要由内向外扩展，很明显可以用到stack先进后出的特性。\n具体到问题上来，我们新创建额外两个stack，一个用来存数字，一个用来存字母。当遇到数字时，将数字记录下来为multi(要记得处理连续数字的情况)；当遇到字母时，直接append到res；当遇到'\\[\\' 符号时，将当前的res和multi压入各自的stack中，并且将multi和res初始化；当遇到'\\]\\'时，需要初始化一个tmp变量，pop出multi里的数字，并迭代加入res到tmp中去，最后要将结果初始为tmp + res.pop()。\n## 代码\n``` java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        Stack<Integer> numberStack = new Stack();\n        Stack<String> stringStack = new Stack();\n        int multi = 0;\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                numberStack.push(multi);\n                stringStack.push(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            } else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int curMulti = numberStack.pop();\n                for(int i = 0; i < curMulti; i++) {\n                    tmp.append(res);\n                }\n                res = new StringBuilder(stringStack.pop() + tmp);\n            } else if(c >= '0' && c <= '9') {\n                multi = multi * 10 + Integer.parseInt(c + \"\");\n            } else {\n                res.append(c);\n            }\n        }\n        return res.toString();\n    }\n}\n```\n## 复杂度分析\n### 时间复杂度\nO(n)\n### 空间复杂度\nO(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ysy0707":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916593071","body":"```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        int n = A.length;\n        List<Integer> res = new ArrayList<>();  // 可以用 LinkeList，或者 ArrayList 往后加，最后反转\n        int i = n - 1, sum = 0, carry = 0;\n        while (i >= 0 || K != 0) {  // 循环条件：两个数有一个没完\n            int x = i >= 0 ? A[i]: 0;\n            int y = K != 0 ? K % 10 : 0;\n                        \n            sum = x + y + carry;\n            carry = sum / 10;\n            K = K / 10;\n\n            i--;\n            res.add(0, sum % 10);\n        }\n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n```\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917321390","body":"```\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int n = S.length();\r\n        int[] ans = new int[n];\r\n\r\n        int prev = Integer.MIN_VALUE / 2;\r\n        for(int i = 0; i < n; i++){\r\n            if(S.charAt(i) == C) prev = i;\r\n            ans[i] =i - prev;\r\n        } \r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for(int i = n - 1; i >= 0; i--){\r\n            if(S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N）\r\n空间复杂度：O(S) S为字符串长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917571830","body":"```\r\nclass CustomStack {\r\n    int[] stack;\r\n    int size;\r\n    int[] increment;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        increment = new int[maxSize + 1];\r\n        size = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(size == stack.length){\r\n            return;\r\n        }\r\n        stack[size++] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(size == 0){\r\n            return -1;\r\n        }\r\n        int res = stack[size - 1];\r\n        if(increment[size] != 0){\r\n            res += increment[size];\r\n            increment[size - 1] += increment[size];\r\n            increment[size] = 0;\r\n        }\r\n        size--;\r\n        return res;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        increment[Math.min(k, size)] += val;\r\n    }\r\n}\r\n```\r\n时间复杂度： O（1）\r\n空间复杂度： O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917789879","body":"```\r\nclass Solution {\r\n    //c为数字：转化为数字num\r\n    //c为字母：在res尾部添加c\r\n    //c为‘[’：将当前num和res入栈stack，并将两者分别空置\r\n    //c为‘]’：stack出栈，res = 刚出栈的res + 当前res * 刚出栈的数字num\r\n\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        int num = 0;\r\n        \r\n        LinkedList<Integer> stackNum = new LinkedList<>();\r\n        LinkedList<StringBuilder> stackRes = new LinkedList<>();\r\n\r\n        for(Character c : s.toCharArray()){\r\n            if(c >= '0' && c <= '9'){\r\n                num = num * 10 + c - '0';\r\n            }else if(c == '['){\r\n                stackNum.addLast(num);\r\n                stackRes.addLast(res);\r\n                num = 0;\r\n                res = new StringBuilder();\r\n            }else if(c == ']'){\r\n                int curNum = stackNum.removeLast();\r\n                StringBuilder tmp = new StringBuilder();\r\n                for(int i = 0; i < curNum; i++){\r\n                    tmp.append(res);\r\n                }\r\n                res = stackRes.removeLast();\r\n                res.append(tmp);\r\n            }else{\r\n                res.append(c);\r\n            }\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AstrKing":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916593572","body":"## 思路\n\n~~~bash\n直接从后往前加，然后最低位留对10的余数即可。\n~~~\n\n## 代码\n\n~~~java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n~~~\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917766453","body":"### 思路\n\n利用栈的特性\n\n### 代码\n\n~~~java\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                stk.removeLast();\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n~~~\n\n### 时间复杂度：O(n)\n\n### 空间复杂度：O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JadeQi":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916595505","body":"# 思路\n\n遍历数组整合成整数\n与k值相加\n刚开始前三个测试样例平安无事，从测4后开始疯狂溢出。\n\n把int 改成Long，短暂解决，测96后，又开始了一轮溢出.....\n\n# 解决方式：\n\n数组的最后一位与k的最后一位相加，注意进位量。\n\n# java\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int n = num.length;\n        for(int i = n-1; i >= 0; i--){\n            //数组最后一个与k的最后一位相加\n            int sum = num[i]+k%10;\n            k /= 10;\n            if(sum >= 10){\n                sum -=10;\n                //进位设置\n                k++;\n            }\n            res.add(sum);\n        }\n        //防止k的位数大于num\n        for(;k >0; k/=10){\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917405605","body":"```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> arr = new ArrayList<>();\n        int[] ret = new int[s.length()];\n        int p = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) arr.add(i);\n        }\n        for (int i = 0; i < s.length(); i++) {\n            if (p < arr.size() - 1 && Math.abs(arr.get(p) - i) > Math.abs(arr.get(p + 1) - i)) p++;\n            ret[i] = Math.abs(arr.get(p) - i);\n        }\n        return ret;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunupdong":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916599149","body":"## 思路：\n\n* 官方题解思路\n* 数组从后往前遍历，数组最后一位与K个位数相加，以此类推\n  * 需要判断相加大于10的情况\n  * 需要判断当k大于数组num时，数组遍历完，k值还有的情况\n  * 最后push进数组，返回时需反转\n\n``` js \n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  const numLength = num.length\n  let res = []\n\n  for (let i = numLength - 1; i >= 0; --i) {\n    // 每一位相加\n    let sum = num[i] + k % 10\n    // 得到除去参与相加的数\n    k = Math.floor(k / 10)\n\n    // 如果相加大于9，结果取个位数，十位数给k，参与下一次循环\n    if (sum > 9) {\n      sum -= 10\n      k++\n    }\n    res.push(sum)\n  }\n\n  /**\n   *  如果k的值大于数组num值，还要将剩余的k的每一位push到数组里\n   *  由于上面执行的操作，k会不断减少一位，如果到这里还剩余，说明大于数组num值，所以此次判断条件为k>0\n   *  for(k=k; k>0; k=Math.floor(k/10))\n   */\n  for (; k > 0; k = Math.floor(k / 10)) {\n    res.push(k % 10)\n  }\n\n  // 由于前面数组是push，个位数在第一个，所以数组要反转一下\n  res.reverse()\n  return res\n};\n```\n\n## 复杂度分析\n\n* 时间复杂度：O(max(n, log k))，其中n为数组的长度\n* 空间复杂度：O(1)。除了返回值以外，使用的空间为常数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917425778","body":"## 思路\n\n* 利用indexof寻找右边界，第二个参数i为从下标 i 元素开始找\n\n``` js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n  // 设置左边界\n  let l = s[0] === c ? 0 : Infinity\n  // 设置右边界\n  let r = s.indexOf(c, 1);\n  const res = Array(s.length);\n\n  for (let i = 0; i < s.length; i++) {\n    //算出左右两边的最小距离\n    res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\n\n    // 如果遍历到右边界，然后右边界变成左边界，右边界从下表l+1开始找\n    if (i === r) {\n      l = r;\n      r = s.indexOf(c, l + 1);\n    }\n  }\n\n  return res;\n};\n```\n\n### 复杂度分析\n\n* 时间复杂度： O(n) n为数组s的长度\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917562317","body":"## 思路\n\n* 对栈的基本操作，需要注意的是pop返回的是出栈的值或者是 -1 ,\n\n``` js\nclass CustomStack {\n\n  /**\n* @param {number} maxSize\n*/\n  constructor(maxSize) {\n    this.maxSize = maxSize\n    this.list = []\n  }\n  \n  /** \n   * @param {number} x\n   * @return {void}\n   */\n  push(x) {\n    if (this.list.length >= this.maxSize) return\n    this.list.push(x)\n  };\n\n  /**\n   * @return {number}\n   */\n  pop() {\n    if (!this.list.length) return -1\n    return this.list.pop()\n  }\n\n  /** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\n  increment(k, val) {\n    // 注意要设置i < this.list.length（刚开始没设置一直不对 v_v）\n    for (let i = 0; i < k && i < this.list.length; i++) {\n      this.list[i] += val\n    }\n  };\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n### 复杂度分析\n\n* 时间复杂度：constructor、push、pop的复杂度为O(1), increment的复杂度为k, k是该方法参数k的长度\n* 空间复杂度：O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Laurence-try":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916599312","body":"### 思路\r\n从k的个位开始，每一位加到num里面，用carry记录进位，并在下一位计算的时候算上carry值并更新carry值。需要对于num和k的长度difference的情况，分别讨论。\r\n### 代码\r\n使用代码: Python3\r\n```py\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        if not num:\r\n            return list(str(k))\r\n        if not k:\r\n            return num\r\n        c = 0\r\n        n_len = len(num)\r\n        pointer = n_len - 1\r\n        res = []\r\n        while pointer >= 0 or k > 0:\r\n            if pointer >= 0:\r\n                k_c = k % 10\r\n                k = k // 10\r\n                new_dig = (num[pointer] + k_c + c) % 10\r\n                c = (num[pointer] + k_c + c) // 10\r\n                num[pointer] = new_dig\r\n                pointer -= 1\r\n            else:\r\n                k = k + c\r\n                k_c = k % 10\r\n                k = k // 10\r\n                res.append(k_c)\r\n                c = 0\r\n        res = res[::-1]\r\n        if c > 0:\r\n            return [c] + num\r\n        else:\r\n            return res + num\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(max(num_len, k_len))， 其中num_len为num的长度， k_len为str(k)的长度\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917225738","body":"### 思路\n新建一个数组长度为n (n 是input数组的长度)， 并把里面所有elements设为n。\n正向遍历一遍， 在新建的数组里面更新第一个字母出现以后的所有distance，如果再次遇见字母，distance归0。\n然后在反向遍历一遍，覆盖刚刚新建的数组，同样从第一个字母出现以后开始覆盖，覆盖的条件是此时的distance要小于上一步更新的distance， 同样如果遇见字母，distance归0。\n\n### 代码\n使用语言：Python3\n```py\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [len(s) for x in range (len(s))]\n        p = 0\n        count = 0\n        flag = False\n        while p < len(s):\n            if s[p] == c:\n                flag = True\n                count = 0\n                res[p] = 0\n            else:\n                if flag:\n                    count += 1\n                    res[p] = count\n            p += 1\n        count = 0\n        flag = False\n        p -= 1\n        while p >= 0:\n            if s[p] == c:\n                flag = True\n                count = 0\n                res[p] = 0\n            else:\n                if flag:\n                    count += 1\n                    if res[p] > count:\n                        res[p] = count\n            p -= 1\n        return res\n```\n***复杂度分析***\n时间复杂度：O(n)\n空间复杂度：O(1), compensate O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917624688","body":"### 思路\r\n初始化stack为Python的list，并设定此stack size的最大值\r\npush(): 在list的末尾append element when the size is not full (在栈顶加入element 在栈的长度小于最大长度的时候，如果大于等于最大长度了，不能添加）\r\npop(): 把list的末尾return出来（把栈顶的element return出来， 在栈有长度的时候，此时在栈里有elements），如果栈的长度为0，此时栈是空的，return -1\r\nincrement(): 把从栈尾（list的前面）的k遍历，并加上val\r\n\r\n### 代码\r\n使用语言：Python3\r\n```py\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.maxSize > len(self.stack):\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range (min(len(self.stack), k)):\r\n            self.stack[i] += val\r\n```\r\n***复杂度分析***\r\n时间复杂度：O(1) for push and pop, O(min(k, len(stack)) for increment\r\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"machuangmr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916600573","body":"### 思路\n-  1、将数组的最后一个元素和k的个位开始相加，\n-  2、大于等于10 就向前进一位（k的前一位 + 1）\n-  3、 重复以上步骤知道数组和k的位数结束\n\n### 代码\n- 语言：Java\n```java\nclass Solution {\n    // 思路： 1、将数组的最后一个元素和k的个位开始相加，\n    //       2、大于10 就向前进一位（k的前一位 + 1）\n     //        3、 重复以上步骤知道数组和k的位数结束\n    public List<Integer> addToArrayForm(int[] num, int k) {\n     List<Integer> rest = new LinkedList<>();\n    int len = num.length - 1;\n    for(int i = len;i >= 0;i--) {\n        int total = num[i] + k % 10;\n        //取除过后一位的前面的值\n        k /= 10;\n        if(total >= 10) {\n            //大于10，则前面的值需要进1\n            k++;\n            total = total % 10;\n        }\n        rest.add(total);\n    }\n    while(k > 0) {\n        rest.add(k % 10);\n        k /=10;\n    }\n     Collections.reverse(rest);\n     return rest;\n    }\n}\n\n````\n### 复杂度\n- 空间复杂度：O(1)\n- 时间复杂度 O max(num.length, k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917422620","body":"### 思路\r\n- 遍历数组，将目标字符的下标的存储起来\r\n- 遍历字符串，将当前下标和字符下表进行计算\r\n- 计算每个下标和目标的值的最小值\r\n\r\n### 语言\r\n- java\r\n````\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n         int[] arr = new int[s.length()];\r\n        List<Integer> list = new ArrayList<>();\r\n        char[] chars = s.toCharArray();\r\n        for(int i = 0;i < chars.length;i++) {\r\n            if (chars[i] == c) {\r\n                list.add(i);\r\n            }\r\n        }\r\n        for (int i = 0;i < s.length();i++) {\r\n\r\n            // Math.abs(i - )\r\n            int num = getMin(i, list);\r\n            arr[i] = num;\r\n        }\r\n        return arr;\r\n    }\r\n     private static int getMin(int i, List<Integer> list) {\r\n        int[] nums = new int [list.size()];\r\n        for (int j = 0;j < list.size();j++) {\r\n            nums[j] = Math.abs(i - list.get(j));\r\n        }\r\n        Arrays.sort(nums);\r\n        return nums[0];\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度 O(n2)\r\n- 空间复杂度O(n)\r\n### 缺点：\r\n时间复杂度太高，必须优化\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917602582","body":"### 思路： \r\n- 利用数组维护一个题目中的栈，\r\n- push 将元素添加到数组中\r\n- pop 返回数组中最后一个元素\r\n- inc 只需要注意边界问题就好\r\n### 语言\r\n- java\r\n\r\n### 代码\r\n```java\r\nclass CustomStack {\r\n    \r\n    int maxSize; // 初始化的最大长度\r\n    int currentSize = -1;// 当前数组的长度，默认为 -1\r\n    int[] customStack = null;\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        customStack = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(currentSize == maxSize - 1) {\r\n            return;\r\n        }\r\n        customStack[++currentSize] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(currentSize == -1) {\r\n            return -1;\r\n        }\r\n        int val = customStack[currentSize];\r\n        currentSize--;\r\n        return val;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(currentSize <= k -1) {\r\n            for(int i = 0;i <= currentSize;i++) {\r\n                customStack[i] += val;\r\n            }\r\n        } else{\r\n            for(int i = 0;i < k;i++) {\r\n                customStack[i] += val;\r\n            }\r\n        }\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度： O(k)\r\n- 空间复杂度：O（N）N为初始化栈的大小，即额外数组的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Gaozizhong":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916600638","body":"# 思路\r\n把K从个位数开始分解成单个值与num从个位开始（倒序）相加，存入数组。\r\n要注意K位数高于num的情况。\r\n最后把结果数组进行反转即可得到正确答案。\r\n\r\n# 代码：Go\r\n```\r\nfunc addToArrayForm(num []int, k int) (result []int) {\r\n\tfor  i := len(num) - 1 ; i >= 0 ; i--{\r\n\t\tsum := num[i] + k % 10\r\n\t\tk /= 10\r\n\t\tif sum >= 10{\r\n\t\t\tk ++\r\n\t\t\tsum -= 10\r\n\t\t}\r\n\t\tresult = append(result, sum)\r\n\t}\r\n\tfor ; k > 0; k /= 10 {\r\n\t\tresult = append(result, k % 10)\r\n\t}\r\n\treverse(result)\r\n\treturn result\r\n}\r\n\r\nfunc reverse(result []int) {\r\n\tfor i, n := 0, len(result); i < n/2; i++{\r\n\t\tresult[i], result[n-1-i] = result[n-1-i], result[i]\r\n\t}\r\n}\r\n```\r\n\r\n# 时间复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wang-hejie":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916601021","body":"## <font color=#A0522D>思路</font>\r\n\r\n从数组末尾开始往前遍历，每一位先和 k 相加。\r\n相加的和 %10 就是这一位应有的数值，相加的和 整除10 就是下一位的 k 。\r\n\r\n<font color=red>**注意：**</font>如果数组遍历结束后， k 仍然不为 0 ，那么需要将剩下的 k 加入到数组开头\r\n\r\n## <font color=#A0522D>复杂度</font>\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)\r\n\r\n## <font color=#A0522D>代码(Python3)</font>\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        for i in range(len(num)-1, -1, -1):\r\n            k_add_num = num[i] + k\r\n            num[i] = k_add_num % 10\r\n            k = k_add_num // 10\r\n            # 提前退出循环的trick\r\n            if not k:\r\n                break\r\n        \r\n        if k:\r\n            while k:\r\n                num.insert(0, k % 10)\r\n                k = k // 10\r\n        \r\n        return num\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917325824","body":"## 思路\n\n先从左到右遍历s字符串数组，更新ans数组。记录当前遍历到最新的字符c下标prev。对于ans的第i个位置，它与它左侧最近字符c的距离是<font color=red>i - prev</font>。遍历结束后，**ans记录每一个位置距离它左侧字符c的最近距离。**\n\n再从右到左遍历s字符串数组，更新ans数组。记录当前遍历到最新的字符c下标prev。对于ans的第i个位置，它与它右侧最近字符c的距离是<font color=red>**prev - i，从prev - i和已经存放的i - prev中选择小的那个存入ans[i]。**</font>遍历结束后，ans记录每一个位置距离字符c的最近距离。\n\n<font color=red>注意：</font>从左到右遍历时，prev初始化成-inf；从右到左遍历时，prev初始化成inf。\n\n## 复杂度\n\n- 时间复杂度：O(n)，遍历了2遍s字符串\n- 空间复杂度：O(n)，n为ans数组大小\n\n## 代码(Python)\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = []\n        prev = float('-inf')\n        # 从左向右遍历\n        for i, char in enumerate(s):\n            if char == c:\n                prev = i\n            ans.append(i - prev)\n        \n        # 从右向左遍历\n        prev = float('inf')\n        for i in range(len(ans)-1, -1, -1):\n            if s[i] == c:\n                prev = i\n            ans[i] = min(ans[i], prev - i)\n        \n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917653417","body":"## <font color=#A0522D>思路</font>\n\n空间换时间。我们实际上只在出栈时关心栈中的值，因此“栈底的 k 个元素的值都增加 val ”这一功能没必要真的去栈里花线性时间加，可以用一个hashmap暂存，其中键为需要加的最后一位元素的下标，值为需要加的 val 。要出栈时，就去hashmap里看一下当前元素是否需要加 val 即可。\n<font color=red>注意：</font>当一个元素出栈时若需要加 val ，当它出栈完毕后，需要更新hashmap，使它对应的键值对中的键-1。\n\n## <font color=#A0522D>复杂度</font>\n\n- 时间复杂度：`push`，`pop`和`inc`都是O(1)\n- 空间复杂度：O(n)，模拟栈的列表和hashmap的大小都是n\n\n## <font color=#A0522D>代码(Python)</font>\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.inc_dict = dict()  # 记录inc状态的hashmap\n        self.max_size = maxSize\n        self.size = 0\n\n    def push(self, x: int) -> None:\n        if self.size < self.max_size:\n            self.stack.append(x)\n            self.size += 1\n\n    def pop(self) -> int:\n        if not self.size:\n            return -1\n        self.size -= 1\n        pop_rslt = self.stack.pop()\n        if self.inc_dict.get(self.size):\n            pop_rslt += self.inc_dict[self.size]\n            # 更新inc_dict\n            if self.inc_dict.get(self.size-1):\n                self.inc_dict[self.size-1] += self.inc_dict[self.size]\n            else:\n                self.inc_dict[self.size - 1] = self.inc_dict[self.size]\n            self.inc_dict.pop(self.size)\n        return pop_rslt\n\n    def increment(self, k: int, val: int) -> None:\n        stop_limit = min(len(self.stack)-1, k-1)\n        if self.inc_dict.get(stop_limit):\n            self.inc_dict[stop_limit] += val\n        else:\n            self.inc_dict[stop_limit] = val\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Francis-xsc":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916601314","body":"### 思路\n\n模拟加法，从个位开始加，如有进位，k--（用变量表示进位有点复杂）\n最后反转\n\n### 代码\n\n\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len=num.size();\n        vector<int>ans;\n        for(int i=len-1;i>=0;--i)\n        {\n            int t=num[i]+(k%10);\n            k/=10;\n            if(t>=10)\n            {\n                t%=10;\n                k++;\n            }\n            ans.push_back(t);\n        }\n        while(k)\n        {\n            ans.push_back(k%10);\n            k/=10;\n        };\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)，其中 N 为数组长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917319149","body":"### 思路\n\n从前到后扫一遍，再从后到前扫一遍，取较小值\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int p=-100000,len=s.length();\n        vector<int> ans(len);\n        for(int i=0;i<len;++i)\n        {\n            if(s[i]==c)\n                p=i;\n            ans[i]=i-p;\n        }\n        p=INT_MAX;\n        for(int i=len-1;i>=0;--i)\n        {\n             if(s[i]==c)\n                p=i;\n            ans[i]=ans[i]<p-i?ans[i]:p-i;\n        }\n        return ans;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N =s.len。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917559772","body":"### 思路\n\n数组模拟栈\n\n### 代码\n\n\n```cpp\n\nclass CustomStack {\nprivate:\n    int *s;\n    int pos;\n    int max;\npublic:\n    CustomStack(int maxSize) {\n        s=new int[maxSize];\n        pos=0;\n        max=maxSize;\n    }\n    \n    void push(int x) {\n        if(pos==max)\n            return;\n        s[pos++]=x;\n    }\n    \n    int pop() {\n        if(pos==0)\n            return -1;\n        return s[--pos];\n    }\n    \n    void increment(int k, int val) {\n        k=k<pos?k:pos;\n        for(int i=0;i<k;++i)\n            s[i]+=val;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：push(),pop():O(1) increment:O(N)，N=min(k,size())。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917745429","body":"### 思路\n\n两个栈\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<int>num;\n        stack<string>str;\n        str.push(\"\");\n        int cnt=0,len=s.size();\n        for(int i=0;i<len;i++)\n        {\n            if(isdigit(s[i]))\n                cnt=cnt*10+s[i]-'0';\n            else if(isalpha(s[i]))\n                str.top()+=s[i];\n            else if(s[i]=='[')\n            {\n                str.push(\"\");\n                num.push(cnt);\n                cnt=0;\n            }\n            else if(s[i]==']')\n            {\n                int n=num.top();\n                num.pop();\n                string t=str.top();\n                str.pop();\n                for(int i=0;i<n;i++)\n                    str.top()+=t;\n            }\n        }\n        return str.top();\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iambigchen":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916602214","body":"### 思路\n大数相加 每个位置相加，如果大于9，向前进一位\n\n### 代码\n```js\nvar addToArrayForm = function(num, k) {\n    k = String(k).split('')\n    var length = Math.max(num.length, k.length)\n    var res = new Array(length).fill(0)\n    for (let index = length-1; index >= 0; index--) {\n        var a = num.length > 0 ? num.pop() : 0\n        var b  = k.length > 0 ?  k.pop() : 0\n        var sum = res[index] + a + +b\n        res[index] = sum % 10\n        if (sum > 9) {\n            if (index-1 >= 0) {\n                res[index - 1] = 1\n            } else {\n                res.unshift(1)\n            }\n        }\n    }\n    return res\n};\n```\n\n### 复杂度\n\n时间： O(n)\n空间： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917378714","body":"### 思路\n遍历S，在每一项向左和右逐步添加，判断是否等于c，如果等于c就是最短距离\n\n### 代码\n```js\nvar shortestToChar = function(s, c) {\n    let res = []\n    for (let index = 0; index < s.length; index++) {\n       let diff = 0\n       while ((index-diff >=0 || diff+index < s.length) && s[index-diff] !== c && s[diff + index] !== c) {\n           diff++\n       }\n       res.push(diff)\n    }\n    \n    return res\n};\n```\n\n### 复杂度\n时间复杂度 O(n^2)\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917591095","body":"### 思路\n用数组存储数据\n\n### 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.val = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.val.length < this.maxSize) {\n        this.val.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.val.length === 0) {\n        return -1\n    }\n    return this.val.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(var i =0; i< k;i++) {\n        if (i < this.val.length) {\n            this.val[i] = this.val[i] + val\n        }\n    }\n};\n```\n\n### 复杂度\n时间复杂度 O(n)\n空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Cartie-ZhouMo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916605114","body":"### 思路\r\n从低位到高位遍历num、k，求和，注意进位。如果 k > A，需将剩余数字转换并插到num前。\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        if k == 0: return num\r\n        flag = 0\r\n        for i in range(len(num)-1, -1, -1):\r\n            k, b = k//10, k%10\r\n            num[i], flag = (num[i] + b + flag)%10, (num[i] + b + flag)//10\r\n        tmp = []\r\n        k += flag\r\n        while k:\r\n            k, n = k//10, k%10\r\n            tmp.append(n)\r\n        return tmp[::-1] + num\r\n```\r\n**复杂度分析**\r\n- 时间：O(max(n, K)) K = k的位数, N = len(num)\r\n- 空间：O(max(1, K-n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917384183","body":"### 思路\n暴力法。遍历字符串，每个字符向左、右寻找最近的c。\n### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = []\n        for ind, ss in enumerate(s):\n            if ss == c:\n                ans.append(0)\n            else:\n                i = 1\n                dis = inf\n                while i <= ind:\n                    if s[ind-i] == c:\n                        dis = i\n                        break\n                    else:\n                        i += 1\n                i = 1\n                while i < len(s) - ind:\n                    if s[ind+i] == c:\n                        dis = min(dis, i)\n                        break\n                    else:\n                        i += 1\n                ans.append(dis)\n        return ans\n```\n**复杂度**\n- 时间：O(N^2) N=len(s)\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917596641","body":"### 思路\npython list模拟栈，pop时判断长度是否=0，push时判断长度是否=maxSize。inc时判断k与长度关系。\n### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        self.len = 0\n\n\n    def push(self, x: int) -> None:\n        if self.len < self.maxSize:\n            self.stack.append(x)\n            self.len += 1\n\n\n    def pop(self) -> int:\n        if self.len == 0:\n            return -1\n        else:\n            self.len -= 1\n            return self.stack.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i < self.len:\n                self.stack[i] += val\n```\n**复杂度**\n- 时间：pop、push O(1), inc O(min(k, len))\n- 空间：O(len)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917786133","body":"### 思路\n遇到'['时，栈内保存当前子串和倍数。遇到']'时，弹出栈顶并与当前子串组合。\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        ans = ''\n        num = 0\n        for c in s:\n            if '0' <= c <= '9':\n                # 注意数字位数\n                num = num*10 + int(c)\n            elif c == '[':\n                stack.append((num, ans))\n                ans = ''\n                num = 0\n            elif c == ']':\n                cnt, tmp_str = stack.pop()\n                ans = tmp_str + ans*cnt\n            else:\n                ans += c\n        return ans\n```\n**复杂度**\n- 时间：O(N)\n- 空间：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ningli12":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916605335","body":"### **思路**\r\n- 从k的个位开始，从num最后一位开始加，用carry记录进位\r\n- 在下一位计算的时候算上carry值并更新carry值, k也需要更新。\r\n- 需要处理carry > 0的情况，在高一位的计算中加carry\r\n- 反转结果\r\n\r\n### **代码**\r\n\r\n- 使用代码: Java\r\n\r\n```\r\nclass Solution {\r\n        public List<Integer> addToArrayForm(int[] num, int k) {\r\n            List<Integer> res = new ArrayList<>();\r\n            if(num == null) return res;\r\n            int carry = 0;\r\n            int size = num.length -1;\r\n            while(k > 0 || size >= 0){\r\n                int curNum = size >= 0? num[size] : 0;\r\n                int curK = k % 10;\r\n                int curSum = curNum + curK + carry;\r\n                int curAdd = curSum % 10;\r\n                carry = curSum / 10;\r\n                size--;\r\n                k = k/10;\r\n                res.add(curAdd);\r\n            }\r\n            if(carry > 0) {\r\n                res.add(carry);\r\n            }\r\n            Collections.reverse(res);\r\n            return res;\r\n        }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n- 时间复杂度：O(max(n, log k))，其中n为数组的长度\r\n- 空间复杂度：O(max(n, log k)。使用的空间为数组和k的最大长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917220140","body":"## 思路 - Array遍历\r\n- 初始化result array.\r\n- 两次遍历\r\n- 第一次从左到右，遇到c，将其右边的依次从 i - pre。 pre不会超过Array的长度\r\n- 第二次从右到左，遇到c，将其左边 i - pre 比较并取min；\r\n\r\n## 代码\r\n```\r\nclass Solution {\r\n  public int[] shortestToChar(String S, char C) {\r\n        int n = S.length(), pre = -n, res[] = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            if (S.charAt(i) == C) pre = i;\r\n            res[i] = i - pre;\r\n        }\r\n        for (int i = pre - 1; i >= 0; i--) {\r\n            if (S.charAt(i) == C)  pre = i;\r\n            res[i] = Math.min(res[i], pre - i);\r\n        }\r\n        return res;\r\n    }\r\n }\r\n```\r\n\r\n## 思路 - DP\r\n- Array遍历\r\n- 初始化result array.\r\n- 遍历从左到右，遇到c，设为0，其余设为 size - 1;\r\n- 遍历从左1到右(i = 1)，和前一位（i - 1） + 1比较后取最小值\r\n- 遍历从右1到左（i = size - 2），和前一位（i + 1） + 1比较后取最小值\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int size = s.length();\r\n        int[] res = new int[size];\r\n        for(int i = 0; i < size; i++){\r\n            res[i] = s.charAt(i) == c? 0: size - 1;\r\n        }\r\n\r\n        for (int i = 1; i < size; i++){\r\n            res[i] = Math.min(res[i], res[i - 1] + 1);\r\n        }\r\n\r\n        for (int i = size - 2; i >= 0; i--){\r\n            res[i] = Math.min(res[i], res[i + 1] + 1);\r\n        }\r\n \r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度：\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917588150","body":"**思路**\r\n使用数组来记录增加的数值\r\n\r\n**代码**\r\n```\r\n    int n;\r\n    int[] inc;\r\n    Stack<Integer> stack;\r\n    public CustomStack(int maxSize) {\r\n        n = maxSize;\r\n        inc = new int[n];\r\n        stack = new Stack<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (stack.size() < n)\r\n            stack.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        int i = stack.size() - 1;\r\n        if (i < 0)\r\n            return -1;\r\n        if (i > 0)\r\n            inc[i - 1] += inc[i];\r\n        int res = stack.pop() + inc[i];\r\n        inc[i] = 0;\r\n        return res;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int i = Math.min(k, stack.size()) - 1;\r\n        if (i >= 0)\r\n            inc[i] += val;\r\n    }\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"YQYCS":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916605762","body":"### 思路：\r\n        将K逐位分解，加入到A中\r\n### 代码\r\n```\r\nclass Solution:\r\n  def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        i = len(A) - 1\r\n        while K:\r\n            A[i] += K\r\n            K, A[i] = A[i] // 10, A[i] % 10\r\n            i -= 1\r\n            if i < 0 and K:\r\n                A.insert(0,0)\r\n                i = 0\r\n        return A\r\n```\r\n### 复杂度分析\r\n        时间复杂度：O（N），需要遍历一遍数组，故为N\r\n        空间复杂度：O（1），不需要额外开辟空间\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917391160","body":"### 思路：\r\n对于各字符而言，它只关心离它最近的那个 C 字符，其他的它都不管。\r\n1、res需初始化，当字符为C时设为0，否则设置为空\r\n2、先从左往右遍历字符串 S，用res数组记录每个字符与左侧最后一个 C 字符的距离；\r\n3、再从右往左遍历字符串 S，将res数组值 和 每个字符与右侧最后一个 C 字符的距离 作大小比较，取最小值，即为距离的最小值。\r\n\r\n### 代码\r\npython代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        res = [0 if s[i] == c else None for i in range(n)]\r\n\r\n        for i in range(1,n):\r\n            if res[i] != 0 and res[i - 1] is not None:\r\n                res[i] = res[i - 1] + 1\r\n\r\n        for i in range(n-2, -1, -1):\r\n            if res[i] is None or res[i + 1] + 1 < res[i]:\r\n                res[i] = res[i + 1] + 1\r\n    \r\n        return res\r\n```\r\n\r\n### 复杂度分析：\r\n时间复杂度：O(N),N 是 S 的长度。\r\n空间复杂度：O(1)。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917618316","body":"### 思路\r\n    普通的栈只有栈顶元素是可见的(可以直接操作)，inc()中要实现的栈底k个元素值都增加，就需要让栈中的所有元素可见(直接对栈的值可直接操作)。\r\n    1、push 操作，判断当前元素的个数是否达到上限，如果没有达到，就把 top 后移一个位置并添加一个元素。\r\n    2、pop 操作，判断当前栈是否为空，非空返回栈顶元素的初始值加上增量 add[top]，在这之后，我们将增量向栈底进行传递，累加至 add[top - 1] 处。并将 top 前移一位，否则返回 -1。\r\n    3、inc 操作，使用数组模拟栈，用一个变量 top 来记录当前栈顶的位置，用数组add记录每次inc操作---栈底的k个元素（栈的个数相比较取最小值）的值都增加 val,将 add[k - 1] 增加 val。只有在 pop 操作时，我们才需要知道栈顶元素的具体值，在其余的情况下，我们只要存储每个元素的增量就行了，在遇到 pop 操作时，我们返回栈顶元素的初始值加上增量 add[top]。\r\n\r\n### 代码\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.add = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        ret = self.stk[self.top] + self.add[self.top]\r\n        if self.top != 0:\r\n            self.add[self.top - 1] += self.add[self.top]\r\n        self.add[self.top] = 0\r\n        self.top -= 1\r\n        return ret\r\n\r\n    def inc(self, k: int, val: int) -> None:\r\n        lim = min(k - 1, self.top)\r\n        if lim >= 0:\r\n            self.add[lim] += val\r\n\r\n```\r\n\r\n\r\n\r\n### 复杂度分析\r\n    时间复杂度：时间复杂度为 O(1)。\r\n    空间复杂度：空间复杂度为O(maxSize)，用了长度为 maxSize 的数组作为辅助空间。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916608620","body":"\n#idea: two iterations to add and decompose the num\n# time and space o(N)\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        nums = 0\n        length = len(num)\n        \n        for i in range(length):\n            nums += num[i] * (10**(length-1-i))\n        print(nums)\n        nums2= nums+k\n        list1 = []\n        if nums2 == 0:\n            return[0]\n        while nums2:\n            a= nums2%10\n            nums2 //= 10\n            list1.insert(0,a)\n        return list1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917218318","body":"#idea: iterate the string, use dictionary to save the distance and update\r\n```\r\nclass Solution:\r\n\tdef shortestToChar(self, s: str, c: str) -> List[int]:\r\n\t\tdic = {c:[]}\r\n\t\tlens = len(s)\r\n\t\toutput = []\r\n\t\tfor i in range(lens):\r\n\t\t\tif s[i] == c:\r\n\t\t\t\tdic[c].append(i)\r\n\t\tfor i in range(lens):\r\n\t\t\ttemp = [abs(i-k) for k in dic[c]]\r\n\t\t\toutput.append(min(temp))\r\n\t\treturn output\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917739217","body":"#idea all strings are separate by the num[], find each subpart string then merge\r\n```\r\nClass Solution:\r\n    def decodeString(self, s:str) -> str:\r\n        stack = []\r\n        strs,nums = '',''\r\n        for i in s:\r\n            if i.isdigit():\r\n                nums += i\r\n            elif i.isalpha():\r\n                strs += i\r\n            elif i == '[':\r\n                stack.append((strs,int(nums)))\r\n                strs,nums = '',''\r\n            elif i == ']':\r\n                prev,num = stack.pop()\r\n                strs = prev+num*strs\r\n        return a\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"siyuelee":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916610263","body":"## 思路：\n将K先加到数组最后一位，再从后向前遍历数组，依次进位\n## 代码\n```Python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n\n        num[-1] += k\n        for i in range(len(num) - 1, -1, -1):\n            carry, num[i] = divmod(num[i], 10)\n            if i > 0:\n                num[i-1] += carry\n        while carry:\n            num = [carry%10] + num\n            carry = carry//10\n        return num\n```\n## 复杂度分析\n    时间复杂度：O（N），需要遍历一遍数组，故为N\n    空间复杂度：O（1），不需要额外开辟空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917324513","body":"## 思路\nIterate twice - from the left and from the right. We will remember the index of the last char c that we've seen and append the distance to res[]. While interating from right to left, we will calc the distance agian and compare it with the one in res. Smaller ones would be the final results.\n\n## Code\n```Python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        prev = float('-inf')\n        res = []\n        for i, x in enumerate(s):\n            if x == c:\n                prev = i\n            res.append(i - prev)\n            \n        prev = float('inf')\n        for i in range(len(s)-1, -1, -1):\n            if s[i] == c:\n                prev = i\n            res[i] = min(res[i], prev - i)\n            \n        return res\n```\n## 复杂度分析\n时间复杂度O（n）\n空间复杂度O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917481852","body":"```Python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        self.stack = [0] * maxSize\n        self.top = -1\n\n    def push(self, x):\n        if self.top < len(self.stack) - 1:\n            self.top += 1\n            self.stack[self.top] = x\n\n    def pop(self):\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stack[self.top + 1]\n        \n\n    def increment(self, k, val):\n        for i in range(min(k, self.top + 1)):\n            self.stack[i] += val\n        \n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917719702","body":"## 思路\n递归\n- 每次遇到[，我们进入下一个function。 \n- 每个function 返回 currentString\n- 父function拿到子function返回的currentString， 乘上base从而加到自己的currentString\n- 遇到]，当前function返回currentString\n- 遇到字符，加到currentString\n- 遇到数字，yongchar2digit提取数字\n\n```Python\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        self.i = 0\n        # 1. what to do before enter the function\n        # 2. what does the function return\n        # 3. what to do after the function\n        def char2digit(s):\n            base = 0\n            i= 0\n            while s[i].isdigit():\n                base = 10 * base + int(s[i])\n                i = i + 1\n            return base,i\n\n        def dfs(s):\n            currentString = \"\"\n            # \"aa321s\"\n            while self.i < len(s):\n                if s[self.i].isdigit():\n                    base, length = char2digit(s[self.i:])\n                    self.i = self.i + length\n                    continue \n                elif s[self.i] == '[':\n                    self.i += 1\n                    ret = dfs(s)\n                    currentString += base * ret\n                elif s[self.i] == ']':\n                    self.i += 1\n                    return currentString\n                else:\n                    currentString += s[self.i]\n                    self.i += 1\n                # self.i += 1\n            return currentString\n        return dfs(s)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916612541","body":"````\nvar addToArrayForm = function(num, k) {\n  let arr = [];\n  while (k !== 0) {\n    arr.unshift(k % 10);\n    k = Math.floor(k / 10);\n  }\n  let res = num.length > arr.length ? num : arr;\n  let i = 1;\n  while (i <= res.length) {\n    let add1 = num.length - i >= 0 ? num[num.length - i] : 0;\n    let add2 = arr.length - i >= 0 ? arr[arr.length - i] : 0;\n    let sum = add1 + add2;\n    if (sum >= 10) {\n      res[res.length - i] = sum % 10;\n      if (res.length - i - 1 >= 0) res[res.length - i - 1] += 1;\n      else res.unshift(1);\n    } else {\n      res[res.length - i] = sum;\n    }\n    i++;\n  }\n  return res;  \n};\n````\n时间复杂度：O(n), n为num和k长度较长的那个\n\n空间复杂度：O(n), n为k的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917418658","body":"````\nvar shortestToChar = function(s, c) {\n  let res = [];\n  let target = s.indexOf(c);\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) {\n      target = i;\n      res.push(0);\n    } else {\n      res.push(Math.abs(target - i));\n    }\n  }\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s[i] === c) {\n      target = i;\n      res[i] = 0;\n    } else {\n      res[i] = Math.min(res[i], Math.abs(target - i));\n    }\n  }\n  return res;\n};\n````\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917542145","body":"`````\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.arr = [];\n  this.length = maxSize;  \n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.arr.length < this.length) {\n    this.arr.push(x);\n  }  \n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if (this.arr.length === 0) {\n    return -1;\n  } else {\n    return this.arr.pop();\n  }  \n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  let len = Math.min(this.arr.length, k);\n  for (let i = 0; i < len; i++) {\n    this.arr[i] += val;\n  }  \n};\n\n/** \n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n````\n时间复杂度：O(maxSize)\n\n空间复杂度：O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SnowBallBears":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916612816","body":"## **题目**\n989. Add to Array-Form of Integer\n\n## **思路**\n\nPretty straightforward thoughts, adding up an array and a number, use carry and another array to take care of the all cases.\n\n## **代码**\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        \n        for i in range(len(num)-1,-1,-1):\n            curr = num[i] + k%10 + carry\n            k = k//10\n            carry = curr//10     \n            num[i] = curr % 10\n    \n        k = k + carry\n        prenum = []\n        \n        while(k>0):\n            prenum.insert(0, k%10)\n            k = k//10\n        \n        return prenum + num\n        \n```\n\n## **复杂度**\n\nSpace: O(max(1, K-N))\nTime: O(N + max(0,(K-N)^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917333033","body":"## **题目**\n821. Shortest Distance to a Character\n\n## **思路**\n\nUse two pointers to find the nearest target letter for each letter\n\n## **代码**\n\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        res = [float('inf')] * n\n        \n        for i in range(n):\n            if s[i] == c:\n                res[i] = 0\n                continue\n            \n            left = right = i\n            while(left>=0):\n                if s[left] == c:\n                    res[i] = min(res[i], abs(left-i))      \n                    break\n                left = left-1\n            \n            while(right<n):\n                if s[right] == c:\n                    res[i] = min(res[i], abs(right-i))\n                    break\n                right = right+1\n        \n        return res\n        \n```\n\n## **复杂度**\n\nSpace: O(N)\nTime: O(N^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917546403","body":"## **题目**\n\n1381. Design a Stack With Increment Operation\n\n\n## **代码**\n\n      1. array\n   \n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.max_size = maxSize\n        self.size = 0\n        self.nums = []\n\n    def push(self, x: int) -> None:\n        if self.size < self.max_size:\n            self.size += 1\n            self.nums.append(x)\n        \n    def pop(self) -> int:\n        if self.size > 0:\n            self.size -= 1\n            return self.nums.pop()\n        \n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,self.size)):\n            self.nums[i] += val\n\n\n```\n\n      2. prefix sum\n\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.max_size = maxSize\n        self.size = 0\n        self.nums = []\n        self.prefix = [0] * (maxSize+1)\n\n    def push(self, x: int) -> None:\n        if self.size < self.max_size:\n            self.size += 1\n            self.nums.append(x)\n        \n    def pop(self) -> int:\n        if self.size > 0:\n            res = self.nums.pop() + self.prefix[self.size]\n            self.prefix[self.size-1] += self.prefix[self.size]\n            self.prefix[self.size] = 0\n            self.size -= 1\n            return res\n            \n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        self.prefix[min(k, self.size)] += val\n        \n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BlueRui":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916613826","body":"# Algorithm\nI use a more general approach to handle cases when k is longer than num, and when overflow may happen.\n1. Convert k to an array of digits\n2. Iterate from the lowest digit to highest one to add num[i] and k[i]. Get the sum of num[i], k[i] and carry. Add sum % 10 to list, and set sum / 10 to the new value of carry. End iteration when we reach the length of the shorter one of num and k\n3. Iterate over the remaining length of num or k in the same way. \n\n# Complexity\n* Time complexity: O(max(num.length, k.length)) \n* Space complexity: O(max(num.length, k.length))\n\n# Code\nLanguage: Java\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList<>();\n        \n        char[] kDigits = Integer.toString(k).toCharArray();\n        int[] numK = new int[kDigits.length];\n        for (int i = 0; i < kDigits.length; i++) {\n            numK[i] = kDigits[i] - '0';\n        }        \n        \n        int carry = 0;\n        int index = 0;\n        while (index < num.length && index < numK.length) {\n            int sum = num[num.length - 1 - index] + numK[numK.length - 1 - index] + carry;\n            result.add(sum % 10);\n            carry = sum / 10;\n            index++;\n        }\n        \n        while (index < num.length) {\n            int sum = num[num.length - 1 - index] + carry;\n            result.add(sum % 10);\n            carry = sum / 10;\n            index++;\n        }\n        \n        while (index < numK.length) {\n            int sum = numK[numK.length - 1 - index] + carry;\n            result.add(sum % 10);\n            carry = sum / 10;\n            index++;\n        }\n        \n        if (carry != 0) {\n            result.add(carry);\n        }\n        \n        Collections.reverse(result);\n        return result;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917180234","body":"# Algorithm\n1. Work through the array from the left to find the closest char c to the right of each char in s.\n2. Then work through the array from the right to find the closest char c to the left of each char in s.\n3. Find the min distance of step 1 and 2.\n4. Step 2 and 3 can be combined.\n\n# Complexity\n* Time Complexity: We are going over the array exactly twice. O(N)\n* Space Complexity: We can use the same output array, so no extra space. O(1)\n\n# Code\nLanguage: Java\n```Java\npublic int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] result = new int[n];\n        Arrays.fill(result, n);\n        // Find closest c on the right of each char\n        int cur = 0;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) != c) {\n                continue;\n            }\n            while (cur <= i) {\n                result[cur] = i - cur;\n                cur++;\n            }\n        }\n\n        // Update to get the closest c from both sides by comparing left side\n        cur = n - 1;\n        for (int i = n - 1; i >=0; i--) {\n            if (s.charAt(i) != c) {\n                continue;\n            }\n            while (cur >= i) {\n                result[cur] = Math.min(result[cur], cur - i);\n                cur--;\n            }\n        }\n        return result;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917536831","body":"# Problem: [1381. Design a Stack With Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n\n# Algorithm\n* Use an array to implement ths stack\n* Use *index* to track the current number of elements in the array and the top of the stack.\n\n# Complexity\n* *push* operation time complexity is O(1) since we simply assign one value to the current index of the array.\n* *pop* operation time complexity is O(1).\n* *inc* operation time complexity is O(k) where k is the number of elements to increment.\n* Total space complexity of the stack is O(n) where n is the maxSize.\n\n# Code\nLanguage: Java\n```java\nclass CustomStack {\n    private int[] stack;\n    private int index = 0;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (index == stack.length) {\n            return;\n        }\n        stack[index++] = x;\n    }\n    \n    public int pop() {\n        if (index == 0) {\n            return -1;\n        }    \n        return stack[--index];\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k; i++) {\n            if (i + 1 > index) {\n                return;\n            }\n            stack[i] += val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917766581","body":"# Problem [394. Decode String](https://leetcode.com/problems/decode-string/)\n\n# Algorithm\n* Iterate over each character in the string and use a stack to keep track of visited character.\n  1. Keep pushing to the stack until we hit a ']' in string.\n  2. When we hit a ']' in string.\n     1. Keep popping from stack and form a substring until we get a '[' from stack.\n     2. Keep popping digits from stack until it is no longer a digit.\n     3. Convert popped out digits to a multiplier of the substring.\n     4. Decode the substring and push the decoded substring to the stack.\n\n# Complexity\nTime Complexity: O(N) where N is the length of the decoded string.\nSpace Complexity: O(N) where N is the length of the decoded string.\n\n# Code\nLanguage: Java\n\n``` Java\npublic String decodeString(String s) {\n   Deque<Character> stack = new ArrayDeque<>();\n   for (char c : s.toCharArray()) {\n       if (c != ']') {\n           stack.addFirst(c);\n           continue;\n       }\n       List<Character> decodedStr = new ArrayList<>();\n       while (stack.peekFirst() != '[') {\n           decodedStr.add(stack.removeFirst());\n       }\n       // Remove '['\n       stack.removeFirst();\n       \n       // Get multiplier\n       int num = 0;\n       int base = 1;\n       // Important to check if stack is empty first\n       while (!stack.isEmpty() && Character.isDigit(stack.peekFirst())) {\n           // It is very important to keep track of base, as the lower digits may be 0s like \"100\"\n           // Simply using num = num * 10 + stack.removeFirst() - '0' won't work.\n           num = num + (stack.removeFirst() - '0') * base;\n           base *= 10;\n       }\n       \n       // Put decoded string back to stack\n       for (int i = 0; i < num; i++) {\n           for (int j = decodedStr.size() - 1; j >= 0; j--) {\n               stack.addFirst(decodedStr.get(j));\n           }\n       } \n   }\n   char[] result = new char[stack.size()];\n   for (int i = stack.size() - 1; i >= 0; i--) {\n       result[i] = stack.removeFirst();\n   }\n   return new String(result);        \n}\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"doveshnnqkl":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916614606","body":"# 思路\n* 从末尾开始遍历数组，最后一位与k最后一位相加，将K除以10取整，有进位加进位，循环\n* 数组遍历完  k还大于0，将k取余放入List, k除以10取整，循环\n* * *\n# 代码\n* 语言：Java\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n       LinkedList<Integer> ret = new LinkedList();\n       int index  = 0 ;\n       for(int i = num.length - 1; i >= 0 ; i--){\n          int   sum =  num[i];\n         \n                sum +=  k % 10 + index;\n                 k = k/10;\n          \n          if(sum >= 10){\n              sum =  sum - 10;\n              k++;\n          }\n          ret.addFirst(sum);\n       }\n       while(k > 0){\n           ret.addFirst(k%10);\n           k = k/10;\n       }\n     \n       return ret;\n    }\n}\n```\n* * *\n# 复杂度\n* 时间复杂度O(n)\n* 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917328807","body":"# 思路\n1.找出字符串中出现的字符的位置，放入List\n2.遍历字符串，找到List中第一个大于当前位置的数。\n3.如果找到的数位置是List 中下标为0， 新数组的数就是 list[0] - 遍历中的字符串当前位置\n4.如果找到的数位置下比0大， 比较  List 前一个数 和 找到的数， 分别做差求绝对值，取出较小的数。\n# 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n           int strLength =  s.length();\n           int[] res = new int[strLength]; \n           List<Integer> l =  new ArrayList<>();\n           for(int i = 0; i < strLength; i++){\n               char s2c =  s.charAt(i);\n               if(s2c == c){\n                   l.add(i);                 \n               }\n           }\n           for(int i = 0; i<strLength;i++){\n               int j = 0;\n               int num = l.get(j);\n               for(;j < l.size();j++){\n                   if(l.get(j) >= i){\n                       num = l.get(j);\n                       break;\n                   }\n               }\n               if(j == 0){\n                 res[i] = Math.abs(num - i);  \n               }else{\n                 res[i] = Math.min(Math.abs(l.get(j-1) -i),Math.abs(num - i));\n               }             \n           }        \n            return res;\n    }\n}\n```\n# 复杂度\n* 时间复杂度：O(n^2)\n* 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917574673","body":"# 思路\n    用Linkedlist当作栈，取一个变量当作指针，指针超过最大容量，不再往栈里存放数据。添加和入出栈操作指针加减一\n# 代码\n* java\n```java\nclass CustomStack {\n    private int index = -1;\n    private int max;\n    public LinkedList<Integer> list =  new LinkedList<>();\n    public CustomStack(int maxSize) {\n          max = maxSize;\n    }\n    \n    public void push(int x) {\n        if(index < max -1){\n           index++;\n           list.addLast(x);         \n        }\n    }\n    \n    public int pop() {\n           if(index == -1){\n               return index;\n           }\n           index--;\n           return list.removeLast();\n    }\n    \n    public void increment(int k, int val) {\n         int changeSize = 0;\n         int listSize = list.size();\n         LinkedList<Integer> temp =  new LinkedList<>();\n         while(changeSize < listSize){\n             if(changeSize < k){\n               temp.addLast(list.get(changeSize) + val);\n             }else{\n               temp.addLast(list.get(changeSize));\n             }\n             changeSize++;\n         }   \n         list =  temp;\n    }\n}\n```\n# 复杂度\n时间复杂度： O（N）\n空间复杂度： O（N）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916615519","body":"# Understand:\n```\n1 <= num.length <= 10^4\n0 <= num[i] <= 9\nnum does not contain any leading zeros except for the zero itself.\n1 <= k <= 10^4\n\nmost significant -> least significant digit\n```\n\n# Plan: \n```\ngo backward, track carry and sum for the current digit\nuse LinkedList for result\n```\n\n# Review:\n```\nnum = [9, 9, 9], k = 1 -> 1000\n\n999\n  1\n \n1000\n\nnum = [1], k = 999\n\n  1\n999\n\n\nnum = [1], k = 9\n```\n\n# Evaluate:\n```\nm = num.length, n = number of digits in k, log(10)k\n\nTime: O(max(m, n))\n\nSpace: O(max(m, n)) for the output list\n```\n\n# Code: \n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> sum = new LinkedList<>();\n        int carry = 0, curDigit = 0;\n        \n        for (int i = num.length - 1; i >= 0; i--) {\n            curDigit = k % 10 + num[i] + carry;\n            carry = curDigit / 10;\n            curDigit = curDigit % 10;\n            k /= 10;\n            sum.addFirst(curDigit);\n        }\n        \n        while (k > 0) {\n            curDigit = k % 10 + carry;\n            carry = curDigit / 10;\n            curDigit = curDigit % 10;\n            k /= 10;\n            sum.addFirst(curDigit);\n        }\n        \n        if (carry == 1) {\n            sum.addFirst(carry);\n        }\n        \n        return sum;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917382405","body":"# https://leetcode.com/problems/shortest-distance-to-a-character/\n\n# Understand:\n```\n1 <= s.length <= 10^4\ns[i] and c are lowercase English letters.\nIt is guaranteed that c occurs at least once in s.\n```\n# Plan:\n```\n1. bruteforce: expand into left and right\n\ncurrent char == c, 0\notherwise, expand out to find the closest matches in the left and right (note, there might be no match)\n\n## Time: O(s.length() ^ 2)\n\n## Space: O(1)\n\n2. auxiliary list to store matched indices\n\nfind the closet match (by traversing)\n\nmatched indices list size = k, k is bounded by s.length()\n\n## Time: O(s.length()) + O(s.length() * k)\n\n## Space: O(k)\n\n3. dp: two lists to store the leftmost & rightmost matched indices\n\nleft to right traversal to build leftclosestIndices\nright to left traversal to build rightclosestIndices\n\ntraverse the s to compute the min distance\n\n3-1 optimization: get the closer (instead of right) indices in the second traversal \n3-2 optimization: prevent the final traversal, directly update closest distances in the array\n\n## Time: O(s.length())\n## Space: O(s.length())\n\n4. see the matched chars in s as boundaries/splitters\nsliding window\n\n## Time: O(s.length()) !!!, l and r will travel O(s.length())\n## Space: O(1)\n```\n# Review:\n```\nInput: s = \"loveleetcode\", c = \"e\"\nOutput: [3,2,1,0,1,0,0,1,2,2,1,0]\n\n\"aaba\"\n\"b\"\n[2,1,0,1]\n```\n\n# Code: \n```jave\nclass Solution {\n    // 4. sliding window: see the matched chars in s as boundaries/splitters\n    // m**  -> intial l = 0, r = 0\n    // *m   -> initial l = -1, r = 1\n    public int[] shortestToChar(String s, char c) {\n        int[] distances = new int[s.length()]; // initialized as max's\n        Arrays.fill(distances, Integer.MAX_VALUE);\n        \n        int l = 0, r = 0;\n        \n        l = s.charAt(0) == c ? 0 : -1; //-1:not finding left boundary for cur window\n        r = findNextRight(s, c, 0);\n        \n        for (int i = 0; i < s.length(); i++) {\n            // compare distances from l and r\n            if (l != -1) { // has left boundary\n                distances[i] = i - l;\n            }\n            if (r != -1) {\n                distances[i] = Math.min(distances[i], r - i);\n            }\n                \n            // slides to the next window when we reach the right boundary\n            if (i == r) {\n                l = r;\n                r = findNextRight(s, c, l + 1);\n            }\n        }\n        return distances;\n    }\n    \n    // time: O(s.length())\n    private int findNextRight(String s, char c, int start) {\n        int i = 0;\n        for (i = start; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                return i;\n            }\n        }\n        return -1; // cannot find a match after (including) start index\n    }\n    \n    // 3-2 optimization: prevent the final traversal, directly update closest distances in the array - clean \n    public int[] shortestToChar_3_2_clean(String s, char c) {\n        \n        int[] closest = new int[s.length()];\n        Arrays.fill(closest, Integer.MAX_VALUE);\n        \n        // find the closest \n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                closest[i] = 0;\n            }\n            // else !! if closest[i - 1] == Integer.MAX_VALUE, no match on its left\n            else if (i > 0 && closest[i - 1] != Integer.MAX_VALUE) {\n                closest[i] = closest[i - 1] + 1;\n            } \n        }\n\n        // the last val in closest won't be max given >=1 match exists\n        for (int i = s.length() - 1; i >= 0; i--) { \n            // no match on its left or cur index is closer to the right match\n            if (closest[i] == Integer.MAX_VALUE || \n                (i < s.length() - 1 && closest[i] > closest[i + 1] + 1)) {\n                closest[i] = closest[i + 1] + 1;\n            }\n        }\n        \n        return closest;\n    }\n    \n    // direction 3 - 1: clean \n    // time: O(s.length())\n    // space: O(s.length())\n    public int[] shortestToChar_3_1_clean(String s, char c) {\n        int[] distances = new int[s.length()]; // initialized as 0's\n        int[] closestIndices = new int[s.length()];\n        Arrays.fill(closestIndices, Integer.MAX_VALUE);\n        \n        // find the closest \n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                closestIndices[i] = i;\n            }\n            // else !! if closestIndices[i - 1] == Integer.MAX_VALUE, no match on its left\n            else if (i > 0 && closestIndices[i - 1] != Integer.MAX_VALUE) {\n                closestIndices[i] = closestIndices[i - 1];\n            } \n        }\n\n        // the last val in closestIndices won't be max given >=1 match exists\n        // find closest index on the right, think about ** * m, ***\n        for (int i = s.length() - 1; i >= 0; i--) { \n            // no match on its left or cur index is closer to the right match\n            if (closestIndices[i] == Integer.MAX_VALUE || \n                (i < s.length() - 1 && i - closestIndices[i] > closestIndices[i + 1] - i)) {\n                closestIndices[i] = closestIndices[i + 1];\n            }\n        }\n        // calculate the min distance\n        for (int cur = 0; cur < s.length(); cur++) {\n            if (s.charAt(cur) == c) {\n                continue;\n            }\n            distances[cur] = Math.abs(closestIndices[cur] - cur);\n        }\n        \n        return distances;\n    }\n    \n    // not clean\n    // 3-1 optimization: get the closer (instead of right) indices in the second traversal \n    public int[] shortestToChar3_1(String s, char c) {\n        int[] distances = new int[s.length()]; // initialized as 0's\n        \n        int[] closestIndices = new int[s.length()];\n        \n        int left = -1, right = -1;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                closestIndices[i] = i;\n                left = i;\n            } else {\n                closestIndices[i] = left;\n            }\n        }\n        \n        for (int i = s.length() - 1; i >= 0; i--) {  \n            if (s.charAt(i) == c) {\n                closestIndices[i] = i;\n                right = i;\n            } \n            // when to update closestIndices[i]\n            if (closestIndices[i] == -1 || (closestIndices[i] != -1 && right != -1 && i - closestIndices[i] > right - i)) { // note this condition\n                closestIndices[i] = right;\n            }\n        }\n        \n        for (int cur = 0; cur < s.length(); cur++) {\n            if (s.charAt(cur) == c) {\n                continue;\n            }\n            distances[cur] = Math.abs(closestIndices[cur] - cur);\n        }\n        \n        return distances;\n    }\n    \n    // not clean\n    // 3. dp: two lists to store the leftmost & rightmost matched indices\n    public int[] shortestToChar3(String s, char c) {\n        int[] distances = new int[s.length()]; // initialized as 0's\n        \n        int[] leftclosestIndices = new int[s.length()];\n        int[] rightclosestIndices = new int[s.length()];\n        \n        int left = -1, right = -1;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                leftclosestIndices[i] = i;\n                left = i;\n            } else {\n                leftclosestIndices[i] = left;\n            }\n        }\n        \n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                rightclosestIndices[i] = i;\n                right = i;\n            } else {\n                rightclosestIndices[i] = right;\n            }\n        }\n\n        for (int cur = 0; cur < s.length(); cur++) {\n            if (s.charAt(cur) == c) continue;\n            \n            if (leftclosestIndices[cur] != -1) {\n                distances[cur] = cur - leftclosestIndices[cur];\n            }\n            \n            if (rightclosestIndices[cur] != -1) {\n                if (distances[cur] != 0) {\n                    distances[cur] = \n                        Math.min(distances[cur], rightclosestIndices[cur] - cur);\n                } else {\n                    distances[cur] = rightclosestIndices[cur] - cur;\n                }\n                \n            }\n        }\n        \n        return distances;\n    }\n    \n    // 2. auxiliary list to store matched indices\n    public int[] shortestToChar2(String s, char c) {\n        int[] distances = new int[s.length()]; // initialized as 0's\n        \n        List<Integer> indices = new ArrayList<>();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                indices.add(i);\n            }\n        }\n        \n        for (int cur = 0; cur < s.length(); cur++) {\n            if (s.charAt(cur) != c) {\n                for (int index : indices) {\n                    int dist = Math.abs(index - cur);\n                    if (distances[cur] == 0) {\n                        distances[cur] = dist;\n                    } else {\n                        if (distances[cur] > dist) {\n                            distances[cur] = dist;\n                        } else {\n                            break;// no need to keep on search\n                        }\n                    }\n                }\n            }\n        }\n        \n        return distances;\n    }\n    \n    // 1. bruteforce: expand into left and right\n    public int[] shortestToChar1(String s, char c) {\n        int[] distances = new int[s.length()]; // initialized as 0's\n        \n        for (int cur = 0; cur < s.length(); cur++) {\n            if (s.charAt(cur) != c) {\n                // expand into 2 directions\n                int left = cur - 1, right = cur + 1;\n                \n                for (int i = left; i >= 0; i--) {\n                    if (s.charAt(i) == c) {\n                        left = i;\n                        break;\n                    }\n                }\n                \n                for (int j = right; j < s.length(); j++) {\n                    if (s.charAt(j) == c) {\n                        right = j;\n                        break;\n                    }\n                }\n                \n                // check if found\n                if (left >= 0 && s.charAt(left) == c) {\n                    distances[cur] = cur - left;\n                }\n                if (right < s.length() && s.charAt(right) == c) {\n                    distances[cur] = distances[cur] == 0 ? right - cur : Math.min(distances[cur], right - cur);\n                }\n            }\n        }\n        return distances;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917575242","body":"# https://leetcode.com/problems/design-a-stack-with-increment-operation/\n\n# Understand:\n```\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\nAt most 1000 calls will be made to each method of increment, push and pop each separately.\n\nIncrements the bottom k elements of the stack by val. If there are less than k elements in the stack, just increment all the elements in the stack.\n```\n# Plan:\n```\n1. Bruteforce Logic:\ncapacity : the max capacity of the stack\nsize : the current size of stack\nuse array to store elements\n\nPush: if it is not full, push, size++\nPop: if it is empty, return -1; else size--, return stack[size]\nIncrement: iterate based on min(k, size) and increment \n\n// https://www.techiedelight.com/iterate-through-stack-java/\n\n## Complexity:\nTime: Pop, Push O(1); Increment O(min(k, size)) \nSpace: O(maxSize)\n\n2. prefix sum\nimprove time using auxiliary space\n\ninc array\n\npop: empty check,\n\nint ans = stack[size - 1] + inc[size - 1];\n        \n        // at least 1 element left after popping\n        if (size >= 2) {\n            inc[size - 2] += inc[size - 1];\n        }\n        \n        // clear that cell\n        inc[size - 1] = 0;\n        size--;\n\nExample：\n\nafter pushing, \nstack:[1,2,3]\n\ninc:[0,0,0]\n         k.val          inc            expected stack status\nincrement(3,3)       [0,0,3]            [4,5,6]\nincrement(2,1)       [0,1,3]            [5,6,6]\nincrement(1,1)       [1,1,3]            [6,6,6]\n\npop(): 3+3=6, inc:[1,1+3]\npop(): 2+4=6, inc:[5]\npop(): 1+5=6, inc:[]\n\n[\"CustomStack\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[3],[3,3],[2,1],[1,1],[],[],[]]\n\n->\n[null,null,null,null,null,null,null,6,6,6]\n\n\npush: check capacity, push, increment size\n\nincrement: empty check, inc[Math.min(k, size) - 1] += val;\n\n## Complexity:\nTime: Pop, Push. Increment O(1)\nSpace: O(maxSize/n) amortized, n=number of operations\n\n3. optimized prefix sum with lists representation\n每次栈 push 的时候，incrementals 也 push 一个 0,不用初始化maxsize的数组\n\n## Complexity:\n\nTime: Pop, Push. Increment O(1)\nSpace: O(max size/n) amortized, n=number of operations, max size bounded by the given maxSize\n\nhttps://stackoverflow.com/questions/43145395/time-complexity-while-deleting-last-element-from-arraylist-and-linkedlist\n\n\n[\"CustomStack\",\"push\",\"pop\",\"push\",\"increment\",\"pop\"]\n[[3],[1],[],[2],[5,100],[]]\n\n[null,null,1,null,null,102]\n```\n\n# Code: \n```java\n\n// 3. with lists\n\nclass CustomStack {\n    int capacity;\n    int size;\n    List<Integer> stack;\n    List<Integer> inc;\n    \n    public CustomStack(int maxSize) {\n        capacity = maxSize;\n        size = 0;\n        stack = new ArrayList<>();\n        inc = new ArrayList<>();\n    }\n    \n    public void push(int x) {\n        if (size < capacity) {\n            stack.add(x);  // stack: bottom -> top\n            inc.add(0);\n            size++;\n        }\n    }\n    \n    public int pop() {\n        if (size == 0) return -1;\n        \n        int ans = stack.get(size - 1) + inc.get(size - 1);\n        // at least 1 element left after popping\n        if (size >= 2) {\n            inc.set(size - 2, inc.get(size - 2) + inc.get(size - 1));\n        }\n        \n        // remove the tail of inc and stack lists\n        inc.remove(size - 1); // by index, O(1)\n        stack.remove(size - 1); // this line is needed in list implementation, as we use stack[size] = x; in array but use add(x) in list implementation\n        \n        size--;\n        \n        return ans;\n    }\n    \n    public void increment(int k, int val) {\n        // empty check\n        if (size > 0) {\n            inc.set(Math.min(k, size) - 1, inc.get(Math.min(k, size) - 1) + val);\n        }\n    } \n}\n\n\n// 2.prefix sum\n/*\nclass CustomStack {\n    int capacity;\n    int size;\n    int[] stack;\n    int[] inc;\n    \n    public CustomStack(int maxSize) {\n        capacity = maxSize;\n        size = 0;\n        stack = new int[capacity];\n        inc = new int[capacity];\n    }\n    \n    public void push(int x) {\n        if (size < capacity) {\n            stack[size] = x;\n            size++;\n        }\n    }\n    \n    public int pop() {\n        if (size == 0) return -1;\n        \n        int ans = stack[size - 1] + inc[size - 1];\n        \n        // at least 1 element left after popping\n        if (size >= 2) {\n            inc[size - 2] += inc[size - 1];\n        }\n        \n        // clear that cell\n        inc[size - 1] = 0;\n        \n        size--;\n        \n        return ans;\n    }\n    \n    public void increment(int k, int val) {\n        // empty check\n        if (size > 0) {\n            inc[Math.min(k, size) - 1] += val; // note - 1 here, in pop() we need to clear inc[cell] \n        }\n    } \n}\n*/\n\n// 1. bruteforce\n/*\nclass CustomStack {\n    int capacity;\n    int size;\n    int[] stack;\n    \n    public CustomStack(int maxSize) {\n        capacity = maxSize;\n        size = 0;\n        stack = new int[capacity];\n    }\n    \n    public void push(int x) {\n        if (size < capacity) {\n            stack[size] = x;\n            size++;\n        }\n    }\n    \n    public int pop() {\n        if (size == 0) return -1;\n        size--;\n        return stack[size];// note this line\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < Math.min(k, size); i++) {\n            stack[i] += val;\n        }\n    }\n}\n*/\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n ```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuWF":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916616395","body":"- convert num to int\n- add num to k\n- iterate through total by making it a string, add to res list\n- time complexity: O(N), N is the num list length\n- space complexity: O(M), M is the num list length\n\n\n\nCode:\n\n```python\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]:\n    total = 0\n    index = 0\n    \n    for n in num[::-1]:\n        total += (10 ** index) * n\n        index += 1\n    \n    total += k\n    \n    res = []\n    for digit in str(total):\n        res.append(int(digit))\n    \n    return res\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917335074","body":"### 📜Notes:\n\n2 pass solution:\n\n- forward iteration to mark res[i] distance closest to target character on the left\n- backward iteration to mark res[i] distance closest tot target character on the right\n- time: O(N), length of s\n- space: O(N)\n\n\n\n------\n\n\n\n### 💻Code:\n\n```python\n# 2 pass\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # len(s) is 1 bigger than max distance\n        res = [len(s)] * len(s)\n        \n        leftMost = rightMost = -1\n        \n        for i in range(len(s)):\n            if s[i] == c: leftMost = i\n            if leftMost != -1:\n                res[i] = i - leftMost\n        \n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c: rightMost = i\n            if rightMost != -1:\n                res[i] = min(res[i], rightMost - i)\n        \n        return res\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917489775","body":"### 📜Notes:\n\n- doubly linked list: access to both bottom and top stack\n- push: O(1)\n- pop: O(1)\n- increment: O(K), k is the number of values to increment\n\n\n\n------\n\n\n\n### 💻Code:\n\n```python\nclass Node:\n    \n    def __init__(self, val):\n        self.val = val\n        self.next = None\n        self.prev = None\n        \nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.head = None\n        self.tail = None\n        self.maxSize = maxSize\n        self.currSize = 0\n\n    def push(self, x: int) -> None:\n        if self.currSize >= self.maxSize: return\n        \n        self.currSize += 1\n        if self.head is None: \n            self.head = Node(x)\n            self.tail = self.head\n            return\n        \n        temp = self.tail\n        self.tail.next = Node(x)\n        self.tail = self.tail.next\n        self.tail.prev = temp\n        \n    def pop(self) -> int:\n        if self.currSize == 0: return -1\n        \n        self.currSize -= 1\n        res = self.tail.val\n        self.tail = self.tail.prev\n        \n        # re-init head and tail\n        if self.tail is None:\n            self.head = None\n            return res\n        self.tail.next = None\n        \n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        curr = self.head\n        for i in range(min(k, self.currSize)):\n            curr.val += val\n            curr = curr.next\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917767541","body":"### 💻Code:\n\n```python\n# use stack to store a pair number of times + the string to repeat\n# use currCount to store how many times to repeat current substring\n# use currString to store current string iterated so far\n\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        currString = ''\n        currCount = 0\n        stack = []\n        \n        for char in s:\n            if char.isdigit():\n                currCount = currCount * 10 + int(char)\n            elif char == '[':\n                # start of a new subtring\n                # store currCount and string\n                # reset currCount and string\n                \n                stack.append(currString)\n                stack.append(currCount)\n                currString = ''\n                currCount = 0\n            elif char == ']':\n                # end of this substring\n                # pop stack top string pair and add to current String\n                \n                count = stack.pop()\n                string = stack.pop()\n                currString = string +  count * currString\n            else:\n                currString += char\n                \n        return currString\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JoeyChengTor":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916620734","body":"### 思路\n\n从数组最后一位到第一位进行遍历, 每次与 k % 10 和 carry 相加, carry = k // 10\n\n每次加完 i 往前退一位, k // 10\n\n所有数组里的数加完有两种情况\n\n1. k 还有剩余\n2. carry 还有剩余\n\n因为 carry 也是加在 k 的最后一位, 所以 k = k + carry 一起处理\n\n每次向数组前面添加 k % 10, 之后 k 取 k // 10\n\n### 代码\n\n```python\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        carry = 0\n        # reverse loop through num and add with each digit of k\n        for i in range(len(num) - 1, -1, -1):\n            val = carry + num[i] + k % 10\n            carry, num[i] = val // 10, val % 10\n            k = k // 10\n        \n        # if there's carry or k left need to add to front of array\n        k = carry + k\n        \n        while k > 0:\n            num = [k % 10] + num\n            k = k // 10\n\n        return num\n```\n\n\n\n### 复杂度\n\n时间复杂度: O(n) 遍历数组\n\n空间复杂度: O(1) 不使用额外空间\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917332667","body":"## 思路\n\n先建立 output 数组所有值为最大值 n\n\n正向遍历一次, 每次遇到 c 更新 l 的值为 c 的位置, 如果左边有 c 的话就更新 output 的值为 i - l 即为跟距离最靠近的左边的 c 的距离\n\n反向遍历一次, 每次遇到 c 更新 r 的值为 c 的位置, 如果右边有 c 点话就更新 output 为 min(output, r - j)\n\n## 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n        n = len(s)\n        output = [n for _ in range(n)]\n\n        # forward pass the string s and calculate the distance based on the closest characater c on the left of each item\n        l = None\n        for i, w in enumerate(s):\n            if w == c:\n                output[i] = 0\n                l = i\n            else:\n                if l is not None:\n                    output[i] = i-l\n\n        # backward pass the stirng s and calculate the distance based on closest character c on the right of each item\n        r = None\n        for j in range(n-1, -1, -1):\n            w = s[j]\n            if w == c:\n                output[j] = 0\n                r = j\n            else:\n                if r is not None:\n                    output[j] = min(output[j], r-j)\n\n        return output\n```\n\n## 复杂度\n\n时间复杂度: O(n) 两次遍历都是 O(n) 时间复杂度\n\n空间复杂度: O(1) 常数级空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917513194","body":"## 思路\n\n用一个 list 来模拟栈, 同一个 size variable 来记录现在的 size 大小, 用一个 maxSize 来记录最大的size 大小, 用一个 increments 数组来记录 increments\n\nincrements 数组当有一个increment时, 记录在最右边的元素对应的increment数组中, 利用了stack从右向左 pop 的特性, 所以虽然 increment 的是底部 k 元素, 第一个 pop 的肯定是这些元素中最靠右的元素\n\n当这个元素被 pop 时, 先把 increment 和这个元素本身相加, 然后把 increment 传递给左边一个元素\n\n### push\n\n如果小于 max size, 那么就 self.stack 加入元素 x, self.increments 加入0, self.size + 1\n\n### pop\n\n如果 self.size 是 0 代表 stack 为空, return -1\n\n否则 将 self.size - 1, 然后 pop 最后一个 increments 数组里的元素\n\n如果 size 还是 > 0, 代表左边还有要被 increment 的元素, 把 increment 加到 increments[self.size-1] 的位置\n\n返回 self.stack.pop() + increment, 即这个数和increment的和\n\n### increment\n\n赋值 increment 给 increments 数组里下标为 min(k-1, self.size-1) 的index里\n\n不需要给前面每个都赋值, 利用了 stack 从右向左 pop 的特性, 每次 increment 被pop之后, 再将值向左传递即可\n\n## 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.size = 0\n        self.maxSize = maxSize\n        self.increments = []\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.stack.append(x)\n            self.increments.append(0)\n            self.size += 1\n\n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n        else:\n            self.size -= 1\n            increment = self.increments.pop()\n            if self.size > 0:\n                self.increments[self.size-1] += increment\n            return self.stack.pop() + increment\n        \n\n    def increment(self, k: int, val: int) -> None:\n        if self.size > 0:\n            self.increments[min(k-1, self.size-1)] += val\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## 复杂度\n\n时间复杂度: O(1) \n\n空间复杂度: O(size / N) 额外空间是 self.stack 和 self.increments 相同大小, size 为 size 最大的大小, N 为操作数, 小于等于 maxSize","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ForLittleBeauty":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916622948","body":"## 思路\n\n***\n\n将给定的list反转后遍历，遍历的每一位与k的最低位，进位数相加，记录进位，并把个位加入最终的结果数组。之后更新k。有两种情况：\n\n- list遍历完了k还有值，那么后面继续把k没用完的位数加入结果数组，这样总体时间复杂度由logk决定\n- k先到0，list还没遍历完，那么其实继续遍历list，并不需要做任何处理，因为k一直是0，相当于每次把list新的一位添加到最终结果数组后面\n\n最后判断一下进位数是否还有值即可。\n\n***\n\n## 代码\n\n***\n\n\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        result = []\n        carry = 0\n        for digit in num[::-1]:\n            temp = digit+k%10+carry\n            k=k//10 #下一轮的k值\n            carry = temp//10 #下一轮的进位\n            temp = temp%10 #当前这一位数\n            result.append(temp)\n\n        #如果k还没耗尽的话\n        while k>0:\n            temp = k%10+carry\n            k=k//10\n            carry = temp//10\n            temp = temp%10\n            result.append(temp)\n        \n        #如果进位值还没耗尽的话\n        if carry>0:\n            result.append(carry)\n        \n        return result[::-1]\n```\n\n\n\n***\n\n时间复杂度: O(max(logk,n))\n\n空间复杂度: O(1)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917416500","body":"## 思路\n\n***\n\n在每一个位置，可能存在一个左边的c，也可能存在一个右边的，那么先从左到右遍历一次，记录左边c与当前位置的距离，再从右到左遍历一次，记录右边c和左边c距离当前位置更近的距离\n\n***\n\n## 代码\n\n***\n\n\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans=[]\n        prev = -float('inf')\n        for i in range(len(s)):\n            if s[i]==c:\n                prev=i\n            ans.append(i-prev)\n        prev = float('inf')\n        for i in range(len(s)-1,-1,-1):\n            if s[i]==c:\n                prev=i\n            ans[i] = min(prev-i,ans[i])\n        return ans\n```\n\n\n\n***\n\n时间复杂度: O(n)\n\n空间复杂度: O(1)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917656146","body":"## 思路\n\n***\n\n总体思路，初始化的时候创建两个数组，分别用来表示栈和值累加数组，使用top指针来指示当前栈顶元素。\n\n- push操作：当top指针比最大容量小的时候，右移指针，插入值\n- inc操作：取k与top中较小的那一个位置，把value添加到add数组里\n- pop操作：当前返回的是值，是栈顶元素加上add数组中的顶部元素的值。如果此时栈中还有元素，那么add[top-1]需要累积上add[top]的值\n\n***\n\n## 代码\n\n***\n\n\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = [0]*maxSize\n        self.add = [0]*maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top<len(self.stack)-1:\n            self.top+=1\n            self.stack[self.top] = x\n\n    def pop(self) -> int:\n        if self.top <= -1:\n            return -1\n        result = self.stack[self.top] + self.add[self.top]\n        #积累值转移\n        if self.top != 0:\n            self.add[self.top - 1] += self.add[self.top]\n        self.add[self.top] = 0\n        self.top -= 1\n        return result\n\n\n    def increment(self, k: int, val: int) -> None:\n        minNum = min(k - 1, self.top)\n        if minNum >= 0:\n            self.add[minNum] += val\n```\n\n\n\n***\n\n时间复杂度: O(1)\n\n空间复杂度: O(n)\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"septasset":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916623473","body":"### **思路**\n\n1. 观察到A最大为10^10000,远超出long上限，因此不可把A转成数字后与k相加再写入结果数组\n2. 模拟手算，使用carry进位\n\n### **关键点**\n\n1. 从整数k中取出倒数第i位数字: k % (int)Math.pow(10, (i+1)) / (int)Math.pow(10, i)\n2. 循环次数取决于A,k中较大数的位数\n\n### **代码(Java)**\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> sumList = new LinkedList<Integer>();\n    Boolean carry = false;\n    int noDigits = Math.max(num.length, Integer.toString(k).length());\n    for (int i = 0; i<noDigits; ++i){\n        int k_digit = k % (int)Math.pow(10, (i+1)) / (int)Math.pow(10, i);\n        int num_digit = i<=num.length-1? num[num.length-1-i]:0;\n\n        int res = carry? k_digit + num_digit + 1 : k_digit + num_digit;\n        if (res>9){\n            res = res - 10;\n            carry = true;\n        }else{\n            carry = false;\n        }\n        sumList.add(0, res);\n    }\n    if (carry) sumList.add(0, 1);\n    return sumList;\n\n}\n```\n\n### **复杂度分析**\n\nm,n为A,k的位数时:\n\n- 时间：O（max(m,n)）\n- 空间：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917381556","body":"### **思路**\n\n1. 遍历字符串s, 记录所有的c出现的位置\n2. 遍历ans数组，计算最近距离有3种情况\n\n### **关键点**\n\n### **代码(Java)**\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        \n        List<Integer> occ = new ArrayList<Integer>();        \n        for (int i = 0; i<s.length(); ++i){\n            if (s.charAt(i)==c) occ.add(i);\n        }\n        \n        int leftInd = 0;\n        for (int j = 0; j<s.length(); ++j){\n            if (j<=occ.get(0)) ans[j] = occ.get(0)-j;\n            else if (j>=occ.get(occ.size()-1)) ans[j] = j-occ.get(occ.size()-1);\n            else{\n                int mi = (occ.get(leftInd) + occ.get(leftInd+1))/2;\n                if (j<=mi) ans[j] = j-occ.get(leftInd);\n                else ans[j] = occ.get(leftInd+1)-j;\n                \n                if (j==occ.get(leftInd+1)) leftInd++;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n### **复杂度分析**\n\n- 时间：O（n）\n- 空间：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917640170","body":"## Day 3\n\n### **思路**\n\n1. stack不记录单个元素，记录前缀和\n2. 记录increment信息，只在pop时使用和更新\n\n### **关键点**\n\n### **代码(Java)**\n\n```java\nclass CustomStack {\n    List<Integer> stack; // stack_pre\n    int maxCap;\n    int currSize;\n    \n    List<Integer> incNum;\n    List<Integer> incVal;\n    \n    public CustomStack(int maxSize) {\n        stack = new ArrayList<Integer>(maxSize);\n        maxCap = maxSize;\n        currSize = 0;\n        \n        incNum = new ArrayList<Integer>();\n        incVal = new ArrayList<Integer>();\n    }\n    \n    public void push(int x) {\n        if (currSize>=maxCap) return;\n        else {\n            if (currSize>=1) {                \n                stack.add(stack.get(currSize-1)+x);\n            }else {\n                stack.add(x);\n            }            \n            currSize++;\n        }\n    }\n    \n    public int pop() {\n        if (currSize<=0) return -1;\n        else {\n            int ele;\n            if (currSize>=2) ele = stack.get(currSize-1)-stack.get(currSize-2);\n            else ele = stack.get(currSize-1);\n            // compute ele with inc\n            for (int i =0; i<incNum.size(); ++i){\n                // System.out.println(ele);\n                if (currSize <= incNum.get(i)) {\n                   ele+= incVal.get(i);\n                   incNum.set(i, incNum.get(i)-1);\n                }\n            }\n            stack.remove(--currSize);\n            return ele;\n        }\n    }\n    \n    public void increment(int k, int val) {\n        incNum.add(Math.min(k, currSize));\n        incVal.add(val);\n    }\n}\n```\n\n### **复杂度分析**\n\n- 时间：push和increment为O（1），pop为O(increment次数)\n- 空间：O(increment次数)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DoubleW2w":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916623658","body":"## 思路\n\n1. 当前位 = `(carry + a + b) % 10` \n2. 进位处理： 当前位 % 10\n3. 调整： `k /= 10`  \n4. 最后要判断是否还有进位  `215 + 806 = 1021`  多了一位  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new ArrayList<>();\n        int i = num.length - 1;\n        int carry = 0, sum = 0;\n        while(i>=0 || k > 0){\n            int a = i>=0 ? num[i] : 0;\n            int b = k!=0 ? k%10: 0;\n\n            //得到和\n            sum = carry + a + b;\n\n            //得到进位\n            carry = sum / 10;\n\n            //得到当前位\n            sum %= 10;\n\n            //调整两个加数\n            k /= 10;\n            i--;\n            ans.add(sum);\n        }\n        if(carry != 0) ans.add(carry);\n        Collections.reverse(ans);\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(max(n,logk))\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917428816","body":"## 思路1:\n\n- 遍历一次字符串，用一个动态数组记录 `c` 在 字符串 `s` 出现的位置。\n- 遍历一次字符串，比较距离\n\n## 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] answer = new int[n];\n        List<Integer> list = new ArrayList<>();\n        int index = 0;\n        for(int i = 0; i < n; i++){\n            if(s.charAt(i) == c) list.add(i);\n        }\n        for(int i = 0; i < n;i++){\n            //index 没到list的末尾  并且 下标i到list.get(index)的距离 > 下标到list.get(index+1) \n            //取后者距离\n            if(index < list.size() - 1 && Math.abs( list.get(index) - i ) > Math.abs( list.get(index+1) - i)){\n                index++;\n            }\n            answer[i] = Math.abs(list.get(index) - i);\n        }\n        return answer;\n    }\n}\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$，两次遍历数组，都是$O(n)$\n- 空间复杂度：$O(n)$，在最坏的情况下，`list` 会存放 `n` 个元素","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"WeilanTao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916628293","body":"### 989 Easy\n\n### 思路\n\n这道题是一个模拟计算的题目。首先想到用一个变量carry来记录进位。获得个位：n%10；获得其他：n/0\n\n用一个while loop 遍历所有--只要`carry` 或 `num[]`或 `k` 没有用完， while loop 就对 carry 进行迭代, 并将此次迭代结果的个位存入结果集合`res`。\n\n在 Java 集合中选择 LinkedList 来储存结果，因为 Java 中 `LinkedList` 提供了接口 `addFirst()`。 LinkedList 在头尾插入复杂度都是O(1)。 若采用ArrayList 则需要调用接口`add(0, nums[i])` 或`Collections.reverse()` ； 相比之下都会降低性能。\n\n### 代码 Java\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        \n        int carry = 0;\n        \n        int len = num.length;\n        int i  =len-1;\n\n        LinkedList<Integer> res = new LinkedList<>();\n        \n        while(carry != 0  || k > 0 || i >= 0 ){\n         \n            if(i>=0){\n                carry += num[i];\n                i--;\n            }\n            \n            if(k>0){\n                int a = k%10;\n                carry+=a;\n                k=(k-a)/10;\n            }\n            \n            res.addFirst(carry % 10);\n            carry = carry/10;\n\n        }\n        \n        return res;\n    }\n}\n```\n\nRuntime: 2 ms, faster than 99.68% of Java online submissions for Add to Array-Form of Integer.\n\nMemory Usage: 41.2 MB, less than 35.41% of Java online submissions for Add to Array-Form of Integer.\n\n### 复杂度分析\n\n时间复杂度：O(max(nums[], k)+1) =>O(n)\n\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917345912","body":"### 821. Shortest Distance to a Character Easy\n\n### Idea\n\nThe basic idea of this problem is to find closest matching character `c` at the left and the right of the characters in the string. To do so, we scan the string from the left to right to find the left match; and scan from the right to left to find the right match. We will use pointer `p` to record the latest position update of `c` ; so the distance will be |i-p|. If any right match gives a smaller distance, then the record in the result array will be overwritten by the smaller one.\n\nCorner case: Either scanning from left to right or from right to left can encounter the case that left/right side doesn't have the matching character.\n\n* left side: \n  * When scanning from left to right and when no `c` occurs, the pointer `p` is set as `-s.length()`; so it means no matching character is at the left side and the recorded distance will be big enough to be overwritten by the matching at the right side.\n  * When scanning from right to left, \n    * if there is a matching character at the end of the string, then the pointer is already there as the result of the left-to-right scan. In this case the distance will be `p -  i`;\n    * If there is no matching character at the end of the string, then  `i - p` is negative in this case, which indicates the absence of the right matching. However, the absolute value of `p - i` equals `i - p`, so if we take absolute value, then there no chance for the left match to be overwritten in this case.\n    * So when it is scanning from right to left, we measure the distance by the absolute value.\n\n### Code  Java\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int p = -len;\n        int res[] =  new int[len];\n        \n        for(int i =0; i < len; i++){\n            if(s.charAt(i)==c){\n                p = i;\n            }\n    \n            res[i] = i - p;\n        }\n        \n        \n        for(int i = len-1; i >= 0; i--){\n            if(s.charAt(i) == c){\n                p = i;\n            }    \n            res[i] = Math.min(res[i], Math.abs(p - i));\n        }\n        \n        return res;\n    }\n}\n```\n\n\n\n### Complexity\n\nTime complexity: O(n)\n\nSpace complexity: O(n)\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917544535","body":"### 1381 Design a Stack With Increment Operation Medium\n\n### Idea\n\nTo construct a stack, we only manipulate top element in the stack as it's a FILO; plus the size of the stack is fixed in this question, so no worry about the overflow of the stack. Therefore, array is a good fit in this question. If we use LinkedList, we can also implement the same functionalities; but LinkedList will be a little bit slower than array in accessing adjacent elements, because LinkedList doesn't address memory consecutively in heap.\n\n### Code Java\n\n```java\nclass CustomStack {\n    private int size;\n    private int capacity;\n    private int [] stack;\n    \n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        size = -1;\n        capacity = maxSize - 1;\n    }\n    \n    public void push(int x) {\n        if(size >= capacity)\n            return;\n        \n        size++;\n        stack[size] = x;\n        \n    }\n    \n    public int pop() {\n        if(size < 0)\n            return -1;\n        int a = stack[size];\n        stack[size]=0;\n        size--;\n        return a;\n    }\n    \n    public void increment(int k, int val) {\n        int i = 0;\n        while(i <= size && i < k){\n            stack[i] += val;\n            i++;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\nRuntime: 5 ms, faster than 69.59% of Java online submissions for Design a Stack With Increment Operation.\n\nMemory Usage: 39.7 MB, less than 69.54% of Java online submissions for Design a Stack With Increment Operation.\n\n### Complexity\n\n* Time Complexity\n\n  ​\t`push(int x)`: O(1)\n\n  ​\t`pop()`: O(1)\n\n  ​\t`increment(int k, int val)`: O(n)\n\n* Space Complexity\n\n  ​\tO(n) for the array\n\n  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917804434","body":"### 394  Decode String Medium\n\n### Idea\n\nIn this question, the encoded string is composed by two parts: string cascading and sub-string in the brackets.\n\n* To cascade a string, use a while loop to scan all the components in the input s and use a `StringBuilder` to record all the decoded part.\n\n* To properly decode the sub-string in the bracket, we use a recursion that keep decoding the inner brackets and finally return a decoded sub-string. Then duplicate the decoded-substring according to the leading number.\n* Use stack to locate the matching open bracket and close bracket. \n* The Java API involved:\n  *  `s.indexOf(char c, int i )` find the index of `c` in a string stating from the index `i` \n  * `s.substring(int s, int e)` s is included; e is excluded\n  * `Integer.parseInt(str s)` convert a string to int \n\n### Code\n\n```java\nclass Solution {  \n    public String decodeString(String s) {\n        StringBuilder sb  = new StringBuilder();\n        int len = s.length();\n\n        int i = 0;\n        while(i < len){\n            char c = s.charAt(i);\n            if(c-'a' >= 0 && c-'z' <= 0){\n                sb.append(c);\n                i++;\n            }else if(c-'0' >= 0 && c -'9' <= 0){\n                //find the first open bracket\n                int strt =  s.indexOf(\"[\",i);\n                int end = findEnd(strt, len, s);\n                String mids= s.substring(strt+1, end);\n                String subs = decodeString(mids);\n                \n                //find the number\n                String numstr = s.substring(i,strt);\n                int num = Integer.parseInt(numstr);\n                \n                for(int j = 0; j < num ;j++){\n                    sb.append(subs);\n                }\n                i = end+1;\n            }\n        }\n           \n        return sb.toString();\n    }\n    \n    private int findEnd(int strt, int len, String s){\n        Deque<Character> brkt = new ArrayDeque<>();\n        brkt.push(s.charAt(strt));\n        for(int i = strt+1; i <= len ; i++){\n            char c = s.charAt(i);\n            if(c == '[')\n                brkt.push(c);\n            else if( c == ']')\n                brkt.pop();\n            \n            if(brkt.peek() == null)\n                return i;\n        }\n        return -1;\n    }\n}\n```\n\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Decode String.\n\nMemory Usage: 36.9 MB, less than 84.66% of Java online submissions for Decode String.\n\n### Complexity\n\nTime: O(N) \n\nSpace: O(N) for the stack \n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kennyxcao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916629214","body":"# 989. Add to Array-Form of Integer\r\n\r\n## Intuition\r\n\r\n1. Start from least significant digit in num and current sum as k.\r\n2. Compute digit sum at each position from right to left.\r\n3. Push least significant digit to the answer array.\r\n4. Shift current sum to right by 1 position.\r\n5. Repeat until all digits in both num and k are processed.\r\n6. Reverse the answer array for the final output.\r\n\r\n## Code\r\n\r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nconst addToArrayForm = function(num, k) {\r\n  const n = num.length;\r\n  const ans = [];\r\n  let curr = k;\r\n  let i = n - 1;\r\n  while (i >= 0 || curr > 0) {\r\n    if (i >= 0) {\r\n      curr += num[i];\r\n    }\r\n    ans.push(curr % 10);\r\n    curr = ~~(curr / 10);\r\n    i -= 1;\r\n  }\r\n  return ans.reverse();\r\n};\r\n```\r\n\r\n## Complexity Analysis\r\n\r\n- Time: O(max(N, K))\r\n- Space: O(max(N, K)) for answer array\r\n- N = len(num)\r\n- K = len(k)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917334975","body":"# 821. Shortest Distance to a Character\n\n## Intuition\n\nTwo Pass\n\n1. Iterate from left to right.\n    - Record the distance to the closest *c* on the left side.\n2. Iterate from right to left.\n    - Record the distance to the closest *c* on the right side.\n    - Only update the answer array if closest right is closer than closest left.\n\n## Code\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nconst shortestToChar = function(s, c) {\n  const n = s.length;\n  const ans = [];\n  let prev = -Infinity;\n  for (let i = 0; i < n; i++) { // left to right\n    if (s[i] === c) prev = i;\n    ans[i] = i - prev;\n  }\n  prev = Infinity;\n  for (let i = n - 1; i >= 0; i--) { // right to left\n    if (s[i] === c) prev = i;\n    ans[i] = Math.min(ans[i], prev - i);\n  }\n  return ans;\n};\n```\n\n## Complexity Analysis\n\n- Time: O(N)\n- Space: O(N) for answer array\n- N = len(s)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917542773","body":"# 1381. Design a Stack With Increment Operation\n\n## Intuition\n\n- Use array to simulate stack operations\n\n## Code\n\n```javascript\nclass CustomStack {\n  /**\n   * @param {number} maxSize\n   */\n  constructor(maxSize) { // Time: O(1)\n    this.maxSize = maxSize;\n    this.stack = [];\n  }\n\n  /** \n   * @param {number} x\n   * @return {void}\n   */\n  push(x) { // Time: O(1)\n    if (this.stack.length < this.maxSize) {\n      this.stack.push(x);\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  pop() { // Time: O(1)\n    return this.stack.length === 0 ? -1 : this.stack.pop();\n  }\n\n  /** \n   * @param {number} k\n   * @param {number} val\n   * @return {void}\n   */\n  increment(k, val) { // Time: O(n)\n    const limit = Math.min(k, this.stack.length);\n    for (let i = 0; i < limit; i++) {\n      this.stack[i] += val;\n    }\n  }\n}\n```\n\n## Complexity Analysis\n\n- Time\n  - constructor: O(1)\n  - push: O(1) amortized\n  - pop: O(1) amortized\n  - increment: O(min(k, maxSize))\n- Space: O(maxSize) for max stack size\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917732544","body":"# 394. Decode String\n\n## Intuition\n\n- Use stack to keep track of each level of repeated encoded_string\n\n## Code\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nconst decodeString = function(s) {\n  const stack = [];\n  let str = '';\n  let num = 0;\n  for (const char of s) {\n    if (/\\d/.test(char)) { // if char is a digit\n      num = num * 10 + parseInt(char, 10);\n    } else if (char === '[') { // save current outer level info and reset for inner level\n      stack.push([num, str]);\n      num = 0;\n      str = '';\n    } else if (char === ']') { // retrieve outer level count and repeat the inner str\n      const [count, outerStr] = stack.pop();\n      str = outerStr + str.repeat(count);\n    } else { // char is a letter\n      str += char;\n    }\n  }\n  return str;\n};\n```\n\n## Complexity Analysis\n\n- Time: O(maxK * n)\n- Space: O(sum(avgK * n))\n- maxK = max k within k[encoded_string] patterns in s\n- n = len(encoded_string)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james20141606":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916632276","body":"# Day 1 989. Add to Array-Form of Integer\n\n- Problem Link\n  - [989. Add to Array-Form of Integer](https://leetcode.com/problems/add-to-array-form-of-integer/submissions/)\n  - Other useful links:\n\n\n- Ideas\n  - convert list to string, then to int, add with k, convert back to list. \n- Complexity: \n  - Time: O(num.length)\n  - Space: O(num.length)\n\n- Code\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num_str = ''.join([str(i) for i in num])\n        sum = int(num_str) + k\n        return [int(i) for i in str(sum)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917325775","body":"# Day 2 821. Shortest Distance to a Character\n\n- Problem Link\n  - [821. Shortest Distance to a Character](https://leetcode.com/problems/shortest-distance-to-a-character/submissions/)\n  - Other useful links:\n\n- Ideas\n  - Start from both sides, initiate position index as -len(s), iterate each character in s, update the position index if the character matches c, take absolute diff to find the closest from both sides and choose the smaller one as result.\n\n- Complexity: \n  - Time: O(s.length)\n  - Space: O(s.length)\n\n- Code\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str):\n        result = []\n        #start from left\n        loc = - len(s)\n        for i in range(len(s)):\n            if s[i] ==c:\n                loc = i\n            result.append(i-loc)\n        #then start from right\n        for i in range(len(s))[::-1]:\n            if s[i] ==c:\n                loc = i\n            result[i] = min(result[i], abs(i - loc))\n        return result\n```\n\n- other resources:","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917796351","body":"# Day 4 394. Decode String\n\n- Problem Link\n  - [394. Decode String](https://leetcode.com/problems/decode-string/)\n  - Other useful links:\n\n- Ideas\n  -  ideas are from [official solution](https://leetcode-solution.cn/solutionDetail?type=3&id=4&max_id=2). We could use stack to store the information before the first ']'. When we meet the first ']' we will get the string before it, then get all the numbers before the string. \n  -  Note the += might cause error since it is reversed order. and not that `stack[-1] != '[':` is required to avoid [ in the string.\n\n- Complexity: \n  - Time: O(len(decoded_string))\n  - Space:  O(len(decoded_string))\n\n- Code\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c ==']':\n                string_to_repeat = ''\n                repeat_times = ''\n                while stack and stack[-1] != '[':\n                    string_to_repeat  =stack.pop() + string_to_repeat\n                stack.pop()  #pop out [\n                while stack and stack[-1].isnumeric():\n                    repeat_times  = stack.pop() + repeat_times\n                stack.append(string_to_repeat * int(repeat_times))\n            else:\n                stack.append(c)\n        return ''.join(stack)\n```\n\n- other resources:\n  - [official solution](https://leetcode-solution.cn/solutionDetail?type=3&id=4&max_id=2)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"muimi":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916632424","body":"### 思路\n从后向前（从个位开始）遍历数组num，依次和K相加。\n\n相加的结果：个位数部分（取余）保存在返回结果里；十位之上部分（取模）作为新的K。\n\n当数组全部遍历之后，K不等于0时，将K的每一位插入结果的头部。\n\n生成结果时，每次插入都是0号位，使用LinkedList而不是ArrayList是为了获得更好的插入效率。\n\n### 代码\n\n```java\nclass Solution {\n  public List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> res = new LinkedList<>();\n    for (int i = num.length - 1; i >= 0; i--) {\n      res.add(0, (num[i] + k) % 10);\n      k = (num[i] + k) / 10;\n    }\n    while (k > 0) {\n      res.add(0, k % 10);\n      k /= 10;\n    }\n    return res;\n  }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N), 确切地说是max(N, log10(K))\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917343936","body":"### 思路\n\n求解最小路径可以抽象成， MIN（与左侧c的距离，与右侧c的距离）\n\n- 第一遍从左向右遍历，生成每个元素与左侧c的距离\n  - 当没有遇到c时，表示左侧没有c，赋予一个超过最大距离length的值\n- 第二遍从右向左遍历，生成每个元素与右侧c的距离，并与第一遍生成的左侧c距离比较，取最小值。\n  - 第一遍遍历之后，pos保存数组最后一个c的位置\n  - pos之后的元素的右侧不存在c，所以这次遍历只需要从pos-1开始\n\n### 代码\n\n````java\nclass Solution {\n  public int[] shortestToChar(String s, char c) {\n    int length = s.length();\n    int[] res = new int[length];\n    int pos = -length;\n    for (int i = 0; i < length; i++) {\n      if (s.charAt(i) == c) pos = i;\n      res[i] = i - pos;\n    }\n    // e.g.\n    // before loop: [length, length, 0, 1, 2, 3(pos-1), 0(pos), 1, 2]\n    // after  loop: [     2,      1, 0, 1, 2, 1       , 0     , 1, 2]\n    for (int i = pos - 1; i >= 0; i--) {\n      if (s.charAt(i) == c) pos = i;\n      res[i] = Math.min(res[i], pos - i);\n    }\n    return res;\n  }\n}\n````\n\n### 复杂度分析\n\n- 时间复杂度：O(N)，两次循环\n- 空间复杂度：O(1)，返回变量之外，没有额外使用空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917595876","body":"### 思路\n使用数组作为底层数据结构实现一个栈\n\n### 代码\n\n````java\n\nclass CustomStack {\n  int[] stack;\n  int count;\n  public CustomStack(int maxSize) {\n    stack = new int[maxSize];\n\t\tcount = 0;\n  }\n  \n  public void push(int x) {\n    if (count < stack.length) stack[count++] = x;\n  }\n  \n  public int pop() {\n    if (count == 0) return -1;\n    return stack[--count];\n  }\n  \n  public void increment(int k, int val) {\n    int temp = Math.min(k, count);\n    for (int i = 0; i < temp; i++) {\n      stack[i] += val;\n    }\n  }\n}\n\n````\n\n### 复杂度\n- 时间复杂度： push是O(1)，pop是O(1)，increment是O(N)\n- 空间复杂度： O(1),没有使用额外的空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Mahalasu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916633989","body":"### 思路\r\n从后往前遍历，每一位都和k相加取个位，其他位继续与更前面的数字相加。如果遍历一边之后k仍大于0，说明所得结果位数大于num的长度，则将k中所有位的数字变成一个新的数组然后与num进行连接合并。\r\n\r\n##\r\n```py\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        for idx in range(len(num) - 1, -1, -1):\r\n            temp = num[idx] + k\r\n            k = temp // 10\r\n            num[idx] = temp % 10\r\n        \r\n        if k:\r\n            return [int(i) for i in str(k)] + num\r\n        else:\r\n            return num\r\n```\r\n##\r\nTime: O(max(n, k))\r\nSpace: O(max(n, k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917257431","body":"## 思路\r\n\r\n### Naive Way\r\n\r\n遍历一遍找出所有的c所在的地方，然后遍历第二遍，将每一个字母与所有c所在的位置进行位置计算，取最短的一个\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        places = []\r\n        result = [float('inf') for _ in range(len(s))]\r\n        \r\n        for idx in range(len(s)):\r\n            if s[idx] == c:\r\n                places.append(idx)\r\n        \r\n        for idx in range(len(s)):\r\n            for cidx in places:\r\n                dist = abs(idx - cidx)\r\n                if abs(idx - cidx) < result[idx]:\r\n                    result[idx] = dist\r\n        \r\n        return result\r\n```\r\n\r\nT：O(MN)\r\nS：O(M)\r\nN为s长度，M为c所在的所有位置的个数\r\n##\r\n\r\n### 正序倒序遍历\r\n\r\n正序遍历得到每个位置到其左侧最近位置的距离，然后倒序遍历得到每个位置到其右侧最近位置的距离\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        length, pos = len(s), float('inf')\r\n        result = [length] * length\r\n        \r\n        for i in list(range(length)) + list(range(length)[::-1]):\r\n            if s[i] == c:\r\n                pos = i\r\n            result[i] = min(result[i], abs(i - pos))\r\n        \r\n        return result\r\n```\r\n\r\nT: O(N)\r\nS: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917572192","body":"### 思路\r\n\r\n用另一个数组来记录需要增加的栈的最高位置和增加的量，在每次pop出的时候加上该量并传递给前一个量。\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n        self.inc = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n            self.inc.append(0)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        if not self.inc:\r\n            return -1\r\n        if len(self.inc) > 1:\r\n            self.inc[-2] += self.inc[-1]\r\n        return self.stack.pop() + self.inc.pop()\r\n        \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.inc:\r\n            self.inc[min(k, len(self.stack)) - 1] += val\r\n```\r\n\r\nT: O(1)\r\nS: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZETAVI":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916634607","body":"## 思路\r\n\r\n从Num数组的**右侧开始往左遍历**数组,将遍历到的数**直接与K相加**,相加的结果取**最低位**插入到List输出链表的**头部**\r\n\r\n## 语言\r\n\r\nJava\r\n\r\n## 代码\r\n\r\n```java\r\npublic class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new LinkedList<>();\r\n        int i;\r\n        for (i = num.length - 1; k > 0 || i >= 0; k /= 10, i--) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            list.add(0, k % 10);\r\n        }\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度:\t$O(max(num.length(),logK))$\r\n\r\n​\t\t\t\t\t\t\t时间复杂度跟输入Num的长度和K的位数有关,又因为List的插入时间复杂度为$O(1)$所以插入可以忽略不计.\r\n\r\n- 额外空间复杂度: $O(1)$\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917370148","body":"## 思路(法一)\r\n\r\n利用库函数**indexOf(c)**来找到**后一个出现字母的位置**,比较前一个出现和后一个出现的距离,取最小值\r\n\r\n## 语言\r\n\r\nJava\r\n\r\n## 代码\r\n\r\n```java\r\npublic class Solution {\r\n   public int[] shortestToChar_1(String s, char c) {\r\n        int[] ans = new int[s.length()];\r\n        int fir = -1, sec = Integer.MAX_VALUE / 2, cur = 0;\r\n        fir = s.indexOf(c);\r\n        for (int i = 0; i < ans.length; i++) {\r\n            if (fir > i) {\r\n                ans[i] = fir - i;\r\n            } else if (fir == i) {\r\n                ans[i] = 0;\r\n                sec = s.indexOf(c, fir + 1) == -1 ? Integer.MAX_VALUE / 2 : s.indexOf(c, fir + 1);\r\n            } else if (i < sec) {\r\n                ans[i] = Math.min(Math.abs(fir - i), Math.abs(sec - i));\r\n            } else {\r\n                ans[i] = 0;\r\n                fir = sec;\r\n                sec = s.indexOf(c, fir + 1) == -1 ? Integer.MAX_VALUE / 2 : s.indexOf(c, fir + 1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度:\t$O(N^2)$\r\n\r\n​\t\t\t\t\t\t\t因为String类中indexOf()方法是暴力匹配方法时间复杂度为$O(N*M)$,而我们这里M=1,所以综上总的时间复杂度为$O(N^2)$\r\n\r\n- 额外空间复杂度: $O(N)$\r\n\r\n## 思路(法二)\r\n\r\n对于每个字符 S[i]，通过**顺序遍历和逆序遍历两次**,试图找出距离向左和向右下一个字符 C 的距离。答案就是这两个值的较小值。\r\n\r\n## 语言\r\n\r\nJava\r\n\r\n## 代码\r\n\r\n```java\r\npublic class Solution {\r\n    public int[] shortestToChar_2(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        //假设上一个出现的位置为Integer.MIN_VALUE / 2\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        //记录s[i]与前一个字符c的距离\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        //假设最后一个出现的位置为Integer.MAX_VALUE / 2\r\n        prev = Integer.MAX_VALUE / 2;\r\n\r\n        //计算s[i]与后一个字符c的距离,与原来的距离比较取最小值\r\n        for (int i = N - 1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度:\t$O(N)$\r\n\r\n- 额外空间复杂度: $O(N)$\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917657010","body":"## 思路(法一)\r\n\r\n用数组arr和一个变量top来模拟实现栈\r\n\r\n## 语言\r\n\r\njava\r\n\r\n## 代码\r\n\r\n```java\r\npublic class CustomStack {\r\n    private int[] arr;\r\n    private int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        arr=new int[maxSize];\r\n        top=-1;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (top < arr.length-1 ) {\r\n            arr[++top]=x;\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if (top >= 0) {\r\n            return arr[top--];\r\n        }return -1;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int end= Math.min(k, top + 1);\r\n        for (int i = 0; i < end; i++) {\r\n            arr[i]+=val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度:CustomStack(),push(),pop()都为$O(1)$, 但是increment()时间复杂度为$O(k)$\r\n- 空间复杂度:$O(maxSize)$\r\n\r\n\r\n\r\n## 思路(法二)\r\n\r\n同样用数组来模拟实现栈,但是对increment()方法进行优化\r\n\r\n再用一个辅助数组add来记录increase的值, 利用==差分思想==, 在每次pop()时把add数组和原数组arr==相加输出==\r\n\r\n## 语言\r\n\r\njava\r\n\r\n## 代码\r\n\r\n```java\r\nclass CustomStack_PrefixSum {\r\n    private int[] arr;\r\n    private int[] add;\r\n    private int top;\r\n\r\n    public CustomStack_PrefixSum(int maxSize) {\r\n        arr=new int[maxSize];\r\n        add=new int[maxSize];\r\n        top=-1;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (top < arr.length-1 ) {\r\n            arr[++top]=x;\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if (top >= 0) {\r\n            int res=arr[top]+add[top];\r\n            if (top>=1){\r\n                add[top-1]+=add[top];\r\n            }\r\n            add[top--]=0;\r\n            return res;\r\n        }return -1;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int end= Math.min(k-1, top);\r\n        if (end>=0){\r\n            add[end]+=val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度:CustomStack(),push(),pop(), increment()时间复杂度为都为$O(1)$\r\n- 空间复杂度:$O(maxSize)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"crystallili":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916642169","body":"### 思路\n把k当作carry 从num的末位开始做加法（做余），不断update k（做除）做为新的carry。最后判断k是否为0，不是为0就用相同方法把k的值放到linkedlist中。\n### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new LinkedList<>();\n        for (int i = num.length-1; i>=0; i--) {\n            ans.add(0, (num[i]+k) % 10);\n            k = (num[i] + k) / 10;\n        }\n        while (k > 0) {\n            ans.add(0, k % 10);\n            k = k / 10;\n        }\n        return ans;\n    }\n}\n```\n### 复杂度\n- 空间只要生成linkedlist就行，所以是O(n)\n- 时间的话，因为一直insert在头部，所以每次是o(1), 做n次，所以也是o(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"benngfour":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916643778","body":"### 思路\r\n\r\n從 Array 尾部開始相加，然後計算剩下的；最後檢查 carryOver 的數字\r\n\r\n### 語言\r\n\r\nJavaScript\r\n\r\n### Code Solution\r\n\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    let result = [];\r\n    let carryOver = 0;\r\n    const arrK = k.toString().split('');\r\n    let numLen = num.length;\r\n    let kLen = arrK.length;\r\n    if (kLen >= numLen) {\r\n        for (let j = numLen - 1; j >= 0; j--) {\r\n                let kNum = Number(arrK[kLen - 1]);\r\n                let sum = kNum + num[j] + carryOver;\r\n                if (sum < 10) {\r\n                    result.push(sum);\r\n                    carryOver = 0;\r\n                } else {\r\n                    result.push(sum - 10);\r\n                    carryOver = 1;\r\n                }\r\n                kLen--;\r\n        }\r\n        for (let i = kLen - 1; i >= 0; i--) {\r\n            let kNum = Number(arrK[i]);\r\n            if (kNum + carryOver >= 10) {\r\n                result.push((kNum + carryOver) - 10);\r\n                carryOver = 1;\r\n            } else {\r\n                result.push(kNum + carryOver);\r\n                carryOver = 0;\r\n            }\r\n        }\r\n    } else {\r\n        for (let i = kLen - 1; i >= 0; i--) {\r\n            let kNum = Number(arrK[i]);\r\n                let sum = kNum + num[numLen - 1] + carryOver;\r\n                if (sum < 10) {\r\n                    result.push(sum);\r\n                    carryOver = 0;\r\n                } else {\r\n                    result.push(sum - 10);\r\n                    carryOver = 1;\r\n                }\r\n            numLen--;\r\n        }\r\n        for (let j = numLen - 1; j >= 0; j--) {\r\n            if (num[j] + carryOver >= 10) {\r\n                result.push((num[j] + carryOver) - 10);\r\n                carryOver = 1;\r\n            } else {\r\n                result.push(num[j] + carryOver);\r\n                carryOver = 0;\r\n            }\r\n        }\r\n\r\n    }\r\n    if (carryOver > 0) {\r\n        result.push(1);\r\n    }\r\n    return result.reverse();\r\n};\r\n```\r\n\r\n### 複雜度分析\r\n\r\n- 時間複雜度 O(N): 沒有 nested for loop， 時間取決於最大的那個 Array length\r\n- 空間複雜度 O(1): 只佔用 result array","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917425008","body":"### 思路\n\n先獲取 input 字符在 s 的所有 index，然後 loop over s 中的字符，計算最短距離，再放入 answer 中\n\n### 語言\n\nJavaScript\n\n### Code Solution\n\n```\nvar shortestToChar = function(s, c) {\n    let answer = [];\n    let idx = [];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === c) {\n            idx.push(i);\n        }\n    }\n    for (let j = 0; j < s.length; j++) {\n        let shortestIdx = s.length;\n        for (let k = 0; k < idx.length; k++) {\n            shortestIdx = Math.min(Math.abs(j - idx[k]), shortestIdx);\n        }\n        answer.push(shortestIdx);\n    }\n    return answer;\n};\n```\n\n### 複雜度分析\n\n- 時間複雜度 O(N^2): nested for loop\n- 空間複雜度 O(2): one answer array, one idx array","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ergwang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916643891","body":"### 思路\r\n\r\n1. 看到题首先想到，变成整数然后直接加再变成数组返回，然后觉得要数组—整数—数组，要遍历两次，肯定时间复杂度高，**倒是没想到整数超范围，看了大家评论才发现**\r\n2. 然后想到直接从末尾加，满十进位就行，准备开整，看了题目给的返回值类型是list，又给提醒了，数组直接进位会出现溢出的情况\r\n3. List搞起来，跑通了，发现还要逆序，用到了Collections.reverse(list);  成了（相当于又遍历了一次）。用时超过38%的人，肯定不完美\r\n4. 去评论区找到了LinkedList ，直接调用双向链表的addFirst，一次遍历出结果，舒服了。\r\n\r\n\r\n\r\n\r\n\r\n### 代码\r\n\r\n\r\n\r\n```java\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> list = new LinkedList<>();\r\n        int over;\r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            // 获取进位值\r\n            over = (num[i] + k) / 10;\r\n            // 得当当前位的值\r\n            num[i] = (num[i] + k) % 10;\r\n            k = over;\r\n            list.addFirst(num[i]);\r\n        }\r\n        // 数组遍历完了，可能进位值是大于0，甚至大于十、百、千，继续进位\r\n        while (k > 0){\r\n            list.addFirst(k % 10);\r\n            k = k / 10;\r\n        }\r\n        return list;\r\n    }\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**复杂度分析**\r\n\r\n—  时间复杂度：O(n)，其中n为数组长度。\r\n\r\n—  空间复杂度：O(n)，新建了一个链表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917413303","body":"### 思路\n\n1. 首先想到一次遍历就得到结果，顺势得出两个指针，一个指向当前元素的左边目标值，一个只想右边目标值，去较小的距离存入数组中，（没动手）\n2. 看了大家的评论，用的是正反遍历的办法，正向遍历获取每个元素距离右边的目标值的距离，反向获取每个元素距离左边目标值的距离，两者取小的存入数组\n\n\n\n\n\n### 代码\n\n\n\n```java\npublic static int[] shortestToChar(String s, char c) {\n        char[] chars = s.toCharArray();\n        int[] temp = new int[chars.length];\n        // 找到第一个目标字符的索引\n        int rightIndex = findRightIndex(c, 0, chars);\n\n        // 正向遍历生成每个字符距离右边最近目标的距离\n        for (int i = 0; i < s.length() - 1; i++) {\n            temp[i] = Math.abs(rightIndex - i);\n            if (chars[i] == c){\n                rightIndex = findRightIndex(c, i, chars);\n            }\n        }\n        // 最后一位没考虑\n        temp[s.length() - 1] = (s.length() - 1) - rightIndex;\n\n        // 同理，反方向再来一次取两次最小值\n        int leftIndex= findLeftIndex(c, s.length()-1, chars);\n        for (int i = s.length() - 1; i > 0; i--) {\n            temp[i] = Math.min(Math.abs(i - leftIndex), temp[i]);\n            if (chars[i] == c){\n                leftIndex = findLeftIndex(c, i, chars);\n            }\n        }\n        // 第一位没考虑\n        temp[0] = leftIndex == 0? 0:temp[0];\n        return temp;\n    }\n\n    private static int findRightIndex(char c , int i, char[] chars){\n        for (int j = i+1; j < chars.length; j++) {\n            if (chars[j] == c){\n                return j;\n            }\n        }\n        return i;\n    }\n\n    private static int findLeftIndex(char c , int i, char[] chars){\n        for (int j = i-1; j >= 0; j--) {\n            if (chars[j] == c){\n                return j;\n            }\n        }\n        return i;\n    }\n\n```\n\n\n\n\n\n**复杂度分析**\n\n—  时间复杂度：O(3n)，其中n为字符串长度。字符串转为数组一次，正反遍历各一次（考虑转换的时候做一次判断就能变为2n了）\n\n—  空间复杂度：O(2n)，新增了一个字符数组和一个整数数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917593431","body":"### 思路\r\n\r\n1. 功能倒是很简单，之前有写过类似的东西\r\n2. 但是时间复杂度就是高啊，还得多看看大神写的代码\r\n\r\n3. 看到大家都用的数组，好像更简单，是我想复杂了？？？\r\n\r\n\r\n\r\n### 代码\r\n\r\n\r\n\r\n```java\r\nclass CustomStack {\r\n    private Integer size = 0;\r\n    private LinkedList<Integer> stack;\r\n    private final Integer maxSize;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        this.stack = new LinkedList<>();\r\n    }\r\n\r\n    /**\r\n     * void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\n     * @param x 元素\r\n     */\r\n    public void push(int x) {\r\n        if (this.size < this.maxSize){\r\n            stack.addFirst(x);\r\n            size++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\n     * @return 栈顶元素或-1\r\n     */\r\n    public int pop() {\r\n        if (size <= 0){\r\n            return -1;\r\n        }else {\r\n            size--;\r\n            return stack.removeFirst();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n     * @param k 栈底的 k 个元素\r\n     * @param val  增加 val\r\n     */\r\n    public void increment(int k, int val) {\r\n        int temp = (k > size? size : k);\r\n        for (int i = 0; i < temp; i++) {\r\n            this.stack.set(size-i-1,this.stack.get(size-i-1)+val);\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**复杂度分析**\r\n\r\n—  时间复杂度：\r\n\r\n1. pop()  : O (1)，直接改了虚拟size\r\n2. push() : O(1)，双向链表，直接加头上\r\n3. increment() : O(2n)，先遍历查找，修改后再遍历修改进去\r\n\r\n—  空间复杂度：\r\n\r\n1. pop()  : O (1)，没变\r\n2. push() : O(n)，每push一次，就加一个存储块\r\n3. increment() : O(1)，不变，再原基础修改了","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"A-PolarBear":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916649889","body":"### 思路\n逐位相加，并通过carry保存进位。需要注意K和num的长度关系。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int len = num.size();\n        int carry = 0;\n        int temp = 0;\n        int i=len-1;\n        while(i>=0||k!=0){\n            int A = i>=0?num[i]:0;\n            temp = A +k%10+carry;\n            carry = temp/10;\n            res.push_back(temp%10);\n            k/=10;\n            i--;\n        }\n        if(carry > 0){\n            res.push_back(carry);\n        }\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917429905","body":"## 思路\n由每一个元素向两边搜索，找到最近的匹配字符，再转入下一个字符\n\n## 代码\n````c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> ans;\n        int prev = 0;\n        int next = 0;\n        for(int i = 0;i<s.size();i++){\n            prev = next = i;\n            while(prev>=0 || next < s.size()){\n                if(prev>=0&&s[prev]==c||next<s.size()&&s[next]==c){\n                    ans.push_back(next-i);\n                    break;\n                }\n                next++;\n                prev--;\n            }\n        }\n    return ans;\n    }\n};\n````\n## 复杂度分析\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917657670","body":"## 思路\n用vector模拟栈\n\n## 代码\n````c++\nclass CustomStack {\npublic:\n    vector<int> stk;\n    int size = 0;\n    int count = 0;\n    CustomStack(int maxSize) {\n        stk.resize(maxSize);\n        size = maxSize;\n    }\n    \n    void push(int x) {\n        if(count<size){\n            stk.insert(stk.begin(),x);\n            count++;\n        }\n    }\n    \n    int pop() {\n        if(count!=0){\n            int temp = stk[0];\n            stk.erase(stk.begin(),stk.begin()+1);\n            count--;\n            return temp;\n        }\n        else{\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        int temp;\n        temp = min(count,k);\n        while(temp>=0){\n            stk[abs(count-temp)]+=val;\n            temp--;\n        }\n\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mixtureve":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916652757","body":"思路：把 k 分成单个的数位，和 nums 的各个数字从后往前依次两两相加，同时注意进位\r\n`class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> listK = new LinkedList<>();\r\n        int kIdx = 3;\r\n        while (k > 0) {\r\n            int digit = k % 10;\r\n            k = k / 10;\r\n            listK.add(0, digit);\r\n        }\r\n        int carryOver = 0;\r\n        int i = num.length - 1;\r\n        int j = listK.size() - 1;\r\n        List<Integer> result = new LinkedList<>();\r\n\r\n        while (i >= 0 || j >= 0) {\r\n\r\n            int a = i >= 0? num[i]: 0;\r\n            int b = j >= 0? listK.get(j): 0;\r\n\r\n            int curDigit = a + b + carryOver;\r\n\r\n            if (curDigit >= 10) {\r\n                carryOver = 1;\r\n            } else {\r\n                carryOver = 0;\r\n            }\r\n\r\n            result.add(0, curDigit % 10);\r\n             i--;\r\n            j--;\r\n        }\r\n\r\n        if (carryOver == 1) {\r\n            result.add(0, 1);\r\n        }\r\n\r\n        return result;\r\n    }\r\n}`\r\nspace complexity: O(X) X指k的位数\r\ntime complexity: O(max(n, X))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917362155","body":"## 思路\r\n- 先过一遍string，记下所有字符c出现的 indes，放进 list 里\r\n- 遍历 string 的每个字符，用一个 pointer k 来指定该用的 list index 来与当前字符的 index 计算距离。do k++ when Math.abs(i - list.get(k)) > Math.abs(i - list.get( k + 1))\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        List<Integer> cIdxList = new ArrayList<>();\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                cIdxList.add(i);\r\n            }\r\n        }\r\n        int m = cIdxList.size();\r\n        int[] ret = new int[n];\r\n        int k = 0; // k is the pointer for cIdxList\r\n        for (int i = 0; i < n; i++) {\r\n            \r\n            if (k + 1 < m && Math.abs(i - cIdxList.get(k)) > Math.abs(i - cIdxList.get(k + 1))) {\r\n                k++;\r\n            }\r\n            ret[i] = Math.abs(i - cIdxList.get(k));\r\n            \r\n        }\r\n        return ret;\r\n        \r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为 string 长度, m 为 c在 string 出现的次数\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(m)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917588217","body":"## 思路\r\n- 用一个 array 去记录增量\r\n- 用 stack 模拟操作\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass CustomStack {\r\n    int n;\r\n    int[] increaseArr;\r\n    Stack<Integer> stack;\r\n    public CustomStack(int maxSize) {\r\n        n = maxSize;\r\n        increaseArr = new int[n];\r\n        stack = new Stack<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (stack.size() < n)\r\n            stack.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        int i = stack.size() - 1;\r\n        if (i < 0)\r\n            return -1;\r\n        if (i > 0)\r\n            increaseArr[i - 1] += increaseArr[i];\r\n        int res = stack.pop() + increaseArr[i];\r\n        increaseArr[i] = 0;\r\n        return res;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int i = Math.min(k, stack.size()) - 1;\r\n        if (i >= 0)\r\n            increaseArr[i] += val;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freedom0123":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916654651","body":"#  989、数组形式的整数加法\n\n## 思路\n\n本质上就是 手动模拟加法的过程\n\n这种思路同时适用于高精度加法\n\n```java\nclass Solution {\n    List<Integer> res = new ArrayList();\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> resTem = new ArrayList<>() ;\n        List<Integer> res  =new ArrayList<>();\n        int i = num.length-1;\n        int tem  = 0;//用来表示进位\n        while(i>=0 || k!=0){\n            if(i>=0){\n                tem+=num[i];\n                i--;\n            }\n            if(k!=0){\n                tem+=(k%10);\n                k= k/10;\n            }\n            resTem.add(tem%10);\n            tem = tem/10;\n        }\n        if(tem>0){\n            resTem.add(tem);\n        }\n        //最后将res 倒叙输出\n        for(int j  = resTem.size()-1;j>=0;j--){\n            res.add(resTem.get(j));\n        }\n        return  res;\n    }\n\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917326625","body":"时间复杂度：O(N)\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] answer = new int[s.length()];\n        //最后一次 c出现的位置，因为要求的是距离最近\n        int pre = Integer.MIN_VALUE/2;\n        //从前往后进行扫描，记住 c 在s[i] 的左边距 距离最近的一次\n        for(int i  = 0;i<s.length();i++){\n           if(s.charAt(i) == c){\n               //说明这就是 c 最后一次出现的位置\n               pre = i;\n           }\n           answer[i] =  i - pre;\n        }\n        pre = Integer.MAX_VALUE/2;\n         for(int i  = s.length()-1;i>=0;i--){\n           if(s.charAt(i) == c){\n               pre = i;\n\n           }\n           answer[i] = Math.min(answer[i],pre-i);\n        }\n\n        return answer;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917550269","body":"用数组模拟栈\n```\nclass CustomStack {\n    private int index;\n    private int[] stack;\n    //初始化\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        index = 0;\n    }\n    // 向栈中添加元素\n    public void push(int x) {\n        if(index >= stack.length){\n            return;\n        }\n        stack[index++] = x;\n\n    }\n    \n    public int pop() {\n        if(index == 0){\n            return -1;\n        }\n        return stack[--index];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i  = 0; i<k && i<index;i++){\n            stack[i]+=val;\n        }\n\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leolisgit":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916654773","body":"### 思路\n1. 看到这道题，想到一个类似的题目，是两个list相加。然后有点类似于merge sort中merge这一步。\n从末尾一直加到开头，如果有一个数组没有到头，就加到结果上。这种方法可以做，但是写起来比较繁琐，因为需要把int转化为数组先。\n2. 因为数据范围限制，没有办法把int 数组转换为数值相加。\n3. 其实每次我们只需要求得该位的余数即可。这样可以直接把k拿来用。使用k和数组每一位求和，取余数，然后除以10。这样就可以得到每一位的余数。\n需要注意如果最后和不为0，需要把每一位取出加入list中。\n\n### 代码\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new LinkedList<>();\n        \n        int sum = k;\n        for (int i = num.length - 1; i >= 0; i--) {\n            sum += num[i];\n            list.add(0, sum % 10);\n            sum /= 10;\n        }\n        \n        while (sum > 0) {\n            list.add(0, sum % 10);\n            sum /= 10;\n        }\n        \n        return list;\n    }\n}\n```\n\n### 复杂度分析\n时间：O(N)  \n空间：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917340961","body":"### 思路\n1. 暴力解法就是记录所有字符出现的位置。然后对于每个字符，进行距离的比较。\n2. 优化\n    * 剪枝，一旦遇到字符的位置距离当前字符的位置开始增加，就可以跳出循环\n    * 对记录字符位置进行二分，可以把时间复杂度降低到O(nlog)\n\n**最优解**:\n从左到右和从右到左遍历两遍，因为最近距离不是到左边字符最近就是到右边，或者相等。\n如果左边没有遇到所求字符，那么该字符一定是到右边的最近。就设置一个虚拟的值。取length + 1即可。\n\n### 代码\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ret = new int[n];\n        \n        int temp = n + 1;\n        for (int i = 0; i < s.length(); i++) {\n            if (c == s.charAt(i)) {\n                temp = 0;\n            } else {\n                temp++;\n            }\n            ret[i] = temp;\n        }\n        \n        temp = n + 1;\n        for (int i = n - 1; i >= 0; i--) {\n            if (c == s.charAt(i)) {\n                temp = 0;\n            } else {\n                temp++;\n            }\n            ret[i] = Math.min(ret[i], temp);\n        }\n        return ret;\n    }\n}\n```\n\n### 复杂度分析\n1. 时间复杂度：O(n)\n2. 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917569465","body":"### 思路\n数组模拟栈。\n1. 暴力做法就每次做increment操作，把增加的值加到数组对应的位置, 时间复杂度为O(n)\n2. 使用presum来优化，但是这个presum相当于是从后往前加。使用一个add数组来保存增量。如果栈顶元素弹出，并且该位置有增量。\n就加上该增量。然后该位置的增量设置为0，因为是从bottom到该位置，该位置之前的元素也属于该增量的范围内。把该值加到之前的一个位置上。\n\n### 代码\n```\nclass CustomStack {\n\n    private int[] stack;\n    private int maxSize;\n    private int[] add;\n    private int cur;\n    \n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        this.maxSize = maxSize;\n        add = new int[maxSize];\n        cur = -1;\n    }\n    \n    public void push(int x) {\n        if (cur + 1 < maxSize) {\n            stack[++cur] = x;\n        }\n    }\n    \n    public int pop() {\n        if (cur < 0) {\n            return -1;\n        }\n        \n        if (cur > 0) {\n            add[cur - 1] += add[cur];\n        }\n        \n        int res = stack[cur] + add[cur];\n        add[cur] = 0;\n        cur--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int size = Math.min(k, cur + 1);\n        if (size > 0) {\n            add[size - 1] += val;\n        }\n    }\n}\n```\n\n### 复杂度：  \n时间：  \n1. push: O(1)  \n2. pop: O(1)  \n3. increment: O(1)   \n\n空间：O(n)  \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuliangyu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916655204","body":"'''\r\nGiven: array form number\r\nreturn: array form number + k \r\n\r\nsample: \r\nnum = [1,2,0,0], k = 34\r\n1200 + 34 = 1234\r\n[1, 2, 3, 4]\r\n\r\n1: \r\ngenerate a integer from array form\r\n[1, 2, 0, 0] => 1200\r\n''\r\n'1'\r\n'12'\r\n'120'\r\n'1200'\r\n\r\n2: k added\r\n1200 + 34 = 1234\r\n\r\n3.\r\nfn generateForm(1234) => return [1, 2, 3, 4]\r\n1234 % 10 = 4 \r\nappend to list res [4]\r\n\r\n1234 // 10 = 123\r\n123 % 10 = 3\r\n[4, 3]\r\n123 // 10 = 12\r\n...\r\n[4, 3, 2]\r\n[4, 3, 2, 1]\r\n\r\n4. \r\nreverse list !!!!\r\n[4, 3, 2, 1] => [1, 2, 3, 4]\r\n\r\ntime O(n)\r\nspace O(n)\r\n\r\n'''\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        if not num: return []\r\n        if k == 0: return num\r\n        \r\n        s = ''\r\n        for ele in num: \r\n            s = s + str(ele)\r\n        newNums = int(s) + k\r\n\r\n        res = self.generateForm(newNums)\r\n        return res[::-1]\r\n    \r\n    def generateForm(self, nums):\r\n        res = []\r\n        while nums:\r\n            digit = nums % 10\r\n            res.append(digit)\r\n            nums = nums // 10\r\n        \r\n        return res\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917352250","body":"'''\nGiven:\ns\nc\nans\nlen\nQuestion:\n0   1   2   3   4   5   6   7   8   9   10  11\nl   o   v   e   l   e   e   t   c   o   d   e\n3   2   1   0   1   0   0   1   2   2   1   0\n\n1 find index of e\n0, 1, 2, 3\n3, 5, 6, 11\n\n0: abs(0 - 3)\n1\n2\n3\n4 min(abs(4-3), abs(4-5))\n\nbisect(7 in [3, 5, 6, 11]), get the index of 3\nneed to comapre index of 2 and 3\n\n7 min(abs(7-6), abs(7 - 11))\n\n0 1 2 3\na a b a\n[2]\n[2, 1, 0, 1]\n\ntime O(nlogn)\n\n'''\n\nfrom collections import deque\nfrom typing import List\nfrom collections import OrderedDict\nfrom collections import defaultdict\nimport functools\nimport heapq\nimport bisect\n\n\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        if not s: return []\n        if len(s) == 0: return []\n\n        indexOfTarget = []\n        ans = [0] * len(s)\n\n        for i, ele in enumerate(s): \n            if ele == c:\n                indexOfTarget.append(i)\n        \n        for i, ele in enumerate(s):\n            if ele != c:\n                # 二分法找到index\n                index = bisect.bisect(indexOfTarget, i)\n                if 0 < index < len(indexOfTarget): \n                    ans[i] = min(abs(i - indexOfTarget[index]), abs(i - indexOfTarget[index - 1]))\n                elif index == 0:\n                    ans[i] = abs(i - indexOfTarget[index])\n                    # print(\"---------------------\")\n\n                elif index == len(indexOfTarget):\n                    # print(\"---------------------\")\n                    # print(i)\n                    # print(indexOfTarget[index - 1] )\n                    print(i - indexOfTarget[index - 1])\n\n                    ans[i] = abs(i - indexOfTarget[index - 1])\n                    \n        \n        return ans\n\n\n\n\n\n\n\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917551635","body":"from collections import deque\nfrom typing import List\nfrom collections import OrderedDict\nfrom collections import defaultdict\nimport functools\nimport heapq\nimport bisect\n\nclass CustomStack:\n    '''\n    maxSize = 3\n    1, 2, 3\n    4, not push\n    '''\n\n    def __init__(self, maxSize: int):\n        self.cap = maxSize\n        self.q = deque()\n\n    def push(self, x: int) -> None:\n        if len(self.q) < self.cap:\n            self.q.append(x)\n\n    def pop(self) -> int:\n        if self.q:\n            return self.q.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        '''\n        k = 4\n         i0    i1      i2\n        [1,     2,      3]\n        '''\n\n        for i in range(len(self.q)):\n            if i < k:\n                cur = self.q[i]\n                self.q[i] = cur + val\n\n\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Kirito1017":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916655676","body":"## 思路 \n###### 从最后一位 一位一位往上相加 并考虑是否有carry 如果长短不一样也没关系 判断一下就行。如果while loop结束后考虑下是否要最后append一个carry \n###### 每次都insert到第一个元素\n\n## 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] nums, int k) {\n        List<Integer> res = new ArrayList<>();\n        int i = nums.length - 1;\n        int carry = 0;\n        while (i >= 0 || k > 0) {\n            int two = k > 0 ? k % 10 : 0;\n            int one = i >= 0 ? nums[i] : 0;\n            int total = two + one + carry;\n            \n            carry = total / 10;\n            res.add(0, total % 10);\n            \n            i--;\n            k = k / 10;\n        }\n        \n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n```\n## 复杂度\n###### 时间复杂度O(n), 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917348006","body":"## 将c的index存到treeset里面 然后iterate每个元素找左右最近的\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        \n        TreeSet<Integer> set = new TreeSet<>();\n        \n        char[] chars = s.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == c) {\n                set.add(i);\n            }\n        }\n        \n        int[] res = new int[s.length()];\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == c) {\n                res[i] = 0;\n            }\n            else {\n                Integer floor = set.floor(i);\n                Integer ceil = set.ceiling(i);\n                if (floor != null && ceil != null) {\n                    res[i] = Math.min(Math.abs(floor - i), Math.abs(ceil - i));\n                }\n                else if (floor!= null) {\n                    res[i] = Math.abs(floor - i);\n                }\n                else if (ceil != null) {\n                    res[i] = Math.abs(ceil - i);\n                }\n            }\n        }\n        \n        return res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"FullStackH":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916657808","body":"# 思路\n逐位相加，carry保存进位\n\n# 代码\n\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    int len = num.length;\n    int count = 0;\n    int flag = 0;\n    List<Integer> ans = new ArrayList<>();\n    while (k > 0) {\n        int tmpNum = len - count - 1 < 0 ? 0: num[len - count - 1];\n        int sum = k % 10 + tmpNum + flag;\n        flag = sum / 10;\n        k /= 10;\n        count++;\n        ans.add(flag == 1 ? sum % 10 : sum);\n    }\n    for(int i = len - count - 1; i > -1; i--) {\n        int sum = num[i] + flag;\n        flag = sum / 10;\n        ans.add(flag == 1 ? sum % 10 : sum);\n    }\n    if (flag == 1) {\n        ans.add(1);\n    }\n    Collections.reverse(ans);\n    return ans;\n}\n\n# 复杂度\n时间复杂度O(n)\n空间复杂度O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917429431","body":"JAVA:\n\n`class Solution {\n    public int[] shortestToChar(String s, char c) {\n        List<Integer> list = new ArrayList();\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i) == c){\n                list.add(i);\n            }\n        }\n        int res[] = new int[s.length()];\n        \n        for(int i=0;i<s.length();i++){\n            int min=Integer.MAX_VALUE;\n            for(int j=0;j<list.size();j++){\n                int abs = Math.abs(i-list.get(j));\n                min = Math.min(abs,min);\n            }\n            res[i] = min;\n        }\n        return res;\n\n    }\n}`\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917661081","body":"JAVA:\n`int[] data;\n    int head;\n\n    public CustomStack(int maxSize) {\n\n        data = new int[maxSize];\n        head = -1;\n    }\n    \n    public void push(int x) {\n\n        if (head == data.length - 1)\n            return;\n            \n        data[++head] = x;\n    }\n    \n    public int pop() {\n\n        if (head == -1)\n            return -1;\n\n        return data[head--];\n    }\n    \n    public void increment(int k, int val) {\n\n        for (int i = 0; i < Math.min(k, head + 1); i++)\n            data[i] += val;`\n时间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chun1hao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916659493","body":"```js\nvar addToArrayForm = function (num, k) {\n  let idx = num.length - 1;\n  let c = 0;\n  while (c || k) {\n    let curK = k % 10;\n    let curNum = idx >= 0 ? num[idx] : 0;\n    let sum = c + curK + curNum;\n    c = Math.floor(sum / 10);\n    sum %= 10;\n    if (idx >= 0) {\n      num[idx--] = sum;\n    } else {\n      num.unshift(sum);\n    }\n    k = Math.floor(k / 10);\n  }\n  return num;\n};\n```\n\n时间：O(N)\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917424498","body":"```js\r\nvar shortestToChar = function(s, c) {\r\n    let ans = []\r\n    let prev = -Infinity\r\n    for(let i=0;i<s.length;i++){\r\n        if(s[i] === c) prev = i\r\n        ans[i] = i - prev\r\n    }\r\n    prev = Infinity \r\n    for(let i= s.length-1;i>=0;i--){\r\n        if(s[i] === c) prev = i\r\n        ans[i] = Math.min(prev - i, ans[i])\r\n    }\r\n    return ans\r\n};\r\n```\r\n空间 O(N)\r\n时间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917638057","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.stack = []\n    this.addVal = new Array(maxSize).fill(0)\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length < this.maxSize){\n        this.stack.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.stack.length){\n        let idx = this.stack.length - 1\n        let num = this.addVal[idx]\n        this.addVal[idx] = 0   \n        this.addVal[idx-1] += num      \n        return this.stack.pop() + num\n    }else{\n        return -1\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let idx = Math.min(k-1, this.stack.length-1)\n    this.addVal[idx] += val\n};\n```\n时间：O(1)  \n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917809489","body":"```js\nvar decodeString = function (s) {\n  let strStack = [];\n  let numStrack = [];\n  let tempNum = 0;\n  for (let i of s) {\n    if (!isNaN(i)) {\n      tempNum = tempNum * 10 + +i;\n    } else if (i === \"]\") {\n      let str = \"\";\n      let cur = strStack.pop();\n      let repeat = numStrack.pop();\n      while (cur && cur !== \"[\") {\n        str = cur + str;\n        cur = strStack.pop();\n      }\n      str = str.repeat(repeat);\n      strStack.push(str);\n    } else {\n      strStack.push(i);\n      if (tempNum) {\n        numStrack.push(tempNum);\n        tempNum = 0;\n      }\n    }\n  }\n  return strStack.join(\"\");\n};\n```\n时间 O(n)\n空间 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"m-z-w":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916661368","body":"```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let newArr = []\r\n    let numK = String(k).split('')\r\n    let maxLen = Math.max(num.length, numK.length)\r\n    let flag = 0\r\n    let cur = 0\r\n    while (cur < maxLen) {\r\n        console.log(cur)\r\n        if (num[cur] === undefined) {\r\n            num.unshift(0)\r\n        }\r\n        if (numK[cur] === undefined) {\r\n            numK.unshift(0)\r\n        } else {\r\n            numK[cur] = Number(numK[cur])\r\n        }\r\n        cur++\r\n    }\r\n    for (let i = maxLen - 1; i >= 0; i--) {\r\n         let n = num[i] + numK[i] + flag\r\n        flag = n >= 10 ? 1 : 0\r\n        n = n >= 10 ? n - 10 : n\r\n        newArr.unshift(n)\r\n    }\r\n    if (flag === 1) {\r\n        newArr.unshift(1)\r\n    }\r\n    return newArr\r\n};\r\n```\r\n时间：O(n)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917361821","body":"```javascript\nvar shortestToChar = function(s, c) {\n    const res = new Array(s.length)\n    let recentIndex = -s.length\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === c) {\n            res[i] = 0\n            recentIndex = i\n        } else {\n            res[i] = Math.abs(i - recentIndex)\n        }\n    }\n    for (let i = s.length - 1; i >= 0; i--) {\n        if (s[i] === c) {\n            res[i] = 0\n            recentIndex = i\n        } else {\n            const num = Math.abs(i - recentIndex)\n            res[i] = num > res[i] ? res[i] : num\n        }\n    }\n    return res\n};\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917628053","body":"```javascript\nvar CustomStack = function(maxSize) {\n    this.stack = []\n    this.length = maxSize\n    this.top = new Array(maxSize)\n    for (let i = 0; i < maxSize; i++) {\n        this.top[i] = 0\n    }\n};\n\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length < this.length) {\n        this.stack.push(x)\n    }\n};\n\nCustomStack.prototype.pop = function() {\n    if (this.stack.length === 0) {\n        return -1\n    } else {\n        let maxIndex = this.stack.length - 1\n        let num = this.stack.pop()\n        const inc = this.top[maxIndex]\n        this.top[maxIndex - 1] += inc\n        this.top[maxIndex] = 0\n        return num + inc        \n    }\n};\n\nCustomStack.prototype.increment = function(k, val) {\n    const min = Math.min(this.stack.length - 1, k - 1)\n    this.top[min] += val\n};\n```\n\n时间复杂度：push、pop、increment均为O(1)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"KennethAlgol":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916664966","body":"思路: 将整个加数 k加入数组表示的数的最低位\n\n    class Solution {\n        public List<Integer> addToArrayForm(int[] num, int k) {\n            List<Integer> res = new ArrayList<Integer>();\n            int n = num.length;\n            for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n                if (i >= 0) {\n                    k += num[i];\n                }\n                res.add(k % 10);\n            }\n            Collections.reverse(res);\n            return res;\n        }\n    }\n\n复杂度分析\n\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\n\n空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Richard-LYF":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916665554","body":"def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n=0\n        for i in range(len(num)):\n            n=n*10+num[i]\n        n=str(n+k)\n        out=[]\n        for i in n:\n            out.append(int(i))\n        return out\n\n分享一个自己的思路，代码比较短，容易理解，但是好像用时和内存消耗没有很优秀\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917338500","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        a=[]\n        p=[]\n        for i in range(len(s)):\n            if s[i]==c:\n                p.append(i)\n        for i in range(len(s)):\n            k=[]\n            for j in p:\n                k.append(abs(j-i))\n            a.append(min(k))\n        return a\n        \n        #time complx   O(n)\n        #space complx  O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917554160","body":"class CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.space=[]\n        self.n=maxSize\n    def push(self, x: int) -> None:\n        if len(self.space)<self.n:\n            self.space.append(x)\n\n    def pop(self) -> int:\n        if self.space:\n            return self.space.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if k>=len(self.space):\n            for i in range(len(self.space)):\n                self.space[i]+=val\n        else:\n            for i in range(k):\n                self.space[i]+=val\n\n# time o(n)\n# space o(n)\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinmenghan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916667562","body":"\n## 题目地址()\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n\n## 题目描述\n\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/add-to-array-form-of-integer\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<Integer>();\n        for (int i = num.length - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            list.add(k % 10);\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917395499","body":"\n## 题目地址()\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n```\n\n## 前置知识\n\n- 数组\n\n## 思路\n先记录字符c出现的位置，\n\n再记录遍历字符，根据记录的位置求最小值\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n public int[] shortestToChar(String s, char c) {\n        int N = s.length();\n        int[] ans = new int[N];\n\n        List<Integer> indexArr= new ArrayList<>();\n        // 记录 c的位置\n        for (int i = 0; i < N; i++) {\n            if (s.charAt(i) == c) {\n                indexArr.add(i);\n            }\n        }\n\n        // 遍历每个字符，取最小路径\n        for (int i = 0; i < N; i++) {\n            int temp = Integer.MAX_VALUE;\n           for(int j = 0; j < indexArr.size(); j++){\n               temp = Math.min(temp, Math.abs(i - indexArr.get(j)));\n           }\n           ans[i] = temp;\n        }\n        return ans;\n    }\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n^2 + n)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917531455","body":"\n## 题目地址()\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1); // 栈变为 [1]\ncustomStack.push(2); // 栈变为 [1, 2]\ncustomStack.pop(); // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2); // 栈变为 [1, 2]\ncustomStack.push(3); // 栈变为 [1, 2, 3]\ncustomStack.push(4); // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100); // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100); // 栈变为 [201, 202, 103]\ncustomStack.pop(); // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop(); // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop(); // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop(); // 返回 -1 --> 栈为空，返回 -1\n\n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n## 前置知识\n\n- 数组\n- 前缀和\n\n## 公司\n\n- 暂无\n\n## 思路\n用数组和指针用来表示栈\n\ntop 来记录栈顶的位置\n\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\nclass CustomStack {\n\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n\n\n\n```\n\n\n**复杂度分析**\n\n令 maxSize 为数组长度。\n\n- 时间复杂度：$O(maxSize)$\n- 空间复杂度：$O(maxSize)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lxy030988":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916671424","body":"# 思路\n\n- 从末尾开始循环逐个相加，把结果存到一个数组里\n- 返回 翻转的数组\n\n# 代码 js\n\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  let len = num.length,\n    res = [],\n    next = 0,\n    ks = k.toString().split('').map(Number),\n    klen = ks.length,\n    maxlen = len > klen ? len : klen\n\n  for (let i = 0; i < maxlen; i++) {\n    let cur = num[len - 1 - i] || 0,\n      kcur = ks[klen - 1 - i] || 0\n\n    cur = cur + kcur + next\n    next = parseInt(cur / 10)\n    cur = cur % 10\n\n    res.push(cur)\n  }\n\n  if (next > 0) {\n    res.push(next)\n  }\n\n  return res.reverse()\n}\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(n) 数组的长度\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917398292","body":"# 思路\n\n- 先取到所有 c 的 index,存到数组里\n- 从头 循环字符串,与靠近右边的 c 比较,把结果存到一个数组 res 中\n- 从尾 循环字符串,与靠左边的 c 比较, 再把这个值与 res 中的结果比较\n\n# 代码 js\n\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n  let cs = []\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == c) {\n      cs.push(i)\n    }\n  }\n  let j = 0,\n    res = []\n  for (let i = 0; i < s.length; i++) {\n    res.push(Math.abs(i - cs[j]))\n\n    if (i == cs[j] && j < cs.length - 1) {\n      j++\n    }\n  }\n\n  for (let i = s.length - 1; i > 0; i--) {\n    if (Math.abs(i - cs[j]) < res[i]) {\n      res[i] = Math.abs(i - cs[j])\n    }\n\n    if (i == cs[j] && j > 0) {\n      j--\n    }\n  }\n\n  return res\n}\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(3n)\n- 空间复杂度：O(3)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917625574","body":"# 思路\n\n- 借助数组实现\n- 把 maxSize 存起来 作为后面方法的比较使用\n\n# 代码 js\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.maxSize = maxSize\n  this.arr = []\n}\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.arr.length < this.maxSize) {\n    this.arr.push(x)\n  }\n}\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  if (this.arr.length) {\n    return this.arr.pop()\n  }\n  return -1\n}\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  let len = k < this.arr.length ? k : this.arr.length\n  for (let i = 0; i < len; i++) {\n    this.arr[i] += val\n  }\n}\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(n) 数组的长度\n- 空间复杂度：O(4)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"52HzEcho":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916675882","body":"#### 思路：类型转换\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n    return String(BigInt(num.join('')) + BigInt(k)).split('')\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917429803","body":"\n```js\nvar shortestToChar = function(s, c) {\n    let array = [];\n    for (let i = 0; i < s.length; i++) {\n        array[i] = s.length;\n    }\n    for (let i = 0; i < s.length; i++){\n        if ( s.substring(i, i+1) === c){\n            for (let j = 0; j < s.length; j++){\n                array[j] = Math.min(Math.abs(i - j),array[j])\n            }\n        }\n    }\n    return array;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917662701","body":"/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.stack.length >= this.maxSize) {\n        return;\n    }\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    return this.stack.length > 0 ? this.stack.pop() : -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    let length = Math.min(k, this.stack.length);\n    for (let i = 0; i < length; i++) {\n        this.stack[i] += val;\n    }\n};","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HarryPangPang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916676513","body":"地位到高位逐位相加，最后的时候需要判断是否溢出\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\n var addToArrayForm = function(num, k) {\n    let res = []\n    let n = num.length\n    for(let i=n-1;i >=0; i--){\n        let sum = num[i]+ k%10\n        k = Math.floor(k/10)\n        if(sum>=10){\n            k++\n            sum -= 10\n        }\n        res.push(sum)\n    }\n\tfor(; k>0;k= Math.floor(k/10)){\n\t\tres.push(k%10)\n\t}\n    res.reverse()\n    return res\n};\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iamtheUsername":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916676823","body":"### 思路\n\n```markdown\n1.由低位到高位逐位相加\n2.进行取余和整数除法\n3.判断进位是否大于0\n```\n\n### 代码(CPP)\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> array;\n\n        for(int i = num.size()-1;i >= 0;i --){\n            int r = num[i] + k;\n            array.push_back(r % 10);\n            k = r / 10;\n        }\n        //判断进位值\n        while(k > 0){\n            array.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(array.begin(),array.end());\n        return array;\n    }\n};\n```\n\n#### 复杂度分析\n\n$$\n时间复杂度：O(n)\n$$\n\n$$\n空间复杂度：O(n)\n$$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917399885","body":"##### 思路\n\n```markdown\n1.遍历一遍s,找出字符c所在的位置\n2.在第一个字符c前面的直接和字符c比较，在后面的直接和最后一个字符c比较\n3.位于两个字符中间的利用二分法\n```\n\n##### 代码(CPP)\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n\n        vector<int> pos;\n        int n = s.length();\n        for(int i = 0;i < n;i++){\n            if(s[i] == c) pos.push_back(i);\n        }\n\n        vector<int> ans;\n        for(int i = 0; i < n; i++){\n            auto ptr = lower_bound(pos.begin(), pos.end(), i);\n            if(ptr == pos.begin()){\n                ans.push_back(pos[0] - i);\n            }else if(ptr == pos.end()){\n                ans.push_back(i - pos.back());\n            }else {\n                int a = *ptr - i;\n                ptr--;\n                int b = i - *ptr;\n                ans.push_back(min(a, b));\n            }\n        }\n        return ans;\n    }\n};\n```\n\n##### 复杂度分析\n\n$$\n时间复杂度：O(nlogn)\n$$\n\n$$\n空间复杂度：O(n)\n$$\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HondryTravis":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916681677","body":"## 思路\r\n\r\n已知 k 不是 bigint 的情况下\r\n\r\n1. 通过对 k 不断累加 nums 的低位来维护 k\r\n2. 通过对 k 不断求模得到当前位，不断求商得到进位，维护 k 即可\r\n\r\n### 代码[javascirpt] Q & A\r\n\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n  const { floor } = Math\r\n  const n = num.length, ret = []\r\n\r\n  let i = n - 1\r\n\r\n  while (i >= 0 || k) {\r\n      // 出现 undefined 就要进位默认值 0\r\n      // num: [0], k = 23\r\n      k += (num[i] || 0)\r\n      ret.push(k % 10)\r\n      k = floor(k / 10)\r\n      i--\r\n  }\r\n\r\n  return ret.reverse()\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917370888","body":"### 思路\n\n1. 从当前下标找到的下标出发，分别向左、右两个方向去寻找目标字符 C\n2. 只在一个方向找到的话，直接计算字符距离\n3. 两个方向都找到的话，取两个距离的最小值(min)\n\n### 代码[js]\n\n```js\nvar shortestToChar = function (S, C) {\n    const result = []\n    \n    //  先找到前两个出现的位置\n    for (let i = 0, l = S.indexOf(C), r = S.indexOf(C, l + 1); i < S.length; i++) {\n        // 计算与左指针的距离\n        result[i] = Math.abs(l - i)\n        if (r === -1) continue\n\n        // 如果右指针存在,取较小的距离\n        result[i] = Math.min(result[i], r - i)\n\n        // 走到右指针则左右指针往下一个\n        if (i != r ) continue\n\n        (result[i] = 0, l = r, r = S.indexOf(C, r + 1))\n       \n    }\n    return result\n};\n```\n\n### 复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917618315","body":"### 思路\r\n\r\n使用数组模拟\r\n\r\n1. push: 当数组长度 >= maxSize 时不push否则添加\r\n2. pop: 只需要关心当前数组长度即可\r\n3. increment: 只需要关心当前数组长度和k的关系\r\n\r\n### 代码[js]\r\n\r\n```js\r\nvar CustomStack = function(maxSize) {\r\n    this.stack = []\r\n    this.maxSize = maxSize || 0\r\n};\r\n\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length >= this.maxSize) return false\r\n    this.stack.push(x)\r\n};\r\n\r\nCustomStack.prototype.pop = function() {\r\n    return this.stack.length\r\n        && this.stack.pop()\r\n        || -1\r\n};\r\n\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const length = Math.min(k, this.stack.length)\r\n    for (let i = 0; i < length; i++) this.stack[i] += val\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度: [push, pop] 为O(1) increment 为 O(n)\r\n\r\n空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Abby-xu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916682817","body":"### 思路\n\n- 列表转换为整数\n- 数字相加\n- 数字拆分成列表\n\n### 代码 （Python）\n\n~~~python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        if num == [0] and k == 0: return [0] \n        x = 0\n        out = []\n        for i in num:\n            x = x*10 + i \n        x += k\n        while x > 0:\n            out.append(x % 10)\n            x //= 10\n        return out[::-1]\n~~~\n\n### 复杂度\n\nTime: $O(n)$\n\nSpace: $O(n)$\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hwpanda":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916683150","body":"**思路:**\n\nNumber和String的类型转换\n\n\n**代码：JavaScript**\n\n\n```\nconst addToArrayForm = (numArr, k) => {\n    if (numArr.length < 1) return [];\n​\n    //convert numArr to string integer\n    let numArrString = numArr.join('');\n  // convert the string integer into number\n    let num = BigInt(numArrString)+BigInt(k);\n​\n  //convert the number to array of strings\n    let strArr = num.toString().split('');\n  \n  //convert it back to integer\n    return strArr.map(i=>parseInt(i));\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917347554","body":"```javascript\n\nconst shortestToChar = (S, C) => {\n    let cIndices = [];\n    for (let i = 0; i < S.length; i++) {\n        if (S[i] === C) cIndices.push(i);\n    }\n    //console.log('cIndices is: ', cIndices);\n​\n    let result = Array(S.length).fill(Infinity);\n​\n    for (let i = 0; i < S.length; i++) {\n        if (S[i] === C) {\n            result[i] = 0;\n            continue;\n        }\n​\n        for (const cIndex of cIndices) {\n            const dist = Math.abs(cIndex - i);\n            //console.log(`i is ${i} and cIndex is ${cIndex} dist is ${dist}`);\n​\n            if (dist >= result[i]) break;\n​\n            result[i] = dist;\n            //console.log('result is ', result);\n        }\n    }\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917495664","body":"``` JavaScript\nconst CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n\nCustomStack.prototype.push = function(x) {\n  if(this.stack.length==this.maxSize) return;\n  \n  this.stack.push(x)\n};\n\n\nCustomStack.prototype.pop = function() {\n  if(this.stack.length ==0) return -1;\n  \n  return this.stack.pop();\n};\n\n\nCustomStack.prototype.increment = function(k, val) {\n  for(let i=0;i<k && i< this.stack.length;i++) {\n      this.stack[i] += val;\n  }\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Nina1031":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916683771","body":"# 思路\n\n数组变为整数，求和，变为数组\n变整数 int(), 'sep'.join(str)\n变数组[int()]\n遍历数组 for item in list\n\n# 代码\n\n```python\nclass Solution(object):\ndef addToArrayForm(self, num, k):\n\"\"\"\n:type num: List[int]\n:type k: int\n:rtype: List[int]\n\"\"\"\np = int(''.join(str(item) for item in num)) # num为int array，需2str\nsum = p+k\nreturn [int(i) for i in str(sum)]\n```\n\n# 复杂度\n\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n空间复杂度用来估量程序运行时占用的临时空间大小，此问题中，占用内存取决于数组长度\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fengchen321":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916689310","body":"# 思路\r\n参考题解\r\n从低位到高位计算，将数组低位与K值求和依次得到末位进行前向插入得到result。\r\n考虑k值太大，K值高位需再同一处理插入result\r\n# 代码\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& A, int K) {\r\n        vector<int> result;\r\n        for (int i = A.size() - 1; i >= 0; i --) {\r\n            int num = A[i];\r\n            K += num; //得到末位和\r\n            int remind = K % 10;\r\n            result.insert(result.begin(), remind);  \r\n            K /= 10;\r\n        }\r\n        if (K) {\r\n            while (K > 9) { //如果K 比较大，那么此时还需要把K循环放进去\r\n                int remind = K % 10;\r\n                result.insert(result.begin(), remind);\r\n                K /= 10;\r\n            }\r\n            result.insert(result.begin(), K);\r\n        }\r\n        return result;\r\n\r\n    }\r\n}; \r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n )\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917416959","body":"# 思路\r\n左右循环遍历取最小距离值；\r\n# 代码\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.size();\r\n        vector<int> res(n,n);\r\n        int lastC = -n;\r\n        for(int i=0; i<n; i++){\r\n            if(S[i]==C) lastC = i;\r\n            res[i] = min(res[i], i-lastC);\r\n        }\r\n\r\n        for(int i=lastC-1; i>=0; i--){\r\n            if(S[i]==C) lastC = i;\r\n            res[i] = min(res[i], lastC-i);\r\n        }\r\n\r\n        return res;\r\n    }   \r\n};\r\n```\r\n# 复杂度分析\r\n时间复杂度: O(n)\r\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917504490","body":"# 思路\r\nm数组含义：st中的前i个元素（包括i），都要加上m[i]\r\npush直接放就行，inc的时候，要更新一下m数组，当k超过st的元素个数，那就更新当前有的就可以了\r\npop的时候，只要加上 当前st的大小去对应m中的值是多少，就是ans\r\n然后把当前m[i]的值更新到前一个去\r\n# 代码\r\n```cpp\r\nclass CustomStack {\r\npublic:\r\n    int mx;\r\n    vector<int> st,m;\r\n    //用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\n    CustomStack(int maxSize) {\r\n        st=vector<int>();\r\n        m=vector<int>(1001,0);\r\n        mx=maxSize;\r\n    }\r\n    //如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\n    void push(int x) {\r\n        if(st.size()==mx) return;\r\n        st.push_back(x);\r\n    }\r\n    //弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\n    int pop() {\r\n        if(st.empty()) return -1;\r\n        int idx=st.size();\r\n        int ans=st.back()+m[idx];\r\n        m[idx-1]+=m[idx];\r\n        m[idx]=0;\r\n        st.pop_back();\r\n        return ans;\r\n    }\r\n    //栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n    void increment(int k, int val) {\r\n         m[min(k,(int)st.size())]+=val;\r\n    }\r\n};\r\n```\r\n# 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maqianxiong":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916690979","body":"### 思路\n\n逐位相加，从最低位加到最高位，若是大于10，进位\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for(int i = n-1;i >= 0;i--){\n            int sum  = num[i] + k%10;\n            k/=10;\n            if(sum >=10){\n                k++;\n                sum -=10;\n            }\n            res.add(sum);\n        }\n        while(k > 0){\n            res.add(k%10);\n            k/=10;\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度 $O(maxlength(num,k))$\n- 空间复杂度 $O(1)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917318050","body":"### 思路\n\n官方题解\n\n从左向右遍历，记录等于c的位置prev，答案就是abs（i- prev）;\n\n从右向左遍历,   记录等于c的位置prev，答案就是abs（prev- i）。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int N  = s.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE/2;\n        for(int i = 0;i < N;i++){\n            if(s.charAt(i) == c){\n                prev = i;\n            }\n            ans[i] =Math.abs( i - prev);\n        }\n        prev = Integer.MIN_VALUE/2;\n        for(int i = N-1;i >=0;i--){\n            if(s.charAt(i) == c){\n                prev = i;\n            }\n            ans[i] = Math.min(ans[i],Math.abs(prev-i));\n        }\n        return ans;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917518851","body":"### 思路\n\n使用数组模拟栈，用一个变量 `top` 来记录当前栈顶的位置。\n\n### 代码\n\n```java\nclass CustomStack {\n    int[] stack ;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top != stack.length - 1){\n            top ++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top == -1){\n            return -1;\n        }\n        top--;\n        return stack[top+1];\n\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k,top+1);\n        for(int i = 0;i < limit;i++){\n            stack[i] += val;\n        }\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Menglin-l":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916691806","body":"### 思路\r\n---\r\n从低位往高位做加法，为避免最后结果需要反转，可选用LinkedList存储数字。\r\n\r\n### 代码\r\n---\r\n```Java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int leng = num.length - 1;\r\n\r\n        while (leng >= 0 || k != 0) {\r\n\r\n            if (leng >= 0) {\r\n                k += num[leng];\r\n                leng--;\r\n            }\r\n\r\n            res.addFirst(k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n---\r\nTime: O(max(N, K)), 由数组num长度和数字k的位数两者中的较大值决定\r\n\r\nSpace: O(1), 在原数组中操作，没有额外开销\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917360370","body":"### 思路：\r\n#### 1.首先要确定S中每个字符C的位置，可用一个ArrayList存储；\r\n#### 2.再次遍历数组S，用当前字符与目标字符依次比较，计算最短距离。\r\n---\r\n\r\n### 代码部分：\r\n```Java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        \r\n        ArrayList<Integer> position = new ArrayList<>();\r\n        int[] res = new int[s.length()];\r\n        int point = 0;\r\n        \r\n        for (int i = 0; i < s.length(); i ++) {\r\n            if (s.charAt(i) == c) position.add(i);\r\n        }\r\n        \r\n        for (int j = 0; j < s.length(); j ++) {\r\n            \r\n            while (point < position.size() - 1 && Math.abs(position.get(point) - j) > Math.abs(position.get(point + 1) - j)) {\r\n                point ++;\r\n            }\r\n            \r\n            res[j] = Math.abs(position.get(point) - j);\r\n            \r\n            point = 0;\r\n        }\r\n        \r\n        return res;\r\n        \r\n    }\r\n}\r\n```\r\n---\r\n\r\n### 复杂度分析：\r\n#### Time: O(n^2)，第二个for循环中包含一个while循环，最坏情况需要再遍历一次数组，为n * n，可优化为n（先打卡再优化）.\r\n#### Space: O(n)，创建一个ArrayList，最坏情况下长度为n.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917586499","body":"### 思路\r\n#### 朴素的数组实现，因为题中对maxSize有限，使用数组不需要担心过高的开销。\r\n---\r\n\r\n### 代码部分\r\n```Java\r\nclass CustomStack {\r\n\tprivate int[] stack;\r\n\tprivate int size;\r\n\r\n\tpublic CustomStack(int maxSize) {\r\n\t\tstack = new int[maxSize];\r\n\t\tsize = 0;\r\n\t}\r\n\r\n\tpublic void push(int x) {\r\n\t\tif (size < stack.length) {\r\n\t\t\tstack[size ++] = x;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic int pop() {\r\n\t\tif (size > 0) {\r\n\t\t\treturn stack[-- size];\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tpublic void increment(int k, int val) {\r\n\t\tfor (int j = 0; j < k && j < size; j ++) {\r\n\t\t\tstack[j] += val;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n---\r\n\r\n### 复杂度\r\n出栈入栈的Time: O(1)\r\nincrement的Time: O(n)\r\nSpace: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917697295","body":"### 思路：\r\n#### 因为方括号可能内嵌，需从最内层decode，可使用一个辅助栈：\r\n#### 1. 将字符依次入栈，遇到第一个']'时出栈，至第一个'['前的数字截止.\r\n#### 2. 根据数字解码得到相应的字符串。\r\n#### 3. 将完成解码后的字符串重新入栈。\r\n#### 4. 重复1-3中操作。\r\n---\r\n\r\n### 代码部分：\r\n```Java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n\r\n        if (s == null || s.length() == 0) {\r\n            return \"\";\r\n        }\r\n\r\n        Stack<Character> stack = new Stack<>();\r\n\r\n        for (char c : s.toCharArray()) {\r\n            if (c != ']') {\r\n                stack.push(c);\r\n                // 遇到']'\r\n            } else {\r\n                StringBuilder sb = new StringBuilder();\r\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) sb.insert(0, stack.pop());\r\n\r\n                String str = sb.toString();\r\n                stack.pop(); // 弹出匹配的'['\r\n\r\n                sb = new StringBuilder();\r\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) sb.insert(0, stack.pop());\r\n\r\n                int cnt = Integer.valueOf(sb.toString());\r\n\r\n                // 根据数字解码得到相应的字符串\r\n                while (cnt > 0) {\r\n                    for (char cc : str.toCharArray()) stack.push(cc);\r\n\r\n                    cnt --;\r\n                }\r\n            }\r\n        }\r\n\r\n        StringBuilder res = new StringBuilder();\r\n        while (!stack.isEmpty()) res.insert(0, stack.pop());\r\n\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n---\r\n\r\n### 复杂度：\r\n#### Time: O(n^2)\r\n#### Space: O(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hewenyi666":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916699491","body":"## 题目名称\n\n**989. 数组形式的整数加法**\n\n\n### 题目思路\n\n1.将 数字型数组 -> 字符串型数组  \n2.将数组中的字符串拼接, 用eval函数取出字符串中的数字 和 k 取和, 然后转为字符串  \n3.将字符串 -> 数字型的数组\n\n### code for python\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        list_str = [str(i) for i in num]\n        final_str = str(eval(\"\".join(list_str)) + k)\n        return [int(j) for j in final_str]\n\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(N)\n- 空间复杂度: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917401537","body":"## 题目名称\n\n**821. 字符的最短距离**\n\n\n### 题目思路\n- 遍历一遍字符串ｓ，获取记录预期字符ｃ在ｓ中所有位置的列表 list_e\n- 定义一个方法: 获取输入字符 和 列表中所有元素 所有差值中绝对值最小的那个值\n- 遍历字符串s，每遍历到一个字符时，调用一次自定义方法，记录到数组中\n\n### code for Python3\n\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        list_e = [i for i in range(len(s)) if s[i] == c]\n        arr = []\n        for j in range(len(s)):\n            arr.append(self.get_abs_minnum(j, list_e))\n        return arr\n\n    def get_abs_minnum(self, first_num:int, li:List):\n        cur = pow(10, 4)\n        for v in li:\n            cur = min(cur, abs(v - first_num))\n        return cur\n\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(N²)  \n　　原因: 双层循环, 每次遍历字符串s时,都会遍历一次list_e\n- 空间复杂度: O(N)   \n　　原因: list_e占用的空间大小和字符串s的长度有关\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917535705","body":"### 题目名称\n\n**1381. 设计一个支持增量操作的栈**\n\n### 题目链接\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n### 题目思路\nPython3用数组模拟栈操作\n\n### code for Python3\n\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.arr = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.arr) < maxSize:\n            self.arr.append(x)\n\n    def pop(self) -> int:\n        if self.arr:\n            return self.arr.pop()\n        else:\n            return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        if not self.arr:\n            return\n        elif len(self.arr) <= k:\n            for i in range(len(self.arr)):\n                self.arr[i] += val\n        else:\n            for i in range(k):\n                self.arr[i] += val\n\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(N)\n- 空间复杂度: O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JinMing-Gu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916700002","body":"【思路】\r\n要注意给定的数组位数过大时，数据大小超出整型数据范围。\r\n【代码】\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k)\r\n    {\r\n        int n = num.size();\r\n        long long a;\r\n        long long b = 0;\r\n        for(int i = 1; i <= n; i++)\r\n        {\r\n            double m = pow(10, n - i);\r\n            a = num[i - 1] * m;\r\n            b = b + a;\r\n        }\r\n        cout << b << endl;\r\n        cout << k << endl;\r\n        long long c = b + k;\r\n        cout << c << endl;\r\n        num.clear();\r\n        vector<int> rnum;\r\n        while(1)\r\n        {\r\n            if(c >= 10)\r\n            {\r\n                long long d = c % 10;\r\n                rnum.push_back(d);\r\n                c = c - d;\r\n                c = c / 10;\r\n            }\r\n            if(c < 10)\r\n            {\r\n                rnum.push_back(c);\r\n                break;\r\n            }\r\n        }\r\n        vector<int>::reverse_iterator riter;\r\n        for (riter = rnum.rbegin(); riter != rnum.rend(); riter++)\r\n            num.push_back(*riter);\r\n        for(auto it = num.begin(); it != num.end(); it++)\r\n            cout << *it << endl;\r\n        return num;\r\n        // reverse(rnum.begin(), rnum.end());\r\n        // for(auto it = rnum.begin(); it != rnum.end(); it++)\r\n        //     cout << *it << endl;\r\n        // return rnum;\r\n    }\r\n};\r\n```\r\n【复杂度】\r\n\r\n【参考】\r\nhttps://www.cnblogs.com/vranger/p/3502885.html","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917386239","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c)\r\n    {\r\n        vector<int> num;\r\n        int n = s.size();\r\n        for(int i = 0; i < n; i++)\r\n        {\r\n            if(s[i] == c)\r\n                num.push_back(i);\r\n        }\r\n        for(auto it = num.begin(); it != num.end(); it++)\r\n            cout << *it << endl;\r\n        int m = num.size();\r\n        vector<int> length;\r\n        vector<int> answer;\r\n        for(int i = 0; i < n; i++)\r\n        {\r\n            for(int j = 0; j < m; j++)\r\n            {\r\n                length.push_back(abs(num[j] - i));\r\n            }\r\n            cout << \"[\" << \" \";\r\n            for(auto it = length.begin(); it != length.end(); it++)\r\n                cout << *it << \" \";\r\n            cout << \"]\" << endl;\r\n            sort(length.begin(), length.end());\r\n            answer.push_back(length[0]);\r\n            length.clear();\r\n        }\r\n        return answer;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Bingbinxu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916700923","body":"**思路**\n将整数K作为移动的部分，不断与A的最后一位叠加，从而更新数组\n注意点：边界条件存在A>=K,和A<K的情况\n**代码**\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len = num.size()-1;\n        while(len>=0)\n        {\n            k = k + num[len];\n            num[len] = k % 10;\n            k = k / 10;\n            len--;\n        }\n        while(k>0)\n        {\n            num.insert(num.begin(),0);\n            num[0] = k % 10;\n            k = k /10;\n        }\n        return num;       \n    }\n};\n```\n**复杂度**\n时间复杂度O（N+max（0，K-N））\nwhile函数遍历N遍，若K超过N，还需要遍历K-N遍\n空间复杂度O（N+max（0，K-N））","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917339824","body":" **思路**\n 先找出数组s中含有c的字符下标\n 循环找出每个字符对应的c的下标距离，求出最短距离\n **代码**\n class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> cp;        \n        int len = s.size();\n        vector<int> sp; \n        for(int i = 0; i < len; i++)\n        {\n            if (s[i]== c)\n            {\n                cp.push_back(i);\n            }          \n        }\n       for(int i = 0; i < len; i++)\n        {\n            sp.push_back(abs(i -cp[0]));\n            for (int j =1; j < cp.size(); j ++)\n            {\n                int a = abs(i -cp[j]);\n                if(sp[i] > a)\n                {\n                    sp[i] = a;\n                }\n            }\n        }      \n       return sp;\n    }\n};\n **复杂度分析**\n 时间复杂度 循环遍历找出c，为O（N）；循环算距离O（N*K），K为s中含有c的个数\n 空间复杂度 O（N）","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917769897","body":"**思路**\r\n遇到数字执行10进制的数字计算，前一个比后一个多10倍\r\n遇到[进行压栈处理\r\n遇到]进行出站处理\r\n遇到普通字符，加上就行\r\n**代码**\r\n```\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        int num = 0;\r\n        string str = \"\";\r\n        string res = \"\";\r\n        stack<int> numstack;\r\n        stack<string> strstack;\r\n        int len = s.size();\r\n        for(int i = 0;i < len; i++)\r\n        {\r\n            if(s[i]>='0' && s[i]<='9')\r\n            {\r\n                num = 10*num + s[i] -'0';\r\n            }\r\n            else if(s[i]=='[')\r\n            {\r\n                numstack.push(num);\r\n                strstack.push(str);\r\n                num = 0;\r\n                str = \"\";\r\n            }\r\n            else if(s[i]==']')\r\n            {\r\n                int j = numstack.top();\r\n                numstack.pop();\r\n                for(int k = 0;k < j;k++ )\r\n                {\r\n                    strstack.top() += str;\r\n                }\r\n                str = strstack.top();\r\n                strstack.pop();\r\n            }\r\n            else\r\n            {\r\n                str +=s[i];\r\n            }\r\n\r\n        }\r\n        return str;\r\n\r\n    }\r\n};\r\n```\r\n**复杂度**\r\n时间复杂度遍历s，同时遍历里面重复[]的次数,复杂度为O（NUM的和）\r\n空间复杂度O([]里的lenth*num)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flame0409":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916703356","body":"### [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n**思路：**\n\n1. 尝试了转整数进行相加后再次转回数组，遇到了越界问题。\n2. 按位相加\n\n**Java代码**\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n       List<Integer> res = new ArrayList<>();\n       for(int i = num.length-1; i >= 0 || k > 0 ; i--){\n           if(i >=0 ){\n               k = k + num[i];\n           }\n           res.add(0,  k % 10);\n           k = k / 10;\n       }\n       return res;\n    }\n```\n\n时间复杂度：*O(max(n,k)*n)*\n\n空间复杂度：*O(1)*\n\n优化：\n\n1.res尾插入，在返回前进行reverse\n\n时间复杂度：O(max(*n*,*k*))\n\n2.使用LinkedList\n\n时间复杂度：O(max(*n*,*k*))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917360057","body":"class Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = -10000;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) loc = i;\n            ans[i] = i - loc;\n        }\n\n        prev = 10000;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) loc = i;\n            ans[i] = Math.min(ans[i], loc - i);\n        }\n\n        return ans;\n    }\n}\n空间复杂度：O（n）\n时间复杂度：O（n）：两次遍历\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917533178","body":"### 1381.设计一个支持增量操作的栈(91每日)\n\njava：\n\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n\n     public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top != stack.length -1){\n            ++top;\n            stack[top] = x;\n        }\n\n    }\n    \n    public int pop() {\n\t\tif(top == -1){\n            return -1;\n        }\n        top--;\n        return stack[top+1];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0; i<Math.min(k, top+1); i++){\n            stack[i] += val;\n        } \n    }\n}\n```\n\n时间复杂度：除increment为O(k)外，其余操作为O（1）\n\n空间复杂度：O(maxSize)\n\n优化：如何降时间复杂度？\n\n使用incre[top]来表示栈的最上面需要累加的内容，每次pop时候进行累加\n\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n    \n    int incre[];\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        incre = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top != stack.length -1){\n            ++top;\n            stack[top] = x;\n        }\n\n    }\n    \n    public int pop() {\n\t\tif(top == -1){\n            return -1;\n        }\n        \n        int num_pop = stack[top] + incre[top];\n        if(top != 0){\n            incre[top -1] += incre[top];\n        }\n        incre[top] = 0;\n        top--;\n        return num_pop;\n    }\n    \n    public void increment(int k, int val) {\n        if(Math.min(k-1, top) >= 0){\n            incre[Math.min(k-1, top)] += val;\n        }\n    }\n}\n```\n\n时间复杂度：increment下降为O(1)\n\n空间复杂度O(2*maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Zhi22":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916705363","body":"# 题目名称：989. 数组形式的整数加法\n## 题目链接：https://leetcode-cn.com/problems/add-to-array-form-of-integer/\n## 思路\n1. 将k转成和num格式一致的数组\n2. 从后向前将两个数组按位相加，并将结果保存至一个新建的数组的末尾，并用变量保存是否进位\n3. 将新建数组逆转并返回\n## 代码\n* python3\n```python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        k_str = str(k)\n        k_arr = []\n        for ch in k_str:\n            k_arr.append(int(ch))\n        addOne = 0\n        ret = []\n        while num or k_arr or addOne:\n            ret.append(0)\n            if k_arr:\n                ret[-1] += k_arr[-1]\n                k_arr.pop()\n            if num:\n                ret[-1] += num[-1]\n                num.pop()\n            ret[-1] += addOne\n            addOne = 1 if ret[-1] > 9 else 0\n            ret[-1] %= 10\n        ret.reverse()\n        return ret\n```\n## 算法复杂度\n- 时间：O(N)\n- 空间：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917428443","body":"# 题目名称：821. 字符的最短距离\n\n## 题目链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 思路\n双向遍历，取最小值\n## 代码\n* python3\n```python3\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ls = len(s)\n        prev = float('inf')\n        ans = [float('inf') for _ in range(ls)]\n        for i in range(ls):\n            if s[i] == c:\n                prev = i\n            ans[i] = abs(i - prev)\n        for i in range(ls - 1, -1, -1):\n            if s[i] == c:\n                prev = i\n            ans[i] = min(ans[i], abs(i - prev))\n        return ans\n```\n\n## 算法复杂度\n\n- 时间：O(2N)\n\n- 空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917656974","body":"## 思路\n用数组模拟栈，并用变量记录栈顶下标\n## 代码\n\n* python3\n\n```python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.arr = [0] * maxSize\n        self.top = -1\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if self.top < self.maxSize - 1:\n            self.top += 1\n            self.arr[self.top] = x\n\n    def pop(self) -> int:\n        if self.top >= 0:\n            self.top -= 1\n            return self.arr[self.top + 1]\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.top + 1)):\n            self.arr[i] += val\n```\n\n## 算法复杂度\n\n- 时间：push和pop均为O(1), increment为O(N)\n\n- 空间：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dongzegithub":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916708579","body":"# [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\r\n## 思路\r\n思路主要体现在加法模板：\r\n1. 和 = A的当前位 + B的当前位 + 进位\r\n2. 当前值 = 和 % 10\r\n3. 进位 = 和 / 10\r\n4. 循环条件： A/B所有位都遍历完成\r\n5. 最后检查一次进位，若不为0，则需要单独加一位\r\n\r\n## 代码\r\n```java\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int i = num.length - 1;\r\n        int carry = 0;\r\n        int sum = 0;\r\n        while (i >= 0 || k > 0) {\r\n            int n = i >= 0 ? num[i] : 0;\r\n            int m = k > 0 ? k % 10 : 0;\r\n            k = k/10;\r\n            i--;\r\n\r\n            sum = n + m + carry;\r\n            carry = sum / 10;\r\n            res.add(sum % 10);\r\n        }\r\n        if (carry != 0) {\r\n            res.add(carry);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n```\r\n\r\n## 复杂度分析\r\n**复杂度为O(N)**\r\nwhile循环的复杂度为  `O(n + m)`  \r\n最后反转复杂度为 `O(x/2)` \r\n综合起来算法复杂度为O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917367896","body":"# [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n## 较优思路（参考官方）\n1. 距离最近的字符只存在于该字符的左右两端\n2. 从左向右遍历，preIndex记录上一个c字符的位置，此时`i - preIndex`即为最小距离\n3. 从右向左遍历，preIndex记录上一个c字符的位置，此时`preIndex - i`即为最小距离\n\n**注意**\npreIndex的初始值要可以兼容未遍历到字符c时的情况\n\n## 代码\n```java\n    public int[] shortestToChar(String s, char c) {\n        int length = s.length();\n        char[] chars = s.toCharArray();\n        int[] res = new int[length];\n\n        int preIndex = -(length * 2);\n        for (int i = 0; i < length; i++) {\n            if (chars[i] == c) {\n                preIndex = i;\n            }\n            res[i] = i - preIndex;\n        }\n\n        preIndex = length * 2;\n        for (int i = length - 1; i >= 0; i--) {\n            if (chars[i] == c) {\n                preIndex = i;\n            }\n            res[i] = Math.min(res[i], preIndex - i);\n        }\n        return res;\n    }\n```\n\n## 复杂度分析\n**时间复杂度为O(N)**\n遍历了两次，每次需要执行N次，总的时间复杂度还是为O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917644205","body":"# [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n## 思路\n该题目在于实现三个方法，而每个方法都可以做到O(1)的时间复杂度\n总思路：使用`originStack`存储原始值，使用`incrementArr`存储增值操作\n1. push： 将原始值入栈(originStack)\n2. pop: 栈不为空时，取出栈顶；此时需要把栈顶的increment向下传递  \n3. increment: 将增值记录在最上层元素对应的index上，保证可以向下传递\n\n## 代码\n```java\npublic class CustomStack {\n    private Stack<Integer> originStack = new Stack<>();\n\n    private int[] incrementArr;\n\n    private int maxSize;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        incrementArr = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (originStack.size() >= maxSize) {\n            return;\n        }\n        originStack.push(x);\n        // 新元素入栈，清空之前增量数组中的缓存值\n        incrementArr[originStack.size() - 1] = 0;\n    }\n\n    public int pop() {\n        if (originStack.isEmpty()) {\n            return -1;\n        }\n        int index = originStack.size() - 1;\n        int origin = originStack.pop();\n        if (index > 0) {\n            incrementArr[index - 1] = incrementArr[index - 1] + incrementArr[index];\n        }\n        return origin + incrementArr[index];\n    }\n\n    public void increment(int k, int val) {\n        if (k <= 0 || originStack.isEmpty()) {\n            return;\n        }\n        int index = Math.min(originStack.size(), k) - 1;\n        incrementArr[index] += val;\n    }\n\n    public int pop1() {\n        if (originStack.empty()) {\n            return -1;\n        }\n        int index = originStack.size() - 1;\n        int origin = originStack.pop();\n        // pop时，需要pop栈顶 + 增量数组当前值\n        return origin + incrementArr[index];\n    }\n\n    public void increment1(int k, int val) {\n        if (k <= 0) {\n            return;\n        }\n        int capacity = Math.min(originStack.size(), k);\n        for (int i = 0; i < capacity; i++) {\n            incrementArr[i] += val;\n        }\n    }\n}\n```\n\n## 复杂度分析\n所有操作的**时间复杂度为O(1)**\n空间复杂度为O(maxSize)：开辟了一个maxSize大小的辅助数组  \n**注：**为了使常数时间最小，还可以使用数组结构代替栈","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916714070","body":"### 思路\r\n两数和按位相加的思路\r\n### js代码\r\n```JavaScript\r\n    let n = num.length-1,carry=0,res=[]\r\n    while(n>=0||k!=0){\r\n        const a = n>=0?num[n]:0\r\n        const b = k!=0?k%10:0\r\n        const sum = a+b+carry\r\n        carry = Math.floor(sum / 10)\r\n        res.push(sum%10)\r\n        n--\r\n        k = Math.floor(k / 10)\r\n    }\r\n    if (carry) res.push(carry)\r\n    return res.reverse()\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n + logk +reverse的长度 )，其中 n 为数组的长度；k以10为底的对数操作次数，来自于reverse的时间消耗\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917419827","body":"### 思路\r\n贪心\r\n\r\n### js代码\r\n```JavaScript\r\nvar shortestToChar = function(s, c) {\r\n  let res = []\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (s[i] === c) res[i] = i;\r\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1];\r\n  }\r\n\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    if (res[i] === Infinity || res[i + 1] - i < i - res[i]) res[i] = res[i + 1];\r\n  }\r\n\r\n  for (let i = 0; i < res.length; i++) {\r\n    res[i] = Math.abs(res[i] - i);\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n )\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917630119","body":"### 思路\n用js的数组操作去实现栈\n### js代码\n```JavaScript\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length >= this.maxSize) {\n        return;\n    }\n    this.stack.push(x);\n};\n\nCustomStack.prototype.pop = function() {\n    return this.stack.length ? this.stack.pop() : -1;\n};\n\nCustomStack.prototype.increment = function(k, val) {\n    let length = Math.min(k, this.stack.length);\n    for (let i = 0; i < length; i++) {\n        this.stack[i] += val;\n    }\n};\n\n```\n### 复杂度分析\n- 时间复杂度 push:O(1)、pop：O(1)、increment：O(N) ，N为min(K， 栈中元素的个数)\n- 空间复杂度：O(N)，N为maxSize","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"GReyQT":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916716466","body":"## 思路\r\n直接在数组中相加，标记进位符号，对进位处进行处理\r\n\r\n\r\n## cpp\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n\r\n        bool up = false;    //进位标识符\r\n\r\n        vector<int> numk;\r\n        while (k > 0)\r\n        {\r\n            numk.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        reverse(numk.begin(), numk.end());  //逆转，尾部为个位数\r\n\r\n        vector<int> res;\r\n        num.size() >= numk.size() ? res = num: (res = numk,numk=num);\r\n\r\n        for (auto it = res.rbegin(); it != res.rend(); ++it)    //从个位开始相加\r\n        {\r\n            if (up)\r\n            {\r\n                *(it - 1) %= 10;\r\n                if ((*it += 1) >= 10)\r\n                {\r\n                    up = true;\r\n                }\r\n                else\r\n                {\r\n                    up = false;\r\n                }\r\n                \r\n            }\r\n\r\n            if (numk.size() > 0)\r\n            {\r\n                if ((*it += numk.back()) >= 10) \r\n                {\r\n                    up = true;\r\n                }\r\n\r\n                numk.pop_back();        //尾出\r\n            }\r\n\r\n        }\r\n\r\n\r\n        if (up) //表示头部需要进位\r\n        {\r\n            reverse(res.begin(), res.end());    //将头部置尾\r\n\r\n            auto it = res.end()-1;\r\n\r\n            *it %= 10;  //求余\r\n\r\n            res.push_back(1);   //尾插\r\n\r\n            reverse(res.begin(), res.end());    //恢复\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n## 复杂度分析\r\n-     时间复杂度：O(n + logk +reverse的长度 )，其中 n 为数组的长度；k以10为底的对数操作次数，来自于reverse的时间消耗\r\n-     空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917363774","body":"## 思路\r\n获取下标，进行下标相减取最小\r\n\r\n## cpp\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n\r\n        vector<int> ac,res;\r\n        int length = s.size();\r\n\r\n        for(int i=0; i < length; ++i)   //获取字符串的下标，及字符C的下标\r\n        {\r\n            res.push_back(i);\r\n            if(c == s[i])\r\n                ac.push_back(i);\r\n        }\r\n\r\n        for(auto it = res.begin(); it != res.end(); ++it)   //使字符串的下标减去字符C的下标并取最小值\r\n        {\r\n            int min = length;\r\n            for(auto at = ac.begin(); at != ac.end(); ++at)\r\n            {\r\n                int temp = abs((*it)-(*at));\r\n                if(min >= temp)\r\n                    min = temp;\r\n            }\r\n            *it = min;\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n## 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917545294","body":"## 思路\r\n取巧使用自带的vector\r\n## cpp\r\n```cpp\r\nclass CustomStack {\r\nprivate:\r\n    int _size;\r\n    int _maxsize;\r\n    vector<int> stack;\r\n    \r\npublic:\r\n    CustomStack(int maxSize) {\r\n        _maxsize=maxSize;\r\n        _size=0;\r\n        \r\n    }\r\n    \r\n    void push(int x) {\r\n        if(_size < _maxsize)\r\n        {\r\n            stack.push_back(x);\r\n            _size++;\r\n        }            \r\n\r\n    }\r\n    \r\n    int pop() {\r\n        if(0 == stack.size())\r\n            return -1;\r\n        \r\n        int re = stack.back();\r\n        \r\n        stack.pop_back();\r\n        _size--;                   \r\n        \r\n        return re;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        if(k > stack.size())\r\n            k=stack.size();\r\n            \r\n        int count=0;\r\n        for(auto it = stack.begin(); it != stack.end(); ++it)\r\n        {\r\n            if(count == k)\r\n                break;\r\n                \r\n            *it += val;\r\n            count++;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```\r\n##复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916722801","body":"## 思路\n\n-\t从后往前加，记录进位，注意 k > n 的情况\n\n\n## 代码\n\n\n```\nvector<int> addToArrayForm_0(vector<int> &num, int k)\n{\n    vector<int> res;\n    // 从后往前加，记录进位\n    int flag = 0;\n    int i = num.size() - 1;\n    while(k || (i >= 0))\n    {\n        int tmp;\n        if (i >= 0)\n            tmp = num[i] + k % 10 + flag;\n        else\n        {\n            tmp = k % 10 + flag;\n        }\n        k = k / 10;\n        if(tmp > 9)\n        {\n            tmp = tmp % 10;\n            flag = 1;\n        }\n        else\n        {\n            flag = 0;\n        }\n        res.push_back(tmp);\n        i--;\n    }\n    if (flag)\n        res.push_back(1);\n\n    for (int i = 0; i < res.size() / 2; i++)\n    {\n        int tmp;\n        tmp = res[i];\n        res[i] = res[res.size() - i - 1];\n        res[res.size() - i - 1] = tmp;\n    }\n    return res;\n}\n\n```\n-\t时间复杂度: O(N)，空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917370770","body":"\r\n```\r\nvector<int> shortestTochar(string s, char c)\r\n    {\r\n        vector<int> res, index;\r\n        int len = s.length();\r\n        for(int i = 0; i < len; i++)\r\n        {\r\n            if(s[i] == c)\r\n            {\r\n                index.push_back(i);\r\n            }\r\n        }\r\n        int p = 0;\r\n        for (int i = 0; i < len; i++)\r\n        {\r\n            if (s[i] != c)\r\n            {\r\n                // 出现在第一个c的最左边\r\n                if (p == 0)\r\n                {\r\n                    res.push_back(abs(index[p] - i));\r\n                }\r\n                else  // 出现在中间\r\n                {\r\n                    if (i < index[p])\r\n                        res.push_back(((i - index[p - 1]) < (index[p] - i) ? (i - index[p - 1]) : (index[p] - i)));\r\n                    else\r\n                        res.push_back(i - index[p]);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                res.push_back(0);\r\n                if (p < index.size() - 1)\r\n                    p++;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n```\r\n-\t时间复杂度: O(N)，空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917619488","body":"```\nclass CustomStack {\npublic:\n    CustomStack(int maxSize)\n    {\n        maxsize = maxSize;\n        data = {};\n        inc = {};\n        len = 0;\n    }\n\n    void push(int x)\n    {\n        if (len < maxsize)\n        {\n            data.push_back(x);\n            inc.push_back(0);\n            len++;\n        }\n    }\n\n    int pop()\n    {\n        if (len)\n        {\n            len--;\n            int res = data[len] + inc[len];\n            if (len)\n                inc[len - 1] += inc[len];\n            data.pop_back();\n            inc.pop_back();\n            return res;\n        }\n        return -1;\n    }\n\n    void increment(int k, int val)\n    {\n        if (k <= len)\n            inc[k-1] += val;\n        else\n            if (len)\n                inc[len-1] += val;\n    }\nprivate:\n    int maxsize;\n    vector<int> data;\n    vector<int> inc;\n    int len;\n};\n\n```\n-\t时间复杂度: O(1)，空间复杂度：O(len / N)，N为操作数，len为栈的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Huangxuang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916726896","body":"# 题目：[989. 数组形式的整数加法]([https://leetcode.com/problems/add-to-array-form-of-integer/](https://leetcode.com/problems/add-to-array-form-of-integer/))\r\n\r\n### 思路\r\n\r\n- 如果转换成int在相加会越界\r\n- 先转换成 array 然后再用array 相加\r\n- 今天来不及了，明天改进一下，直接用arry 和数字相加\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        \r\n        //convert K to array type\r\n        ArrayList k_array = intToArray(k);\r\n        //add two arry together and return \r\n        return arraySum (num, k_array);\r\n    }\r\n    \r\n    private ArrayList<Integer> intToArray(int k) {\r\n        ArrayList <Integer> res = new ArrayList();\r\n        if (k == 0) {\r\n            res.add(0);\r\n            return res;\r\n        }\r\n        while (k > 0) {\r\n            int reminder = k % 10;\r\n            res.add(reminder);\r\n            k /= 10;\r\n        }\r\n        //reverse \r\n        ArrayList<Integer> reversed = new ArrayList();\r\n        for (int i = res.size() - 1; i >= 0; i--) {\r\n            reversed.add(res.get(i));\r\n        }\r\n        \r\n        return reversed;\r\n    }\r\n    \r\n    private ArrayList<Integer> arraySum(int[] num, ArrayList<Integer> x) {\r\n        ArrayList<Integer> res = new ArrayList();\r\n        int N = num.length; \r\n        int L = x.size();\r\n        int carray = 0;\r\n        for (int i = 0; i < Math.min(N, L); i++) {\r\n            int sum = num[N - 1 - i] + x.get(L -1 -i)+ carray;\r\n            res.add(sum % 10);\r\n            carray = sum / 10;\r\n            //carray = sum > 9 ? 1 :0;          \r\n        }\r\n        // add all other numbers directly, count carray in \r\n        if (N > L) {\r\n            //num[N - L - 1]  += carray;\r\n            for (int i = N - L - 1; i >= 0; i--) {\r\n                int sum = num[i] + carray;\r\n                res.add(sum % 10);\r\n                carray = sum / 10;\r\n            }\r\n        } \r\n        if (N < L) {\r\n            for (int i = L - N - 1; i >= 0; i--) {\r\n                int sum =  x.get(i) + carray;\r\n                res.add(sum % 10);\r\n                carray = sum / 10;\r\n            }\r\n        }      \r\n        if (carray == 1) {\r\n            res.add(1);\r\n        }\r\n    \r\n        \r\n        Collections.reverse(res);\r\n        return res;\r\n        \r\n    } \r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- \r\n\r\n### attention！\r\n\r\n**int 是2进制的32bit, 10位十进制的数，long是64位，20位10进制的数**","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917566049","body":"# 题目：[1381. Design a Stack With Increment Operation]([https://leetcode.com/problems/design-a-stack-with-increment-operation/](https://leetcode.com/problems/design-a-stack-with-increment-operation/))\r\n\r\n### 思路\r\n\r\n- 用linkedlist 来实现\r\n- \r\n\r\n### 代码\r\n\r\n```java\r\nclass CustomStack {\r\n    public LinkedList<Integer> list;\r\n    public int maxSize;\r\n    public int size;\r\n\r\n    public CustomStack(int maxSize) {\r\n        // use linked list to implement this stack, always add element to the end, \r\n        //and get element from the end; then bottom k element are the first k element\r\n        list = new LinkedList();\r\n        this.maxSize = maxSize;\r\n        size = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (size >= maxSize) {\r\n            return;\r\n        }\r\n        list.add(x);\r\n        size++;\r\n    }\r\n    \r\n    public int pop() {\r\n        if (size > 0) {\r\n            size--;\r\n            return list.pollLast(); \r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int l = Math.min(k, size);\r\n        for (int i = 0; i < l; i++) {\r\n            list.set(i, list.get(i) +val);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- increment的时间复杂度是On，其他是O1","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Wu-zonglin":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916730474","body":"### 思路\n数据类型转换\n### 代码\n~~~ python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sum = int(''.join(map(str, num)))+k\n        return list(map(int,str(sum)))\n~~~\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917408062","body":"### 思路\n前后指针\n~~~ python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = []\n        cur = s.find(c)\n        pre = -float('inf')\n        for i in range(len(s)):\n            if i == cur and c in s[cur+1:] :\n                pre = cur\n                cur += 1 + s[cur+1:].find(c)\n                res.append(0)\n            else:\n                res.append(abs(i-cur) if abs(i-cur) <= abs(i-pre) else abs(i-pre))\n        return res\n~~~\n### 复杂度分析\n- 时间复杂度：`O(n)`\n- 空间复杂度：`O(n)`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JAYWX":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916738912","body":"# 思路\nK与num转化为列表  \n准备一个接收列表\n\n两列表同时从末尾往前根据索引取值  \n两值相加的结果c,  \n\n如果 c大于等于10,  \n十位用sum记录，为前一位计算做记录\n\n如果 c小于10，  \nsum记得清零\n\nc的个位加入接收列表\n\n注：循环结束记得把不为0的sum加入接收列表\n\n接收列表末尾为结果首位，最后把列表reverse一次\n\n\n# 代码\n```python\nfrom typing import List\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        A = num\n        a_len = len(A)\n        B = list(int(i) for i in str(k))\n        b_len = len(B)\n        big_num = max(a_len, b_len)\n\n        sum = 0\n        index_sum = 0\n        res = []\n        for i in range(big_num):\n            index_sum -= 1\n            a = 0 if a_len < abs(index_sum) else A[index_sum]\n            b = 0 if b_len < abs(index_sum) else B[index_sum]\n            c = a + b + sum\n            if c >= 10:\n                sum = c // 10 % 10\n                c = c // 1 % 10\n            else:\n                sum = 0\n            res.append(c)\n\n        if sum:\n            res.append(sum)\n\n        res.reverse()\n        return res\n```\n## 复杂度分析\n令 n 为数组长度。\n\n时间复杂度：$O(n)$  \n空间复杂度：$O(n)$  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917351718","body":"# 思路\n找到所有c字符在s列表的索引, 放入一个列表 c_index_lst\n变量start和变量end表示在c_index_lst中的索引，\n根据s中的索引值i，与start和end做减法取绝对值，找到最小值，加入结果集res，\n当最小值为0时，start和end往前进一位，即start, end = end, end + 1，\n注意c_index_lst索引的边界值\n\n# 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        c_index_lst = []\n        _x = 0\n        for i in s:\n            if i == c:\n                c_index_lst.append(_x)\n            _x += 1\n\n        start = float('-inf')\n        c_index = 0\n        end = c_index_lst[c_index]\n        index = 0\n        res = []\n        for i in s:\n            c = min(abs(start - index), abs(end - index))\n            print(c)\n            res.append(c)\n            if c == 0:\n                start = end\n                if c_index + 1 < len(c_index_lst):\n                    c_index += 1\n                end = c_index_lst[c_index]\n            index += 1\n\n        return res\n```\n## 复杂度分析\n时间复杂度：$O(n)$  \n空间复杂度：$O(n)$  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917535841","body":"## 思路\n使用list构造栈；  \n为了在increment时，复杂度为O(1)，多用了一个列表，存val，  \n只有在pop时再计算输出的值；  \n空间换时间  \n\n注：  \npush时，incrementals列表append(0);  \npop时，需要判断好边界条件，incrementals列表的-2项元素等于自身加-1项\n\n\n## 代码 \n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n        self.size = 0\n        self.incrementals = []\n\n    def push(self, x: int) -> None:\n        if self.size != self.maxSize:\n            self.stack.append(x)\n            self.incrementals.append(0)\n            self.size += 1\n\n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n        self.size -= 1\n        if self.size > 0:\n            self.incrementals[-2] += self.incrementals[-1]\n        return self.incrementals.pop() + self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.incrementals:\n            self.incrementals[min(self.size, k) - 1] += val\n\n```\n### 复杂度分析\n时间复杂度：$O(1)$  \n空间复杂度：$O(n)$  ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaowenhe":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916747421","body":"```CPP\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int n = num.size() - 1;\n        int cur = k;\n        vector<int> result;\n        while(n >= 0 || cur)\n        {\n            if(n>=0)\n            {\n                cur = cur + num[n];\n            }\n            result.push_back(cur%10);\n            cur = cur / 10;\n            n--;\n        }\n        reverse(result.begin(), result.end());\n        return result;\n\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917373473","body":"## 思路\r\n分别左右遍历，取最小\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n\r\n\r\n        results = []\r\n        pos = float('-inf')\r\n        for i in range(len(S)):\r\n            if S[i] == C:\r\n                pos = i\r\n            results.append(i - pos)\r\n        pos = float('inf')\r\n        for i in range(len(S)-1,-1,-1):\r\n            if S[i] == C:\r\n                pos = i\r\n            results[i] = min(results[i],(pos - i))\r\n        return results\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917620191","body":"```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self._maxSize = maxSize\r\n        self._stack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if (len(self._stack) < self._maxSize):\r\n            self._stack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self._stack) > 0:\r\n            return self._stack.pop()\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self._stack))):\r\n            self._stack[i] += val\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mglslg":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916756192","body":"时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n```java\r\n    /**\r\n     * 先前试图抖机灵将数组转换为数字然后加k再转回来\r\n     * 结果分分钟被测试用例[9,9,9,9,9,9,9,9,9,9]教做人\r\n     * 数组越界，只能乖乖按位相加了哎~~~\r\n     * 技巧：线性表从左向右增长使用Array，从右向左增长使用LinkedList::addFirst\r\n     * 这样就不必使用stack倒来倒去\r\n     */\r\n    class Solution {\r\n        public List<Integer> addToArrayForm(int[] num, int k) {\r\n            if (num.length == 0) {\r\n                return numToList(k);\r\n            }\r\n            LinkedList<Integer> result = new LinkedList<>();\r\n            int carry = 0;\r\n            int size = num.length;\r\n            LinkedList<Integer> kNum = numToList(k);\r\n            while (!kNum.isEmpty()) {\r\n                if (size > 0) {\r\n                    int x = kNum.pollLast() + num[size - 1];\r\n                    result.addFirst((x + carry) % 10);\r\n                    carry = (x + carry) / 10;\r\n                    size--;\r\n                } else {\r\n                    int x = kNum.pollLast();\r\n                    result.addFirst((x + carry) % 10);\r\n                    carry = (x + carry) / 10;\r\n                }\r\n            }\r\n            while (size > 0) {\r\n                int x = num[size - 1];\r\n                result.addFirst((x + carry) % 10);\r\n                carry = (x + carry) / 10;\r\n                size--;\r\n            }\r\n            if (carry > 0) {\r\n                result.addFirst(1);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        private LinkedList<Integer> numToList(int num) {\r\n            LinkedList<Integer> list = new LinkedList<>();\r\n            while (num / 10 > 0) {\r\n                list.addFirst(num % 10);\r\n                num = num / 10;\r\n            }\r\n            list.addFirst(num % 10);\r\n            return list;\r\n        }\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HouHao1998":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916760585","body":" public List<Integer> addToArrayForm(int[] num, int k) {\n\t\tList<Integer> sumList =new ArrayList<>();\n    \tif(num.length==1&&num[0]==0&&k==0){\n\t\t\tsumList.add(0);\n    \t\treturn sumList;\n\t\t}\n\t\tList<Integer> kList =new ArrayList<>();\n\t\twhile (k/10!=0){\n\t\t\tkList.add(k%10);\n\t\t\tk = k/10;\n\t\t}\n\t\tkList.add(k%10);\n\t\tint nl =num.length;\n\t\tint[] num2 = new int[nl];\n\t\tfor (int a:num) {\n\t\t\tnum2[--nl]=a;\n\t\t}\n\t\tnl =num.length-1;\n\t\tint kl =kList.size()-1;\n\t\tint go =0;\n\t\tint sun =0;\n\t\tint[] sum;\n\t\tsum =new int[Math.max(nl,kl)+2];\n\t\tfor (int i = 0; i <= Math.max(nl,kl); i++) {\n\t\t\tif(i<=nl&&i<=kl){\n\t\t\t\tsun = kList.get(i)+num2[i]+go;\n\t\t\t}else {\n\t\t\t\tsun = nl>kl?num2[i]+go:kList.get(i)+go;\n\t\t\t}\n\t\t\tsum[i]=sun%10;\n\t\t\tgo=sun/10;\n\t\t}\n\t\tif(go!=0){\n\t\t\tsum[sum.length-1]= go;\n\t\t}\n\n\t\tboolean a= true;\n\t\tfor (int i = sum.length-1; i >=0; i--) {\n\t\t\tif(sum[i]==0&&a){\n\t\t\t\tcontinue;\n\t\t\t}else {\n\t\t\t\ta=false;\n\t\t\t}\n\t\t\tsumList.add(sum[i]);\n\t\t}\n\treturn sumList;\n    }\n## 思路\n把数字变成倒叙数组，数组也直接倒叙，进位相加，再次倒叙\n复杂度分析\n\n数字或数组最长为n\n复杂度O（N）\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917426557","body":"**思路**\r\n双指针写法，遍历一次得到最优解\r\n```\r\n    public int[] shortestToChar(String s, char c) {\r\n\r\n    \tint[] arr= new int[s.length()];\r\n\t\tList<Integer> list = new ArrayList<>();\r\n\t\tfor (int i = 0; i <s.length(); i++) {\r\n\t\t\tif (s.charAt(i)==c){\r\n\t\t\t\tlist.add(i);\r\n\t\t\t}\r\n\t\t}\r\n\t\tint l =0 ;\r\n\t\tint r =list.get(0) ;\r\n\t\tint ln =0 ;\r\n\t\tfor (int i = 0; i <s.length(); i++) {\r\n\t\t\tif(l==0&&i<r&&list.get(0)!=0){\r\n\t\t\t\tarr[i]=r-i;\r\n\t\t\t} else if(i==r){\r\n\t\t\t\tif(ln<list.size()-1) {\r\n\t\t\t\t\tl = r;\r\n\t\t\t\t\t++ln;\r\n\t\t\t\t\tr = list.get(ln);\r\n\t\t\t\t\tarr[i] = 0;\r\n\t\t\t\t}else {\r\n\t\t\t\t\tl=r;\r\n\t\t\t\t\tr=0;\r\n\t\t\t\t\tarr[i] = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t}else {\r\n\t\t\t\tarr[i]=Math.min(Math.abs(i-l), Math.abs(r-i));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn arr;\r\n    }\r\n```\r\n时间复杂度\r\nO（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917439405","body":"### 思路\r\n用数组实现，记录栈顶的大小\r\n### 代码\r\n```\r\nclass CustomStack {\r\n\t    int [] stack;\r\n\t    int now ;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack =new int[maxSize];\r\n        now=-1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(now<stack.length-1){\r\n            stack[++now]=x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(now==-1||stack==null){\r\n            return -1;\r\n        }\r\n        int p = stack[now];\r\n        now--;\r\n        return p;\r\n\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < k; i++) {\r\n            if(i<=now){\r\n                stack[i]=stack[i]+val;\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n时间复杂度查询插入都是O1\r\n累加是O（k）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AruSeito":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916761326","body":"## 思路\r\n将k拆成数组，按照竖式相加的方式进行每位相加，如果相加和大于等于10，那么当前位取10的余数，前一位进1。如果是最后一位大于10，要在前面进行补加一位。\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  let kArray = k\r\n    .toString()\r\n    .split(\"\")\r\n    .map((kNum) => Number(kNum));\r\n  let flag = false;\r\n  const maxLength = Math.max(num.length, kArray.length);\r\n  while (kArray.length < maxLength) kArray.unshift(0);\r\n  while (num.length < maxLength) num.unshift(0);\r\n  for (let i = maxLength - 1; i >= 0; i--) {\r\n    let tmpSum = num[i] + kArray[i];\r\n    if (tmpSum >= 10) {\r\n      if (i - 1 < 0) {\r\n        flag = true;\r\n        kArray.unshift(0);\r\n      }\r\n      kArray[i - 1 < 0 ? i : i - 1] += 1;\r\n      tmpSum = tmpSum % 10;\r\n    }\r\n    kArray[flag ? i + 1 : i] = tmpSum;\r\n  }\r\n\r\n  return kArray;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(3m-n+Max(m,n))$ m代表k的位数，n代表num的长度，对k进行拆分的时候split是一个m，map又一个m，再两个位数补全的时候是|m-n|\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917343698","body":"## 思路\r\n暴力法：直接遍历一遍，把出现过的每个索引存起来。然后再遍历s，计算出每个字符跟每个索引的差值，将最小值放到结果里。\r\n\r\n## 代码\r\n\r\n```javascript\r\nvar shortestToChar = function(s, c) {\r\n    let index = [],res=[],i=0;\r\n    for(let i = 0 ; i < s.length;i++){\r\n        if(s[i] === c){\r\n            index.push(i);\r\n        }\r\n    }\r\n    for(let i = 0 ; i < s.length;i++){\r\n        let tmp = Number.MAX_SAFE_INTEGER\r\n        for(let j = 0 ; j <index.length;j++){\r\n            tmp = Math.min(tmp,Math.abs(index[j]-i))\r\n        }\r\n        res.push(tmp)\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n时间复杂度： O（N）；\r\n空间复杂度：O（N）；其实是O（2N）？？？最坏的时候index里把每个字符的索引都存了，再加上结果值，N足够大的时候常数就被省略了。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917565302","body":"## 思路：\r\n简单的栈实现。\r\n## 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.stack = new Array(maxSize);\r\n    this.maxSize = maxSize;\r\n    this.index = 0;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.index < this.maxSize){\r\n        this.stack[this.index++] = x; \r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(this.index !==0){\r\n        return this.stack.splice(--this.index,1)\r\n    }\r\n    return -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(let i = 0 ; i<this.index && k>0;i++,k--){\r\n        this.stack[i] = this.stack[i]+val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917820752","body":"## 思路\n遇到非]进栈，遇到]就出栈，遇到[前将出栈的拼成一个字符串，然后[之前的所有数字都出栈拼成重复次数，按照重复次数重复前面拼成的字符串，拼成的结果再放到栈里去，最终结果就是栈里的各个项拼成的字符串\n```javascript\nvar decodeString = function (s) {\n  const stack = [];\n  for (let i = 0; i < s.length; i++) {\n    switch (s[i]) {\n      case \"]\": {\n        let str = \"\";\n        while (stack[stack.length - 1] !== \"[\") {\n          str = stack.pop() + str;\n        }\n        stack.pop();\n        let number = 0,\n          count = 0;\n        while (stack[stack.length - 1] >= 0 && stack[stack.length - 1] <= 9) {\n          number = number + stack.pop() * Math.pow(10, count++);\n        }\n        let sum = \"\";\n        while (number > 0) {\n          sum += str;\n          number--;\n        }\n        stack.push(sum);\n        break;\n      }\n      default: {\n        if (Number(s[i]) >= 0 && Number(s[i]) <= 9) {\n          stack.push(Number(s[i]));\n        } else {\n          stack.push(s[i]);\n        }\n      }\n    }\n  }\n  return stack.join(\"\");\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BreezePython":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916762658","body":"## 思路\r\n\r\n数学题…\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num, k) :\r\n        n = reduce(lambda x, y: x * 10 + y, num) + k\r\n        return [0] if n == 0 else [int(i) for i in str(n)]\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917021301","body":"## 思路\n1. 既然我们需要找到最短距离，那么首先应该获取到该字符在字符串 s 中的所有下标位置。\n2. 使用O(n)的时间遍历一次字符串，并将等于目标字符的下标添加至动态数组arr中。\n3. 初始化指针p，指向arr的0位置\n4. 创建 ret 数组，长度为len(s)\n5. 再次遍历s的过程中，我们需要判断当满足以下两点条件时，指针 p 右移一位\n   1. p小于arr最大下标\n   2. 前下标i 到 p + 1的绝对距离比到 p 的绝对距离小\n6. 每次将 p - i 的绝对距离添加至 ret[i] 中\n7. 最终返回ret即可\n\n## 代码\n**Python:**\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ret, p, arr = [], 0, [i for i in range(len(s)) if s[i] == c]\n        for i, j in enumerate(s):\n            if p < len(arr) - 1 and abs(arr[p] - i) > abs(arr[p + 1] - i):\n                p += 1\n            ret.append(abs(arr[p] - i))\n        return ret\n```\n**Java:**\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> arr = new ArrayList<>();\n        int[] ret = new int[s.length()];\n        int p = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) arr.add(i);\n        }\n        for (int i = 0; i < s.length(); i++) {\n            if (p < arr.size() - 1 && Math.abs(arr.get(p) - i) > Math.abs(arr.get(p + 1) - i)) p++;\n            ret[i] = Math.abs(arr.get(p) - i);\n        }\n        return ret;\n    }\n}\n```\n## 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917590927","body":"## 思路\n\n二维数组记录增量值\n\n## 代码\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.size = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) == self.size:\n            return\n        self.stack.append([x, 0])\n\n    def pop(self) -> int:\n        if self.stack:\n            x, val = self.stack.pop()\n            if self.stack:\n                self.stack[-1][1] += val\n            return x + val\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if not self.stack:\n            return\n        k = min(len(self.stack), k)\n        self.stack[k - 1][1] += val\n```\n## 复杂度\n- 时间复杂度： O(1)\n- 空间复杂度： O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HZHENGZHI":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916763651","body":"**思路** \n模拟手算加法过程。当两数之和小于10，则直接加入到list中，当遇到两数之和大于10的时候，需要将1带入进行运算\n\n**代码**\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> linkedList=new LinkedList<>();\n        int temp=0;\n        for (int i = num.length-1; i >=0; i--) {\n            temp=k%10;\n            k=k/10;\n            if(num[i]+temp>=10)\n            {\n                k++;\n                linkedList.addFirst((temp+num[i])%10);\n            }\n            else\n            {\n                linkedList.addFirst(temp+num[i]);\n            }\n            if(i==0)\n            {\n                while (k!=0)\n                {\n                    temp=k%10;\n                    k=k/10;\n                    linkedList.addFirst(temp);\n                }\n            }\n        }\n        return linkedList;\n    }\n```\n**复杂度分析**\nn为num长度，m为k的长度\n+ 空间复杂度$O(n)$\n+ 空间复杂度$O(max(n,m-n))$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917309006","body":"**思路**\n每一次都查找到距离当前字符最近的字符c的位置，进行相减处理。当减到自己为0后，查找下一个字符c所在位置\n**代码**\n```java\npublic int[] shortestToChar(String s, char c) {\n        int []ans=new int[s.length()];\n        char chars[]=s.toCharArray();\n        int j=0;\n        int temp=0;\n        for (int i = 0; i < chars.length; i++) {\n            while (j<chars.length &&chars[j]!=c  )\n            {\n                j++;\n            }\n            if(i-j!=0)\n            {\n                if(j<chars.length && chars[temp]==c &&chars[j]==c)\n                {\n                    ans[i]=Math.min(Math.abs(temp-i),Math.abs(j-i));\n\n                }\n                else if(j<chars.length && chars[j]==c)\n                {\n                    ans[i]=Math.abs(i-j);\n                }\n                else if(chars[temp]==c)\n                {\n                    ans[i]=Math.abs(temp-i);\n                }\n            }\n            if(i-j==0)\n            {\n                ans[i]=0;\n                temp=j;\n                j++;\n            }\n        }\n        return ans;\n    }\n```\n**复杂度**\n+ 空间复杂度$O(n)$\n+ 时间复杂度$O(n*m)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917517759","body":"**思路**\n用数组模拟一个栈，push考虑栈是否为满，pop考虑栈是否为空\n**代码**\n```java\nclass CustomStack {\n    int stack[];\n    int index;\n    public CustomStack(int maxSize) {\n        stack=new int[maxSize];\n        index=0;\n    }\n    public void push(int x) {\n        if(index<stack.length)\n        {\n            stack[index]=x;\n            index++;\n        }\n    }\n    public int pop() {\n        if(index==0)\n        {\n            return -1;\n        }\n        else\n        {\n            return stack[--index];\n        }\n    }\n    \n    public void increment(int k, int val) {\n        if(index>=k)\n        {\n            for(int i=0;i<k;i++)\n            {\n                stack[i]=stack[i]+val;\n            }\n        }\n        else\n        {\n            for(int i=0;i<index;i++)\n            {\n                stack[i]=stack[i]+val;\n            }\n        }\n    }\n}\n```\n**复杂度**\n+ 空间复杂度$O(1)$\n+ 时间复杂度$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"max-qaq":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916766187","body":"## 思路\n\n从个位开始，向高位加\n\n## 关键点\n\n- \n\n## 代码\n\n- \n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        int i = n - 1;\n        int carry = 0;\n        List<Integer> list = new ArrayList<>();\n        while(i>=0 || k > 0){\n            int sum = 0;\n            int num1 = i>=0? num[i] : 0;\n            int num2 = k>0? k%10 : 0;\n            sum = num1 + num2 + carry;\n            carry = sum / 10;\n            list.add(sum % 10);\n            i--; k/=10;\n        }\n        if(carry != 0) list.add(carry);\n        Collections.reverse(list);\n        return list;\n    }\n}\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917661673","body":"### 思路\r\n\r\n数组模拟栈\r\n\r\n### 代码\r\n\r\n~~~Java\r\nint[] data;\r\n    int head;\r\n\r\npublic CustomStack(int maxSize) {\r\n\r\n    data = new int[maxSize];\r\n    head = -1;\r\n}\r\n\r\npublic void push(int x) {\r\n\r\n    if (head == data.length - 1)\r\n        return;\r\n        \r\n    data[++head] = x;\r\n}\r\n\r\npublic int pop() {\r\n\r\n    if (head == -1)\r\n        return -1;\r\n\r\n    return data[head--];\r\n}\r\n\r\npublic void increment(int k, int val) {\r\n\r\n    for (int i = 0; i < Math.min(k, head + 1); i++)\r\n        data[i] += val;\r\n}\r\n```\r\n\r\n### \r\n~~~\r\n\r\n### 复杂度分析\r\n\r\n#### 时间复杂度：\r\n\r\n#### 空间复杂度：\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tobepellucid":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916768752","body":"# 思路\n类型转换+数位迭代计算\n\n# 代码\n``` python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:    \n        a_ = ''\n        for i in num:\n            a_ += str(i)\n        a_ = ''.join(a_)\n        sum_result = int(a_) + k\n        \n        res_array = []\n        while(sum_result>0):\n            res_array.insert(0, sum_result%10)\n            sum_result = sum_result // 10\n        if len(res_array) == 0:\n            res_array.append(0)\n        return res_array    \n```\n\n# 复杂度分析\n* 时间复杂度O(N)\n* 空间复杂度O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BpointA":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916771959","body":"### 思路\n模拟竖式的运算。首先将两个数转化为长度相同的数组，再从末位向前计算，依次进位。\n### python3代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        add=[int(i) for i in str(k)]\n        if len(add)>len(num):\n            a=[0]+add\n            b=[0]*(len(add)-len(num)+1)+num\n        else:\n            a=[0]+num\n            b=[0]*(len(num)-len(add)+1)+add\n        res=[0]*len(a)\n        for i in range(len(a)-1,0,-1):\n            k=a[i]+b[i]+res[i]\n            res[i]=k%10\n            res[i-1]=k//10\n        if res[0]==0:\n            return res[1:]\n        return res\n```\n### 复杂度\n时间复杂度：O(n) n为较长数组的长度\n\n空间复杂度：O(n)  n为答案数组的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917035360","body":"### 思路\n分别遍历两次数组。\n第一次从右向左遍历，记录s每个字母与最近的c的距离。第二次从左向右遍历，同步将距离更新为左右中较小的距离。\n\n### python3代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res=[len(s)]*len(s)\n        temp=len(s)\n        for i in range(len(s)-1,-1,-1):\n            if s[i]!=c and temp==len(s):\n                continue\n            elif s[i]==c:\n                temp=i\n                res[i]=0\n            else:\n                res[i]=temp-i\n        temp=-1\n        for i in range(len(s)):\n            if s[i]!=c and temp==-1:\n                continue\n            elif s[i]==c:\n                temp=i\n                res[i]=0\n            else:\n                res[i]=min(res[i],i-temp)\n        return res                              \n```\n### 复杂度分析\n时间复杂度：O(n) 其中n为数组长度，具体时间复杂度为O(2n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917433958","body":"### 思路\r\n直接利用栈的基本操作实现\r\n\r\n### Python3代码\r\n```Python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.m=maxSize\r\n        self.stk=[]\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stk)<self.m:\r\n            self.stk.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stk)==0:\r\n            return -1\r\n        return self.stk.pop()\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(k):\r\n            if i<len(self.stk):\r\n                self.stk[i]+=val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：increment为O(k)，insert和pop为O(1)\r\n\r\n空间复杂度：O(maxsize)\r\n\r\n### 优化\r\n可利用差分法思想，利用add数组累积求和，这样increment的时候只需记录增量，将其时间复杂度同样降到O(1)。\r\n```Python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.m=maxSize\r\n        self.stk=[]\r\n        self.add=[]\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stk)<self.m:\r\n            self.stk.append(x)\r\n            self.add.append(0)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stk)==0:\r\n            return -1\r\n        v=self.stk.pop()\r\n        i=self.add.pop()\r\n        if len(self.add)>0:\r\n            self.add[-1]+=i\r\n        return v+i\r\n        \r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        t=min(len(self.stk),k)\r\n        if t>=1:\r\n            self.add[t-1]+=val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sxr000511":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916776310","body":"\n\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n \n\n示例 1：\n\n输入：A = [1,2,0,0], K = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：A = [2,7,4], K = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：A = [2,1,5], K = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n示例 4：\n\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\n输出：[1,0,0,0,0,0,0,0,0,0,0]\n解释：9999999999 + 1 = 10000000000\n\n\n \n\n提示：\n\n1 <= A.length <= 10000\n0 <= A[i] <= 9\n0 <= K <= 10000\n如果 A.length > 1，那么 A[0] != 0\n```\n\n## 思路\n模仿加法计算过程，通过商和余数完成进位\n\njs里没整型数据，需要Math.floor()向下取整，要不然`/`得到的是小数\n\n## 关键点\n有几个边界条件要考虑\n\n1. 输入[0] 23 或者  [0],10000---》数组短，数据长，不能在数组结束就跳出循环\n\n```javascript\n        const x = i >= 0 ? A[i] : 0\n        const y = K != 0 ? K % 10 : 0\n```\n2. 输入 [2,1,5],806   ---》最高位有进位，不能跳出循环\n\n```javascript\n if (carry) res.push(carry)\n```\n3. 循环的条件是：(i >=0 || K != 0)，K不为零用来处理数组短的情况\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(A, K) {\n    const res = []\n    let i = A.length - 1, carry = 0\n    while (i >=0 || K != 0) {\n        //处理边界条件\n        const x = i >= 0 ? A[i] : 0\n        const y = K != 0 ? K % 10 : 0\n\n        const sum = x + y + carry\n        res.push(sum % 10)\n        carry = Math.floor(sum / 10)\n\n        i--\n        K = Math.floor(K / 10)\n    }\n    //处理最高位进位\n    if (carry) res.push(carry)\n    return res.reverse()\n};\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917351193","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n\n\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n\n \n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n```\n\n## 思路\n\n### 自己的版本\n\n很简单的做法，三个指针\n\nindex ：定位字符\n\nfront：字符前或空\n\nend：字符后一个或空\n\n通过判断`s[index]`, 's[front]', 's[end]' 是否和 c相同即可，相同push进abs坐标\n\n\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\n//  match 返回所有index 直接用+- min 计算\nvar shortestToChar = function(s, c) {\n    let index = 0;\n    let front = index +1;\n    let end = index - 1;\n    let answer = [];\n    let len  = s.length - 1;\n    while(index <= len ){\n    let head = s[front]?s[front]:'';\n    let tail = s[end]?s[end]:'';\n    if( s[index] ===c){\n        answer.push(0);\n        index++;\n        front = index +1;\n        end = index - 1;\n    }else if( head === c){\n        answer.push( Math.abs(front-index));\n        index++;\n        front = index +1;\n        end = index - 1;\n    }else if( tail === c){\n        answer.push(Math.abs(end-index));\n        index++;\n        front = index +1;\n        end = index - 1;\n    }else{\n        front++;\n        end--;\n    }\n    }\n    return answer\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n^2)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917627494","body":"\n## 题目地址(1381. 设计一个支持增量操作的栈)\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n \n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1);                          // 栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n\n\n \n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n\n## 思路\n\n### 我的版本：（菜狗）\n\n没啥好讲的，好简单的思路，js总是不讲武德\n\n### 通过hashMap 保存 inc操作\n\n![](https://pic.leetcode-cn.com/9e63bf59b9f83c4407bf0ef6a7a58a14b9e63fe01bc91b9a56c189982439acdd-custom_stack.png)\n\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n### 1. array模拟stack\n\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = [];\n    this.maxSize = maxSize;\n\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\nif( this.stack.length < this.maxSize){\n    this.stack.push(x);\n    return null;\n}else{\n    return null;\n}\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if( this.stack.length === 0 ){\n        return -1\n    }else{\n        return this.stack.pop();\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let helper = [];\n     k = k > this.stack.length ? this.stack.length : k;\n    for ( let i = this.stack.length-1 ; i >= 0 ; i--){\n        helper.push(i >= k ? this.stack.pop() : this.stack.pop()+val)\n    }\n    for ( let i = helper.length-1 ; i >= 0 ; i--){\n        this.stack.push(helper.pop())\n    }\n};\n\n//或者……………………\nCustomStack.prototype.increment = function(k, val) {\n      if(k>= this.stack.length ){\n        this.stack = this.stack.map(item => item+val)\n    }else{\n        for(let i=0;i<k;i++){\n            this.stack[i] += val\n        }\n    }\n};\n\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n### 2.  通过hashMap ：\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.list = []\n  this.maxSize = maxSize\n  this.hashMap = {}\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nCustomStack.prototype._setInc = function (key, value) {\n  if (!(key in this.hashMap)) {\n    this.hashMap[key] = 0\n  }\n  this.hashMap[key] += value\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nCustomStack.prototype._getInc = function (key) {\n  return this.hashMap[key] || 0\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype._size = function () {\n  return this.list.length\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this._size() < this.maxSize) {\n    this.list.push(x)\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  const top = this._size() - 1\n  const inc = this._getInc(top)\n\n  let item = this.list.pop()\n  if (item === void 0) {\n    return -1\n  }\n\n  item += inc\n  const newTop = top - 1\n  this._setInc(newTop, inc)\n  this.hashMap[top] = 0\n  return item\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  const size = this._size()\n  k = k < size ? k - 1 : size - 1\n  this._setInc(k, val)\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：\n1. 方法1\n$O(1)$ push pop      $O(k)$inc取决于修改几个\n\n2. 方法2\n时间复杂度 O(1) 的增量操作，不过代价就是额外的 O(n) 空间。\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"july-aha":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916798881","body":"# 思路\nJavaScript api解决\n\n# 代码\n```javascript\nvar addToArrayForm = function (num, k) {\n    return (BigInt(num.join(\"\")) + BigInt(k)).toString().split('')\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917630173","body":"```Javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.stack = [];\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.stack.length < this.maxSize) {\n        this.stack.push(x);\n    } else {\n        return;\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    if (this.stack.length > 0) {\n        return this.stack.pop();\n    } else {\n        return -1;\n    }\n\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    if (this.stack.length < k) {\n        return this.stack = this.stack.map((item) => item + val)\n    } else {\n        return this.stack = this.stack.map((item,index) => { return index < k ? item + val : item })\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xyinghe":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916799914","body":"#### 链接：\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n#### 思路：\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/jian-dan-yi-dong-javacpythonjs-pei-yang-a8ofe\n\n数组从右往左遍历每一个元素（i--)；\n\n整数每次个位数用到后去掉；\n\n用carry记录进位；\n\n反转结果集；\n\n#### 题解：\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int carry = 0;\n        int l1 = num.length -1 ;\n\n        while(l1 >= 0 || k != 0){\n            int x = l1 < 0 ? 0 : num[l1];\n            int y = k == 0 ? 0 : k % 10;\n\n            int sum = x + y + carry;\n            res.add(sum % 10);\n            carry = sum / 10;\n\n            l1--;\n            k = k / 10;\n        }\n        if(carry != 0){\n            res.add(carry);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n\n```\n\n\n\n\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917420695","body":"#### 链接：\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n#### 思路：\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/821zi-fu-de-zui-duan-ju-chi-shi-yong-zhi-n7o9/\n\n首先应该获取到该字符在字符串 s 中的所有下标位置；\n使用O(n)的时间遍历一次字符串，并将等于目标字符的下标添加至动态数组arr中。\n初始化指针p，指向arr的0位置；\n创建 ret 数组，长度为len(s)；\n再次遍历s的过程中，我们需要判断当满足以下两点条件时，指针 p 右移一位\np小于arr最大下标；\n前下标i 到 p + 1的绝对距离比到 p 的绝对距离小；\n每次将 p - i 的绝对距离添加至 ret[i] 中；\n最终返回ret即可；\n\n#### 题解：\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> arr = new ArrayList<>();\n        int[] ret = new int[s.length()];\n        int p = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) arr.add(i);\n        }\n        for (int i = 0; i < s.length(); i++) {\n            if (p < arr.size() - 1 && Math.abs(arr.get(p) - i) > Math.abs(arr.get(p + 1) - i)) p++;\n            ret[i] = Math.abs(arr.get(p) - i);\n        }\n        return ret;\n    }\n}\n\n```\n\n#### 复杂度：\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joriscai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916802793","body":"# 思路\n先将k转成数组，再利用双指针分别从k和num的最后一位开始按位计算。注：需要考虑最后一次进位的情况。\n\n# 代码\njavascript\n\n```javascript\n/*\n * @lc app=leetcode.cn id=989 lang=javascript\n *\n * [989] 数组形式的整数加法\n */\n\n// @lc code=start\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n  const kArr = (k + '').split('')\n  let temp = 0\n  const ret = []\n  let i = num.length - 1\n  let j = kArr.length - 1\n  while(i >= 0 || j >= 0) {\n    const sum = (num[i] || 0) + parseInt(kArr[j] || 0) + temp\n    ret.unshift(sum % 10)\n    temp = parseInt(sum / 10)\n    i--\n    j--\n  }\n  if (temp) {\n    ret.unshift(temp)\n  }\n\n  return ret\n};\n// @lc code=end\n\n```\n\n# 复杂度分析\n时间复杂度：O(max(n, log k))，其中 n 为数组的长度。log k为k的位，即log 10(k)，10为底k的对数。\n空间复杂度：O(max(n, log k))。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917425586","body":"# 思路\n- 先正序遍历数组，找目标字符跟右边元素的距离\n- 再反序遍历数组，找目标字符与左边元素的距离，同时取两次距离的最小值\n\n# 代码\njavascript\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n  let dis = Infinity\n  const ret = []\n  for (let i = 0; i < s.length; i++) {\n    const cur = s[i]\n    if (cur === c) {\n      dis = 0\n    } else {\n      dis++\n    }\n    ret.push(dis)\n  }\n\n  for (let i = s.length - 1; i >= 0; i--) {\n    const cur = s[i]\n    if (cur === c) {\n      dis = 0\n    } else {\n      dis++\n    }\n    ret[i] = Math.min(dis, ret[i])\n  }\n\n  return ret\n};\n\n```\n\n# 复杂度分析\n- 时间复杂度：O(n)，需要遍历两次数组，正序和反序\n- 空间复杂度：O(n)，返回结果的大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917656547","body":"# 思路\n- push方法要限制超过长度时不入栈\n- pop方法为了让所有操作都为O(1)的话，在出栈时再进行增加操作\n  - 出栈时要取出对应的增加值，并与栈顶值相加\n  - 由于数据出栈了，对应位置的加值无用，故对应位置的加值设为0，即默认值\n  - 由于inc方法的k是指栈底的 k 个元素，故此时下一位的加值要加上此次取出的加值，inc方法是栈底k个元素都增加val。\n- increment方法在对应的位置累加上加值即可 O(1)\n\n# 代码\njavascript\n\n```javascript\n/*\n * @lc app=leetcode.cn id=1381 lang=javascript\n *\n * [1381] 设计一个支持增量操作的栈\n */\n\n// @lc code=start\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.size = maxSize\n  this.stack = []\n  this.add = []\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length < this.size) {\n    this.stack.push(x)\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  // 方法一\n  // return this.stack.pop() || -1\n\n  // 方法二\n  const len = this.stack.length\n  if (len === 0) {\n    return -1\n  }\n\n  const add = this.add[len] || 0\n  // 由于只记录当前栈顶的增加值\n  // 故要更新下一个栈顶\n  this.add[len - 1] = this.add[len - 1] || 0\n  this.add[len - 1] += add\n  // 出栈后，对应位置的增加值无用，重置为0\n  this.add[len] = 0\n\n  const curr = this.stack.pop()\n\n  return curr + add\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  // 方法一\n  // const len = Math.min(this.stack.length, k)\n  // for (let i = 0; i < len; i++) {\n  //   this.stack[i] += val\n  // }\n\n  // 方法二\n  const index = Math.min(this.stack.length, k)\n  this.add[index] = this.add[index] || 0\n  this.add[index] += val\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n// @lc code=end\n\n```\n\n# 复杂度分析\n- 时间复杂度：O(1)，三个方法都是O(1)\n- 空间复杂度：O(n)，一个栈空间和一个加值存放空间，两个都是n的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"OASans":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916809316","body":"### 思路\n逐位相加，直接加到num里面。如果加后大于10则在k上进行调整\n\n### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n        while k:\n            num[i] += k % 10\n            if num[i] >= 10:\n                k = k // 10 + num[i] // 10\n                num[i] = num[i] % 10\n            else:\n                k = k // 10\n            i -= 1\n            if i < 0 and k:\n                num.insert(0, 0)\n                i = 0\n        return num\n```\n### 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917429743","body":"### 思路\n数组/字符串的前后遍历\n\n### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        prev = float('-inf')\n        ans = []\n        for i, x in enumerate(s):\n            if x == c: prev = i\n            ans.append(i - prev)\n\n        prev = float('inf')\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c: prev = i\n            ans[i] = min(ans[i], prev - i)\n\n        return ans\n```\n\n### 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917608289","body":"### 思路\n用一个数组来维护栈，一个变量来维护栈当前长度\n\n### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxsize = maxSize\n        self.stack = []\n        self.length = 0\n\n    def push(self, x: int) -> None:\n        if self.length >= self.maxsize:\n            return\n        self.stack.append(x)\n        self.length += 1\n\n    def pop(self) -> int:\n        if self.length == 0:\n            return -1\n        self.length -= 1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        k = k if self.length > k else self.length\n        for i in range(0, k):\n            self.stack[i] += val\n```\n\n### 复杂度分析\n* 时间：push、pop为O(1)，increment为O(k)\n* 空间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cy-sues":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916817098","body":"# 思路\n\n从末位开始将数组和k的每一位相加，若大于10则在下一步运算中进一位，ArrayList添加这些数字，最后反转。\n\n# 代码\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> arr = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            arr.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            arr.add(k % 10);\n        }\n        Collections.reverse(arr);\n        return arr;\n    }\n}\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917425418","body":"# 思路\n分别从字符串的左右遍历，经过C点时保存位置，记录后边遍历非C点的距离，碰见C点更新，最后选择两个方向的最小值，参考了官方的解法\n# 代码\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917536837","body":"# 代码\nclass CustomStack {\n\n    int [] data;//数组代替栈\n    int head;//头指针位置\n    public CustomStack(int maxSize) {\n        data=new int[maxSize];//maxSize 是栈中最多能容纳的元素数量\n        head=-1;\n    }\n    \n    public void push(int x) {\n        if(data.length-1==head) \n            return;//栈在增长到 maxSize 之后则不支持 push 操作\n        head++;\n        data[head]=x;\n    }\n    \n    public int pop() {\n        if (head==-1) return -1;//栈为空时返回 -1 。\n        return data[head--];\n    }\n    \n    public void increment(int k, int val) {\n            if (head+1<k)//如果栈中元素总数小于 k ，则栈中的所有元素都增加 val \n            for(int i=0;i<head+1;i++)\n            {\n                data[i]+=val;\n            }\n            else\n            for(int j=0;j<k;j++)\n            {\n                data[j]+=val;\n            }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shenzhengkang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916818186","body":"思路\n1. 当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\n2.AB两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在前面。\n伪代码\nwhile ( A 没完 || B 没完)\n    A 的当前位\n    B 的当前位\n    和 = A 的当前位 + B 的当前位 + 进位carry\n    当前位 = 和 % 10;\n    进位 = 和 / 10;\n    判断还有进位吗；\n\n代码\nint* addToArrayForm(int* num, int numSize, int k, int* returnSize) {\n    int* res = malloc(sizeof(int) * fmax(10, numSize + 1));\n    *returnSize = 0;\n    for (int i = numSize - 1; i >= 0; --i) {\n        int sum = num[i] + k % 10;\n        k /= 10;\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res[(*returnSize)++] = sum;\n    }\n    for (; k > 0; k /= 10) {\n        res[(*returnSize)++] = k % 10;\n    }\n    for (int i = 0; i < (*returnSize) / 2; i++) {\n        int tmp = res[i];\n        res[i] = res[(*returnSize) - 1 - i];\n        res[(*returnSize) - 1 - i] = tmp;\n    }\n    return res;\n}\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\n\n空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linrAx":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916825233","body":"# 思路\r\n\r\n将数组从低位到高位加到k上,最后反转\r\n\r\n# 代码\r\n\r\n语言支持:java\r\n\r\n```java\r\nclass Solution {`\r\n\r\n  public List<Integer> addToArrayForm(int[] num, int k) {\r\n\r\n​    List<Integer> res = new ArrayList<>();\r\n\r\n​    for(int i = num.length-1;i >= 0|| k >0;i--,k/=10){\r\n\r\n​      if(i>=0){\r\n\r\n​        k+=num[i];\r\n\r\n​      }\r\n\r\n​      res.add(k%10);\r\n\r\n​    }\r\n\r\n​    Collections.reverse(res);\r\n\r\n​    return res;\r\n\r\n  }\r\n\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n\r\n时间复杂度  O(max(n,log k)) , n为数组长度\r\n\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917421526","body":"# 思路\n\n 左遍历一遍，存储距离，右遍历一遍，两者最小值为最近距离\n\n# 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int N = s.length();\n        int[] res = new int[N];\n        int prev  = -10001;\n        for(int i=0;i<N;++i){\n            if (s.charAt(i)==c) prev =i;\n            res[i] = i - prev;\n        }\n        prev  = 10001;\n        for(int i=N-1;i>=0;--i){\n            if (s.charAt(i)==c) prev =i;\n            res[i] = Math.min(prev -i,res[i]);\n        }\n        return  res;\n    }\n}\n```\n\n# 复杂度分析\n\n时间复杂度    O(N) \n\n空间复杂度    O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917637676","body":"# 思路\n\n用数组作为底层构建栈\n\n# 代码\n\n```java\nclass CustomStack {\n    int[] stack;\n    int count;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        count = 0;    \n    }\n    \n    public void push(int x) {\n        if(count < stack.length) stack[count++] = x;     \n    }\n    \n    public int pop() {\n        if(count == 0) return -1;\n        return  stack[--count];\n    }\n    \n    public void increment(int k, int val) {\n        int temp = Math.min(k,count);\n        for (int i = 0; i <temp;i++){\n            stack[i] +=val;\n        }\n    }\n}\n```\n\n# 复杂度分析\n\n时间复杂度 push、pop 为O(1) , increment 为O(N)\n\n空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"L-mx-wq":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916826948","body":"思路:逐位相加，大于10加到下一位\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n\n复杂度分析\n时间复杂度：O(max⁡(n,logk))\n其中 n 为数组的长度。\n空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Okkband":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916827469","body":"### 思路\r\n面向测试用例的编程\r\n\r\n``` CPP\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int n = num.size();\r\n        int cnt = 0;\r\n        int pre = 0;\r\n        int tmp = 0;\r\n        while(k / 10 || k % 10 || cnt < n){\r\n            cnt += 1;\r\n            if (cnt > n){\r\n                tmp = pre + 0 + k % 10;\r\n            } else {\r\n                tmp = pre + num[n - cnt] + k % 10;\r\n            }\r\n            k /= 10;\r\n            pre = 0;\r\n            if (tmp >= 10){\r\n                pre = 1;\r\n                tmp -= 10;\r\n            }\r\n            if (cnt > n){\r\n                num.insert(num.begin(), tmp);\r\n            } else {\r\n                num[n - cnt]  = tmp;\r\n            }\r\n            \r\n        }\r\n        if (pre == 1) num.insert(num.begin(), 1);\r\n        return num;\r\n    }\r\n};\r\n```\r\n#### 时间复杂度\r\nO(n, m), 其中n, 为num的长度，m为k的位数\r\n#### 空间复杂度\r\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917408303","body":"``` CPP\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.size();\r\n        vector<int> ans(n, 0);\r\n        int pre = INT_MIN / 2;\r\n        for (int i=0; i<n; i++){\r\n            if (s[i] == c){\r\n                pre = i;\r\n            }\r\n            ans[i] = i - pre;\r\n        }\r\n        pre = INT_MAX / 2;\r\n        for (int i=n-1; i>=0; i--){\r\n            if (s[i] == c){\r\n                pre = i;\r\n            }\r\n            ans[i] = min(ans[i], pre - i);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917657270","body":"``` CPP\r\n\r\nclass CustomStack {\r\nprivate:\r\n    vector<int> vec;\r\n    int top;\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        vec.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top != vec.size() - 1){\r\n            vec[++top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1) return -1; \r\n        else \r\n        {\r\n            top--;\r\n            return vec[top+1];\r\n        }\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int idx = min(k, top+1);\r\n        for(int i=0; i<idx; i++){\r\n            vec[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n\r\n```\r\n### 时间复杂度：push: O(1), pop: O(1), increment: O(n)\r\n### 空间复杂度：O(n), n为栈的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ryzhao5":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916830080","body":"# 思路\r\n从后往前遍历数组，同时取出非负整数的个位数，与其相加，传入新的数组中\r\n# 代码\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> result = new LinkedList<>();\r\n        int temp = 0;\r\n        for(int i = num.length - 1; i >= 0; i--){\r\n            temp = k%10;\r\n            k = k/10;\r\n            if(num[i] + temp >= 10){\r\n                k++;\r\n                result.addFirst((num[i] + temp) % 10);\r\n            }\r\n            else{\r\n                result.addFirst((num[i] + temp) % 10);\r\n            }\r\n\r\n            if(i == 0){\r\n                while(k != 0){\r\n                    temp = k % 10;\r\n                    k = k / 10;\r\n                    result.addFirst(temp);\r\n                     \r\n                }\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n# 时间复杂度\r\nO(max(m,n))\r\n\r\n# 空间复杂度\r\nO(max(m,n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917418274","body":"# 思路\r\n从左往右遍历一遍数组，找出离它最近的且在左边的字符c的距离\r\n从右往左遍历一遍数组，找出离它最近的且在右边的字符c的距离，和上边的距离比较，取最小值\r\n\r\n# 代码\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] result = new int[len];\r\n        Arrays.fill(result, len);\r\n\r\n        //找左边的最近距离\r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i) == c){\r\n                result[i] = 0;\r\n            }\r\n            else if(i > 0){\r\n                result[i] = result[i-1] + 1;\r\n            }\r\n        }\r\n\r\n        for(int i = len - 1; i >= 0; i--){\r\n            if(s.charAt(i) == c){\r\n                result[i] = 0;\r\n            }\r\n            else if(i < len - 1){\r\n                result[i] = Math.min(result[i+1] + 1, result[i]);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n# 时间复杂度\r\nO（n）\r\n\r\n# 空间复杂度\r\nO（）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917611888","body":"# 思路\r\n正常设计\r\n# 代码\r\n\r\n```\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;//指向最上层的已存元素\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top != stack.length - 1){\r\n            stack[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top != -1){\r\n            return stack[top--];\r\n        }\r\n        else{\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int min = Math.min(k, top+1);\r\n        for(int i = 0; i < min; i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n# 时间复杂度\r\nincrement为ON，其他均为O1","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mosihan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916836424","body":"## 题目\n\n989. [数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n### 思路\n\n提取数组的数字，加K，加完后转为string，将string拆分为list填充\n\n### code\n\n```python\nA = [9,9,9,9,9,9,9,9,9,9]\nK = 1\n\nA_sum=0\nfor i in range(len(A)):\n  A_part=A[i]*10**(len(A)-i-1)\n  A_sum=A_sum+A_part\n\nprint(A_sum)\n\nak=A_sum+K\nlist1=[]\nak_s=str(ak)\nfor j in range(len(ak_s)):\n  list1.append(int(ak_s[j]))\n\nprint(ak_s)\n```\n\n### 复杂度\n\n+ 时间复杂度\n\n  O(max(m,n))\n\n+ 空间复杂度\n\n  O(max(m,n))\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917048782","body":"## 题目\n\n[821字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n### 思路\n\n正则化匹配符合要求的index，对原数组的每个索引与匹配好的数组索引做差，取绝对值后的min即为该索引到目标字符的最小距离\n\n### code\n\n```python\nimport re\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        f=re.finditer(c[0],s)\n\n        s_index=[]\n        for i in f:\n            s_index.append(i.span()[0])\n        print(s_index)\n\n        index1=range(len(s))\n        index2=[]\n        dis_min=float(\"inf\")\n        for j in index1:\n            for k in s_index:\n                dis_min=min(dis_min,abs(k-j))\n            index2.append(dis_min)\n            dis_min=float(\"inf\")\n\n        return index2\n```\n\n### 复杂度\n\n+ 时间复杂度\n\n  O(m*n)\n\n+ 空间复杂度\n\n  O(m*n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917475157","body":"## 题目\n\n[1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n### 思路\n\nclass 内创建空list1，通过maxsize限制list1的长度\n\n### code\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n      self.list1=[]\n      self.num=0\n      self.maxsize=maxSize\n\n    def push(self, x: int) -> None:\n      if self.num<self.maxsize:\n        self.list1.append(x)\n        self.num+=1\n\n\n    def pop(self) -> int:\n      if self.num==0:\n        return -1\n      self.num-=1\n      return self.list1.pop()\n\n    def increment(self, k: int, val: int) -> None:\n      if k>=len(self.list1):\n        for i in range(len(self.list1)):\n          self.list1[i]+=val\n      else:\n        for i in range(k):\n          self.list1[i]+=val\n```\n\n### 复杂度\n\n+ 时间复杂度\n\n  O(1)\n\n+ 空间复杂度\n\n  O(1)\n\n# [题解](https://leetcode-solution.cn/solutionDetail?type=3&id=3&max_id=2)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"babbomax98":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916838767","body":"#### 思路\n因为是数据形式的相加，那么首先考虑因为LinkedList的add的时间复杂度是1，AyyayList的add的时间复杂度是N，所以此处选用LinkedList，\n然后以数组的下标作为循环的条件，每次给传入的int值除以10来去除最后一位数，当坐标i>=0时，加上k和10取余的值，通过LinkedList的add(int index, E element)方法插入到链表头\n最后返回即可\n#### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        List<Integer> res = new LinkedList<Integer>();\n        int n = A.length;\n        for (int i = n - 1; i >= 0 || K > 0; --i, K /= 10) {\n            if (i >= 0) {\n                K += A[i];\n            }\n            res.add(0,K % 10);\n        }\n        return res;\n    }\n}\n```\n#### 复杂度分析\n时间复杂度：O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917408655","body":"#### 思路\n 此题使用双指针,定义一个index值指向下一个C和上一个C的坐标，然后另一个指针从第一个开始移动，与记录C坐标的值做对比，然后每当遍历到C传入的值就更新一次index，如果与传入的值不相等，那就通过计算，给本次循环的返回数组存入与上个C坐标距离和下个C坐标距离的小值，最终得到结果\n\n#### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] result=new int[N];\n        int indexNext=S.indexOf(C);//双指针，indexNext表示下一个C的下标， \n        int index=indexNext;//index表示前一个C的坐标\n    // 通过这里的赋值使在只有左边有C字符的时候（此时index = indexNext）的时候\n    //index也在当前字符的右边，否则在左右都有C字符的时候，当前字符必在index和indexNext的中间。\n       for(int i = 0; i < S.length(); i++){\n            if(S.charAt(i) == C){//每当遍历到C就更新index和indexNext\n                result[i] = 0;\n                index = i;\n                indexNext = S.indexOf(C, i+1);\n                //注意：这里如果当前是最后一个C时，此时indexNext为-1，这也保证了上面的情况3\n\n            }else{\n                result[i] = Math.min(Math.abs(index - i), Math.abs(indexNext - i));//\n            }\n        }\n       return result;\n    }\n}\n```\n\n#### 复杂度分析\n时间复杂度O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917615490","body":"#### 思路\n根据题意直接创建对应的栈方法\n#### 代码\n```java\n\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack=new int[maxSize];\n        top=-1;\n    }\n    \n    public void push(int x) {\n        if(top!=stack.length-1){\n            ++top;\n            stack[top]=x;\n        }\n\n    }\n    \n    public int pop() {\n        if(top==-1)\n            return -1;\n        --top;\n        return stack[top+1];\n\n    }\n    \n    public void increment(int k, int val) {\n        int li=Math.min(k,top+1);\n        for(int i=0;i<li;i++){\n            stack[i]+=val;\n        }\n\n    }\n}\n```\n#### 复杂度分析\n时间复杂度O（N）\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"EggEggLiu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916840372","body":"# 思路\n取num和k的低位，逐级相加\n\n# 代码\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> ret;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            ret.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            ret.push_back(k % 10);\n        }\n        reverse(ret.begin(), ret.end());\n        return ret;\n    }\n};\n```\n\n# 复杂度分析\n时间O(max(n, logk))\n\n空间O(max(n, logk))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917428821","body":"# 思路\r\n\r\n先扫描一遍记录下与`c`相同的字符位置，再扫描一遍确定输出结果\r\n\r\n# 代码\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res;\r\n        vector<int> position;\r\n        const size_t len = s.size();\r\n        for (int i = 0; i < len; ++i) {\r\n            if (s[i] == c) {\r\n                position.push_back(i);\r\n            }\r\n        }\r\n        int ptr = 0;\r\n        const size_t size = position.size();\r\n        for (int i = 0; i < len; ++i) {\r\n            if (i == position[ptr]) {\r\n                res.push_back(0);\r\n            } else if (i < position[ptr]) {\r\n                res.push_back(position[ptr] - i);\r\n            } else {\r\n                if (ptr == size - 1) {\r\n                    res.push_back(i - position[ptr]);\r\n                } else {\r\n                    if (i - position[ptr] < abs(i - position[ptr + 1])) {\r\n                        res.push_back(i - position[ptr]);\r\n                    } else {\r\n                        res.push_back(abs(i - position[ptr + 1]));\r\n                        ++ptr;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n# 复杂度\r\n\r\n时间：O(n)\r\n\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917555474","body":"# 思路\n用\"一个数组 + 栈顶指针\"实现栈，push-O(1)，pop-O(1)，inc-O(n)\n# 代码\n```cpp\nclass CustomStack {\n    int size;\n    int top;\n    vector<int> simStack;\npublic:\n    CustomStack(int maxSize) {\n        size = maxSize;\n        top = 0;\n    }\n    \n    void push(int x) {\n        if (top < size) {\n            simStack.push_back(x);\n            ++top;\n        }\n    }\n    \n    int pop() {\n        if (top) {\n            --top;\n            int ret = simStack.back();\n            simStack.pop_back();\n            return ret;\n        }\n        return -1;\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i < k && i < top; ++i) {\n            simStack[i] += val;\n        }\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carinSkyrim":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916845902","body":"## 代码\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        left = int(''.join(list(map(str, num))))\n        return [int(i) for i in str(left+k)]\n\n```\n## 复杂度\n时间复杂度 O(n)   \n空间复杂度 O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917631183","body":"## 代码\n```python\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxsize = maxSize\n        self.list = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.list) == self.maxsize:\n            return\n        self.list.append(x)\n\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.list) == 0:\n            return -1\n        tmp = self.list[-1]\n        self.list = self.list[:-1]\n        return tmp\n\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        tmp = min(k, len(self.list))\n        for i in range(tmp):\n            self.list[i] += val\n        return\n``` \n## 复杂度\n时间复杂度: O(1), O(1), O(min(k, cnt))  \n空间复杂度: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Brandylulu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916862006","body":"## 思路\nlist→string→int→list\n## 代码\nclass Solution:\n\n       def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n\n             n = len(A)\n\n             x = 0\n\n             for i in range(n):\n\n                  x = x + A[i] * (10**(n-i-1))\n\n             return str(x+k)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ivalkshfoeif":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916863413","body":"```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int i = num.length - 1;\n        int carry = 0;\n        List<Integer> ans = new ArrayList();\n        while(k !=0 || i >= 0){\n            //int n1 = (i >=0)? num[i]: 0;\n            int n = k % 10;\n            n += (i >=0)? num[i]: 0;\n            n += carry;\n            int temp = n%10;\n            carry = n / 10;\n            ans.add(temp);\n            k /= 10;\n            i--;\n        }\n        if (carry != 0){\n            ans.add(carry);\n        }\n        Collections.reverse(ans);\n        return ans;\n        \n    }\n}\n```\nO(N) O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917420151","body":"```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int prev = -10000;\n        char[] sChars = s.toCharArray();\n        int[] ans = new int[sChars.length];\n        for (int i = 0; i < sChars.length; i++){\n            if (sChars[i] == c){\n                prev = i;\n            }\n            ans[i] = i - prev;\n        }\n        prev = 100000;\n        for (int i = sChars.length - 1; i >= 0; i--){\n            if (sChars[i] == c){\n                prev = i;\n            }\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n        return ans;\n    }\n}\n```\nO(N) O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Socrates2001":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916864816","body":"- 时间：2021年9月10日13:34:46\n- 题目：[989.数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n- 思路：逐位相加（最低位开始），将结果逐个放入动态分配的数组中。若某两位相加大于10，则只和的将个位放入数组，十位在适当的数中(k)进1。最后将得到的数组内的数倒置，即为所求。\n\n## c\n\n```c\nint* addToArrayForm(int* num, int numSize, int k, int* returnSize){\n   int *res = (int *)malloc(sizeof(int) * fmax(10, numSize+1));\n   *returnSize = 0;\n   int i, sum, temp;\n\n   for(i=numSize-1; i>=0; i--)\n   {\n       sum = num[i] + k%10;\n       k /= 10;\n       if(sum >= 10)\n       {\n           k++;\n           sum -= 10;\n       }\n       res[(*returnSize)++] = sum;\n   }\n\n   for(; k>0; k/=10)\n   {\n       res[(*returnSize)++] = k % 10;\n   }\n\n   for(i=0; i < (*returnSize)/2; i++)\n   {\n       temp = res[i];\n       res[i] = res[(*returnSize)-1-i];\n       res[(*returnSize)-1-i] = temp;\n   }\n\n    return res;\n}\n```\n\n\n\n- 时间复杂度：O(max(n, lgk)) 其中n为数组长度\n\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917377555","body":"- 时间：2021年9月11日17:26:00\n- 题目：[821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n- 思路：先从左到右遍历一遍，计算出（部分）各元素到指定字符的距离，然后再反向遍历一遍，计算出（部分）各元素到指定元素的距离（只有小于之前的距离才能进行相应赋值）。\n\n## C implementation\n\n```c\nint* shortestToChar(char * s, char c, int* returnSize){\n    unsigned int * answer = malloc(sizeof(int) * strlen(s));\n    int i;\n\n    *returnSize = 0; \n    for(i=0; i<strlen(s); i++)\n    {\n        if(s[i] != c)\n            continue;\n\n        for(; (*returnSize)<=i; (*returnSize)++)\n            answer[(*returnSize)] = i - (*returnSize);\n    }\n\n    *returnSize = strlen(s) - 1;\n    for(i=strlen(s)-1; i>=0; i--)\n    {\n        if(s[i] != c)\n            continue;\n\n        for(; (*returnSize)>=i; (*returnSize)--)\n            if((*returnSize) - i < answer[(*returnSize)])\n                answer[(*returnSize)] = (*returnSize) - i;\n    }\n\n    (*returnSize) = strlen(s);\n    \n    return answer;\n}\n```\n\n\n\n- 时间复杂度：O(n²)\n\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917610733","body":"- 时间：2021年9月12日18:25:24\n- 题目：[1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n- 思路：按部就班。\n\n## C implementation\n\n```c\ntypedef struct {\n    int topOfStack;\n    int capacity;\n    int * array;\n\n} CustomStack;\n\n\nCustomStack* customStackCreate(int maxSize) {\n    CustomStack * s = malloc(sizeof(CustomStack));\n    if(s == NULL)\n    {\n        printf(\"Out of space!\");\n        return NULL;\n    }\n    s->array = malloc(sizeof(int) * maxSize);\n    if(s->array == NULL)\n    {\n        printf(\"Out of space!\");\n        return NULL;\n    }\n    s->capacity = maxSize;\n    s->array[s->topOfStack] = -1;\n\n    return s;\n}\n\nvoid customStackPush(CustomStack* obj, int x) {\n    if(obj->array[obj->topOfStack] != obj->capacity-1)\n    {\n        printf(\"Full stack!\");\n        return;\n    }\n    obj->array[++obj->topOfStack] = x;\n    \n}\n\nint customStackPop(CustomStack* obj) {\n    if(obj->array[obj->topOfStack] == -1)\n    {\n        printf(\"Empty stack!\");\n        return -1;\n    }\n    return obj->array[obj->topOfStack--];\n}\n\nvoid customStackIncrement(CustomStack* obj, int k, int val) {\n    int i;\n\n    if(k >= obj->capacity)\n        for(i=0; i<obj->capacity; i++)\n            obj->array[i] += val;\n    else\n        for(i=0; i<k; i++)\n            obj->array[i] += val;\n}\n\nvoid customStackFree(CustomStack* obj) {\n    if(obj != NULL)\n    {\n        free(obj->array);\n        free(obj);\n    }\n}\n\n/**\n * Your CustomStack struct will be instantiated and called as such:\n * CustomStack* obj = customStackCreate(maxSize);\n * customStackPush(obj, x);\n \n * int param_2 = customStackPop(obj);\n \n * customStackIncrement(obj, k, val);\n \n * customStackFree(obj);\n*/\n```\n\n\n\n- 时间复杂度：除了增量操作为O(min(k, maxSize) )外，其他均为O(1)。\n\n- 空间复杂度：O(1)\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Just-focus":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916865049","body":"## 代码\r\n\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n) n为较长数组的长度\r\n空间复杂度：O(n) n为答案数组的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917416783","body":"### 代码\r\n\r\n```js\r\nvar shortestToChar = function(S, C) {\r\n    let arrC = [-Infinity], res = [];\r\n    for(let i = 0; i < S.length; i++) if(S[i] === C) arrC.push(i);\r\n    arrC.push(Infinity);\r\n    for(let i = 0; i < S.length; i++) {\r\n        if(S[i] === C) {\r\n            arrC.shift();\r\n            res.push(0);\r\n        }else {\r\n            res.push(Math.min(i - arrC[0], arrC[1] - i))\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n### 复杂度分享\r\n\r\n时间复杂度: O(n)\r\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917647469","body":"### 代码\r\n\r\n```js\r\nclass CustomStack {\r\n  constructor(maxSize) {\r\n    this._maxSize = maxSize\r\n    this._size = 0\r\n    this._content = {}\r\n  }\r\n  push(x) {\r\n    if(this._size < this._maxSize) {\r\n      this._content[++this._size] = x\r\n    }\r\n  }\r\n  pop() {\r\n    if(this._size === 0) {\r\n      return -1\r\n    } else {\r\n      const topStackValue = this._content[this._size]\r\n      delete this._content[this._size--]\r\n      return topStackValue\r\n    }\r\n  }\r\n  increment(k, val) {\r\n    if(this._size === 0) {\r\n      return\r\n    }\r\n    for (let index = 1; index <= this._size && index <= k; index++) {\r\n      this._content[index] += val\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(1)。\r\n空间复杂度：O(n)。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916865936","body":"思路\n\n平铺直叙\n\n\n\n代码（Python）\n\n    class Solution:\n        def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n            List=num[:]\n            res=[]\n            sum=0\n            Len=len(List)\n            i=Len-1\n            q=1\n            while i>=0:\n                sum=sum+List[i]*q\n                i-=1\n                q*=10\n            sum+=k\n            while sum!=0:\n                res.append(sum%10)\n                sum//=10\n            res.reverse()\n            if len(res)==0:\n                res.append(0)\n            return res\n\n\n\n复杂度\n\n时间：O(n)\n\n空间：O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917377278","body":"821. 字符的最短距离\n\n思路\n\n先确定字符C在字符串S中的位置，其次设置两个值left和right分别代表当前字符距左边和右边字符C的距离（要考虑越界情况），最后比大小。\n\n代码（Python）\n\n    class Solution:\n        def shortestToChar(self, s: str, c: str) -> List[int]:\n            ans = [-1] * len(s)\n            Len = len(s)\n            num = []\n            for i in range(Len):\n                if c == s[i]:\n                    ans[i] = 0\n                    num.append(i)\n            Len1 = len(num)\n            left, right = 0, 1\n            if right >= Len1:\n                right = Len1 - 1\n            for i in range(Len):\n                if i >= num[right]:\n                    left += 1\n                    right += 1\n                if right >= Len1:\n                    right = Len1 - 1\n                if left >= Len1:\n                    left = Len1 - 1\n                if ans[i] != 0:\n                    ans[i] = min(abs(num[left] - i), abs(num[right] - i))\n            \n    \n    \n            return ans\n\n复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：o(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917565149","body":"# 1381.设计一个支持增量操作的栈\n\n## 思路\n\n平铺直叙\n\n## 代码(python)\n\n    class CustomStack:\n    \n        def __init__(self, maxSize: int):\n            self.maxSize = maxSize\n            self.Len = 0\n            self.Stack=[]\n    \n        def push(self, x: int) -> None:\n            if self.Len < self.maxSize:\n                self.Stack.append(x)\n                self.Len += 1\n    \n        def pop(self) -> int:\n            if self.Len == 0:\n                return -1\n            else:\n                self.Len -= 1\n                t = self.Stack[self.Len]\n                del self.Stack[self.Len]\n                return t\n    \n        def increment(self, k: int, val: int) -> None:\n            for i in range(self.Len):\n                if i < k:\n                    self.Stack[i] += val\n                else:\n                    break\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ray-hr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916875507","body":"# 思路   \r\n输出位=x+y+carry   \r\n将A设为LinkedList双向链表   \r\n# 代码  \r\n\r\n````java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        int n = A.length;\r\n        LinkedList<Integer> res = new LinkedList<>();  // 使用双向链表 LinkeList，或者 ArrayList 最后反转\r\n        int i = n - 1, sum = 0, carry = 0;\r\n        while (i >= 0 || K != 0) {  // 循环条件：两个数有一个没完\r\n            int x = i >= 0 ? A[i]: 0;\r\n            int y = K != 0 ? K % 10 : 0;\r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            K = K / 10;\r\n            i--;\r\n            res.add(0, sum % 10);\r\n        }\r\n        if (carry != 0) res.add(0, carry);\r\n        return res;\r\n    }\r\n}    \r\n````\r\n# 复杂度  \r\n时间复杂度：O(max(n, lgk))  其中n为数组长度   \r\n空间复杂度：\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917397071","body":"#思路 \r\n最小数组，左右遍历比较大小\r\n#代码  \r\n```` java  \r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    } \r\n````  \r\n#复杂度 \r\n时间复杂度：O(N)O(N)，其中 NN 是 S 的长度，我们需要遍历字符串两次。  \r\n空间复杂度：O(N)O(N)，ans 数组的大小。  ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"PearlCoastal":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916884534","body":"## 思路\n- 从末尾开始做加法\n- 注意处理进位的方式\n    ·新建一个数组b=[]来处理进位，当 [2] + 998 时， carry = 100，b = [1, 0, 0]\n- 取模运算 **%**，和取整运算 **//**的区别\n    · 86 % 10 = 6 \n    · 86 // 10 = 8\n- 数组的加法运算：把两个数组连在一起\n    · A = [1, 2, 3], B = [2, 3, 4]\n    · A + B = [1, 2, 3, 2, 3, 4]\n## 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: [int], k: int) -> [int]:\n        carry = 0\n        for i in range(len(num) - 1, -1, -1):\n            curr_sum = num[i] + k % 10 + carry\n            num[i] = curr_sum % 10\n            carry = curr_sum // 10\n            k //= 10\n        \n        carry += k\n        b = []\n        while carry:\n            b = [(carry % 10)] + b\n            carry //= 10\n\n        return b + num\n```\n\n## 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917402504","body":"## 思路\n\n两次遍历字符串。\n\n第一次从左到右， 找到当前字符最左边的 c ;\n\n第二次从右到左， 找到当前字符最右边的 c ;\n\n下标为 i 的字符距离字符 c 最近的距离就是 min(i - left, right - i)。\n\n## 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        left, right = float('-inf'), float('inf')\n        ans = []\n        for i, num in enumerate(s):\n            if num == c:\n                left = i\n            ans.append(i - left)\n        \n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c:\n                right = i\n            ans[i] = min(ans[i], right - i)\n        return ans\n```\n\n## 复杂度分析\n- 时间复杂度： O(n)\n- 空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917581200","body":"## 思路\r\n**模拟。**\r\n\r\n用数组模拟栈。\r\n\r\n栈大小为 size = maxSize。\r\n\r\n1. push 操作要考虑当前栈满时， 不允许 push 。\r\n\r\n2. pop 操作要考虑当前栈空时， 返回 -1 。\r\n\r\n3. increment 操作时， 对倒数 k 个元素叠加 val， 考虑当栈大小小于 k 的情况， 取 min(k, len(stack) 。\r\n\r\n## 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.size = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.size:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) > 0:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n    def increment(self, k: int, val: int) -> None:\r\n        if not len(self.stack):\r\n            return\r\n        for i in range(min(len(self.stack), k)):\r\n            self.stack[i] += val\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度\r\n  1. push O(1)\r\n  2. pop O(1)\r\n  3. increment O(k)\r\n- 空间复杂度： O(k)\r\nk 为栈 maxSize","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nekomoon404":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916884660","body":"【思路——数组模拟加法过程】\n\n类似用数组模拟大数加法，即模拟人手算的过程，从低位开始，逐位相加，逢十进一，即：\n\n 当前位 = (数A的当前位 + 数B的当前位 + 低位的进位carry) % 10。\n \n 当最后的进位不为0时，需要添加到答案数组的起始位置，可以用 `vector` 的 `insert` 函数，如 `res.insert(res.begin(), carry)`；\n \n 或者我们可以在存答案数组时，从低位到高位存，即`res[0]`表示最低位，这样在运算过程中一直向数组的尾部插入元素即可，最后再将数组翻转。\n\n【C++代码】\n\n```c++\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    int n = num.size();\n    vector<int> res;\n\n    int i = n - 1, sum = 0, carry = 0;\n    while(i >= 0 || k != 0) {\n        int a = i >= 0 ? num[i] : 0;\n        int b = k != 0 ? k % 10 : 0;\n\n        sum = a + b + carry;\n        carry = sum / 10;\n        res.push_back(sum % 10);\n\n        i--;\n        k /= 10;\n    }\n\n    if(carry != 0)\n        res.push_back(carry);\n    reverse(res.begin(), res.end());\n\n    return res;\n}\n```\n\n时间复杂度： $O(N)$，记 $N= \\max(n, \\log k)$，即表示答案数组的长度， `while` 遍历是 $O(N)$ 的复杂度，翻转数组也是 $O(N)$ 的复杂度。\n\n空间复杂度： $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917428300","body":"【思路——前后遍历数组】\n\n对于字符串s中的每个字符`s[i]`，找他它边最近的字符c和它右边最近的字符c，两个距离取最小值就是`res[i]`。\n\n而找离 `s[i]`左边最近的字符`c`，可以从左到右遍历数组，每次遇到字符`c`就更新下标`prev`的值，然后计算`s[i]`离`prev`的距离，就是`i-prev`；反之，从右向左遍历数组，求`res[i]`和距离`prev-i`的最小值。\n\n过程中涉及到求最小值，我们可以给`prev`初始一个很大的正值，如`INT_MAX`；如果担心运行过程中对大数的加减等操作会导致越界，可以初始成“不那么大的数”，常用的是`0x3f3f3f3f`；本题初始`prev=INT_MAX`不会越界。\n\n```c++\nconst int INF = 0x3f3f3f3f;\nvector<int> shortestToChar(string s, char c) {\n    int n = s.size();\n    vector<int> res(n, 0);\n\n    int prev = INF;\n    for(int i = 0; i < n; i++){\n        if(s[i] == c)  prev = i;\n        res[i] = i - prev;\n    }\n\n    prev = INF;\n    for(int i = n - 1; i >= 0; i--){\n        if(s[i] == c)  prev = i;\n        res[i] = min(abs(res[i]), prev - i);\n    }\n\n    return res;\n}\n```\n\n时间复杂度：$O(n)$，两次遍历数组；\n\n空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917620392","body":"【思路1——数组模拟栈】\n\n题目要求的三个操作中前两个操作`push`和`pop`都是栈的常规操作，而增量操作`increment`需要对栈底元素操作，而STL中栈的栈底是不可见的，那我们可以直接用数组来模拟栈。\n\n```c++\nclass CustomStack {\npublic:\n    vector<int> stk;\n    int top;\n    CustomStack(int maxSize) {\n        stk.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top != stk.size() - 1)\n            stk[++top] = x;\n    }\n    \n    int pop() {\n        if(top == -1)\n            return -1;\n        return stk[top--];\n    }\n    \n    void increment(int k, int val) {\n        int cnt = min(k, top + 1);\n        for(int i = 0; i < cnt; i++)\n            stk[i] += val;\n    }\n};\n```\n\n时间复杂度： `push`和`pop`操作是$O(1)$；增量操作是$O(k)$，需要遍历数组的前k各元素，依次加上val。\n\n空间复杂度： $O(maxSize)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chen-ds":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916884680","body":"# 思路\n\n从最低位开始相加，按逆序存储在vector中，最后把vector逆序一下就可以。\n\n# 代码\nC++\n```\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    vector<int> res;\n    int carry = 0;\n    int i = num.size() - 1;\n    while (i >= 0 || k || carry) {\n        int tmp = i >= 0 ? num[i--] + carry + k%10 : carry + k%10;\n        carry = tmp /10;\n        k /= 10;\n        res.push_back(tmp%10);\n    }\n    reverse(res.begin(), res.end());\n    return res;\n}\n```\n\n# 复杂度\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917328606","body":"# 思路\n从左边和从右边分别遍历，记录上一个指定字符位置和当前位置的距离，最后遍历一遍取最小值\n# 代码\n```\nvector<int> shortestToChar(string s, char c) {\n        vector<int> right;\n        vector<int> res;\n        int prev = INT_MAX / 2;\n        for(int i = s.size() - 1; i >= 0; i--) {\n            if(s[i] == c) {\n                prev = i;\n            }\n            right.push_back(prev - i);\n        }\n\n        prev = INT_MIN / 2;\n        for(int i = 0; i < s.size(); i++) {\n            if(s[i] == c) {\n                prev = i;\n            }\n            res.push_back(min(i - prev, right[s.size()-i-1]));\n        }\n        return res;\n    }\n```\n# 复杂度\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"minuet-red":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916889747","body":"标准加法模板\r\n时间复杂度O(n),空间复杂度O(n)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n\tvector<int> addToArrayForm(vector<int>& num, int k) {\r\n\t\treverse(num.begin(), num.end());\r\n\t\tvector<int>res;\r\n\t\tint carry = 0;\r\n\t\tfor (int i = 0; i < num.size() || k>0; i++) {\r\n\t\t\t// num的当前位\r\n\t\t\tint a = (i < num.size() ? num[i] : 0);\r\n\t\t\t// 模拟加法公式\r\n\t\t\tint sum = a + k % 10 + carry;\r\n\t\t\tres.emplace_back(sum % 10);\r\n\t\t\tk /= 10;\r\n\t\t\tcarry = sum / 10;\r\n\t\t}\r\n\t\tif (carry > 0) {\r\n\t\t\tres.emplace_back(carry);\r\n\t\t}\r\n\t\treverse(res.begin(), res.end());\r\n\t\treturn res;\r\n\t}\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917314402","body":"对每个字符左右寻找最小的，遇到边界输出另一边\r\n如果该字符为c，则直接给0\r\n\r\n时间O(n)\r\n空间O(1)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n\tvector<int> shortestToChar(string s, char c) {\r\n\t\tint len = s.size();\r\n\t\tvector<int>answer;\r\n\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\tif (s[i] == c) {\r\n\t\t\t\tanswer.push_back(0);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tint j = i;\r\n\t\t\tint k = i;\r\n\t\t\twhile (s[j] != c) {\r\n\t\t\t\tj--;\r\n\t\t\t\tif (j < 0) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile (s[k] != c) {\r\n\t\t\t\tk++;\r\n\t\t\t\tif (k >= len) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tint la = i - j;\r\n\t\t\tint lb = k - i;\r\n\r\n\t\t\tif (j < 0) {\r\n\t\t\t\tanswer.push_back(lb);\r\n\t\t\t}\r\n\t\t\telse if (k >= len) {\r\n\t\t\t\tanswer.push_back(la);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tanswer.push_back(min(la, lb));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn answer;\r\n\t}\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917642461","body":"简单模拟\r\n```cpp\r\nclass CustomStack {\r\npublic:\r\n\tCustomStack(int maxSize) {\r\n\t\tm_maxSize = maxSize;\r\n\t}\r\n\r\n\tvoid push(int x) {\r\n\t\tif (stack.size() < m_maxSize) {\r\n\t\t\tstack.push_back(x);\r\n\t\t}\r\n\t}\r\n\r\n\tint pop() {\r\n\t\tif (stack.size() > 0) {\r\n\t\t\tint top = stack.back();   // 返回栈最后一个元素\r\n\t\t\tstack.pop_back();         // 弹出栈最后一个元素\r\n\t\t\treturn top;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid increment(int k, int val) {\r\n\t\tif (k > stack.size()) {\r\n\t\t\tk = stack.size();\r\n\t\t}\r\n\t\tfor (int i = 0; i < k; i++) {\r\n\t\t\tstack[i] += val;\r\n\t\t}\r\n\t}\r\n\r\n\tvector<int>stack;\r\n\tint m_maxSize;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917795154","body":"时间复杂度O(n)\r\n空间复杂度O(n)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n\tstring decodeString(string s) {\r\n\t\tstring res;   // 字符串形式的栈\r\n\t\tfor (int i = 0; i < s.size(); i++) {    // 遍历整个string\r\n\t\t\tif (s[i] != ']') {\r\n\t\t\t\tres += s[i];\r\n\t\t\t}\r\n\t\t\telse if (s[i] == ']') {                  // 如果到']'就往回走\r\n\t\t\t\tstring saveStr = \"\";            // 每次循环初始化\r\n\t\t\t\tstring saveNum = \"\";\r\n\t\t\t\twhile (res.back() != '[') {   // 前面一定有'['\r\n\t\t\t\t\tsaveStr = res.back() + saveStr;   // 记录括号内的字符串\r\n\t\t\t\t\tres.pop_back();           // 往前走\r\n\t\t\t\t}\r\n\t\t\t\tres.pop_back();               // 去掉'['\r\n\t\t\t\twhile (res.size() != 0 && isdigit(res.back())) {   // 前面是数字且不越界都成立才循环\r\n\t\t\t\t\tsaveNum = res.back() + saveNum;          // 记录前面的数字\r\n\t\t\t\t\tres.pop_back();           // 往前走\r\n\t\t\t\t} // 得到数字和数字作用的字符串，已解出当前括号\r\n\t\t\t\tint n = stoi(saveNum);\r\n\t\t\t\twhile (n--) {\r\n\t\t\t\t\tres += saveStr;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn res;\r\n\t}\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LAGRANGIST":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916891700","body":"## 思路\r\n\r\n* 用 carry 记录上一位是否有进位， carry =  ( A[i]+B[i]+carry ) **>=** 10 ? 1 : 0  （注意这里是大于等于而不是大于）\r\n* 当前位 cur 可以表示为 ( A[i]+B[i]+carry ) % 10 \r\n* 处理完 num 的所有数字后，再处理k（如果k的位数比 num 大）\r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n## 代码\r\n\r\n```c++\r\n#include <bits./stdc++.h>\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nvector<int> addToArrayForm(vector<int> &num, int k)\r\n{\r\n    int carry = 0;\r\n    int cur = 0;\r\n    vector<int> res;\r\n    while (!num.empty())\r\n    {\r\n\r\n        cur = (num.back() + k % 10 + carry) % 10;\r\n        carry = (num.back() + k % 10 + carry) >= 10 ? 1 : 0;//看看这一位是否要进位到下一位\r\n        k /= 10;//去除k最后一位数字\r\n        res.push_back(cur);//res先反向保存，之后调用reverse调转之后再返回\r\n        num.pop_back();//去除num最后一位数字\r\n    }\r\n\r\n    while(k!= 0)//k位数比num大\r\n    {\r\n        cur = (k % 10 + carry) % 10;\r\n        carry = (k % 10 + carry) >= 10 ? 1 : 0;\r\n        k /= 10;\r\n        res.push_back(cur);\r\n    }\r\n\r\n    if(carry)//最后一次还要进位\r\n    {\r\n        res.push_back(1);\r\n    }\r\n\r\n    reverse(res.begin(), res.end()); //反转输出才是正确的\r\n    return res;\r\n}\r\n\r\n//TestDrive\r\nint main()\r\n{\r\n    vector<int> num = {2,1,5};\r\n    int k = 806;\r\n    vector<int> ans = addToArrayForm(num,k);\r\n    for (auto it = ans.begin(); it != ans.end();it++)\r\n    {\r\n        cout << *it << \" \";\r\n    }\r\n}\r\n```\r\n\r\n***\r\n\r\n\r\n\r\n## 复杂度分析\r\n\r\n\r\n\r\n### 时间复杂度\r\n\r\n此方法需要遍历一个 num 和 int类型数字 k 的每一位\r\n\r\n所以时间复杂度是：O( max(N , K ) ) , 其中N和K分别是 num 和 k 的位数 \r\n\r\n\r\n\r\n### 空间复杂度\r\n\r\n利用了一个辅助 `vector<int> res` 其大小为max（N , K)\r\n\r\n所以空间复杂度是O( max(N, K ) )","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917353759","body":"G## 思路\r\n\r\n* res [ i ] 记录的是第 i 个元素与离他最近的字符 c 的距离，它左边的 c 和右边的 c 到他距离中比较小的那一个就是最短距离\r\n\r\n* 初始化数组 res 全部为 -1\r\n\r\n* 从左向右遍历一遍\r\n\r\n\t* 如果发现 c，用 pre 来保存 c 的下标\r\n\t* 如果不是 c 但是没有找到c（pre == -1）就啥也不做跳过\r\n\r\n\t* 如果不是 c 并且 找到了 c (pre 不是 -1) 的话，就将res [ i ] 的值更新为 i - pre\r\n\r\n* 将pre重新归为 -1 （非常重要，我在这个地方就犯错了）\r\n\r\n* 从右向左遍历一遍\r\n\r\n\t* 如果发现 c，用 pre 来保存 c 的下标\r\n\t* 如果不是 c 但是没有找到c（pre == -1）就啥也不做跳过\r\n\r\n\t* 如果不是 c 并且 找到了 c (pre 不是 -1) 的话，就将res [ i ] 的值更新为 min ( res [ i ] , pre - i )\r\n\t\t* 但是这里要注意如果 res [ i ] 在从左向右结束后值为 -1 的话上述min值会是-1，所以单独判断一下是不是 -1，是的话直接将其更新为pre - i\r\n\r\n***\r\n\r\n\r\n\r\n\r\n\r\n## 代码\r\n\r\n```c++\r\nclass Solution\r\n{\r\npublic:\r\n    vector<int> shortestToChar(string s, char c)\r\n    {\r\n        int pre = -1;                        //用来记录上一个找到的 c,-1表示还没有找到\r\n        vector<int> res(s.size(), -1);       // -1 表示还没有找到对应的最近距离\r\n        for (int i = 0; i < s.length(); i++) //从 0 走到最后（从左到右扫描）\r\n        {\r\n            if (s[i] == c)\r\n            {\r\n                res[i] = 0;\r\n                pre = i; //记录下c的位置\r\n            }            //if\r\n\r\n            else if (pre != -1) //已经发现了他之前的一个c\r\n            {\r\n                res[i] = i - pre;\r\n            }\r\n\r\n            //如果没发现c就保持-1不变\r\n\r\n        } //for前到后\r\n\r\n        pre = -1; //这个很关键啊，第一次写就忘记重新归位了\r\n\r\n        for (int i = s.size() - 1; i >= 0; i--)\r\n        {\r\n            if (s[i] == c)\r\n            {\r\n                res[i] = 0;\r\n                pre = i; //记录下c的位置\r\n            }            //if\r\n\r\n            else if (pre != -1)\r\n            {\r\n                if (res[i] == -1)//防止后面的 min 里面因为 -1 更小就保留成 -1 了\r\n                {\r\n                    res[i] = pre - i;\r\n                }\r\n                else\r\n                    res[i] = min(res[i], pre - i); //如果从后往前扫的距离短了就更新\r\n            }\r\n\r\n        } //for从后到前\r\n\r\n        return res;\r\n\r\n    } //shortesToChar\r\n};    //Solution\r\n\r\n```\r\n\r\n***\r\n\r\n\r\n\r\n## 复杂度分析\r\n\r\n\r\n\r\n### 时间复杂度\r\n\r\n遍历了两次数组，复杂度是 O( n )\r\n\r\n\r\n\r\n### 空间复杂度\r\n\r\n用了一个 vector 用于保存返回的数组，复杂度是 O( n )\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917623076","body":"## 题目描述\r\n\r\n#### [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\r\n\r\n难度中等\r\n\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 `CustomStack` ：\r\n\r\n- `CustomStack(int maxSize)`：用 `maxSize` 初始化对象，`maxSize` 是栈中最多能容纳的元素数量，栈在增长到 `maxSize` 之后则不支持 `push` 操作。\r\n- `void push(int x)`：如果栈还未增长到 `maxSize` ，就将 `x` 添加到栈顶。\r\n- `int pop()`：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 **-1** 。\r\n- `void inc(int k, int val)`：栈底的 `k` 个元素的值都增加 `val` 。如果栈中元素总数小于 `k` ，则栈中的所有元素都增加 `val` 。\r\n\r\n \r\n\r\n**示例：**\r\n\r\n```\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n```\r\n\r\n \r\n\r\n**提示：**\r\n\r\n- `1 <= maxSize <= 1000`\r\n- `1 <= x <= 1000`\r\n- `1 <= k <= 1000`\r\n- `0 <= val <= 100`\r\n- 每种方法 `increment`，`push` 以及 `pop` 分别最多调用 `1000` 次\r\n\r\n***\r\n\r\n## 思路\r\n\r\n* 前两个函数实现就是普通的栈功能\r\n* 关键是第三个函数 inc 的实现：初步设计思路（今天作业好多先不考虑前缀和做法了，模拟方法过了再说）\r\n* IMPROVE ME !!!\r\n\r\n***\r\n\r\n## 代码\r\n\r\n> cpp 面向对象还没怎么学，用 c 写了这题\r\n\r\n```c\r\ntypedef struct {\r\n    int data[1001];\r\n    int top;\r\n    int maxSize;\r\n} CustomStack,*pt;//pt as the pointer of CumstomStack\r\n\r\n\r\nCustomStack* customStackCreate(int maxSize) {\r\n    pt stk = (CustomStack *)malloc(sizeof(CustomStack));\r\n    memset(stk, 0, sizeof(CustomStack));\r\n\r\n    stk->top = -1;//mark -1 as empty,maxSize -1 as full\r\n                 // and top is the index of the top element\r\n    stk->maxSize = maxSize;\r\n    return stk;\r\n}\r\n\r\nvoid customStackPush(CustomStack* obj, int x) {\r\n    if(obj->top < obj->maxSize - 1)//栈不满\r\n    {\r\n        obj -> data[++(obj->top)] = x;\r\n    }\r\n}\r\n\r\nint customStackPop(CustomStack* obj) {\r\n    if(obj->top != -1)//栈不空\r\n    {\r\n        int top_value = obj -> data[obj->top];\r\n        obj->top--;\r\n        return top_value;\r\n    } \r\n    return -1;\r\n}\r\n\r\nvoid customStackIncrement(CustomStack* obj, int k, int val) {\r\n    for(int i = 0;i<k;i++)\r\n    {\r\n        obj -> data[i]+=val;\r\n    }\r\n}\r\n\r\nvoid customStackFree(CustomStack* obj) {\r\n     free(obj);\r\n}\r\n\r\n/**\r\n * Your CustomStack struct will be instantiated and called as such:\r\n * CustomStack* obj = customStackCreate(maxSize);\r\n * customStackPush(obj, x);\r\n \r\n * int param_2 = customStackPop(obj);\r\n \r\n * customStackIncrement(obj, k, val);\r\n \r\n * customStackFree(obj);\r\n*/\r\n```\r\n\r\n***\r\n\r\n## 复杂度分析\r\n\r\n### 时间复杂度\r\n\r\ninc 是 O( k ) 其他两个是 O( 1 )\r\n\r\n### 空间复杂度\r\n\r\n辅助空间只有一些单个变量所以空间复杂度是 O( 1 )","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mokrs":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916900111","body":"## 思路一\n\n从低位到高位，逐位相加，相加结果直接修改原数组\n\n## 分析\n\n- 时间复杂度：$O(max(n,  logK))$\n\n- 空间复杂度：$O(1)$\n\n```c++\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    int i = num.size() - 1;\n    int plus = 0;\n\n    while (i >= 0 && k > 0){\n        int t = num[i] + plus + k % 10;\n        plus = t >= 10 ? 1 : 0;\n        num[i] = t % 10;\n        k /= 10;\n        --i;\n    }\n\n    while (i >= 0){\n        int t = num[i] + plus;\n        plus = t >= 10 ? 1 : 0;\n        num[i] = t % 10;\t\t\t\n        --i;\n    }\n\n    while (k > 0){\n        int t = plus + k % 10;\n        plus = t >= 10 ? 1 : 0;\n        num.insert(num.begin(), t % 10);\n        k /= 10;\t\t\t\n    }\n\n    if (plus > 0){\n        num.insert(num.begin(), plus);\n    }\n\n    return num;\n}\n```\n\n## 思路二\n\n从低位到高位，逐位相加，相加结果以逆序方式存储，最后对数组进行翻转\n\n## 分析\n\n- 时间复杂度：$O(max(n,  logK))$\n\n- 空间复杂度：$O(n)$\n\n```c++\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    vector<int> res;\n    int i = num.size() - 1;\n    int plus = 0;\n    while (i >= 0 || k > 0){\n        int sum = plus;\n        sum += i >= 0 ? num[i] : 0;\n        sum += k > 0 ? k % 10 : 0;\n        plus = sum >= 10 ? 1 : 0;\n        res.push_back(sum % 10);\n        k /= 10;\n        --i;\n    }\t\n\n    if (plus > 0){\n        res.push_back(plus);\n    }\n\n    reverse(res.begin(), res.end());\n    return res;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917390211","body":"## 思路\r\n\r\n分为三种情况：\r\n\r\n1. 只有左边有字符c：距离为 `c的索引 - 字符的索引`\r\n2. 左右都有字符c：取与两个c的距离更小者\r\n3. 只有右边有字符c：距离为 `字符的索引 - c的索引`\r\n\r\n```c++\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> res(s.length());  \r\n    //使用r1和r2分别记录依次出现的两个字符c的索引\r\n    //由于字符s长度<=10000，将r2初始值设置为10001，则情况1可与情况2作相同处理\r\n    int i = 0, r1 = 0, r2 = 10001;\r\n   \t\r\n    while (i < s.length()){\r\n        //从索引i起，在s中找到第一个c的索引，记为r1\r\n        //如未找到，r1为s最后一个字符的索引+1\r\n        while (r1 < s.length() && s[r1] != c){\r\n            ++r1;\r\n        }\r\n        //计算索引i到r之间各字符的结果，即取i与r1和r2差值的更小者\r\n        for (; i < r1; ++i)\t{\r\n            //未找到c时，即出现情况3，结果为i与最后一个c的索引的差值\r\n            if (r1 == s.length()){\r\n                res[i] = i - r2;\r\n            }          \r\n            //情况1与情况2\r\n            else{\r\n                res[i] = min(abs(r1 - i), abs(i - r2));\r\n            }\r\n        }\r\n\r\n        r2 = r1;\r\n        ++r1;\r\n        i = r1;\r\n    }\r\n\r\n    return res;\r\n}\r\n```\r\n\r\n## 分析\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917610928","body":"## 思路\n使用一个数组来模拟，用一个变量记录top的位置\n\n```c++\nclass CustomStack {\nprivate:\n\tvector<int> vec;\n\tint maxSize;\n\tint top;\n\npublic:\n    CustomStack(int maxSize) {\n        this->maxSize = maxSize;\n\t\ttop = -1;\t\t\n    }\n    \n    void push(int x) {\n        if (top < (int)(vec.size()) - 1){\n\t\t\tvec[++top] = x;\n\t\t}\n\t\telse if (vec.size() < maxSize){\n\t\t\tvec.push_back(x);\n\t\t\t++top;\n\t\t}\t\n    }\n    \n    int pop() {\n        if (top > -1){\n\t\t\treturn vec[top--];\n\t\t}\n\t\telse{\n\t\t\treturn -1;\n\t\t}\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i < k && i <= top; ++i){\n\t\t\tvec[i] += val;\n\t\t}\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：push和pop为O(1)，increment为O(k)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"niyaolanggeyo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916902429","body":"# 思路\n\n总体思路仿照的是，加法计算过程。采用最低位向前依次递进的方式。最后逆序输出。\n\n# 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        List<Integer> res = new ArrayList<Integer>();\n\n        for (int i = n - 1; i >= 0 || k > 0; i--) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.add(k % 10);\n            k /= 10;\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n# 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917420615","body":"# 思路\n通过使用双指针来计算当前位置的最小距离。当索引等于右指针的位置后，及时地更新两个指针的位置。这样可以保证最小距离的计算结果的正确性。\n\n# 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] result = new int[s.length()];\n        int first = s.indexOf(c);\n        int second = s.indexOf(c, first+1) != -1 ? s.indexOf(c, first+1) : first;\n        for (int i=0; i<s.length();i++){\n            int dis1 = Math.abs(i - first);\n            int dis2 = Math.abs(i - second);\n            result[i] = dis1 <= dis2 ? dis1 : dis2;\n            if(i == second){\n                first = second;\n                second = s.indexOf(c, first+1) != -1 ? s.indexOf(c, first+1) : first;\n            }\n        }\n        return result;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917648973","body":"# 思路\n\n- 因为本题给出了最多元素个数，所以选择数组来模拟栈的操作\n- 使用s来表示栈顶元素的索引\n- 出栈和入栈的时候，要考虑到是否已空或者已满\n\n# 代码\n\n```java\nclass CustomStack {\n    private int[] stack;\n    private int s;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        s = 0;\n    }\n    \n    public void push(int x) {\n        if (s == stack.length){\n            return;\n        }\n        stack[s++] = x;\n    }\n    \n    public int pop() {\n        if (s == 0) return -1;\n        return stack[--s];\n    }\n    \n    public void increment(int k, int val) {\n        int b = Math.min(k, s);\n        for (int i = 0; i < b; i++){\n            stack[i] += val;\n        }\n    }\n}\n```\n\n# 复杂度\n\n- 时间复杂度：\n\n  push：O(1)\n\n  pop：O(1)\n\n  increment：O(min(k, s))\n\n- 空间复杂度：\n\n  O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bowlofnoodles":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916904082","body":"## 思路\n常规思路\n\n## 代码\n``` javascript\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n\n```\n\n## 复杂度分析\n+ 时间复杂度：O(N)\n+ 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Moin-Jer":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916904187","body":"### 思路\r\n---\r\n转化为两个数组，从后往前对应位置相加，最后再进行反转\r\n### 代码\r\n----\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new ArrayList<>();\r\n        char[] ch = String.valueOf(k).toCharArray();\r\n        int i = num.length - 1, j = ch.length - 1, carry = 0;\r\n        while (i >= 0 || j >= 0 || carry > 0) {\r\n            int x = (i >= 0 ? num[i] : 0);\r\n            int y = (j >= 0 ? ch[j] - '0' : 0);\r\n            int sum = x + y + carry;\r\n            list.add(sum % 10);\r\n            carry = sum / 10;\r\n            --i;\r\n            --j;\r\n        }\r\n        Collections.reverse(list);\r\n        return list;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n---\r\n+ 时间复杂度：O(max(nums.length, logk))\r\n+ 空间复杂度：O(logk)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917360042","body":"### 思路\n---\n数组的正向遍历和反向遍历取最值\n### 代码\n---\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] ch = s.toCharArray();\n        int len = ch.length;\n        int[] ans = new int[len];\n        \n        int pre = -len;\n        for (int i = 0; i < len; ++i) {\n            if (ch[i] == c) {\n                pre = i;\n            }\n            ans[i] = i - pre;\n        }\n\n        pre = 2 * len;\n        for (int i = len - 1; i >= 0; --i) {\n            if (ch[i] == c) {\n                pre = i;\n            }\n            ans[i] = Math.min(ans[i], pre - i);\n        }\n        return ans;\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度： O(N)\n+ 空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917561760","body":"### 思路\n---\n使用数组模拟栈\n\n### 代码\n---\n```java\nclass CustomStack {\n\n    int[] stack;\n    int capacity, size;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        capacity = maxSize;\n        size = 0;\n    }\n    \n    public void push(int x) {\n        if (size < capacity) {\n            ++size;\n            stack[size - 1] = x;\n        }\n    }\n    \n    public int pop() {\n        int ans = -1;\n        if (size > 0) {\n            ans = stack[size - 1];\n            --size;\n        }\n        return ans;\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < size && i < k; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度： O(1)\n+ 空间复杂度： O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry9926":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916906152","body":"### 思路\r\n\r\n先mark\r\n\r\n### 代码\r\n\r\n```js\r\nvar addToArrayForm = function (num, k) {\r\n    const ret = [];\r\n    let i = num.length - 1, carry = 0;\r\n    while (i >= 0 || k != 0) {\r\n        let x = i >= 0 ? num[i] : 0;\r\n        let y = k !== 0 ? k % 10 : 0;\r\n\r\n        const sum = x + y + carry;\r\n\r\n        ret.push(sum % 10);\r\n        carry = Math.floor(sum / 10);\r\n\r\n        i--;\r\n        k = Math.floor(k / 10);\r\n    }\r\n    if (carry) {\r\n        ret.push(carry);\r\n    }\r\n    return ret.reverse();\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917431013","body":"### 思路\r\n\r\n两次遍历\r\n(先mark)\r\n\r\n### 代码\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    //两个循环，设prev 为 INFINITY\r\n    //第一个循环从左到右，每次在s找到 c 这个字符 就更新 prev = i（c 这个字符的INDEX）\r\n    // 然后让最近更新的 c 字符 Index 和 当前 字符 INDEX 相减 取绝对值（因为从左到右，不取绝对值会得到负数）\r\n    let prev = Infinity;\r\n    let res = [];\r\n    for(let i =0; i<s.length;i++){\r\n        if(s[i] === c){\r\n            prev = i;\r\n        }\r\n        res[i] = Math.abs(prev-i);\r\n    }\r\n    //第一次循环之后 res 里面的结果，当前数值还没完全正确\r\n// I I I 0 1 0 0 1 2 3 4  ，I = Infinity\r\n    \r\n    // reset prev to INFINITY\r\n    prev = Infinity;\r\n    // 第二次循环从右到左， 跟第一次循环步骤一样\r\n    for(let j = s.length-1; j>=0; j--){\r\n        if(s[j] === c){\r\n            prev = j;\r\n        }\r\n        // 不同的地方是这里 对比第一次循环和第二次循环得到的值，然后取最小值更新res\r\n        res[j] = Math.min(res[j],prev-j);\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917656508","body":"### 思路\r\n\r\n用额外array存相加的数字，pop的时候才把两个数字相加，就不用遍历数组把每个数字相加\r\n\r\n(先mark)\r\n\r\n### 代码\r\n\r\n```js\r\n//time O(1)\r\n//space O(n) extra space\r\n\r\nvar CustomStack = function(maxSize) {\r\n    this.size = maxSize;\r\n    this.sum = new Array(maxSize).fill(0);\r\n    this.values = [];\r\n};\r\n\r\n\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.values.length <this.size){\r\n        this.values.push(x);\r\n    } \r\n};\r\n\r\n\r\nCustomStack.prototype.pop = function() {\r\n   if(this.values.length){\r\n       let lastElementIndex = this.values.length-1;\r\n       let SumPosition = this.sum[lastElementIndex];\r\n       if(lastElementIndex>0){\r\n           this.sum[lastElementIndex-1]+= this.sum[lastElementIndex] \r\n       }\r\n        this.sum[lastElementIndex] = 0;\r\n       return this.values.pop() + SumPosition;\r\n   }\r\n    return -1;\r\n};\r\n\r\n\r\nCustomStack.prototype.increment = function(k, val) {\r\n   let sumIndex = Math.min(this.values.length,k)-1;\r\n    this.sum[sumIndex]+= val;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Shinnost":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916906847","body":"### 思路\n将数字`k`作为一个整体由低位到高位进行相加，从而不断进位。因为每一次同位加法都有可能发生进位，进位数大于10对加法运算没有影响。初始化：`i = len(num) - 1`。将数字`k`与`num[i]`相加，对结果取个位数作为新的`num[i]`；将结果除以10作为新的`k`。`i -= 1`。不断执行上述过程，直至`k`第一次为0时停止。因为`k`是作为一个整体往`num`上加的，当最后的结果的位数大于转换成数字的`num`的位数时，索引`i`会超过数组`num`的索引范围，故需要进行判断并添加`num`的长度使得上述过程能够正常运行，即对`num`的前几个元素添加适当的0。\n\n### 实现(python)\n```python\n## https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/pythonc-san-chong-jie-fa-by-milomusiala-7wc5/\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n\n        while k != 0:\n            num[i] += k\n            k, num[i] = num[i] // 10, num[i] % 10\n            i -= 1\n\n            if i < 0 and k != 0:\n                num.insert(0, 0)\n                i = 0\n\n        return num\n```\n\n### 复杂度分析\n1. 时间复杂度：$O(n^2)$。遍历数组嵌套python的list.insert()。\n2. 空间复杂度：$O(1)$。原地操作，使用了常数级空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917404762","body":"### 思路\n\n双指针法。从头至尾遍历字符串。索引`left`和`right`指向相邻的两个字符`c`，对`left`和`right`之间的字符按照规则进行编号。初始化：`left = -len(s), right = 0`。终止条件：`right != len(s)`\n\n### 实现(python)\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = []\n        length = len(s)\n        left, right = -length - 1, 0\n        while right != length:\n            while right != length and s[right] != c:\n                right += 1\n\n            if right != length:\n                if left == -length - 1:\n                    for i in range(right + 1):\n                        ans.append(right - i)\n                else:\n                    for i in range(left + 1, right + 1):\n                        if i - left < right - i:\n                            ans.append(i - left)\n                        else:\n                            ans.append(right - i)\n                left, right = right, right + 1\n            elif s[-1] != c:\n                for i in range(left + 1, length):\n                    ans.append(i - left)\n        return ans\n```\n\n### 复杂度分析\n\n1. 时间复杂度：$O(n^2)$。相当于嵌套遍历了两次字符串。\n2. 空间复杂度：$O(1)$。除返回值外，只使用了常数级空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917654301","body":"### 思路\n\n使用大小为`maxSize`的数组记录栈信息，用变量`top`来记录栈顶的位置并对数组进行相应的操作。进行优化：使用大小为`maxSize`的数组`add`记录`increment()`的操作。其原理为：由于`increment()`是一个批量操作，对于索引在`[0, min(k - 1, top))`的元素加的是同一个`val`，所以可只对位置为`min(k - 1, top)`的元素进行操作，通过`pop()`时输出实际栈顶值，并通过`add[top - 1], add[top] = add[top], 0`向前传播`incremrnt()`操作时的信息\n\n\t关键点：\n\n\t- `top`代表的是当前栈顶的索引，当前元素的实际个数为`top + 1`\n\t- `lim = min(k - 1, self.top)`：因为是对数组进行操作，索引从0开始\n\t- 当`self.top == 0`时，代表所有的信息已经传递到第一个元素了，故不需要向前传递以免超出索引值\n\n### 实现(python)\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.add = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        ret = self.stk[self.top] + self.add[self.top]\n        if self.top != 0:\n            self.add[self.top - 1] += self.add[self.top]\n        self.add[self.top] = 0\n        self.top -= 1\n        return ret\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k - 1, self.top)\n        if lim >= 0:\n            self.add[lim] += val\n```\n\n### 复杂度分析\n\n1. 渐进时间复杂度：均为O(1)$。\n2. 渐进空间复杂度：$O(maxSize)$。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kendj-staff":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916907412","body":"```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int index = num.length - 1;\r\n        int carry = 0;\r\n        while (k != 0 || index >= 0) {\r\n            int knum = k % 10;\r\n            k = k / 10;\r\n\r\n            int numTemp = index < 0 ? 0 : num[index];\r\n            int temp =  knum + numTemp + carry;\r\n\r\n            res.add(temp % 10);\r\n            carry = temp >= 10 ? 1 : 0;\r\n            index --;\r\n        }\r\n        if (carry == 1) {\r\n            res.add(carry);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917364656","body":"```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        int prev = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                prev = i;\n            }\n            res[i] = i - prev;\n        }\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                prev = i;\n            }\n            res[i] = Math.min(prev - i, res[i]);\n        }\n        return res;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Joyce94":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916909438","body":"###思路\r\n从后往前，逐个相加\r\n\r\n###代码\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        n = len(num)\r\n        # num比k长\r\n        # num比k短\r\n        carry = 0\r\n        for i in range(n - 1, -1, -1):\r\n            cur = num[i] + carry + k % 10\r\n            num[i], carry = cur % 10, cur // 10 \r\n            k = k // 10 \r\n        \r\n        # k += carry\r\n        while k != 0 or carry != 0:\r\n            cur = carry + k % 10\r\n            num.insert(0, cur % 10)\r\n            carry = cur // 10 \r\n            k = k // 10 \r\n        return num \r\n```\r\n\r\n###复杂度\r\n时间复杂度 o(min(n,m))\r\n空间复杂度 o(1))","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917779924","body":"#####思路\n两个栈，一个字母栈，一个数字栈\n左括号开始就进入字母栈，右括号就开始出栈(出栈生成的结果要重新入字母栈)，括号也要进栈，标志边界\n        # a：3 2          -> a：3         -> a：\n        # b：[ a [ c ]    -> b：[ a c c ] -> b：a c c a c c a c c\n        # res: a c c a c c a c c\n        # a：3       -> a：2              -> a：\n        # b：[ a ]   -> b：a a a [ b c ]  -> b：a a a b c b c \n        # res:\n\n#####代码\n```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        '''\n        case: \"100[leetcode]\"\n        '''\n        stack_num = []\n        stack_alpha = []\n        flag = False \n        for i in range(len(s)):\n            cur = s[i]\n            if cur.isdigit():\n                if flag is False:\n                    stack_num.append(int(cur))\n                else:\n                    pre = int(stack_num.pop())\n                    num = pre * 10 + int(cur) \n                    stack_num.append(num)\n                flag = True\n            elif cur == ']':\n                flag = False\n                word = ''\n                while len(stack_alpha) > 0:\n                    tmp = stack_alpha.pop()\n                    if tmp == '[':\n                        break\n                    word += tmp\n                # 逆序退出栈\n                count = int(stack_num.pop())\n                while count > 0:\n                    # for ele in word:\n                    for j in range(len(word) - 1, -1, -1):\n                        stack_alpha.append(word[j])\n                    count -= 1 \n            else:\n                flag = False\n                stack_alpha.append(cur)\n        if len(stack_num) != 0:\n            return ''    \n        return ''.join(stack_alpha)\n```\n\n#####复杂度\n时间复杂度：o(n)\n空间复杂度：o(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asterqian":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916909443","body":"### 思路\r\n两数相加从个位开始，自然想到从后往前遍历数组并且也从k的个位开始向前加，唯一要考虑的是进位问题，包括99+1=100这样的edge case。\r\n### 题解\r\n```C++\r\nvector<int> addToArrayForm(vector<int>& num, int k) {\r\n    vector<int> res;\r\n    int i = num.size() - 1;\r\n    int sum = 0;\r\n    int carry = 0;\r\n    while (i >= 0 || k != 0) {\r\n        int x = i < 0 ? 0 : num[i];\r\n        int y = k % 10;\r\n        sum = x + y + carry;\r\n        carry = sum / 10;\r\n        sum %= 10;\r\n        res.push_back(sum);\r\n        k /= 10;\r\n        --i;\r\n    }\r\n    if (carry != 0) { res.push_back(1); }\r\n    // faster than using insert in front every time\r\n    reverse(res.begin(), res.end());\r\n    return res;\r\n}   \r\n```\r\n### 复杂度分析\r\n###### 时间复杂度：O(max(N, K))，N为数组长度，K为k的长度（注：reverse的时间复杂度也为O(max(N, K))）\r\n###### 空间复杂度：O(max(N, K))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917349012","body":"### 思路\n计算relative distance类型，第一反应是用dp来储存。这道题由于c可能在左右两边，因此需要遍历两边才能得到shortest path。\n### 题解\n```C++\nvector<int> shortestToChar(string s, char c) {\n    vector<int> memo(s.size(), 0);\n    int prev = INT_MIN/2;\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] == c) {\n            // mark the pos of c last seen\n            prev = i;\n        } else {\n            // loop from i == 0, thus if c is seen, prev must be smaller than i\n            // if is not seen, i - INT_MIN will become a large positive number\n            memo[i] = i - prev; \n        }\n    }\n    int prev = INT_MAX/2;\n    for (int i = s.size() - 1; i >= 0; --i) {\n        if (s[i] == c) {\n            prev = i;\n        } else {\n            // loop from right to left, either curr is the best solution \n            // or a closer pos of c occurred after i, then prev - i is positive\n            // if not, prev - i would be a large positive number(thats why prev is updated as INT_MAX/2)\n            memo[i] = min(memo[i], prev - i);\n        }\n    }\n    return memo;\n}   \n```\n### 复杂度分析\n###### 时间复杂度：O(2N)，N为数组长度\n###### 空间复杂度：O(N)，因为是一维的数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917567240","body":"### 思路\nUsing underlying array structure\n### 题解\n```C++\npublic:\n    int max = 0;\n    vector<int> arr;\n    CustomStack(int maxSize) {\n       max = maxSize;\n       arr.reserve(max);\n    }\n    \n    void push(int x) {\n        if (arr.size() == max) return;\n        arr.push_back(x);    \n    }\n    \n    int pop() {\n        if (arr.size() == 0) return -1;\n        int last = arr.back();\n        arr.pop_back();\n        return last;\n    }\n    \n    void increment(int k, int val) {\n        /*for (int i = 0; i < min(k, arr.size()); ++i) {\n            arr[i] += val;\n        }*/\n        int size = arr.size() < k ? arr.size() : k;\n        for (int i = 0; i < size; ++i) {\n            arr[i] += val;\n        }\n    }\n```\n### 复杂度分析\n###### 时间复杂度：O(1) for push and pop，O(min(k, arr.size()) for increment\n###### 空间复杂度：O(N)，用了array来模拟stack","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jmstart":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916910988","body":"```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n​    List<Integer> res = new ArrayList<>();\n​    for(int i = num.length-1;i >= 0|| k >0;i--,k/=10){\n​      if(i>=0){\n​        k+=num[i];\n​      }\n​      res.add(k%10);\n​    }\n​    Collections.reverse(res);\n​    return res;\n  }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Tomtao626":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916911109","body":"## 思路\r\n> + 将整个加数 kk 加入数组表示的数的最低位\r\n## 代码\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```\r\n## 复杂度分析\r\n> + 时间: O(max(n,logk))，其中 nn 为数组的长度。\r\n> + 空间: O(1)。除了返回值以外，使用的空间为常数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917414568","body":"## 思路\r\n> + 对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\r\n## 代码\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n```\r\n## 复杂度\r\n> + 时间:O(N)\r\n> + 空间:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917647271","body":"## 思路\r\n> + 使用数组模拟栈，用一个变量 top 来记录当前栈顶的位置\r\n## 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.add = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        ret = self.stk[self.top] + self.add[self.top]\r\n        if self.top != 0:\r\n            self.add[self.top - 1] += self.add[self.top]\r\n        self.add[self.top] = 0\r\n        self.top -= 1\r\n        return ret\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k - 1, self.top)\r\n        if lim >= 0:\r\n            self.add[lim] += val\r\n```\r\n## 复杂度\r\n> + 时间:  O(1)\r\n> + 空间: O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lizzy-123":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916911369","body":"思路：\n     1. 将数组 reverse 以下，这样从0开始低位数\n      2. 将数字求出数组形式--这时得到数组应该是从低位数到高位数\n     3. 将上面两个数组相同索引数字相加，这个相加的就是从低位到高位，如果相加数大于10，将数据减10.\n    4. 将得到数据reverse。\n代码：\n\tvector<int> addToArrayForm(vector<int>& num, int k) {\n\t\tvector<int> result;\n\t\tint n = num.size();\n\t\treverse(num.begin(), num.end());\n\t\tfor (int i = 0; i <n; ++i) {\n\t\t\tint sum = num[i] + k % 10;\n\t\t\tk /= 10;\n\t\t\tif (sum >= 10) {\n\t\t\t\tk++;\n\t\t\t\tsum -= 10;\n\t\t\t}\n\t\t\tresult.push_back(sum);\n\t\t}\n\t\tfor (; k > 0; k /= 10) {\n\t\t\tresult.push_back(k % 10);\n\t\t}\n\t\treverse(result.begin(), result.end());\n\t\treturn result;\n\t}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917409029","body":"vector<int> shortestToChar(string s, char c) {\r\n    int n = s.size();\r\n    std::vector<int> results(n,0);\r\n   // std::vector<int> tmp;\r\n   int last = 1e4;\r\n   int lastIndex = 0;\r\n    for(int i=0;i<n;++i)\r\n    {\r\n        if(s[i]==c)\r\n        {\r\n             for(int j = i;j>=lastIndex;--j)\r\n               {\r\n                  int dis = min(i-j,abs(last-j));\r\n                  results[j] = dis; \r\n                 \r\n                  \r\n               } \r\n                last = i;\r\n               lastIndex= i;         \r\n        }\r\n    }\r\n   \tif (lastIndex<n)//还有部分在指定字符右边\r\n\t\t{\r\n\t\t\tfor (int j = lastIndex + 1; j < n;j++)\r\n\t\t\t{\r\n\t\t\t\tresults[j] = j - lastIndex;\r\n\t\t\t}\r\n\t\t}\r\n  return results;\r\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917608406","body":"时间复杂度：push,top,初始化，O(1)，inc复杂度O(maxSize);\r\n空间复杂度：因为需要一个辅助空间，所以复杂度O(maxSize)\r\n\r\n`void push(int x) {\r\n if(maxM!=nums.size()-1)\r\n {\r\n     maxM++;\r\n    nums[maxM] = x;\r\n }\r\n    \r\n}\r\n\r\nint pop() {\r\nif(maxM==-1)return -1;\r\n    maxM--;\r\n    return nums[maxM+1];\r\n}\r\n\r\nvoid increment(int k, int val) {\r\n    \r\n    int minX = min(k,maxM+1);\r\n    for(int i=0;i<minX;++i)\r\n    {\r\n        nums[i]+=val;\r\n    }\r\n}\r\n`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Poidaze7":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916918813","body":"### 思路\n\n先将列表转换成字符串再转换成数字，与k相加，再转回列表\n\n### 代码\n\n```python\ndef to_list(num):\n        return [int(i) for i in str(num)]\n\ndef to_num(num_list):\n    return int(''.join([str(i) for i in num_list]))\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        l = to_num(num) + k\n        return to_list(l)\n```\n\n### 总结\n\n总觉得不看题解的话，自己思想有点跑偏，希望慢慢转变\n\n### 复杂度分析\n\n- 时间：=。=\n- 空间：好像挺高","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917589633","body":"### **设计一个支持增量操作的栈**\n\n\n\n- 链接\n\n  [设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n- 思路\n\n  - 数组模拟栈实现功能\n\n- 代码\n\n  ```python\n  class CustomStack:\n  \n      def __init__(self, maxSize: int):\n          self.__maxSize__ = maxSize\n          self.__arr__ = []\n          self.__len__ = 0\n  \n      def push(self, x: int) -> None:\n          if self.__len__ < self.__maxSize__:\n              self.__arr__.append(x)\n              self.__len__ += 1\n  \n  \n      def pop(self) -> int:\n          if self.__len__ == 0 : return -1\n          else :\n              self.__len__ -= 1\n              return self.__arr__.pop()\n  \n  \n      def increment(self, k: int, val: int) -> None:\n          if self.__len__ < k : self.__arr__ = [i + val for i in self.__arr__]\n          else :\n              for i in range(k):\n                  self.__arr__[i] += val\n  ```\n\n  \n\n- 复杂度\n\n  - 时间：pop、push $O(1)$\tncrement $O(N)$\n  - 空间：$O(N)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"edge-wzw":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916919493","body":"**思路**\n\n1.自己的思路\n\n逆序遍历数组，每次将位置i的元素与k求和得到新的k，将新k的最低位(k % 10)替换num[i]，同时k移除最低位(k /= 10);\n\n如果k在数组遍历后不为0，例如num=[0], k =100,则将100转换为列表[1,0,0]；\n\n最后将元素存入列表中返回。\n\n**代码**\n\n```java\nclass Day1LC989V0 {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        //逆序遍历数组，每次将位置i的元素与k求和得到新的k，将和的最低位(k % 10)替换num[i]，同时k移除最低位(k /= 10);\n        for (int i = num.length - 1; i >= 0; i--) {\n            k = num[i] + k;\n            num[i] = k % 10;\n            k = k / 10;\n            //如果遍历时k为0,则无需继续求和，直接退出遍历\n            if (k == 0) break;\n        }\n        List<Integer> list = new ArrayList<>();\n        //如果k在遍历后不为0，例如num=[0], k =100,则将100转换为列表[1,0,0]\n        while (k != 0){\n            list.add(k % 10);\n            k /= 10;\n        }\n        //将list的元素逆序存入res列表中\n        for (int i = list.size() - 1; i >= 0; i--) {\n            res.add(list.get(i));\n        }\n        //将求和后的num元素添加到res列表中\n        for (int i : num) {\n            res.add(i);\n        }\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917321246","body":"**思路**\n\n1.自己的思路\n\n对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\n\n`idx`记录上一个字符 C 出现的位置，从左向右遍历时初始值为 `s.length() - 1(最坏情况字符在s末尾)` ；从右向左遍历时初始值为 `0(最坏情况字符在s头部)` \n\n从左向右遍历，最短距离为`abs(i - idx)`。\n\n从右向左遍历，最短距离为`abs(i - idx)`。\n\n对比两次遍历的结果，取最小值为最短距离。\n\n**代码**\n\n```java\nclass Day2LC821vV0 {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        char[] strs = s.toCharArray();\n        int idx = s.length() - 1;\n        for (int i = 0; i < strs.length; i++) {\n            if (strs[i] == c){\n                idx = i;\n            }\n            res[i] = Math.abs(i - idx);\n        }\n        idx = 0;\n        for (int i = strs.length - 1; i >= 0; i--) {\n            if (strs[i] == c){\n                idx = i;\n            }\n            res[i] = Math.min(Math.abs(i - idx), res[i]);\n        }\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917577021","body":"**思路**\n\n1.自己的思路\n\n数组模拟\n\n**代码**\n\n```java\n/**\n * 数组模拟\n */\nclass CustomStack {\n    int[] arr;\n    int size = 0;\n\n    public CustomStack(int maxSize) {\n        this.arr = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (size < arr.length){\n            arr[size++] = x;\n        }\n    }\n\n    public int pop() {\n        if (size == 0){\n            return -1;\n        }\n        int res = arr[size - 1];\n        size--;\n        return res;\n    }\n\n    public void increment(int k, int val) {\n        for (int i = 0; i < Math.min(size, k); i++) {\n            arr[i] += val;\n        }\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：push()、pop()的时间复杂为O(1)，increment()为O(k)；\n- 空间复杂度：O(maxSize)\n\n2.力扣官方题解\n\n我们用一个辅助数组 add 记录每次 inc 操作。具体地，如果 inc 操作是将栈底的 k 个元素（将 k 与栈中元素个数取较小值）增加 val，那么我们将 add[k - 1] 增加 val。这样做的目的在于，只有在 pop 操作时，我们才需要知道栈顶元素的具体值，在其余的情况下，我们只要存储每个元素的增量就行了。\n\n因此在遇到 pop 操作时，我们返回栈顶元素的初始值加上增量 add[top]。在这之后，我们将增量向栈底进行传递，累加至 add[top - 1] 处，这样 inc 操作的时间复杂度也减少至 O(1) 了。\n\n**代码**\n\n```java\nclass CustomStack {\n    int[] stack;\n    int[] add;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        add = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        int ret = stack[top] + add[top];\n        if (top != 0) {\n            add[top - 1] += add[top];\n        }\n        add[top] = 0;\n        --top;\n        return ret;\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k - 1, top);\n        if (limit >= 0) {\n            add[limit] += val;\n        }\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：所有操作的渐进时间复杂度均为 O(1)\n- 空间复杂度：这里用到了两个长度为 `maxSize` 的数组作为辅助空间，渐进空间复杂度为 O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"20donkey":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916920617","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n-1; i>=0;--i){\n            int sum = num[i] + k%10;\n            k/=10;\n            if(sum>=10){\n                k++;\n                sum-=10;\n            }\n            res.add(sum);\n        }\n        for(;k>0;k/=10){\n            res.add(k%10);\n        }\n        Collections.reverse(res);\n            return res;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917420530","body":"思路\n官方题解\n代码（python）\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        prev = float('-inf')\n        ans = []\n        for i, x in enumerate(S):\n            if x == C: prev = i\n            ans.append(i - prev)\n\n        prev = float('inf')\n        for i in xrange(len(S) - 1, -1, -1):\n            if S[i] == C: prev = i\n            ans[i] = min(ans[i], prev - i)\n\n        return ans\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Kashinggo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916922619","body":"# 思路\r\n模拟题，逐位遍历，一开始用carry保存进位，后面发现要考虑太多，k++更省心。\r\nps. 因为是数组，如果用 add(0, sum)，每次都需要移动N次；链表的 addFirst 或最后 reverse 更优\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n\r\n        // 第一天打卡数组 模拟题 \r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum > 9) k++;\r\n            sum %= 10;\r\n            res.add(sum);\r\n        }\r\n\r\n        while (k != 0) {\r\n            res.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        \r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度\r\n## 时间复杂度 \r\n*O(max(N, K))*，N 为数组长度，K 为数字 k 的位数\r\n## 空间复杂度 \r\n*O(max(N, K))*，额外的 list 用于返回结果 ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917427920","body":"# 思路\n本来用了中心扩散法，一看别人的思路更好，就是两次遍历，判断左边和右边最近的目标字符，何者距离更小。\n\n# 代码\n```java\nclass Solution {\n    // 第二天打卡 字符串题\n    public int[] shortestToChar(String s, char c) {\n        \n        // 转成 char 数组方便处理\n        char[] ca = s.toCharArray();\n        int len = ca.length;\n        int[] res = new int[len]; \n\n        // 从头到尾 即离该字符较近的 c 在前面\n        // 除以2是因为防止加减溢出 第一次时写懵逼\n        int idx = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < len; i++) {\n            if (ca[i] == c) {\n                idx = i;\n            }\n            res[i] = i - idx;\n        }\n\n        // 从尾到头 即离该字符较近的 c 在后面\n        idx = Integer.MAX_VALUE / 2;\n        for (int i = len - 1; i >= 0; i--) {\n            if (ca[i] == c) {\n                idx = i;\n            }\n            // 取两者更小的值\n            res[i] = Math.min(res[i], idx - i);\n        }\n\n        return res;\n    }\n}\n```\n\n# 复杂度\n## 时间复杂度 *O(N)* \n遍历两次，N为字符串长度\n## 空间复杂度 *O(N)* \n字符数组和结果数组，长度都为N","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917662224","body":"# 思路\n有点巧妙，用数组记录要增加的值，出栈时处理。\n\n# 代码\n```java\nclass CustomStack {\n\n    Stack<Integer> stack;\n    int[] arr;\n    int maxSize = -1;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        stack = new Stack<>();\n        arr = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (stack.size() < maxSize) {\n            stack.push(x);\n        }\n    }\n    \n    public int pop() {\n        int i = stack.size() - 1;\n        if (i < 0) return -1;\n        if (i > 0) {\n            arr[i - 1] += arr[i];\n        }\n        int res = stack.pop() + arr[i];\n        arr[i] = 0;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int i = Math.min(k, stack.size()) - 1;\n        if (i >= 0) {\n            arr[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n# 复杂度\n## 时间复杂度\n*O(n)*\n## 空间复杂度\n*O(n)*","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DAXIAdaxia":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916922772","body":"### Java\n\n---\n\n**思路**：\n\n按照加法思路，从个位开始进行加运算，这里直接直接和 k 进行相加，然后取余得到最低位的数值，此值为相加后的结果，如此循环。注意有可能 num 还有剩余，而k已经为0了，这是只需把 num 剩下没运算的数值加到 List 尾部即可，最后对 List 进行反转，即可得到相加后的结果。\n\n\n\n**代码**：\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int index = num.length - 1;\n        while(k != 0){\n            int sum = 0;\n            if(index >= 0){\n                sum = k % 10 + num[index];\n                index--;\n            }else{\n                sum = k % 10;\n            }\n            res.add(sum % 10);\n            k = k / 10 + sum / 10;\n        }\n        for(int i = index; i >= 0; i--)\n            res.add(num[i]);\n\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n\n\n**复杂度**：\n\n* **时间复杂度**：O(N)\n* **空间复杂度**：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917399190","body":"### Java\n\n---\n\n**思路**：\n\n1. 使用集合 indexList 记录字符 c 在字符串中的位置\n2. 计算字符串中每个字符距离字符 c 的距离\n   * 若是存在于两个字符 c 的中间，则需要比较距离那边比较近\n\n\n\n**代码**：\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        ArrayList<Integer> indexList = new ArrayList<>();\n        for(int i = 0; i < len; i++)\n            if(s.charAt(i) == c)\n                indexList.add(i);\n\n        int[] res = new int[len];\n        int index = 0;\n\n        for(int i = 0; i < len; i++){\n            if(s.charAt(i) != c){\n                if(index > 0){\n                    res[i] = Math.min(Math.abs(i - indexList.get(index)), Math.abs(i - indexList.get(index - 1)));\n                }else{\n                    res[i] = Math.abs(i - indexList.get(index));\n                }\n            }else{\n                res[i] = 0;\n                if(index < indexList.size() - 1)\n                    index++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n\n* **时间复杂度**：O(N)，其中 N 为字符串的长度\n\n* **空间复杂度**：O(M)，其中 M 为字符串中字符 c 的个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917653444","body":"### Java\n\n---\n\n**思路**：\n\n1. 使用一个长度为 maxSize 的数组来作为栈，变量 curSize 来标识当前已经入栈的长度\n   * 当 curSize >= maxSize ，则说明栈满，元素不能再进栈了\n   * 当 curSize <= 0，说明栈中已经没有元素可以出栈了，直接返回 -1\n   * 给栈底 k 个元素增加 val 值时，当 k < curSize，栈底 k 个元素直接加 val；当 k >= curSize，栈中所有的元素都加上 val 值\n\n\n\n**代码**：\n\n```java\nclass CustomStack {\n\n    int[] stack;\n    int maxSize;\n    int curSize;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        this.maxSize = maxSize;\n        this.curSize = 0;\n    }\n    \n    public void push(int x) {\n        if(curSize >= maxSize) return;\n        stack[curSize++] = x;\n    }\n    \n    public int pop() {\n        if(curSize <= 0) return -1;\n        int popValue = stack[curSize - 1];\n        curSize--;\n        return popValue;\n    }\n    \n    public void increment(int k, int val) {\n        int i = 0;\n        while(i < curSize && i < k){\n            stack[i] += val;\n            i++; \n        }\n    }\n}\n```\n\n\n\n**复杂度**分析：\n\n* **时间复杂度**：入栈和出栈的时间复杂度都是O(1)，给k个栈底元素增加val的时间复杂度为O(k)\n* **空间复杂度**：O(N)，需要使用一个数组来存放元素\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"potatoMa":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916923321","body":"### 思路\n***\n先在对应位置一一相加，再进行进位操作\n### 代码\n***\nJavascript code:\n```javascript\nvar addToArrayForm = function(num, k) {\n    let temp = 0;\n    const kLen = k.toString().length;\n    for (let i = 0;i < kLen;i++) {\n        if (num.length < kLen) num.unshift(0);\n        temp = k % 10;\n        k = Math.floor(k / 10);\n        num[num.length - 1 - i] += temp;\n    }\n    const nLen = num.length;\n    for (let i = nLen - 1;i > 0;i--) {\n        if (num[i] >= 10) {\n            num[i - 1] += 1\n            num[i] = num[i] % 10;\n        }\n    }\n    if (num[0] >= 10) {\n        num[0] = num[0] % 10;\n        num.unshift(1);\n    }\n    return num;\n};\n```\n### 复杂度分析\n***\n时间复杂度O(max(N,logk))<br/>\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917350423","body":"### 思路1\n\n***\n\n空间换时间：先记录每一个字符C出现的下标，再遍历一次字符串S，通过下标相减的绝对值找出每个字符距离C最近的距离\n\n### JavaScript代码\n\n***\n\n```javascript\nvar shortestToChar = function(s, c) {\n    const targetIndex = [];\n    for (let i = 0;i < s.length;i++) {\n        if (s[i] === c) {\n            targetIndex.push(i);\n        }\n    }\n    const res = [];\n    for (let i = 0;i < s.length;i++) {\n        let min = Infinity;\n        for (let ti of targetIndex) {\n            if (min <= Math.abs(i - ti)) {\n                break;\n            }\n            min = Math.abs(i - ti);\n        }\n        res.push(min);\n    }\n    return res;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：O(N * K)，K是字符C在字符串S中出现的次数，K <= N\n\n空间复杂度：O(K)\n\n### 思路2\n\n***\n\n贪心，先从左往右遍历S，计算每个下标离左边距离C最近的距离，再从右往左遍历计算一次，如有更小的距离则覆盖\n\n### JavaScript代码\n\n***\n\n```javascript\nvar shortestToChar = function(s, c) {\n    let targetIndex = null;\n    const res = new Array(s.length);\n    for (let i = 0;i < s.length;i++) {\n        if (s[i] === c) targetIndex = i;\n        if (targetIndex === null) {\n            res[i] = Infinity;\n        } else {\n            res[i] = Math.abs(i - targetIndex);\n        }\n    }\n    targetIndex = null;\n    for (let i = s.length - 1;i > -1;i--) {\n        if (s[i] === c) targetIndex = i;\n        if (targetIndex !== null) {\n            res[i] = Math.min(res[i], Math.abs(i - targetIndex));\n        }\n    }\n    return res;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917562392","body":"### 思路\n\n***\n\n简单的栈实现+保存增量，通过哈希表保存每个下标的增量，在pop时再进行increment\n\n### JavaScript代码\n\n***\n\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = new Array();\n    this.maxSize = maxSize;\n    this.hashMap = new Map();\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.maxSize > this.stack.length) {\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    const k = this.stack.length - 1;\n    if (k < 0) return -1;\n    const hashValue = this.hashMap.get(k) || 0;\n    this.hashIncrement(k - 1, hashValue);\n    this.hashMap.set(k, 0);\n    return this.stack.pop() + hashValue;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(index, val) {\n    const k = Math.min(this.stack.length - 1, index - 1);\n    if (k < 0) {\n        return;\n    }\n    this.hashIncrement(k, val);\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.hashIncrement = function(index, val) {\n    if (!this.hashMap.has(index)) {\n        this.hashMap.set(index, val);\n    } else {\n        this.hashMap.set(index, this.hashMap.get(index) + val);\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：push:O(1)、pop:O(1)、increment:O(1)、pop:O(1)\n\n空间复杂度：O(N)、N为min(k, maxSize)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"vincentLW":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916927171","body":"代码\n```\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        int carry = 0;\n        List<Integer> res = new ArrayList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0) {\n            int cur = (i >= 0 ? num[i] : 0) + (k > 0 ? k % 10 : 0) + carry;\n            k = k > 0 ? k / 10 : 0;\n            i = i >= 0 ? i - 1 : -1;\n            carry = cur / 10;\n            cur = cur % 10;\n            res.add(cur);\n        }\n        if (carry == 1) res.add(carry);\n        Collections.reverse(res);\n        return res;\n    }\n```\n时间复杂度：$O(n)$\n空间复杂度：$O(n)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzcyx":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916929362","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        ArrayList list=new ArrayList<Integer>();\n        int f=num.length-1;int carry=0;\n        while(f>=0&&k!=0)\n        {\n            int a=(num[f]+k%10+carry)%10;carry=(num[f]+k%10+carry)/10;\n            list.add(a);\n            f--;k/=10;\n        }\n        while(k>0)\n        {\n            int a=(k%10+carry)%10;carry=(k%10+carry)/10;list.add(a);\n            k/=10;\n        }\n        while(f>=0)\n        {\n            int a=(num[f]+carry)%10;carry=(num[f]+carry)/10;list.add(a);\n            f--;\n        }\n        if(carry>0)list.add(1);\n         Collections.reverse(list);\n         return list;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917326518","body":" \n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int pre=Integer.MIN_VALUE/2;int dist[]=new int[s.length()];\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)==c)\n            {\n                pre=i;\n            }\n            dist[i]=i-pre;\n        }\n        pre=Integer.MAX_VALUE/2;\n        for(int i=s.length()-1;i>=0;i--)\n        {\n            if(s.charAt(i)==c)\n            {\n                pre=i;\n            }\n            dist[i]=Math.min(dist[i],Math.abs(pre-i));\n        }\n        return dist;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917538598","body":"class CustomStack {\n\n    int []s;int maxSize;int top=-1;\n    public CustomStack(int maxSize) {\n        this.maxSize=maxSize;\n        s=new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(top+1<maxSize)s[++top]=x;\n        \n    }\n    \n    public int pop() {\n        if(top==-1)return -1;\n        return s[top--];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<k&&i<=top;i++)\n            s[i]+=val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916930744","body":"### **思路**\n\n倒着过一遍num，和k逐位相加。\n\n1. k的位数：用取mod和地板除可以直接把k用掉的位置扔掉，同时如果要进位，直接进位到k上即可。是一种比较便捷的方式。\n2. 一开始想用先初始化n长度的list存储结果，但是其实list长度很难定，所以可以直接用reverse，reverse复杂度是O(n)\n3. 注意会有k长度比num大的情况的！并不都是k长度小于n\n4. 加法问题记得再研究下模板\n\n    [力扣](https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/)\n\n### **代码**\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # 可能会有k长度大于num的情况\n        # 反转列表\n        res = []\n        n = len(num) - 1\n        for i in range(n, -1, -1):\n            cur_sum = k % 10 + num[i]\n            k = k // 10\n            if cur_sum < 10:\n                res.append(cur_sum)\n            else:\n                res.append(cur_sum % 10)\n                k += 1\n        while k:\n            res.append(k % 10)\n            k //= 10\n        res.reverse()\n        return res\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(min(n,k)) reverse复杂度是O(n) 所以是n长度和k长度最小值\n- 空间复杂度：O(1) 没有额外空间","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917651282","body":"思路\n用数组（在python中一个list）模拟栈\n\n代码\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.max_size = maxSize\n        self.stack = list()\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        else:\n            pop_item = self.stack[-1]\n            self.stack = self.stack[:-1]\n            return pop_item\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n复杂度分析\n时间复杂度：push O(1)；pop O(1); increment O(N)\n空间复杂度：O(N) 这里用到了一个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为 O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jaysonss":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916934318","body":"## 思路\n\n把k转化成数组K，然后让A和K从低位到高位进行相加操作，注意进位问题。\n\n## 关键点\n\n- 如果遍历到最高位后有进位，需要在结果里加上1\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```dart\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> kList = new ArrayList<>();\n\n        while (k != 0) {\n            kList.add(k % 10);\n            k /= 10;\n        }\n        Collections.reverse(kList);\n        int i = num.length - 1;\n        int j = kList.size() - 1;\n        List<Integer> retList = new ArrayList<>();\n        int delta = 0;\n\n        while (i >= 0 || j >= 0) {\n            int a = i >= 0 ? num[i] : 0;\n            int b = j >= 0 ? kList.get(j) : 0;\n            int v = a + b + delta;\n            \n            if (v > 9) {\n                retList.add(v % 10);\n                delta = 1;\n            } else {\n                retList.add(v);\n\t\tdelta = 0;\n            }\n            i--;\n            j--;\n        }\n\n        if (delta == 1) {\n            retList.add(1);\n        }\n        Collections.reverse(retList);\n        return retList;\n    }\n\n}\n```\n\n**复杂度分析**\n\n时间复杂度：k的取值范围是1-10000，数组K最大长度为5，主要看num的长度，因此为O(n)\n\n空间复杂度：保存结果的List长度主要由num决定，因此为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917428343","body":"## 思路\n\n遍历数组，如果当前字符不是目标字符就记录下位置，如果是目标字符就查看下缓存的所有非目标字符的位置，\n\n这里存在两种情况：第一种是之前还没遍历到目标字符，则位置差可以直接计算出来。第二种是之前有记录过最后一个目标字符的位置，此时需要比较哪个距离更小。处理完成后更新最后一个字符索引继续遍历。\n\n## 关键点\n\n- 边界条件：如果遍历结束还有很多非目标字符被缓存，需要计算它们和最后一个目标字符位置的距离\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int lastIdx = -1;\n        int[] disArr = new int[s.length()];\n        int disIdx = 0;\n        List<Integer> idxList = new ArrayList<>();\n\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                boolean hasLastIdx = lastIdx == -1;\n                for (int idx : idxList) {\n                    disArr[disIdx++] = hasLastIdx ? i - idx : Math.min(i - idx, idx - lastIdx);\n                }\n                disArr[disIdx++] = 0;\n                lastIdx = i;\n                idxList.clear();\n            } else {\n                idxList.add(i);\n            }\n        }\n        if(!idxList.isEmpty()){\n            for(int idx: idxList){\n                disArr[disIdx++] = idx-lastIdx;\n            }\n        }\n        return disArr;\n    }\n}\n```\n\n**复杂度分析**\n\n时间复杂度：就遍历了一次字符串，所以为O(n)\n\n空间复杂度：缓存非目标字符位置的List和数组长度相关，最坏情况下可能就是字符串长度，因此为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917659430","body":"## 思路\n\n用数组来模拟栈，用指针记录下栈顶的索引即可。\n\n## 关键点\n\n-  无\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\nclass CustomStack {\n\t\t\n    int[] _data;\n\n    int idx = -1;\n\n    public CustomStack(int maxSize) {\n        _data = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (idx == _data.length - 1)\n            return;\n        _data[++idx] = x;\n    }\n\n    public int pop() {\n        if (idx == -1)\n            return -1;\n        return _data[idx--];\n    }\n\n    public void increment(int k, int val) {\n        for (int i = 0; i <= Math.min(k - 1, idx); i++) {\n            _data[i] = _data[i] + val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：push和pop操作都是O(1)，increase是O(min(k,idx)), idx为栈目前的大小\n- 空间复杂度：数组占用为O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Bochengwan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916934555","body":"### 思路\r\n\r\n从个位开始加，如果加到最后比原数组长，则把多余的位数append到左边。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n\r\n        digits = len(A)-1\r\n        \r\n        left = K\r\n        \r\n        while left!=0 and digits != -1:\r\n            result = left+A[digits]\r\n            left, A[digits] = result//10, result%10\r\n            digits-=1\r\n            \r\n        if digits == -1 and left!=0:\r\n            while left!=0:\r\n                A = [left%10]+A\r\n                left = left//10\r\n\r\n        return A\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917422452","body":"### 思路\r\n\r\n两次扫描，一次从左到右，一次从右到左，然后第二次需要比较第一次的结果，取较小的那个。\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\n        distance = [sys.maxsize]*len(S)\r\n        prev_c = -sys.maxsize\r\n        for i in range(len(S)):\r\n            if S[i]==C:\r\n                prev_c = i\r\n            distance[i] = i-prev_c\r\n        prev_c = sys.maxsize\r\n        \r\n        for i in range(len(S)-1,-1,-1):\r\n            if S[i]==C:\r\n                prev_c = i\r\n            distance[i] = min(prev_c-i,distance[i])\r\n        return distance\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917661940","body":"### 思路\r\n\r\n通过数组模拟stack。\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.myStack = []\r\n        self.delta = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.myStack)<self.maxSize:\r\n            self.myStack.append(x)\r\n            self.delta.append(0)\r\n        \r\n        \r\n        \r\n\r\n    def pop(self) -> int:\r\n        if len(self.myStack)==0:\r\n            return -1\r\n        delta = self.delta.pop()\r\n        \r\n        if self.delta:\r\n            self.delta[-1]+=delta\r\n        return self.myStack.pop()+delta\r\n        \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        length = len(self.myStack)\r\n        if length ==0:\r\n            return None\r\n        inc_length = k\r\n        if k>length:\r\n            inc_length = length\r\n        \r\n        self.delta[inc_length-1]+=val\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：pop O(1), PUSH O(1), INCREMENT O(min(k, N),其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917664701","body":"### 思路\r\n\r\n利用两个栈，一个存数字，一个存字符，每次遇到括号进行处理。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        bracket_stack = []\r\n        number_stack = []\r\n        c = ''\r\n        n = ''\r\n        for e in s:\r\n            \r\n            if e.isdigit():\r\n                n+=e\r\n            elif e == '[':\r\n                bracket_stack.append(c)\r\n                number_stack.append(n)\r\n                n = ''\r\n                c = ''\r\n            elif e == ']':\r\n                \r\n                c = (bracket_stack.pop() + c*int(number_stack.pop()))\r\n            else:\r\n                c += e\r\n        return c\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(m+n), m = len(number_stack), n = len(bracket_stack）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maxsarratt":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916935148","body":"### 代码\r\n\r\n```java\r\n// Time: O(max(n, log(k))) ; Space: O(max(n, log(k)))\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        if (num == null || num.length == 0) {\r\n            return new LinkedList<>();\r\n        }\r\n\r\n        List<Integer> result = new LinkedList<>();\r\n\r\n        int carry = 0;\r\n        int index = num.length - 1;\r\n        while (index >= 0 || k != 0) {\r\n            int sum = carry;\r\n\r\n            if (index >= 0) {\r\n                sum += num[index--];\r\n            }\r\n            if (k != 0) {\r\n                sum += k % 10;\r\n            }\r\n\r\n            result.add(0, sum % 10);\r\n            carry = sum / 10;\r\n            k /= 10;\r\n        }\r\n\r\n        if (carry != 0) {\r\n            result.add(0, carry);\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917334801","body":"### 代码\r\n\r\n```java\r\n// Time: O(n); Space: O(n)\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {        \r\n        int len = s.length();\r\n\r\n        List<Integer> list = new LinkedList<>();\r\n        for (int i = 0; i < len; i++) {\r\n            if (s.charAt(i) == c) {\r\n               list.add(i);\r\n            }\r\n        }\r\n        \r\n        int p = 0;\r\n        int[] res = new int[len];\r\n        \r\n        for (int i = 0; i < len; i++) {\r\n            if (p < list.size() - 1 && Math.abs(list.get(p) - i) > Math.abs(list.get(p + 1) - i)) {\r\n                p++;\r\n            }\r\n            res[i] = Math.abs(list.get(p) - i);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bxcharlie":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916935576","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& B, int k) {\n         vector<int> result;\n    for (int i = B.size() - 1; i >= 0; i --) {\n        int num = B[i];\n        k += num; \n        int remind = k % 10;\n        result.insert(result.begin(), remind);\n        k /= 10;\n    }\n    if (k) {\n        while (k > 9) { \n            int remind = k % 10;\n            result.insert(result.begin(), remind);\n            k /= 10;\n        }\n        result.insert(result.begin(), k);\n    }\n    return result;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917424870","body":"# C++ \n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> answer(s.size());\n        int prev = -100000;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == c) {\n                prev = i;\n            }\n            answer[i] = i - prev;\n        }\n        prev = 20000;\n        for (int i = s.size() - 1; i >= 0; i--) {\n            if (s[i] == c){\n                prev = i;\n            }\n            answer[i] = min(answer[i], prev - i);\n        }\n        return answer;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917657004","body":"```C++\nclass CustomStack {\nprivate:\n    int m_maxSize = 0;\n    vector<int> stk;\npublic:\n    CustomStack(int maxSize) {\n        m_maxSize = maxSize;\n    }\n    \n    void push(int x) {\n        if(stk.size() == m_maxSize){\n            return;\n        }\n        stk.push_back(x);\n    }\n    \n    int pop() {\n        if(stk.empty()){\n            return -1;\n        }\n        int top = stk.back();\n        stk.pop_back();\n        return top;\n    }\n    \n    void increment(int k, int val) {\n        int i = 0;\n        while(i < k && i < stk.size()){\n            stk[i] += val;\n            i++;\n        }\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zszs97":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916938349","body":"# 开始刷题\r\n\r\n## 题目简介\r\n\r\n \r\n【Day 1 】2021-09-10 - 989. 数组形式的整数加法 \r\n-------------------\r\n\r\n\r\n### 题目思路\r\n\r\n1、注意进位\r\n2、如果全部加完还有进位，需要特殊处理。 比如 A = [2], K = 998\r\n\r\n## 题目代码\r\n### 代码块\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> sum;\r\n        int size = num.size();\r\n        for(int i = size-1;i>=0;i--)\r\n        {\r\n            int nsum = num[i] + k % 10;\r\n            k/= 10;\r\n            if(nsum>=10)\r\n            {\r\n                k++;\r\n                nsum-=10;\r\n            }\r\n            sum.push_back(nsum);\r\n        }\r\n        //如果全部加完还有进位 如2+998\r\n        while(k>0)\r\n        {\r\n            sum.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(sum.begin(),sum.end());\r\n        return sum;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n+ 空间复杂度 O(1)\r\n+ 时间复杂度 O(n + logk + resLength)，其中 n 为数组的长度；resLength是res这个vector的长度，来自于reverse的时间消耗\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917423261","body":"# 开始刷题\r\n\r\n## 题目简介\r\n\r\n \r\n【Day 2 】2021-09-11 - (821. 字符的最短距离)\r\n-------------------\r\n\r\n\r\n### 题目思路\r\n\r\n+ 从当前下标出发，分别向左、右两个方向去寻找目标字符 C。\r\n+ 只在一个方向找到的话，直接计算字符距离\r\n+ 两个方向都找到的话，取两个距离的最小值\r\n+ 正反两趟遍历，比较与c的距离，取小的值\r\n\r\n## 题目代码\r\n### 代码块\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> str(s.length());\r\n\r\n        for(int i = 0;i<s.length();i++)\r\n        {\r\n            if(s[i] == c) continue;\r\n            int left = i;\r\n            int right = i;\r\n            int dist = 0;\r\n            while(left >0 || right <= s.length()-1){  //left:往左边的指针 right：往右边的指针\r\n                if(s[left] == c) {\r\n                    dist = i-left;\r\n                    break;\r\n                }\r\n                if(s[right] == c){\r\n                    dist = right -i;\r\n                    break;\r\n                }\r\n                if(left>0) left--;\r\n                if(right<s.length()-1) right++;\r\n            }\r\n            str[i] = dist;\r\n        }\r\n        return str;\r\n        \r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n+ 空间复杂度 O(N)\r\n+ 时间复杂度 O(N)，其中 N 为数组的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917590698","body":"# 开始刷题\r\n\r\n## 题目简介\r\n\r\n \r\n【Day 3 】2021-09-12 - (1381. 设计一个支持增量操作的栈)\r\n-------------------\r\n\r\n\r\n### 题目思路\r\n\r\n+ 用数组模拟栈 设置top和最大长度\r\n+ 只用判断k和长度的大小，哪个小就循环多少次的增加val\r\n\r\n\r\n## 题目代码\r\n### 代码块\r\n``` c++\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stack;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize);  //resize()设置当前容器大小\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top != stack.size()-1)\r\n        {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if( top == -1)\r\n        return -1;\r\n        --top;\r\n        return stack[top+1];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int y = min(top+1,k);\r\n        for(int i = 0;i<y;i++)\r\n            stack[i]+=val;\r\n        \r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```\r\n\r\n## 复杂度\r\n+ 空间复杂度 O(maxSize)\r\n+ 时间复杂度 O(k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yj9676":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916941829","body":"## LC989 数组形式的整数加法\r\n### Array\r\n\r\n---\r\n### 思路\r\n与LC2 两数相加类似，从末位开始逐位相加，最后判断carry是否为0\r\n\r\n```\r\nwhile (元素A不为null或者未结束 || 元素B不为null或者未结束)\r\n    currA\r\n    currB\r\n\r\n    sum = currA + currB + carry\r\n\r\n    curr = sum % 10;\r\n    carry = sum / 10;\r\n```\r\n#### Solution\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n        List<Integer> ans = new ArrayList<Integer>();\r\n        int step = len - 1;\r\n        int sum = 0;\r\n        int carry = 0;\r\n\r\n        while (step >= 0 || k != 0){\r\n            int x = step >= 0 ? num[step] : 0;\r\n            int y = k != 0 ? k % 10 : 0;\r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            k = k / 10;\r\n\r\n            ans.add(sum % 10);\r\n            step--;\r\n        }\r\n\r\n        if (carry != 0){\r\n            ans.add(carry);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n* 时间复杂度 : *O(max(num.length, logk))*\r\n\r\n* 空间复杂度 : *O(1)* \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917395387","body":"## LC821 字符的最短距离\n### String\n\n---\n### 思路\n遍历两次，一次从左遍历，一次从右遍历，判断两次距离上次字符C所在位置距离的最短\n\n#### Solution\n\n```\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int len = S.length();\n        int[] ans = new int[len];\n        int cPosition = -100000;\n\n        for (int i = 0; i < len; ++i) {\n            if (S.charAt(i) == C) cPosition = i;\n            ans[i] = i - cPosition;\n        }\n\n        cPosition = 100000;\n        for (int i = len-1; i >= 0; --i) {\n            if (S.charAt(i) == C) cPosition = i;\n            ans[i] = Math.min(ans[i], cPosition - i);\n        }\n\n        return ans;\n    }\n}\n\n```\n\n**复杂度分析**\n\n* 时间复杂度 : *O(n)*\n\n* 空间复杂度 : *O(n)* \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917627418","body":"[TOC]\n## LC1381 设计一个支持增量操作的栈 [Medium]\n**Design a Stack With Increment Operation**\n\n- None\n- [link](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n---\n### 思路1\nstack是已知顶部元素的结构，需要一个变量记录最顶部当前位置\npop和push常规stack操作\n对于Inc函数，需要整个stack元素都已知，可以采用数组来模拟\n\n#### Solution1\n\n```\nclass CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        int maxSize = stack.length;\n        if(top != maxSize - 1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top > -1){\n            int popNum = stack[top];\n            top--;\n            return popNum;\n        }else{\n            return -1;\n        }\n    }\n    \n    public void increment(int k, int val) {\n         int maxAdded = Math.min(k, top+1);\n         for(int i=0; i<maxAdded; i++){\n             stack[i] += val;\n         }\n    }\n}\n\n```\n**复杂度分析**\n\n* 时间复杂度 : 初始化/push/pop *O(1)*, Inc *O(k)*\n\n* 空间复杂度 : *O(maxSize)* \n\n---\n### 思路2\n如果采用数组模拟需要遍历数组的所有元素\n可以采用一个add[]数组，记录每次执行inc函数前k个变化的增量\n再进行pop操作时只需要top+增量就可以知道最终值,然后将最顶端的值往下传递，add[top-1] += add[top]\n\n#### Solution2\n\n```\nclass CustomStack {\n    int[] stack;\n    int[] add;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        add = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        int maxSize = stack.length;\n        if(top != maxSize - 1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1){\n            return -1;\n        }\n        int ans = stack[top]+add[top];\n        if (top>0){\n            add[top-1] += add[top];\n        }\n        add[top] = 0;\n        top--;\n        return ans;\n    }\n    \n    public void increment(int k, int val) {\n         int maxAdded = Math.min(k-1, top);\n         if (maxAdded >= 0){\n             add[maxAdded] += val;\n         }\n    }\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度 : *O(1)*\n\n* 空间复杂度 : *O(maxSize)* \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carreylife":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916945203","body":"### 思路\n加法运算，用 `carry` 来表示进位，反向遍历数组即可。\n\n遍历结束条件：\n\n1. 数组所有元素都遍历过了\n2. 当 K 为 0 的时候\n\n需要注意的点：\n\n如果遍历结束后 `carry` 大于 0，还需要在数组前面补一位。\n\n### JS代码\n```javascript\nvar addToArrayForm = function(A, K) {\n  const res = []\n  let i = A.length - 1, carry = 0\n  while (i >=0 || K != 0) {\n      const x = i >= 0 ? A[i] : 0\n      const y = K != 0 ? K % 10 : 0\n\n      const sum = x + y + carry\n      res.push(sum % 10)\n      carry = Math.floor(sum / 10)\n\n      i--\n      K = Math.floor(K / 10)\n  }\n  if (carry) res.push(carry)\n  return res.reverse()\n};\n```\n\n**复杂度分析**\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917415190","body":"### 思路\n正反两边同时遍历找到距离目标值最小的距离\n\n### 代码\n```js\n/**\n * @param {string} s = \"loveleetcode\"\n * @param {character} c = \"e\"\n * @return {number[]} [3,2,1,0,1,0,0,1,2,2,1,0]\n */\nvar shortestToChar = function (s, c) {\n  let res = Array(s.length).fill(0);\n\n  for (let i = 0; i < s.length; i++) {\n    // 如果当前位置是目标字符就跳出\n    if (s[i] === c) continue;\n    // 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let left = i,\n      right = i,\n      shortest = Infinity;\n\n    while (left >= 0) {\n      if (s[left] === c) {\n        shortest = Math.min(shortest, i - left);\n        break;\n      }\n      left--;\n    }\n\n    while (right < s.length) {\n      if (s[right] === c) {\n        shortest = Math.min(shortest, right - i);\n        break;\n      }\n      right++;\n    }\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n***复杂度***\n\n- 时间复杂度: O(N^2)\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917627794","body":"### 思路\n使用数组来模拟栈\n### 代码 js\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.list = [];\n  this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.list.length < this.maxSize) {\n    this.list.push(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  const item = this.list.pop();\n  return item === void 0 ? -1 : item;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  for (let i = 0; i < k && i < this.list.length; i++) {\n      this.list[i] += val;\n  }\n};\n```\n***复杂度分析***\n- 时间复杂度  `push` 和 `pop` 是 $O(1)$，`increment ` 是 $O(k)$。\n- 空间复杂度  空间复杂度：$O(maxSize)$。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fzzfgbw":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916945692","body":"### 思路\r\n\r\n从后往前加、再反转\r\n\r\n### 代码\r\n\r\n\r\n```go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n\tvar res []int\r\n\tfor i:= len(num)-1;i>=0||k>0;i-- {\r\n\t\tif i >= 0 {\r\n\t\t\tk+=num[i]\r\n\t\t}\r\n\t\tres = append(res,k%10)\r\n\t\tk/=10\r\n\t}\r\n\tfor i,n:=0,len(res);i<n/2 ;i++{\r\n\t\tres[i],res[n-i-1] = res[n-i-1],res[i]\r\n\t}\r\n\treturn res\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(max(n,log(k)))。\r\n- 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917041009","body":"### 思路\n\n从左遍历，找到左边最近距离；\n从右边遍历，找到右边最近的距离并与之前左边最近距离相比较。\n\n### 代码\n\n\n```go\nfunc shortestToChar(s string, c byte) []int {\n\tvar ans []int\n\tcurr := -len(s)\n\tfor i := range s {\n\t\tif s[i] == c {\n\t\t\tcurr = i\n\t\t\tans = append(ans, 0)\n\t\t} else {\n\t\t\tans = append(ans, i-curr)\n\t\t}\n\t}\n\tcurr = 2*len(s)\n\tfor i := len(s) - 1; i >= 0; i-- {\n\t\tif s[i] != c {\n\t\t\tif curr-i < ans[i] {\n\t\t\t\tans[i] = curr - i\n\t\t\t}\n\t\t} else {\n\t\t\tcurr = i\n\t\t}\n\t}\n\treturn ans\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(1)。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917442498","body":"### 思路\n\n\n\n### 代码\n\n\n```go\ntype CustomStack struct {\n\tstack []int\n}\n\nfunc Constructor(maxSize int) CustomStack {\n\treturn CustomStack{make([]int, 0,maxSize)}\n}\n\nfunc (this *CustomStack) Push(x int) {\n\tif len(this.stack) < cap(this.stack) {\n\t\tthis.stack = append(this.stack, x)\n\t}\n}\n\nfunc (this *CustomStack) Pop() int {\n\tif len(this.stack) > 0 {\n\t\tres := this.stack[len(this.stack)-1]\n\t\tthis.stack = this.stack[:len(this.stack)-1]\n\t\treturn res\n\t} else {\n\t\treturn -1\n\t}\n}\n\nfunc (this *CustomStack) Increment(k int, val int) {\n\tif k > len(this.stack) {\n\t\tk = len(this.stack)\n\t}\n\tfor i := 0; i < k; i++ {\n\t\tthis.stack[i] += val\n\t}\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度： push 、pop O(1)    increment：（O(min(k,len(stack)))）\n- 空间复杂度：O(1)。\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Zzh-Zh3nDu1":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916946095","body":"## 思路\r\n先在对应位置一一相加，再进行进位操作\r\n\r\n## 代码\r\nJavascript code:\r\n\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    let temp = 0;\r\n    const kLen = k.toString().length;\r\n    for (let i = 0;i < kLen;i++) {\r\n        if (num.length < kLen) num.unshift(0);\r\n        temp = k % 10;\r\n        k = Math.floor(k / 10);\r\n        num[num.length - 1 - i] += temp;\r\n    }\r\n    const nLen = num.length;\r\n    for (let i = nLen - 1;i > 0;i--) {\r\n        if (num[i] >= 10) {\r\n            num[i - 1] += 1\r\n            num[i] = num[i] % 10;\r\n        }\r\n    }\r\n    if (num[0] >= 10) {\r\n        num[0] = num[0] % 10;\r\n        num.unshift(1);\r\n    }\r\n    return num;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度O(max(N,logk))\r\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917405319","body":"## 思路\n先取到所有 c 的 index,存到数组里\n从头 循环字符串,与靠近右边的 c 比较,把结果存到一个数组 res 中\n从尾 循环字符串,与靠左边的 c 比较, 再把这个值与 res 中的结果比较\n\n## 代码 js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\n```\nvar shortestToChar = function (s, c) {\n  let cs = []\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == c) {\n      cs.push(i)\n    }\n  }\n  let j = 0,\n    res = []\n  for (let i = 0; i < s.length; i++) {\n    res.push(Math.abs(i - cs[j]))\n\n    if (i == cs[j] && j < cs.length - 1) {\n      j++\n    }\n  }\n\n  for (let i = s.length - 1; i > 0; i--) {\n    if (Math.abs(i - cs[j]) < res[i]) {\n      res[i] = Math.abs(i - cs[j])\n    }\n\n    if (i == cs[j] && j > 0) {\n      j--\n    }\n  }\n\n  return res\n}\n```\n\n## 复杂度分析\n时间复杂度：O(3n)\n空间复杂度：O(3)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Weisday":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916946830","body":"#### 思路\n\n​\t将数组倒序遍历，分别使用school method addition，逐位相加。\n\n​\t自己一开始在遍历中没有考虑 `i >= 0 || k > 0` 中的k在数组遍历后不为零的情况。后来在参考别人的解析后意识到了这一点。\n\n#### 代码\n\n~~~c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        res.reserve(num.size() + 1);\n        for (int i = num.size() - 1; i >= 0 || k > 0; --i)\n        {\n            k += (i >= 0 ? num[i] : 0);\n            res.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(begin(res), end(res));\n        return res;\n    }\n};\n\n\n~~~\n\n#### 复杂度分析\n\n时间复杂度： O(max(n,k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917415329","body":"#### 思路\n\n正反两次遍历，取更小的一个值\n\n#### 代码\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> res(n);\n\n        int pre = INT_MAX / 2;\n        for(int i = 0; i < n; i++)\n        {\n            if(s[i] == c)\n                pre = i;\n            res[i] = abs(pre - i);\n        }\n        \n        for(int i = n - 1; i >= 0; i--)\n        {\n            if(s[i] == c)\n                pre = i;\n            res[i] = min(res[i], abs(pre - i));\n        }\n        return res;\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917645818","body":"#### 代码\n\n```C++\nclass CustomStack {\nprivate:\n    vector<int> vec;\n    int maxsize;\n    \npublic:\n    CustomStack(int maxSize) {\n        maxsize = maxSize;\n        vec.clear();\n        vec.reserve(maxsize);\n    }\n    \n    void push(int x) {\n        if(vec.size() == maxsize)\n            return ;\n        vec.push_back(x);\n    }\n    \n    int pop() {\n        if (vec.empty()) \n            return -1;\n        int res = vec.back();\n        vec.pop_back();\n        return res;\n    }\n    \n    void increment(int k, int val) {\n        k = std::min(static_cast<size_t>(k),vec.size());\n        for (int i = 0; i < k; ++i)\n            vec[i] += val;\n    }\n};\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jsyxiaoba":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916948342","body":"## 思路\n\n从最低位开始相加，k = 123， X = [4,5,6]，\n[4,5,6+123] --> [4,5,129] --> 129 % 10 --> 9 --> [4,5,9] --> 129 - 9 --> 120 --> Matn.floor(120 / 10) --> 12 --> [4,5+12,9]\n......\n\n## js代码\n\n```js\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\n        if (i >= 0) {\n            k += num[i];\n        }\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n``` \n\n## 复杂度\n\n* 时间复杂度：O(max(n,logk))，其中 n 为数组的长度\n* 空间复杂度：O(1)。除了返回值以外，使用的空间为常数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917428632","body":"## 思路\n把 C 看成分界线，将 S 划分成一个个窗口。然后对每个窗口进行遍历，分别计算每个字符到窗口边界的距离最小值 <br/>\n如：s = 'woshicaiji' ,   c = 'i' <br>\n第一个窗口：woshi   <br>\n第二个窗口：icai   <br>\n第三个窗口：iji\n\n## js代码\n```ls\nvar shortestToChar = function (S, C) {\n  // 窗口左边界，如果没有就初始化为 Infinity，初始化为 S.length 也可以\n  let l = S[0] === C ? 0 : Infinity,\n    // 窗口右边界\n    r = S.indexOf(C, 1);\n\n  const res = Array(S.length);\n\n  for (let i = 0; i < S.length; i++) {\n    // 计算字符到当前窗口左右边界的最小距离\n    res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\n\n    // 遍历完了当前窗口的字符后，将整个窗口右移\n    if (i === r) {\n      l = r;\n      r = S.indexOf(C, l + 1);\n    }\n  }\n\n  return res;\n};\n```\n\n## 复杂度\n* 时间复杂度：O(N) N是字符串S的长度\n* 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917627439","body":"## js代码\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize = maxSize;\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n\r\n    if(this.stack.length < this.maxSize){\r\n        this.stack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n\r\n    return this.stack.length > 0 ? this.stack.pop() : -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const len = Math.min(this.stack.length, k);\r\n    for(let i = 0;i < len; i++){\r\n        this.stack[i] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度： push:O(1)、pop：O(1)、increment：O(N) ，N为min(K， 栈中元素的个数)\r\n- 空间复杂度：O(N)，N为maxSize","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carterrr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916951028","body":"class 989_数组形式的加法{\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        for(int i = num.length - 1; i >= 0 || k > 0 ; i--) {\n            if(i >=0) {\n             k +=  num[i];\n            }\n            res.add(k % 10);\n            k /= 10;\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917393635","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        // 双轮遍历  填充最大值用于回头的时候取到最小值 如果不填充在头部的时候最小值全是0\n        Arrays.fill(res, s.length());\n        int cur = -1;\n        for(int i = 0; i < s.length(); i++) {\n            if(s.charAt(i) == c) {\n                cur = i;\n                res[i] = 0;\n                continue;\n            }\n\n            if(cur != -1) {\n                res[i] = i - cur;\n            }\n        }\n\n        cur = -1;\n        for(int i = s.length() - 1; i >= 0; i--) {\n            if(s.charAt(i) == c) {\n                cur = i;\n                continue;\n            }\n\n            if(cur != -1) {\n                res[i] = Math.min(res[i], cur - i);\n            }\n        }\n\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917596410","body":"  private int[] stack ;\n    private int[] inc;\n    private int top = -1;// 初始栈空  top指向当前栈顶元素的位置\n    public CustomStack_TrieSum(int maxSize) {\n        stack = new int[maxSize];\n        inc = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if(top < stack.length - 1) {\n            stack[++top] = x;\n        }\n    }\n\n    public int pop() {\n        if(top == -1) return -1;\n        int res = stack[top] + inc[top];\n        if(top > 0) {\n            inc[top - 1] += inc[top];\n        }\n        inc[top] = 0;// 避免increment方法再次自增的时候又加上了\n        top --;\n        return res;\n    }\n\n    public void increment(int k, int val) {\n        int incMax = Math.min(top, k - 1);\n        // 要给对应位置赋值  incMax应该指向最大位置\n        if(incMax >= 0) {\n            // 注意是叠加  不能直接赋值 =\n            inc[incMax] += val;\n        }\n    }","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ff1234-debug":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916953423","body":"> #### 思路\r\n> ​将k视为整体直接与最低位相加，进行取余，进位，最后再对k进行取余，进位\r\n> \r\n> ​ 数组逆置是为了便于最后单独对k的处理\r\n> \r\n> #### 代码\r\n> c++\r\n>\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) \r\n    {\r\n        if(k==0) return num;\r\n        int res=0,c=0,n=num.size();\r\n        reverse(num.begin(),num.end());\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            k=k+num[i];\r\n            num[i]=k%10;\r\n            k/=10;\r\n        }\r\n        while(k!=0)\r\n        {\r\n            num.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(num.begin(),num.end());\r\n        return num;\r\n    }\r\n};\r\n```\r\n\r\n> #### 复杂度分析\r\n> 时间复杂度： O(max(n,log(k))\r\n>空间复杂度： O(1)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917374548","body":"> ### 思路\r\n> 从头到尾和从尾到头分别遍历两次数组，分别找到字符左边和右边的目标字符最小距离，再取两者之间的最小值。 \r\n> ### 代码\r\n>   c++\r\n ```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) \r\n    {\r\n        int n=s.length();\r\n        vector<int> ans(n);\r\n        int before=n+5;\r\n        for(int i=0;i<n;i++)\r\n        {\r\n           if(s[i]==c) before=i;\r\n           ans[i]=abs(i-before);\r\n        }\r\n        int after=2*n+5;\r\n        for(int i=n-1;i>=0;i--)\r\n        {\r\n            if(s[i]==c) after=i;\r\n            ans[i]=min(abs(after-i),ans[i]);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n> ### 复杂度\r\n> 时间复杂度：O(n)\r\n> 空间复杂度：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917598929","body":"> ## 思路\r\n> vecor模拟栈的操作，优化时新增一个vector用于存放增量，在出栈时才进行相加\r\n> \r\n> ### c++ vector实现 \r\n``` \r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) \r\n    {\r\n        q.resize(maxSize);\r\n        inc.resize(maxSize);\r\n        top=-1;\r\n    }\r\n    \r\n    void push(int x) \r\n    {\r\n        if(top!=q.size()-1) \r\n        {\r\n          top++;\r\n          q[top]=x;\r\n        }\r\n    }\r\n    \r\n    int pop() \r\n    {\r\n       if(top==-1) return -1;\r\n       int x=q[top]+inc[top];\r\n       if(top!=0) inc[top-1]+=inc[top];\r\n       inc[top]=0;\r\n       top--;\r\n       return x;\r\n    }\r\n    \r\n    void increment(int k, int val) \r\n    {\r\n        int n=top<k-1?top:k-1;\r\n        if(n>=0) inc[n]+=val;\r\n    }\r\nprivate:\r\n    vector<int> q;\r\n    vector<int> inc;\r\n    int top;\r\n};\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```\r\n> ## 复杂度分析\r\n> * **时间复杂度**:  O(1)\r\n> * **空间复杂度**  O(maxSize)的栈空间\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzhsaga":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916953516","body":"Code:\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n\nTc：O(max(n,logk)) \n\nSc：O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917254115","body":"### Code\r\n```\r\npublic class test {\r\n    public static int[] shortestToChar(String s, char c) {\r\n        int l = s.length();\r\n        int[] ans = new int[l];\r\n        int prev = -10000;\r\n        for (int i = 0; i < l; i++){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            ans[i] = i-prev;\r\n        }\r\n        prev = 10000;\r\n        for (int i = l - 1; i >=0; i--){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            ans[i] = Math.min(prev - i, ans[i]);\r\n        }\r\n        return ans;\r\n    }\r\n```\r\n### Complexity Analysis\r\n- TC: O(n)\r\n- SC: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heyqz":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916955471","body":"## 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        carry = 0\r\n        for i in range(len(num)-1, -1, -1):\r\n            remain = k % 10\r\n            k = k // 10\r\n            total = num[i] + remain + carry\r\n            carry = total // 10\r\n            res.append(total % 10)\r\n        \r\n        k = k + carry\r\n        while k:\r\n            res.append(k % 10)\r\n            k //= 10\r\n        \r\n        res.reverse()\r\n        return res\r\n```\r\n## 复杂度\r\n* time complexity: O(max(n, logk))\r\n* space complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917420910","body":"## 思路\r\n分别从左和从右两次遍历\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        left, right, res = [None] * n, [None] * n, [None] * n\r\n        \r\n        tmp = float('inf')\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                tmp = 0\r\n            left[i] = tmp\r\n            tmp += 1\r\n                \r\n        tmp = float('inf')\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                tmp = 0\r\n            right[i] = tmp\r\n            tmp += 1\r\n            \r\n        for i in range(n):\r\n            res[i] = min(left[i], right[i])\r\n            \r\n        return res\r\n```\r\n## 复杂度\r\n* time complexity: O(n)\r\n* space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917654431","body":"## code\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.cur_size = 0\r\n        self.size = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cur_size < self.size:\r\n            self.stack.append(x)\r\n            self.cur_size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.cur_size == 0:\r\n            return -1\r\n        self.cur_size -= 1\r\n        return self.stack.pop()\r\n        \r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, self.cur_size)):\r\n            self.stack[i] += val\r\n```\r\n## complexity\r\n* time complexity: push, pop: O(1), inc: O(k)\r\n* space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917721498","body":"## 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        \r\n        for c in s:\r\n            if c != \"]\":\r\n                stack.append(c)\r\n            else:\r\n                substr = \"\"\r\n                while stack[-1] != \"[\":\r\n                    substr = stack.pop() + substr\r\n                stack.pop() # pop out the \"[\"\r\n                \r\n                k = \"\"\r\n                while stack and stack[-1].isdigit(): \r\n                    k = stack.pop() + k\r\n                stack.append(int(k) * substr)\r\n        \r\n        return \"\".join(stack)\r\n```\r\n## 复杂度\r\n* time complexity: O(n)\r\n* space complexity: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Lovemyse1f":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916956842","body":"思路：题解\n\n代码（python）\nclass Solution(object):\n    def addToArrayForm(self, num, K):\n        i = len(num) - 1\n        while K:\n            num[i] += K#\n            K, num[i] = num[i] // 10, num[i] % 10#\n            i -= 1\n\n            if i < 0 and K:\n                num.insert(0,0)\n                i = 0\n        return num\n复杂度：\n时间O（N）\n空间O(|K-N|)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Clarence5":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916962545","body":"```js\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\n        if (i >= 0) {\n            k += num[i];\n        }\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n\naddToArrayForm([1,2,6,3,0,7,1,7,1,9,7,5,6,6,4,4,0,0,6,3],516);\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MissNanLan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916962803","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n \n\n示例 1：\n\n输入：A = [1,2,0,0], K = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：A = [2,7,4], K = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：A = [2,1,5], K = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n示例 4：\n\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\n输出：[1,0,0,0,0,0,0,0,0,0,0]\n解释：9999999999 + 1 = 10000000000\n\n\n \n\n提示：\n\n1 <= A.length <= 10000\n0 <= A[i] <= 9\n0 <= K <= 10000\n如果 A.length > 1，那么 A[0] != 0\n```\n\n## 前置知识\n\n- 求第一个非负整数的个位与第一位分别是求余、除以10\n\n## 公司\n\n- 暂无\n\n## 思路\n\n逐位相加法\n\n## 关键点\n\n-  两数相加超过10怎么用代码表示\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (n, k) {\n  var res = [];\n  for (var i = n.length - 1; i >= 0; --i) {\n    var sum = n[i] + (k % 10);\n    k = Math.floor(k / 10);\n    if (sum >= 10) {\n      k++;\n      sum = sum - 10;\n    }\n    res.push(sum);\n  }\n  for (; k > 0; k = Math.floor(k / 10)) {\n    res.push(k % 10);\n  }\n  return res.reverse();\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917645843","body":"## 前置知识\n\n- 栈先进后出\n- js原型知识\n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n-  时间复杂度的优化。从O(k)->O(1)\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.arr = new Array(max);\n  this.maxSize = maxSize;\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.arr.length < this.maxSize) {\n    return this.arr.push(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  if (this.arr.length > 0) {\n    return this.arr.pop();\n  }\n  return -1;\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  for (var i = 0; i < k && i < this.arr.length; i++) {\n    this.arr[i] += val;\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(k)\n- 空间复杂度：O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JinhMa":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916963481","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        int len = A.length;\n        int lastNum =K;\n        LinkedList<Integer> ret= new LinkedList<>();\n\n        int i = len-1;\n        while(i >=0 || lastNum > 0){\n            if(i >= 0){\n                lastNum+=A[i];\n            }\n            ret.addFirst(lastNum%10);\n            lastNum/=10;\n            i--;\n        }\n        return ret;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917362135","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n        int l = s.length();\n        int[] ans = new int[l];\n        int start = 0;\n        List<Integer> record = new ArrayList<>();\n        while(start<l){\n            int end = start;\n            if(s.charAt(end)==c){\n                record.add(end);\n                start = end+1;\n            }\n            else{\n                while(end<l && s.charAt(end)!=c){\n                    end++;\n                }\n                if(end<l){\n                    record.add(end);\n                    for(int i=start;i<end;i++){\n                        if(record.size()==1){\n                            ans[i] = Math.abs(end-i);\n                        }\n                        else{\n                            int num1 = Math.abs(record.get(record.size()-1)-i);\n                            int num2 = Math.abs(record.get(record.size()-2)-i);\n                            ans[i] = Math.min(num1, num2);\n                        }\n                    }\n                }\n                if(end==l){\n                    for(int i=start;i<end;i++){\n                         ans[i] = Math.abs(record.get(record.size()-1)-i); \n                    }\n                }\n                start = end;\n            }\n        }\n        return ans;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917546538","body":"class CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top<stack.length-1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top==-1){\n            return -1;\n        }\n        else{\n            top--;\n            return stack[top+1];\n        }\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917814555","body":"\nclass Solution {\n    public String decodeString(String s) {\n        char[] c = s.toCharArray();\n        int l = c.length;\n        Stack<Integer> num = new Stack<>();\n        Stack<String> record = new Stack<>();\n        int start = 0;\n        while (start<l){\n            if (Character.isDigit(c[start])){\n                int shu = 0;\n                while (Character.isDigit(c[start])){\n                    shu = shu * 10 + c[start]-'0';\n                    start++;\n                }\n                start--;\n                num.add(shu);\n            }\n            else if (c[start]==']'){\n                int tmp = num.peek();\n                num.pop();\n                String str = \"\";\n                StringBuilder sb = new StringBuilder();\n                while(!record.peek().equals(\"[\")){\n                    sb = sb.append(record.peek());\n                    record.pop();\n                }\n                if (record.peek().equals(\"[\")){\n                    record.pop();\n                }\n                for (int i=0;i<tmp;i++){\n                    str = str + sb;\n                }\n                record.add(str);\n            }\n            else {\n                record.add(String.valueOf(c[start]));\n            }\n            start++;\n        }\n        StringBuilder ans = new StringBuilder();\n        while (!record.isEmpty()){\n            ans = ans.append(record.peek());\n            record.pop();\n        }\n        return ans.reverse().toString();\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aatoe":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916965868","body":"先把卡打上，后面在优化。\n      var addToArrayForm = function(num, k) {\n        // 第一步先将k 加进num里，\n        let kArr = ('' + k).split('').reverse()\n        let len = kArr.length\n        for (let i = 0; i < len; i++) {\n          if (num[num.length - 1 - i] !== undefined) num[num.length - 1 - i] += +kArr[i]\n          else num.unshift(kArr[i])\n        }\n        console.log(num, 'num')\n        // 第二步将num里把每一项进行进位\n        let i = num.length - 1\n        while (i >= 0) {\n          // 大于9 进一\n          if (num[i] > 9) {\n            debugger\n            console.log(i, 'i')\n            if (i > 0) num[i - 1] = +num[i - 1] + parseInt((num[i] % 100) / 10)\n            else {\n              console.log(num[i], 'um[i]')\n              if (num[i] > 9) {\n                num.unshift()\n                let first = parseInt(num[i] % 10)\n                let second = parseInt((num[i] % 100) / 10)\n                num[i] = first\n                num.unshift(second)\n              } else {\n                num.unshift(num[i])\n              }\n            }\n            num[i] = parseInt(num[i] % 10)\n          }\n          i--\n        }\n        return num\n      }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917392659","body":"设置双循环，第一次循环将值存在数组中，\n第二次循环将获取到的值和第一次的做比较。得出最终的数组。 \n var shortestToChar = function(s, c) {\n        let result = []\n        let sArr = s.split('')\n        // 这是左循环\n        for (let i = 0; i < sArr.length; i++) {\n          let distance = 0\n          while (true) {\n            if (sArr[i + distance] === c) break\n            distance++\n            if (distance > s.length) {\n              distance = Infinity\n              break\n            }\n          }\n          result.push(distance)\n        }\n        // 这是右循环\n        for (let i = sArr.length - 1; i >= 0; i--) {\n          let distance = 0\n          while (true) {\n            if (sArr[i - distance] === c) break\n            distance++\n            if (distance > s.length) break\n          }\n          // 如果小于则替换\n          if (distance < result[i]) result.splice(i, 1, distance)\n        }\n        return result\n      }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917511353","body":"js code\n```js\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.arr = []\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.arr.length >=this.maxSize) return\n    this.arr.push(x)  \n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    // console.log(this,\"this\")\n    if(this.arr.length === 0) return -1\n    return this.arr.pop()\n    \n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    k = this.arr.length >k?k:this.arr.length\n    for(let i =0 ; i<k;i++){\n        this.arr[i] += val\n    }\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BadCoderChou":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916966133","body":"从低位往高位顺着加\r\n\r\n代码 ： java\r\n```java\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        int carry = 0;\r\n        List<Integer> res = new ArrayList<>();\r\n        int i = num.length - 1;\r\n        while (i >= 0 || k > 0) {\r\n            int cur = (i >= 0 ? num[i] : 0) + (k > 0 ? k % 10 : 0) + carry;\r\n            k = k > 0 ? k / 10 : 0;\r\n            i = i >= 0 ? i - 1 : -1;\r\n            carry = cur / 10;\r\n            cur = cur % 10;\r\n            res.add(cur);\r\n        }\r\n        if (carry == 1) res.add(carry);\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n```\r\n复杂度分析\r\n时间复杂度：O(n)，其中 n 为数组的长度\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917419173","body":"思路\r\n左右循环遍历取最小距离值；\r\n\r\n代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] result = new int[len];\r\n        Arrays.fill(result, len);\r\n\r\n        //找左边的最近距离\r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i) == c){\r\n                result[i] = 0;\r\n            }\r\n            else if(i > 0){\r\n                result[i] = result[i-1] + 1;\r\n            }\r\n        }\r\n\r\n        for(int i = len - 1; i >= 0; i--){\r\n            if(s.charAt(i) == c){\r\n                result[i] = 0;\r\n            }\r\n            else if(i < len - 1){\r\n                result[i] = Math.min(result[i+1] + 1, result[i]);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n```\r\n时间复杂度\r\nO（n）\r\n\r\n空间复杂度\r\nO（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917646199","body":"代码(Java)\r\n```java\r\nclass CustomStack {\r\n    List<Integer> stack; // stack_pre\r\n    int maxCap;\r\n    int currSize;\r\n    \r\n    List<Integer> incNum;\r\n    List<Integer> incVal;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        stack = new ArrayList<Integer>(maxSize);\r\n        maxCap = maxSize;\r\n        currSize = 0;\r\n        \r\n        incNum = new ArrayList<Integer>();\r\n        incVal = new ArrayList<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (currSize>=maxCap) return;\r\n        else {\r\n            if (currSize>=1) {                \r\n                stack.add(stack.get(currSize-1)+x);\r\n            }else {\r\n                stack.add(x);\r\n            }            \r\n            currSize++;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (currSize<=0) return -1;\r\n        else {\r\n            int ele;\r\n            if (currSize>=2) ele = stack.get(currSize-1)-stack.get(currSize-2);\r\n            else ele = stack.get(currSize-1);\r\n            // compute ele with inc\r\n            for (int i =0; i<incNum.size(); ++i){\r\n                // System.out.println(ele);\r\n                if (currSize <= incNum.get(i)) {\r\n                   ele+= incVal.get(i);\r\n                   incNum.set(i, incNum.get(i)-1);\r\n                }\r\n            }\r\n            stack.remove(--currSize);\r\n            return ele;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        incNum.add(Math.min(k, currSize));\r\n        incVal.add(val);\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HWFrankFung":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916966146","body":"代码\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n\n复杂度\n时间复杂度：O(max(n,logk))\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917420400","body":"Ideas\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nUse res[] to store every elemets distance to the specific c, by traversing the array s to seek whether there's any shorter distance.\n\nCode\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```javascript\nvar shortestToChar = function (s, c) {\n    let arr = []\n    let res = []\n    for (var i = 0; i < s.length; i++) {\n        if (s[i] === c) arr.push(i)\n    }\n\n    var dis = 0\n    for (var i = 0; i < s.length; i++) {\n        dis = Math.abs(i - arr[0])\n        for (var j = 1; j < arr.length; j++) {\n            dis = Math.min(dis, Math.abs(i - arr[j]))\n        }\n        res.push(dis)\n    }\n    return res\n};\n```\nComplexity\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nTime: O(n)  \nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917635651","body":"Ideas\n----------------------------------\nPush and pop can be directly called by arary.push() and array.pop(). Increment is also not that difficult. Compare k and the length of the array to determine which element should be increased. \n \nCode\n----------------------------------\n```javascript\n        var CustomStack = function (maxSize) {\n             this.arr = [];\n             this.maxSize = maxSize;\n        };\n\n        CustomStack.prototype.push = function (x) {\n            if (this.arr.length < this.maxSize){\n                this.arr.push(x);\n            }\n        };\n\n        CustomStack.prototype.pop = function () {\n            if (this.arr.length){\n                return this.arr.pop();\n            }\n            return -1;\n        };\n\n        CustomStack.prototype.increment = function (k, val) {\n            if(this.arr.length <= k) {\n                for(let i = 0; i < this.arr.length; i++){\n                    this.arr[i] += val;\n                }\n            }else{\n                for(let i = 0; i < k; i++){\n                    this.arr[i] += val;\n                }\n            }\n        };\n```\nComplexity\n-----------------------------------------------\npop() and push: O(1)  \nIncrement: O(k)\n\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangyifan2018":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916969010","body":"## 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int sum = 0, len = num.length;\n        List<Integer> res = new ArrayList<Integer>();\n\n        for(int i = len - 1; i >= 0; i--){\n            sum = num[i] + k % 10;\n            k /= 10;\n            if(sum >= 10){\n                k++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        for(; k > 0; k/= 10){\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917409958","body":"```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[s.length()];\n        Arrays.fill(ans, n - 1);\n        int right = n - 1;\n\n        for(int i = 0; i < n; i++){\n            if(s.charAt(i) ==c){\n                ans[i] = 0;\n                right = i;\n            } else{\n                ans[i] = Math.min(ans[i], Math.abs(right - i));\n            }\n        }\n\n        for(int i = n - 1; i>=0; --i){\n            if(s.charAt(i) == c){\n                right = i;\n                ans[i] = 0;\n            }\n            else{\n                ans[i] = Math.min(ans[i], Math.abs(right - i));\n            }\n        }\n\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917515042","body":"## 添加一个add数组做累积\n\n```java\nclass CustomStack {\n    int[] stack;\n    int[] add;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        add = new int[maxSize];\n        top=-1;\n    }\n    \n    public void push(int x) {\n        if(top != stack.length - 1){\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top == -1){\n            return -1;\n        }\n        int ret = stack[top] + add[top];\n        if(top != 0){\n            add[top - 1] += add[top];\n        }\n        add[top] = 0;\n        --top;\n        return ret;\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k-1, top);\n        if(limit >= 0){\n            add[limit] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917777270","body":"```golang\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n\nfunc decodeString(s string) string {\n    stk := []string{}\n    ptr := 0\n    for ptr < len(s) {\n        cur := s[ptr]\n        if cur >= '0' && cur <= '9'{\n            digits := getDigis(s, &ptr)\n            stk = append(stk, digits)\n        } else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <='Z' || cur =='['){\n            stk = append(stk, string(cur))\n            ptr++\n        } else {\n            ptr ++\n            sub := []string{}\n            for stk[len(stk) - 1] != \"[\" {\n                sub = append(sub, stk[len(stk) - 1])\n                stk = stk[:len(stk)-1]\n            }\n            for i := 0; i < len(sub)/2; i++{\n                sub[i], sub[len(sub) -i - 1] = sub[len(sub) -i -1], sub[i]\n            }\n            stk = stk[:len(stk) - 1]\n            repTime, _ := strconv.Atoi(stk[len(stk) -1])\n            stk = stk[: len(stk) - 1]\n            t := strings.Repeat(getString(sub), repTime)\n            stk = append(stk, t)\n        }\n    }\n    return getString(stk)\n}\n\nfunc getDigis(s string, ptr *int) string {\n    ret := \"\"\n    for ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++{\n        ret += string(s[*ptr])\n    }\n    return ret\n}\n\nfunc getString(v []string) string {\n    ret := \"\"\n    for _, s := range v {\n        ret += s\n    }\n    return ret\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eemsyw":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916969273","body":"## 思路\n数字逐位相加，满十进一。\n## 代码\n```\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n\n```\n\n## 复杂度\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\n空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linearindep":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916969683","body":"【思路】这题肯定要用reverse,因为add（0，x)更可怕。如果先把array转为int的话，在大数字面前就不准。所以最好还是直接在array上面操作。就是普通的进位。从右到左，依次相加。保留一个进位。每次每位上面的数字就是 k%10 + num[pos] + carry. 如果k还有但是pos没有的话，num[pos] = 0；\r\n【复杂度】O（n) ，遍历一遍，reverse也是O(n)\r\n\r\n```\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> rtn = new ArrayList<>();\r\n\r\n        int[] ans = num;\r\n        int add = k;\r\n        int carry = 0;\r\n        int pos = num.length - 1;\r\n        while(add != 0 || pos >= 0){\r\n            int newDigit = add % 10;\r\n            int oldDigit = (pos>=0)? num[pos] : 0;\r\n            int newSum = newDigit + oldDigit + carry;\r\n            carry = newSum / 10 ;\r\n            rtn. add( newSum % 10);\r\n            pos--;\r\n            add = add /10;\r\n        }\r\n        if(carry!=0) rtn.add(carry);\r\n        \r\n        Collections.reverse(rtn);\r\n        return rtn;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917334683","body":"【思路】从左和右各遍历一遍代码，左边起始可以是-10000，右边是10000 【题目说size<10^4】，记录发现c的位置，然后和之前发现的C的位置相减。最后取左右两边算出来最小的值\r\n【复杂度分析】O（n）\r\n\r\n```\r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] left = new int[s.length()];\r\n        int[] right = new int[s.length()];\r\n\r\n        int leftPos = -10000;\r\n        int rightPos = 10000;\r\n        for(int i = 0 ; i < s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                leftPos = i;\r\n                left[i] = 0;\r\n            }else{\r\n                left[i] = -leftPos+i;\r\n            }\r\n        }\r\n\r\n        for(int i = s.length()-1 ; i >= 0; i--){\r\n            if(s.charAt(i) == c){\r\n                rightPos = i;\r\n                right[i] = 0;\r\n            }else{\r\n                right[i] = rightPos - i;\r\n            }\r\n             left[i] = Math.min(left[i],right[i]);\r\n        }\r\n\r\n        \r\n        return left;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917553871","body":"【思路】前缀和。 每次increament的时候，把所有从0到k都加val。因为我们并不需要储存每一个加好的值。可以不断累积。在最后pop的时候把累积的值加上再return；\r\n【复杂度】O（1）\r\n\r\n```\r\nArrayList<Integer> stack = new ArrayList<>();\r\n    int size = 0;\r\n    int capacity = 0;\r\n    int[] inc ;\r\n    public CustomStack(int maxSize) {\r\n       \r\n        this.capacity = maxSize;\r\n        this.inc = new int[maxSize];\r\n\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(size+1 > capacity){\r\n            return;\r\n        }\r\n\r\n        stack.add(x);\r\n        size++;\r\n\r\n    }\r\n    \r\n    public int pop() {\r\n        if(size==0) return -1;\r\n        int temp = this.stack.remove(size-1);\r\n        size--;\r\n        temp = temp + this.inc[size];\r\n        this.inc[size] = 0;\r\n        return temp;\r\n\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i = 0; i<k; i++){\r\n            if(i>=this.size) return;\r\n            this.inc[i] += val;\r\n        }\r\n\r\n    }\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iciue":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916971835","body":"### 代码\n```js\nconst solution = (num, k) => {\n    const result = []\n    let [cleanNum, carry] = [num, k]\n\n    while(cleanNum.length || carry) {\n        const sum = cleanNum.pop() || 0 + carry % 10\n        carry = ~~(sum / 10) + ~~(carry / 10)\n        result.push(sum)\n    }\n\n    if (carry) result.push(carry)\n    \n    return result.reverse()\n}\n```\n\n### 复杂度分析\n时间复杂度: O(Math.max(num.length, k.length) + result.length)\n\n空间复杂度: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917662767","body":"### 思路\n利用数组模拟栈，维护一个额外的 increment数组， pop 时再计算增加的值\n\n### 代码\n```ts\nclass CustomStack {\n    maxSize:number;\n    cnt:number;\n    stack: Array<number>;\n    incrementInfos: Array<number>;\n\n    constructor(maxSize: number) {\n      this.maxSize = maxSize;\n      this.cnt = -1;\n      this.incrementInfos = new Array(maxSize).fill(0);\n      this.stack = [];\n    }\n\n    push(x: number): void {\n      if (this.cnt < this.maxSize -1) {\n        this.cnt++;\n        this.stack.push(x);\n      }\n    }\n\n    pop(): number {\n      if (this.cnt === -1) return -1;\n      const inc = this.incrementInfos[this.cnt];\n      \n      if (inc) {\n        this.incrementInfos[this.cnt] = 0;\n        this.incrementInfos[this.cnt -1] += inc;\n      }\n      this.cnt--;\n      return this.stack.pop() + inc;\n    }\n\n    increment(k: number, val: number): void {\n      let i = k;\n      if (this.cnt < i) i = this.cnt + 1;\n      if (i > 0 ) this.incrementInfos[i - 1] += val;\n    }\n}\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiayinya":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916972497","body":"### 解题思路\r\n##### 1. 暴力解题 （将两数相加 —>转成数组）【自己最开始的想法】（测试耗时76s）\r\n好吧，补充下，提交之后发现这种写法是错误的。\r\n```javascript\r\n  var addToArrayForm = function(num, k) {\r\n    let str = ''\r\n    for (const i of num) {\r\n      str = str + i\r\n    }\r\n    const numStr = Number(str)\r\n    const sum = numStr + k\r\n    const sumStr = sum.toString()\r\n    // 将数字1234变成[1, 2, 3, 4]\r\n    const arr = []\r\n    for (let i = 0; i < sumStr.length; i++) {\r\n      arr.push(Number(sumStr[i]))\r\n    }\r\n    return arr\r\n  };\r\n```\r\n时间复杂度：\r\n空间复杂度：O(1)\r\n\r\n##### 2. 力扣优解（测试耗时80s，迷茫了，怎么比暴力解题的时间还长），这个优解还未彻底理解，待消化\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n  let count = 0\r\n  const len = k.toString().length\r\n  for (let i = 0; i < len; i++) {\r\n    if (num.length < len) {\r\n      num.unshift(0)\r\n    }\r\n    count = k % 10\r\n    k = parseInt(k / 10)\r\n    num[num.length - 1 - i] += count\r\n  }\r\n  for (let i = 0; i < num.length; i++) {\r\n    if (num[0] > 9) {\r\n      num.unshift(0)\r\n    }\r\n    if (num[num.length - 1 - i] > 9) {\r\n      num[num.length - 2 - i]++\r\n      num[num.length - 1 - i] = num[num.length - 1 - i] % 10\r\n    }\r\n  }\r\n  return num\r\n};\r\n```\r\n时间复杂度：\r\n空间复杂度：O(1) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chaggle":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916974685","body":"# Day-1 ：2021-09-10 \n\n# 989.数组形式的整数加法\n\n### 题目\n\n```cpp\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n示例 1：\n\n输入：A = [1,2,0,0], K = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n示例 2：\n\n输入：A = [2,7,4], K = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n示例 3：\n\n输入：A = [2,1,5], K = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n示例 4：\n\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\n输出：[1,0,0,0,0,0,0,0,0,0,0]\n解释：9999999999 + 1 = 10000000000\n\n\n提示：\n\n1 <= A.length <= 10000\n0 <= A[i] <= 9\n0 <= K <= 10000\n如果 A.length > 1，那么 A[0] != 0\n```\n\n## 题目思路\n\n-   1、建立一个res的动态数组，以位数的形式来存储最后的结果值；\n-   2、从后往前与k相加，然后对相加得到的值对10进行求余数；\n-   3、如果k的位数大于nums数组所给的位数时候，必然导致k在循环内除以10后余留的值大于0，此时需要扩展数组，由于是动态数组，直接改写类似循环中k = sum / 10，此处为k /= 10，直到k为0为止。\n-   4、最后逆序数组即可输出。\n\n## 题目代码\n\n### 代码块\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& nums, int k) {\n        vector<int> res;\n        for(int i = nums.size() - 1; i >= 0; i--)\n        {\n            int sum = nums[i] + k;\n            res.push_back(r % 10);\n            k = sum / 10;\n        }\n\n        while(k > 0)\n        {\n            res.push_back(k % 10);\n            k /= 10;\n        }\n        \n        reverse(res.begin(), res.end());\n        //此处使用reverse函数时间复杂度会更低一些\n        /* for(int i = 0, j = res.size() - 1; i < j; i++, j--)\n        {\n            int temp = res[i];\n            res[i] = res[j];\n            res[j] = temp;\n        }  */\n        \n        return res;\n    }\n};\n```\n\n## 复杂度\n\n-   空间复杂度：申请了一个常数级数组，故空间为O(1)\n-   时间复杂度：$O(max(n, \\log k))$，其中n为数组的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917380909","body":"# Day-2 ：2021-09-11 \n\n# **821. 字符的最短距离**\n\n### 题目\n\n```cpp\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n```\n\n## 题目思路\n\n-   1、建立一个vector存储遍历字符串后等于输入字符c的位置position下标\n-   2、对于每一个位置，将其减去数组中的值，返回其abs（绝对值），并返回其中最小的值。\n-   3、min(abs(i - pos[j]), abs(i - pos[j + 1]))中会出现数组长度为一的特殊的情况，所以此处在今晚会进一步进行优化。\n\n## 题目代码\n\n### 代码块\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> pos;\n        vector<int> ans(n, n); \n        for(int i = 0; i < n; i++)\n        {\n            if(s[i] == c) pos.push_back(i);\n        }\n        \n        for(int i = 0; i < n; i++)\n        {\n            int tmp = 0;\n            if(pos.size() != 1)\n            {\n                for(int j = 0; j < pos.size() - 1; j++)\n                {\n                    tmp = min(abs(i - pos[j]), abs(i - pos[j + 1]));\n                    if(ans[i] > tmp) ans[i] = tmp;\n                }\n            }\n            else \n            {\n                ans[i] = abs(i - pos[0]);\n            }\n            \n        }\n        return ans;\n    }\n};\n```\n\n## 复杂度\n\n-   时间复杂度：O(n*k)，n是s的长度，k是字符c在字符串中出现的次数，k <= n。\n\n-   空间复杂度：O(k)，k为字符c出现的次数，这是记录字符c出现下标的辅助数组消耗的空间。\n\n    ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917605390","body":"# Day-3 ：2021-09-12 \n\n# **821. 字符的最短距离**\n\n### 题目\n\n```cpp\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n    \nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1); // 栈变为 [1]\ncustomStack.push(2); // 栈变为 [1, 2]\ncustomStack.pop(); // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2); // 栈变为 [1, 2]\ncustomStack.push(3); // 栈变为 [1, 2, 3]\ncustomStack.push(4); // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100); // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100); // 栈变为 [201, 202, 103]\ncustomStack.pop(); // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop(); // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop(); // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop(); // 返回 -1 --> 栈为空，返回 -1\n\n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n## 题目思路\n\n-   1、创建一个动态数组data，可以使用c++中的resize函数重置数组容量；\n-   2、push、pop都是经典的栈写法；\n-   3、increment数通过一个数组遍历即可。\n\n### 代码块\n\n```c++\nclass CustomStack {\nprivate:\n    vector<int> data;\n    int top;\n    \npublic:\n    CustomStack(int maxSize) \n    {\n        data.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) \n    {\n        if (top != data.size() - 1) \n        {\n            data[++top] = x;\n        }\n    }\n    \n    int pop() \n    {\n        if (top == -1) return -1;\n        else return data[top--];\n    }\n    \n    void increment(int k, int val) \n    {\n        int minx = k  < (top + 1) ?  k : top + 1;\n        for (int i = 0; i < minx; i++) \n        {\n            data[i] += val;\n        }\n    }\n};\n```\n\n## 复杂度\n\n-   时间复杂度：push、pop均为O(1)，而increment为O(minx)。\n\n-   空间复杂度：由创建的动态数组data的长度决定，即为O(maxSize)。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sqshada":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916979869","body":"### 思路\n逐位相加\n\n### 代码\n```js\n/**\n * @param {number[]} A\n * @param {number} K\n * @return {number[]}\n */\nvar addToArrayForm = function (A, K) {\n    const res = []\n    const len = A.length\n    for (let i = len - 1; i >= 0; i--) {\n        let sum = A[i] + K % 10\n        K = Math.floor(K / 10)\n        if (sum >= 10) {\n            K++\n            sum -= 10\n        }\n        res.push(sum)\n    }\n    for (; K > 0; K = Math.floor(K / 10)) {\n        res.push(K % 10)\n    }\n    res.reverse()\n    return res\n};\n```\n\n### 复杂度分析\n时间复杂度 O(N)，N 为数组的长度。     \n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917420833","body":"### 思路\n左右依次遍历\n\n### 代码\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n  const res = [];\n  let prev = -10001;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) {\n      prev === i;\n    }\n    res[i] = i - prev;\n  }\n  prev = 10001;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s[i] === c) {\n      prev === i;\n    }\n    res[i] = Math.min(res[i], prev - i);\n  }\n  return res;\n};\n```\n\n\n### 复杂度分析\n时间复杂度 O(N)，N 为数组的长度。\n空间复杂度 O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"CoreJa":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916980151","body":"# 思路\n思路1：把num数组合并为数字，两个数字相加再转换成数组\n思路2：把k转换成数组，两个数组相加，但要额外处理一下进位的过程\n思路1里的部分可以用python的map映射偷懒完成，先把数组用join+map转成str，再换成int，还原同理\n\n# 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        return list(map(int,str(int(\"\".join(map(str,num)))+k)))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917365668","body":"# 思路\r\n遍历数组的每个字母，向左和向右分别找到离该字母最近的C，取最小值即可。\r\n这个思路相对比较暴力法，最坏的情况下时间复杂度为O(N^2)\r\n\r\n另一个思路有贪心和DP的思想，即使用数组来保存状态。因为题目要求找每个字母离最近的C的距离，显然每个字母都可以向左延伸和向右延伸。从左遍历数组即可得到每个字符距离左边最近的C的距离。(假设上一个C的坐标为`pos_l`，则当前字母的距离为`i-pos_l`)，从右遍历同理。\r\n\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar1(self, S: str, C: str) -> List[int]:\r\n        res = []\r\n        for i in range(len(S)):\r\n            right = S[i:].find(C)\r\n            left = S[:i + 1].rfind(C)\r\n            if left == -1:\r\n                left = float('inf')\r\n            else:\r\n                left = len(S[:i + 1]) - 1 - left\r\n            if right == -1:\r\n                right = float('inf')\r\n\r\n            res.append(min(left, right))\r\n        return res\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        res = []\r\n        l = len(S)\r\n        left = [float('inf')] * l\r\n        right = [float('inf')] * l\r\n        pos_l = -float('inf')\r\n        pos_r = float('inf')\r\n        for i in range(l):\r\n            j = l - 1 - i\r\n            if S[i] == C:\r\n                pos_l = i\r\n            left[i] = i - pos_l\r\n            if S[j] == C:\r\n                pos_r = j\r\n            right[j] = pos_r - j\r\n        for i in range(l):\r\n            res.append(min(left[i], right[i]))\r\n        return res\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917585831","body":"# 思路\n这个题本以为是个简单的栈的实现，看了别人的题解才发现increment里大有玄机\n关键点在于把实时的increment变成lazy load，只在元素pop的时候才真正的加上，这样就实现了O(1)的时间复杂度\n\n具体需要多一个数组来记录每次的increment操作，定义为：列表的下标对应increment操作里的参数k，值为val，其表示需要对0-k个元素进行+val的操作。在每次pop的时候，根据下标找到add数组中该元素需要+val，同时将该值传递给add数组中的前一个元素。这里一定要注意边界情况，谨防越界。\n\n# 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.top = 0\n        self.stack = [0] * maxSize\n        self.add = [0] * maxSize\n\n    def push(self, x: int) -> None:\n        if self.top >= len(self.stack):\n            return\n        self.stack[self.top] = x\n        self.top += 1\n        return\n\n    def pop(self) -> int:\n        if self.top > 0:\n            self.top -= 1\n            self.stack[self.top] += self.add[self.top]\n            if self.top > 0:\n                self.add[self.top - 1] += self.add[self.top]\n            self.add[self.top] = 0\n            return self.stack[self.top]\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        k = min(k, self.top)\n        if k > 0:\n            self.add[k - 1] += val\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"daidaidashixiong666":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916980667","body":"``` java\nclass Solution {\npublic List addToArrayForm(int[] num, int k) {\nboolean addOne=false;//进位\nLinkedList list = new LinkedList<>();\nfor(int i=num.length-1;i>=0;i--){\nif(addOne){\nif(k%10+num[i]+1>=10){\naddOne=true;\n}else {\naddOne=false;\n}\nlist.add((k%10+num[i]+1)%10);\n}else {\nif(k%10+num[i]>=10){\naddOne=true;\n}else {\naddOne=false;\n}\nlist.add((k%10+num[i])%10);\n}\nk/=10;\n}\nif(addOne&&k==0){\nlist.add(1);\naddOne=false;\n}else if(k!=0){\nwhile (k!=0){\nif(addOne){\nlist.add((k%10+1)%10);\nif((k%10+1)>=10){\naddOne=true;\n}else {\naddOne= false;\n}\n}else {\nlist.add(k%10);\n}\nk/=10;\n}\n}\nif(addOne)\nlist.add(1);\nCollections.reverse(list);\nreturn list;\n}\n}\n复杂度分析\n\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917613866","body":"```java\nclass CustomStack {\n            int[] num;\n            int length=0;\n            public CustomStack(int maxSize) {\n                    num=new int[maxSize];\n            }\n\n            public void push(int x) {\n                if(length<num.length){\n                    num[length]=x;\n                    length++;\n                }\n            }\n\n            public int pop() {\n                if(length-1==-1)\n                    return -1;\n                length--;\n                return num[length];\n            }\n\n            public void increment(int k, int val) {\n                    if(k>=length+1){\n                        for(int i=0;i<length;i++){\n                            num[i]+=val;\n                        }\n                    }else{\n                            for (int i=0;i<k;i++){\n                                num[i]+=val;\n                            }\n                        }\n                    }\n            }\n\n**复杂度分析**\n- 时间复杂度 push pop 为O(1),increment为O(n)\n- 空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Maschinist-LZY":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916981887","body":"思路：\r\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\r\n\r\n语言：C\r\n\r\n\r\n\r\nint* addToArrayForm(int* A, int ASize, int K, int* returnSize){\r\n    int sum, len_K, len;\r\n    int * res;\r\n    if(K == 0)\r\n    {\r\n        *returnSize = ASize;\r\n        return A;\r\n    }\r\n    len_K = log10(K) + 1;\r\n    *returnSize = (ASize > len_K) ? ASize + 1: len_K + 1;\r\n    res = (int *) malloc(*returnSize * sizeof(int));\r\n    len = *returnSize;\r\n    while(len - 1 >= 1 || K > 0)\r\n    {\r\n       if(ASize > 0) K += A[--ASize];\r\n       res[--len] = K % 10;\r\n       K /= 10;\r\n    }\r\n    *returnSize -= len;\r\n    return res + len;\r\n} \r\n\r\n复杂度分析：\r\n时间：O(n)\r\n空间：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917712038","body":"# 思路\n先全部压入栈\n然后识别到数字，遍历直达不是数字为止\n对数字后的【】进行解码\n# 代码(Python)\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack1=list()\n        length=len(s)\n        i=length-1\n        while i>=0:\n            if s[i].isdigit()==False:\n                stack1.append(s[i])\n                i-=1\n            else:\n                num=''\n                while i>=0 and s[i].isdigit():\n                    num=s[i]+num\n                    i-=1\n                sub=''\n                while stack1[-1]!=']':\n                    tmp=stack1.pop()\n                    if tmp!='[':\n                        sub+=tmp\n                stack1.pop()\n                sub=int(num)*sub\n                stack1.append(sub)\n\n        stack1.reverse()\n        return ''.join(stack1)\n```\n# 复杂度分析\n时间：O(n)  \n\n空间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingkong1994":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916981984","body":"#数组形式的整数加法\n## 考察点\n1、数组为空时的处理情况。  \n2、数值求和进位的问题，需要注意一些特殊情况。  \n3、数组的长度跟数值k的位数长短的比较。  \n<1> 若数组长度更长，则在按位求和完k后，需要进一步考虑进位的问题。 这里需要特别注意在数组索引为0的求和进位问题。  \n<2> 若数值k的位数更长，则根据索引依次求和完num后，也同样需要考虑进位的问题。注意k的最高位进位问题。\n##代码\n```python\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int size = num.size();\n        if (num.empty()) {\n            while(k) {\n                int val = k % 10;\n                num.push_back(val);\n                k /= 10;\n            }\n            reverse(num.begin(), num.end());\n            return num;\n        }\n        int carry = 0;\n        while (size && k) {\n            int sum = num[size - 1] + (k % 10) + carry;\n            if (sum > 9) {\n                sum -= 10;\n                carry = 1;\n            } else {\n                carry = 0;\n            }\n            num[size - 1] = sum;\n            size --;\n            k /= 10;\n        }\n        while(size && carry) { \n            int sum = num[size - 1] + carry;\n            if (sum > 9) {\n                sum -= 10;                   \n                carry = 1;\n            } else {\n                carry = 0;\n            }\n            num[size - 1] = sum;\n            size --; \n        }\n        while (k) {\n            int val = k % 10 + carry;\n            if (val > 9) {\n                val -= 10;\n                carry = 1;\n            } else {\n                carry = 0;\n            }\n            num.insert(num.begin(), val);\n            k /= 10;\n        }\n        if (carry) { num.insert(num.begin(), carry); }\n        return num; \n    }\n};\n```\n##复杂度\n时间复杂度： O（n）  \n空间复杂度： O（1）  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917388008","body":"## 字符的最短距离  \n### 思路\n思路一：  \n1、 先把字符串中等于字符的对应索引用vector存储起来。\n2、遍历整个字符串，当发现不等于该字符时，则去vector中计算最短距离。  \n思路二：\n1、先从左到右扫描一遍，然后从右到左再扫描一遍。   \n### 代码  \n```python\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> idx_vec;\n        for (int i = 0; i < s.length(); i++) {\n            if (s[i] == c)  idx_vec.push_back(i);\n        }\n        if (idx_vec.empty())  return vector<int>{};\n        vector<int> res;\n        for (int i = 0; i < s.length(); i++) {\n            if (s[i] == c)  {\n                res.push_back(0);\n                continue;\n            }\n            int MIN = s.length();\n            for (int j = 0; j < idx_vec.size(); j++) {\n                MIN = min(MIN, abs(idx_vec[j] - i));\n            }\n            res.push_back(MIN);\n        }\n        return res;\n    }\n};\n```\n### 复杂度  \n时间复杂度： O(n*k)，n表示字符串的长度， k表示字符c的个数。  \n空间复杂度：O(n)。  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917598412","body":"## 思路\n1、采用数组的方式进行查询存储，这样的话可以直接通过索引直接进行检索。\n## 代码  \nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        max_size = maxSize;\n    }\n    \n    void push(int x) {\n        if (vals.size() < max_size) {\n            vals.push_back(x);\n        }\n    }\n    \n    int pop() {\n        if (vals.empty())  return -1;\n        int val = vals.back();\n        vals.pop_back();\n        return val;\n    }\n    \n    void increment(int k, int val) {\n        if (vals.empty())  return;\n        k = k > vals.size()? vals.size(): k;\n        for (int i = 0; i < k; i++) {\n            vals[i] += val;\n        }\n    }\n    vector<int> vals;\n    int max_size;\n};\n## 复杂度\n时间复杂度：pop 和 push操作都是O(1)， increment操作是 O(k) 。\n空间复杂度：O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"itsjacob":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916982551","body":"### Intuition\nSince the input array is passed by reference, we are allowed to modify it in place.\n\nWe start from number k, and add the digits in the array from right to left following the standard addition rule, i.e., if the sum is greater than 10 we reset the current digit and add one to the next digit. \n\nThe modulo and division operations are used to calculate the remainder and update the carry values.\n    \n\n### Implementation\n```c++\nclass Solution\n{\n  public:\n    std::vector<int> addToArrayForm(std::vector<int>& num, int k)\n    {\n        int carry = k;\n        for (int i = num.size() - 1; i >= 0; i--) {\n            int tmp = carry + num[i];\n            carry = tmp / 10;\n            num[i] = tmp % 10;\n        }\n        // Insert to the front at most 3 times\n        while (carry > 0) {\n            num.insert(num.begin(), carry % 10);\n            carry /= 10;\n        }\n        return num;\n    }\n};\n```\n### Complexity\n- Time complexity: O(n)\n- Space complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917338764","body":"### Intuition\nThe observation is that the closest char 'c' for each char in the string is either its first left neigboring 'c' or right neigboring 'c'.\n\nWe can compute the distance on the fly when find the occurances of char 'c' in the string.\n\nIn the first pass going from left to right, whenever we find a char 'c', we record its index in the string, and update its following right neighors untils it hits the next occurance.\n\nIn the second pass going from right to left, whenever we find a char 'c', we record its index in the string, and update its following left neighors untils it hits the next occurance.\n\nNotice that the initial values of result vector is initialized to INT_MAX, but a value of str.length() is enough.\n    \n\n### Implementation\n```c++\nclass Solution\n{\n  public:\n    vector<int> shortestToChar(string s, char c)\n    {\n        // The shortest distance to c is eight from its left neighboring c or right neighboring c\n        int n = s.length();\n        vector<int> res(n, INT_MAX);\n\n        // Sweep from left to right\n        // When one c occurance is found, update its right neighors until the next occurance of c\n        int cIdx = -1;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == c) {\n                cIdx = i;\n            }\n            if (cIdx != -1) {\n                res[i] = i - cIdx;\n            }\n        }\n\n        // Sweep from right to left\n        // When one c occurance is found, update its left neighors until the next occurance of c\n        cIdx = n;\n        for (int i = n - 1; i >= 0; i--) {\n            if (s[i] == c) {\n                cIdx = i;\n            }\n            if (cIdx != n) {\n                res[i] = std::min(res[i], cIdx - i);\n            }\n        }\n\n        return res;\n    }\n};\n```\n### Complexity\n- Time complexity: O(n)\n- Space complexity: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917543733","body":"### Intuition\nThe array based implementattion is fairly simple:\n\n- Upon contruction, an array of size maxSize is created, maybe a sanity check of positive value of maxSize is needed\n- An internal pointer topIdx is used for two purposes:\n\t- Pointing to the top element of in the stack\n\t- Indicate the actual size of the stack, ie., topIdx+1\n- Keep an eye on what the interviewer means about \"bottom\"\n\n### Implementation\n```c++\nclass CustomStack\n{\n\n  public:\n    CustomStack(int maxSize)\n        : maxSize_{ maxSize }\n        , topIdx_{ -1 }\n        , sbuf_(maxSize)\n    {}\n\n    void push(int x)\n    {\n        if (topIdx_ < maxSize_ - 1) {\n            sbuf_[++topIdx_] = x;\n        }\n    }\n\n    int pop()\n    {\n        if (topIdx_ < 0) {\n            return -1;\n        } else {\n            return sbuf_[topIdx_--];\n        }\n    }\n\n    void increment(int k, int val)\n    {\n        int end = std::min(topIdx_, k - 1);\n        for (int i = 0; i <= end; i++) {\n            sbuf_[i] += val;\n        }\n    }\n\n  private:\n    int topIdx_;\n    int maxSize_;\n    std::vector<int> sbuf_;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n### Complexity\n- Time complexity:\n\t- pop(...): O(1)\n\t- push(...): O(1)\n\t- increment(...): O(k)\n- Space complexity: O(n) for internal array storage","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917772426","body":"### Intuition\nPairing brackets in a string is often associated with stack ADT. We do nothing but pushing each char onto a stack until we encounter the right bracket ']'. When ']' is found, we need to pop elements on the stack until we find its first pairing bracket '['. Then some operations need to be done with the popped elements, in this case, we record the chars in between '[' and ']', and use the knowledge of numeric number right before '[' to repeat the recorded chars. After the operation is done, we can remove the pairing bracket '[' and the numeric number from the stack and push the after-processing chars back to the stack. After iterating through the original string, the stack will be left of pure chars without numeric numbers and brackets.\nThe final results is done backward iterating through the stack.\n\nThe key point in implementing it in c++ is that the stack is of type char not string, because char comparison is cheaper than the string comparison.\n\nOne caveat when we get the numeric number from the stack is that we need an additional stack to store the digits. This is because we store the number from high digit to low digit, for example, if we have 300[a], the stack is ['3', '0', '0', '[', 'a'], we need to have a helper stack to store the digits ['0', '0', '3']. An optimization can be done by observing that all integers are in the range [1, 300]. We can allocate a static array of size 3 and reset it to ['\\*', '\\*', '*'] before we compute the numeric number and fill the digits backwards into the array. \n\nThis is a more natural solution to me and sounds like DFS.\nThe two stacks approach consisting of numeric number stack and string stack is kind of hard to memorize for me.\n\n### Implementation\n```c++\nclass Solution\n{\npublic:\n  string decodeString(string s)\n  {\n    std::stack<char> resStack;\n    std::vector<char> digitVec(3, '*');\n    for (auto const& c : s) {\n      if (c != ']') {\n        resStack.push(c);\n      } else {\n        // Find the chars to be repeated in between '[' and ']'\n        std::vector<char> repeatStrVec;\n        while (resStack.top() != '[') {\n          repeatStrVec.push_back(resStack.top());\n          resStack.pop();\n        }\n        // Remove the '[' from the stack\n        resStack.pop();\n        // Find the repeat count, and remove the numbers from the stack\n        std::fill(digitVec.begin(), digitVec.end(), '*');\n        int idx = digitVec.size();\n        // static_cast is needed as isdigit has undefined behavior for char type\n        while (!resStack.empty() && std::isdigit(static_cast<unsigned char>(resStack.top()))) {\n          digitVec[--idx] = resStack.top();\n          resStack.pop();\n        }\n        int count{digitVec[idx] - '0'}; \n        for (int ii = idx+1; ii < digitVec.size(); ii++) {\n          count = 10 * count + digitVec[ii] - '0';\n        }\n        // Repeat the chars in betwen '[' and ']' count times and push them back to the stack\n        for (int ii = 0; ii < count; ii++) {\n          for (auto it = repeatStrVec.rbegin(); it != repeatStrVec.rend(); it++) {\n            resStack.push(*it);\n          }\n        }\n      }\n    }\n    // Pre-allocate the string so that we don't need string concatenation\n    std::string res(resStack.size(), '*');\n    int idx = resStack.size();\n    while (!resStack.empty()) {\n      res[--idx] = resStack.top();\n      resStack.pop();\n    }\n    return res;\n  }\n};\n```\n### Complexity\n- Time complexity: O(300n) = O(n) regardless of loops inside loop\n- Space complexity: O(300n) = O(n) for storing the expanded chars in stack\n- 300 comes from the factor that the max integer is 300","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alwaysbest":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916982643","body":"# 思路\n#### 从低到高处理数组，刚下班，先打卡\n# 代码\npublic class add2ArrayFromInteger {\n\n    public static void main(String[]args) {\n        Scanner scan = new Scanner(System.in);\n        //数组长度\n        int len = scan.nextInt();\n        //数组\n        ArrayList<Integer> list = new ArrayList<>(len);\n        int i = 0;\n        while (scan.hasNext() && i<len) {\n            list.add(scan.nextInt());\n            i++;\n        }\n        //整数k\n        int k = scan.nextInt();\n        System.out.println(\"数组：\" + list);\n        System.out.println(\"整数：\" + k);\n        //调用方法\n        System.out.println(\"结果：\"+getSum(list, k));\n\n    }\n    \n    private static ArrayList<Integer> getSum(ArrayList<Integer> list, int k) {\n        \n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pzl233":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916985748","body":"# 思路\n\n把k本身当作carry\n从低位到高位进行循环，把carry加到目前处理的最低位，并对carry进行更新\n\n# 代码\n\n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new LinkedList<>();\n        for (int i = num.length - 1; i >=0 ; i--) {\n            int carray = (num[i] + k) % 10;\n            k = (num[i] + k) / 10;\n            result.add(0, carray);\n        }\n        while (k > 0) {\n            result.add(0, k % 10);\n            k /= 10;\n        }\n        return result;\n    }\n\n```\n# 复杂度分析\n时间复杂度： O(n), where n is the length of the num array.\n空间复杂度:   O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917418783","body":"# 思路\r\n遍历数组两边：\r\n    先按从左到右的顺序计算当前的i离左边最近的字符C的距离\r\n    再从右到左计算当前i离右边最近的字符C的距离， 然后取两者之中的最小值记录作为结果\r\n\r\n\r\n# 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int curr = -n;\r\n        int result[] = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                curr = i;\r\n            }\r\n            result[i] = i - curr;\r\n        }\r\n        for (int i = curr - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c)  {\r\n                curr = i;\r\n            }\r\n            result[i] = Math.min(result[i], curr - i);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n```\r\n# 复杂度分析\r\n时间复杂度： O(n), where n is the length of the String s.\r\n空间复杂度:   O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917654968","body":"# 思路\n\n在设计普通stack的同时记录一个额外的数组inc\ninc[i]代表stack[0]到stack[i]之间的元素应该增加的量\n因为我们只需要在pop的时候用到这个多增加的量，所以可以在pop的时候返回stack顶的元素+inc[topIndex[对stack的下一个\ntop对应的inc, which is inc[i - 1]进行 inc[i - 1] += inc[i]的赋值\n# 代码\n\n```java\nclass CustomStack {\n    private int capacity;\n    private int size = 0;\n    private int[] stack;\n    private int[] inc;\n    private int topIndex = -1;\n\n    public CustomStack(int maxSize) {\n        capacity = maxSize;\n        stack = new int[maxSize];\n        inc = new int[maxSize];\n        \n    }\n    \n    public void push(int x) {\n        if (size < capacity) {\n            topIndex = size;\n            stack[size++] = x;\n        }\n    }\n    \n    public int pop() {\n        if (topIndex < 0) {\n            return -1;\n        }\n        if (topIndex > 0) {\n            inc[topIndex - 1] += inc[topIndex];\n        }\n        int result = stack[topIndex] + inc[topIndex];\n        inc[topIndex--] = 0;\n        size--;\n        return result;\n    }\n    \n    public void increment(int k, int val) {\n        int i = Math.min(k, size) - 1;\n        if (i >= 0) {\n            inc[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n```\n# 复杂度分析\n时间复杂度： \n\npush：O(1)\n\npop：O(1)\n\nincrement：O(1)\n\n空间复杂度:   O(maxSize)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangshisong":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916987710","body":"# Day-1 ：2021-09-10\r\n# 思路\r\n从右向左\r\n进位操作在下一步执行\r\n下一步根据不同情况执行不同操作\r\n\r\n### 缺点\r\n每次需要判断不同情况用以执行不同操作，主要耗时在这个地方\r\n\r\n\r\n\r\n\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        last = 0\r\n        for i in range(max(len(num), len(str(k)))):\r\n            \r\n            if i  < len(str(k)) and i  < len(num):\r\n            \r\n                num[-1-i] = num[-1-i] + int(str(k)[-1-i]) + last\r\n            elif i  >= len(str(k)) and i  < len(num):\r\n                if last > 0:\r\n                    num[-1-i] = num[-1-i] + last\r\n                    last = 0\r\n                else:\r\n                    break\r\n            elif i  < len(str(k)) and i  >= len(num):\r\n                num = [int(str(k)[-1-i])  + last ] + num\r\n                \r\n            if num[-1-i] >= 10:\r\n                num[-1-i] -= 10\r\n                last = 1\r\n            else:\r\n                last = 0\r\n\r\n        if last == 1:\r\n            return [1] + num\r\n                \r\n        return num\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917380083","body":"# Day-12：2021-09-11\r\n# 思路\r\n从左向右遍历一次\r\n考虑不同情况\r\n\r\n\r\n### 缺点\r\n数组索引次数较多，略耗时\r\n\r\n\r\n\r\n\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        toLeft_list = []\r\n        result_list = []\r\n        previous_max = 0\r\n        for chara_index, chara in enumerate(s):                 \r\n            if chara == c:\r\n                toLeft_list = toLeft_list + [chara_index-previous_max]\r\n                if chara_index == 0:\r\n                    result_list = [0]\r\n                else:\r\n                    toLeft_list_len = len(toLeft_list)\r\n                    if len(result_list) == 0:\r\n                        toLeft_list.reverse()\r\n                        result_list = toLeft_list\r\n                    elif toLeft_list_len > 2:\r\n                        result_list = result_list + toLeft_list[1:int((toLeft_list_len + 0.5)/2)]\r\n                        toLeft_list = toLeft_list[:-int((toLeft_list_len + 0.5)/2) ]\r\n                        toLeft_list.reverse()    \r\n                        result_list = result_list + toLeft_list\r\n                    else:\r\n                        result_list = result_list + [0]\r\n                    previous_max = len(result_list)-1\r\n                    toLeft_list = [0]\r\n            else:\r\n                toLeft_list = toLeft_list + [chara_index-previous_max]\r\n        return result_list + toLeft_list[1:]\r\n```\r\n# 复杂度\r\n时间复杂度 O(n)\r\n空间复杂度 应该是O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917558206","body":"# Day-12：2021-09-12\r\n# 思路\r\n不需要思路\r\n用变量记录长度，并不确定是否比调用len()更节约时间\r\n\r\n\r\n### 缺点\r\n没什么直观缺点\r\n\r\n\r\n\r\n\r\n# 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n        self.stack_length = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.stack_length < self.maxSize:\r\n            self.stack.append(x)\r\n            self.stack_length += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.stack_length ==0:\r\n            return -1\r\n        self.stack_length -= 1\r\n        return self.stack.pop(-1)\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for inc_index in range(k):\r\n            if inc_index < self.stack_length:\r\n                self.stack[inc_index] += val\r\n            else:\r\n                break\r\n```\r\n# 复杂度\r\n时间复杂度 O(n)\r\n空间复杂度 应该是O(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"baoqin87":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916989796","body":"## 989. 数组形式的整数加法\n\n### 思路 逐位加法\n例如计算 123+912，我们从低位到高位依次计算 3+2、2+1 和 1+9。任何时候，若加法的结果大于等于 10，把进位的 1 加入到下一位的计算中，所以最终结果为 1035。\n\n### 代码 JavaScript\n\n```javascript\nvar addToArrayForm = function(num, k) {\n  let n = num.length\n  let sum = 0\n  let res = []\n  for (let i = n - 1; i>=0; i--) {\n      sum = num[i] + k % 10\n      k = Math.floor(k/10)\n      if (sum>=10) {\n          k++\n          sum -= 10\n      }\n      res.push(sum)\n  }\n  for (;k>0;k=Math.floor(k/10)){\n      res.push(k%10)\n  }\n  res.reverse()\n  return res\n}\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(max⁡(n,log⁡k))，其中 n 为数组的长度。\n* 空间复杂度：O(n)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917421521","body":"## 821.字符的最短距离\n\n### 思路\n向左或者向右距离目标字符最近的距离，取最小值\n\n### 代码 JavaScript\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n  let len = s.length\n  let res = []\n  let prev = -10000\n  for (let i = 0; i < len; ++i) {\n    if (s.charAt(i) == c) prev = i\n    res[i] = i - prev\n  }\n  prev = 20000\n  for (let i = len - 1; i >= 0; --i) {\n    if (s.charAt(i) == c) prev = i\n    res[i] = Math.min(res[i], prev - i)\n  }\n  return res\n}\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(n2)，其中 n 为数组的长度。\n* 空间复杂度：O(n)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917644078","body":"## 1381.设计一个支持增量操作的栈\n\n### 思路\n用数组模拟栈操作\n\n### 代码 JavaScript\n\n```javascript\nvar CustomStack = function(maxSize) {\n  stack = []\n  len = 0\n  size = maxSize\n};\nCustomStack.prototype.push = function(x) {\n  if (len < maxSize) stack[++len] = x\n  return stack\n\n};\nCustomStack.prototype.pop = function() {\n  if (len) return stack[len--]\n  return -1\n};\nCustomStack.prototype.increment = function(k, val) {\n  while (k) stack[k--] += val\n}\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(1)。\n* 空间复杂度：O(1)。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"StefanLeeee":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916990366","body":"### 思路\r\n把k本身当作carry\r\n从低位到高位进行循环，把carry加到目前处理的最低位，并对carry进行更新\r\n### 代码\r\n`class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}`\r\n### 复杂度分析\r\n时间复杂度：O(max(n,logk))，其中 nn 为数组的长度。\r\n空间复杂度：O(1)。除了返回值以外，使用的空间为常数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917429247","body":"# 思路\n将字符串转化为数组，chatAt()可以算出ASCII码，然后遍历整个数组，每个元素的charAt(i) - charAt(C)，即可算出每个字符到字符C的最短距离\n# 代码\n```\n public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n\n```\n# 复杂度分析\n时间复杂度：O(N)\n空间复杂读：O(N) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Venchyluo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916993064","body":"###### \r\n简易版，把K也变成list, 然后翻转两个list， 每个位置相加。 主要注意carry， 进位的问题就好。 这样的做法就有点像linked list 相加的那道题了.\r\n\r\nO (N) 做法其实只需要从num 尾巴开始加起，也是注意carry， 是否有进位的情况。\r\n######\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        carry,i = 0,len(num)-1\r\n      \r\n        while carry or k or i > -1:\r\n            carry += (num[i] if i > -1 else 0) + (k % 10 if k else 0)\r\n            res.append(carry % 10)\r\n            k //= 10\r\n            carry //= 10\r\n            i -= 1\r\n            \r\n        return res[::-1]\r\n```\r\n\r\n###### \r\n时间复杂度： O(N)\r\n\r\n空间复杂度：O(1)（ 不算res的情况下）\r\n###### ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917418667","body":"###### \r\n第一个char之前都是以第一个char为标准， 同理最后一个char之后都是以这个char为标准。中间的 [char， x, x, x, char] 就需要左右两边扫一次看看是哪个char 离得近。 \r\n\r\n######\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        \r\n        prev = float('-inf')\r\n        res = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                prev = i # update new_prev             \r\n            res.append(i - prev)\r\n        \r\n        prev = float('inf')\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i] == c:\r\n                prev = i\r\n            res[i] = min(res[i], prev - i)\r\n            \r\n        return res\r\n```\r\n\r\n###### \r\n时间复杂度： O(N) 左右各循环一次\r\n\r\n空间复杂度：O(N) for res || O(1)\r\n###### \r\n\r\n\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        # 贴一个用stack的写法，就不用走两遍，重点就是记住前一个s[i] == c的位置\r\n        stack = []\r\n        res = [0]*len(s) #这样下面当s[i] == c  就不要考虑 0 的问题了\r\n        prev = -1\r\n        \r\n        for i in range(len(s)):\r\n            if not stack and s[i] == c:\r\n                prev = i\r\n                continue \r\n                \r\n            if stack and s[i] == c:\r\n                while stack:\r\n                    tmp = stack.pop()\r\n                    if prev != -1: # indicate it's not the first 'c'\r\n                        res[tmp] = min(abs(i-tmp),abs(prev-tmp))                      \r\n                    else:\r\n                        res[tmp] = abs(i-tmp)\r\n                        \r\n                prev = i\r\n                continue\r\n            \r\n            stack.append(i)\r\n                       \r\n        while stack:\r\n            temp = stack.pop()\r\n            res[temp] = temp-prev\r\n                \r\n        return res\r\n            \r\n\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917660387","body":"###### \r\n用array 模拟stack， 注意控制一个maxSize的量就好量\r\n######\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max_size = maxSize\r\n        self.size = 0\r\n        self.stack = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.max_size:\r\n            self.stack.append(x)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.size > 0:\r\n            self.size -= 1\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k,len(self.stack))):\r\n            self.stack[i] += val\r\n            \r\n\r\n        \r\n```\r\n\r\n###### \r\ntime complexity:  push O(1) 放在尾巴,  pop O(1), increment O(min(k,len(stack)))\r\n\r\nspace complexity: O(N) for self.stack\r\n###### \r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Lydia61":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916993282","body":"**思路**：取整，大于10进1，否则0，然后去掉多余0.\r\n**代码：python**\r\n`class Solution():\r\n    def plusK(self, digits, k):\r\n        res = [k] #把k当作初始值去做加法，66题的启示\r\n        for digit in digits[::-1]: #遍历\r\n            current_digit = res[-1] + digit #进位后\r\n            res[-1] = current_digit % 10 #整除\r\n            res.append(current_digit // 10) #＞10进位1；否则0\r\n        if res[-1] == 0: #去0\r\n            res.pop()\r\n        return res[::-1]\r\ndemo = Solution()\r\ndemo.plusK([9, 9], 11)`\r\n**时间复杂度n\r\n空间复杂度n**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917429802","body":"**思路**\n左右遍历，取最小值\n\n**代码 python**\n `class Solution():\n   def shortChar(self, S, C):\n        ans = []\n        first = -10**4\n        for i, x in enumerate(S):\n            if x == C: \n                first = i \n            ans.append(i - first)\n\n        first = 10**4\n        for i in range(len(S)-1, -1, -1):\n            if S[i] == C: \n                first = i\n            ans[i] = min(ans[i], first - i)\n        return ans\ndemo = Solution()\ndemo. shortChar(\"loveleetcode\", \"e\")` \n\n**复杂度分析**\n\n空间复杂度 O(N)\n时间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917659353","body":"# 设计一个支持增量操作的栈\r\n\r\n## 思路\r\n\r\n- **存储数据：** 用list存储栈的内容\r\n- **push()操作：** 入栈前对内容长度进行判断，如果内容长度小于`maxSize`，则进行入栈操作\r\n- **pop()操作：** 出栈前对内容长度进行判断，如果长度大于`0`则删除并返回栈顶元素，否则直接返回`-1`\r\n- **increment(k, val)操作：** 将栈底的前 `min(k, length)`个元素的值加`k`，其中`length`为内容长度\r\n\r\n## 代码\r\n\r\n``` python \r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.stack = []\r\n        self.max_size = maxSize\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        return self.stack.pop() if self.stack else -1\r\n\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i] += val\r\n```\r\n## 复杂度分析\r\n\r\n### 时间复杂度\r\n\r\n- push: O(1) \r\n- pop: O(1) \r\n- increment: O(k)\r\n\r\n### 空间复杂度\r\n\r\nO(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Auto-SK":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916993544","body":"## 思路\n\n不断取 `num` 和 `k` 的最后一位相加，和为 `acc`，进位为 `carry`。使用队列来保存结果，保证先入先出。\n\n## 代码\n\n``` python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = collections.deque()\n        acc, carry = 0, 0\n        while num or k:\n            x = num.pop() if len(num) > 0 else 0\n            y = k % 10\n            k //= 10\n            acc = x + y + carry\n            carry = acc // 10\n            res.appendleft(acc % 10)\n        if carry > 0:\n            res.appendleft(1)\n        return list(res)\n```\n\n## 复杂度分析\n\n时间复杂度：O(max(n, log(k)))\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917374529","body":"## 思路\n\n两次遍历，第一次遍历从头到尾，`pre` 记录前面出现 `c` 的位置，第二次遍历从尾到头，`pre` 记录后面出现 `c` 的位置，取两次最小的距离。\n\n## 代码\n\n``` python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = []\n        pre = -float('inf')\n        for i in range(len(s)):\n            if s[i] == c:\n                pre = i\n            ans.append(i - pre)\n        pre = float('inf')\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c:\n                pre = i\n            ans[i] = min(ans[i], pre - i)\n        return ans\n```\n\n## 复杂度分析\n\n* 时间复杂度：O(n)\n\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917610899","body":"## 思路：增量数组\n\n用数组模拟栈，`stack` 用来存储栈的元素，`diff` 用来存储增量。当调用 `pop` 和 `increment` 方法时，改变 `diff` 数组的元素。\n\n* 当 `pop` 时，若操作后，栈不为空，`diff[-1]` 加上上一个 `diff[-1]`；\n* 当 `increment` 时，如果栈为空，不操作；若 k > 栈长，`diff[-1] += val`；若 k < 栈长，`diff[k - 1] += val`。\n\n## 代码\n\n``` python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.max_size = maxSize\n        self.stack = []\n        self.diff = []\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n            self.diff.append(0)\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        s = self.stack.pop()\n        d = self.diff.pop()\n        if self.diff:\n            self.diff[-1] += d\n        return s + d\n    def increment(self, k: int, val: int) -> None:\n        if not self.diff:\n            return\n        if len(self.diff) < k:\n            self.diff[-1] += val\n        else:\n            self.diff[k - 1] += val\n```\n\n## 复杂度分析\n\n* 时间复杂度：O(1)\n* 空间复杂度：O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LOVEwitch":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916993689","body":"//javascript按位相加\nvar addToArrayForm = function(num, k) {\n  //split后每一项为字符串，相加时要注意转换为数字\n  let newNum = String(k).split('');\n  //进位的值\n  let jw = 0;\n  //保证num为长数组\n  if(num.length < newNum.length){\n      let temp = num;\n      num = newNum;\n      newNum = temp;\n  }\n  //长数组从尾到头遍历一遍\n  for(let i = num.length - 1, j = newNum.length - 1; i >= 0; i--){\n      //sum为相应位置上长短数组和进位的和\n      let sum = 0;\n      //短数组存在时，长短数组和进位相加，否则长数组和进位\n      if(j >= 0){\n          sum = Number(num[i]) + Number(newNum[j]) + jw; \n          j--;\n      } else {\n          sum = Number(num[i]) + jw; \n      }\n      //保留非进位的数字\n      num[i] = sum % 10;\n      //判断是否进位，并存储此次循环的进位\n      if( sum >= 10){\n          jw = Math.floor(sum / 10);\n      } else {\n          jw = 0;\n      } \n      \n  }\n  //循环完后还有进位，存储到数组头部\n  if(jw){\n    num.unshift(jw)\n  }\n  return num;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917369964","body":"//两次遍历法，第一次从左向右，当前元素距离左边特定字符的位置，第二次，从右向左，当前元素距离右侧元素的距离，二者取最小\n var shortestToChar = function(s, c) {\n  const N = s.length;\n  let res = new Array(N), lastIndex = -N;\n\n  for(let i = 0; i < N; i++) {\n      if(s[i] === c) {\n          lastIndex = i;\n          res[i] = 0;\n      }\n      res[i] = i - lastIndex;\n  }\n  for(let i = N-1; i >= 0; i--){\n    if(s[i] === c) {\n      lastIndex = i;\n      res[i] = 0;\n    }\n    res[i] = Math.min(Math.abs(lastIndex - i), res[i])\n  }\n  return res;\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MusicOfWind":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916994086","body":"思路:逐位相加\r\n让我们逐位将数字加在一起。例如计算 123+912123+912，我们从低位到高位依次计算 3+23+2、2+12+1 和 1+91+9。任何时候，若加法的结果大于等于 1010，把进位的 11 加入到下一位的计算中，所以最终结果为 10351035。\r\n\r\n代码:\r\nclass Solution {\r\npublic List addToArrayForm(int[] num, int k) {\r\nLinkedList ans = new LinkedList<>();\r\nint temp=0;\r\nfor (int i = num.length-1; i >=0 ; i--) {\r\ntemp = k%10;\r\nk/=10;\r\nif (temp+num[i]>=10){\r\nk++;\r\nans.addFirst((temp+num[i])%10);\r\n}else {\r\nans.addFirst(temp+num[i]);\r\n}\r\n//处理特殊情况\r\nif (i==0){\r\nwhile (k>0){\r\ntemp = k%10;\r\nk/=10;\r\nans.addFirst(temp);\r\n}\r\n}\r\n}\r\nreturn ans;\r\n}\r\n}\r\n\r\n复杂度:\r\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\r\n空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917401544","body":"思路:\r\n对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值\r\n\r\n代码:\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        ArrayList<Integer> arr = new ArrayList<>();\r\n        int[] ret = new int[s.length()];\r\n        int p = 0;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) arr.add(i);\r\n        }\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (p < arr.size() - 1 && Math.abs(arr.get(p) - i) > Math.abs(arr.get(p + 1) - i)) p++;\r\n            ret[i] = Math.abs(arr.get(p) - i);\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n\r\n复杂分析度:\r\n时间复杂度：O(N)，其中 N 是 S 的长度，我们需要遍历字符串两次。\r\n空间复杂度：O(N)，ans 数组的大小。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingcai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916996704","body":"##  思路\n\nnum数组从后往前遍历， k值从个位开始遍历。 使用add来记录是否有进位\n\n## 代码\n```cpp\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        std::vector<int> result;\n        //int devide = 10;\n        int num_index = num.size() - 1;\n        int add = 0; // 进位标志\n        int value = 0;\n        while (num_index >= 0 or k > 0) {\n            // 三种情况下 都记着+add\n            if(num_index >= 0 && k > 0) { // num和k都有值可用\n                value = num[num_index] + k % 10 + add;\n            } else if (num_index >= 0) { // k已经用完，num还没有遍历完\n                value = num[num_index] + add;\n            } else {\n                value = k % 10 +add; // num已经遍历完， k还没有用完\n            }\n\n            int real_value = value % 10;  // %10 取个位置 放入到result\n            add = value / 10; // 是否有进位\n            result.push_back(real_value);\n            k = k / 10; // 将k去掉个位，十位变成个位\n            num_index--; // num_index往前移动\n        }\n        if (add > 0) {\n            result.push_back(add); //压入最后可能存在的进位\n        }\n        reverse(result.begin(), result.end()); // 翻转result\n        return result;\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度  O(n) , 必须遍历数组且会将结果数组翻转\n空间复杂度 O(n) 用来保存结果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917415390","body":"## 思路\n\n最先开始肯定是考虑 固定一个元素，然后去遍历整个数组，找到最小位置。对于每个元素找一个 时间复杂度是O(n) ，所有找下来就是O(n*n) 。需要找到更快速的方法。\n在解题中想到的方法是：\n1）先遍历一遍数组，找到所有存在c的位置，将位置记录在一个数组c_positions中。 时间复杂度O(n), 空间复杂度O(n);\n2）然后再遍历这个数组，初始化两个变量left,right来记录数组c_positions，而它们保存的值则代表在c_positon[left] 或者 c_positon[right]位置上保存有字符c。 在循环中，有一个if, else; 如果有遍历的位置==c_positon[right] ，则我们本身就在c的位置；那么会2.1）将位置放入到results中；2.2）right赋值给left; 2.3)如果right+1没有超过c_positon大小上界，则++； else中，则是直接和c_position[left] 、c_postion[right]做比较，找到相对较小的那个。  这一步时间复杂度为O(n), 空间复杂度O(n) 用来保存结果。\n\n## 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        std::vector<int> c_positions; // 记录了char c出现的位置\n        for (int i = 0; i < s.length(); ++i) {\n            if (s[i] == c) { //如果为c, 则记录c出现的位置\n                c_positions.push_back(i);\n            }\n        }\n        vector<int> results(0, s.length()); //开辟空间 用来保存结果\n        // 定义left 和 right， 代表当前位置最靠近左侧和最靠近右侧为c的位置（位置指的是在c_position的下标）\n        int left_c_index = 0;\n        int right_c_index = 0;\n        for (int i = 0; i < s.length(); ++i) { // 开始遍历\n            if (i == c_positions[right_c_index]) {// 如果i和c_positions[xx]相等，则代表这个位置本身保存的就是c\n                results.push_back(0);\n                left_c_index = right_c_index; // 将right下标赋值给left\n                if (right_c_index + 1 < c_positions.size()) {//如果还存在right，则将ringth+1\n                    right_c_index += 1;\n                    } \n                } else { //否则 就直接将该下标和c_positions保存的位置相比较\n                    int dis = min(abs(i - c_positions[right_c_index]), abs(i - c_positions[left_c_index]));\n                    results.push_back(dis);\n            }\n        }\n        return results;\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度 O(n)\n空间复杂度 O(n)\n\n## 思考\n\n看了题解后，比较理想而且好理解的是左右遍历；1） 先从左到右遍历一遍数组，记录每个元素左侧出现c的最靠近的位置；2） 再从右到左遍历一遍数组，记录每个元素右侧出现c的最靠近的位置；3）然后左右取最小，则是该元素距离c最小的距离。\n\n碰到这种找距离，需要瞻左顾右的题目，需要想到从左到右，从右到左两次遍历，分别记录，再根据题目所给计算想要的结果。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917564334","body":"### 解题思路\n这道题主要需要思考的是在increment时是否可以优化，使得inc不用是O(n), 以此来降低复杂度\n\n1） 比较直观的思路时， 遇到Inc操作时，按照参数逐一遍历栈中元素然后加上val, 此时操作是O(MaxK) 复杂度，同时由于需要遍历栈， 栈需要使用vector来保存，而不能使用原始的std:stack;\n\n2）还有一个思路时，由于pop操作是只针对栈顶元素的，那么我们记录inc时，也只需要记录该位置上累计的加操作，当这个位置的元素弹出时，将这个位置的inc累计值赋值给前一个元素的inc , 以此来达到各个操作都是O(1) 时间复杂度。 不过需要有一个数组来记录各个位置的累加inc值， 空间复杂度则是O(n)\n\n\n### 代码\n\n```cpp\nclass CustomStack {\n\nprivate:\n    vector<int> _stack;\n    vector<int> _add;\n    int _maxsize;\n    int _now_size;\npublic:\n    CustomStack(int maxSize) {\n        _stack.resize(maxSize, 0);\n        _add.resize(maxSize); // 用于记录在每个位置上inc的值（如果inc多次，会累加）\n        _maxsize = maxSize;\n        _now_size = 0;\n    }\n    \n    void push(int x) {\n        //std::cout << \" enter push \" << std::endl;\n        if (_now_size < _maxsize) {\n            std::cout << \"push now size : \" << _now_size << std::endl;\n            _stack[_now_size] = x;\n            _now_size++;\n        }\n\n    }\n    \n\n    int pop() {\n        //std::cout << \" enter pop\" << std::endl;\n\n        if (_now_size > 0) {\n            int pop_value = _stack[_now_size - 1] + _add[_now_size - 1];\n            if (_now_size > 1) {\n                _add[_now_size-2] += _add[_now_size-1]; // 将后一个inc的值叠加到这个位置上\n            }\n            _add[_now_size - 1] = 0; // 归零操作，防止push的之后inc计算有原有数据\n            _now_size--;\n            return pop_value;\n        }\n        return -1;\n    }\n\n    void increment(int k, int val) {\n        //std::cout << \" enter inc\" << std::endl;\n        int inc_num = (k > _now_size) ? _now_size : k;\n        if (inc_num > 0) {\n            _add[inc_num - 1] += val;\n        }\n       \n    }\n\n    int pop_old() {\n        std::cout << \" enter pop\" << std::endl;\n        if (_now_size > 0) {\n            std::cout << \"pop now size : \" << _now_size << std::endl;\n            int pop_value = _stack[_now_size-1];\n            _now_size--;\n            return pop_value;\n        } \n        return -1;\n    }\n    \n    void increment_old(int k, int val) {\n        std::cout << \" enter inc\" << std::endl;\n\n        int inc_num = (k > _now_size) ? _now_size : k;\n        std::cout << \"inc_num : \" << inc_num << \" k : \" << k << \" _now_size: \" << _now_size <<  std::endl;\n        for (int i = 0; i < inc_num; ++i) {\n            _stack[i] += val;\n            std::cout << \" _stack : \" << _stack[i] << std::endl;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n### 复杂度\npop push increment 三个操作时间复杂度都为O(1) 空间复杂度为 O(n) , 需要记录累加值\n\n### 思考\n对于栈的操作，我们都是在栈顶进行操作，不会像数组下标直接取很多。 因此在记录元素状态时，可以使用一个数组来记录，弹出时改变这个数组状态（累加 累减），而不需要每次操作都遍历一次全部的栈元素。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JunQu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916996830","body":"## 思路分析\r\n首先考虑最常见的情况，第二种输入示例2里面的情况，对位相加。\r\n然后考虑到进位，增加一个参数`n`表示进位，则`n`的值只能是`0`或者`1`。\r\n最后一个边缘情况是数字的长度大于数组的长度，这样首位前面补`0`。\r\n\r\n## 代码实现\r\n```js\r\nconst addToArrayForm = function(num, k) {\r\n  let n = 0;\r\n  let len = k.toString().length;\r\n  while (len > num.length) {\r\n    num.unshift(0);\r\n  }\r\n  for (let i = num.length - 1; i >= 0; i--) {\r\n    const digit = k % 10;\r\n    const sum = num[i] + digit + n;\r\n    n = sum > 9 ? 1 : 0;\r\n    num[i] = sum % 10;\r\n    k = ~~(k / 10);\r\n  }\r\n  if (n) {\r\n    num.unshift(n);\r\n  }\r\n  return num;\r\n};\r\n```` \r\n失误点：没有一次提交过，是因为我没有考虑数字长度大于数组长度。\r\n\r\n## 复杂度分析\r\nfor 循环的时间复杂度为 O(n)，理论上 unshift 操作的复杂度也是 O(n),但是考虑到 k 的长度是5以内，所以整体的时间复杂度还是 O(n)。\r\n\r\n空间复杂度取决于 K 的长度，根据条件 K 的长度小于5，那么最大空间复杂度就是 5.\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuetong3yu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916997256","body":"### JS解法\r\n\r\n```js\r\nvar addToArrayForm = function (num, k) {\r\n    const ret = [];\r\n    let i = num.length - 1, carry = 0;\r\n    while (i >= 0 || k != 0) {\r\n        let x = i >= 0 ? num[i] : 0;\r\n        let y = k !== 0 ? k % 10 : 0;\r\n\r\n        const sum = x + y + carry;\r\n\r\n        ret.push(sum % 10);\r\n        carry = Math.floor(sum / 10);\r\n\r\n        i--;\r\n        k = Math.floor(k / 10);\r\n    }\r\n    if (carry) {\r\n        ret.push(carry);\r\n    }\r\n    return ret.reverse();\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917657176","body":"思路\r\n用数组模拟\r\n\r\n代码\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n    this.maxSize = maxSize;\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n    if (this.stack.length >= this.maxSize) {\r\n        return;\r\n    }\r\n    this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n    return this.stack.length > 0 ? this.stack.pop() : -1\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n    let length = Math.min(k, this.stack.length);\r\n    for (let i = 0; i < length; i++) {\r\n        this.stack[i] += val;\r\n    }\r\n};\r\n\r\n```\r\n\r\n时间复杂度：O(1)push pop, O(n)inc\r\n空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kbfx1234":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916998377","body":"#### [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n``` cpp\n// 9-10 cpp \nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int i = num.size() - 1;\n        int up = 0;\n        vector<int> ans;\n        while (i >= 0 || k != 0) {\n            int x = i >= 0 ? num[i] : 0;\n            int y = k != 0 ? k%10 : 0;\n\n            int sum = x + y + up;\n            ans.push_back(sum % 10);\n            up = sum / 10;\n\n            i--;\n            k = k / 10;\n        }\n        if (up) ans.push_back(up);\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917380020","body":"#### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n``` cpp\n// 9-11 cpp \nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int len = s.length();\n        vector<int> record;\n        vector<int> ans(len);\n        for (int i = 0; i < len; i++) {\n            if (s[i] == c) record.push_back(i);\n        }\n        \n        for (int i = 0; i < len; i++) {\n            int temp = INT_MAX;\n            for (int k = 0; k < record.size(); k++) {\n                temp = min(temp, abs(i - record[k]));\n            }\n            ans[i] = temp;\n        }\n        return ans;\n    }\n};\n```\n\n **时间复杂度：** O( n^2 )\n\n **空间复杂度：** O( k )","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"crypteee":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916998496","body":"## 思路\r\n\r\n- 原地修改数组，无需开辟额外的空间\r\n- 由于加法从右到左逐位计算，自然地倒序遍历数组\r\n- 模运算 `%` 可拿到每次计算结果的末位数，然后把该末位数原地更新到原数组\r\n- 取整的除运算 `/` 可拿到去掉末位数的剩余数字，这些数字即下一轮要继续计算的数字，直到剩余的数字归零\r\n- 如果数组已经完全计算完毕，但是还有剩余的数字要计算，则对原数组的头部补 0，然后继续运算剩余的数字，直到归零\r\n\r\n## 实现\r\n\r\n语言：TypeScript\r\n\r\n```typescript\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n  let restK = k;\r\n  let i = num.length - 1;\r\n\r\n  while (i >= 0) {\r\n    const curSum = num[i] + restK;\r\n    num[i] = curSum % 10;\r\n    restK = ~~(curSum / 10);\r\n\r\n    if (i === 0 && restK !== 0) {\r\n      // 原数组用完了，但还存留未计算的数，那么就在数组首部补零\r\n      num.unshift(0);\r\n    } else {\r\n      // 原数组没用完，那就继续向左移动\r\n      i = i - 1;\r\n    }\r\n  }\r\n\r\n  return num;\r\n};\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度：每个元素只遍历一次，所以是 O(N)\r\n- 空间复杂度：由于是原地操作数组，所以是 O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917662016","body":"## 思路\r\n\r\n- 栈的进出可以通过数组的 push 和 pop 实现\r\n- inc 操作要求可以通过遍历更新栈的值，但时间复杂度为 O(N)\r\n- 通过使用 Map 对象记录 inc 操作（第 K 个元素及其 inc 值），在 pop 时才对数值进行计算，把时间复杂度降低到 O(1)\r\n- 通过 Map 对象，每次 pop 时，需要把第 K 个元素的记录删除，同时将 inc 值累加到下一个元素即第 k - 1 个元素的 inc 记录去，这样才能满足题目要求「栈底的 K 个元素都增加 val」而不是「第 K 个元素增加 val」\r\n\r\n## 实现\r\n\r\n开发语言：TypeScript\r\n\r\n```ts\r\nclass CustomStack {\r\n    /**\r\n     * 记录栈的长度\r\n     */\r\n    private length = 0;\r\n    /**\r\n     * 记录栈的数值\r\n     */\r\n    private stack = [];\r\n    /**\r\n     * 记录栈底的第 k 个元素的值要增加的 val 值\r\n     * 该记录可以使 inc 操作的时间复杂度降低到 O(1)\r\n     */\r\n    private incMap = new Map();\r\n\r\n    constructor(private maxSize: number) {\r\n    }\r\n\r\n    push(x: number): void {\r\n      // 栈在增长到 maxSize 之后则不支持 push 操作\r\n      if (this.length === this.maxSize) {\r\n        return;\r\n      }\r\n      this.length += 1;\r\n      this.stack.push(x);\r\n    }\r\n\r\n    pop(): number {\r\n      if (this.length === 0) {\r\n        return -1;\r\n      }\r\n\r\n      // 当前第 k 个元素在 pop 之前被要求增加的值\r\n      const incVal = this.incMap.get(this.length) ?? 0;\r\n      // 由于元素被 pop 出去，所以增加之后无需保留，可以进行清除已节省空间\r\n      this.incMap.delete(this.length);\r\n      // 更新栈的长度\r\n      this.length -= 1;\r\n      if (this.length >= 0) {\r\n        // 此时要更新下一个元素即 k - 1 被要求增加的值\r\n        // 同时需要累加第 k 个元素被要求增加的值\r\n        // 因为题意要求增加的值是对栈底 0 到 k - 1 个元素进行累加\r\n        this.incMap.set(\r\n          this.length,\r\n          (this.incMap.get(this.length) ?? 0) + incVal\r\n        );\r\n      }\r\n\r\n      return this.stack.pop() + incVal;\r\n    }\r\n\r\n    increment(k: number, val: number): void {\r\n      // 如果栈中元素总数小于 k ，则栈中的所有元素都增加 val\r\n      const incK = Math.min(k, this.length);\r\n      this.incMap.set(incK, (this.incMap.get(incK) ?? 0) + val);\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度：每个操作都是 O(1) 操作，所以复杂度为 O(1)\r\n- 空间复杂度：开辟了两个存储空间，一个存储栈值的数组，空间为 O(maxSize)，另一个是存储 inc 操作的 Map 对象，空间为 O(k 不等的 inc 调用的次数)，合并之后，空间复杂度为 O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzcyes":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917000501","body":"方法一：末尾相加\r\n\r\n```typescript\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n const sum:number[] = [];\r\n    let i = num.length - 1;\r\n    while(i >= 0 || k > 0){\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        sum.push(k % 10);   //  把k的末位push进数组\r\n        i--;\r\n        k = Math.floor(k / 10); // 把k的末位去掉\r\n    }\r\n    return sum.reverse();\r\n};\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yliboom":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917000554","body":"# 思路\n根据 arr 的长度 在遍历过程中做幂等运算，得出 arr 转换后的数组\n# 代码\n```javascript\n\nconst addToArrayForm = function (arr, k) {\n\n    let number = 0;\n    // 根据 arr 的长度 在遍历过程中 做运算，得出 arr 转换后的数组\n    // 0 + 1 * 1000 + 2 * 100 + 3 * 10 + 4\n\n    for (let i = 0; i < arr.length; i++) {\n        let len = arr.length - i - 1;\n        number +=  arr[i] * Math.pow(10, len);\n    }\n    return number + k\n\n}\n\n\n\n````\n# 复杂度分析\nfor 循环的时间复杂度为 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917368512","body":"# 思路\n\n- 将 string 转为数组, 根据字符串所在位置组成目标字符串数组，在原数组中找到每个字符串具体目标字符串索引最近的位置\n- 关键词：绝对值以及 索引位置\n\n\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nlet shortestToChar = function(s, c) {\n\n    let array = [];\n    let S = s.split('');\n    let placeArray = [];\n\n    for (let i = 0; i < S.length; i++) {\n        if (S[i] == c) placeArray.push(i);\n    }\n\n    for (let i = 0; i < S.length ; i++) {\n\n        let min = 0;\n        let subtract = 0;\n\n        for (let j = 0; j < placeArray.length ; j++) {\n\n            subtract = Math.abs(placeArray[j] - i)\n\n            if (j === 0 || min > subtract) {\n                min = subtract\n            }\n\n        }\n\n        array.push(min)\n    }\n\n    return array;\n\n};\n\nshortestToChar(\"loveleetcode\", 'e')\n\n```\n\n# 复杂度分析\n1. 时间复杂度：log(n) + n\n2. 空间复杂度:  log(n) + n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Gjts":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917000754","body":"## 语言 CSharp \n\n* 时间复杂度:O(max⁡(n,log⁡k))\n* 空间复杂度:O(N)\n\n> 考点：两个数相加 超过10进一位 \n\n> 操作：%10 取个位上的数  /10取十位上的数 添加到数组 数组反转\n\n> 思考：先考虑有没有加0的可能性，试着用一个自己习惯的数字来进行 比如[9,9]+5 先处理一个小的数\n```\npublic IList<int> AddToArrayForm(int[] num, int k) {\n        int i = num.Length - 1;\n        int sum = k;\n        List<int> arr = new List<int>();\n        while(i >= 0 || sum != 0){\n            if(i >= 0){\n                sum += num[i];\n            }\n            arr.Add(sum % 10);\n            sum /= 10;\n            i--;\n        }\n        int[] arr1 = arr.ToArray();\n        Array.Reverse(arr1);\n        return arr1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917429975","body":"## 语言 CSharp\n* 时间复杂度：O(N)\n* 空间复杂度：O(N)\n\n\n> 思路：找出距离向左或者向右下一个字符 C 的距离\n\n\n> 操作：向左 向右遍历\n\n\n```javascript\npublic int[] ShortestToChar(string s, char c) {\n        int N = s.Length;\n        var isok = s.ToCharArray();\n        int[] ans = new int[N];\n        var prev = int.MinValue >> 1;\n        for (int i = 0; i < s.Length; i++)\n        {\n            if (isok[i] == c) prev = i;\n            ans[i] = i - prev;\n        }\n        prev = int.MaxValue >> 1;\n        for (int i = N - 1; i >= 0; --i)\n        {\n            if (isok[i] == c) prev = i;\n            ans[i] = Math.Min(ans[i], prev - i);\n        }\n        return ans;\n    }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917662349","body":"## 语言 CSharp \n* 时间复杂度：Push:O(1)  Pop:O(1)  Increment:O(k)\n* 空间复杂度：O(n)\n\n> 思路：先想一下栈的特性：先入后出的结构、底层存储有两种方式、数组和链表可以选择\n\n> 步骤：对于Push 操作判断是不是数组是不是满了 对于Pop操作看看数组是不是为空了\n\n__Code__\n```javascript\npublic class CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top =-1;\n    }\n    public void Push(int x) {\n        if(top!=stack.Length-1)\n        {\n            top++;\n            stack[top]=x;\n        }\n    }\n    public int Pop() {\n        if(top==-1)\n        {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    public void Increment(int k, int val) {\n        int limit = Math.Min(k, top + 1);\n        for (int i = 0; i < limit; ++i)\n        {\n            stack[i] += val;\n        }\n    }\n}\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenbihao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917000877","body":"\n## 思路\n硬刚出来的，明天看看别人的解答\n\n## 关键点\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        // 先转int[] 再去加   进位字段\n        String kStr = String.valueOf(k);\n        int[] kArray = getIntArray(kStr);\n\n        List<Integer> result;\n\n        // 计算并取进位\n        if (num.length >= kArray.length) {\n            result = calculate(num, kArray);\n        } else {\n            result = calculate(kArray, num);\n        }\n        return result;\n    }\n\nprivate List<Integer> calculate(int[] longer, int[] shorter) {\n        int carry = 0;\n        for (int i = 0; i < longer.length; i++) {\n            int longerLen = longer.length - i - 1;\n            int shorterLen = shorter.length - i - 1;\n\n            if (shorterLen >= 0) {\n                int i1 = shorter[shorterLen] + longer[longerLen] + carry;\n                longer[longerLen] = i1 % 10;\n                carry = i1 / 10;\n            } else {\n                // 当k比num位数少的时候，还得计算完进位的情况\n                if (carry != 0) {\n                    int i1 = longer[longerLen] + carry;\n                    longer[longerLen] = i1 % 10;\n                    carry = i1 / 10;\n                }\n            }\n        }\n\n        // 判断最后有没有进位，有的话补上\n        List<Integer> result = Arrays.stream(longer).boxed().collect(Collectors.toList());\n        if (carry != 0) {\n            ArrayList<Integer> integers = new ArrayList<>();\n            integers.add(carry);\n            integers.addAll(result);\n            result = integers;\n        }\n        return result;\n    }\n    \n    private int[] getIntArray(String str) {\n        int[] ints = new int[str.length()];\n        for (int i = 0; i < ints.length; i++) {\n            Character ch = str.charAt(i);\n            ints[i] = Integer.parseInt(ch.toString());\n        }\n        return ints;\n    }\n\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917426477","body":"总觉得菜鸡的我为什么每次写的都很长很冗余的感觉，哭了\n\n``` java\n\npublic int[] shortestToChar(String s, char c) {\n        char[] cs = new char[s.length()];\n        int[] result = new int[s.length()];\n        \n        for (int i = 0; i < cs.length; i++) {\n            cs[i] = s.charAt(i);\n        }\n        for (int i = 0; i < cs.length; i++) {\n            Integer forward = null;\n            Integer backward = null;\n            if (cs[i] == c) {\n                result[i] = 0;\n                continue;\n            }\n            // 向前遍历\n            for (int j = 1; i - j >= 0; j++) {\n                if (cs[i - j] == c) {\n                    forward = j;\n                    break;\n                }\n            }\n            // 向后遍历\n            for (int j = 1; i + j < cs.length; j++) {\n                if (cs[i + j] == c) {\n                    backward = j;\n                    break;\n                }\n            }\n            if (forward==null) {\n                result[i] =backward;\n            }else if(backward == null){\n                result[i] =forward;\n            }else{\n                result[i] = forward > backward ? backward : forward;\n            }\n        }\n        return result;\n    }\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917622502","body":"\n## 思路\n最开始写测试的时候以为数组的值也要每一步一致，导致走了点弯路\n\n其实题目只要 pop 和 push，并没有获取整个数组的方法\n\n看题解的时候发现还有优化的做法，可以使inc操作的时间复杂度优化为 O(1):\n\n* 增加一个增量操作的数组\n* 调用 inc 时，只需要简单的赋值，复杂度是 O(1) ，v1版的是for循环，复杂度是 O(k)\n* 调用 pop 时，只需要获取顶部的增量值+原栈值；并且把增量值往下合并即可\n\n因为这里是栈的结构，只需操作栈顶，所以可以不用考虑获取中间值的状况，所以可以使用这种方法来优化 inc 方法的复杂度\n\n## 关键点\n\n栈 、前缀和\n\n## 代码\n\nJava Code:\n\n```java\n\npackage array_stack_queue;\n\n/**\n * @author: chenbihao\n * @create: 2021/9/10\n * @Description:\n * @History:\n */\npublic class LeetCode_1381_CustomStack {\n\n    int top;\n    int[] stack;\n\n    public LeetCode_1381_CustomStack(int maxSize) {\n        top = -1;\n        stack = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (top != stack.length - 1) {\n            stack[++top] = x;\n        }\n    }\n\n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        return stack[top--];\n    }\n\n    public void increment(int k, int val) {\n        k = Math.min(k, top + 1);\n        for (int i = 0; i < k; i++) {\n            stack[i] += val;\n        }\n    }\n}\n\nclass LeetCode_1381_CustomStack_v2 {\n\n    int top;\n    int[] stack, add;\n\n    public LeetCode_1381_CustomStack_v2(int maxSize) {\n        top = -1;\n        stack = new int[maxSize];\n        add = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (top != stack.length - 1) {\n            stack[++top] = x;\n        }\n    }\n\n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        int ret = stack[top] + add[top];\n        if (top != 0) {\n            add[top - 1] += add[top];\n        }\n        add[top--] = 0;\n        return ret;\n    }\n\n    public void increment(int k, int val) {\n        k = Math.min(k - 1, top);\n        if (k >= 0) {\n            add[k] += val;\n        }\n    }\n}\n\n\n```\n\n\n**复杂度分析**\n\nv1版：\n- 时间复杂度：  \n  - push 操作和 pop 操作： O(1) \n  - inc 操作： O(k)\n- 空间复杂度： O(maxSize)\n\nv2版：\n- 时间复杂度： O(1)\n- 空间复杂度： O(maxSize)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuanaxuan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917001862","body":"### 思路\n\n待补\n\n### 代码\n\n\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\n\nvar addToArrayForm = function(num, k) {\n  const res = []\n  let i = num.length - 1\n  let carry = 0\n  while (i >= 0 || k > 0 || carry > 0) {\n    let cur = (num[i] || 0) + k % 10 + carry\n    res.push(cur % 10)\n    carry = cur / 10 | 0\n    i--\n    k = k / 10 | 0\n  }\n  return res.reverse()\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917365809","body":"##### 思路\r\n用变量prevC记录c的下标,初始值为无穷大,当s[i]=c时更新preC=i\r\n遍历字符串,将非c的字符串存入临时栈中,当遇到c时,依次计算栈中字符串到当前c以及prevC的最小距离,注意针对C非S最后一个字符串的情况,需要再清空下临时栈\r\n##### 复杂度\r\n时间复杂度：$O(N)$, N 为S数组长度。\r\n空间复杂度：$O(N)$, N 为S数组长度。\r\n##### 代码\r\n```js\r\nvar shortestToChar = function (S, C) {\r\n  let arr = [],\r\n    prevC = -Infinity,\r\n    map = [];\r\n  //清空暂存栈\r\n  function clear(prev, next = Infinity) {\r\n    for (const targetIndex of map) {\r\n      const Index = Math.min(Math.abs(targetIndex - prev), Math.abs(targetIndex - next));\r\n      arr.push(Index);\r\n    }\r\n    map = [];\r\n  }\r\n  for (let index = 0; index < S.length; index++) {\r\n    const ele = S[index];\r\n    if (ele === C) {\r\n      clear(prevC, index);\r\n      arr.push(0);\r\n      prevC = index;\r\n    } else {\r\n      map.push(index);\r\n    }\r\n  }\r\n  if (map.length > 0) {\r\n    clear(prevC);\r\n  }\r\n  return arr;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917534757","body":"### 设计一个支持增量操作的栈\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n链接：https://leetcode-cn.com/problems/design-a-stack-with-increment-operation\r\n\r\n#### 思路\r\n两种做法:\r\n一种常规遍历.\r\n一种运用辅助栈,空间换时间，用一个 O(M)的 hashtable 来记录所有 increment 的操作，\r\n在要 pop 的时候把操作对弹出栈的值进行运算,并且要更新辅助栈.\r\n\r\n#### 复杂度\r\n\r\n1. 复杂度分析\r\n时间复杂度：O(N) \r\n空间复杂度：O(1)\r\n\r\n2. 辅助栈\r\n时间复杂度：O(1)\r\n空间复杂度：O(N)\r\n\r\n#### 代码\r\n\r\n```js\r\nvar CustomStack = function (maxSize) {\r\n  this.list = [];\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n* @param {number} x\r\n* @return {void}\r\n*/\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.list.length < this.maxSize) {\r\n      this.list.push(x)\r\n  }\r\n};\r\n\r\n1.\r\n/**\r\n* @return {number}\r\n*/\r\nCustomStack.prototype.pop = function () {\r\n  return this.list.length ? this.list.pop() : -1\r\n};\r\n\r\n/** \r\n* @param {number} k \r\n* @param {number} val\r\n* @return {void}\r\n*/\r\nCustomStack.prototype.increment = function (k, val) {\r\n  let min = Math.min(k, this.list.length)\r\n  for (let index = 0; index < min; index++) {\r\n      this.list[index] += val\r\n  }\r\n};\r\n\r\n\r\n2.\r\nCustomStack.prototype.pop = function() {\r\n  if(this.stack.length < 1) return -1; //如果长度为0，返回-1\r\n  let curLastIndex = this.stack.length - 1; //现在即将要被pop出去的元素的index\r\n  let last = this.stack.pop(); //last = 被pop的\r\n  if(this.record.has(curLastIndex)){ //如果record有这个index的操作记录\r\n    let temp = this.record.get(curLastIndex) //让temp等于这个index的增加的总值\r\n    last += temp //加到last上去\r\n    //调整相关记录\r\n    this.record.set(curLastIndex - 1, (this.record.get(curLastIndex - 1) || 0 ) + temp )\r\n    //删除已经用过的记录\r\n    this.record.delete(curLastIndex)\r\n  }\r\n\r\n  return last;\r\n};\r\n\r\nCustomStack.prototype.increment = function(k, val) {\r\n const index = Math.min(k,this.stack.length) - 1;\r\n  this.record.set(index, (this.record.get(index) || 0) + val)\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JianXinyu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917004761","body":"```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917423711","body":"- 找出s中所有的c所在位置，记为数组idxs\n- s中的每一个字符必然落在两个c位置之间，记为l和r\n- 比较两个的距离即可\n- 使用iterator方便迭代idxs\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        const int n = s.length();\n        vector<int> ans(n, 0);\n        vector<int> idxs;\n\n        \n        for(int i = 0; i < n; ++i){\n            if( s[i] == c ){\n                idxs.push_back(i);\n            }\n        }\n        idxs.push_back(10000);\n        vector<int>::iterator itr = idxs.begin();\n        int l = -10000, r = *itr;\n        for(int i = 0; i < n; ++i){\n            ans[i] = min(i - l, r - i);\n            if( r == i){\n                l = r;\n                itr++;\n                if( itr == idxs.end() )\n                    r = 20000;\n                else\n                    r = *itr;\n            }\n        }\n\n        return ans;\n\n    }\n};\n```\nT: O(n)\nS: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917631608","body":"```cpp\nclass CustomStack {\nprivate:\n    int size_;\n    int length_;\n    vector<int> *stack_;\npublic:\n    CustomStack(int maxSize) {\n        size_ = maxSize;\n        length_ = 0;\n        stack_ = new vector<int>(maxSize);\n    }\n    \n    void push(int x) {\n        if( length_ < size_ )\n            stack_->at(length_++) = x;\n    }\n    \n    int pop() {\n        int ans;\n        if(length_ > 0){\n            ans = stack_->at(--length_);\n        }\n        else\n            return -1;\n        return ans;\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0; i < k; i++){\n            if( i < length_ ){\n                stack_->at(i) += val;\n            }\n        }\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"CruiseYuGH":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917007515","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        tmp = 0\n        for i in range(n-1,-1,-1):\n            num_tmp = num[i] + k%10+ tmp\n            tmp =num_tmp//10\n            num[i] = num_tmp%10\n            k = k//10\n        #print(k,tmp,num)\n        k += tmp\n        while k!=0:\n            num.insert(0,k%10)\n            k = k//10\n        return num\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917421775","body":"## 思路\r\n左遍历一遍，存储距离，右遍历一遍，两者最小值为最近距离\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        left_num, right_num =[],[]\r\n        c_tmp = -99\r\n        for i,s_char in enumerate(s):\r\n            if s_char == c:\r\n                c_tmp = i\r\n            if c_tmp != -99:\r\n                left_num.append(i-c_tmp)\r\n            else:\r\n                left_num.append(10001)\r\n        c_tmp = -99\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i] == c:\r\n                c_tmp = i\r\n            if c_tmp != -99:\r\n                right_num.insert(0,c_tmp-i)\r\n            else:\r\n                right_num.insert(0,10001)\r\n        res = [min(right_num[i],left_num[i]) for i in range(len(s))]\r\n        return res\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917655502","body":"## 思路\n前缀和思想\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.size = 0\n        self.maxSize = maxSize\n        self.s = []\n        self.s_add = []\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.s.append(x)\n            self.s_add.append(0)\n            self.size += 1\n\n    def pop(self) -> int:\n        if self.size == 0: return -1\n        self.size -= 1\n        if self.size >= 1:\n            self.s_add[-2] += self.s_add[-1]\n        return self.s.pop() + self.s_add.pop()\n\n\n\n    def increment(self, k: int, val: int) -> None:\n        if self.size:\n            self.s_add[min(self.size, k) - 1] += val\n        print(self.s_add)\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Kuroky-Chen":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917007922","body":"* 语言：JavaScript\r\n```\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brainlds":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917008176","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n    \n      LinkedList<Integer> list = new LinkedList<>();\n           \n            for(int i=num.length-1;i>=0;i--){\n                 k = k + num[i];\n                 int a=(k)%10;\n\n                  k=k/10;\n\n                  list.addFirst(a);\n\n            }\n            if(k>0){\n                while(k>0){\n                   \n                    int b = k % 10;\n                     k=k/10;\n                    list.addFirst(b);\n                }\n            }\n            return list;\n\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917329642","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n         char[] chars = s.toCharArray();\n         int[] arr=new int[s.length()];\n        for(int i=0;i<s.length();i++){\n           String s1 = new String(chars,0,i);\n           String s2 = new String(chars,i,s.length()-i);\n           int i1 = s1.lastIndexOf(c);\n           int i2 = s2.indexOf(c);\n           int min=-1;\n           if(i1==-1){\n             min=i2;\n           }\n           if(i2==-1){\n           i1 = s1.length()-i1;\n            min=i1;\n           }\n            if(i1!=-1&&i2!=-1){\n                i1 = s1.length()-i1;\n               min = i1<i2?i1:i2;\n            }\n\n               arr[i]=min;\n        }\n             return arr;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flagyk5":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917009198","body":"```\nclass Solution:\n#list转换为int\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        B = 0\n        for i in range(len(A)):\n            B += A[i]*(10**(len(A) - i - 1))\n#做加法     \n        C = B + K    \n#加判断,程序测试的时候发现[0]和0通不过       \n        if C == 0:\n            D = [0]\n        else:\n            D = []     \n#int转化为list，注意reverse\n#while循环，除了0， 空字符串，空列表，空元组，空字典，空集合等，其它都为True\n        while C:\n            D.append(C%10)\n            C //=10\n        D.reverse()\n        return D\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917411362","body":"```\nfrom typing import List\n\nclass Solution:\n    def shortestToChar(self, S: str, C: str) -> List[int]:\n        ans = []\n\n        for i in range(len(S)):\n            l = r = i\n            while l >= 0:\n                if S[l] == C: break\n                l -= 1\n            while r < len(S):\n                if S[r] == C: break\n                r += 1\n\n            if l == -1: l = -10000\n            if r == len(S): r = 10000\n            ans.append(min(r - i, i - l))\n        return ans\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917650807","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.cs = []\n        self.sz = maxSize\n        \n    def push(self, x: int) -> None:\n        if len(self.cs) < self.sz: \n            self.cs.append(x)\n            \n    def pop(self) -> int:\n        if len(self.cs) == 0:\n            return -1\n        return self.cs.pop()\n        \n    def increment(self, k: int, val: int) -> None:\n        if len(self.cs) <= k:\n            for i in range(len(self.cs)):\n                self.cs[i] += val\n        if len(self.cs) > k:\n            for i in range(k):\n                self.cs[i] += val\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917013134","body":"### 代码实现\n\n```\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\n        if (i >= 0) {\n            k += num[i];\n        }\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(max(n,logk))，其中 nn 为数组的长度\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moxiaopao278":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917014944","body":"#include <algorithm>\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& A, int K) {\n        int carry = 0;\n        vector<int> B;\n        while(K > 0){\n            B.push_back(K%10);\n            K /= 10;\n        }\n        if(B.size()==0){\n            B.push_back(0);\n        }\n        reverse(A.begin(), A.end());\n        int i;\n        int maxl = max(A.size(), B.size());\n        vector<int> C(maxl);\n        //对齐A组和B组的数位。\n        while(A.size()<maxl)A.push_back(0);\n        while(B.size()<maxl)B.push_back(0);\n        for(i = 0; i < maxl; i++){\n            C[i] = A[i] + B[i] + carry;\n            carry = C[i] / 10;\n            C[i] %= 10;\n        }\n        if(carry){\n            C.push_back(carry);\n        }\n        reverse(C.begin(), C.end());\n        return C;\n\n    }\n};\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917662357","body":"#思路\n##官方思路 不太会，学习别人的\n###JAVA\n###class CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.max_size = maxSize\n        self.size = 0\n        self.stack = []\n        \n\n    def push(self, x: int) -> None:\n        if self.size < self.max_size:\n            self.stack.append(x)\n            self.size += 1\n\n    def pop(self) -> int:\n        if self.size > 0:\n            self.size -= 1\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.stack))):\n            self.stack[i] += val\n            \n\n        \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangsizhongbin":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917015435","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n      List returnList= new ArrayList<Integer>();\n\n      //1. 转换成int  \n      int sum = num[0];\n\n      for(int i = 0; i< num.length - 1; i++){\n          sum *=10;\n          sum += num[i+1];\n      }\n\n      //2. 相加\n      sum = sum + k;\n\n      //2. 转成Integer[]\n      String str = Integer.toString(sum);\n      char[] chars = str.toCharArray();\n\n      for(int i = 0; i < chars.length; i++){\n          Integer integer = Integer.valueOf(String.valueOf(chars[i]));\n          returnList.add(integer);\n      }\n\n      return returnList;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917427815","body":"```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        // 1. 获取c的位置\n        List<Integer> cPos = new ArrayList<>();\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == c){\n                cPos.add(i);\n            }\n        }\n\n        // 2. 计算距离\n        int min;\n        int[] res = new int[s.length()];\n        for(int i = 0; i < s.length(); i++){\n            min = Integer.MAX_VALUE;\n            for(int j = 0; j < cPos.size(); j++){\n                int abs = Math.abs(i - cPos.get(j));\n                min = Math.min(abs, min);\n            }\n            res[i] = min;\n        }\n\n        // 3. 返回res\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917542514","body":"class CustomStack {\n    int[] stack;\n    int size;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        size = 0;\n    }\n    \n    public void push(int x) {\n       if(size < stack.length) {\n           stack[size] = x;\n           size++;\n       }\n    }\n    \n    public int pop() {\n        if(size == 0){\n            return -1;\n        }\n        return stack[--size];\n    }\n    \n    public void increment(int k, int val) {\n        int len = size > k ? k : size;\n\n        for(int i = 0; i< len; i++){\n            stack[i] += val;\n        }\n\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zyMacro":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917015464","body":"    let arr2_ = [];\n    while(k>=0) {\n        arr2_.push(k%10);\n        k = Math.floor(k/10);\n        if(k === 0) {\n            break;\n        }\n    }\n    let arr1_ = num.reverse();\n    let len1 = num.length;\n    let len2 = arr2_.length;\n    if(len1 > len2) {\n        while(len1 - len2 > 0) {\n            arr2_.push(0);\n            len1 = len1 - 1;\n        }\n    } else if (len1 < len2){\n        while(len2 - len1 > 0) {\n            arr1_.push(0);\n            len2 = len2 - 1;\n        }\n    }\n    let res = [];\n    let bit = 0;\n    let supplement = 0;\n    arr1_.forEach((val,i) => {\n        let sum = val + arr2_[i];\n        if(sum + bit > 9) {\n            supplement = sum - 10;\n            res.push(supplement + bit);\n            bit = 1;\n        } else {\n            supplement = sum ;\n            res.push(supplement + bit);\n            bit = 0;\n        }\n    })\n    if(bit === 1) {\n        res.push(1);\n    }\n    return res.reverse();","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917381031","body":"```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let arr = s.split('');\n    let indexArr = [];\n    let res = [];\n    arr.forEach((val, i) => {\n        if(val === c) {\n            indexArr.push(i);\n        }\n    })\n    for(let i = 0; i < arr.length; i++) {\n        if(indexArr[0] >= i) {\n            res.push(indexArr[0] - i);\n        } else if (indexArr[indexArr.length - 1] <= i) {\n            res.push(i - indexArr[indexArr.length - 1]);\n        } else {\n            let distance = i - indexArr[0];\n            indexArr.forEach((val) => {\n                distance = distance > Math.abs(i - val) ? Math.abs(i - val) : distance;\n            })\n            res.push(distance);\n        }\n\n    }\n    return res;\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917656961","body":"```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length < this.maxSize) {\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.stack.length === 0) {\n        return -1;\n    }\n    let pop = this.stack.pop();\n    return pop;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    this.stack.forEach((item, index) => {\n        if(index + 1 <= k) {\n            this.stack[index] += val;\n        }\n    })\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"winterdogdog":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917015491","body":"```js\r\n**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];\r\n    for(let i = num.length - 1; i >= 0; i--) {\r\n        let sum = k % 10 + num[i]\r\n        k = Math.floor(k / 10)\r\n        if (sum >= 10) {\r\n            k++\r\n            res.push( sum % 10 );\r\n        } else {\r\n            res.push(sum)\r\n        }\r\n    }  \r\n    while(k > 0) {\r\n        res.push(k % 10)\r\n        k = Math.floor( k / 10)\r\n    }\r\n    return res.reverse()\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917415842","body":"```js\r\n左右循环两次\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let res = [], str = s.split(''), pre = Infinity;\r\n    str.forEach((item, index) => {\r\n        if (item === c) {\r\n            pre = index\r\n        }\r\n        res.push(Math.abs(index - pre))\r\n    })\r\n    pre = Infinity;\r\n    for(let i = str.length - 1; i>=0; i--) {\r\n        if (str[i] === c) {\r\n            pre = i\r\n        }\r\n        if (res[i] > Math.abs(pre - i)) {\r\n            res[i] = Math.abs(pre - i)\r\n        }\r\n    }\r\n    return res\r\n};\r\n\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yankang233":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917015563","body":"#python\r\n\r\n    class Solution:\r\n        def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n            i = len(A) - 1\r\n            while K:\r\n                A[i] += K\r\n                K, A[i] = A[i] // 10, A[i] % 10\r\n                i -= 1\r\n\r\n              if i < 0 and K:\r\n                A.insert(0,0)\r\n                i = 0\r\n           return A\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917351715","body":"## Code\n### python3\n      class Solution:\n          def shortestToChar(self, s: str, c: str) -> List[int]:\n              cc = [ i  for i in range(len(s))   if s[i]==c]\n              return([min([abs(x-y)  for y in cc]) for x in range(len(s))])\n\n## 复杂度\n\n时间：O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917639352","body":"    class CustomStack:\n\n        def __init__(self, maxSize: int):\n            self.stk = [0] * maxSize\n            self.top = -1\n\n        def push(self, x: int) -> None:\n            if self.top != len(self.stk) - 1:\n                self.top += 1\n                self.stk[self.top] = x\n\n        def pop(self) -> int:\n            if self.top == -1:\n                return -1\n            self.top -= 1\n            return self.stk[self.top + 1]\n\n        def increment(self, k: int, val: int) -> None:\n            lim = min(k, self.top + 1)\n            for i in range(lim):\n                self.stk[i] += val","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gentleman-goodman":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917017117","body":"### 思路\n\n------\n\n先在对应位置一一相加，有进位就进位，再进行进位操作，获取每位的数出来\n\n### 语言\n\n------\n\nJava\n\n        class Solution {\n        public List<Integer> addToArrayForm(int[] num, int k) {\n      List<Integer> res = new ArrayList<Integer>();\n       int n = num.length;\n       for (int i = n - 1; i >= 0; --i) {\n         int sum = num[i] + k % 10;\n       k /= 10;\n      if (sum >= 10) {\n       k++;\n     sum -= 10;\n     }\n       res.add(sum);\n      }\n      for (; k > 0; k /= 10) {\n       res.add(k % 10);\n        }\n      Collections.reverse(res);\n      return res;\n          }\n         }\n复杂度分析\n\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\n\n空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zulliu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917017139","body":"**思路**\n\n倒序遍历，将数字拆分为位数相加\n\n**代码**\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        holder = 0\n        counter = 0\n        num=num[::-1]\n        while k > 0 or counter < len(num):\n            if counter >= len(num):\n                digit = k % 10 + holder\n                num.append(digit % 10)\n            else:\n                digit = num[counter] + k % 10 + holder\n                num[counter] = digit % 10\n            holder = digit // 10\n            k = k //10\n            counter += 1\n        if holder == 1:\n            num.append(1)\n        num = num[::-1]\n        return num\n```\n**复杂度分析**\n\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"supermeohh":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917017461","body":"\n\n## 思路\n\n遍历进位\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> r = new ArrayList<Integer>();\n        int n = num.length;\n        for(int i = n-1;i >=0;--i){\n            int sum = num[i] + k%10;\n            k /=10;\n            if(sum >= 10){\n                k++;\n                sum -=10;\n            }\n            r.add(sum);\n        }\n        for(; k>0; k /=10){\n            r.add(k%10);\n        }\n        Collections.reverse(r);\n        return r;\n    }\n}\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n空间复杂度 O(1)\n时间复杂度 O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917424146","body":"\n\n## 思路\n\n左右遍历，取最小值\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n\n\n```\n\n\n**复杂度分析**\n\n\n空间复杂度 O(2N)\n时间复杂度 O(N)\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Baiqr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917022001","body":"```javascript\nfunction calculateTwoNumberSum(arr, num) {\n    const arrNumberStr = arr.join(',')\n    const res = (Number(arrNumberStr.replace(/,/g, \"\")) + num)\n    return String(res).split(\"\")\n}\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"V-Enzo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917027391","body":"## 思路\r\n判断末尾相加的和是否大于10，如果大于10则需要，给k/=10后的k加1，然后进行下一轮操作。使用push_back更易操作\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> result;\r\n        int num_size = num.size();\r\n        for(int i=num_size -1; i>=0; i--){\r\n            int value = num[i] + k%10;\r\n            k/=10;\r\n            if (value>=10){\r\n                k += 1;\r\n                value -= 10;\r\n            }\r\n            result.push_back(value);\r\n        }\r\n        for( ; k>0; k/=10){            \r\n            result.push_back(k%10);\r\n        }\r\n        reverse(result.begin(), result.end());\r\n        return result;\r\n    }\r\n};\r\n```\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917344037","body":"## 思路\r\n找到指定字符，计算出所有的距离，取最小值即可。这里其实变为指针移动去判断更好，能降到时间复杂度为O(N)\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int s_len = s.length();\r\n        vector<int> pos;\r\n        for(int i=0; i<s_len;i++){\r\n            if (s[i] ==c)\r\n                pos.push_back(i);\r\n        }\r\n        vector<int> ans;\r\n        for(int i=0; i<s_len; i++){\r\n            vector<int> min_dist;\r\n            for(int j=0; j<pos.size(); j++){\r\n                min_dist.push_back(abs(i-pos[j]));            \r\n                }\r\n            int min_v = *min_element(min_dist.begin(), min_dist.end());\r\n            ans.push_back(min_v);\r\n            }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n## 复杂度\r\n空间复杂度为O(N)\r\n时间复杂度为O(N^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917592064","body":"## 思路\r\n构建类中的vector，以及top（来标记栈目前的位置），随后通过改变top的值，来压入和弹出值。\r\n```C++\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stack;\r\n    int top;\r\n\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        // cout<<top;\r\n        if(top != stack.size() - 1){\r\n            top += 1;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if(top==-1){\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top+1];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int num = min(k, top+1);\r\n        for(int i=0; i<num; i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n};\r\n```\r\n## 复杂度分析\r\n时间复杂度O(N)\r\n空间复杂度O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ThreeGold-yxh":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917027518","body":"## 思路一\n\n把 num[ ] 和k都转化为list，然后用0补齐较短的那个list，再遍历相加，加法策略为两数相加再加上进位，遍历完了之后最后检查一下进位是否为0，不为0还要插进结果list中，最后把结果list反转即可\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        //首先把k变为数组模式kList\n        int temp = k;\n        List<Integer> kList = new ArrayList<>();\n        while(temp > 0){\n            int kBit = temp % 10;\n            kList.add(kBit);\n            temp = temp / 10;\n        }\n        //KList这时候是反的，个位在第一个\n        //把数组int[] num 变为 numList，注意也是个位数在最前面\n        List<Integer> numList = new ArrayList<>();\n        for(int i = num.length - 1; i >=0; i--){\n            numList.add(num[i]);\n        }\n        //比较一下这两个list哪个长，短的在后面补0\n        if(numList.size() > kList.size()){\n            int length= numList.size() - kList.size();\n            while(length-- > 0){\n                kList.add(0);\n            }\n        }\n        else{\n            int length= kList.size() - numList.size();\n             while(length-- > 0){\n                numList.add(0);\n            }\n        }\n        // //两个list反转\n        // Collections.reverse(numList);\n        // Collections.reverse(kList);\n        List<Integer> resultList = new ArrayList<>();\n        //按位做加法\n        //进位\n        int carryBit = 0;\n        for(int i = 0; i < numList.size(); i++){\n            int currentBit = numList.get(i) + kList.get(i) + carryBit;\n            int remainBit = currentBit % 10;\n            carryBit = currentBit / 10;\n            resultList.add(remainBit);\n        }\n        //最后看一下进位\n        if(carryBit != 0){\n            resultList.add(carryBit);\n        }\n        //反转resultList\n        Collections.reverse(resultList);\n        return resultList;\n    }\n}\n```\n\n### 复杂度分析\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(n)$\n\n因为用到了一个辅助List去保存结果","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917334828","body":"#### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n\n\n\n## 思路一\n\n双指针做法，一个firstIndex快指针，优先找到c的位置，然后慢指针secondIndex再来移动，补全结果数组\n\n\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        //双指针来做\n        int firstIndex = 0;\n        int secondIndex = -1;\n        int[] resultArr = new int[s.length()];\n        while(firstIndex <= s.length() - 1){\n            if(!(c==(s.charAt(firstIndex)))){\n                //如果慢指针还没有动过，那么这时候连一个c都没找到，全部赋值10001\n                if(secondIndex == -1){\n                    resultArr[firstIndex] = 10001;\n                }\n                //反之此时慢指针应该指向上一个c的位置，取位置的差值赋进去\n                else{\n                    resultArr[firstIndex] = firstIndex - secondIndex;\n                }\n                //快指针继续向后\n                firstIndex++;\n            }\n            //此时快指针到了下一个c的所在地，\n            else{\n                resultArr[firstIndex] = 0;\n                int mid = 0;\n                //修改位置差值,如果secondIndex == -1，那么全部都要修改\n                if(secondIndex == -1){\n                    mid = 0;\n                }\n                //修改位置差值,从mid到firstIndex的元素都需要修改值\n                else{\n                    mid = secondIndex + ((firstIndex - secondIndex) + 1) / 2 ;\n                }\n                while(mid < firstIndex){\n                    resultArr[mid] = firstIndex - mid;\n                    mid ++;\n                }\n                //最后把慢指针直接移动到快指针位置\n                secondIndex = firstIndex;\n                //然后快指针继续移动\n                firstIndex ++;\n            }\n        }\n        return resultArr;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：$O(n^2)$\n\n空间复杂度：$O(n)$\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"for123s":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917027734","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int len = num.size() - 1;\r\n        while(len>=0)\r\n        {\r\n            int sum = k % 10 + num[len];\r\n            k /= 10;\r\n            if(sum>=10)\r\n            {\r\n                ++k;\r\n                sum -= 10;\r\n            }\r\n            --len;\r\n            res.push_back(sum);\r\n        }\r\n        while(k>0)\r\n        {\r\n            res.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917328223","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n\r\n## 思路\r\n用数组index存放c在s中的位置，之后对s进行遍历，比较当前位置与index[i]，index[i+1]的距离，取最近距离值。\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res(s.size(),0);\r\n        vector<int> index;\r\n        for(int i=0;i<s.size();++i)\r\n        {\r\n            if(s[i]==c)\r\n                index.push_back(i);\r\n        }\r\n        for(int i=0;i<index[0];++i)\r\n            res[i] = index[0] - i;\r\n        int idx1 = 0, idx2 = idx1+1<index.size()?idx1+1:idx1;\r\n        for(int i=index[0]+1;i<s.size();++i)\r\n        {\r\n            if(idx2==idx1)\r\n                res[i] = i - index[idx1];\r\n            else\r\n                res[i] = (i-index[idx1])<(index[idx2]-i)?(i-index[idx1]):(index[idx2]-i);\r\n            if(res[i]==0)\r\n            {\r\n                idx1++;\r\n                idx2 = idx1+1<index.size()?idx1+1:idx1;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917655795","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass CustomStack {\r\n    int len;\r\n    vector<int> res;\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        len = 0;\r\n        res.resize(maxSize,0);\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(len==res.size())\r\n            return;\r\n        res[len] = x;\r\n        ++len;\r\n    }\r\n    \r\n    int pop() {\r\n        if(len==0)\r\n            return -1;\r\n        --len;\r\n        return res[len];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        if(len<k)\r\n            for(int i=0;i<len;++i)\r\n                res[i] += val;\r\n        else\r\n            for(int i=0;i<k;++i)\r\n                res[i] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Yufanzh":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917128012","body":"## Intuition\r\nTraverse the array from left to right, and then right to left. Both sides will iterative using the following logic:\r\ninitialize the location of c `lastc` as max_value, iterative through rray, if find char == c, then update `lastc = i`; else, update `distance = lastc - i`\r\ndo the same from end to begin\r\nthen the ans will be the minimum value comparing those two at each location.\r\n\r\n## Algorithm\r\ncode in python3\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = [0]*len(s)\r\n        lastc = float('inf')\r\n        for i, ch in enumerate(s):\r\n            if ch == c:\r\n                lastc=i\r\n            else:\r\n                res[i] = abs(lastc-i)\r\n        for i in range(len(s))[::-1]:\r\n            ch = s[i]\r\n            if ch == c:\r\n                lastc = i\r\n            else:\r\n                res[i] = min(res[i], abs(lastc-i))\r\n        return res\r\n```\r\n## Complexity analysis\r\ntime complexity: O(len(s)\r\nextra space complexity: O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917657653","body":"## Intuition\nThe hard part and tricky part is the increment function.\nSimple way is to use for loop and add incremental to each element in the last k positions, which will take O(N) time complexity to finish\nA tricky way to do it in O(1) time complexity is to create another array to record incremental value which we call `incr` array. We modify `incr` with `stack` array. Thus, when push, we also append 0 to `incr` array to keep it the same size as stack. When pop, since we only care about the element's value when it was popped, so we can modify it at the time of popping. So we can just modify `incr[k]` with val added to it. And the returned element from pop will be the element in the `stack` + popped element in the 'incr' array. At the same time, we will update the incr[-2] element with the incr[-1] to update the current last element in `incr` after popping.\n\n## Algorithm in python3\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        #track size, current element count,\n        self.max_size = maxSize\n        self.stack = []\n        self.incr = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n            self.incr.append(0)\n\n    def pop(self) -> int:\n        if len(self.stack) == 0:\n            return -1\n        val = self.stack.pop()\n        if len(self.stack) >=1:\n            self.incr[-2] += self.incr[-1]\n        return val + self.incr.pop()\n    \n    def increment(self, k: int, val: int) -> None:\n        if self.stack:\n            self.incr[min(k, len(self.stack)) -1] += val\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## Complexity Analysis\n- time complexity: O(1) for all functions\n- space complexity: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917714542","body":"## Intuition\n(only figure out how to do it in iterative way)\nUse stack structure to help figuring out this problem. Use two variables to store: `repeatStr` to record letters to be repeated, `repeatCnt`: the repeated numbers, respectively.\nbefore we met with \"]\", we push every character encountered into stack individually. \nWhen we met with \"]\", we start to pop and record. At the step, we will need to check the types of element at the top of stack.\nif \"[\", pop out and not record; if letter, add to `repeatStr`, if numbers, add to `repeatCnt` as strings.\nThen the answer would be \"repeatStr * int(repeatCnt)\"\n## Algorithm in python 3\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        #method-1:iterative way\n        #check the char types: number?letter?left or right parenthese\n        #left: push in stack; right: pop out of stack\n        stack = []\n        for c in s:\n            if c == \"]\":\n                #right parenthese start to triggle pop\n                repeatStr = \"\"\n                repeatCnt = \"\"\n                while stack and stack[-1] != '[':\n                    repeatStr = stack.pop() + repeatStr\n                # pop out [\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCnt = stack.pop() + repeatCnt\n                stack.append(repeatStr * int(repeatCnt))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n```                            \n## Complexity analysis\n- Time complexity: O(N)\n- Space complexity: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HuijunXu":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917139121","body":"### 思路\r\n\r\n* 双指针\r\n\r\n### 代码\r\n```javascript\r\nvar shortestToChar = function(s, c) {\r\n    var l = -1;\r\n    var n = -1;\r\n    var i =0;\r\n    var arr = [];\r\n    while(i<s.length){\r\n        if(n<=i){\r\n            n++;\r\n            while(s[n]!=c&&n<s.length){\r\n                n++\r\n            };\r\n        }\r\n        if(s[i]===c){\r\n            l = i;\r\n            arr[i]=0\r\n        }else{\r\n            if(l<0){\r\n                arr[i] = Math.abs(i-n)\r\n            }else if(n===s.length){\r\n                arr[i] = Math.abs(i-l)\r\n            } else{\r\n                arr[i]=Math.min(Math.abs(i-l),Math.abs(i-n))\r\n            }\r\n        }\r\n        i++\r\n    }\r\n    return arr\r\n};\r\n```\r\n### 复杂度分析\r\n时间：O(n)\r\n空间：O(n)\r\n\r\n### 结果\r\n\r\nAccepted\r\n76/76 cases passed (80 ms)\r\nYour runtime beats 79.89 % of javascript submissions\r\nYour memory usage beats 50.28 % of javascript submissions (40 MB)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bolunzhang2021":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917225566","body":"# java, 菜鸡解法\n```import java.util.Collections;\nimport java.util.ArrayList;\nimport java.util.*;\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n       char []arr=s.toCharArray();\n        int[]ans=new int[arr.length];\n      ArrayList<Integer> a=new ArrayList<Integer>();\n\n        for(int i=0; i<arr.length; i++)\n        {\n            if(arr[i]==c)\n                a.add(i);\n        }\n        for(int i=0; i<arr.length;i++)\n        {\n        ArrayList<Integer> list = new ArrayList<Integer>(); \n            for(int j=0;j<a.size();j++)\n            {\n               list.add(Math.abs(i-a.get(j)));\n            }\n             ans[i]=Collections.min(list);\n        }\n              return ans;\n    }\n}```\n时间复杂度o(n^2)\n空间复杂度0（n）\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917548006","body":"#设计增量栈\r\n-java\r\n-官方题解，用数组\r\n-主要学习如何设计函数\r\n\r\n```java\r\nimport java.util.Stack;\r\nclass CustomStack {\r\n int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n-时间复杂度O(N)\r\n-空间复杂度O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917815687","body":"#JAVA 栈\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n         String res = \"\";\r\n        Stack<Integer> countStack = new Stack<>();\r\n        Stack<String> resStack = new Stack<>();\r\n        int idx = 0;\r\n        while (idx < s.length()) {\r\n            if (Character.isDigit(s.charAt(idx))) {\r\n                int count = 0;\r\n                while (Character.isDigit(s.charAt(idx))) {\r\n                    count = 10 * count + (s.charAt(idx) - '0');\r\n                    idx++;\r\n                }\r\n                countStack.push(count);\r\n            }\r\n            else if (s.charAt(idx) == '[') {\r\n                resStack.push(res);\r\n                res = \"\";\r\n                idx++;\r\n            }\r\n            else if (s.charAt(idx) == ']') {\r\n                StringBuilder temp = new StringBuilder (resStack.pop());\r\n                int repeatTimes = countStack.pop();\r\n                for (int i = 0; i < repeatTimes; i++) {\r\n                    temp.append(res);\r\n                }\r\n                res = temp.toString();\r\n                idx++;\r\n            }\r\n            else {\r\n                res += s.charAt(idx++);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n时间复杂度O(N)\r\n空间复杂度O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"simonsayshi":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917243682","body":"```\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        \n        vector<int>arr;int Last_Occ=-1;\n        int l;\n        for(int j = 0 ; j < s.length() ; j++)\n        {\n            size_t k = s.find(c,j);  \n            if(j==k)//found c at index j\n            {\n                arr.push_back(0);\n                Last_Occ=k;//store the latest index of occurence of char c\n            }\n            else{\n                if(Last_Occ==-1)//not reached index 'j' yet where s[j] == c\n\t\t\t\t\tarr.push_back(k-j);\n                else\n                {\n\t\t\t\t/* use  l = min(k - j , j - Last_Occ) */\n                    if( k - j <= j - Last_Occ)\n                        l = k - j;\n                    else\n                        l = j - Last_Occ;\n                    arr.push_back(l);\n                }\n            }\n            \n        }\n        return arr;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"FlorenceLLL":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917256344","body":"先写一个自己想出来的暴力解决方法\r\n#### 思路\r\n1.首先找到c的所有位置，存在indexList数组中\r\n2.遍历s每个index - indexList的值，取最小，存到answer中\r\n\r\n#### 代码\r\n``` python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        ##找出所有c的位置\r\n        index = s.find(c)\r\n        indexList = []\r\n        indexList.append(index)\r\n\r\n        while (index != -1):\r\n            index = s.find(c,index + 1)\r\n            if(index != -1):\r\n                indexList.append(index)\r\n\r\n        ##计算s每个位置 - c所有的位置，取最小，存到list中\r\n        answer = []\r\n        for i in range(len(s)):\r\n            min = abs(i - indexList[0])\r\n            for j in range(len(indexList)):\r\n               if(abs(i-indexList[j]) < min):\r\n                   min = abs(i-indexList[j])\r\n            answer.append(min)\r\n        \r\n        return answer\r\n```\r\n\r\n#### 复杂度分析\r\n时间复杂度 $$O(n^2)$$ 因为循环两次\r\n空间复杂度 $$O(n)$$ 因为新建了一个数组存answer","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917661136","body":"### 思路\n用python list的基本操作+判断完成\n\n### 代码\n``` python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        self.stack = []\n        self.maxSize = maxSize\n        self.currentSize = 0\n        \n    def push(self, x):\n        if self.currentSize < self.maxSize:\n            self.stack.append(x)\n            self.currentSize += 1\n\n\n    def pop(self):\n        if self.currentSize > 0:\n            self.currentSize -= 1\n            return self.stack.pop()\n        else:\n            return -1\n\n\n    def increment(self, k, val):\n        for i in range(min(k,self.currentSize)):\n            self.stack[i] += val\n```\n\n### 复杂度分析\n#### 时间复杂度：\npush & pop：O(1)\nincrement：O(min(k, self.currentSize))\n\n#### 空间复杂度：\nO(maxSize) 主要是push在使用空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"devosend":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917302280","body":"## 思路\n遍历两次字符串，找到当前字符距离左边和右边第一个目标字符的距离，存储较小的值\n\n## 代码\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = []\n        index = -len(s)\n\n        for i in range(len(s)):\n            if s[i] == c:\n                index = i\n            \n            ans.append(i - index)\n\n        # index = len(s)\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c:\n                index = i\n            \n            ans[i] = min(ans[i], abs(index - i))\n        \n        return ans\n\n```\n\n## 复杂度分析\n- 时间复杂度: O(n)\n- 空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"comst007":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917314532","body":"[821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n----\r\n\r\n### 思路\r\n\r\nmin_dist[i] = min(dist_to_left[i], dist_to_right[i])\r\n\r\n\r\n----\r\n### 代码\r\n\r\n```cpp\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> ans(s.size());\r\n        int pos_c = -10009;\r\n        for(int ii = 0; ii < s.size(); ++ ii){\r\n            if(s[ii] == c){\r\n                pos_c = ii;\r\n                ans[ii] = 0;\r\n                continue;\r\n            }\r\n            ans[ii] = ii - pos_c;\r\n        }\r\n        pos_c = 20009;\r\n        for(int jj = s.size() - 1; jj >= 0;  -- jj){\r\n            if(s[jj] == c){\r\n                pos_c = jj;\r\n                ans[jj] = 0;\r\n                continue;\r\n            }\r\n            ans[jj] = min(ans[jj], pos_c - jj);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n};\r\n\r\n``` \r\n\r\n----\r\n\r\n**复杂度分析**\r\n-   分别从左右两边遍历一边 `O(n)`\r\n-   `O(1)`\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917486247","body":"[1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n----\n\n### 思路\n内部通过变量记录当前元素个数和最大元素个数\n内部通过 `vector<int>`类型的数组存储栈中的数据\n\n\n----\n### 代码\n\n- C++\n\n```cpp\nclass CustomStack {\nprivate:\n    int _maxSize;\n    vector<int> _nums;\n    int _curSize;\npublic:\n    CustomStack(int maxSize) {\n        _maxSize = maxSize;\n        _curSize = 0;\n    }\n    \n    void push(int x) {\n        if(_curSize >= _maxSize) return;\n        ++_curSize;\n        _nums.push_back(x);\n    }\n    \n    int pop() {\n        if(_curSize <= 0) return -1;\n        int tmp = _nums[--_curSize];\n        _nums.pop_back();\n        return tmp;\n    }\n    \n    void increment(int k, int val) {\n        int jj = k > _curSize? _curSize : k;\n        for(int ii = 0; ii < jj; ++ ii){\n            _nums[ii] += val;\n        }\n    }\n};\n\n\n``` \n\n----\n\n**复杂度分析**\n-   incement 为$O(k)$, 其余为$O(1)$\n-   空间复杂度  $O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917695691","body":"[394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n----\n\n### 思路\n借助数据结构 中的 栈。一个栈用来存储中间计算结果st1，一个栈用来存储出现次数 st2。\n从头开始扫描：\n - 遇到连续是数字的字符把它转化成最终的整数存入到st2中。\n - 遇到的字符是大小写字母或者`[`就把它存储到st1 中。\n- 遇到的字符是`]`， 则逐渐弹出st1中的字符，直到`[`。弹出的字符形成的字符串记为s_tmp，然后从st2中弹出一个整数s_feq，最后将s_tmp重复s_feq次，然后把结果存入st1中。\n\n最后返回st1中的字符构成的字符串。\n\n\n----\n### 代码\n\n* C++\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        vector<int> num_st;\n        vector<char> ch_st;\n        for(int ii = 0, cur_cnt = 0; ii < s.size(); ++ ii){\n            if(s[ii] <= '9' && s[ii] >= '0'){\n                cur_cnt = cur_cnt * 10 + s[ii] - '0';\n                continue;\n            }\n            if(cur_cnt > 0){\n                 num_st.push_back(cur_cnt);\n                 cur_cnt = 0;\n            }\n            \n            if( (s[ii] <= 'z' && s[ii] >= 'a') || (s[ii] <= 'Z' && s[ii] >= 'A') || (s[ii] == '[')){\n                ch_st.push_back(s[ii]);\n                continue;\n            }\n            if(s[ii] == ']'){\n                vector<char> tmp_ch;\n                while(ch_st.back() != '['){\n                    tmp_ch.push_back(ch_st.back());\n                    ch_st.pop_back();\n                }\n                ch_st.pop_back();\n                int feq = num_st.back();\n                num_st.pop_back();\n                while(feq --){\n                    for(int jj = tmp_ch.size() - 1; jj >= 0; -- jj){\n                        ch_st.push_back(tmp_ch[jj]);\n                    }\n                }\n            }\n        }\n\n        return string(ch_st.begin(), ch_st.end());\n    }\n\n\n};\n\n``` \n\n----\n\n**复杂度分析**\n假设最终的解码后的字符串长度为m\n-   时间复杂度  遍历一遍字符串的字符 `O(m)`\n-   空间复杂度 需要借助栈来辅助计算 `O(m)`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asuka1h":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917330206","body":"### 思路\r\n官方题解里的贪心算法，\r\n### 代码\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n       int n = S.length();\r\n       vector<int> ret(n,n);\r\n       for(int i = 0; i < n; ++i){\r\n           if(S[i] == C){\r\n               ret[i] = 0;\r\n           }\r\n           else if(i > 0){\r\n               ret[i] = ret[i - 1] + 1;\r\n           }\r\n       }\r\n\r\n       for(int i = n -1; i >= 0; --i){\r\n           if(ret[i] == n || (i < n-1 && ret[i+ 1] + 1 < ret[i]) ){\r\n               ret[i] = ret[i + 1] + 1;\r\n           }\r\n       }\r\n       return ret;\r\n       \r\n    }\r\n};\r\n### 复杂度\r\n时间O（n）\r\n空间O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917332543","body":"# Python 思路\n先遍历s，将位置记录下\n再遍历一遍s，计算s中的元素到每一个位置的距离，取最小值（双重循环）\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        position = []\n        distance = []\n        for i,item in enumerate(s):\n            if item == c:\n                position.append(i)\n                continue\n        print(position)\n\n        for i in range(len(s)):\n            dist = []\n            for p in range(len(position)):\n                if len(position)==1:\n                    d = abs(i-position[p])\n                else:\n                    dist.append(abs(i-position[p]))\n                    d = min(dist)\n            distance.append(d)\n\n\n        return distance\n```\n时间复杂度：O（N*K）\n空间复杂度：O（K）\nK为c在s中出现的次数\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917552614","body":"# 思路：维护一个数组\n```\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.data = []\n        self.maxSize = maxSize\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.data) < self.maxSize:\n            self.data.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.data)==0:\n            return -1\n        else:\n            value = self.data.pop(-1)\n            return value\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        if len(self.data)<k:\n            for i in range(len(self.data)):\n                (self.data)[i] += val\n        else:\n            for i in range(0,k):\n                (self.data)[i] += val\n```\n时间复杂度：O（1）\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"x-joey":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917335984","body":"## 思路\n暴力法：\n首先记录c在字符串中出现的下标，并保存在list中\n然后遍历字符串，字符串中每一位下标和list中的下标相减取绝对值，并保存最小的一个\n## 关键点\n\n-  值得注意的是，看了题解，我的代码可以在两个地方优化\n1. 在两层循环时候，一旦遇到字符c，就不需要进入内循环\n2. 在内循环中，一旦遇到距离大于之前的距离，就可以直接退出内循环，因为是顺序的，后面的距离肯定更大。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        List<Integer> list = new ArrayList();\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i) == c){\n                list.add(i);\n            }\n        }\n        int res[] = new int[s.length()];\n        \n        for(int i=0;i<s.length();i++){\n            int min=Integer.MAX_VALUE;\n            for(int j=0;j<list.size();j++){\n                int abs = Math.abs(i-list.get(j));\n                min = Math.min(abs,min);\n            }\n            res[i] = min;\n        }\n        return res;\n\n    }\n}\n\n```\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n*m)$n是数组长度，m是字符串中出现c的个数\n- 空间复杂度：$O(n)$\n\n```java\n//从左往右和从右往左遍历\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int ans[] = new int[n];\n        int prev = Integer.MIN_VALUE/2;//注意越界，所以除以2\n\n        for(int i=0;i<n;i++){\n            if(s.charAt(i)==c){\n                prev = i;\n            }\n            ans[i] = i-prev;\n        }\n       prev = Integer.MAX_VALUE/2;\n        for(int i=n-1;i>=0;i--){\n            if(s.charAt(i) == c){\n                prev = i;\n            }\n            ans[i] = Math.min(ans[i],prev-i);\n        }\n        return ans;\n    }\n}\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$n是数组长度\n- 空间复杂度：$O(n)$\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biancaone":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917337981","body":"### 思路\n对于string 中的每个charater, 比较离它最近的左右两边target charater的距离，返回最小值\n\n### 代码\n```python3\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        if not s:\n            return []\n\n        result = [0 for i in range(len(s))]\n\n        prev = -sys.maxsize\n\n        for i in range(len(s)):\n            if s[i] == c:\n                prev = i\n            result[i] = i - prev\n\n        prev = sys.maxsize\n\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c:\n                prev = i\n            result[i] = min(result[i], prev - i)\n\n        return result\n```\n### 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917494514","body":"### 思路\n重点，难点其实是inc功能的实现。\n\n****\n### 代码\n```python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.n = maxSize\n        \n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.n:\n            self.stack.append(x)\n        \n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n\n```\n****\n### 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)\n****","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917685635","body":"### 思路\n用栈来记录number和之前的字符串。遇到左括号，就压栈，遇到右括号，弹栈，并更新当前的字符串。\n\n****\n### 代码\n```python3\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        if not s:\n            return ''\n        \n        stack = []\n        \n        cur_string = ''\n        cur_num = 0\n        \n        for char in s:\n            if char == '[':\n                stack.append(cur_string)\n                stack.append(cur_num)\n                cur_string = ''\n                cur_num = 0\n            elif char == ']':\n                prev_num = stack.pop()\n                prev_string = stack.pop()\n                cur_string = prev_string + cur_string * prev_num\n            elif char.isdigit():\n                cur_num = cur_num * 10 + int(char)\n            else:\n                cur_string += char\n                \n        \n        return cur_string\n```\n****\n### 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)\n****","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyxupup":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917339015","body":"Two pass\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int c_position = -n;\n        int[] ans = new int[n];\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                c_position = i;\n            }\n            ans[i] = i - c_position;\n        }\n        \n        for (int j = n - 1; j >= 0; j--) {\n            if (s.charAt(j) == c) {\n                c_position = j;\n            }\n            ans[j] = Math.min(ans[j], Math.abs(j - c_position));\n        }\n        return ans;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917644802","body":"Imple w/ ArrayList\nclass CustomStack {\n    \n    int n;\n    List<Integer> myStack = new ArrayList<>();\n    \n    public CustomStack(int maxSize) {\n        n = maxSize;\n    }\n    \n    public void push(int x) {\n        if (myStack.size() < n) {\n            myStack.add(x);\n        }\n    }\n    \n    public int pop() {\n        if (!myStack.isEmpty()) {\n            return myStack.remove(myStack.size() - 1);\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i < myStack.size(); i++) {\n            myStack.set(i, myStack.get(i) + val);\n        }\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cassiechris":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917341652","body":"### 思路\n\n先遍历一遍字符串s，把c每次出现的index记录下来存为一个list\n然后再次遍历s，每个元素计算与每个c的距离（遍历list），如果计算得到更小的距离就更新最小距离直到遍历完c的list，将得到的最小距离存到距离的list中，最后输出最终的list\n\n### 代码\n\n```python\ndef shortestToChar(s: str, c: str):\n    ls_c = []\n    for i,e in enumerate(s):\n        if e == c:\n            ls_c.append(i)\n    ls_d = []\n    for i in range(len(s)):\n        distance = abs(i-ls_c[0])\n        for c in ls_c:\n            if abs(c-i) < distance:\n                distance = abs(c-i)\n        ls_d.append(distance)\n    return ls_d\n```\n\n**复杂度分析**\n\n- 时间复杂度: $O(N)$，N为字符串s的长度\n- 空间复杂度: $O(N)$，N为字符串s的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"XinnXuu":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917344179","body":"### 思路\n向左向右各遍历一次，比较取距离最小值。\n### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] res = new int[n];\n        int pos = -10001;\n        for(int i = 0; i <= n - 1; i++){\n            if(s.charAt(i) == c){\n                pos = i;\n            }\n            res[i] = i - pos;\n        }\n        pos = 10001;\n        for(int i = n - 1; i >= 0; i--){\n            if(s.charAt(i) == c){\n                pos = i;\n            }\n            res[i] = Math.min(res[i], pos - i);\n        }\n        return res;\n    }\n}\n```\n### 复杂度分析\n- 时间复杂度：$O(N)$, N为数组长度\n- 空间复杂度：$O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917567573","body":"### 思路\n通过增加一个辅助数组，来优化increment操作到O(1)。辅助数组专门负责记录increment操作增加的val值和位置。重点在于pop操作，这时再将栈顶值加上辅助数组记录的val值，并传递该val值给辅助数组的前一位。\n另外要注意一些top=-1以及0时的边界。\n### 代码\n```java\nclass CustomStack {\n    int[] stack;\n    int[] add;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        add = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1){\n            return -1;\n        }\n        int sum = stack[top] + add[top];\n        if (top != 0){\n            add[top - 1] += add[top]; \n        }\n        add[top] = 0;\n        top--;\n        return sum;\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k - 1, top);\n        if (limit >= 0){\n        add[limit] += val; \n        }\n    }\n}\n\n```\n### 复杂度分析\n- 时间复杂度：均为O(1)\n- 空间复杂度：用到了两个数组，O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917718484","body":"\n### 思路\n遇到右括号前不断压栈，遇到右括号后开始出栈，先出栈所有字母直至非字母为止得到repeatStr，再继续出栈所有数字到非数字为止得到重复次数，根据重复次数拼接repeatStr并压入栈。循环结束后全部出栈即得到所求结果。\n### 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n\n        Stack<Character> stack = new Stack<Character>();\n        \n        for (char c : s.toCharArray()){\n            //把遇到]前的所有字符压入栈\n            if(c != ']'){ \n                stack.push(c);\n            } else{\n                //遇到]后开始出栈\n                //1.先取[]内字母\n                StringBuilder letters = new StringBuilder();\n                //弹出[]内字母\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())){\n                    letters.insert(0, stack.pop());\n                }\n\n                String repeatStr = letters.toString();\n                stack.pop(); //pop一次去除左括号[\n\n                //2.开始取倍数数字\n                StringBuilder num = new StringBuilder();\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    num.insert(0, stack.pop());\n                }\n                int repearCount = Integer.valueOf(num.toString());\n\n                //3.根据倍数，拼接字符并压入栈中\n                for ( ; repearCount > 0; repearCount--){\n                    for (char ch : repeatStr.toCharArray()){\n                        stack.push(ch);\n                    }\n                }\n            }\n        }\n        StringBuilder res = new StringBuilder();\n        while (!stack.isEmpty()){\n            res.insert(0, stack.pop());\n        }\n        return res.toString();\n    }\n}\n```\n### 复杂度分析\n- 时间复杂度：O(N),N为s长度\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AgathaWang":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917344743","body":"# 思路\n采用标答第二种思路，空间换时间\n\n# 代码\n```\n# python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        c_lst = [i for i in range(len(s)) if s[i]==c]\n\n        output = []\n        for w in range(len(s)):\n            min_dist = min([abs(i-w) for i in c_lst])\n            output.append(min_dist)\n        return output\n```\n# 复杂度\n- 时间复杂度： O(N*K)\n- 空间复杂度： O(K)\n\nK = length of c_lst, the number of c in s\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917551856","body":"# 答案\n```\n# python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.st = []\n        # self.cnt = 0\n        self.maxSize = maxSize\n\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.st) < self.maxSize:\n            self.st.append(x)\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.st == []:\n            return -1\n        else:\n            return self.st.pop()\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        if k > len(self.st):\n            k = len(self.st)\n       \n        self.st[:k] = [i+val for i in self.st[:k]]\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917817362","body":"# 迭代法\n```\n# python\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        for w in s:\n            repeat_ct = \"\"\n            repeat_char = \"\"\n            if w == \"]\":\n                while stack[-1] != '[':\n                    repeat_char = stack.pop() + repeat_char\n                stack.pop() # delete [\n                while stack and stack[-1].isnumeric():\n                    repeat_ct = stack.pop() + repeat_ct\n                temp = int(repeat_ct)*repeat_char\n                stack.append(temp)\n            else:\n                stack.append(w)\n        return \"\".join(stack)\n```\n时间复杂度： O(s)\n空间复杂度： O(s)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sumukeio":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917350684","body":"class Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        result = [float('inf') for i in s]\r\n        last_c = -float('inf')\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                last_c = i\r\n                result[i] = i-last_c\r\n            else:\r\n                result[i] = i-last_c\r\n        last_c = float('inf')\r\n        for i in range(len(s)-1, -1,-1):\r\n            if s[i] == c:\r\n                last_c = i\r\n            result[i] = min(result[i], last_c - i)\r\n        return result ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917652275","body":"class CustomStack {\r\nprivate:\r\n    int ans[1000];\r\n    int size;\r\n    int top;\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        size = maxSize;\r\n        top = 0;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top < size) \r\n            ans[top ++] = x;\r\n    }\r\n    \r\n    int pop() {\r\n        if (top > 0) return ans[-- top];\r\n        else return -1;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for (int i = 0, num = min(k, top); i < num; i ++)\r\n            ans[i] += val;\r\n    }\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"watermelonDrip":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917351060","body":"```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        indx_c = list()\r\n        \r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                indx_c.append(i)\r\n        \r\n        # find shortest distance\r\n        \r\n        res = [10000]* len(s)\r\n\r\n        for j in range(len(s)):\r\n            if j in indx_c:\r\n                res[j] = 0\r\n            else:\r\n                tmp = [abs(x - j) for x in indx_c]\r\n                res[j] = min(tmp)\r\n\r\n\r\n        return res\r\n\r\n                \r\n\r\n            \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917516610","body":"\r\n栈允许尾部操作，可以用数组进行模拟。\r\n1.\r\npush O(1)\r\npop O(1)\r\nincre O(K): 因为有一层循环\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = list() \r\n        self.maxSize = maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stk) < self.maxSize:\r\n            self.stk.append(x)\r\n        \r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stk) == 0:\r\n            return -1\r\n        tmp = self.stk.pop(-1)\r\n        return tmp\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        k_len = min(k,len(self.stk))\r\n        for i in range(k_len):\r\n            self.stk[i] += val\r\n        \r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n2.\r\n法1中, incre操作的时间复杂度是O(K)。考虑空间换时间。因为只在pop操作的时候，才返回。\r\n用一个数组add来保存每次需要增加的值。\r\n刚写的时候，多次不通过的原因是，很多边界没考虑\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.add = [0] * maxSize \r\n \r\n        self.top = -1  \r\n        self.maxSize = maxSize \r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top == self.maxSize -1:\r\n            return \r\n        self.top += 1\r\n        self.stk[self.top] = x\r\n        \r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        ret = self.add[self.top] + self.stk[self.top]\r\n        if self.top > 0:\r\n            self.add[self.top - 1] += self.add[self.top]\r\n        \r\n        self.add[self.top] = 0\r\n        self.top -= 1\r\n        return ret\r\n        \r\n \r\n    def increment(self, k: int, val: int) -> None:\r\n        k_len = min(k-1,self.top)\r\n        if k_len<0:\r\n            return \r\n\r\n        self.add[k_len] += val\r\n        \r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917803837","body":"```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack =[]\r\n        res = ''\r\n        k = 0\r\n        for elem in s:\r\n            if '0' <=  elem  <= '9':\r\n                k  = k*10+ int(elem)\r\n            elif elem == '[':\r\n                stack.append([res, k])\r\n                res = ''\r\n                k =0\r\n \r\n            elif elem == ']':\r\n                tmp_str, tmp_k = stack.pop()\r\n                \r\n                res = tmp_str + res * tmp_k \r\n            \r\n                \r\n            else:\r\n                res =  res + elem \r\n              \r\n        return res\r\n     time:O(N)        \r\nspace(O(N))\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xvm03":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917351757","body":"### 思路\r\n找s里所有c的位置，遍历s逐一和c的数组进行差值计算，找到最小值，新建数组存放最小值\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n            List<Integer> list = new ArrayList();\r\n            int length = s.length();\r\n            for(int i=0;i<length;i++){\r\n                char b = s.charAt(i);\r\n                if(b == c){\r\n                    list.add(i);\r\n                }\r\n            }\r\n            int[] result = new int[length];\r\n            for(int i=0;i<length;i++){\r\n                char b = s.charAt(i);\r\n                int diffNum=0;\r\n\r\n                for(int y=0;y<list.size();y++){\r\n                    Integer d = list.get(y);\r\n                    int innerDiffNum=0;\r\n                    if(i>d){\r\n                        innerDiffNum=i-d;\r\n                    }else{\r\n                        innerDiffNum=d-i;\r\n                    }\r\n\r\n                    if(y==0){\r\n                        diffNum=innerDiffNum;\r\n                    }\r\n                    if(innerDiffNum<diffNum){\r\n                        diffNum=innerDiffNum;\r\n                    }\r\n                }\r\n                result[i]=diffNum;\r\n            \r\n            }\r\n            return result;\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n需要先遍历一遍s，复杂度：n，然后再遍历一遍s，和重复c的数组进行逐一比对，n*c.length()，n+n*c.length()\r\n\r\n时间复杂度：o(n)\r\n空间复杂度：o(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengistchan":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917353463","body":"# 代码\n```javascript\nconst shortestToChar = (s, c) => {\n  const res = Array(s.length).fill(-1)\n  let close = -1, i = 0\n  while(i < s.length) {\n    if(s[i] === c) {\n      res[i] = 0\n      close = i\n    } else {\n      res[i] = close === -1 ? -1 : i - close\n    }\n    i++\n  }\n  i = s.length - 1\n  while(i >= 0) {\n    if(s[i] === c) {\n      close = i\n    } else {\n      res[i] = res[i] === -1 ? Math.abs(i - close) : Math.min(res[i], Math.abs(i - close))\n    }\n    i--\n  }\n  return res\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917631390","body":"# 代码\n```javascript\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize\n  this.stack = []\n};\n\nCustomStack.prototype.push = function(x) {\n  if(this.stack.length < this.maxSize) {\n    this.stack.push(x)\n  }\n};\n\nCustomStack.prototype.pop = function() {\n  if(this.stack.length === 0) return -1\n  return this.stack.pop()\n};\n\nCustomStack.prototype.increment = function(k, val) {\n  let t = 0\n  while(t < k && t < this.stack.length) {\n    this.stack[t] += val\n    t++\n  }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"QiZhongdd":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917359579","body":"**思路**\n- 定义变量prev代表前一次目标字符出现的小标，然后进行前向遍历，记录与目标字符的距离的绝对值。如同与目标字符相同，则更新变量prev.\n-  进行后序遍历，记录与目标字符的距离的绝对值，与第一次遍历的值比较取最小值。如果与目标字符相同，更新变量prev.\n\n**复杂度**\n- 时间复杂度2n\n- 空间复杂度n\n\n```\nvar shortestToChar = function(s, c) {\n   let prev=-Infinity,result=[];\n   for(let i=0;i<s.length;i++){\n       if(s.charAt(i)===c){\n           prev=i\n       }\n       result[i]=Math.abs(i-prev)\n   }\n   prev=Infinity\n   for(let j=s.length-1;j>=0;--j){\n        if(s.charAt(j)===c){\n           prev=j\n       }\n       result[j]=Math.min(result[j],Math.abs(prev-j))\n   }\n   return result\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917598202","body":"```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize=maxSize\n    this.val=[];\n    this.cnt=0;\n    this.incrementals=new Array(maxSize).fill(0)\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.cnt<this.maxSize){\n        this.val.push(x)\n        this.cnt += 1\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.cnt==0)return -1;\n    if(this.cnt>=2){\n        this.incrementals[this.cnt-2]+=this.incrementals[this.cnt-1];\n    }\n    let val=this.incrementals[this.cnt-1]+this.val.pop();\n    this.incrementals[this.cnt-1]=0;\n    this.cnt-=1;\n    return val;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  if (this.cnt){\n      this.incrementals[Math.min(this.cnt, k) - 1] += val\n  }\n};\n```\n**复杂度**\n时间复杂度都为O(1),空间复杂度为O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youyiqin":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917361047","body":"## 思路\n- 从左到右遍历，结果数组保存距离\n- 从右到左遍历，修正相对较小的距离值\n\n## 代码\n```js\nvar shortestToChar = function(S, C) {\n    let res = [];\n    // tip: max length is 10^4\n    let prev = -10001;\n    \n    for (let i = 0; i < S.length; i++) {\n        if (S.charAt(i) == C) {\n            prev = i;\n        }\n        res[i] = i - prev;\n    }\n\n    prev = 10001;\n    for (let i = S.length - 1; i >= 0; i--) {\n        if (S.charAt(i) == C) {\n            prev = i;\n        }\n        // 取向左和向右中的最小值\n        res[i] = Math.min(res[i], prev - i);\n    }\n    return res;\n};\n```\n\n## 复杂度\n- Time: O(n)\n- Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917661881","body":"# 思路\n使用对象和递增的下标模拟数组的下标，实现访问元素的复杂度为 O(1)\n\n# 代码\n```js\nclass CustomStack {\n  constructor(maxSize) {\n    this._maxSize = maxSize\n    this._size = 0\n    this._content = {}\n  }\n  push(x) {\n    if(this._size < this._maxSize) {\n      this._content[++this._size] = x\n    }\n  }\n  pop() {\n    if(this._size === 0) {\n      return -1\n    } else {\n      const topStackValue = this._content[this._size]\n      delete this._content[this._size--]\n      return topStackValue\n    }\n  }\n  increment(k, val) {\n    if(this._size === 0) {\n      return\n    }\n    for (let index = 1; index <= this._size && index <= k; index++) {\n      this._content[index] += val\n    }\n  }\n}\n```\n# 复杂度\n时间: O(1)\n空间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"juleijs":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917363682","body":"### 思路\r\n* 从当前下标出发，分别向左、向右寻找目标字符C\r\n* 只从一个方向找到的话，直接计算目标距离\r\n* 两个方向都有的话，计算最短的那一个距离\r\n### 代码\r\n``` javascript\r\nfunction shortestToChar(s, c) {\r\n  let res = Array(s.length).fill(0)\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) continue;\r\n    let l = i,\r\n      r = i,\r\n      shortest = Infinity;\r\n    while(l >= 0) {\r\n      if (s[l] === c) {\r\n        shortest = Math.min(shortest, i - l)\r\n        break;\r\n      }\r\n      l--\r\n    }\r\n    while(r < s.length) {\r\n      if (s[r] === c) {\r\n        shortest = Math.min(shortest, r - i)\r\n        break;\r\n      }\r\n      r++\r\n    }\r\n    res[i] = shortest\r\n  }\r\n  return res\r\n}\r\n```\r\n### 复杂度\r\n* 时间复杂度：O(N²)\r\n* 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917588556","body":"### 思路\r\n用数组模拟栈实现，pop、push用数组的原生方法实现，increment时为数组中的每个元素都加上增量的值\r\n### 代码\r\n``` javascript\r\nconst CustomStack = function(maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = [];\r\n};\r\n\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.stack.length >= this.maxSize) return;\r\n  this.stack.push(x);\r\n};\r\n\r\nCustomStack.prototype.pop = function() {\r\n  return this.stack.length > 0 ? this.stack.pop() : -1;\r\n};\r\n\r\nCustomStack.prototype.increment = function(k, val) {\r\n  const length = Math.min(k, this.stack.length);\r\n  for (let i = 0; i < length; i++) {\r\n    this.stack[i] += val;\r\n  };\r\n};\r\n```\r\n### 复杂度\r\n* 时间复杂度：pop、push O(1); increment O(N)\r\n* 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rebel-ly":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917368065","body":"### **思路**\r\n刚开始没啥思路，编程水平低还做的题少。。妈哦，看了官方题解，就解释一下官方题解的思路把！\r\n计算字符串之间的最短距离，对于一个字符串元素来说，就有两个距离，一个靠左边标记点的，一个靠右边标记点的，结合西法老师备注的数组正向，反向遍历，可以想到这里要用两次遍历来找到对于每个字符串元素而言的两个距离，再留下其中的最小值。\r\nanswer直接创建一个整型数组即可。int[ ]\r\n记标记点为pre, 都用charAt(i)来找到，找到赋值为pre=i\r\n首先，从左向右遍历，标记点在元素的左侧，所以answer值为i-pre;\r\n(为了让左侧没有标记点的元素也有一个值，事先对pre赋值为MIN_VALUE/2，除2 是为了防止溢出，因为MIN_VALUE的绝对值比MAX_VALUE还要大1，所以直接减去最小值的话会溢出，感觉这里/3，/4均可以)\r\n其次，从右向左遍历，标记点在元素的右侧，所以answer的值为 pre-i;\r\n（这里官方题解给pre的初始赋值为MAX_VALUE/2，感觉是可以不除以2的，因为pre-int，最大也不会溢出）\r\n最后再对每个字符元素的距离左边右边标记点的距离作比较（Math.min(a,b)），赋值给answer即可。\r\n### **代码**\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n=s.length();\r\n        int[] answer= new int[n];\r\n        int pre=Integer.MIN_VALUE/2;\r\n        for(int i=0; i<n; i++){\r\n            if(s.charAt(i)==c){\r\n                pre=i;\r\n            }\r\n            answer[i]=i-pre;\r\n        }\r\n        pre=Integer.MAX_VALUE;\r\n        for(int i=n-1;i>=0;i--){\r\n            if(s.charAt(i)==c){\r\n                pre=i;\r\n            }\r\n            answer[i]=Math.min(answer[i],pre-i);\r\n        }\r\n        return answer;\r\n\r\n    }\r\n}\r\n```\r\n### **复杂度**\r\n这里的复杂度也主要取决于for循环，都是循环数组长度N \r\n时间复杂度 O(N)\r\n空间上也是占用一个数组长度的空间，因此\r\n空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917581675","body":"### 思路：\r\n 今天的题之前接触过相关的知识，用数组模拟一个队列，所以还是有些头绪的，但是太久没看，还是在检测队列是否为空还是为满的条件上犯了错，看了题解，都是使用Top指标来检测的，在队列初始化的时候，TOP=-1，加一个元素进去，Top++，抛出一个元素，也是在Top处做文章，Top--，抛出Top+1.\r\n至于判断为空为满的条件错误原因：使用nums.length 这始终是我们用来模拟队列的数组长度，是一个固定的值，而Top代表的才是真正的队列长度，所以Top=-1说明没有元素push 队列为空；Top=nums.length-1 说明用来构建队列满了。\r\n对于增值函数比较简单，就是看队列元素也就是Top+1和K的大小关系，取最小值，加就可以了。\r\n反思：晚上空余学习一下用链表模拟队列，希望顺利，今天还学习了滑动窗口的经典题209，加油拉。\r\n### 代码\r\n```\r\nclass CustomStack {\r\n//先进先出 top处进去 top处出去\r\n    int top;\r\n    int[] cust;\r\n\r\n    public CustomStack(int maxSize) {\r\n      cust=new int[maxSize];\r\n      top=-1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n       if (!isFull()){\r\n         top++;\r\n         cust[top]=x;\r\n         }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(isEmpty())\r\n           return -1;\r\n        top--;\r\n        return cust[top+1];\r\n\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit=Math.min(k,top+1);\r\n        for(int i=0;i<limit;i++){\r\n            cust[i]+=val;\r\n        }\r\n\r\n    }\r\n    public boolean isEmpty(){\r\n        //return cust.length==0;\r\n        return top==-1;\r\n    }\r\n    public boolean isFull(){\r\n        return top==cust.length-1;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n对于一个队列的操作push或者pop都是O(1)\r\n但是在increment这里涉及到了循环，所以是O（n）\r\n时间复杂度：O(n)\r\n空间上最大也是一个数组\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Winperrr":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917370146","body":" c++\r\n---\r\n### 思路\r\n\r\n\r\n1. 先遍历字符串，把与字符相同的元素下标存储在数组key中\r\n2. 双重循环，计算answer每个元素的下标与key中各个元素的距离绝对值，得到最小值存储到answer中，便得到结果\r\n\r\n---\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int len =s.length();\r\n        vector<int> key;\r\n        vector<int> answer;\r\n        for(int i=0;i<len;i++){\r\n            if(s[i]==c) key.push_back(i);\r\n        }\r\n        int n=key.size();\r\n        for(int k=0;k<len;k++){\r\n            int ans=abs(k-key[0]);\r\n            for(int j=1;j<n;j++){\r\n                if (ans>abs(k-key[j]) )ans=abs(k-key[j]);\r\n            }\r\n            answer.push_back(ans);\r\n        }\r\n        return answer;\r\n    }\r\n};\r\n```\r\n---\r\n### 时间复杂度\r\n**O(n*n) 双重循环**\r\n### 空间复杂度\r\n**O(n)**","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangcn111":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917371448","body":"``` javascript \n function shortestToChar(S, C) {\n    //先把c的所有下标找到\n    let indexs = [];\n    let res = [];\n    for (let i = 0; i < S.length; i++) {\n        if (S[i] === C) {\n            indexs.push(i);\n        }\n    }\n    //每一个元素跟 c的下标差的绝对值最小的那个\n    for (let i = 0; i < S.length; i++) {\n        let min = Infinity;\n        indexs.reduce((minx, cur) => {\n            min = minx < Math.abs(i - cur) ? minx : Math.abs(i - cur);\n            return min;\n        }, Infinity);\n        res.push(min);\n    }\n    return res;\n}\n\n``` \n\n复杂度分析\n\n时间复杂度：O(N*K)O(N∗K)，N 是 S 的长度，K 是字符 C 在字符串中出现的次数，K <= NK<=N。\n\n空间复杂度：O(K)O(K)，K 为字符 C 出现的次数，这是记录字符 C 出现下标的辅助数组消耗的空间\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freesan44":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917385468","body":"### 思路\r\n通过指针检索当前index与下一个，跟当前字符距离哪个大，然后进位\r\n\r\n### 代码\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        indexList = []\r\n        for index,val in enumerate(s):\r\n            if val == c:\r\n                indexList.append(index)\r\n        resList = []\r\n        p = 0#通过指针检索当前index与下一个，跟当前字符距离哪个大，然后进位\r\n        # print(indexList)\r\n        for index,val in enumerate(s):\r\n            # print(index)\r\n            if p < len(indexList)-1 and (abs(index-indexList[p]) > abs(index-indexList[p+1])):\r\n                p += 1\r\n            resList.append(abs(index-indexList[p]))\r\n        return resList\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间：O(N) \r\n- 空间：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917546707","body":"## 思路\r\n通过数组的append和pop实现增删\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass CustomStack:\r\n    maxSize = 0\r\n    stack = []\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = list()\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) > 0:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.stack) >= k:\r\n            for i in range(0,k):\r\n                self.stack[i] += val\r\n        else:\r\n            for i in range(len(self.stack)):\r\n                self.stack[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917742130","body":"## 思路\r\n通过一个临时栈，从]符号开始倒数栈内的字符串然后进行拼接处理\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        sList = list(s)\r\n        stack = list()\r\n        res = \"\"\r\n        while len(sList) != 0:\r\n            i = sList.pop(0)\r\n            # print(i)\r\n            if i == \"]\":#出栈\r\n                tempStr = \"\"#找出栈内最后一个[]内的字符串\r\n                while True:\r\n                    j = str(stack.pop())\r\n                    if j.isalpha() == True:\r\n                        tempStr = j + tempStr\r\n                    elif j == \"[\":\r\n                        break\r\n                tempInt = \"\"#找出栈内最后一个连续数字\r\n                # print(stack, tempStr, tempInt,\"-\")\r\n                while True:\r\n                    try:\r\n                        k = stack.pop()\r\n                        if k.isnumeric() == True:\r\n                            tempInt = k + tempInt\r\n                        else:\r\n                            stack.append(k)#如果是非数字，再次入栈\r\n                            break\r\n                    except:#用于边界条件【其实不稳固】\r\n                        break\r\n                # print(stack,tempStr,tempInt)\r\n                stack.append(tempStr*int(tempInt))\r\n                # print(stack)\r\n            else:\r\n                stack.append(i)\r\n                # print(stack)\r\n        return \"\".join(stack)\r\n\r\n\r\n\r\nif __name__ == '__main__':\r\n    # s = \"3[a]2[bc]\"\r\n    # s = \"3[a2[c]]\"\r\n    # s = \"2[abc]3[cd]ef\"\r\n    # s = \"abc3[cd]xyz\"\r\n    s = \"100[leetcode]\"\r\n    result = Solution().decodeString(s)\r\n    print(result)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(n)$\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"XiangyDeng":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917386558","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> answer;\n        answer.resize(s.length());\n\n        for(int i = 0;i < s.length();i++)\n        {\n            int j = i,k = i;\n\n            while(j >= 0 || k <= s.length()-1)\n            {\n                if(j >= 0)\n                {\n                    if(s[j] == c)\n                    {\n                        answer[i] = abs(i-j);\n                        break; \n                    }\n                    j--;\n                }\n                if(k <= s.length())\n                {\n                    if(s[k] == c)\n                    {\n                        answer[i] = abs(i - k);\n                        break;\n                    }\n                    k++;\n                }\n            }\n        }\n        return answer;\n    }\n};\n时间复杂度：O(n^2)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanjyumoso":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917390477","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = [len(s)] * len(s)\n\n        j = 0\n        for i in range(len(s)):\n            if s[i] != c:\n                continue\n            ans[i] = 0\n            while j <= i:\n                ans[j] = min(abs(1 + ans[j-1]), abs(i-j)) if j > 0 else abs(i-j)\n                j += 1\n        while j < len(s):\n            ans[j] = 1 + ans[j-1]\n            j += 1\n        return ans\n```\n\n* Time: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leige635539766":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917394084","body":"class Solution:\n    def __init__(self, S, C):\n        self.S = S\n        self.C = C\n\n    def Distance(self):\n        C_loc = []\n        min_dis = []\n        for i in range(len(self.S)):\n            if self.S[i] == self.C:\n                C_loc.append(i)\n        for i in range(len(self.S)):\n            distance = []\n            for j in C_loc:\n                distance.append(abs(j-i))\n            min_dis.append(sorted(distance)[0])\n\n        return min_dis\n\n\n\n\n\n\n\n思路： \n  先把字符所在的位置标记出来；\n  再遍历字符串中每个字符距离指定字符最近的距离。\n \n \n \n时间复杂度分析：\n  O(N*K) N位字符串长度 K位指定字符出现的次数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917571670","body":"## 思路\r\n\r\n\r\n满了的条件判断；\r\n空了的条件判断。\r\n\r\n\r\n## 代码\r\n```\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, size):\r\n        self.size = size\r\n        self.st = []\r\n        self.cnt = 0\r\n\r\n\r\n    def push(self, x):\r\n        if self.cnt < self.size:\r\n            self.st.append(x)\r\n            self.cnt += 1\r\n\r\n\r\n\r\n    def pop(self):\r\n        if self.cnt == 0: return -1\r\n        self.cnt -= 1\r\n        return self.st.pop()\r\n\r\n\r\n\r\n    def increment(self, k, val):\r\n        for i in range(0, min(self.cnt, k)):\r\n            self.st[i] += val\r\n```\r\n## 时间复杂度\r\n\r\nO(min(cnt, k))\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Master-guang":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917405597","body":"Leetcode 821 字符的最短距离\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n题目思路：\n把输入字符 C 看成分界线，将 S 划分成一个个窗口。\n然后对每个窗口进行遍历，分别计算每个字符到窗口边界的距离最小值。\n\n代码：\nvar shortestToChar = function (S, C) {\n  let left = S[0] === C ? 0 : Infinity\n  let right = S.indexOf(C, 1);\n\n  let res = Array(S.length);\n\n  for (let i = 0; i < S.length; i++) {\n    res[i] = Math.min(Math.abs(i - left), Math.abs(right - i));\n\n    if (i === right) {\n      left = right;\n      right = S.indexOf(C, left + 1);\n    }\n  }\n\n  return res;\n};\n\n复杂度分析\n时间复杂度：O(N)，N 是 S 的长度。\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917654622","body":"> # 1381. 设计一个支持增量操作的栈\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n> \r\n> ## 前置知识\r\n> * 栈\r\n> * 前缀和\r\n> \r\n\r\n语言：Pyhton\r\n\r\n1. 解题思路1：简单数组操作\r\n使用数组的栈结构，进出栈分别通过简单的数组赋值与读取进行操作，increment函数通过一个循环进行赋值操作\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top < len(self.stack)-1:\r\n            self.top += 1\r\n            self.stack[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top is -1:\r\n            return self.top\r\n        else:\r\n            self.top -= 1\r\n            return self.stack[self.top+1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k,self.top+1)):\r\n            self.stack[i] += val\r\n\r\n时间复杂度：O（k），由复杂度最高的函数increment决定，因为有一个for循环，其他函数都是常量复杂度。\r\n空间复杂度：O（maxSize）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"summer506hai":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917418464","body":"#-*- coding : utf-8 -*-\n'''\n遍历字符串，找到目标字母，用cIndices数组记下位置. 遍历字符串，将当前位置与cIndices数组的位置进行相减，取最小值\n'''\ndef shortestToChar(S, C):\n    cIndices = []\n    res = []\n    for i,x in enumerate(S):\n        if x == C:\n            cIndices.append(i)\n    for i,x in enumerate(S):\n        r = float('inf')\n        for j,y in enumerate(cIndices):\n            r = min(r,abs(i - y))\n        res.append(r)\n    return res\n\nprint(shortestToChar(\"loveleetcode\",\"e\"))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917610041","body":"## 解题思路\n- 创建inc数组用来记录增量操作\n## 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.cnt = 0\n        self.maxSize = maxSize\n        self.inc = []\n        self.st = []\n\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.maxSize:\n            self.st.append(x)\n            self.cnt = self.cnt + 1\n            self.inc.append(0)\n\n\n    def pop(self) -> int:\n        if self.cnt == 0:\n            return -1\n        self.cnt -= 1\n        if self.cnt >= 1:\n            self.inc[-2] += self.inc[-1]\n        return self.st.pop() + self.inc.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        if self.cnt:\n            self.inc[min(k,self.cnt)-1] += val\n            #print(self.inc)\n\n\nif __name__ == '__main__':\n    obj = CustomStack(3)\n    obj.push(1)\n    obj.push(2)\n    obj.pop()\n    obj.push(2)\n    obj.push(3)\n    obj.push(4)\n\n    obj.increment(5, 100)\n    obj.increment(2, 100)\n    print(obj.pop())\n    print(obj.pop())\n    print(obj.pop())\n    print(obj.pop())\n```\n## 算法复杂度\n时间负责度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ChenJingjing85":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917419109","body":"## 思路\n遍历字符串直到找到一个匹配位置，记录上一个匹配的位置， 这两个位置之间的字符的最短距离必然由这两个位置产生。注意匹配字符在两端和在中间的不同情况。\n## 代码\n``` java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        char[] ss = s.toCharArray();\n        int lastHitIndex = -99;\n        for(int i = 0; i < s.length(); i ++){\n            if(ss[i] == c){\n                if(lastHitIndex >=0 ){\n                    int mid = (lastHitIndex + i)/2; \n                    int dis = 0;\n                    for(int j = lastHitIndex; j <= mid; j ++){\n                        res[j] = dis++;\n                    }\n                    dis = 0;\n                    for(int j = i; j > mid; j --){\n                        res[j] = dis++;\n                    }\n                }else{\n                    int dis = i;\n                    for (int j = 0; j <= i; j ++){\n                        res[j] = dis--;\n                    }\n                }\n\n                lastHitIndex = i;\n            }\n        }\n        int dis = 0;\n        for(int j = lastHitIndex; j <= s.length()-1; j ++){\n            res[j] = dis++;\n        }\n        return res;\n    }\n}\n```\n## 复杂度分析\n时间复杂度：O(N)\n\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917543324","body":"### 思路\n利用数组实现栈，用一个指针记录栈顶位置\n### 代码\n``` java\nclass CustomStack {\n    private int[] stack;\n    private int top = -1;;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(stack.length-1 > top){\n            stack[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top>=0){\n            return stack[top--];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int incre = Math.min(k, top+1);\n        for(int i = 0; i < incre; i ++){\n            stack[i] = stack[i]+val;\n        }\n\n    }\n}\n```\n### 复杂度分析\n* 增加元素：时间O(1), 空间O（1）\n* 删除元素：时间O(1), 空间O（1）\n* 增量操作：时间O(N), 空间O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saltychess":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917427308","body":"思路\n-------\n学习官方解法，左右各遍历一遍\n\n代码\n-------\n语言：java\n```java\npublic int[] shortestToChar(String s, char c) {\n\tint len=s.length();\n\tint[] ans =new int[len];\n\tint pre = Integer.MIN_VALUE/2;\n\tfor(int i=0;i<len;i++) {\n\t\tif(s.charAt(i)==c) {\n\t\t\tpre = i;\n\t\t}\n\t\tans[i] = i-pre;\n\t}\n\tpre = Integer.MAX_VALUE;\n\tfor(int i=len-1;i>=0;i--) {\n\t\tif(s.charAt(i)==c) {\n\t\t\tpre = i;\n\t\t}\n\t\tans[i] = Math.min(ans[i], pre-i);\n\t}\n\treturn ans;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917596611","body":"思路\n-------\n用数组模拟栈，这次依旧参考了官方的代码，一开始想用数组模拟队列的代码修改一下，结果反而想复杂了。\n\n代码\n-------\n```java\nclass CustomStack {\n    int[] stack;\n    int head=-1;\n    int maxSize=0;\n    public CustomStack(int maxSize) {\n        this.stack=new int[maxSize];\n        this.maxSize=maxSize;\n    }\n    public void push(int x) {\n        if(head>=maxSize-1) {\n            return;\n        }\n        head++;\n        stack[head]=x;\n    }\n    public int pop() {\n        if(head==-1) {\n            return -1;\n        }\n        head--;\n        int res=stack[head+1];\n        stack[head+1]=0;\n        return res;\n    }\n    public void increment(int k, int val) {\n        if(k>=maxSize) {\n            k=maxSize;\n        }\n        for(int i=0;i<=k-1;i++) {\n            stack[i]+=val;\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lihuiwen":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917428923","body":"## 思路\n正序遍历和反序遍历\n## 代码\n```\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n  let dis = Infinity\n  const ret = []\n  for (let i = 0; i < s.length; i++) {\n    const cur = s[i]\n    if (cur === c) {\n      dis = 0\n    } else {\n      dis++\n    }\n    ret.push(dis)\n  }\n\n  for (let i = s.length - 1; i >= 0; i--) {\n    const cur = s[i]\n    if (cur === c) {\n      dis = 0\n    } else {\n      dis++\n    }\n    ret[i] = Math.min(dis, ret[i])\n  }\n\n  return ret\n};\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917659625","body":"## 思路\n用数组模拟栈\n## 代码\n```\nvar CustomStack = function (maxSize) {\n  this.maxSize = maxSize\n  this.stack = []\n}\n\nCustomStack.prototype.push = function (x) {\n  if (this.stack.length >= this.maxSize) {\n    return;\n  }\n  this.stack.push(x)\n}\n\nCustomStack.prototype.pop = function () {\n  return this.stack.length > 0 ? this.stack.pop() : -1\n}\n\nCustomStack.prototype.increment = function (k, valu) {\n  let len = Math.min(k, this.stack.length)\n  for (let i = 0; i < len; i++) {\n    this.stack[i] += val\n  }\n}\n```\n## 复杂度\n时间复杂度：O(1)push、O(1)pop 、O(n)inc\n\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhy3213":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917429931","body":"# 思路\n\n保存位置，计算差值，找最小\n\n```\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pos=[]\n        res=[]\n        for i, cha in enumerate(s):\n            if cha==c:\n                pos.append(i)\n        for i in range(len(s)):\n            res.append(min([abs(j-i) for j in pos]))\n        return res\n```\n\n写起来很方便但理论时间复杂度O(N^2)，空间O(N)\n\n而实际执行中根据所选字符的频率，再加入合理的剪枝，执行速度并不会较左右遍历有很大差距。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917549491","body":"# 思路\nlazy increment: 维护一个增量数组，由于是底部k个值同时增加，可以在需要增加的最顶元素上标记仅标记一次，在pop时再进行加操作，即可实现O(1)的increment\n\n# 代码\n```python\ndef __init__(self, maxSize: int):\n        self.stk=[]\n        self.inc=[]\n        self.maxSize=maxSize\n        self.top=0\n\n    def push(self, x: int) -> None:\n        if self.top == self.maxSize:\n            return\n        self.stk.append(x)\n        self.inc.append(0)\n        self.top+=1\n\n    def pop(self) -> int:\n        if self.top==0:\n            return -1\n        ret=self.stk.pop()\n        ret+=self.inc[self.top-1]\n        if self.top>1:\n            self.inc[self.top-2]+=self.inc.pop()\n        else:\n            self.inc.pop()\n        self.top-=1\n        return ret\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stk)==0:\n            return\n        self.inc[min(k,len(self.inc))-1]+=val\n```\n# 复杂度\n空间O(N)\n时间O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917429949","body":"```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        ArrayList<Integer> arr = new ArrayList<>();\r\n        int[] ret = new int[s.length()];\r\n        int p = 0;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) arr.add(i);\r\n        }\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (p < arr.size() - 1 && Math.abs(arr.get(p) - i) > Math.abs(arr.get(p + 1) - i)) p++;\r\n            ret[i] = Math.abs(arr.get(p) - i);\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917644778","body":"## 思路\r\n用数组来模拟栈操作\r\n1. pop时候需要栈考虑是否已空,且返回的是删除的值\r\n2. push时候需要栈考虑是否已满\r\n## 代码\r\nJava实现\r\n```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top != stack.length - 1){\r\n            top++;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top != -1){\r\n            top--;\r\n            return stack[top+1];\r\n        }else{\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int min = Math.min(k, top+1);\r\n        for(int i=0;i<min;i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hibriansun":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917444038","body":"## Main idea\n模拟\n\n## Code\n```cpp\n// C++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        stack.resize(maxSize);\n    }\n    \n    void push(int x) {\n        if (top + 1 < stack.size()) {\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        int rtn = stack[top];\n        top--;\n        return rtn;\n    }\n    \n    void increment(int k, int val) {\n        k > stack.size() ? k = stack.size() : k;\n        for (int i = 0; i < k; i++) {\n            stack[i] += val;\n        }\n    }\nprivate:\n    vector<int> stack;\n    int top = -1;\n};\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n## Complexity\nTime: O(N)\nSpace: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jz1433":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917486769","body":"\n``` python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(len(self.stack), k)):\n            self.stack[i] += val\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aduispace":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917498723","body":"### IDEA\nUse an int array as stack, and a pointer to record the top of stack\n\n### Code\n\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top < stack.length - 1) {\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top > -1) {\n            int prevTopValue = stack[top];\n            top--;\n            return prevTopValue;\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        if (top == -1) return;\n        for (int i = 0; i < Math.min(k, top + 1); i++) {\n            stack[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n\n```\n\n### Time and Space Complexity\n\nTime: O(1) for push and pop, O(Math.min(k, top + 1)) for increment\nSpace: O(MaxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenlong201807":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917538106","body":"### 解题思路\r\n```\r\njs中数组的操作，支持push pop 即为后进先出，符合栈的特点\r\nthis指针在原型中可以指向构造函数，因此，在构造函数中，初始化需要的基本数据内容。比如这里需要一个数组作为栈中数据的存储内容\r\n栈中的最大长度作为数组的长度，即可符合需求\r\n具体的细节要求按照执行就行了。\r\n\r\n```\r\n\r\n### 代码块\r\n```javascript\r\n\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function(maxSize) {\r\n  this.arr = []\r\n  this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.arr.length < this.maxSize) {\r\n    this.arr.push(x)\r\n  }\r\n\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  if (this.arr.length) {\r\n    return this.arr.pop()\r\n  }\r\n\r\n  return -1\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  const addValNum = Math.min(this.arr.length, k)\r\n  for (let i = 0; i < addValNum; i++) {\r\n    this.arr[i] = this.arr[i] + val\r\n  }\r\n};\r\n\r\n```\r\n\r\n### 时间复杂度和空间复杂度\r\n- 时间复杂度\r\n    + push O(1)\r\n    + pop O(1)\r\n    + incr O(k)\r\n- 空间复杂度\r\n   + push O(1)\r\n   +  pop O(1)\r\n   + incr O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LareinaWei":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917580204","body":"### 思路\n使用一个list来进行stack的模拟，push使用append进行模拟，pop使用list的pop函数进行模拟\nincrement先比较k与current stack size的大小，再进行increment\n\n### 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.size = 0\n        self.maxSize = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.stack.append(x)\n            self.size += 1\n\n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n        self.size -= 1\n        return self.stack.pop()\n        \n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i < self.size:\n                self.stack[i] += val\n```\n\n### 复杂度分析\n时间复杂度: Push O(1), pop O(1), increment O(n)  \n空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qibao1112":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917600091","body":"### 思路\r\n\r\n使用数组构建栈的push和pop操作，同时需要记录当前数组的大小。\r\n\r\n### 代码\r\n\r\n```\r\nclass CustomStack {\r\n\r\n     private int[] stack;\r\n    private int maxSize;\r\n    private int currentSize = 0;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        stack = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (currentSize < maxSize) {\r\n            stack[currentSize] = x;\r\n            currentSize++;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (currentSize == 0) return -1;\r\n        currentSize--; \r\n        return stack[currentSize];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int n = k < currentSize ? k : currentSize;\r\n        for (int i = 0; i < n; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ziyue08":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917600668","body":" \r\n## 解题思路：\r\n初始化函数中，定义栈的最大容量maxSize，设置栈指针为-1。push函数中判断当前栈是否已满，未满，则指针加1，对应位置赋值为x，pop函数内，判断栈是否为空，为空返回-1，不为空指针减1，并返回栈顶元素。increment函数内，先找到k与栈长度的最小值。然后将最小值范围内的元素加上val。代码如下：\r\n\r\n## 代码如下\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function(maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = [];\r\n};\r\n\r\n/** \r\n* @param {number} x\r\n* @return {void}\r\n*/\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.stack.length < this.maxSize) {\r\n      this.stack.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n* @return {number}\r\n*/\r\nCustomStack.prototype.pop = function() {\r\n  if (this.stack.length > 0) {\r\n      return this.stack.pop();\r\n  } else {\r\n      return -1;\r\n  }\r\n};\r\n\r\n/** \r\n* @param {number} k \r\n* @param {number} val\r\n* @return {void}\r\n*/\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let len = this.stack.length;\r\n  if (len < k) {\r\n      for (let i = 0; i < len; i++ ) {\r\n          this.stack[i] += val;\r\n      }\r\n  } else {\r\n      for (let i = 0; i < k; i++) {\r\n          this.stack[i] += val;\r\n      }\r\n  }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Alanwgy":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917603196","body":"# 解法： 模拟\n时间复杂度：初始化、push 操作和 pop 操作的渐进时间复杂度为 O(1)，increment 操作的渐进时间复杂度为 O(k)。\n空间复杂度：用到了一个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为 O(maxSize)\n\n~~~python\n\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = [0] * maxSize\n        self.top = -1\n\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stack) - 1:\n            self.top += 1\n            self.stack[self.top] = x\n\n\n\n    def pop(self) -> int:\n        if self.top == -1: return -1\n        self.top -= 1\n        return self.stack[self.top+1]\n\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k,self.top+1)\n        for i in range(lim):\n            self.stack[i] += val\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuezhongyuan":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917604786","body":"### 思路：\r\n双数组实现\r\n\r\n### 代码：\r\n```\r\nclass CustomStack {\r\n    private int size;\r\n    private int[] arrayStack;\r\n    private int[] increArray;\r\n\r\n    public CustomStack(int maxSize){\r\n        arrayStack = new int[maxSize];\r\n        increArray = new int[maxSize];\r\n        size = -1;\r\n    }\r\n\r\n    public void push(int x){\r\n        if (size <arrayStack.length - 1)\r\n            arrayStack[++size] = x;\r\n    }\r\n\r\n    public int pop(){\r\n        if (size == -1)\r\n            return -1;\r\n\r\n        int ans = arrayStack[size] + increArray[size];\r\n\r\n        if (size != 0)\r\n            increArray[size - 1] += increArray[size];\r\n\r\n        increArray[size] = 0;\r\n        size--;\r\n\r\n        return ans;\r\n    }\r\n\r\n    public void increment(int k ,int val){\r\n            int min = Math.min(size,k-1);\r\n            if (min >= 0 ){\r\n                increArray[min] += val;\r\n            }\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析：\r\n时间复杂度：O(k)\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"watchpoints":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917607639","body":"~~~c++\r\n// @lc code=start\r\n//time  increment 0（k）\r\n//space:o(n)\r\nclass CustomStack\r\n{\r\nprivate:\r\n    vector<int> m_data; //随机读写\r\n    int m_maxlen;\r\n    int m_top; //下一个元素位置 m_data没有元素\r\npublic:\r\n    CustomStack(int maxSize)\r\n    {\r\n        m_maxlen = maxSize;\r\n        m_data.resize(maxSize); //无扩容操作\r\n        m_top = 0;              //空栈\r\n    }\r\n\r\n    void push(int x)\r\n    {\r\n        //满： m_top == m_maxlen\r\n        if (m_top >= m_maxlen)\r\n        {\r\n            return;\r\n        }\r\n\r\n        m_data[m_top++] = x;\r\n    }\r\n\r\n    int pop()\r\n    {\r\n        //空栈 m_top == 0\r\n        if (m_top <= 0)\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        return m_data[--m_top];\r\n    }\r\n\r\n    void increment(int k, int val)\r\n    {\r\n\r\n        int size = min(k, m_top);\r\n        for (int i = 0; i < size; i++)\r\n        {\r\n            m_data[i] += val;\r\n        }\r\n    }\r\n};\r\n~~~","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wanghuaikuan":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917620989","body":"1. 思路\r\n较简单的栈的基本实现\r\n\r\n2. 代码\r\n```cpp\r\nclass CustomStack {\r\npublic:\r\n    vector<int> s;\r\n    int size;\r\n    CustomStack(int maxSize) {\r\n        s.resize(maxSize);\r\n        size=0;\r\n    }\r\n    void push(int x) {\r\n        if(size<s.size())s[size++]=x;\r\n    }\r\n    int pop() {\r\n        if(size>0) return s[--size];\r\n        return -1;\r\n    }\r\n    void increment(int k, int val) {\r\n        for(int i=0;i<min(k,size);i++)  s[i]+=val;\r\n    }\r\n};\r\n\r\n```\r\n\r\n3.复杂度\r\n时间复杂度：increment方法为O(k),其他的都为O(1)；\r\n空间复杂度：O(maxSize);","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ShuchenWuu":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917634185","body":"#include <iostream> \r\n#include <stack> \r\nusing namespace std;\r\n\r\nclass CustomStack {\r\npublic:\r\n        vector<int> stack;\r\n        int size;\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize);\r\n        size = 0;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (size < stack.size()){\r\n            stack[size] = x;\r\n            size++;            \r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        int res = -1;\r\n        if (size > 0){\r\n            size--;\r\n            res = stack[size];\r\n        }\r\n\r\n        return res;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for (int i = 0; i < min(k, size); i++)\r\n            stack[i] += val;\r\n    }\r\n};\r\n\r\n时间复杂度push：O(1)，pop：O(1)，increment：O(N) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luoanyang":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917642515","body":"### 思路\n用js中的数组来模拟栈\n\n### 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.stack = [];\n  this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if(this.stack.length == this.maxSize) return;\n  this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n   if(this.stack.length==0) return -1;\n   let cur = this.stack[this.stack.length-1];\n   this.stack.length = this.stack.length-1\n   console.log(cur)\n   console.log(this.stack)\n   return cur;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  if(this.stack.length == 0)return;\n  console.log(this.stack)\n  for(let i=0;i<this.stack.length;i++){\n    if(i>=k) break;\n    this.stack[i] += val;\n  }\n};\n\n```\n\n### 复杂度\n- 时间复杂度\npush：O(1)\npop：O(1)\nincrement：O(min(k,stack.length))\n\n- 空间复杂度 O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ymwang-2020":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917647694","body":"## 思路\n判断栈空、栈满\n## 关键点\nk的处理\n## 代码\n\n - 语言支持\n\npython3\n\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n```\n\n## 复杂度分析\n\n令 n 为数组长度。\n\n - 时间复杂度：$O(k)$\n - 空间复杂度：$O(maxSize)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chanceyliu":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917651915","body":"### 思路\n\n按照官方题解\n\n### 代码\n\n```javascript\nvar CustomStack = function (maxSize) {\n  s = [];\n  t = 0;\n  n = maxSize;\n};\nCustomStack.prototype.push = function (x) {\n  if (t < n) s[++t] = x;\n  return s;\n};\nCustomStack.prototype.pop = function () {\n  if (t) return s[t--];\n  return -1;\n};\nCustomStack.prototype.increment = function (k, val) {\n  while (k) s[k--] += val;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：push,pop 为$O(1)$,increment 为$O(k)$\n- 空间复杂度：$O(1)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Craig-Cheng":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917654553","body":"### 用Javascript解题\nincrement 的时间复杂度 O(k)\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.stack = [];\n    this.size = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.stack.length < this.size) this.stack.push(x);\n    return this.stack;\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    if (this.stack.length === 0) return -1;\n    return this.stack.pop();\n};\n\n/**\n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    if (!this.stack.length) return;\n    const min = Math.min(k, this.stack.length);\n    for (let i = 0; i < min; i++) {\n        this.stack[i] += val;\n    }\n    return this.stack;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"GZ712D":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917657922","body":"零基础以及一点点编程（python）基础  \r\n呃，我题目没看懂，后面尽力加班加点，抓紧跟上课程  \r\n唉，低估了算法入门的难度  ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weichuliao":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917658127","body":"### Main Idea ###\r\nImplement stack with list\r\n\r\n### Code with Python ###\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n        return self\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) > 0:\r\n            res = self.stack[len(self.stack)-1]\r\n            self.stack.pop()\r\n            return res\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        length = min(len(self.stack), k)\r\n        for i in range(length):\r\n            self.stack[i] += val\r\n        return self\r\n```\r\n\r\n### Complexity Analysis ###\r\n- Time Complexity: \r\n  - Push: O(1)\r\n  - Pop: O(1)\r\n  - Increment: O( min(len(stack), K )\r\n- Space Complexity: O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Davont":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917666102","body":"## 思路\n利用栈,以前做过，还是对中括号的匹配，很经典一题\n## 代码\n```js\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    const numStack = [];\n    const strStack = [];\n    let repeatTimes = '';\n    for (let i = 0; i< s.length; i++) {\n      const char = s[i];\n      if(!Number.isNaN(+char)){\n          repeatTimes += char;\n          continue;\n      }\n      if(repeatTimes){\n        numStack.push(+repeatTimes);\n        repeatTimes = '';\n      }\n      if(char === ']'){\n          let repeatStr = '';\n          while(strStack.length && strStack.slice(-1)[0]!=='['){\n            let a = strStack.slice(-1);\n            repeatStr = strStack.pop() + repeatStr;\n          }\n          strStack.pop();\n          strStack.push(repeatStr.repeat(numStack.slice(-1)));\n          numStack.pop();\n      }else{\n          strStack.push(char);\n      }\n    }\n    return strStack.join('');\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"absent1353":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917731516","body":"### 思路：\n辅助栈的思路\n### 代码：\n```\ndef decodeString(self, s: str) -> str:\n        stack=[]\n        length = len(s)\n        i = length - 1\n        while i>=0:\n            if not s[i].isdigit():\n                stack.append(s[i])\n                i -= 1\n            else:\n                num = ''\n                while s[i].isdigit() and i>=0:\n                    num = s[i]+num\n                    i -= 1\n                sub = ''\n                while stack[-1]!=']':\n                    tmp = stack.pop()\n                    if tmp != '[':\n                        sub += tmp\n                stack.pop()\n                sub = int(num)*sub\n                stack.append(sub)\n        stack.reverse()\n        return ''.join(stack)\n```\n### 复杂度：\n时间复杂度 $O(N)$\n空间复杂度 $O(N)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"banjingking":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917733641","body":"### 思路\n***\nnumStack: 要repeated多少遍的数字  \nstrStack: 存a，当[a2[c]], a是不用repeat的  \ntail: 当前的string是什么  \n先loop每个char，判断char是digit，open bracket, close bracket, 遇到open bracket, 要将之前记录的string清空，push进去strStack, 遇到close bracket，就把numstack pop出来，乘上 tail\n\n***\n### 代码  \n\npublic String decodeString(String s) {\n\n        Deque<Integer> numStack = new ArrayDeque<>();\n        Deque<String> strStack = new ArrayDeque<>();\n        \n        StringBuilder tail = new StringBuilder();\n        int n = s.length();\n        for(int i = 0; i < n; i++){\n            char c = s.charAt(i);\n            // if is number\n            if(Character.isDigit(c)){\n                // maybe not only one digit\n                int num = c - '0';\n                // see if next is digit\n                while(i +1 <n && Character.isDigit(s.charAt(i+1))){\n                    num = num *10 + s.charAt(i+1) - '0';\n                    i++;\n                }\n                // put number into numStack\n                numStack.push(num);\n            }else if(c == '['){\n                //put string which before the open bracket to the stack\n                strStack.push(tail.toString());\n                tail = new StringBuilder();\n            }else if(c == ']'){\n                StringBuilder tmp = new StringBuilder(strStack.pop());\n                int repeatedTime = numStack.pop();\n                for(int j =0; j < repeatedTime; j++){\n                    tmp.append(tail);\n                }\n                \n                tail = tmp;\n            }else{\n                tail.append(c);\n            }\n        }\n        return tail.toString();\n        \n    }","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"now915":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917750281","body":"``` javaScript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = []\n    let multi = 0\n    let res = ''\n\n    for (const c of s) {\n        if (c == '[') {\n            stack.push([multi, res])\n            multi = 0\n            res = ''\n        } else if (c == ']') {\n            const last = stack.pop()\n            let tmp = ''\n            for (let i = 0; i < last[0]; i++) {\n                tmp += res\n            }\n            res = last[1] + tmp\n        } else if ('0' <= c && c <= '9') {\n            multi = multi * 10 + (c - 0)\n        } else {\n            res += c\n        }\n    }\n    return res\n}; \n```\n- 时间复杂度 O(n) \n- 空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"akxuan":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917782563","body":"这题看着容易， 但是实现好不容易。 \r\n### 思路\r\n首先弄两个 stack, 其中一个存数字， 另一个存string。 \r\n然后每次遇到 ']' 的时候就把string 中最后一个替换成 数字stack[-1]* str_stack[-1]. \r\n\r\n### 坑\r\n1. 首先就是需不需要用一个string 来存output。 如果用一个res 存output， 那就还要再判断一次 num_stack  是不是空的， 这个就蛋疼了。 \r\n2. 最后用 ''.join(stack) 返回非常好。 因为就算有空 string 也不影响\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s):\r\n        stack_num, stack_string =  [],[\"\"]\r\n        num = 0\r\n        res = ''\r\n        for c in s:\r\n            if  c.isdigit():\r\n                num = num*10 + int(c)\r\n            elif c =='[':\r\n                stack_string.append(\"\")\r\n                stack_num.append(num)\r\n                num = 0 \r\n            elif c == ']':\r\n                temp_str = stack_string.pop()\r\n                temp_rep = stack_num.pop()\r\n                last_str = stack_string.pop()\r\n                stack_string.append(last_str+ temp_rep*temp_str)\r\n            else:\r\n                stack_string[-1] += c\r\n        return \"\".join(stack_string)\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"doMoreCode":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917816032","body":"# 思路\n想法是使用栈来进行字符串的复制工作，但是我参考了leetcode的官方的思路，使用了两个栈，一个栈是用来存储数字，另一个用来存储字符串。\n* 如果是数字保存下来， 当然后一位也可能是数字， 因此不用压栈\n* 如果是字符的话，同样保存下来，不用压栈\n* 如果是' [ '，那么把上述两个变量清零，然后压栈\n* 如果是 ' ] ',这时候比较关键，因为这时候的字符串变量是有值的，这个值是括号里面的值。因此我们需要复制这个字符串变量的值k次，然后依次出栈。\n# C++代码\n``` c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<int> nums;\n        stack<string> strs;\n\n        string res = \"\";\n        int n = 0;\n        for (int i = 0; i < s.size(); i ++) {\n            if (s[i] >= '0' && s[i] <= '9') {\n                n = n * 10 + (s[i] - '0');\n            } else if (s[i] == '[') {\n                nums.push(n);\n                n = 0;\n                strs.push(res);\n                res = \"\";\n            } else if (s[i] >= 'a' && s[i] <= 'z' || s[i] >= 'A' && s[i] <= 'Z') {\n                res += s[i];\n            } else {\n                int time = nums.top();\n                nums.pop();\n                for (int j = 0; j < time; j ++) {\n                    strs.top() += res;\n                }\n\n                res = strs.top();\n                strs.pop();\n            }\n        }\n\n        return res;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}