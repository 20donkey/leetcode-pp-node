{"azl397985856":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/32#issuecomment-835293321","body":"2121212121"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840280816","body":"### 思路\r\n栈符号，读str然后写进stack里面，先找 ']' , 再回过来找 '[' \r\n有参考题解的思路\r\n\r\n### 代码 Python3\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for i in s:\r\n            if  i == ']':\r\n                les = ''\r\n                num = ''\r\n                while stack[-1].isalpha():\r\n                    les = stack.pop() + les\r\n                stack.pop()\r\n                while stack != [] and stack[-1].isnumeric():\r\n                    num = stack.pop() + num\r\n                stack.append(les * int(num))\r\n            else:\r\n                stack.append(i)\r\n        return \"\".join(stack)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"angusgenius":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835847052","body":"### 思路\r\n- 模拟数字加法，利用 `K` 保存进位，先将对应位置的数字相加，再进行取余操作保留结果。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc addToArrayForm(A []int, K int) (ans []int) {\r\n    for i := len(A) - 1; i >= 0 || K > 0; i-- {\r\n        if i >= 0 {\r\n            K += A[i]\r\n        }\r\n        ans = append(ans, K%10)\r\n        K /= 10\r\n    }\r\n    reverse(ans)\r\n    return\r\n}\r\n\r\nfunc reverse(A []int) {\r\n    for i, n := 0, len(A); i < n/2; i++ {\r\n        A[i], A[n-1-i] = A[n-1-i], A[i]\r\n    }\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(max(n, logk))，其中 n 为数组的长度。\r\n- 空间复杂度：O(1)，常数级别。"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-836995457","body":"### 思路\r\n- 双向遍历，对于每个字符 `S[i]`，找出向左或者向右下一个字符 `C` 的距离，这两个值的较小值即最短距离。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    n := len(s)\r\n    ans := make([]int, 0, n)\r\n    prev := math.MinInt32 / 2\r\n\r\n    for i := 0; i < n; i++ {\r\n        if s[i] == c {\r\n            prev = i\r\n        }\r\n        ans = append(ans, i - prev)\r\n    }\r\n\r\n    prev = math.MaxInt32 / 2\r\n    for i := n-1; i >= 0; i-- {\r\n        if s[i] == c {\r\n            prev = i\r\n        }\r\n        ans[i] = min(ans[i], prev - i)\r\n    }\r\n\r\n    return ans\r\n}\r\n\r\nfunc min(a, b int) int {\r\n    if a > b {\r\n        return b\r\n    }\r\n    return a\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N)，其中 `N` 是 S 的长度。\r\n- 空间复杂度：O(1)，常数级别。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-836995457","body":"### 思路\r\n- 双向遍历，对于每个字符 `S[i]`，找出向左或者向右下一个字符 `C` 的距离，这两个值的较小值即最短距离。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    n := len(s)\r\n    ans := make([]int, 0, n)\r\n    prev := math.MinInt32 / 2\r\n\r\n    for i := 0; i < n; i++ {\r\n        if s[i] == c {\r\n            prev = i\r\n        }\r\n        ans = append(ans, i - prev)\r\n    }\r\n\r\n    prev = math.MaxInt32 / 2\r\n    for i := n-1; i >= 0; i-- {\r\n        if s[i] == c {\r\n            prev = i\r\n        }\r\n        ans[i] = min(ans[i], prev - i)\r\n    }\r\n\r\n    return ans\r\n}\r\n\r\nfunc min(a, b int) int {\r\n    if a > b {\r\n        return b\r\n    }\r\n    return a\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N)，其中 `N` 是 S 的长度。\r\n- 空间复杂度：O(1)，常数级别。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840552068","body":"### 思路\r\n- 模拟栈\r\n    - 若当前的字符为数位，解析出一个数字并进栈。\r\n    - 若当前的字符为字母或者左括号，直接进栈.\r\n    - 若当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字，即该字符串出现的次数，据此构造出新的字符串并进栈。\r\n    - 重复如上操作，最终将栈中的元素按照从栈底到栈顶的顺序拼接起来。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc decodeString(s string) string {\r\n    stk := []string{}\r\n    ptr := 0\r\n    for ptr < len(s) {\r\n        cur := s[ptr]\r\n        if cur >= '0' && cur <= '9' {\r\n            digits := getDigits(s, &ptr)\r\n            stk = append(stk, digits)\r\n        } else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <= 'Z') || cur == '[' {\r\n            stk = append(stk, string(cur))\r\n            ptr++\r\n        } else {\r\n            ptr++\r\n            sub := []string{}\r\n            for stk[len(stk)-1] != \"[\" {\r\n                sub = append(sub, stk[len(stk)-1])\r\n                stk = stk[:len(stk)-1]\r\n            }\r\n            for i := 0; i < len(sub)/2; i++ {\r\n                sub[i], sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i]\r\n            }\r\n            stk = stk[:len(stk)-1]\r\n            repTime, _ := strconv.Atoi(stk[len(stk)-1])\r\n            stk = stk[:len(stk)-1]\r\n            t := strings.Repeat(getString(sub), repTime)\r\n            stk = append(stk, t)\r\n        }\r\n    }\r\n    return getString(stk)\r\n}\r\n\r\nfunc getDigits(s string, ptr *int) string {\r\n    ret := \"\"\r\n    for ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++ {\r\n        ret += string(s[*ptr])\r\n    }\r\n    return ret\r\n}\r\n\r\nfunc getString(v []string) string {\r\n    ret := \"\"\r\n    for _, s := range v {\r\n        ret += s\r\n    }\r\n    return ret\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass Solution {\r\n    int ptr;\r\n\r\n    public String decodeString(String s) {\r\n        LinkedList<String> stk = new LinkedList<String>();\r\n        ptr = 0;\r\n\r\n        while (ptr < s.length()) {\r\n            char cur = s.charAt(ptr);\r\n            if (Character.isDigit(cur)) {\r\n                String digits = getDigits(s);\r\n                stk.addLast(digits);\r\n            } else if (Character.isLetter(cur) || cur == '[') {\r\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \r\n            } else {\r\n                ++ptr;\r\n                LinkedList<String> sub = new LinkedList<String>();\r\n                while (!\"[\".equals(stk.peekLast())) {\r\n                    sub.addLast(stk.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                stk.removeLast();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = Integer.parseInt(stk.removeLast());\r\n                StringBuffer t = new StringBuffer();\r\n                String o = getString(sub);\r\n                while (repTime-- > 0) {\r\n                    t.append(o);\r\n                }\r\n                stk.addLast(t.toString());\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer ret = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            ret.append(s.charAt(ptr++));\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> v) {\r\n        StringBuffer ret = new StringBuffer();\r\n        for (String s : v) {\r\n            ret.append(s);\r\n        }\r\n        return ret.toString();\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N)，其中 N 为字符串的长度。\r\n- 空间复杂度：O(N)，其中 N 为字符串的长度。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"devil-lin":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835849107","body":"\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n\r\n        int n = num.size();\r\n        for(int i = n - 1; i >= 0 || k; i --)\r\n        {\r\n            if(i >= 0)\r\n                k += num[i];\r\n            res.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        reverse(res.begin(), res.end());\r\n\r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838552141","body":"\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n   vector<int> shortestToChar(string S, char C) {\r\n       vector<int> distance(S.size(), 0);\r\n       int prev = INT_MIN/2;\r\n       for(int i = 0; i < S.size(); i ++){\r\n           if(S[i] == C) prev = i;\r\n           distance[i] = i - prev;\r\n       }\r\n       prev = INT_MAX/2;\r\n       for(int i = S.size() - 1; i >= 0; i --){\r\n           if(S[i] == C) prev = i;\r\n           distance[i] = min(distance[i], prev - i);\r\n       }\r\n       return distance;\r\n   }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838552141","body":"\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n   vector<int> shortestToChar(string S, char C) {\r\n       vector<int> distance(S.size(), 0);\r\n       int prev = INT_MIN/2;\r\n       for(int i = 0; i < S.size(); i ++){\r\n           if(S[i] == C) prev = i;\r\n           distance[i] = i - prev;\r\n       }\r\n       prev = INT_MAX/2;\r\n       for(int i = S.size() - 1; i >= 0; i --){\r\n           if(S[i] == C) prev = i;\r\n           distance[i] = min(distance[i], prev - i);\r\n       }\r\n       return distance;\r\n   }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zliu1413":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835862900","body":"思路：add K to each digit of the num. \r\n语言：python\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        i = len(num)-1\r\n        while(i>=0 or k>0):\r\n            if i>=0:\r\n                k += num[i]\r\n            res.append(k%10)\r\n            k = k//10\r\n            i -= 1\r\n        return res[::-1]\r\n\r\n```\r\n\r\n复杂度：\r\n时间：O(max(n,logK)), logK is the how many times that K can be divided by 10 until residual is single digit\r\n空间：O(1）\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837327271","body":"解题思路：\r\n双向遍历。两次遍历的每个位置比较大小。\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        \r\n        \"\"\"\r\n        #first attemp\r\n        cLocs = []\r\n        for idx,elem in enumerate(s):\r\n            if elem == c: \r\n                cLocs.append(idx)\r\n        \r\n        res = []\r\n        for idx, elem in enumerate(s):\r\n            res.append(min(abs(mark - idx) for mark in cLocs))\r\n        \r\n        return res\r\n        \"\"\"\r\n        # second\r\n        ref = float(inf)\r\n        distanceList = []\r\n        for i,val in enumerate(s):\r\n            if val==c: ref = i\r\n            distanceList.append(abs(ref-i))\r\n        \r\n        ref = float(inf)\r\n        for i in range(len(s)-1,-1,-1):\r\n            val = s[i]\r\n            if val==c: ref = i\r\n            distanceList[i] = min(distanceList[i],abs(ref-i))\r\n        \r\n        return distanceList\r\n\r\n```\r\n复杂度：\r\n时间：O(n)\r\n空间：O(n)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837327271","body":"解题思路：\r\n双向遍历。两次遍历的每个位置比较大小。\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        \r\n        \"\"\"\r\n        #first attemp\r\n        cLocs = []\r\n        for idx,elem in enumerate(s):\r\n            if elem == c: \r\n                cLocs.append(idx)\r\n        \r\n        res = []\r\n        for idx, elem in enumerate(s):\r\n            res.append(min(abs(mark - idx) for mark in cLocs))\r\n        \r\n        return res\r\n        \"\"\"\r\n        # second\r\n        ref = float(inf)\r\n        distanceList = []\r\n        for i,val in enumerate(s):\r\n            if val==c: ref = i\r\n            distanceList.append(abs(ref-i))\r\n        \r\n        ref = float(inf)\r\n        for i in range(len(s)-1,-1,-1):\r\n            val = s[i]\r\n            if val==c: ref = i\r\n            distanceList[i] = min(distanceList[i],abs(ref-i))\r\n        \r\n        return distanceList\r\n\r\n```\r\n复杂度：\r\n时间：O(n)\r\n空间：O(n)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840126932","body":"思路：用栈存储乘数和中间结果，写的太笨了，之后再优化\r\n\r\n```Python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        answer = \"\"\r\n        stackElem = []\r\n        multifier = 0\r\n        for i,elem in enumerate(s):\r\n            if elem.isdigit():\r\n                multifier = 10*multifier+int(elem)\r\n            elif elem ==\"[\":\r\n                stackElem.append([multifier,\"\"])\r\n                multifier = 0\r\n            elif elem == \"]\":\r\n                multi,val = stackElem.pop()\r\n                if len(stackElem)!=0:\r\n                    stackElem[-1][1] += multi*val\r\n                else:\r\n                    answer += multi*val\r\n            else:\r\n                if len(stackElem) != 0:\r\n                    stackElem[-1][1] += elem\r\n                else:\r\n                    answer += elem\r\n        \r\n        return answer\r\n\r\n```\r\n复杂度：\r\n时间 O(N)\r\n空间 O(N）\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840705914","body":"思路：use two stacks to implement a queue. inStack will receive data, and outStack and push the data in reverse order.\r\n\r\n```Python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n    def in2out(self):\r\n        while (self.instack!=[]):\r\n            self.outstack.append(self.instack.pop())\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.instack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.outstack == []:\r\n            self.in2out()\r\n        return self.outstack.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.outstack == []:\r\n            self.in2out()\r\n        return self.outstack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return (self.outstack==[]) & (self.instack==[])\r\n\r\n```\r\n\r\n时间复杂度：O(1)\r\n空间复杂度：O(N)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joe-the-plumber":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835868625","body":"思路：using string to convert back and forth\r\n语言：python\r\n复杂度：\r\n时间：O(n)\r\n空间：O(n）\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        \r\n        number_int =  functools.reduce(lambda a,b : str(a)+str(b),num)\r\n        number_int = int(number_int) + k\r\n        \r\n        result_int_array = []\r\n        for i in str(number_int):\r\n            result_int_array.append(int(i))\r\n            \r\n        return result_int_array\r\n```\r\n\r\n            \r\n        "},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837583648","body":"同上： 先将所有目标字符位置找出，再遍历整个列表，计算与前后目标字符的距离绝对值，取值小的。\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        #1. find all currence of c\r\n        position_array = []        \r\n        for i, v in enumerate(s):\r\n            if v == c:\r\n                position_array.append(i)\r\n       \r\n        #duplicate the last element, we can access the right boundary more easily\r\n        position_array.append(position_array[-1])  \r\n                \r\n        #initilize the return value arrary\r\n        shortest_distance_array = [0 for _ in range(len(s))]\r\n        j1 = 0\r\n            \r\n        for i, v in enumerate(s):\r\n            shortest_distance_array[i] = min( abs( i-position_array[j1] )\r\n                                             , abs(i-position_array[j1+1] ) \r\n                                            )\r\n            #if the moving left_p(j1), right_p(j1+1) pair need to be updated    \r\n            if i==position_array[j1+1]:\r\n                # the right_p should not move out of boundary\r\n                if j1+1+1<len(position_array) :\r\n                    j1 += 1\r\n\r\n        return shortest_distance_array\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837583648","body":"同上： 先将所有目标字符位置找出，再遍历整个列表，计算与前后目标字符的距离绝对值，取值小的。\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        #1. find all currence of c\r\n        position_array = []        \r\n        for i, v in enumerate(s):\r\n            if v == c:\r\n                position_array.append(i)\r\n       \r\n        #duplicate the last element, we can access the right boundary more easily\r\n        position_array.append(position_array[-1])  \r\n                \r\n        #initilize the return value arrary\r\n        shortest_distance_array = [0 for _ in range(len(s))]\r\n        j1 = 0\r\n            \r\n        for i, v in enumerate(s):\r\n            shortest_distance_array[i] = min( abs( i-position_array[j1] )\r\n                                             , abs(i-position_array[j1+1] ) \r\n                                            )\r\n            #if the moving left_p(j1), right_p(j1+1) pair need to be updated    \r\n            if i==position_array[j1+1]:\r\n                # the right_p should not move out of boundary\r\n                if j1+1+1<len(position_array) :\r\n                    j1 += 1\r\n\r\n        return shortest_distance_array\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840315378","body":"参照答案，写了一遍\r\nhttps://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/medium/394.decode-string\r\n1）答案是在做inplace change。\r\n2）思路是每次遇到]，就处理了到 [, 减少了一个pair。。一直到最后\r\n\r\n复杂度\r\nTime: O(N) \r\nSpace: O(N)\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for char in s:\r\n            #need to decode at the ] , find out repeat string and count\r\n            if char == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n            \r\n                #regular char, notice we use while here\r\n                while stack and stack[-1] != '[':\r\n                        repeatStr = stack.pop() + repeatStr\r\n\r\n                #stack[-1] == '['\r\n                stack.pop()\r\n\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount\r\n\r\n                stack.append(repeatStr*int(repeatCount))\r\n                \r\n            else:\r\n                stack.append(char)\r\n    \r\n        return \"\".join(stack)\r\n\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Critsu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835891780","body":"思路：add K to each digit\r\n语言：java\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList<>();\r\n\r\n        for(int i=num.length-1; i>=0; i--){\r\n \r\n            int temp = num[i] + k;\r\n            int temp1 = temp%10;\r\n            ans.add(0, temp1);\r\n            k= temp/10;\r\n            \r\n        }\r\n\r\n        while(k>0){\r\n            ans.add(0, k%10);\r\n            k/=10;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837609304","body":"```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int prev = -1;\r\n        \r\n        for(int i=0; i<res.length; i++){\r\n            if(s.charAt(i) == c){\r\n                res[i] = 0;\r\n                prev = i;\r\n            }else if(prev>-1){\r\n                res[i] = i-prev;\r\n            }else {\r\n                res[i] = Integer.MAX_VALUE;\r\n            }\r\n        }\r\n        \r\n        prev=-1;\r\n        \r\n        for(int i=res.length-1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }else if(prev>-1){\r\n                res[i] = Math.min((prev-i), res[i]);\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837609304","body":"```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int prev = -1;\r\n        \r\n        for(int i=0; i<res.length; i++){\r\n            if(s.charAt(i) == c){\r\n                res[i] = 0;\r\n                prev = i;\r\n            }else if(prev>-1){\r\n                res[i] = i-prev;\r\n            }else {\r\n                res[i] = Integer.MAX_VALUE;\r\n            }\r\n        }\r\n        \r\n        prev=-1;\r\n        \r\n        for(int i=res.length-1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }else if(prev>-1){\r\n                res[i] = Math.min((prev-i), res[i]);\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840132950","body":"```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<Integer> numStack = new Stack<>();\r\n        Stack<String> strStack = new Stack<>();\r\n        StringBuilder res = new StringBuilder();\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            char b = s.charAt(i);\r\n            \r\n            if(Character.isDigit(b)){\r\n                int num = b - '0';\r\n                while( i+1<s.length() && Character.isDigit(s.charAt(i+1))){\r\n                    num = num * 10 + s.charAt(i+1) - '0';\r\n                    i++;\r\n                }\r\n                numStack.push(num);\r\n            }\r\n            else if(b == '['){\r\n                strStack.push(res.toString());\r\n                res = new StringBuilder();\r\n            }\r\n            else if(b==']'){\r\n                StringBuilder temp = new StringBuilder(strStack.pop());\r\n                int k = numStack.pop();\r\n                for(int j=0; j<k; j++){\r\n                    temp.append(res);\r\n                }\r\n                res = temp;\r\n            }\r\n            else{\r\n                res.append(b);\r\n            }\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835892157","body":"# Logic:\r\n```\r\nGo backward from the end of num (the least significant digit) \r\nwhile num still has unprocessed digits or k still has unprocessed digits:\r\n    get k's lowest digit \r\n    update k (k = 0 would be fine)\r\n    \r\n    # add up the current sum for the current digit\r\n    if (no digit to use in num): no need to add from num \r\n    else: add up the current sum for the current digit, decrement the index in num\r\n    \r\n    get carry\r\n    insert to the sum list\r\n    \r\nif (carry == 1): insert at sum list's head\r\n```\r\n# Caveats:\r\nStart from the least significant digit in num (go backward), consider carry, what if k's len is longer/shorter, use linkedlist.addFirst()\r\n\r\n[0]\r\n23\r\n\r\n# Complexity:\r\nTime: O(max(num.length, num of digits in k))\r\n\r\nSpace: O(max(num.length, num of digits in k)) if we consider the output list; otherwise O(1)\r\n\r\n# Code:\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> sum = new LinkedList<>();\r\n        int index = num.length - 1;\r\n        int carry = 0;\r\n        while (index >= 0 || k != 0) {\r\n            int curDigit = k % 10;\r\n            k = k / 10;\r\n            \r\n            if (index == -1) {\r\n               curDigit += carry; \r\n            } else {\r\n                curDigit += num[index--] + carry;\r\n            }\r\n            carry = curDigit / 10;\r\n            sum.addFirst(curDigit % 10);\r\n        }\r\n        if (carry == 1) {\r\n            sum.addFirst(1);\r\n        }\r\n        return sum;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838725255","body":"# Logic:\r\n```\r\ntraverse from the left to find matchPos (the closest match on the current index's left)\r\n- update for each index in s\r\n\r\ntraverse from the right (the closest match on the current index's right)\r\nno need to update the elements after the matchPos, because they have no match on the right\r\n- update for each index in s\r\n```\r\n\r\ns = \"loveleetcode\", c = \"e\"\r\nIt is guaranteed that c occurs at least once in s.\r\n\r\n\"aaba\"\r\n\"b\"\r\n\r\n# Complexity:\r\nTime: O(2n) -> O(n), n is the length of S\r\nSpace: O(1) - if we do not consider the output array\r\n\r\n# Code:\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] dist = new int[s.length()];\r\n        int matchPos = -s.length(); // the closest c position\r\n        // traverse from the left to find matchPos (the closest match on the current index's left)\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) {\r\n                matchPos = i;\r\n            }\r\n            dist[i] = i - matchPos;\r\n        }\r\n        // traverse from the right (the closest match on the current index's right)\r\n        // no need to update the elements after the matchPos, because they have no match on the right\r\n        for (int i = matchPos - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                matchPos = i;\r\n            }\r\n            dist[i] = Math.min(matchPos - i, dist[i]);\r\n        }\r\n        return dist;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838725255","body":"# Logic:\r\n```\r\ntraverse from the left to find matchPos (the closest match on the current index's left)\r\n- update for each index in s\r\n\r\ntraverse from the right (the closest match on the current index's right)\r\nno need to update the elements after the matchPos, because they have no match on the right\r\n- update for each index in s\r\n```\r\n\r\ns = \"loveleetcode\", c = \"e\"\r\nIt is guaranteed that c occurs at least once in s.\r\n\r\n\"aaba\"\r\n\"b\"\r\n\r\n# Complexity:\r\nTime: O(2n) -> O(n), n is the length of S\r\nSpace: O(1) - if we do not consider the output array\r\n\r\n# Code:\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] dist = new int[s.length()];\r\n        int matchPos = -s.length(); // the closest c position\r\n        // traverse from the left to find matchPos (the closest match on the current index's left)\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) {\r\n                matchPos = i;\r\n            }\r\n            dist[i] = i - matchPos;\r\n        }\r\n        // traverse from the right (the closest match on the current index's right)\r\n        // no need to update the elements after the matchPos, because they have no match on the right\r\n        for (int i = matchPos - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                matchPos = i;\r\n            }\r\n            dist[i] = Math.min(matchPos - i, dist[i]);\r\n        }\r\n        return dist;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840653980","body":"# Logic: \r\n\r\nUse two stacks:\r\n(freqStack) to store the integer (freqStack)\r\n(strStack) to store the previous stringbuilders (we append the current string which has been repeated for freqStack.pop() times to strStack.pop())\r\n\r\ncurrent string: use StringBuilder()\r\n```\r\ns contains 3 cases:\r\n1. a digit which comes before '['- make sure to make \"123\" -> 123\r\n\r\n2. [: \r\npush the number to freqStack, push current string to strStack\r\nreset the number, reset the current string\r\n\r\n3. ]: \r\nset temp = cur\r\ncur = strStack.pop()\r\nfreq = freqStack.pop()\r\ncur.append(temp) for freq times\r\n\r\n4. letter: append to the current string\r\n```\r\n# Complexity:\r\nTime: O(n), n is the length of decoded S\r\n\r\nSpace: O(n), n is the length of decoded S\r\n\r\nNote: \"1[a]\" is valid\r\n\r\n# Code:\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<StringBuilder> strStack = new Stack<>();\r\n        Stack<Integer> freqStack = new Stack<>();\r\n        \r\n        StringBuilder cur = new StringBuilder();\r\n        int num = 0;\r\n\r\n        // do not use while to get multi-digit num, e.g. \"321\"\r\n        for (char c : s.toCharArray()) {\r\n            if (Character.isDigit(c)) {\r\n                num = num * 10 + c - '0';\r\n            }\r\n            else if (c == '[') { // reach the end of number str\r\n                freqStack.push(num);\r\n                num = 0;\r\n                // \"abc3[cd]xyz\", deal with cur\r\n                strStack.push(cur);\r\n                cur = new StringBuilder();\r\n            } else if (c == ']') { // \"3[a2[c]]\"\r\n                StringBuilder temp = cur; //\"c\"\r\n                cur = strStack.pop();\r\n                int iter = freqStack.pop();\r\n                for (int i = 0; i < iter; i++) {\r\n                    cur.append(temp);\r\n                }                \r\n            } else { // see a letter\r\n                cur.append(c);\r\n            }\r\n            \r\n        }\r\n        return cur.toString();\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanjyumoso":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835903934","body":"### 思路\r\n\r\n1. Convert the array to string\r\n2. convert the string to integer for addition. \r\n3. Convert integer to array.\r\n\r\n### 代码\r\nPython\r\n\r\n\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        a = \"\"\r\n        for i in num:\r\n            a+=str(i)\r\n        x = int(a)+k\r\n        newList = [int(i) for i in str(x)]\r\n        return newList \r\n\r\n```\r\n\r\n**复杂度分析**\r\n- Time：O(n)\r\n- Space：O(n)"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840305939","body":"#### 思路\r\n* 两个栈， 一个存string repeat的次数， 一个存string。 遇到 ]  pop\r\n* code太丑了，脑子没了\r\n\r\n``` python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        times = []\r\n        time = \"\"\r\n        for n, i in enumerate(s):\r\n            current = ''\r\n            if i.isdigit():\r\n                time += i\r\n                if not s[n+1].isdigit():\r\n                    times.append(int(time))\r\n                    time = \"\"\r\n            else:\r\n                if i == ']':\r\n                    t = times.pop()\r\n                    v = stack.pop()\r\n                    for j in range(t):\r\n                        current += v\r\n                    stack.pop()\r\n                    if len(stack)>0 and stack[-1] != '[':\r\n                        stack[-1] += current\r\n                    else:\r\n                        stack.append(current)\r\n                elif i == '[':\r\n                    stack.append(i)\r\n                else:\r\n                    if len(stack) == 0:\r\n                        stack.append('[')\r\n                        stack.append(i)\r\n                        times.append(1)\r\n                    elif(stack[-1] != '['):\r\n                        stack[-1] += i\r\n                    else:\r\n                        stack.append(i)\r\n        return stack[-1]\r\n```\r\n#### 复杂度\r\nTime: O(N) N = len(s)\r\nSpace: O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lilyzhaoyilu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835920262","body":"## LC 989. Add to Array-Form of Integer\r\n\r\n### 思路\r\n\r\n循环处理 k 和 num  \r\n让 k 的每一位和 num 对应的 digit 相加  \r\n并且记录是否需要进位  \r\n需要注意一些特殊 case 的处理\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  let i = num.length - 1\r\n  let carry = false;\r\n\r\n  while(k > 0 || i >= 0){\r\n    let curDigit = k % 10\r\n    k = Math.floor(k / 10)\r\n\r\n    //此处注意可能有i <0 的情况，所以 || 0\r\n    //corner case: [0] 233\r\n    let newDigit = curDigit + (num[i]||0)\r\n\r\n    //如果需要进位\r\n    if(carry){\r\n      newDigit++\r\n      carry = false;\r\n    }\r\n\r\n    //判断是否需要进位\r\n    if(newDigit >=10){\r\n      carry = true;\r\n      newDigit = newDigit % 10\r\n    }\r\n\r\n    //同样需要处理 i< 0 的情况\r\n    i >= 0 ? num[i] = newDigit : num.unshift(newDigit)\r\n    i--\r\n  }\r\n\r\n  //最后看看是否需要进位\r\n  //corner case: [9,9] 1\r\n  if(carry) num.unshift(1)\r\n\r\n  return num;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(Math.max(M+N)) 两个长度中的最大值 其实就是 O(N) </br>\r\n空间复杂度：O(1) 只保存了常量\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-836997697","body":"## LC 821. Shortest Distance to a Character\r\n\r\n- Shortest Distance to a Character\r\n  - [遍历两次](#思路-遍历两次)\r\n  - [暴力](#思路-暴力)\r\n  - [双指针](#思路-双指针)\r\n  - [窗口](#思路-窗口)\r\n\r\n### 思路 遍历两次\r\n\r\n漾宝真棒！么么哒  \r\n遍历两次，一次从左到右，另一次反方向  \r\n遍历的时候分别记录从左到右和从右到左的该 s[i]对 c 的距离\r\n并且保留较小的那个\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar shortestToChar = function(s, c) {\r\n  //greedy\r\n  const res = new Array(s.length).fill(Infinity)\r\n\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] === c) res[i] = 0;\r\n    //处理一下i == 0 的情况，不然的话res[i -1] => NaN\r\n    else res[i] = i == 0 ? Infinity : res[i - 1] + 1\r\n  }\r\n\r\n\r\n  for(let i = s.length - 1; i >= 0; i--){\r\n    //res[i + 1] 是这个数组中右边的那一位\r\n    //如果res[i] == Infinity 就说明这个i的左边没有e\r\n    //或者 res[i + 1] + 1 < res[i]说明这个res[i]离右边的更近\r\n    if(res[i] == Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(1)\r\n\r\n### 思路 暴力\r\n\r\n暴力  \r\n先遍历数组，求出所有 c 的 index  \r\n然后再遍历数组，遇到跟 c 不同的时候，遍历 targetIndex 里的数组，求最小值\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  //brutal force\r\n  const res = [];\r\n  const targetIndex = [];\r\n  //iterate through s to get the indexs of c\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] == c) targetIndex.push(i)\r\n  }\r\n  //iterate through s to see wether a character is c\r\n  //if it is c, then the corresponding output should be 0\r\n  //if it is not c, then iterate through the targetIndex array\r\n  //    find the min of current char's index and all the target's index\r\n  //英文写真长啊下次还是打中文吧...\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] != c){\r\n      let temp = Infinity;\r\n      for(let t = 0; t < targetIndex.length; t++){\r\n          temp = Math.min(temp, Math.abs(i - targetIndex[t]))\r\n      }\r\n      res.push(temp)\r\n    }else{\r\n      res.push(0)\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：$O(N * M)$ M 是 c 的在 s 中的次数</br>\r\n空间复杂度：O(M) M 为 s 中 c 的个数\r\n\r\n### 思路 双指针\r\n\r\n双指针  \r\n在遍历 s 中遇到非 c 的时候，  \r\n派两个指针去寻找左边和右边的 c，并且计算最小值\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  //two pointers\r\n  const res = new Array(s.length).fill(Infinity)\r\n  for(let i = 0; i < s.length; i++){\r\n\r\n    if(s[i] == c){\r\n      res[i] = 0\r\n    }else{\r\n      let right = i + 1;\r\n      let left = i - 1\r\n\r\n      while(s[left] != c && left > 0){\r\n        left--\r\n      }\r\n\r\n      while(s[right] != c && right < s.length-1){\r\n        right++\r\n      }\r\n\r\n      //这里进行了边界处理，即处理了left/right越界的情况\r\n      //也处理了如果left/right 只是单纯的到边界停下了的情况\r\n      //比如s='love' 在s[i] = o i=1的时候，left就会是0\r\n      let leftSideC = s[left] != c  ? Infinity : i - left;\r\n      let rightSideC = s[right] != c ? Infinity : right - i\r\n      // console.log(i, s[i], left, leftSideC, right, rightSideC)\r\n      res[i] = Math.min(rightSideC, leftSideC)\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：$O(N^2)$ </br>\r\n空间复杂度：O(1) 只保存了常量\r\n\r\n### 思路 窗口\r\n\r\n\r\n我要请漾宝吃饭！   \r\n滑动的~？窗口  \r\n制造一个窗口，让他的左右两端分别为 c 或者 s 的边界  \r\n当为 s 的边界的时候，让窗口的值等于 Infinity  \r\n因为必然有 c，所以只要处理 i = 0 的时候就好了\r\n然后计算每个 s 到窗口两边的值，取最小\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar shortestToChar = function(s, c) {\r\n  //sliding window\r\n\r\n  let left = s[0] === c ? 0 : Infinity;\r\n  //从index = 1 的位置开始寻找c\r\n  let right = s.indexOf(c, 1);\r\n\r\n  const res = new Array(s.length);\r\n\r\n  for(let i = 0; i < s.length; i++){\r\n    res[i] = Math.min(Math.abs(i - left), Math.abs(i - right))\r\n    //变到下一个窗口\r\n    if(i === right){\r\n      left = right;\r\n      right = s.indexOf(c, left + 1)\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N · (NK)) 其中 n 是 s 的长度，indexof 的时间复杂度是 O(NK),其中 k 是每次找到的目标的长度 </br>\r\n空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-836997697","body":"## LC 821. Shortest Distance to a Character\r\n\r\n- Shortest Distance to a Character\r\n  - [遍历两次](#思路-遍历两次)\r\n  - [暴力](#思路-暴力)\r\n  - [双指针](#思路-双指针)\r\n  - [窗口](#思路-窗口)\r\n\r\n### 思路 遍历两次\r\n\r\n漾宝真棒！么么哒  \r\n遍历两次，一次从左到右，另一次反方向  \r\n遍历的时候分别记录从左到右和从右到左的该 s[i]对 c 的距离\r\n并且保留较小的那个\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar shortestToChar = function(s, c) {\r\n  //greedy\r\n  const res = new Array(s.length).fill(Infinity)\r\n\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] === c) res[i] = 0;\r\n    //处理一下i == 0 的情况，不然的话res[i -1] => NaN\r\n    else res[i] = i == 0 ? Infinity : res[i - 1] + 1\r\n  }\r\n\r\n\r\n  for(let i = s.length - 1; i >= 0; i--){\r\n    //res[i + 1] 是这个数组中右边的那一位\r\n    //如果res[i] == Infinity 就说明这个i的左边没有e\r\n    //或者 res[i + 1] + 1 < res[i]说明这个res[i]离右边的更近\r\n    if(res[i] == Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(1)\r\n\r\n### 思路 暴力\r\n\r\n暴力  \r\n先遍历数组，求出所有 c 的 index  \r\n然后再遍历数组，遇到跟 c 不同的时候，遍历 targetIndex 里的数组，求最小值\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  //brutal force\r\n  const res = [];\r\n  const targetIndex = [];\r\n  //iterate through s to get the indexs of c\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] == c) targetIndex.push(i)\r\n  }\r\n  //iterate through s to see wether a character is c\r\n  //if it is c, then the corresponding output should be 0\r\n  //if it is not c, then iterate through the targetIndex array\r\n  //    find the min of current char's index and all the target's index\r\n  //英文写真长啊下次还是打中文吧...\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] != c){\r\n      let temp = Infinity;\r\n      for(let t = 0; t < targetIndex.length; t++){\r\n          temp = Math.min(temp, Math.abs(i - targetIndex[t]))\r\n      }\r\n      res.push(temp)\r\n    }else{\r\n      res.push(0)\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：$O(N * M)$ M 是 c 的在 s 中的次数</br>\r\n空间复杂度：O(M) M 为 s 中 c 的个数\r\n\r\n### 思路 双指针\r\n\r\n双指针  \r\n在遍历 s 中遇到非 c 的时候，  \r\n派两个指针去寻找左边和右边的 c，并且计算最小值\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  //two pointers\r\n  const res = new Array(s.length).fill(Infinity)\r\n  for(let i = 0; i < s.length; i++){\r\n\r\n    if(s[i] == c){\r\n      res[i] = 0\r\n    }else{\r\n      let right = i + 1;\r\n      let left = i - 1\r\n\r\n      while(s[left] != c && left > 0){\r\n        left--\r\n      }\r\n\r\n      while(s[right] != c && right < s.length-1){\r\n        right++\r\n      }\r\n\r\n      //这里进行了边界处理，即处理了left/right越界的情况\r\n      //也处理了如果left/right 只是单纯的到边界停下了的情况\r\n      //比如s='love' 在s[i] = o i=1的时候，left就会是0\r\n      let leftSideC = s[left] != c  ? Infinity : i - left;\r\n      let rightSideC = s[right] != c ? Infinity : right - i\r\n      // console.log(i, s[i], left, leftSideC, right, rightSideC)\r\n      res[i] = Math.min(rightSideC, leftSideC)\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：$O(N^2)$ </br>\r\n空间复杂度：O(1) 只保存了常量\r\n\r\n### 思路 窗口\r\n\r\n\r\n我要请漾宝吃饭！   \r\n滑动的~？窗口  \r\n制造一个窗口，让他的左右两端分别为 c 或者 s 的边界  \r\n当为 s 的边界的时候，让窗口的值等于 Infinity  \r\n因为必然有 c，所以只要处理 i = 0 的时候就好了\r\n然后计算每个 s 到窗口两边的值，取最小\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar shortestToChar = function(s, c) {\r\n  //sliding window\r\n\r\n  let left = s[0] === c ? 0 : Infinity;\r\n  //从index = 1 的位置开始寻找c\r\n  let right = s.indexOf(c, 1);\r\n\r\n  const res = new Array(s.length);\r\n\r\n  for(let i = 0; i < s.length; i++){\r\n    res[i] = Math.min(Math.abs(i - left), Math.abs(i - right))\r\n    //变到下一个窗口\r\n    if(i === right){\r\n      left = right;\r\n      right = s.indexOf(c, left + 1)\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N · (NK)) 其中 n 是 s 的长度，indexof 的时间复杂度是 O(NK),其中 k 是每次找到的目标的长度 </br>\r\n空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840172489","body":"## LC 394. Decode String\r\n\r\n- [辅助栈](#思路-辅助栈)\r\n- [辅助栈 2](#思路-辅助栈2)\r\n\r\n### 思路 辅助栈\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  const stack = [];\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] != ']'){\r\n      stack.push(s[i])\r\n    }else if(s[i] == ']'){\r\n      let temp = ''\r\n      while(stack[stack.length - 1] != '['){\r\n        temp = stack.pop() + temp;\r\n      }\r\n      stack.pop() //这一步一定是'['\r\n\r\n      let num = ''\r\n      while(stack[stack.length - 1] >= '0' && stack[stack.length - 1] <= '9'){\r\n        num = stack.pop() + num\r\n      }\r\n\r\n      temp = temp.repeat(parseInt(num))\r\n      stack.push(temp)\r\n    }\r\n  }\r\n  return stack.join('');\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(N)\r\n\r\n### 思路 辅助栈 2\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  const numStack = [], strStack = []\r\n  let num = 0, res = ''\r\n\r\n  for(let char of s){\r\n    if(!isNaN(char)){ // !isNaN() 来判断是否是一个数字\r\n      num = num * 10 + Number(char) // Number(char)转换数字\r\n    }else if(char == '['){\r\n      strStack.push(res); //把之前存的string入栈，进入新的一层\r\n      res = '' //清空之前存的str\r\n      numStack.push(num) //把 [ 前面的 number入栈\r\n      num = 0 //清空 num\r\n    }else if(char == ']'){\r\n      //input: \"3[ab2[d]]\" 此时 ab    +  2 * d\r\n      //现在的res是[]里面的所有字符\r\n      res = strStack.pop() + res.repeat(numStack.pop())\r\n    }else{\r\n      res += char\r\n    }\r\n  }\r\n\r\n  return res\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(N)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Size-of":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835929595","body":"```javascript\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  const res = []\r\n  let i = num.length - 1\r\n  let carry = 0\r\n  while (i >= 0 || k > 0 || carry > 0) {\r\n    let cur = (num[i] || 0) + k % 10 + carry\r\n    res.push(cur % 10)\r\n    carry = cur / 10 | 0\r\n    i--\r\n    k = k / 10 | 0\r\n  }\r\n  return res.reverse()\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(max(n, logk))$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837506159","body":"## 代码\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const res = new Array(s.length).fill(Infinity)\r\n  for (let i = 0; i < s.length; i++) {\r\n    res[i] = s.substr(i, 1) === c ? 0 : (res[i - 1] != undefined ? res[i - 1] : Infinity) + 1\r\n  }\r\n\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    let prev = res[i + 1] !== undefined ? res[i + 1] : Infinity\r\n    res[i] = prev + 1 < res[i] ? prev + 1 : res[i]\r\n  }\r\n\r\n  return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$, N为s的长度\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837506159","body":"## 代码\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const res = new Array(s.length).fill(Infinity)\r\n  for (let i = 0; i < s.length; i++) {\r\n    res[i] = s.substr(i, 1) === c ? 0 : (res[i - 1] != undefined ? res[i - 1] : Infinity) + 1\r\n  }\r\n\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    let prev = res[i + 1] !== undefined ? res[i + 1] : Infinity\r\n    res[i] = prev + 1 < res[i] ? prev + 1 : res[i]\r\n  }\r\n\r\n  return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$, N为s的长度\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840563176","body":"\r\n\r\n\r\n\r\n## 代码\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  s = s.split('')\r\n  function dfs(sub, k) {\r\n    let str = ''\r\n    let num = 0\r\n    while (sub.length) {\r\n      let char = sub.shift()\r\n      if (/\\d/.test(char)) {\r\n        num = num * 10 + +char\r\n      } else if (char === '[') {\r\n        str += dfs(sub, num)\r\n        num = 0\r\n      } else if (char === ']') {\r\n        let _str = str\r\n        while (--k) {\r\n          str += _str\r\n        }\r\n        break\r\n      } else {\r\n        str += char\r\n      }\r\n    }\r\n    return str\r\n  }\r\n\r\n  return dfs(s, 0)\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Talent-Rain":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835930598","body":"\r\n## [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/bao-li-xiang-jia-by-jzsq_lyx-pon7/)\r\n\r\n### 分析\r\n1. 给定的 k 值是数字，不好按位来和数组中的值进行比对，而这里最后返回的是一个数组，所以先把数组 k 转成字符数组 -- kArr\r\n2. 根据数组长度，从地位到高位进行相加，用遍历 addOne 表示是否进位\r\n3. 每一次相加都需要判断是否超过 9, 超出时返回余数，并更新遍历 addOne\r\n4. 由于返回的 num，所以先用 ALen 遍历，遍历结束后，根据 KLen 的值判断是否还有 kArr 的值，同时还得注意次数 addOne 是否需要进位\r\n5. 时间复杂度：遍历 k 是 O(k) -- 其中 k 是 KLen，然后是遍历两个数组，所以最后 O(N),其中 N 是 Math.max(KLen,ALen)\r\n6. 空间复杂度: O(K)  -- 其中 k 是 KLen\r\n\r\n```javascript\r\n// 989. 数组形式的整数加法\r\n\r\n/**\r\n * @分析\r\n * 1. 由于最后返回的是数组形式，所以将 k 转成单个字符加到数组中比较合适\r\n * 2. 主要考察字符串切分字符，字符与数字相加转换问题\r\n */\r\n var addToArrayForm = function (num, k) {\r\n\r\n    let addOne = false // 进位\r\n    // 转成 number[]\r\n    const kArr = String(k).split('').map(str => Number(str))\r\n    let ALen = num.length, KLen = kArr.length \r\n    while (ALen--) {\r\n        let sum = num[ALen]\r\n        if (KLen) {\r\n            KLen--\r\n            sum += kArr[KLen]\r\n        }\r\n        if (addOne) {\r\n            sum++\r\n            addOne = false\r\n        }\r\n        if (sum >= 10) {\r\n            num[ALen] = sum % 10\r\n            addOne = true\r\n        } else {\r\n            num[ALen] = sum\r\n        }\r\n    }\r\n    while (KLen--) {\r\n        // 还有的值全部加到后面\r\n        let sum = kArr[KLen]\r\n        if (addOne) {\r\n            sum++\r\n            addOne = false\r\n        } \r\n        if (sum >= 10) {\r\n            num.unshift(sum % 10)\r\n            addOne = true\r\n        } else {\r\n            num.unshift(sum)\r\n        }\r\n    }\r\n    if (addOne) {\r\n        num.unshift(1)\r\n    }\r\n    return num\r\n};\r\n\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837524070","body":"[ 821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/bao-li-mei-ju-by-jzsq_lyx-ya8d/)\r\n### 直接暴力解法\r\n1. 将所有 c 的下标标记出来，用 temp 数组保存\r\n2. 遍历第二次的时候根据 temp 的值作为节点，计算对应的 abs 值\r\n3. 需要特别注意的是第一个节点和最后一个节点\r\n4. 时间复杂度：遍历了两次 s -- O(N) 其中 N 是 s 的长度\r\n5. 空间复杂度： 存储的是 c 出现的次数 -- O(C) -- 其中 C 的值为 [1,N]\r\n```javascript\r\n// 821. 字符的最短距离\r\n\r\n/**\r\n * @分析 -- 暴力解法\r\n */\r\n var shortestToChar = function (s, c) {\r\n    const len = s.length\r\n    //当结果为 c 的时候，就是 0，默认先全是 0\r\n    const ret = new Array(len).fill(0)\r\n    const temp = []\r\n    // 遍历第一次，找出所有 c 对应的 index\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) temp.push(i)\r\n    }\r\n\r\n    let index = 0\r\n    // 再遍历一次，完成所有值\r\n    for (let i = 0; i < temp.length; i++) {\r\n        const right = temp[i]\r\n        if (i === 0) {\r\n            while (index < right) {\r\n                ret[index] = right - index\r\n                index++\r\n            }\r\n        } else {\r\n            const left = temp[i - 1]\r\n            while (index > left && index < right) {\r\n                ret[index] = Math.min(right - index, index - left)\r\n                index++\r\n            }\r\n        }\r\n        // 因为相同的节点直接就是 0，所以直接跳过了\r\n        index++\r\n    }\r\n    // 走完了，如果index<len,做最后一次遍历\r\n    while (index < len) {\r\n        ret[index] = index - temp[temp.length - 1]\r\n        index++\r\n    }\r\n    return ret\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837524070","body":"[ 821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/bao-li-mei-ju-by-jzsq_lyx-ya8d/)\r\n### 直接暴力解法\r\n1. 将所有 c 的下标标记出来，用 temp 数组保存\r\n2. 遍历第二次的时候根据 temp 的值作为节点，计算对应的 abs 值\r\n3. 需要特别注意的是第一个节点和最后一个节点\r\n4. 时间复杂度：遍历了两次 s -- O(N) 其中 N 是 s 的长度\r\n5. 空间复杂度： 存储的是 c 出现的次数 -- O(C) -- 其中 C 的值为 [1,N]\r\n```javascript\r\n// 821. 字符的最短距离\r\n\r\n/**\r\n * @分析 -- 暴力解法\r\n */\r\n var shortestToChar = function (s, c) {\r\n    const len = s.length\r\n    //当结果为 c 的时候，就是 0，默认先全是 0\r\n    const ret = new Array(len).fill(0)\r\n    const temp = []\r\n    // 遍历第一次，找出所有 c 对应的 index\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) temp.push(i)\r\n    }\r\n\r\n    let index = 0\r\n    // 再遍历一次，完成所有值\r\n    for (let i = 0; i < temp.length; i++) {\r\n        const right = temp[i]\r\n        if (i === 0) {\r\n            while (index < right) {\r\n                ret[index] = right - index\r\n                index++\r\n            }\r\n        } else {\r\n            const left = temp[i - 1]\r\n            while (index > left && index < right) {\r\n                ret[index] = Math.min(right - index, index - left)\r\n                index++\r\n            }\r\n        }\r\n        // 因为相同的节点直接就是 0，所以直接跳过了\r\n        index++\r\n    }\r\n    // 走完了，如果index<len,做最后一次遍历\r\n    while (index < len) {\r\n        ret[index] = index - temp[temp.length - 1]\r\n        index++\r\n    }\r\n    return ret\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840183957","body":"## [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/solution/zhan-by-jzsq_lyx-u6lz/)\r\n### 分析\r\n1. 用栈保存临时值，每个 [ 都会入栈，所以栈中数字的值肯定和最后 ] 的值保持一致的；\r\n2. 具体规则如下：当 `遇到数字而临时字符串 temp 是非数字字符串时` 或者遇到 ‘[’ 的时候，栈加一个 temp\r\n3. 当遇到 ] 的时候，表示临时字符串结束，需要判断栈顶是否是数字字符串，如果不是，弹出加在 temp 前面，如果是，repeat 字符串\r\n4. 最后会得到一个全是非数字字符串的栈和最后一个 temp，累加栈中的值并最后加上 temp 便是最终结果\r\n```javascript\r\n// 394. 字符串解码\r\n\r\n/**\r\n * @分析\r\n * 1. 创建栈，保存数字和字符串\r\n * 2. 由题目可知：当 `遇到数字而临时字符串 temp 是非数字字符串时` 或者遇到 ‘[’ 的时候，栈加一个 temp\r\n * 3. 当遇到 ] 的时候，表示临时字符串结束，需要判断栈顶是否是数字字符串，如果不是，弹出加在 temp 前面，如果是，repeat 字符串\r\n */\r\n var decodeString = function (s) {\r\n    let stack =[]; // 当 [ 和 第一次出现数字的时候，存储\r\n    let temp = '' // 临时子串\r\n    for(let i = 0;i<s.length;i++){\r\n        const item = s[i]\r\n        if(item === '['){\r\n            stack.push(temp)\r\n            temp = ''\r\n        }else if (item === ']') {\r\n            // 要一直弹出数字位置\r\n            while(isNaN(stack[stack.length-1])){\r\n                temp = stack.pop()+temp\r\n            }\r\n            temp = temp.repeat(stack.pop())\r\n        }else if (!isNaN(item) && isNaN(temp) && temp !=='') {\r\n            //  item 是数字，temp 是非数字字符串，且 temp 不能为空\r\n            stack.push(temp)\r\n            temp = item\r\n        }  else {\r\n            // 普通字符或者普通数字\r\n            temp += item\r\n        }\r\n    }\r\n    let result = ''\r\n    while(stack.length){\r\n        result+=stack.shift()\r\n    }\r\n    return result+temp\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kofzhang":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835972664","body":"### 思路\r\n1.先转成整数\r\n2.相加\r\n3.再转成数组\r\n### 代码（Python3）\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        inta = 0\r\n        for i in A:\r\n            inta = inta*10 + i\r\n        inta = inta+K\r\n        res = []\r\n        for i in str(inta):\r\n            res.append(int(i))\r\n        return res\r\n        \r\n```\r\n### 复杂度\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837578403","body":"### 思路\r\n解法1：先将所有目标字符位置找出，再遍历整个列表，计算与前后目标字符的距离绝对值，取值小的。\r\n解法2：正反遍历，取小值\r\n### 代码（Python3）\r\n#### 解法1：\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = []\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                l.append(i)\r\n        k = 0\r\n        res = []\r\n        for i in range(len(s)):\r\n            if k!=len(l)-1 and abs(i-l[k])>abs(i-l[k+1]):\r\n                k += 1\r\n            res.append(abs(i-l[k]))\r\n        return res\r\n```\r\n#### 解法2：\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        t = len(s)\r\n        for i in s:\r\n            t=0 if i==c else t+1\r\n            res.append(t)\r\n        for idx,i in enumerate(s[::-1]):\r\n            t = 0 if i==c else t+1\r\n            res[-(idx+1)] = min(t,res[-(idx+1)])\r\n        return res\r\n        \r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837578403","body":"### 思路\r\n解法1：先将所有目标字符位置找出，再遍历整个列表，计算与前后目标字符的距离绝对值，取值小的。\r\n解法2：正反遍历，取小值\r\n### 代码（Python3）\r\n#### 解法1：\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = []\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                l.append(i)\r\n        k = 0\r\n        res = []\r\n        for i in range(len(s)):\r\n            if k!=len(l)-1 and abs(i-l[k])>abs(i-l[k+1]):\r\n                k += 1\r\n            res.append(abs(i-l[k]))\r\n        return res\r\n```\r\n#### 解法2：\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        t = len(s)\r\n        for i in s:\r\n            t=0 if i==c else t+1\r\n            res.append(t)\r\n        for idx,i in enumerate(s[::-1]):\r\n            t = 0 if i==c else t+1\r\n            res[-(idx+1)] = min(t,res[-(idx+1)])\r\n        return res\r\n        \r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840229636","body":"### 思路\r\n用栈存储，倒着遍历，设置一个标志，初始值为False。\r\n当遇到数字的时候，标志设置为True\r\n当标志为True并且是字符的时候，出栈存储到临时列表里，直到遇到\"]\"\r\n将临时列表里的字符转成字符串，再以\"[\"分割，前面的是数值，后面的是字符，进行运算，并将结果压栈\r\n持续处理，直到结束。\r\n小技巧，最后一个如果是数值的话，最后一部分是不处理的，所以在字符串前面加一个字符，最后再删除可以省很多代码。\r\n### 代码（Python3）\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack=[]\r\n        flag = False\r\n        for c in s[::-1]+\"/\":\r\n            \r\n            if c.isdigit():\r\n                flag = True\r\n            if not c.isdigit() and flag:    \r\n                flag = False            \r\n                temp = []\r\n                while True:\r\n                    t = stack.pop()\r\n                    if t!=\"]\":\r\n                        temp.append(t)\r\n                    else:\r\n                        break\r\n                temp = \"\".join(temp).split(\"[\")\r\n                stack.append(int(temp[0])*temp[1])\r\n            stack.append(c)\r\n        stack.pop()\r\n        return \"\".join(stack[::-1])\r\n\r\n        \r\n                    \r\n```\r\n### 复杂度\r\n- 时间复杂度：不会算O(n)?\r\n- 空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pkuphy":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835973571","body":"```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sum = int(''.join(map(str, num))) + k\r\n        sum = map(int, str(sum))\r\n        return sum\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838010994","body":"思路：单调栈\r\n\r\n代码：\r\n\r\n```py\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        pre = -1e4\r\n        length = len(S)\r\n        result = []\r\n\r\n        for i in range(length):\r\n            if S[i] == C: pre = i\r\n            result.append(i - pre)\r\n        pre = 20000\r\n        for i in range(length - 1, -1, -1):\r\n            if S[i] == C: pre = i\r\n            result[i] = min(result[i], pre - i)\r\n        return result\r\n```\r\n\r\n复杂度：\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838010994","body":"思路：单调栈\r\n\r\n代码：\r\n\r\n```py\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        pre = -1e4\r\n        length = len(S)\r\n        result = []\r\n\r\n        for i in range(length):\r\n            if S[i] == C: pre = i\r\n            result.append(i - pre)\r\n        pre = 20000\r\n        for i in range(length - 1, -1, -1):\r\n            if S[i] == C: pre = i\r\n            result[i] = min(result[i], pre - i)\r\n        return result\r\n```\r\n\r\n复杂度：\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840286758","body":"#### 思路\r\n按顺序处理字符串中的每一个字符。使用一个list模拟栈来处理。\r\n```\r\n如果是数字:\r\n    如果栈顶也是数字，将这两个字符合并为一个数字\r\n    否则将该数字压栈\r\n否则：\r\n    如果不是]字符，则将该字符压栈\r\n    否则:\r\n        往前找到匹配的[字符，将这部分拼接为一个字符串，乘以前面的数字后压栈\r\n合并栈中的所有字符串\r\n```\r\n\r\n#### 代码 Python\r\n```py\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n\r\n        for x in s:\r\n            if x.isnumeric():\r\n                if stack and stack[-1].isnumeric():\r\n                    stack.append(stack.pop() + x)\r\n                else:\r\n                    stack.append(x)\r\n            else:\r\n                if x != ']':\r\n                    stack.append(x)\r\n                else:\r\n                    temp = x\r\n                    while temp[0] != '[':\r\n                        temp = stack.pop() + temp\r\n                    stack.append(int(stack.pop()) * temp[1:-1])\r\n        return ''.join(stack)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tongxw":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835995408","body":"### 思路\r\n\r\nwhile num[i]存在 或者 k不为0:\r\n    当前位sum = 进位 + nums[i](如果存在) + k mod 10 (如果k不为0)；\r\n    倒序遍历num，同时k = k /10;\r\n    进位 carry = sum / 10;\r\n    当前位 digit = sum mod 10;\r\n    输出数组记录digit;\r\n如果最后一位有进位，添加到输出数组中;\r\n倒序返回输出数组；\r\n\r\n\r\n### 代码\r\n```java\r\n/*\r\n * @lc app=leetcode id=989 lang=java\r\n *\r\n * [989] Add to Array-Form of Integer\r\n */\r\n\r\n// @lc code=start\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int i = num.length - 1;\r\n        int carry = 0;\r\n        ArrayList<Integer> res = new ArrayList<>();\r\n        while (i>=0 || k != 0) {\r\n            int sum = carry;\r\n            if (i >= 0) {\r\n                sum += num[i];\r\n                i--;\r\n            }\r\n            if (k != 0) {\r\n                sum += k % 10;\r\n                k /= 10;\r\n            }\r\n\r\n            carry = sum / 10;\r\n            res.add(sum % 10);\r\n        }\r\n\r\n        if (carry > 0) {\r\n            res.add(carry);\r\n        }\r\n\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n// @lc code=end\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)，其中 N 为数组长度。\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837392702","body":"### 思路\r\n正序遍历字符串,\r\n    当c出现时，记录c的位置\r\n    当前字符与c的距离1 = c上次出现的位置 - 当前位置\r\n\r\n逆序遍历字符串，\r\n    当c出现时，记录c的位置\r\n    当前字符与c的距离2 = 当前位置 - c上次出现的位置 \r\n    同时，最短距离 = min(距离1， 距离2）\r\n\r\n### 代码\r\n\r\n```py\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n\r\n        c_pos = -10000 #s.length < 10^4\r\n        i = 0\r\n        for char in s:\r\n            if char == c:\r\n                c_pos = i\r\n            res.append(i - c_pos)\r\n            i = i + 1\r\n        \r\n        c_pos = 10000 #s.length < 10^4\r\n        i = i - 1\r\n        for char in s[::-1]:\r\n            if char == c:\r\n                c_pos = i;\r\n            res[i] = min(res[i], c_pos - i)\r\n            i = i - 1\r\n        \r\n        return res\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)，不考虑输出数组。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837392702","body":"### 思路\r\n正序遍历字符串,\r\n    当c出现时，记录c的位置\r\n    当前字符与c的距离1 = c上次出现的位置 - 当前位置\r\n\r\n逆序遍历字符串，\r\n    当c出现时，记录c的位置\r\n    当前字符与c的距离2 = 当前位置 - c上次出现的位置 \r\n    同时，最短距离 = min(距离1， 距离2）\r\n\r\n### 代码\r\n\r\n```py\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n\r\n        c_pos = -10000 #s.length < 10^4\r\n        i = 0\r\n        for char in s:\r\n            if char == c:\r\n                c_pos = i\r\n            res.append(i - c_pos)\r\n            i = i + 1\r\n        \r\n        c_pos = 10000 #s.length < 10^4\r\n        i = i - 1\r\n        for char in s[::-1]:\r\n            if char == c:\r\n                c_pos = i;\r\n            res[i] = min(res[i], c_pos - i)\r\n            i = i - 1\r\n        \r\n        return res\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)，不考虑输出数组。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840167926","body":"### 思路\r\n类似用栈判断括号匹配，每次括号匹配都是一次解析子串的过程。\r\nwhile 遍历字符串：\r\n1. 数字，记录到number中（不能立刻进栈因为数字可能不止一位）\r\n2. 字符，进栈\r\n3. 左侧括号，如果number不为空，进栈，然后number字符串清空；左侧括号也进栈。\r\n4. 右侧括号，栈顶元素依次出栈同时逆向组合到临时的字符串中，碰到左侧括号后，左侧括号的下一位就是重复的次数。之后把这次处理好的字符串压进栈。\r\n遍历结束后，栈里所有解析好的字串依次出栈，逆向组成结果。\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        char[] chars = s.toCharArray();\r\n        Stack<String> stack = new Stack<>();\r\n        String number = \"\";\r\n        \r\n        for (char c: chars) {\r\n            if (c >= '0' && c<= '9') {\r\n                number += c;\r\n            } else if (c == '[') {\r\n                if (!\"\".equals(number)) {\r\n                    stack.push(number);\r\n                    number = \"\";\r\n                }\r\n                stack.push(String.valueOf(c));\r\n            } else if (c == ']') {\r\n                // pop\r\n                String topStr;\r\n                StringBuffer buffer = new StringBuffer();\r\n                while (!\"[\".equals(topStr = stack.pop())) {\r\n                    buffer.insert(0, topStr);\r\n                }\r\n \r\n                String tmp = buffer.toString();\r\n                int repeat = Integer.parseInt(stack.pop()) - 1;\r\n                while (repeat != 0) {\r\n                    buffer.append(tmp);\r\n                    repeat--;\r\n                }\r\n                stack.push(buffer.toString());\r\n            } else {\r\n                // 'a' - 'z'\r\n                stack.push(String.valueOf(c));\r\n            }\r\n        }\r\n\r\n        StringBuffer res = new StringBuffer();\r\n        while (stack.size() != 0) {\r\n            res.insert(0, stack.pop());\r\n        }\r\n\r\n        // \"\"100[a]\"\"\r\n        // \"\"3[2[a]]\"\"\r\n        // \"\"30[22[a]]\"\"\r\n        // \"\"3[b3[a]]\"\"\r\n        return res.toString();\r\n    }\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： O(N), N为解析后字符串长度 。\r\n- 空间复杂度：O(N)，N为解析后字符串长度。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bolunzhang2021":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836052238","body":"哈？老哥你不会是发错了吧😂\n\nxmlb88 ***@***.***> 于 2021年5月9日周日 下午9:38写道：\n\n> vector<int> addToArrayForm(vector<int>& num, int k) {\n>     vector<int> res;\n>     for (int i = num.size() - 1; i >= 0; --i) {\n>         int sum = num[i] + (k % 10);\n>         k /= 10;\n>         if (sum / 10) ++k;\n>         res.push_back(sum % 10);\n>     }\n>\n>     while (k) {\n>         res.push_back(k % 10);\n>         k /= 10;\n>     }\n>\n>     reverse(res.begin(), res.end());\n>     return res;\n> }\n>\n> —\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836050621>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AT7X2IERQBJMNHNNMTESUQLTM42KPANCNFSM44PJ5S6A>\n> .\n>\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837866279","body":"代码：JAVA\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int N=s.length\r\n     for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n prev = Integer.MAX_VALUE / 2; //整型反转，防止越界\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n时间复杂度 O（n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837866279","body":"代码：JAVA\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int N=s.length\r\n     for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n prev = Integer.MAX_VALUE / 2; //整型反转，防止越界\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n时间复杂度 O（n）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xmlb88":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836051481","body":"c++:\r\n```c++\r\nvector<int> addToArrayForm(vector<int>& num, int k) {\r\n    vector<int> res;\r\n    for (int i = num.size() - 1; i >= 0; --i) {\r\n        int sum = num[i] + (k % 10);\r\n        k /= 10;\r\n        if (sum / 10) ++k;\r\n        res.push_back(sum % 10);\r\n    }\r\n\r\n    while (k) {\r\n        res.push_back(k % 10);\r\n        k /= 10;\r\n    }\r\n\r\n    reverse(res.begin(), res.end());\r\n    return res;\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837629554","body":"```c++\r\n// 暴力\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> idx;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) idx.push_back(i);\r\n    }\r\n\r\n    vector<int> res;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        int dis = INT_MAX;\r\n        for (int j = 0; j < idx.size(); ++j) {\r\n            dis = min(dis, abs(i - idx[j]));\r\n        }\r\n        res.push_back(dis);\r\n    }\r\n\r\n    return res;\r\n}\r\n```\r\n\r\n```c++\r\n// 2次遍历\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> res;\r\n    int last_idx = INT_MAX;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) last_idx = i;\r\n        res.push_back(abs(last_idx - i));\r\n    }\r\n\r\n    last_idx = INT_MAX;\r\n    for (int i = s.size() - 1; i >= 0; --i) {\r\n        if (s[i] == c) last_idx = i;\r\n        res[i] = min(res[i], abs(last_idx - i));\r\n    }\r\n    \r\n    return res;\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837629554","body":"```c++\r\n// 暴力\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> idx;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) idx.push_back(i);\r\n    }\r\n\r\n    vector<int> res;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        int dis = INT_MAX;\r\n        for (int j = 0; j < idx.size(); ++j) {\r\n            dis = min(dis, abs(i - idx[j]));\r\n        }\r\n        res.push_back(dis);\r\n    }\r\n\r\n    return res;\r\n}\r\n```\r\n\r\n```c++\r\n// 2次遍历\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> res;\r\n    int last_idx = INT_MAX;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) last_idx = i;\r\n        res.push_back(abs(last_idx - i));\r\n    }\r\n\r\n    last_idx = INT_MAX;\r\n    for (int i = s.size() - 1; i >= 0; --i) {\r\n        if (s[i] == c) last_idx = i;\r\n        res[i] = min(res[i], abs(last_idx - i));\r\n    }\r\n    \r\n    return res;\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840500709","body":"```c++\r\nstring decodeString(string s) {\r\n    stack<char> st_c;\r\n    stack<int> st_i;\r\n    \r\n    int num = 0;\r\n    for (char c : s) {\r\n        if (isdigit(c)) {\r\n            num = num * 10 + (c - '0');\r\n        } else {\r\n            if (c == '[') {\r\n                st_i.push(num);\r\n                num = 0;\r\n                st_c.push(c);\r\n            } else if (c == ']') {\r\n                string s;\r\n                while (st_c.top() != '[') {\r\n                    s.push_back(st_c.top());\r\n                    st_c.pop();\r\n                }\r\n                st_c.pop();\r\n                int count = st_i.top();\r\n                st_i.pop();\r\n                string s_repeat;\r\n                while (count--) {\r\n                    s_repeat += s;\r\n                }\r\n                while (!s_repeat.empty()) {\r\n                    st_c.push(s_repeat.back());\r\n                    s_repeat.pop_back();\r\n                }\r\n            } else {\r\n                st_c.push(c);\r\n            }\r\n        }\r\n    }\r\n\r\n    string res;\r\n    while (!st_c.empty()) {\r\n        res.push_back(st_c.top());\r\n        st_c.pop();\r\n    }\r\n    reverse(res.begin(), res.end());\r\n    return res;\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Saberfish":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836053127","body":"## 代码\r\n\r\nC++ :\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int i=num.size()-1;\r\n        while(k>0){\r\n            k=k+num[i];\r\n            num[i]=k%10;\r\n            k=k/10;\r\n            i--;\r\n            if(i<0 && k>0){\r\n                num.insert(num.begin(),0);\r\n                i=0;\r\n            }\r\n        }\r\n        return num;\r\n    }\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837693091","body":"### 思路\r\n\r\n\t先把所有目标字符的下标存到数组里面，再进行遍历查找每个字符的距离。\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int lenS=S.size();\r\n        vector<int> dest={};\r\n        for(int i=0;i<lenS;i++){\r\n            if(C==S[i]){\r\n                dest.insert(dest.end(),i);\r\n            }\r\n        }\r\n        int lenD=dest.size();\r\n        vector<int> output={};\r\n        for(int i=0;i<lenS;i++){\r\n            int a=i;\r\n            int distance=10000;\r\n            for(int j=0;j<lenD;j++){\r\n                int b=dest[j];\r\n                int dis=0;\r\n                if(a<b){\r\n                    dis=b-a;\r\n                }\r\n                else{\r\n                    dis=a-b;\r\n                }\r\n                if(dis<distance){\r\n                    distance=dis;\r\n                }\r\n            }\r\n            output.insert(output.end(),distance);\r\n        }\r\n        return output;\r\n    }\r\n};\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837693091","body":"### 思路\r\n\r\n\t先把所有目标字符的下标存到数组里面，再进行遍历查找每个字符的距离。\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int lenS=S.size();\r\n        vector<int> dest={};\r\n        for(int i=0;i<lenS;i++){\r\n            if(C==S[i]){\r\n                dest.insert(dest.end(),i);\r\n            }\r\n        }\r\n        int lenD=dest.size();\r\n        vector<int> output={};\r\n        for(int i=0;i<lenS;i++){\r\n            int a=i;\r\n            int distance=10000;\r\n            for(int j=0;j<lenD;j++){\r\n                int b=dest[j];\r\n                int dis=0;\r\n                if(a<b){\r\n                    dis=b-a;\r\n                }\r\n                else{\r\n                    dis=a-b;\r\n                }\r\n                if(dis<distance){\r\n                    distance=dis;\r\n                }\r\n            }\r\n            output.insert(output.end(),distance);\r\n        }\r\n        return output;\r\n    }\r\n};\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840637813","body":"维护两个栈，一个用来存数字，一个用来存字符串\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<int> k_stack;\r\n        stack<string> s_stack;\r\n        string curStr;\r\n        int length=s.length();\r\n        int temp=0;\r\n        for(int i=0;i<length;i++){\r\n            if(isdigit(s[i])){\r\n                //temp=temp*10+s[i]-'0';\r\n                do{\r\n                    temp=temp*10+s[i]-'0';\r\n                }while(isdigit(s[++i]));\r\n                --i;\r\n            }else if(isalpha(s[i])){\r\n                curStr+=s[i];\r\n            }else if(s[i]=='['){\r\n                k_stack.push(temp);\r\n                temp=0;\r\n                s_stack.push(curStr);\r\n                curStr.clear();\r\n            }else{//s[i]=']'\r\n                int times=k_stack.top();\r\n                k_stack.pop();\r\n                for(int j=0;j<times;j++){\r\n                    s_stack.top()+=curStr;\r\n                }\r\n                curStr=s_stack.top();\r\n                s_stack.pop();\r\n            }\r\n        }\r\n        return curStr;\r\n    }\r\n};\r\n```\r\n复杂度：\r\n时间 O(N)\r\n空间 O(N）\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiongyujie":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836058937","body":"语言：java\r\n时间复杂度：O(9n) => O(n) ,数组插入\r\n空间复杂度：除去输出结果,空间复杂度O(1)\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int out = 0 ;\r\n        int len = num.length;\r\n        int i = len - 1;\r\n        for(; i >= 0 && k > 0; i--){\r\n            int tmp =out + num[i] +  k % 10;\r\n            out = tmp / 10;\r\n            k = k / 10;\r\n            res.add(0, tmp % 10);\r\n        }\r\n        while(i >= 0){\r\n            int tmp = out + num[i];\r\n            out = tmp / 10;\r\n            res.add(0, tmp % 10);\r\n            i--;\r\n        }\r\n        while(k > 0){\r\n            int tmp = out + k % 10;\r\n            k = k / 10;\r\n            out = tmp / 10;\r\n            res.add(0, tmp % 10);\r\n        }\r\n        if(out > 0){\r\n            res.add(0, out);\r\n        }\r\n        return res ;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837711066","body":"思路：两次遍历，第一次记住字符c的下标，第二次计算与字符c的最近距离。\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        List<Integer> tmp = new ArrayList<>();\r\n        int index = 0 ;\r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i) == c){\r\n                tmp.add(i);\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < len; i++ ){\r\n            int cur =  tmp.get(index);\r\n            if(index < 1){\r\n                res[i] = Math.abs(i - cur);\r\n            }else{\r\n                res[i] = Math.min(Math.abs(i - cur), Math.abs(i - tmp.get(index - 1)));\r\n            }\r\n            if(i == tmp.get(index) && (index + 1) < tmp.size()){\r\n                index ++ ;\r\n            }\r\n        }\r\n        return res ;\r\n\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837711066","body":"思路：两次遍历，第一次记住字符c的下标，第二次计算与字符c的最近距离。\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        List<Integer> tmp = new ArrayList<>();\r\n        int index = 0 ;\r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i) == c){\r\n                tmp.add(i);\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < len; i++ ){\r\n            int cur =  tmp.get(index);\r\n            if(index < 1){\r\n                res[i] = Math.abs(i - cur);\r\n            }else{\r\n                res[i] = Math.min(Math.abs(i - cur), Math.abs(i - tmp.get(index - 1)));\r\n            }\r\n            if(i == tmp.get(index) && (index + 1) < tmp.size()){\r\n                index ++ ;\r\n            }\r\n        }\r\n        return res ;\r\n\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840350994","body":"麻瓜，做了半天\r\n```\r\nclass Solution {\r\n\r\n    public String decodeString(String s) {\r\n        Stack<Integer> sk1 = new Stack<>();\r\n        Stack<String> sk2 = new Stack<>();\r\n        int i = 0;\r\n        int len = s.length();\r\n        StringBuilder sb = new StringBuilder();\r\n        int num = 0;\r\n        while(i < len){\r\n            char ch =  s.charAt(i);    \r\n            i++;    \r\n            if(ch - '0' >= 0 && ch - '0' < 10){\r\n               num = num * 10 + (ch - '0');\r\n            }else if(ch == '['){\r\n                sk1.add(num);\r\n                num = 0;\r\n                while(ch - 'a' >= 0 && ch - 'a' < 26 && i < len){\r\n                    ch = s.charAt(i++);\r\n                    sb.append(ch);\r\n                }\r\n                sk2.add(sb.toString());\r\n                sb = new StringBuilder();\r\n            }else if(ch == ']'){\r\n                int num2 = sk1.pop();\r\n                String str = sk2.pop();\r\n                for(int j = 0; j < num2; j++){\r\n                    sb.append(str);\r\n                }\r\n                if(sk2.isEmpty()){\r\n                    sk2.add(sb.toString());\r\n                }else{\r\n                    sk2.add( sk2.pop() + sb.toString());\r\n                }\r\n                sb = new StringBuilder();\r\n            }else{\r\n                 if(sk2.isEmpty()){\r\n                    sk2.add(\"\" + ch);\r\n                }else{\r\n                    sk2.add(sk2.pop() + \"\" + ch);\r\n                }\r\n            }\r\n\r\n        }\r\n        return sk2.pop();\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Syan115":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836060783","body":"思路：\r\n1. 从低位起按位相加，注意进位问题\r\n2. list反转一下\r\n\r\n复杂度分析\r\n- 时间复杂度O(n)\r\n- 空间复杂度O(n)\r\n\r\n```class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n = num.length;\r\n        int sum = 0;\r\n        List<Integer> res = new ArrayList<>();\r\n        // 按位相加\r\n        for(int i=n-1; i>=0; i--){\r\n            sum = num[i] + k%10;\r\n            if(sum>=10){\r\n                sum = sum%10;\r\n                k = k+10;\r\n            }\r\n            res.add(sum);\r\n            k = k/10;          \r\n        }\r\n        while(k!=0){\r\n            res.add(k%10);\r\n            k = k/10;\r\n        }\r\n\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n} \r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837606516","body":"## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n\r\n## 思路\r\n分别从左向右和从右向左的遍历来获得当前位置字符与目标字符的距离，并取两者中较小的那一个。\r\n\r\n\r\n\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] dist = new int[length];\r\n        \r\n        // 从左遍历\r\n        int loc = 10000;\r\n        for(int i=0;i<length;i++){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.abs(i-loc);\r\n        }\r\n\r\n        // 从右遍历\r\n        for(int i=length-1;i>=0;i--){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.min(dist[i],Math.abs(i-loc));\r\n        }\r\n\r\n        return dist;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为字符串长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837606516","body":"## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n\r\n## 思路\r\n分别从左向右和从右向左的遍历来获得当前位置字符与目标字符的距离，并取两者中较小的那一个。\r\n\r\n\r\n\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] dist = new int[length];\r\n        \r\n        // 从左遍历\r\n        int loc = 10000;\r\n        for(int i=0;i<length;i++){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.abs(i-loc);\r\n        }\r\n\r\n        // 从右遍历\r\n        for(int i=length-1;i>=0;i--){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.min(dist[i],Math.abs(i-loc));\r\n        }\r\n\r\n        return dist;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为字符串长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840459584","body":"\r\n## 题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n\r\n```\r\n\r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n\r\n```\r\n\r\n\r\n## 思路\r\n- 题目主要是涉及到了括号嵌套的问题，先从内从括号展开，再展开外层，这一方式联想到使用栈来解决\r\n- 利用两个栈来分别存储信息，一个存储重复次数，一个存储内容\r\n\r\n\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        int times = 0; // 重复次数\r\n        StringBuilder res = new StringBuilder(); // 结果记录\r\n        Deque<Integer> numStack = new LinkedList<>();\r\n        Deque<StringBuilder> strStack = new LinkedList<>();\r\n\r\n        for(char c:s.toCharArray()){ \r\n            if(Character.isDigit(c)){ // 是数字的话记录重复次数（可能有多位数字\r\n                times = times*10 + c -'0';\r\n            }\r\n            else if(Character.isAlphabetic(c)){  // 是字母的话记录进res中\r\n                res.append(c);\r\n            }\r\n            else if(c == '['){ // 左括号的话把字母和次数都入栈\r\n                numStack.push(times);\r\n                strStack.push(res);\r\n                times = 0;\r\n                res = new StringBuilder(); //相当于把二者都清空\r\n            }else{ // 相当于c == ']'\r\n                int n = numStack.pop(); // 字符串要重复的次数\r\n                StringBuilder tmp = strStack.pop(); \r\n                for(int i=0;i<n;i++){\r\n                    tmp.append(res);\r\n                }\r\n                res = tmp;\r\n            } \r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为字符串长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"NorthSeacoder":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836063398","body":"## 思路\r\n利用 BigInt 计算\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n    \r\n    return (BigInt(num.join('')) + BigInt(k)).toString().split('')\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(1),没遍历数组....\r\n- 空间复杂度：O(n), 直接把数组转成 BigInt,不确定这里对不对...."},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838453454","body":"## 思路\r\n- 字符串拆成数组,并查询c 的所有下标\r\n- 遍历数组查询每个下标到 c 的最短距离\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n    const res=[],sIndexs=[];\r\n    \r\n    s.split('').forEach((char,index)=>{\r\n        if(char===c)sIndexs.push(index)\r\n    })\r\n    for(let i = 0;i<s.length;i++){\r\n        let tem = sIndexs.map(item=>Math.abs(i-item)).sort((a,b)=>a-b).shift();\r\n        res.push(tem)\r\n    }\r\n    return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n*m) m为字符 c 在 s 中的重复次数\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838453454","body":"## 思路\r\n- 字符串拆成数组,并查询c 的所有下标\r\n- 遍历数组查询每个下标到 c 的最短距离\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n    const res=[],sIndexs=[];\r\n    \r\n    s.split('').forEach((char,index)=>{\r\n        if(char===c)sIndexs.push(index)\r\n    })\r\n    for(let i = 0;i<s.length;i++){\r\n        let tem = sIndexs.map(item=>Math.abs(i-item)).sort((a,b)=>a-b).shift();\r\n        res.push(tem)\r\n    }\r\n    return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n*m) m为字符 c 在 s 中的重复次数\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840240878","body":"## 思路\r\n辅助栈\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s) {\r\n    let repeats = 0, res = ''; const strStack = [], numStack = [];\r\n    for (let str of s) {\r\n        if (!isNaN(str)) {//是数字\r\n            repeats = 10 * repeats + +str;\r\n        } else if (str === '[') {\r\n            //进入下一层\r\n            numStack.push(repeats);\r\n            repeats = 0;\r\n            strStack.push(res);\r\n            res = ''\r\n        } else if (str === ']') {\r\n            res = strStack.pop() + res.repeat(numStack.pop())\r\n        } else {\r\n            res += str\r\n        }\r\n    }\r\n        return res\r\n\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shizukanaskytree":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836063868","body":"\r\n## 题目地址(989. Add to Array-Form of Integer)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\nThe array-form of an integer num is an array representing its digits in left to right order.\r\n\r\nFor example, for num = 1321, the array form is [1,3,2,1].\r\n\r\nGiven num, the array-form of an integer, and an integer k, return the array-form of the integer num + k.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: num = [1,2,0,0], k = 34\r\nOutput: [1,2,3,4]\r\nExplanation: 1200 + 34 = 1234\r\n\r\n\r\nExample 2:\r\n\r\nInput: num = [2,7,4], k = 181\r\nOutput: [4,5,5]\r\nExplanation: 274 + 181 = 455\r\n\r\n\r\nExample 3:\r\n\r\nInput: num = [2,1,5], k = 806\r\nOutput: [1,0,2,1]\r\nExplanation: 215 + 806 = 1021\r\n\r\n\r\nExample 4:\r\n\r\nInput: num = [9,9,9,9,9,9,9,9,9,9], k = 1\r\nOutput: [1,0,0,0,0,0,0,0,0,0,0]\r\nExplanation: 9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\nConstraints:\r\n\r\n1 <= num.length <= 104\r\n0 <= num[i] <= 9\r\nnum does not contain any leading zeros except for the zero itself.\r\n1 <= k <= 104\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nfrom typing import List \r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_val = 0\r\n\r\n        for n in num:\r\n            num_val += n            \r\n            num_val = num_val * 10\r\n        num_val //= 10\r\n        \r\n        new_val = num_val + k\r\n        \r\n        if new_val == 0:\r\n            return [0]\r\n        \r\n        res = []\r\n        last_digit = 0\r\n            \r\n        while new_val != 0:\r\n            last_digit = new_val % 10\r\n            res.append(last_digit)    \r\n            new_val = new_val // 10\r\n\r\n        res.reverse()\r\n        return res\r\n\r\na = [0]\r\ns = Solution()\r\nres = s.addToArrayForm(a, k=0)\r\nprint(res)\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838260266","body":"\r\n## 题目地址(821. Shortest Distance to a Character)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\nGiven a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\r\n\r\nThe distance between two indices i and j is abs(i - j), where abs is the absolute value function.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"loveleetcode\", c = \"e\"\r\nOutput: [3,2,1,0,1,0,0,1,2,2,1,0]\r\nExplanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed).\r\nThe closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3.\r\nThe closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 3.\r\nFor index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.\r\nThe closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2.\r\n\r\n\r\nExample 2:\r\n\r\nInput: s = \"aaab\", c = \"b\"\r\nOutput: [3,2,1,0]\r\n\r\n\r\n \r\n\r\nConstraints:\r\n\r\n1 <= s.length <= 104\r\ns[i] and c are lowercase English letters.\r\nIt is guaranteed that c occurs at least once in s.\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n\"\"\"\r\nloveleetco d  e\r\n0123456789 10 11\r\n+++0100123 4  0\r\n3210100432 1  0\r\n3210100122 1  0\r\n\r\n 3 2 1 0 1 0 0 1 2 2 1 0\r\n[3,2,1,0,1,0,0,1,2,2,1,0]\r\n\r\n\"\"\"\r\n\r\n# 1.\r\n# https://stackoverflow.com/questions/6810036/whats-better-the-reverse-method-or-the-reversed-built-in-function#:~:text=reverse()%20actually%20reverses%20the,than%20actually%20reversing%20the%20elements.\r\n\r\n# 2.\r\n# https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode/\r\n\r\n# 3.\r\n# range(start, stop, step)\r\n# 左闭右开! []start, stop)\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        anchor = float('-inf')\r\n        # distance = left - righ\r\n        # distance = curr_val - anchor\r\n        # distance = postive_val - float('-inf')\r\n        dist = []\r\n        for i, l in enumerate(s):\r\n            if l == c:\r\n                dist[i] = prev\r\n            else:\r\n                dist[i] = i - prev\r\n        for i, l in enumerate(reversed(s)):\r\n            if l == c:\r\n                dist[i] = min(dist[i], )\r\n\r\n        \r\n\"\"\"\r\nclass Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n\r\n作者：LeetCode\r\n链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode/\r\n来源：力扣（LeetCode）\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n\"\"\"\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838260266","body":"\r\n## 题目地址(821. Shortest Distance to a Character)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\nGiven a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\r\n\r\nThe distance between two indices i and j is abs(i - j), where abs is the absolute value function.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"loveleetcode\", c = \"e\"\r\nOutput: [3,2,1,0,1,0,0,1,2,2,1,0]\r\nExplanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed).\r\nThe closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3.\r\nThe closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 3.\r\nFor index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.\r\nThe closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2.\r\n\r\n\r\nExample 2:\r\n\r\nInput: s = \"aaab\", c = \"b\"\r\nOutput: [3,2,1,0]\r\n\r\n\r\n \r\n\r\nConstraints:\r\n\r\n1 <= s.length <= 104\r\ns[i] and c are lowercase English letters.\r\nIt is guaranteed that c occurs at least once in s.\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n\"\"\"\r\nloveleetco d  e\r\n0123456789 10 11\r\n+++0100123 4  0\r\n3210100432 1  0\r\n3210100122 1  0\r\n\r\n 3 2 1 0 1 0 0 1 2 2 1 0\r\n[3,2,1,0,1,0,0,1,2,2,1,0]\r\n\r\n\"\"\"\r\n\r\n# 1.\r\n# https://stackoverflow.com/questions/6810036/whats-better-the-reverse-method-or-the-reversed-built-in-function#:~:text=reverse()%20actually%20reverses%20the,than%20actually%20reversing%20the%20elements.\r\n\r\n# 2.\r\n# https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode/\r\n\r\n# 3.\r\n# range(start, stop, step)\r\n# 左闭右开! []start, stop)\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        anchor = float('-inf')\r\n        # distance = left - righ\r\n        # distance = curr_val - anchor\r\n        # distance = postive_val - float('-inf')\r\n        dist = []\r\n        for i, l in enumerate(s):\r\n            if l == c:\r\n                dist[i] = prev\r\n            else:\r\n                dist[i] = i - prev\r\n        for i, l in enumerate(reversed(s)):\r\n            if l == c:\r\n                dist[i] = min(dist[i], )\r\n\r\n        \r\n\"\"\"\r\nclass Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n\r\n作者：LeetCode\r\n链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode/\r\n来源：力扣（LeetCode）\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n\"\"\"\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840417194","body":"\r\n## 题目地址(394. Decode String)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 题目描述\r\n\r\n```\r\nGiven an encoded string, return its decoded string.\r\n\r\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\r\n\r\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\r\n\r\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"3[a]2[bc]\"\r\nOutput: \"aaabcbc\"\r\n\r\n\r\nExample 2:\r\n\r\nInput: s = \"3[a2[c]]\"\r\nOutput: \"accaccacc\"\r\n\r\n\r\nExample 3:\r\n\r\nInput: s = \"2[abc]3[cd]ef\"\r\nOutput: \"abcabccdcdcdef\"\r\n\r\n\r\nExample 4:\r\n\r\nInput: s = \"abc3[cd]xyz\"\r\nOutput: \"abccdcdcdxyz\"\r\n\r\n\r\n \r\n\r\nConstraints:\r\n\r\n1 <= s.length <= 30\r\ns consists of lowercase English letters, digits, and square brackets '[]'.\r\ns is guaranteed to be a valid input.\r\nAll the integers in s are in the range [1, 300].\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/solution/java-di-gui-si-lu-qing-xi-dai-ma-yi-dong-t6mn/\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def onlyString(self, s):\r\n        index = 0\r\n        while index != len(s):\r\n            c = s[index]\r\n            if c == '[' or c == ']':\r\n                return False\r\n            index += 1\r\n        \r\n        return True\r\n\r\n    def decodeString(self, s: str) -> str:\r\n        if self.onlyString(s):\r\n            return s \r\n\r\n        i = 0\r\n        len_s = len(s)\r\n\r\n        res = ''\r\n\r\n        while i < len_s:\r\n            c = s[i]\r\n            if 'a' < c < 'z':\r\n                res += c\r\n                i += 1\r\n            else:\r\n                n = 0\r\n                left = i \r\n                right = i \r\n                while right < len_s and '0' <= s[right] <= '9':\r\n                    right += 1\r\n                \r\n                n = int(s[left:right+1])\r\n                left = right + 1\r\n                right += 1\r\n                leftP = 1\r\n                while leftP != 0:\r\n                    t = s[right]\r\n                    if t == '[':\r\n                        leftP += 1\r\n                    elif t == ']'\r\n                        leftP -= 1\r\n                    \r\n                    if leftP == 0:\r\n                        break\r\n                    right += 1\r\n                \r\n                smallFrac = decodeString(s[left + 1, right])\r\n                res += smallFrac*n\r\n                i = right + 1\r\n\r\n        return res \r\n\r\n    \r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：递归不知道\r\n- 空间复杂度：取决于问题吧, 如果 10000000[abc] \r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BeBraveBeCurious":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836072235","body":"``` Python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n\r\n        i, carry = len(num) - 1, 0\r\n        while i >= 0 or k != 0:\r\n            x = num[i] if i >= 0 else 0\r\n            y = k % 10 if k != 0 else 0\r\n\r\n            sum = x + y + carry\r\n            res.append(sum % 10)\r\n            carry = sum // 10\r\n\r\n            i -= 1\r\n            k //= 10\r\n\r\n        if carry != 0:\r\n            res.append(carry)\r\n            \r\n        return res[::-1]\r\n```\r\n**复杂度分析**\r\nn 为数组长度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838401294","body":"### 解题思路\r\n- 从左向右遍历, 记录 `i - prev`, `prev`为前一次`c`出现的下标\r\n- 从右向左遍历, 记录 `prev - i`, `prev`为靠右的`c`出现的下标\r\n\r\n### 代码\r\n\r\n```python3\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = []\r\n\r\n        for i, x in enumerate(s):\r\n            if x == c: prev = i \r\n            ans.append(i - prev)\r\n        \r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i \r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans \r\n```\r\n\r\n### 复杂度分析\r\n- **时间复杂度**：$O(n)$, 两次遍历`2n`化简为`n`\r\n- **空间复杂度**：$O(n)$, `n`为ans数组的长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838401294","body":"### 解题思路\r\n- 从左向右遍历, 记录 `i - prev`, `prev`为前一次`c`出现的下标\r\n- 从右向左遍历, 记录 `prev - i`, `prev`为靠右的`c`出现的下标\r\n\r\n### 代码\r\n\r\n```python3\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = []\r\n\r\n        for i, x in enumerate(s):\r\n            if x == c: prev = i \r\n            ans.append(i - prev)\r\n        \r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i \r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans \r\n```\r\n\r\n### 复杂度分析\r\n- **时间复杂度**：$O(n)$, 两次遍历`2n`化简为`n`\r\n- **空间复杂度**：$O(n)$, `n`为ans数组的长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840237710","body":"### 解题思路\r\n- 数字处理, `multi`初始化为0\r\n```python3\r\nmulti = 0\r\nif '0' <= c <= '9:\r\nmulti = multi * 10 + int(c)\r\n```\r\n- 左括号'['入栈'[multi, res]'\r\n```python3\r\nif c == '[':\r\n    stack.append([multi, res])\r\n    res, multi = '', 0\r\n```\r\n- 右括号`]`出栈\r\n```python3\r\nif c == ']':\r\n    cur_multi, last_res = stack.pop()\r\n    res = last_res + cur_multi * res \r\n```\r\n- 其余为数字的情况，将`c`添加至`res`\r\n``` python3\r\nelse:\r\n    res += c\r\n```\r\n\r\n### 代码\r\n\r\n```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], '', 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = '', 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res \r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)\r\n            else:\r\n                res += c\r\n        return res \r\n\r\n```\r\n[参考K神题解](https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/)\r\n\r\n![5.jpg](https://pic.leetcode-cn.com/1620871801-OsAwvq-5.jpg)\r\n**复杂度分析**\r\n- 时间复杂度: $O(n)$, 一次遍历s\r\n- 空间复杂度: $O(n)$, 极端情况下辅助栈需要线性空间，`2[3[4[a]]]`\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"watermelonDrip":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836072251","body":"## 思路\r\n- 转int 和 k 相加\r\n- 取余逐位加到res_list里\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n         \r\n        str_num = ''.join(str(x) for x in num)\r\n        tmp = int(str_num)\r\n        int_res = tmp + k\r\n        list_res = []\r\n        if int_res == 0:\r\n            return [0]\r\n        while int_res>0:\r\n            list_res.append(int_res%10)\r\n            int_res = int_res//10\r\n        return list_res[::-1]\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837668088","body":"## 思路\r\n\r\n- 模拟\r\n- 先统计s出现的位置，两个位置的距离是odd,递增序列+递减序列。如果是even，就去掉一个中间数。\r\n如果统计s 的位置不是最后一位，最后再加一个递减序列\r\n \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        list_c = list()\r\n        for i, item in enumerate(s):\r\n            if item == c:\r\n                list_c.append(i)\r\n     \r\n        left = 0\r\n        right = 0\r\n        \r\n      \r\n        res = list()\r\n         \r\n        while  right <  len(list_c):\r\n     \r\n            if left == right:\r\n                \r\n                for i in range(list_c[right],-1,-1):\r\n                    res.append(i)\r\n                right+=1\r\n            elif list_c[right] < len(s) and left < right:\r\n                tmp = list_c[right] - list_c[left]\r\n                distance = tmp //2\r\n                distance_num = tmp%2\r\n                for i in range( 1,distance+distance_num ):\r\n                    res.append(i)\r\n                for i in range(distance,-1,-1):\r\n                    res.append(i)\r\n                right+=1\r\n                left+=1\r\n             \r\n            else:\r\n                break\r\n        len_s = len(s)\r\n       \r\n        if list_c[-1] < len_s -1:\r\n            for i in range(1, len_s - list_c[-1] ):\r\n                res.append(i)\r\n            \r\n        return res \r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837668088","body":"## 思路\r\n\r\n- 模拟\r\n- 先统计s出现的位置，两个位置的距离是odd,递增序列+递减序列。如果是even，就去掉一个中间数。\r\n如果统计s 的位置不是最后一位，最后再加一个递减序列\r\n \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        list_c = list()\r\n        for i, item in enumerate(s):\r\n            if item == c:\r\n                list_c.append(i)\r\n     \r\n        left = 0\r\n        right = 0\r\n        \r\n      \r\n        res = list()\r\n         \r\n        while  right <  len(list_c):\r\n     \r\n            if left == right:\r\n                \r\n                for i in range(list_c[right],-1,-1):\r\n                    res.append(i)\r\n                right+=1\r\n            elif list_c[right] < len(s) and left < right:\r\n                tmp = list_c[right] - list_c[left]\r\n                distance = tmp //2\r\n                distance_num = tmp%2\r\n                for i in range( 1,distance+distance_num ):\r\n                    res.append(i)\r\n                for i in range(distance,-1,-1):\r\n                    res.append(i)\r\n                right+=1\r\n                left+=1\r\n             \r\n            else:\r\n                break\r\n        len_s = len(s)\r\n       \r\n        if list_c[-1] < len_s -1:\r\n            for i in range(1, len_s - list_c[-1] ):\r\n                res.append(i)\r\n            \r\n        return res \r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840366228","body":"## 思路\r\n \r\n-  辅助栈 \r\n-   这个题里好多的细节啊\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack =[]\r\n        res = ''\r\n        k = 0\r\n        for elem in s:\r\n            if '0' <=  elem  <= '9':\r\n                k  = k*10+ int(elem)\r\n            elif elem == '[':\r\n                stack.append([res, k])\r\n                res = ''\r\n                k =0\r\n \r\n            elif elem == ']':\r\n                tmp_str, tmp_k = stack.pop()\r\n                \r\n                res = tmp_str + res * tmp_k \r\n \r\n                \r\n            else:\r\n                res =  res + elem \r\n              \r\n        return res\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cecilia-vu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836079487","body":"### 思路\r\n\r\n从低位按位计算，注意处理最高位进位的情况\r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int add = 0;\r\n        for (int i = num.size() - 1; i>=0; i--) {\r\n            int digit = k % 10;\r\n            k = k / 10;\r\n            int tmp = num[i] + digit + add;\r\n            if (tmp > 9) {\r\n                res.push_back(tmp - 10);\r\n                add = 1;\r\n            } else {\r\n                res.push_back(tmp);\r\n                add = 0;\r\n            }\r\n        }\r\n        while (k > 0) {\r\n            int tmp = k % 10 + add;\r\n            if (tmp > 9) {\r\n                res.push_back(tmp - 10);\r\n                add = 1;\r\n            } else {\r\n                res.push_back(tmp);\r\n                add = 0;\r\n            }\r\n            k = k / 10;\r\n        }\r\n        if (add == 1) {\r\n            res.push_back(1);\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838562572","body":"### 思路\r\n\r\n正向和逆向分别遍历数组，计算和上一个目标字符的最短距离，保留两次遍历中较小的距离\r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.size();\r\n        vector<int> ans(n);\r\n        int prec = INT_MIN / 2;\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) {\r\n                ans[i] = 0;\r\n                prec = i;\r\n            } else {\r\n                ans[i] = i - prec;\r\n            }\r\n        }\r\n\r\n        prec = INT_MAX / 2;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s[i] == c) {\r\n                s[i] = 0;\r\n                prec = i;\r\n            } else {\r\n                ans[i] = min(ans[i], prec - i);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838562572","body":"### 思路\r\n\r\n正向和逆向分别遍历数组，计算和上一个目标字符的最短距离，保留两次遍历中较小的距离\r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.size();\r\n        vector<int> ans(n);\r\n        int prec = INT_MIN / 2;\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) {\r\n                ans[i] = 0;\r\n                prec = i;\r\n            } else {\r\n                ans[i] = i - prec;\r\n            }\r\n        }\r\n\r\n        prec = INT_MAX / 2;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s[i] == c) {\r\n                s[i] = 0;\r\n                prec = i;\r\n            } else {\r\n                ans[i] = min(ans[i], prec - i);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840266167","body":"### 思路\r\n\r\n用 vector 模拟栈操作，顺序遍历输入字符串，遇到 ']' 时进行 pop 操作，并将 ']'  和 '[' 之间的字符串复制所需次数后入栈  \r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n\r\n    vector<char> st;\r\n    int top = -1;\r\n\r\n    string decodeString(string s) {\r\n        for (auto c : s) {\r\n            if (c == ']') {\r\n                string tmp;\r\n                while (st[top] != '[') {\r\n                    if (isalpha(st[top])) {\r\n                        tmp += st[top];\r\n                    }   \r\n                    top--;   \r\n                }\r\n                top--;\r\n                reverse(tmp.begin(), tmp.end());\r\n                string cnt_tmp;\r\n                while (top > - 1 && isdigit(st[top])) {\r\n                    cnt_tmp += st[top];\r\n                    top--;\r\n                }\r\n                reverse(cnt_tmp.begin(), cnt_tmp.end());\r\n                int cnt = std::stoi(cnt_tmp);\r\n                string res_tmp;\r\n                for (int i=0; i<cnt; i++) {\r\n                    res_tmp.append(tmp);\r\n                }\r\n                for (auto c : res_tmp) {\r\n                    if (top + 1 < st.size()) {\r\n                        ++top;\r\n                        st[top] = c;\r\n                    } else {\r\n                        st.push_back(c);\r\n                        top++;\r\n                    }\r\n                }\r\n            } else {\r\n                    if (top + 1 < st.size()) {\r\n                        ++top;\r\n                        st[top] = c;\r\n                    } else {\r\n                        st.push_back(c);\r\n                        top++;\r\n                    }\r\n            }\r\n        }\r\n        string res;\r\n        int n = top + 1 < st.size() ? top + 1 : st.size();\r\n        for (int i=0; i<n; i++) {\r\n            res += st[i];\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Davont":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836079739","body":"### 思路\r\n1.先反转数组\r\n2.上下相加\r\n3.再反转成正常数组\r\n\r\n### 代码（JavaScript）\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  /**\r\n   * 大数相加，先将两个数反转\r\n   */\r\n  let numAStr = num.reverse();\r\n  let numBStr = k.toString().split('').reverse();\r\n  let temp = 0;\r\n  let result = [];\r\n  for (let i = 0; i < Math.max(numAStr.length, numBStr.length); i++) {\r\n    if (!numAStr[i]) {\r\n      numAStr[i] = 0;\r\n    }\r\n    if (!numBStr[i]) {\r\n      numBStr[i] = 0;\r\n    }\r\n    result[i] = numAStr[i] + +numBStr[i] + temp;\r\n    if (result[i] > 9) {\r\n      result[i] -= 10;\r\n      temp = 1;\r\n    } else{\r\n        temp = 0;\r\n    }\r\n  }\r\n  if (temp === 1) {\r\n    result.push(temp);\r\n  }\r\n  return result.reverse();\r\n};\r\n``` \r\n\r\n        \r\n### 复杂度\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838734919","body":"### 思路\r\n先存入index，然后比较每个index和遍历到数的最小距离，进行输出\r\n\r\n### 代码\r\n```js\r\nvar shortestToChar = function(S, C) {\r\n    let len = S.length;\r\n    let cArr = [];\r\n    let res = [];\r\n    for (let i = 0; i < len; i++) {\r\n        if (S[i] === C) {\r\n            cArr.push(i)\r\n        }\r\n    }\r\n    for (let i = 0; i < len; i++) {\r\n        let distance = Math.abs(i - cArr[0]);\r\n        for (let j = 0; j < cArr.length; j++) {\r\n            if (distance > Math.abs(i - cArr[j])) {\r\n                distance = Math.abs(i - cArr[j])\r\n            }\r\n        }\r\n        res.push(distance)\r\n    }\r\n    return res;\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838734919","body":"### 思路\r\n先存入index，然后比较每个index和遍历到数的最小距离，进行输出\r\n\r\n### 代码\r\n```js\r\nvar shortestToChar = function(S, C) {\r\n    let len = S.length;\r\n    let cArr = [];\r\n    let res = [];\r\n    for (let i = 0; i < len; i++) {\r\n        if (S[i] === C) {\r\n            cArr.push(i)\r\n        }\r\n    }\r\n    for (let i = 0; i < len; i++) {\r\n        let distance = Math.abs(i - cArr[0]);\r\n        for (let j = 0; j < cArr.length; j++) {\r\n            if (distance > Math.abs(i - cArr[j])) {\r\n                distance = Math.abs(i - cArr[j])\r\n            }\r\n        }\r\n        res.push(distance)\r\n    }\r\n    return res;\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LangqiZhao":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836081583","body":"### 思路\r\n\r\n把数组从末尾开始，和k进行加法运算，并通过进位更新需要加的数值。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        ans = list()\r\n\r\n        add_value = k\r\n        for idx in range(len(num)):\r\n            val = num[len(num) - 1 - idx] + add_value\r\n            add_value = val // 10\r\n            ans.append(val % 10)\r\n\r\n            if add_value == 0:\r\n                break\r\n\r\n        while add_value > 0:\r\n            ans.append(add_value % 10)\r\n            add_value = add_value // 10\r\n\r\n        ans = ans[::-1]\r\n\r\n        if idx < len(num) - 1:\r\n            ans = num[:len(num) - idx - 1] + ans\r\n        return ans\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837627118","body":"### 思路\r\n\r\n通过类似单调栈的方法，计算到C的距离。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = [0] * len(s)\r\n        stack = list()\r\n        sig = None\r\n\r\n        for idx in range(len(s)):\r\n            while stack and (s[stack[-1]] != c) and (s[idx] == c):\r\n                temp_index = stack.pop(-1)\r\n                if sig is None:\r\n                    ans[temp_index] = abs(idx - temp_index)\r\n                else:\r\n                    ans[temp_index] = min(abs(idx - temp_index), abs(sig - temp_index))\r\n            if s[idx] == c:\r\n                sig = idx\r\n            stack.append(idx)\r\n\r\n        while stack and s[stack[-1]] != c:\r\n            temp_index = stack.pop(-1)\r\n            ans[temp_index] = abs(temp_index - sig)\r\n        return ans\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837627118","body":"### 思路\r\n\r\n通过类似单调栈的方法，计算到C的距离。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = [0] * len(s)\r\n        stack = list()\r\n        sig = None\r\n\r\n        for idx in range(len(s)):\r\n            while stack and (s[stack[-1]] != c) and (s[idx] == c):\r\n                temp_index = stack.pop(-1)\r\n                if sig is None:\r\n                    ans[temp_index] = abs(idx - temp_index)\r\n                else:\r\n                    ans[temp_index] = min(abs(idx - temp_index), abs(sig - temp_index))\r\n            if s[idx] == c:\r\n                sig = idx\r\n            stack.append(idx)\r\n\r\n        while stack and s[stack[-1]] != c:\r\n            temp_index = stack.pop(-1)\r\n            ans[temp_index] = abs(temp_index - sig)\r\n        return ans\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840240046","body":"### 思路\r\n\r\n建立栈，判断是否是\"]\"，如果不是，入栈；如果是，字符串复制。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        num_list = [str(num) for num in range(10)]\r\n        stack_list = list()\r\n        for item in s:\r\n            if item != ']':\r\n                stack_list.append(item)\r\n                continue\r\n            repeat_string = ''\r\n            while stack_list and stack_list[-1] != '[':\r\n                cur_string = stack_list.pop(-1)\r\n                repeat_string = cur_string + repeat_string\r\n            if stack_list[-1] == '[':\r\n                stack_list = stack_list[:-1]\r\n            num_string = ''\r\n            while stack_list and stack_list[-1] in num_list:\r\n                cur_string = stack_list.pop(-1)\r\n                num_string = cur_string + num_string\r\n            if repeat_string and num_string:\r\n                stack_list.append(int(num_string) * repeat_string)\r\n        return ''.join(stack_list)\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taozi-taozi":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836083170","body":"### 思路：\r\n数组遍历\r\n### 代码：\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        re = 0\r\n        for i in num[:-1]:\r\n            re = (re + i) * 10\r\n        re = re + num[-1] + k\r\n        return [int(x) for x in str(re)]\r\n```\r\n### 复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837649030","body":"### 思路\r\n双指针.....😮\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        re = [0]*n\r\n        slow, fast = 0,0\r\n        pre = inf\r\n        while fast<n:\r\n            while s[fast] != c:\r\n                if fast == n-1:\r\n                    break\r\n                fast+=1\r\n            while slow<=fast:\r\n                if s[fast]!=c:\r\n                    re[slow] = abs(slow-pre)\r\n                else:\r\n                    re[slow] = min(abs(slow-pre),abs(slow-fast))\r\n                slow+=1\r\n            pre = fast\r\n            fast+=1\r\n        return re\r\n```\r\n### 复杂度分析😖\r\n时间复杂度：O(n)?\r\n空间复杂度：O(n)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837649030","body":"### 思路\r\n双指针.....😮\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        re = [0]*n\r\n        slow, fast = 0,0\r\n        pre = inf\r\n        while fast<n:\r\n            while s[fast] != c:\r\n                if fast == n-1:\r\n                    break\r\n                fast+=1\r\n            while slow<=fast:\r\n                if s[fast]!=c:\r\n                    re[slow] = abs(slow-pre)\r\n                else:\r\n                    re[slow] = min(abs(slow-pre),abs(slow-fast))\r\n                slow+=1\r\n            pre = fast\r\n            fast+=1\r\n        return re\r\n```\r\n### 复杂度分析😖\r\n时间复杂度：O(n)?\r\n空间复杂度：O(n)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840243834","body":"### 思路\r\n栈，括号匹配\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for i in range(len(s)):\r\n            if s[i] == ']':\r\n                zong = ''\r\n                re = stack.pop()\r\n                while re != '[':\r\n                    zong = zong + re[::-1]\r\n                    re = stack.pop()\r\n                shu = ''\r\n                re = stack.pop()\r\n                while re.isdigit():\r\n                    shu = shu + re\r\n                    if len(stack) == 0:\r\n                        break\r\n                    else:\r\n                        re = stack.pop()\r\n                if not re.isdigit():\r\n                    stack.append(re)\r\n                stack.append(zong[::-1]*int(shu[::-1]))\r\n            else:\r\n                stack.append(s[i])\r\n        return ''.join(stack)\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DIUDIU110":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836088010","body":"### 思路\r\n    模拟数字加法，利用 K 保存进位，先将对应位置的数字相加，再进行取余操作保留结果。\r\n### 程序 C++\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& a, int k) {\r\n        vector<int>res;\r\n        vector<int>b;\r\n        while(k)\r\n        {\r\n            b.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(b.begin(),b.end());\r\n        int fl=0;\r\n        int i,j;\r\n        for(i=a.size()-1,j=b.size()-1;i>=0&&j>=0;i--,j--)\r\n        {\r\n            int te=a[i]+b[j]+fl;\r\n            fl=te/10;\r\n            res.push_back(te%10);\r\n        }\r\n        while(i>=0)\r\n        {\r\n            int te=a[i]+fl;\r\n            fl=te/10;\r\n            res.push_back(te%10);\r\n            i--;\r\n        }\r\n        while(j>=0)\r\n        {\r\n            int te=b[j]+fl;\r\n            fl=te/10;\r\n            res.push_back(te%10);\r\n            j--;\r\n        }\r\n        if(fl)\r\n            res.push_back(fl);\r\n        reverse(res.begin(),res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n   时间: o(max(n,m)) \r\n   空间: o(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837967947","body":"### 算法思想：\r\n首先遍历一遍数组记录c的位置  为了处理方便 最好在最前面和最后面加上一个特殊位置\r\n再遍历一遍数组求解当前字符前后c位置差的最小值即可 注意最后一个区间里的遍历需要控制一下 不让其再变动区间\r\n### 代码：\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n=s.size();\r\n        int v1[10005];\r\n        int cnt=0;\r\n        v1[cnt++]=n+1;\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            if(s[i]==c)\r\n                v1[cnt++]=i;\r\n        }\r\n        v1[cnt++]=-n-1;\r\n        vector<int>res(n);\r\n        cnt=1;\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            if(i<=v1[cnt])\r\n                res[i]=min(abs(i-v1[cnt-1]),abs(i-v1[cnt]));\r\n\r\n            else\r\n            {\r\n                if(v1[cnt]!=-n-1)\r\n                    cnt++;\r\n                res[i]=min(abs(i-v1[cnt-1]),abs(i-v1[cnt]));\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间：o(n)\r\n空间：o(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837967947","body":"### 算法思想：\r\n首先遍历一遍数组记录c的位置  为了处理方便 最好在最前面和最后面加上一个特殊位置\r\n再遍历一遍数组求解当前字符前后c位置差的最小值即可 注意最后一个区间里的遍历需要控制一下 不让其再变动区间\r\n### 代码：\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n=s.size();\r\n        int v1[10005];\r\n        int cnt=0;\r\n        v1[cnt++]=n+1;\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            if(s[i]==c)\r\n                v1[cnt++]=i;\r\n        }\r\n        v1[cnt++]=-n-1;\r\n        vector<int>res(n);\r\n        cnt=1;\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            if(i<=v1[cnt])\r\n                res[i]=min(abs(i-v1[cnt-1]),abs(i-v1[cnt]));\r\n\r\n            else\r\n            {\r\n                if(v1[cnt]!=-n-1)\r\n                    cnt++;\r\n                res[i]=min(abs(i-v1[cnt-1]),abs(i-v1[cnt]));\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间：o(n)\r\n空间：o(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840373383","body":"### 解题思路\r\n#### 数字处理, multi初始化为0\r\nmulti = 0\r\nif '0' <= c <= '9:\r\nmulti = multi * 10 + int(c)\r\n#### 左括号'['入栈'[multi, res]'\r\nif c == '[':\r\n    stack.append([multi, res])\r\n    res, multi = '', 0\r\n#### 右括号]出栈\r\nif c == ']':\r\n    cur_multi, last_res = stack.pop()\r\n    res = last_res + cur_multi * res \r\n#### 其余为数字的情况，将c添加至res\r\nelse:\r\n    res += c\r\n### Code C++\r\n```\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<int>s1;\r\n        stack<string>s2;\r\n        string res=\"\";\r\n        int mul=0;\r\n        for(auto c:s)\r\n        {\r\n            if(c>='0'&&c<='9')//0-9之间 需要记录一下当前mul\r\n            {\r\n                mul=mul*10+c-'0';\r\n            }\r\n            else if(c=='[')\r\n            {\r\n                s1.push(mul);\r\n                s2.push(res);\r\n                res=\"\";\r\n                mul=0;\r\n            }\r\n            else if(c==']')\r\n            {\r\n                int cur_mul=s1.top();\r\n                s1.pop();\r\n                string last_res=s2.top();\r\n                s2.pop();\r\n                for(int i=0;i<cur_mul;i++)\r\n                {\r\n                    last_res+=res;\r\n                }\r\n                res=last_res;\r\n            }\r\n            else\r\n                res+=c;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：o(n)\r\n空间复杂度：o(n)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rfhklwt":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836091338","body":"## 思路\r\n* 模拟竖式加法，逐位相加，并记录`carry`位\r\n```伪代码\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n## 代码\r\n* Python3\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        n = len(num)\r\n        res = []\r\n        i, Sum, carry = n - 1, 0, 0\r\n        \r\n        while i >= 0 or k != 0:\r\n            x = num[i] if i >= 0 else 0\r\n            y = k % 10 if k != 0 else 1\r\n\r\n            Sum = x + y + carry\r\n            # 当前位\r\n            res.append(Sum % 10)\r\n            # 进位\r\n            carry = Sum // 10\r\n            i, k = i - 1, k // 10\r\n        \r\n        # 最后检查进位是否为１\r\n        if carry > 0:\r\n            res.append(carry)\r\n        \r\n        return res[::-1]\r\n```\r\n* Julia\r\n```julia\r\nfunction add_to_array_form(num::Vector{Int}, k::Int)::Vector{Int}\r\n    n = length(num)\r\n    i, val, carry = n, 0, 0\r\n    res = Int[]\r\n\r\n    while i > 0 || k != 0\r\n        x = i > 0 ? num[i] : 0\r\n        y = k != 0 ? k % 10 : 0\r\n\r\n        val = x + y + carry\r\n        append!(res, val % 10)\r\n        carry = val ÷ 10\r\n        i, k = i - 1, k ÷ 10\r\n    end\r\n\r\n    if carry > 0\r\n        append!(res, carry)\r\n    end\r\n\r\n    return reverse(res)\r\nend\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：`O(max(n,log k))`，其中`n`为数组的长度。\r\n\r\n* 空间复杂度：`O(1)`，不考虑返回数组。\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838237568","body":"## 思路\r\n1. 首先正向遍历一遍，求出往右找的最短距离；\r\n2. 接着反向遍历一遍，求出往左找的最短距离；\r\n3. 算出他们的最小值就是最短距离了。\r\n\r\n## 代码\r\n* Python3\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n, pos = len(s), float('-inf')\r\n        res = [n] * n\r\n        for i in list(range(n)) + list(range(n)[::-1]):\r\n            if s[i] == c:\r\n                pos = i\r\n            res[i] = min(res[i], abs(i - pos))\r\n        \r\n        return res\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：`O(n)`\r\n\r\n* 空间复杂度：`O(n)`"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838237568","body":"## 思路\r\n1. 首先正向遍历一遍，求出往右找的最短距离；\r\n2. 接着反向遍历一遍，求出往左找的最短距离；\r\n3. 算出他们的最小值就是最短距离了。\r\n\r\n## 代码\r\n* Python3\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n, pos = len(s), float('-inf')\r\n        res = [n] * n\r\n        for i in list(range(n)) + list(range(n)[::-1]):\r\n            if s[i] == c:\r\n                pos = i\r\n            res[i] = min(res[i], abs(i - pos))\r\n        \r\n        return res\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：`O(n)`\r\n\r\n* 空间复杂度：`O(n)`"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840249650","body":"## 思路\r\n当遇到`[`符号时，我们知道要将括号里面的字符串重复`k`遍，所以用一个**栈**来存放`(current_string, k)`，而当遇到`]`符号的时候就可以把里面的字符串重复`k`遍。\r\n\r\n## 代码\r\n* Python3\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        current_string = \"\"\r\n        k = 0\r\n\r\n        for char in s:\r\n            if char == '[':\r\n                stack.append((current_string, k))\r\n                current_string = \"\"\r\n                k = 0\r\n            elif char == ']':\r\n                last_string, last_k = stack.pop()\r\n                current_string = last_string + last_k * current_string\r\n            elif char.isdigit():\r\n                k = k * 10 + int(char)\r\n            else:\r\n                current_string += char\r\n        \r\n        return current_string\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：`O(S)`，其中`S`为解码后的字符串长度\r\n* 空间复杂度：`O(S)`，其中`S`为解码后的字符串长度"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HTian1997":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836091664","body":"思路：模拟加法\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = k\r\n        for i in range(len(num) - 1, -1, -1):\r\n            num[i] += carry\r\n            carry = num[i] // 10\r\n            num[i] %= 10\r\n        \r\n        while carry:\r\n            num.insert(0, carry % 10)\r\n            carry //= 10\r\n        \r\n        return num\r\n```\r\n\r\n复杂度：time O(N), space O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837649590","body":"思路：从左到右和从右到左遍历两边\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        ans = [float('inf') for i in range(n)]\r\n\r\n        pos = s.index(c)\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                pos = i\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(ans[i], abs(i - pos))\r\n        \r\n        pos = s.rindex(c)\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                pos = i\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(ans[i], abs(i - pos))\r\n        \r\n        return ans\r\n```\r\n\r\nComplexity: time O(N), space O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837649590","body":"思路：从左到右和从右到左遍历两边\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        ans = [float('inf') for i in range(n)]\r\n\r\n        pos = s.index(c)\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                pos = i\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(ans[i], abs(i - pos))\r\n        \r\n        pos = s.rindex(c)\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                pos = i\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(ans[i], abs(i - pos))\r\n        \r\n        return ans\r\n```\r\n\r\nComplexity: time O(N), space O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840200523","body":"思路：判断当前字符是否为\"]\"，如果不是就直接push进栈，是就开始一系列操作：不断弹出栈顶元素直到为\"[\"，翻转这部分然后再根据数字入栈。需要注意数字可能多位，需要累积。\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        ans = \"\"\r\n        stack = []\r\n\r\n        for char in s:\r\n            # pop up\r\n            if char == \"]\":\r\n                repeat = \"\"\r\n                while stack[-1] != \"[\":\r\n                    repeat += stack.pop(-1)\r\n                \r\n                # reverse the repeat\r\n                repeat = repeat[::-1]\r\n                stack.pop(-1)\r\n\r\n                number = \"\"\r\n                while stack and stack[-1].isnumeric():\r\n                    number += stack.pop(-1)\r\n                \r\n                number = int(number[::-1])\r\n                \r\n                for i in range(number):\r\n                    for elem in repeat: \r\n                        stack.append(elem)\r\n            \r\n            else:\r\n                stack.append(char)\r\n        \r\n        return \"\".join(stack)\r\n```\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"terrylijiayang":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836094791","body":"**思路**\r\n两个循环。第一个循环先统一到一个数组，第二个循环再做进位处理。\r\n**代码**\r\n```\r\nvar addToArrayForm = function (A, K) {\r\n    count = 0;\r\n    len = K.toString().length;\r\n    for (let i = 0; i < len; i++) {\r\n        if (A.length < len) {\r\n            A.unshift(0);\r\n        }\r\n        count = K % 10;\r\n        K = parseInt(K / 10);\r\n        A[A.length - 1 - i] += count;\r\n    }\r\n    for (let i = 0; i < A.length; i++) {\r\n        if (A[0] > 9) {\r\n            A.unshift(0);\r\n        }\r\n        if (A[A.length - 1 - i] > 9) {\r\n            A[A.length - 2 - i]++;\r\n            A[A.length - 1 - i] = A[A.length - 1 - i] % 10;\r\n        }\r\n    }\r\n    return A;\r\n};\r\n```\r\n**复杂度**\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838562657","body":"**思路**\r\n先用数组存储距离位置，再通过外循环找位置，再内循环找最小值。\r\n\r\n**代码**\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    let array = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        array[i] = s.length;\r\n    }\r\n    for (let i = 0; i < s.length; i++){\r\n        if ( s.substring(i, i+1) === c){\r\n            for (let j = 0; j < s.length; j++){\r\n                array[j] = Math.min(Math.abs(i - j),array[j])\r\n            }\r\n        }\r\n    }\r\n    return array;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n时间复杂度：O（n²）\r\n空间复杂度：O（n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838562657","body":"**思路**\r\n先用数组存储距离位置，再通过外循环找位置，再内循环找最小值。\r\n\r\n**代码**\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    let array = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        array[i] = s.length;\r\n    }\r\n    for (let i = 0; i < s.length; i++){\r\n        if ( s.substring(i, i+1) === c){\r\n            for (let j = 0; j < s.length; j++){\r\n                array[j] = Math.min(Math.abs(i - j),array[j])\r\n            }\r\n        }\r\n    }\r\n    return array;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n时间复杂度：O（n²）\r\n空间复杂度：O（n）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Xyxy1722":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836098804","body":"思路\r\n每次取num的最后一位和k运算并保存最后一位的结果\r\n\r\n代码\r\n语言支持：Python3\r\nPython3 Code:\r\n\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = len(num) - 1\r\n        result = []\r\n        while(i >= 0 or k != 0):\r\n            if i >= 0:\r\n                k = k + num[i]\r\n            result.insert(0, k % 10)\r\n            k = int(k / 10)\r\n            i = i - 1\r\n        return result\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837654968","body":"## 思路\r\ndis值只和最近的c的位置有关 从左向右遍历一遍再从右向左遍历一遍\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        c_loc = -10000\r\n        dis = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                c_loc = i\r\n            dis.append(abs(i - c_loc))\r\n        c_loc = 20000\r\n        while(i >= 0):\r\n            if s[i] == c:\r\n                c_loc = i\r\n            if dis[i] > abs(i - c_loc):\r\n                dis[i] = abs(i - c_loc)\r\n            i = i - 1\r\n        return dis\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837654968","body":"## 思路\r\ndis值只和最近的c的位置有关 从左向右遍历一遍再从右向左遍历一遍\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        c_loc = -10000\r\n        dis = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                c_loc = i\r\n            dis.append(abs(i - c_loc))\r\n        c_loc = 20000\r\n        while(i >= 0):\r\n            if s[i] == c:\r\n                c_loc = i\r\n            if dis[i] > abs(i - c_loc):\r\n                dis[i] = abs(i - c_loc)\r\n            i = i - 1\r\n        return dis\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eachless":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836098983","body":"\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n =  num.length;\r\n        int cur = k;\r\n        List<Integer> ans = new ArrayList();\r\n        \r\n        int i = n;\r\n        \r\n        while(--i >=0 || cur > 0){\r\n            if( i >= 0){\r\n                cur +=num[i];\r\n            }\r\n            \r\n            ans.add(cur % 10);\r\n            cur /= 10;\r\n        }\r\n        \r\n        \r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837305634","body":"\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] arr = new int[len];\r\n        int cpos = -len;\r\n        \r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i) == c){\r\n                cpos = i;\r\n            }\r\n            \r\n            arr[i] = i - cpos;\r\n        }\r\n        \r\n        for ( int i =len -1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                cpos=i;\r\n            }\r\n            arr[i] = Math.min(arr[i],Math.abs(i-cpos));\r\n        }\r\n        \r\n        return arr;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837305634","body":"\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] arr = new int[len];\r\n        int cpos = -len;\r\n        \r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i) == c){\r\n                cpos = i;\r\n            }\r\n            \r\n            arr[i] = i - cpos;\r\n        }\r\n        \r\n        for ( int i =len -1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                cpos=i;\r\n            }\r\n            arr[i] = Math.min(arr[i],Math.abs(i-cpos));\r\n        }\r\n        \r\n        return arr;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840083896","body":"class Solution {\r\n    public String decodeString(String s) {\r\n        int num = 0;\r\n        Stack <Object> stack = new Stack<>();\r\n        for(char c : s.toCharArray()){\r\n            //1 number\r\n            if(Character.isDigit(c)){\r\n                num = num * 10 + c - '0';\r\n            }else if( c == '['){\r\n                stack.push(Integer.valueOf(num));\r\n                num = 0;\r\n            }else if(c == ']'){\r\n                String newstr = dfs(stack);\r\n                Integer cnt = (Integer)stack.pop();\r\n                for(int i=0; i<cnt; i++){\r\n                    stack.push(newstr);\r\n                }\r\n            }else{//4. character\r\n                stack.push(String.valueOf(c));\r\n            }\r\n            //2 letter\r\n        }\r\n        return dfs(stack);\r\n    }\r\n    \r\n    private String dfs(Stack<Object> stack){\r\n        Stack<String> tmp = new Stack<>();\r\n        while(!stack.isEmpty()&& stack.peek() instanceof String){\r\n            tmp.push((String)stack.pop());\r\n        }\r\n        \r\n        StringBuilder sb = new StringBuilder();\r\n        while(!tmp.isEmpty()){\r\n            sb.append(tmp.pop());\r\n        }\r\n        return sb.toString();\r\n    }\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linearindep":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836108570","body":"【思路】记住加法进位数量，一级一级加\r\n\r\n【代码】java\r\n\r\n`        int ans = 0;\r\n        List<Integer> arr = new ArrayList<Integer>();\r\n        int i = num.length-1;\r\n       \r\n        while( k>0||i>=0){  \r\n            if(i>=0){\r\n                k = num[i]+k; \r\n            } \r\n                    \r\n            int temp = k%10;\r\n            k = k/10;\r\n            arr.add(temp);\r\n            i--;\r\n        }\r\n        Collections.reverse(arr);\r\n        return arr;\r\n    }`\r\n\r\n【复杂度】时间O(n),空间O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837697742","body":"【思路】先找出所有的index存起来，再从右往左比较每个数前后两个index的距离，如果碰到了这个数，就remove掉它的index。\r\n               这么做可以，但是太慢了。其实跟从左找一遍再从右找一遍思路差不多，而且后者会更快\r\n【复杂度】 时间O(N) 空间O(N)\r\n\r\n     `public int[] shortestToChar(String s, char c) {\r\n        ArrayList<Integer> index = new ArrayList<Integer>() ;\r\n        int[] ans = new int[s.length()] ;\r\n        int i = 0;\r\n        for(i =0;i<s.length();i++){\r\n            if(s.charAt(i)==c){\r\n                index.add(i);\r\n                ans[i]=0;\r\n            }\r\n        }\r\n        int lastIdx = 99999;\r\n        for(i = s.length()-1; i>=0 ;i--){\r\n            int dis = 0;\r\n            if(index.size()==0){\r\n                dis = Math.abs(lastIdx-i);\r\n                \r\n            }else{\r\n            int curr = index.get(index.size()-1);\r\n            dis =Math.min(Math.abs(curr-i),Math.abs(i-lastIdx));\r\n                if(i == curr){\r\n                    index.remove(index.size()-1);\r\n                    lastIdx = curr;\r\n                }\r\n            }\r\n            ans[i] = dis;\r\n            \r\n\r\n        }\r\n        \r\n        return ans;\r\n\r\n    }`"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837697742","body":"【思路】先找出所有的index存起来，再从右往左比较每个数前后两个index的距离，如果碰到了这个数，就remove掉它的index。\r\n               这么做可以，但是太慢了。其实跟从左找一遍再从右找一遍思路差不多，而且后者会更快\r\n【复杂度】 时间O(N) 空间O(N)\r\n\r\n     `public int[] shortestToChar(String s, char c) {\r\n        ArrayList<Integer> index = new ArrayList<Integer>() ;\r\n        int[] ans = new int[s.length()] ;\r\n        int i = 0;\r\n        for(i =0;i<s.length();i++){\r\n            if(s.charAt(i)==c){\r\n                index.add(i);\r\n                ans[i]=0;\r\n            }\r\n        }\r\n        int lastIdx = 99999;\r\n        for(i = s.length()-1; i>=0 ;i--){\r\n            int dis = 0;\r\n            if(index.size()==0){\r\n                dis = Math.abs(lastIdx-i);\r\n                \r\n            }else{\r\n            int curr = index.get(index.size()-1);\r\n            dis =Math.min(Math.abs(curr-i),Math.abs(i-lastIdx));\r\n                if(i == curr){\r\n                    index.remove(index.size()-1);\r\n                    lastIdx = curr;\r\n                }\r\n            }\r\n            ans[i] = dis;\r\n            \r\n\r\n        }\r\n        \r\n        return ans;\r\n\r\n    }`"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yeanli95":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836112944","body":"## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\nFirst Idea is to convert the array into Integer, then  sum up the array and k, then convert into desire result format.\r\n\r\nBut when array size gets larger, it is easy to get overflow when converting into integer.\r\n\r\nThen we need to go through the long way, adding bits from least significant to most significant, \r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```Java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> result = new ArrayList<>();\r\n\r\n        int carry = 0;\r\n        int numindex = num.length -1;\r\n        \r\n        while(numindex >=0 || k > 0 ){\r\n            int nums = numindex >=0 ? num[numindex] : 0;\r\n            int results = k > 0 ? k % 10 : 0;\r\n                                                      \r\n            int tempval = results + nums + carry;\r\n            int remainder = tempval % 10;\r\n            \r\n            carry = tempval / 10;\r\n            \r\n            result.add(0, remainder);\r\n            numindex--;\r\n            k /=10;\r\n        }\r\n        \r\n        if(carry > 0){\r\n            result.add(0, carry);\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837685280","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\nIterate the array from left to right, then from right to left to find optimal solution\r\n## 关键点\r\nInitialized Array to Integer.MAX_VALUE since we will be using Math.min function;\r\nWhen we first start iterating , assume the matching character will be on the other end.\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```Java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int [] result = new int[s.length()];\r\n        int cur = s.length() - 1;\r\n        Arrays.fill(result,Integer.MAX_VALUE);\r\n        for(int i =0; i < s.length(); i ++){\r\n            if(s.charAt(i) == c){\r\n                cur = i;\r\n            }\r\n            \r\n            result[i] = Math.min(result[i], Math.abs(cur - i));\r\n        }\r\n        \r\n        cur = 0;\r\n        for(int i =s.length() - 1; i >=0; i--){\r\n            if(s.charAt(i) == c){\r\n                cur = i;\r\n            }\r\n            result[i] = Math.min(result[i], Math.abs(cur - i));\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837685280","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\nIterate the array from left to right, then from right to left to find optimal solution\r\n## 关键点\r\nInitialized Array to Integer.MAX_VALUE since we will be using Math.min function;\r\nWhen we first start iterating , assume the matching character will be on the other end.\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```Java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int [] result = new int[s.length()];\r\n        int cur = s.length() - 1;\r\n        Arrays.fill(result,Integer.MAX_VALUE);\r\n        for(int i =0; i < s.length(); i ++){\r\n            if(s.charAt(i) == c){\r\n                cur = i;\r\n            }\r\n            \r\n            result[i] = Math.min(result[i], Math.abs(cur - i));\r\n        }\r\n        \r\n        cur = 0;\r\n        for(int i =s.length() - 1; i >=0; i--){\r\n            if(s.charAt(i) == c){\r\n                cur = i;\r\n            }\r\n            result[i] = Math.min(result[i], Math.abs(cur - i));\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840270723","body":" * - ## 394. Decode String\r\n\r\n     https://leetcode.com/problems/decode-string/\r\n\r\n      ## 题目描述\r\n\r\n      ```\r\n     Given an encoded string, return its decoded string.\r\n     \r\n     The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\r\n     \r\n     You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\r\n     \r\n     Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\r\n     \r\n      \r\n     \r\n     Example 1:\r\n     \r\n     Input: s = \"3[a]2[bc]\"\r\n     Output: \"aaabcbc\"\r\n     Example 2:\r\n     \r\n     Input: s = \"3[a2[c]]\"\r\n     Output: \"accaccacc\"\r\n     Example 3:\r\n     \r\n     Input: s = \"2[abc]3[cd]ef\"\r\n     Output: \"abcabccdcdcdef\"\r\n     Example 4:\r\n     \r\n     Input: s = \"abc3[cd]xyz\"\r\n     Output: \"abccdcdcdxyz\"\r\n      ```\r\n\r\n      ## 前置知识\r\n\r\n      - \r\n\r\n      ## 公司\r\n\r\n      - 暂无\r\n\r\n      ## 思路\r\n\r\n     没想明白。参考leetcode官方题解\r\n\r\n     使用两个Stack 一个存次数 一个存string \r\n\r\n     因为这个规律是不变的 所以如果看到[ ， 就知道这是新的开始 也是旧的结束 所以把数字跟string 都放进stack \r\n\r\n     如果看到 ]  就知道， string已经完结 可以看看有多少重复 都列入去\r\n\r\n      ## 关键点\r\n\r\n      \r\n\r\n      ## 代码\r\n\r\n      - 语言支持：Java\r\n\r\n      Java Code:\r\n\r\n      ```Java\r\n     class Solution {\r\n         public String decodeString(String s) {\r\n             Stack<Integer> number = new Stack<>();\r\n             Stack<StringBuilder> sb = new Stack<>();\r\n             int k = 0;\r\n             StringBuilder currentString = new StringBuilder();\r\n             for(char ch : s.toCharArray()){\r\n                 if(Character.isDigit(ch)){\r\n                     k = k* 10 + ch -'0';\r\n                 }\r\n                 else if(ch == '['){\r\n                     number.push(k);\r\n                     \r\n                     sb.push(currentString);\r\n                     \r\n                     currentString = new StringBuilder();\r\n                     \r\n                     k = 0;\r\n                 }\r\n                 else if( ch ==']'){\r\n                     StringBuilder temp = sb.pop();\r\n                     for(int i = number.pop(); i > 0; i --){\r\n                         temp.append(currentString);\r\n                     }\r\n                     \r\n                     currentString = temp;\r\n                 }\r\n                 else{\r\n                     currentString.append(ch);\r\n                 }\r\n             }\r\n             \r\n             return currentString.toString();\r\n         }\r\n     }\r\n      ```\r\n\r\n\r\n      **复杂度分析**\r\n    \r\n      令 n 为数组长度。\r\n    \r\n      - 时间复杂度：$O(maxK * n)$\r\n      - 空间复杂度：$O(m+n)$\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"minuet-red":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836115382","body":"### **题目地址(989. 数组形式的整数加法)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 数组转数字\r\n1. 数字相加\r\n2. 数字转数组\r\n```\r\n\r\n### **代码**\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        tmp = 0\r\n        for i in num:\r\n            tmp = tmp * 10 + i   # 数组转数字\r\n        tmp += k      # 加法运算\r\n        result = []\r\n        for j in str(tmp):    # 数字转数组\r\n            result.append(int(j))\r\n        \r\n        return result\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(n)\r\n1. 空间复杂度：O(n)\r\n```\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838285144","body":"### **题目地址(821. 字符的最短距离)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n- 字符串 S 的长度范围为 [1, 10000]。\r\n- C 是一个单字符，且保证是字符串 S 里的字符。\r\n- S 和 C 中的所有字母均为小写字母。\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 考察数组的遍历(正向遍历和反向遍历)\r\n我的思路\r\n1. 对于字符串s的每一个字符，如果该字符等于c，输出0，进行下一个循环\r\n2. 对于字符串s的每一个字符，如果该字符不等于c，往前往后分别查找c,\r\n\t- 一方找不到c，输出另一方距离\r\n\t- 都找得到c，记录两个距离\r\n3. 输出两个距离中的最小值\r\n```\r\n\r\n### **代码**\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        slength = len(s)\r\n        res = []\r\n        for i in range(slength):\r\n            if s[i] == c:\r\n                res.append(0)\r\n                continue\r\n            j = i\r\n            k = i\r\n            while(s[j] != c):\r\n                j -= 1\r\n                if j < 0:\r\n                    break  \r\n                \r\n            while(s[k] != c):\r\n                k += 1\r\n                if k >= slength:\r\n                    break\r\n                    \r\n            la = i-j    \r\n            lb = k-i    \r\n            if j < 0: \r\n                res.append(lb)\r\n            elif k >= slength:\r\n                res.append(la) \r\n            else:\r\n                res.append(min(la, lb))\r\n        return res\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(n·k)，n是字符串的长度，k是查找到字符c的长度\r\n1. 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838285144","body":"### **题目地址(821. 字符的最短距离)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n- 字符串 S 的长度范围为 [1, 10000]。\r\n- C 是一个单字符，且保证是字符串 S 里的字符。\r\n- S 和 C 中的所有字母均为小写字母。\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 考察数组的遍历(正向遍历和反向遍历)\r\n我的思路\r\n1. 对于字符串s的每一个字符，如果该字符等于c，输出0，进行下一个循环\r\n2. 对于字符串s的每一个字符，如果该字符不等于c，往前往后分别查找c,\r\n\t- 一方找不到c，输出另一方距离\r\n\t- 都找得到c，记录两个距离\r\n3. 输出两个距离中的最小值\r\n```\r\n\r\n### **代码**\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        slength = len(s)\r\n        res = []\r\n        for i in range(slength):\r\n            if s[i] == c:\r\n                res.append(0)\r\n                continue\r\n            j = i\r\n            k = i\r\n            while(s[j] != c):\r\n                j -= 1\r\n                if j < 0:\r\n                    break  \r\n                \r\n            while(s[k] != c):\r\n                k += 1\r\n                if k >= slength:\r\n                    break\r\n                    \r\n            la = i-j    \r\n            lb = k-i    \r\n            if j < 0: \r\n                res.append(lb)\r\n            elif k >= slength:\r\n                res.append(la) \r\n            else:\r\n                res.append(min(la, lb))\r\n        return res\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(n·k)，n是字符串的长度，k是查找到字符c的长度\r\n1. 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840394919","body":"### **题目地址(394. 字符串解码)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n示例 3：\r\n\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n示例 4：\r\n\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 考察栈、入栈、出栈、括号匹配显然是一种栈问题\r\n1. 遍历字符串：\r\n\t若不是']': 入栈\r\n\t若是']': 创建两个字符串分别记录括号内字符串和括号前数字\r\n\t\t\t若栈末尾不是'['就循环:出栈，记录出栈的字符\r\n\t\t\t弹出'[' 找出了匹配的'['并在栈中消除了该'[', 未干扰后面的']'\r\n\t\t\t若栈末尾是数字且栈不为空就循环:出栈，记录出栈的数字\r\n\t\t\t入栈:数×括号内字符串\r\n\t栈列表转字符串\r\n```\r\n\r\n### **代码**\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for i in s:\r\n            if i == ']':\r\n                saveStr = ''\r\n                saveNum = ''\r\n                while stack[-1] != '[':\r\n                    saveStr = stack.pop() + saveStr\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    saveNum = stack.pop() + saveNum \r\n                stack.append(int(saveNum) * saveStr)\r\n            else:\r\n                stack.append(i)\r\n        return \"\".join(stack)\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(n²)\r\n1. 空间复杂度：O(n)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LexieLiu01":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836117591","body":"`\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        carry = 0\r\n        for i in range(len(A) - 1, -1, -1):\r\n        A[i], carry = (carry + A[i] + K % 10) % 10, (carry + A[i] + K % 10) // 10\r\n        K //= 10\r\n        B = []\r\n        carry = carry + K\r\n        while carry:\r\n        B = [(carry) % 10] + B\r\n        carry //= 10\r\n    return B + A\r\n\r\n`"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838334269","body":"class Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        for i in range(len(s)):\r\n            l = r = i\r\n            \r\n            while l > -1:\r\n                if s[l] == c: break\r\n                l -= 1\r\n            while r < len(s):\r\n                if s[r] == c: break\r\n                r += 1\r\n            \r\n            if l == -1:\r\n                l = -10000\r\n            if r == len(s):\r\n                r = 20000\r\n            ans.append(min(r-i,i-l))\r\n            \r\n        return ans"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838334269","body":"class Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        for i in range(len(s)):\r\n            l = r = i\r\n            \r\n            while l > -1:\r\n                if s[l] == c: break\r\n                l -= 1\r\n            while r < len(s):\r\n                if s[r] == c: break\r\n                r += 1\r\n            \r\n            if l == -1:\r\n                l = -10000\r\n            if r == len(s):\r\n                r = 20000\r\n            ans.append(min(r-i,i-l))\r\n            \r\n        return ans"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HackBL":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836118591","body":"* 思路：Array从后往前遍历，每遍历一次，加上k，取总和的个位数，存入到list中。k /= 10，为下一个元素做准备。 遍历整个数组，如果k还存在数字（即 != 0)，继续遍历k，一一存入到list中\r\n* 误区：最开始使用int，把数组和k的数字相加在一起，导致integer overflow\r\n* 语言：Java\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new LinkedList<>();\r\n        \r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            k += num[i];\r\n            list.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        while (k != 0) {\r\n            list.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n        return list;\r\n    }\r\n}\r\n```\r\n* 时间：O(n), n: max(nums.length, k的长度)\r\n* Space: O(n), n: max(nums.length, k的长度)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837785007","body":"* 思路：先正序，再倒序\r\n正序：所有在s中的元素（除了c元素），以其左边的c为参照物，求出距离，并存在answer中。若元素的左边没有参照物c，则存入string.length()与当前index的差值。\r\n倒序：所有在s中的元素（除了c元素），以其右边的c为参照物，求出最小距离（min(answer[o], pos-1)），并存在answer中。\r\n若当前元素为c，answer当前index的元素为0\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int pos = -n;\r\n        int[] answer = new int[n];\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) pos = i;\r\n            answer[i] = i - pos;\r\n        }\r\n        \r\n        for (int i = pos; i >= 0; i--) {\r\n            if (s.charAt(i) == c) pos = i;\r\n            answer[i] = Math.min(answer[i], pos - i);\r\n        }\r\n        \r\n        return answer;\r\n    }\r\n}\r\n```\r\n* 时间：O(n)， n为s的长度\r\n* 空间：O(n)， 建立新数组answer，长度为n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837785007","body":"* 思路：先正序，再倒序\r\n正序：所有在s中的元素（除了c元素），以其左边的c为参照物，求出距离，并存在answer中。若元素的左边没有参照物c，则存入string.length()与当前index的差值。\r\n倒序：所有在s中的元素（除了c元素），以其右边的c为参照物，求出最小距离（min(answer[o], pos-1)），并存在answer中。\r\n若当前元素为c，answer当前index的元素为0\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int pos = -n;\r\n        int[] answer = new int[n];\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) pos = i;\r\n            answer[i] = i - pos;\r\n        }\r\n        \r\n        for (int i = pos; i >= 0; i--) {\r\n            if (s.charAt(i) == c) pos = i;\r\n            answer[i] = Math.min(answer[i], pos - i);\r\n        }\r\n        \r\n        return answer;\r\n    }\r\n}\r\n```\r\n* 时间：O(n)， n为s的长度\r\n* 空间：O(n)， 建立新数组answer，长度为n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840297389","body":"Will do"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixi-jiu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836121004","body":"### 思路\r\n\r\n利用 加一 那道题的思路 从个位加起\r\n最后还要处理 k 大于 0 的情况\r\n例如：num = [0];k = 23 \r\n\r\n不明白为什么耗时很多 200+ms\r\n### 代码\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    const len = num.length;\r\n    let res = [];\r\n    for (let i = len - 1;i >= 0;i--) {\r\n        let sum = num[i] + (k % 10);\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n            res.unshift(sum);\r\n        } else {\r\n            res.unshift(sum);\r\n        }\r\n    }\r\n    while (k > 0) {\r\n        res.unshift(k % 10);\r\n        k = Math.floor(k / 10);\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837644356","body":"/* 思路\r\n- 遍历字符串\r\n- 从每个字符的左边和右边分别开始寻找目标字符\r\n- 如果找到了, 结束遍历\r\n- 如果没有找到, 给下标赋值无穷大\r\n- 选择较近的距离即可\r\n*/ \r\n// 代码\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let res = [];\r\n    for (let i = 0;i < s.length;i++) {\r\n        let left = i, right = i;\r\n        while (left >= 0) {\r\n            if (s[left] === c) {\r\n                break;\r\n            }\r\n            left--;\r\n        }\r\n        while (right < s.length) {\r\n            if (s[right] === c) {\r\n                break;\r\n            }\r\n            right++;\r\n        }\r\n        // 如果没有找到\r\n        if (left === -1) left = -Infinity;\r\n        if (right === s.length) right = Infinity;\r\n        // 选择较近的距离\r\n        res[i] = Math.min((i - left), (right - i));\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(N ^ 2)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n*/"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837644356","body":"/* 思路\r\n- 遍历字符串\r\n- 从每个字符的左边和右边分别开始寻找目标字符\r\n- 如果找到了, 结束遍历\r\n- 如果没有找到, 给下标赋值无穷大\r\n- 选择较近的距离即可\r\n*/ \r\n// 代码\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let res = [];\r\n    for (let i = 0;i < s.length;i++) {\r\n        let left = i, right = i;\r\n        while (left >= 0) {\r\n            if (s[left] === c) {\r\n                break;\r\n            }\r\n            left--;\r\n        }\r\n        while (right < s.length) {\r\n            if (s[right] === c) {\r\n                break;\r\n            }\r\n            right++;\r\n        }\r\n        // 如果没有找到\r\n        if (left === -1) left = -Infinity;\r\n        if (right === s.length) right = Infinity;\r\n        // 选择较近的距离\r\n        res[i] = Math.min((i - left), (right - i));\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(N ^ 2)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n*/"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840222483","body":"/* 思路\r\n- 用两个栈, 一个是存倍数的栈, 一个是存待拼接的字符串的栈\r\n- num 用来表示临时倍数\r\n- result 用来表示结果字符串\r\n- 如果碰到数字 -> 计算出倍数 -> 注意如果是连续多个数字, 要处理倍数\r\n- 如果碰到 '[' -> result 入栈(保存之前的) 并清零, num 入栈并清零\r\n- 把之前的 result 和 num 入栈, 开始寻找新的\r\n- 如果碰到 ']' -> 两个栈的栈顶元素出栈并计算\r\n- 之前的 + 现在的\r\n*/ \r\n// 代码\r\n```js\r\nvar decodeString = function(s) {\r\n    let numStack = [];\r\n    let strStack = [];\r\n    let num = 0;\r\n    let result = \"\";\r\n    for (const char of s) {\r\n        if (!isNaN(char)) {\r\n            num = num * 10 + Number(char);\r\n        } else if (char === '[') {\r\n            numStack.push(num);\r\n            num = 0;\r\n            strStack.push(result);\r\n            result = \"\";\r\n        } else if (char === ']') {\r\n            let repeatTimes = numStack.pop();\r\n            result = strStack.pop() + result.repeat(repeatTimes);\r\n        } else {\r\n            result += char;\r\n        }\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(n)，其中 n 为数组长度。\r\n- 空间复杂度：O(n)\r\n*/"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Daniel-Zheng":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836131939","body":"### 思路\r\n\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int length = num.size();\r\n        int current = k;\r\n        \r\n        while (--length >=0 || current > 0) {\r\n            if (length >= 0) current += num[length];\r\n            res.push_back(current % 10);\r\n            current /= 10;\r\n        }\r\n        \r\n        reverse(res.begin(), res.end());\r\n        return res; \r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837622983","body":"### 思路\r\n\r\n正反遍历\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res(s.size());\r\n        int current = 99999;\r\n        \r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] == c) current = i;\r\n            res[i] = abs(i - current);\r\n        }\r\n        \r\n        current = 99999;\r\n        for (int j = s.size() - 1; j >= 0; j--) {\r\n            if (s[j] == c) current = j;\r\n            res[j] = min(abs(j - current), res[j]);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837622983","body":"### 思路\r\n\r\n正反遍历\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res(s.size());\r\n        int current = 99999;\r\n        \r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] == c) current = i;\r\n            res[i] = abs(i - current);\r\n        }\r\n        \r\n        current = 99999;\r\n        for (int j = s.size() - 1; j >= 0; j--) {\r\n            if (s[j] == c) current = j;\r\n            res[j] = min(abs(j - current), res[j]);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840348543","body":"### 思路\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<int> numberCount;\r\n        stack<string> tempString;\r\n        int index = 0;\r\n        string result = \"\";\r\n        string temp = \"\";\r\n        \r\n        while (index < s.length()) { \r\n            if (isdigit(s[index])) {\r\n                int numberIndex = 0;\r\n                while (isdigit(s[index])) {\r\n                    numberIndex = numberIndex * 10 + s[index] - '0';\r\n                    index++;\r\n                }\r\n                numberCount.push(numberIndex);\r\n            }\r\n            else if (s[index] == '[') {\r\n                tempString.push(result);\r\n                result = \"\";\r\n                index++;\r\n            }\r\n            else if (s[index] == ']') {\r\n                int number = numberCount.top();\r\n                numberCount.pop();\r\n                temp = tempString.top();\r\n                tempString.pop();\r\n                for (int i = 0; i < number; i++) {\r\n                    temp += result;\r\n                }\r\n                result = temp;\r\n                index++;\r\n            }\r\n            else {\r\n                result += s[index];\r\n                index++;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hannahliu-github":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836142144","body":"思路：先把str变成int；加上k；再转回str，放进list里\r\n\r\n代码：python\r\n\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        x = int(''.join([str(s) for s in num]))\r\n        ans = x + k\r\n        array_form = [int(s) for s in str(ans)]\r\n        return array_form\r\n\r\n复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yunli2015":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836150346","body":"**思路**： 和add string一样，从末尾往前遍历，用sum， carry 记录\r\n**代码**：java\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int carry = 0, sum =0;\r\n        List<Integer> list = new ArrayList<>();\r\n        if(num.length == 0) return list;\r\n        int i= num.length - 1;\r\n        while(i>=0 || k != 0) {\r\n            sum = carry;\r\n            if(i >= 0) {\r\n                sum += num[i];\r\n                i--;\r\n            }\r\n            if(k != 0) {\r\n                sum += k %10;\r\n                k = k/10;\r\n            }\r\n            list.add(0, sum %10);\r\n            carry = sum /10;\r\n        }\r\n\r\n        if(carry != 0) list.add(0, carry);\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析：**\r\n时间复杂度：O（n）\r\n空间复杂度：O（1）"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839942156","body":"two passes, one from left and one from right\r\n\r\njava\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int prev = Integer.MIN_VALUE /2;\r\n        \r\n        int[] ans = new int[s.length()];\r\n        \r\n        for(int i=0; i<s.length(); i++) {\r\n            if(c == s.charAt(i)) {\r\n                prev = i;\r\n            }\r\n            ans[i] = i-prev;\r\n        }\r\n        \r\n        prev = Integer.MAX_VALUE /2;\r\n        for(int i=s.length() - 1; i>=0; i--) {\r\n            if(c == s.charAt(i)) {\r\n                prev = i;\r\n            }\r\n            ans[i] = Math.min(prev - i, ans[i]);\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\nT: O(N)\r\nS: O(N)? the size of ans[i]"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840349815","body":"O(n)\r\nO(n)\r\n\r\n```\r\nclass Solution {\r\n    \r\n    class elem{\r\n        int n;\r\n        String s;\r\n        elem (int n, String s) {\r\n            this.n = n;\r\n            this.s = s;\r\n        }\r\n    }\r\n    public String decodeString(String s) {\r\n        Stack<elem> stack = new Stack<>();\r\n        \r\n        int number = 0;\r\n        for(int i=0; i<s.length(); i++) {\r\n            char c = s.charAt(i);\r\n            if(Character.isDigit(c)) {\r\n                number = number * 10 + c - '0';\r\n            } else if (c == '[') {\r\n                stack.push(new elem(number, \"\"));\r\n                //System.out.println(number);\r\n                number = 0;\r\n                stack.push(new elem(0, Character.toString(c)));\r\n            } else if (c == ']') {\r\n                Stack<String> temp = new Stack<>();\r\n                while(!stack.peek().s.equals(\"[\")) {\r\n                    temp.push(stack.pop().s);\r\n                }\r\n                \r\n                stack.pop();\r\n                int num = stack.pop().n;\r\n                StringBuilder sb = new StringBuilder();\r\n                while(!temp.isEmpty()) {\r\n                    sb.append(temp.pop());\r\n                }\r\n                \r\n                for(int j=0; j<num; j++) {\r\n                    stack.push(new elem(0, sb.toString()));\r\n                }\r\n            } else {\r\n                stack.push(new elem(0, Character.toString(c)));\r\n            }\r\n        }\r\n        \r\n        Stack<String> temp2 = new Stack<>();\r\n        while(!stack.isEmpty()) {\r\n            temp2.push(stack.pop().s);\r\n        }\r\n        StringBuilder sb = new StringBuilder();\r\n        while(!temp2.isEmpty()) {\r\n            sb.append(temp2.pop());\r\n        }\r\n        \r\n        return sb.toString();\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Xeraphinite":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836152663","body":"### 思路\r\n模拟即可，需要注意最终返回数组的长度\r\n\r\n### 时空复杂度\r\n**时间复杂度**：O(max(log(k), n))，只进行了一次遍历\r\n**空间复杂度**：O(1)，除了存储结果的 `vector` 之外没有用到额外的变量\r\n\r\n### Code\r\n\r\n#### C++\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n      reverse(num.begin(), num.end());\r\n      int n = num.size(), i = 0;\r\n      vector<int> ans(max(n, (int)to_string(k).size()) + 1, 0);\r\n      while (i < n || k) {\r\n        ans[i] += (i < n ? num[i] : 0) + k % 10; \r\n        ans[i + 1] += ans[i] / 10, ans[i] %= 10;\r\n        k /= 10, i++;\r\n      }\r\n      if (ans.back() == 0) ans.pop_back();\r\n      return vector<int>(ans.rbegin(), ans.rend());\r\n    }\r\n};\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838309562","body":"### 思路\r\n记录下标，并从前后两次遍历分别更新值。\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n      int n = s.size();\r\n      vector<int> res(n, 0), nextC;\r\n      for (int i = 0; i < n; i++)\r\n        if (s[i] == c) nextC.emplace_back(i);\r\n      int m = nextC.size();\r\n      for (int i = 0, j = 0; i < n; i++) {\r\n        res[i] = abs(nextC[j] - i);\r\n        if (j < m - 1 && nextC[j] == i) j++;\r\n      }\r\n      for (int i = n - 1, j = m - 1; i >= 0; i--) {\r\n        res[i] = min(abs(nextC[j] - i), res[i]);\r\n        if (j > 0 && nextC[j] == i) j--;\r\n      }\r\n      return res;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838309562","body":"### 思路\r\n记录下标，并从前后两次遍历分别更新值。\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n      int n = s.size();\r\n      vector<int> res(n, 0), nextC;\r\n      for (int i = 0; i < n; i++)\r\n        if (s[i] == c) nextC.emplace_back(i);\r\n      int m = nextC.size();\r\n      for (int i = 0, j = 0; i < n; i++) {\r\n        res[i] = abs(nextC[j] - i);\r\n        if (j < m - 1 && nextC[j] == i) j++;\r\n      }\r\n      for (int i = n - 1, j = m - 1; i >= 0; i--) {\r\n        res[i] = min(abs(nextC[j] - i), res[i]);\r\n        if (j > 0 && nextC[j] == i) j--;\r\n      }\r\n      return res;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840589861","body":"### 思路\r\n\r\n写栈不知道为啥写炸了，明天再调调看\r\n\r\n一个普通的递归下降分析。(参考官方代码写的）\r\n\r\n时间复杂度：O(n)， n 为字符串长度\r\n空间复杂度：O(n)，最多需要用到长度为 n 的系统栈储存\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int getNum() {\r\n      int repeatTimes = 0;\r\n      while (idx < src.size() && isdigit(src[idx])) {\r\n        repeatTimes *= 10;\r\n        repeatTimes += (src[idx++] - '0');\r\n      }\r\n      return repeatTimes;\r\n    }\r\n\r\n    string getString() {\r\n      if (idx >= src.size() || src[idx] == ']') {\r\n        return \"\";\r\n      }\r\n      string ret;\r\n      char cur = src[idx]; \r\n      int repTime = 1;\r\n      if (isdigit(cur)) {\r\n        repTime = getNum(); \r\n        idx++;\r\n        string str = getString(); \r\n        idx++;\r\n        while (repTime--) ret += str; \r\n      } else if (isalpha(cur)) {\r\n        ret = string(1, src[idx++]);\r\n      }\r\n      return ret + getString();\r\n    }\r\n\r\n    string decodeString(string s) {\r\n      src = s, idx = 0;\r\n      return getString();\r\n    }\r\nprivate:\r\n    size_t idx;\r\n    string src;\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sumukeio":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836153578","body":"思路：由低位到高位将数字逐位相加\r\nwhile(A没完 ||B没完)\r\n     A的当前位\r\n     B的当前位\r\n\r\n    和 = A的当前位 + B的当前位 + 进位carry;\r\n\r\n当前位  = 和 % 10;\r\n进位 = 和/10;\r\n\r\n判断还有进位么？\r\n\r\n代码：\r\nint* addToArrayForm(int* A, int ASize, int K, int* returnSize)\r\n{\r\n     int len = fmax(ASize, 5) + 1;//防止越界\r\n     int *res = (int*)malloc(sizeof(int) * len);\r\n     int i = ASize - 1;\r\n     int idx = 0;\r\n//k不为0，数组数据未处理完，继续处理\r\nwhile(k !=0 || i>=0)\r\n{\r\n    k += ( i >= 0) ? A[ i--]  : 0;\r\n    res[ --len] = k % 10;\r\n    k /= 10;\r\n    idx++;\r\n}\r\n*returnSize = idx;\r\nreturn res + len;\r\n}\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838112294","body":"思路：第一次从左到右遍历到最左端最短的距离，第二次从右到左遍历到最右端最短的距离\r\n代码：\r\nint* shortestToChar(char* s, char c, int* returnSize){\r\nint len=strlens(s);\r\nint* a=(int*)malloc(sizeof(int)*len);\r\nint count=0;\r\nfor(int i=0;i<len;i++){\r\nif(s[i]==c){\r\na[count++]=0;\r\n}else{\r\nint left=10001,right=10001;\r\nfor(int j=i+1;j<len;j++){\r\nif(s[j]==c){\r\nright=j;\r\nbreak;\r\n}\r\n}\r\nfor(int x=i-1;x>=0;x--){\r\nif(s[x]==c){\r\nleft=x;\r\nbreak;\r\n}\r\n}\r\nright=fmin(abs(i-left),abs(i-right));\r\na[count++]=right;\r\n}\r\n}\r\n*returnSize=len;\r\nreturn a;\r\n}\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838112294","body":"思路：第一次从左到右遍历到最左端最短的距离，第二次从右到左遍历到最右端最短的距离\r\n代码：\r\nint* shortestToChar(char* s, char c, int* returnSize){\r\nint len=strlens(s);\r\nint* a=(int*)malloc(sizeof(int)*len);\r\nint count=0;\r\nfor(int i=0;i<len;i++){\r\nif(s[i]==c){\r\na[count++]=0;\r\n}else{\r\nint left=10001,right=10001;\r\nfor(int j=i+1;j<len;j++){\r\nif(s[j]==c){\r\nright=j;\r\nbreak;\r\n}\r\n}\r\nfor(int x=i-1;x>=0;x--){\r\nif(s[x]==c){\r\nleft=x;\r\nbreak;\r\n}\r\n}\r\nright=fmin(abs(i-left),abs(i-right));\r\na[count++]=right;\r\n}\r\n}\r\n*returnSize=len;\r\nreturn a;\r\n}\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Mvbbb":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836163931","body":"# 思路\r\n\r\n按照竖式的个位加法来相加\r\n\r\n\r\n# 代码\r\n\r\n```java\r\nclass Solution{\r\n    public List<Integer> addToArrayForm(int[] num,int k){\r\n        int len = num.length;\r\n        int lastNum = k;\r\n        int i = len-1;\r\n        LinkedList<Integer> list = new LinkedList<>();\r\n        while(i>=0||lastNum>0){  // 循环条件: 没有遍历完num或者lastNum中的数还没有全部插入到 list 中\r\n            if(i>=0){ \r\n                lastNum+=num[i]; // 加上一个个位数\r\n            }\r\n            list.addFirst(lastNum%10); // 每一次循环都需要从 lastNum 末尾取一个数放到 list 中\r\n            lastNum/=10;\r\n            i--;\r\n        }\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度\r\n\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838027915","body":"**刚开始的思路：**\r\n\r\n遍历一遍数组， 找到 c 的位置的集合。\r\n在遍历一次数组，如果当前元素不是 c，就计算出当前元素下标到哪个c下标最近。\r\n\r\n时间复杂度 O(Nk) 。k 是 c 出现的次数\r\n\r\n**看了题解之后的思路：**\r\n\r\n\r\n离一个字符最近的 c 要不然是它右边最近的一个 c，要不然在它左边最近的一个 c\r\n\r\n遍历两次字符串\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] left = new int[s.length()]; \r\n        int[] right = new int[s.length()];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        int behind = Integer.MAX_VALUE/2;\r\n        for(int i=0,j=s.length()-1;i<s.length();i++,j--){\r\n            if(s.charAt(i)==c){\r\n                prev = i;\r\n                left[i]=0;\r\n            }else{\r\n                left[i]=i-prev;\r\n            }\r\n            if(s.charAt(j)==c){\r\n                behind = j;\r\n                right[j]=0;\r\n            }else{\r\n                right[j]=behind-j;\r\n            }            \r\n        }\r\n\r\n        for(int i=0;i<left.length;i++){\r\n            left[i]= Math.min(left[i],right[i]);\r\n        }\r\n        return left;\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度 O(N）\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838027915","body":"**刚开始的思路：**\r\n\r\n遍历一遍数组， 找到 c 的位置的集合。\r\n在遍历一次数组，如果当前元素不是 c，就计算出当前元素下标到哪个c下标最近。\r\n\r\n时间复杂度 O(Nk) 。k 是 c 出现的次数\r\n\r\n**看了题解之后的思路：**\r\n\r\n\r\n离一个字符最近的 c 要不然是它右边最近的一个 c，要不然在它左边最近的一个 c\r\n\r\n遍历两次字符串\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] left = new int[s.length()]; \r\n        int[] right = new int[s.length()];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        int behind = Integer.MAX_VALUE/2;\r\n        for(int i=0,j=s.length()-1;i<s.length();i++,j--){\r\n            if(s.charAt(i)==c){\r\n                prev = i;\r\n                left[i]=0;\r\n            }else{\r\n                left[i]=i-prev;\r\n            }\r\n            if(s.charAt(j)==c){\r\n                behind = j;\r\n                right[j]=0;\r\n            }else{\r\n                right[j]=behind-j;\r\n            }            \r\n        }\r\n\r\n        for(int i=0;i<left.length;i++){\r\n            left[i]= Math.min(left[i],right[i]);\r\n        }\r\n        return left;\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度 O(N）\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840266496","body":"```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n    \tDeque<Integer> numStack = new ArrayDeque<>();\r\n    \tDeque<String> strStack = new ArrayDeque<>();\r\n    \t\r\n    \tStringBuilder tail = new StringBuilder();\r\n\r\n        int n = s.length();\r\n        for(int i=0;i<n;i++){\r\n            char c = s.charAt(i);\r\n            if(Character.isDigit(c)){\r\n            \t// 将数字放入到操作数栈中\r\n                int num = c-'0';\r\n                while(i+1<n&&Character.isDigit(s.charAt(i+1))){\r\n                    num = num*10+s.charAt(i+1)-'0';\r\n                    i++;\r\n                }\r\n                numStack.push(num);\r\n            }\r\n            else if(c=='['){\r\n            \t// 将处于 ] 和 [ 之间的字符串放进 strStack 中\r\n                strStack.push(tail.toString());\r\n                tail = new StringBuilder();\r\n            }\r\n            else if(c==']'){\r\n            \t// 从 strStack 中取出字符串, numStack 中取出重复次数\r\n                StringBuilder tmp = new StringBuilder(strStack.pop());\r\n                int repeatedTimes = numStack.pop();\r\n                for(int j=0;j<repeatedTimes;j++){\r\n                    tmp.append(tail);\r\n                }\r\n                tail = tmp;\r\n            }\r\n            else{\r\n            \t// 当前 c 一定还没有被 [] 包围\r\n                tail.append(c);\r\n            }\r\n            \r\n        }\r\n        return tail.toString();\r\n    }\r\n}\r\n\r\n```\r\n时间复杂度 和 空间复杂度都是 O(S). S 是字符串解码之后的长度"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thisisandy":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836172220","body":"# 思路\r\n各位依次相加\r\n\r\n# 代码\r\n```typescript\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    const num2 = []\r\n    const result = []\r\n    let diff = k\r\n    while(diff){\r\n        const unit = diff%10\r\n        num2.unshift(unit)\r\n        diff = Math.floor(diff/10)\r\n    }\r\n    let a;\r\n    let b;\r\n    let bonus = 0;\r\n    while(bonus || num.length || num2.length){\r\n        a = num.pop() || 0 \r\n        b = num2.pop() || 0\r\n        const sum = a + b + bonus\r\n        const unit = (sum) % 10\r\n        bonus = Math.floor((sum)/10)\r\n        result.unshift(unit)\r\n    }\r\n    return result\r\n};\r\n```\r\n# 复杂度\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837700548","body":"```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    let lastPosition = - Infinity;\r\n    const result = []\r\n    for(let i =0; i< s.length; i++){\r\n        if(s[i] === c){\r\n            lastPosition = i\r\n        }\r\n        result[i] = i - lastPosition\r\n    }\r\n    for(let i =s.length-1; i>=0; i--){\r\n        if(s[i] === c){\r\n            lastPosition = i\r\n        }\r\n        result[i] = Math.min(Math.abs(i-lastPosition),result[i])\r\n    }\r\n    return result\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837700548","body":"```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    let lastPosition = - Infinity;\r\n    const result = []\r\n    for(let i =0; i< s.length; i++){\r\n        if(s[i] === c){\r\n            lastPosition = i\r\n        }\r\n        result[i] = i - lastPosition\r\n    }\r\n    for(let i =s.length-1; i>=0; i--){\r\n        if(s[i] === c){\r\n            lastPosition = i\r\n        }\r\n        result[i] = Math.min(Math.abs(i-lastPosition),result[i])\r\n    }\r\n    return result\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840478234","body":"```typescript\r\nfunction decodeString(s: string): string {\r\n    const stack = []\r\n    for(let i =0;i<s.length; i++){\r\n        if(/[[\\d\\w]/.test(s[i])){\r\n            stack.push(s[i])\r\n        }\r\n        if(/\\]/.test(s[i])){\r\n            let str = ''\r\n            for(let j = stack.length-1; j>=0; j--){\r\n                const char = stack.pop()\r\n                if(char!=='['){\r\n                    str = char + str\r\n                }else{\r\n                    break;\r\n                }\r\n            }\r\n            let rep = ''\r\n            for(let j = stack.length-1; j>=0; j--){\r\n                const char = stack.pop()\r\n                if(!/\\d/.test(char)){\r\n                    stack.push(char)\r\n                    break;\r\n                }else{\r\n                    rep = char +rep\r\n                }\r\n            }\r\n            stack.push(str.repeat(Number(rep)))\r\n        }\r\n    }\r\n    return stack.join('')\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzqnb":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836191824","body":"语言： java\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n\tint i = len - 1, sum = 0, carry = 0, res = 0;\r\n\tList<Integer> list = new ArrayList<>();\r\n\twhile (i >= 0 || k != 0) {\r\n\t\tsum = (i >= 0 ? num[i] : 0) + (k != 0 ? k % 10 : 0) + carry;\r\n\t\tcarry = sum / 10;\r\n\t\tres = sum % 10;\r\n\t\tlist.add(res);\r\n\t\tk /= 10;\r\n\t\ti--;\r\n\t}\r\n        if (carry!=0) list.add(carry);\r\n\tCollections.reverse(list);\r\n\treturn list;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837839988","body":"左右两次遍历，参考了官方的解题方法加入了自己的思路\r\n\r\n**java**\r\n```\r\nclass Solution {\r\n\tpublic int[] shortestToChar(String s, char c) {\r\n\t\tint len = s.length(), prev = s.indexOf(c);\r\n\t\tint[] res = new int[len];\r\n\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\tif (s.charAt(i) == c) prev = i;\r\n\t\t\tint tmp = i - prev;\r\n\t\t\tres[i] = tmp >= 0 ? tmp : -tmp;\r\n\t\t}\r\n\t\tprev = s.lastIndexOf(c);\r\n\t\tfor (int i = len - 1; i >= 0; i--) {\r\n\t\t\tif (s.charAt(i) == c) prev = i;\r\n\t\t\tint tmp = i - prev;\r\n\t\t\ttmp = tmp >= 0 ? tmp : -tmp;\r\n\t\t\tres[i] = tmp >= res[i] ? res[i] : tmp;\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837839988","body":"左右两次遍历，参考了官方的解题方法加入了自己的思路\r\n\r\n**java**\r\n```\r\nclass Solution {\r\n\tpublic int[] shortestToChar(String s, char c) {\r\n\t\tint len = s.length(), prev = s.indexOf(c);\r\n\t\tint[] res = new int[len];\r\n\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\tif (s.charAt(i) == c) prev = i;\r\n\t\t\tint tmp = i - prev;\r\n\t\t\tres[i] = tmp >= 0 ? tmp : -tmp;\r\n\t\t}\r\n\t\tprev = s.lastIndexOf(c);\r\n\t\tfor (int i = len - 1; i >= 0; i--) {\r\n\t\t\tif (s.charAt(i) == c) prev = i;\r\n\t\t\tint tmp = i - prev;\r\n\t\t\ttmp = tmp >= 0 ? tmp : -tmp;\r\n\t\t\tres[i] = tmp >= res[i] ? res[i] : tmp;\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengyi666":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836198313","body":"**思路：**\r\n• 判断长度\r\n• 考虑进位\r\n• 考虑越位开辟新空间\r\n• 正序输入，倒序输出\r\n### \r\n**力扣python打卡**\r\n\r\n\r\n```\r\n#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\nvoid  addToArrayForm(int* A, int ASize, int K)\r\n{\r\n\t//计算K的位数\r\n\tint len = 0;\r\n\tint tmp = K;\r\n\twhile (tmp)\r\n\t{\r\n\t\tlen++;\r\n\t\ttmp /= 10;\r\n\t}\r\n\t//开辟空间，注意最高位可能存在进位的情况\r\n\tint arrLen = ASize > len ? ASize + 1 : len + 1;\r\n\tint* arr = (int*)malloc(sizeof(int) * arrLen);\r\n\t//逐位相加\r\n\tint index = 0;\r\n\tint end = ASize - 1;\r\n\tint step = 0;\r\n\twhile (end >= 0 || K > 0)\r\n\t{\r\n\t\tint cursum = step;\r\n\t\tif (end >= 0)\r\n\t\t{\r\n\t\t\tcursum += A[end];\r\n\t\t}\r\n\t\tif (K > 0)\r\n\t\t{\r\n\t\t\tcursum += (K % 10);\r\n\t\t}\r\n\t\t//如果位数的值超过9需要进位\r\n\t\tif (cursum > 9)\r\n\t\t{\r\n\t\t\tstep = 1;\r\n\t\t\tcursum -= 10;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tstep = 0;\r\n\t\t}\r\n\t\tarr[index++] = cursum;\r\n\t\tend--;\r\n\t\tK /= 10;\r\n\t}\r\n\t//判断最高位是否存在进位\r\n\tif (step == 1)\r\n\t{\r\n\t\tarr[index++] = step;\r\n\t}\r\n\t//为了方便对数组进行尾插，所以数据是逆序存储，故要对数组进行逆序操作。\r\n\tint start = 0;\r\n\tend = index - 1;\r\n\twhile (start < end)\r\n\t{\r\n\t\tint tmp = arr[start];\r\n\t\tarr[start] = arr[end];\r\n\t\tarr[end] = tmp;\r\n\t\tstart++;\r\n\t\tend--;\r\n\t}\r\n\tfor (int i = 0; i < index; ++i)\r\n\t\tprintf(\"%d \", *(arr + i));\r\n}\r\n//主函数\r\nint main() {\r\n\t\tint a[10] = {};\r\n\t\tint Asize, k;\r\n\t\tprintf(\"想输入几位数组？：\\n\");\r\n\t\tscanf_s(\"%d\", &Asize);\r\n\t\tprintf(\"请输入数组：\\n\");\r\n\t\tfor (int i = 0; i < Asize; i++) {\r\n\t\t\tscanf_s(\"%d\", &a[i]);\r\n\t\t}\r\n\t\tprintf(\"请输入0~10000的整数：\\n\");\r\n\t\tscanf_s(\"%d\", &k);\r\n\taddToArrayForm(a, Asize, k);\r\n\treturn 0;\r\n}\r\n//分为1.判断位数2.逐位相加3.进位4.越位5.逆序\r\n```\r\n**复杂度**\r\n\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837733723","body":"**思路**\r\n1.获取目标在s中的下标\r\n2.从头开始，比较相邻2个的目标\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        location = []\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                location.append(i) # 获取目标在s中的下标\r\n        k = 0\r\n        whole = len(location)-1\r\n        res = []\r\n        for i in range(len(s)):\r\n            if k!=whole and abs(i-location[k])>abs(i-location[k+1]):\r\n                k += 1\r\n            res.append(abs(i-location[k]))\r\n        return res\r\n```\r\n**复杂度分析**\r\n\r\n- 时间:O(n)\r\n\r\n- 空间:O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837733723","body":"**思路**\r\n1.获取目标在s中的下标\r\n2.从头开始，比较相邻2个的目标\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        location = []\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                location.append(i) # 获取目标在s中的下标\r\n        k = 0\r\n        whole = len(location)-1\r\n        res = []\r\n        for i in range(len(s)):\r\n            if k!=whole and abs(i-location[k])>abs(i-location[k+1]):\r\n                k += 1\r\n            res.append(abs(i-location[k]))\r\n        return res\r\n```\r\n**复杂度分析**\r\n\r\n- 时间:O(n)\r\n\r\n- 空间:O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840512151","body":"**思路**\r\n栈\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = [] # 定义空栈\r\n        res = ''\r\n        num = 0\r\n        for c in s:\r\n            if c == \"[\":\r\n                stack.append([num,res])\r\n                res = ''\r\n                num = 0\r\n            elif c == \"]\":\r\n                last_num,last_res = stack.pop()\r\n                res = last_res + last_num * res\r\n            elif c.isdigit():\r\n                num = num * 10 + int(c)\r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n复杂度\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nanwy":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836213176","body":"思路\r\n1.各位相加，如果进位，将k加1，把相加后的数对10取余放入数组，最后反转数组\r\n\r\n代码（js）\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [],carry=0;\r\n    for(let i=num.length-1;i>=0;i--){\r\n        let sum = num[i] + k % 10\r\n        k = k / 10 | 0\r\n        if(sum > 9){\r\n            k++\r\n        }\r\n        res.push(sum % 10)\r\n    }\r\n    while(k != 0){\r\n        res.push(k % 10)\r\n        k = k / 10 | 0\r\n    }\r\n    return res.reverse()\r\n};\r\n```\r\n        \r\n复杂度\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837737014","body":"## 思路：先进行遍历，碰到c后，派出两个指针分别向左向右，取最小值。\r\n```js\r\nvar shortestToChar = function (s, c) {\r\n        let i = 0,res = Array(s.length).fill(Infinity);\r\n        while (i < s.length) {\r\n                if (s[i] !== c) {\r\n                        let l = i - 1,\r\n                                r = i + 1;\r\n                        while (s[l] != c && l > 0) {\r\n                                l--;\r\n                        }\r\n                        while (s[r] != c && r < s.length - 1) {\r\n                                r++;\r\n                        }\r\n                        let left = s[l] == c ? i - l : Infinity;\r\n                        let right = s[r] == c ? r - i : Infinity;\r\n                        let ans = Math.min(left, right);\r\n                        // console.log(ans)\r\n                        res[i] = ans;\r\n                } else {\r\n                        res[i] = 0;\r\n                }\r\n                i++;\r\n        }\r\n        // console.log(res)\r\n        return res;\r\n};\r\n```\r\n## 复杂度分析\r\n\r\n- 时间：O(n^2)\r\n- 空间：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837737014","body":"## 思路：先进行遍历，碰到c后，派出两个指针分别向左向右，取最小值。\r\n```js\r\nvar shortestToChar = function (s, c) {\r\n        let i = 0,res = Array(s.length).fill(Infinity);\r\n        while (i < s.length) {\r\n                if (s[i] !== c) {\r\n                        let l = i - 1,\r\n                                r = i + 1;\r\n                        while (s[l] != c && l > 0) {\r\n                                l--;\r\n                        }\r\n                        while (s[r] != c && r < s.length - 1) {\r\n                                r++;\r\n                        }\r\n                        let left = s[l] == c ? i - l : Infinity;\r\n                        let right = s[r] == c ? r - i : Infinity;\r\n                        let ans = Math.min(left, right);\r\n                        // console.log(ans)\r\n                        res[i] = ans;\r\n                } else {\r\n                        res[i] = 0;\r\n                }\r\n                i++;\r\n        }\r\n        // console.log(res)\r\n        return res;\r\n};\r\n```\r\n## 复杂度分析\r\n\r\n- 时间：O(n^2)\r\n- 空间：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840426835","body":"思路：\r\n用两个栈分别存入重复的次数和被重复的字符串，遍历数组遇到'['将数字和字符串压入栈，遇到']'将两个栈分别弹出，并赋值给新的str。\r\n```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let numStack = [], strStack = [],str = '', num=0\r\n    for(let i=0;i<s.length;i++){\r\n        if(/[0-9]/.test(s[i])){\r\n            // numStack.push(s[i])\r\n            num = num * 10 + +s[i]\r\n        }else if(s[i] == '['){\r\n            strStack.push(str)\r\n            str = ''\r\n            numStack.push(num)\r\n            num = 0\r\n        }else if(s[i] == ']'){\r\n            let newStr = str.repeat(numStack.pop())\r\n            // strStack.push(newStr)\r\n            // console.log(newStr)\r\n            str = strStack.pop() +  newStr\r\n        }else{\r\n            str += s[i]\r\n        }\r\n    }\r\n    // console.log(strStack,numStack,str)\r\n    return str\r\n};\r\n```\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(2n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"surahe":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836217045","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  将k 转换为数组 k_arr\r\n-  比较 k_arr 和 num 长度，将其中较长的一个的长度+1，定义为 max_length\r\n-  创建数组digit，长度为max_length，用来存储进位\r\n-  将 k_arr 和 num 长度补长到与 max_length相同\r\n-  从低位开始逐位计算，超过10则在digit 对应位置进1\r\n-  如果最高为是0，去除\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\nvar addToArrayForm = function (num, k) {\r\n  var result = []\r\n  var k_arr = k.toString().split('')\r\n  var max_length = num.length > k_arr.length ? num.length + 1 : k_arr.length + 1\r\n  var digit = Array(max_length).fill(0)\r\n  var now_res\r\n\r\n  for (var i = num.length; i < max_length; i++) {\r\n    num.unshift(0)\r\n  }\r\n  for (var i = k_arr.length; i < max_length; i++) {\r\n    k_arr.unshift(0)\r\n  }\r\n\r\n  for (var i = max_length - 1; i >= 0; i--) {\r\n    if (digit[i] + num[i] + +k_arr[i] >= 10) {\r\n      digit[i-1] = 1\r\n      now_res = digit[i] + num[i] + +k_arr[i] - 10\r\n    } else {\r\n      now_res = digit[i] + num[i] + +k_arr[i]\r\n    }\r\n    result.unshift(now_res)\r\n  }\r\n\r\n  if (result[0] === 0) {\r\n    result.shift()\r\n  } \r\n\r\n  return result\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(Max(num, k)+1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837820712","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  用两个数组分别存储从左遍历向左比较（→）和从左遍历向右比较（←）的情况\r\n-  对于向右查找，如果数组长度不够，需要补99999\r\n- 对于向左查找，情况更复杂点。没遇到 c前都需要补99999，只要遇到一次以后就不需要再补99999。如果遍历结束，right 长度还不够，需要把k 遍历 push 进right\r\n- 比较 left、right 各项大小，取较小的\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  var length = s.length\r\n\r\n  var left = []\r\n  var i = 0\r\n  var j = 0\r\n\r\n  var right = []\r\n  var k = 0\r\n  var l = 0\r\n\r\n  while (i < length) {\r\n    if (s[i]!== c) {\r\n      j++\r\n    } else {\r\n      for (var index = j; index >= 0; index--) {\r\n        left.push(index)\r\n        j = 0\r\n      }\r\n    }\r\n    i++\r\n  }\r\n  for (var t1 = left.length; t1 < length; t1++) {\r\n    left.push(99999)\r\n  }\r\n\r\n  let flag = true\r\n  while (k < length) {\r\n    if (s[k] !== c) {\r\n      if (flag) {\r\n        right.push(99999)\r\n      } else {\r\n        l++\r\n      }\r\n    } else {\r\n      flag = false\r\n      for (var index = 1; index <= l; index++) {\r\n        right.push(index)\r\n      }\r\n      right.push(0)\r\n      l = 0\r\n    }\r\n    k++\r\n    if (k === length && l !== 0) {\r\n      for (var index = 1; index <= l; index++) {\r\n        right.push(index)\r\n      }\r\n    }\r\n  }\r\n\r\n  for (var i = 0; i < length ; i++) {\r\n    if (right[i] < left[i]) {\r\n      left[i] = right[i]\r\n    }\r\n  }\r\n  return left\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837820712","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  用两个数组分别存储从左遍历向左比较（→）和从左遍历向右比较（←）的情况\r\n-  对于向右查找，如果数组长度不够，需要补99999\r\n- 对于向左查找，情况更复杂点。没遇到 c前都需要补99999，只要遇到一次以后就不需要再补99999。如果遍历结束，right 长度还不够，需要把k 遍历 push 进right\r\n- 比较 left、right 各项大小，取较小的\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  var length = s.length\r\n\r\n  var left = []\r\n  var i = 0\r\n  var j = 0\r\n\r\n  var right = []\r\n  var k = 0\r\n  var l = 0\r\n\r\n  while (i < length) {\r\n    if (s[i]!== c) {\r\n      j++\r\n    } else {\r\n      for (var index = j; index >= 0; index--) {\r\n        left.push(index)\r\n        j = 0\r\n      }\r\n    }\r\n    i++\r\n  }\r\n  for (var t1 = left.length; t1 < length; t1++) {\r\n    left.push(99999)\r\n  }\r\n\r\n  let flag = true\r\n  while (k < length) {\r\n    if (s[k] !== c) {\r\n      if (flag) {\r\n        right.push(99999)\r\n      } else {\r\n        l++\r\n      }\r\n    } else {\r\n      flag = false\r\n      for (var index = 1; index <= l; index++) {\r\n        right.push(index)\r\n      }\r\n      right.push(0)\r\n      l = 0\r\n    }\r\n    k++\r\n    if (k === length && l !== 0) {\r\n      for (var index = 1; index <= l; index++) {\r\n        right.push(index)\r\n      }\r\n    }\r\n  }\r\n\r\n  for (var i = 0; i < length ; i++) {\r\n    if (right[i] < left[i]) {\r\n      left[i] = right[i]\r\n    }\r\n  }\r\n  return left\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840658514","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  用栈分别存储重复次数、字符串内容\r\n- 记录左括号、右括号匹配次数\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s) {\r\n  var state\r\n  var multi = 1\r\n  var left = 0\r\n  var right = 0\r\n\r\n  var str = ''\r\n  var strStack = []\r\n\r\n  var repeatStack = []\r\n\r\n  var a2z = /[a-z]/\r\n  var one2nine = /[1-9]/\r\n  for (var i = 0; i < s.length; i++) {\r\n    if (a2z.test(s[i])) {\r\n      if (i === 0 || s[i - 1] === ']') {\r\n        repeatStack.push(1)\r\n      }\r\n      str += s[i]\r\n      if (i == s.length -1 && str) {\r\n        strStack.push(str)\r\n      }\r\n    }\r\n    if (one2nine.test(Number(s[i]))) {\r\n      multi = multi * Number(s[i])\r\n      if (state === 'on') {\r\n        repeatStack.push(multi)\r\n      } else {\r\n        repeatStack.push(Number(s[i]))\r\n      }\r\n      if ( str) {\r\n        strStack.push(str)\r\n        str = ''\r\n      }\r\n    }\r\n    if (s[i] === '[') {\r\n      if (state === 'on' && str) {\r\n        strStack.push(str)\r\n        str = ''\r\n      }\r\n      left ++\r\n      state = 'on'\r\n    }\r\n    if (s[i] === ']' && str) {\r\n      strStack.push(str)\r\n      str = ''\r\n      right ++\r\n      state = 'off'\r\n      if (left === right) {\r\n        multi = 1\r\n      }\r\n    }\r\n  }\r\n  var result = ''\r\n  for (var i = 0; i < repeatStack.length; i ++) {\r\n    for(var j = 0; j < repeatStack[j]; j++) {\r\n      result+=strStack[j]\r\n    }\r\n  }\r\n  return result\r\n};\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为字符串长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Serrust":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836227745","body":"```import java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\n/*\r\n * @lc app=leetcode id=989 lang=java\r\n *\r\n * [989] Add to Array-Form of Integer\r\n */\r\n\r\n// @lc code=start\r\nclass Solution {\r\n    /**\r\n     * Explanation:\r\n     * create an arraylist to store the answer.\r\n     * loop starting from the last element of input,\r\n     * here i use an example:\r\n     * for 123 + 912, where 123 is the integer represented by A and 912 is K\r\n     * we start with [1, 2, 3+912]. \r\n     * Then we perform the addition 3+912, leaving 915. \r\n     * The 5 stays as the digit, while we 'carry' 910 into the next column which becomes 91.\r\n     * We repeat this process with [1, 2+91, 5]. \r\n     * We have 93, where 3 stays and 90 is carried over as 9. \r\n     * Again, we have [1+9, 3, 5] which transforms into [1, 0, 3, 5].\r\n     * Complexity Analysis:\r\n     * Todo: why?\r\n     * Time: O(max(N, log K)) where N is the length of A\r\n     * Space: O(max(N,log K))\r\n     * @param A\r\n     * @param K\r\n     * @return\r\n     */\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        \r\n        int N = A.length;\r\n        int temp = K;\r\n        List<Integer> ans = new ArrayList<>();\r\n        \r\n        int i = N-1;\r\n        // Note: we are not sure if the integer that A represents is larger or k is larger\r\n        while (i >= 0 || temp > 0) {\r\n            // Note: we add this if condition because i can be negative if K is larger than the integer represented by A\r\n            if (i >= 0) {\r\n                temp += A[i];\r\n            }\r\n            ans.add(temp % 10);\r\n            temp /= 10;\r\n            i -= 1;\r\n        }\r\n        Collections.reverse(ans);\r\n\r\n        return ans;\r\n    }\r\n}\r\n// @lc code=end```\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838668830","body":"```/*\r\n * @lc app=leetcode id=821 lang=java\r\n *\r\n * [821] Shortest Distance to a Character\r\n */\r\n\r\n// @lc code=start\r\nclass Solution {\r\n    /**\r\n     * Explanation:\r\n     * create an array to store the answers\r\n     * create int c_position and set it to a negative number\r\n     * iterate through the existing string by each character twice\r\n     * in the first loop, loop from the front\r\n     * in each iteration, the distance (from the left char c) = current position - c_position\r\n     * once char c is found, update c_position to the position of c\r\n     * then set c_position to a very large positive integer and start the second loop\r\n     * in the second loop, loop from the end\r\n     * in each iteration, the distance (from the right char c) = c_position - current position IF this distance is smaller than the distance we calculated in the first iteration\r\n     * return the array with the shortest distance\r\n     * \r\n     * Complexity Analysis:\r\n     * Time: O(n) since 2 iterations, each iteration length is n\r\n     * Space: O(n) since only an array with the length of input string is used\r\n     * \r\n     * @param S\r\n     * @param C\r\n     * @return\r\n     */\r\n    public int[] shortestToChar(String S, char C) {\r\n\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        \r\n        // NOTE: for this kind of problem, remember to use Interger.MIN_VALUE or Integer.MAX_VALUE to set min/max values\r\n        int cPosition = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < N; i++) {\r\n            if (S.charAt(i) == C) {\r\n                cPosition = i;\r\n            }\r\n            ans[i] = i - cPosition;\r\n        }\r\n\r\n        cPosition = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; i--) {\r\n            if (S.charAt(i) == C) {\r\n                cPosition = i;\r\n            }\r\n            // NOTE: cPosition is larger or equal to current index i\r\n            ans[i] = Math.min(ans[i], cPosition - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n// @lc code=end\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838668830","body":"```/*\r\n * @lc app=leetcode id=821 lang=java\r\n *\r\n * [821] Shortest Distance to a Character\r\n */\r\n\r\n// @lc code=start\r\nclass Solution {\r\n    /**\r\n     * Explanation:\r\n     * create an array to store the answers\r\n     * create int c_position and set it to a negative number\r\n     * iterate through the existing string by each character twice\r\n     * in the first loop, loop from the front\r\n     * in each iteration, the distance (from the left char c) = current position - c_position\r\n     * once char c is found, update c_position to the position of c\r\n     * then set c_position to a very large positive integer and start the second loop\r\n     * in the second loop, loop from the end\r\n     * in each iteration, the distance (from the right char c) = c_position - current position IF this distance is smaller than the distance we calculated in the first iteration\r\n     * return the array with the shortest distance\r\n     * \r\n     * Complexity Analysis:\r\n     * Time: O(n) since 2 iterations, each iteration length is n\r\n     * Space: O(n) since only an array with the length of input string is used\r\n     * \r\n     * @param S\r\n     * @param C\r\n     * @return\r\n     */\r\n    public int[] shortestToChar(String S, char C) {\r\n\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        \r\n        // NOTE: for this kind of problem, remember to use Interger.MIN_VALUE or Integer.MAX_VALUE to set min/max values\r\n        int cPosition = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < N; i++) {\r\n            if (S.charAt(i) == C) {\r\n                cPosition = i;\r\n            }\r\n            ans[i] = i - cPosition;\r\n        }\r\n\r\n        cPosition = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; i--) {\r\n            if (S.charAt(i) == C) {\r\n                cPosition = i;\r\n            }\r\n            // NOTE: cPosition is larger or equal to current index i\r\n            ans[i] = Math.min(ans[i], cPosition - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n// @lc code=end\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cicihou":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836239329","body":"思路：\r\n将 array -> str -> int, 相加之后重新转换成array[int]\r\n\r\n代码：\r\n\r\n> class Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        # method 1 list iteration\r\n        # return [int(j) for j in str(int(''.join([str(i) for i in num])) + k)]\r\n\r\n        # method 2, same as method 1, use for-loop explicitly to analyze the complexity\r\n        # as following, the time complexity is O(n)\r\n        # the space complexity is O(1)\r\n        res = []\r\n        for i in num:\r\n            res.append(str(i))\r\n        res = str(int(''.join(res)) + k)\r\n        res = [int(i) for i in res]\r\n        return res\r\n\r\n\r\n\r\n复杂度分析：\r\n\r\n令 n 为数组长度。\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n\r\n![Uploading image.png…]()\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837653863","body":"思路\r\n遍历数组，将数组中命中c的值设为0并获得命中的c的index_list，其他值设为无穷大。\r\n再次遍历数组，将其与命中c的list index 做比较，获取绝对值大小\r\n\r\nPython Code:\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str):\r\n        res = []\r\n        zero_point = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                res.append(0)\r\n                zero_point.append(i)\r\n            else:\r\n                res.append(float('inf'))\r\n        for i in range(len(res)):\r\n            for j in zero_point:\r\n                if i != j:\r\n                    res[i] = min(res[i], abs(i-j))\r\n        return res\r\n```\r\n\r\n复杂度分析\r\n\r\n令 n 为字符串长度。\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837653863","body":"思路\r\n遍历数组，将数组中命中c的值设为0并获得命中的c的index_list，其他值设为无穷大。\r\n再次遍历数组，将其与命中c的list index 做比较，获取绝对值大小\r\n\r\nPython Code:\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str):\r\n        res = []\r\n        zero_point = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                res.append(0)\r\n                zero_point.append(i)\r\n            else:\r\n                res.append(float('inf'))\r\n        for i in range(len(res)):\r\n            for j in zero_point:\r\n                if i != j:\r\n                    res[i] = min(res[i], abs(i-j))\r\n        return res\r\n```\r\n\r\n复杂度分析\r\n\r\n令 n 为字符串长度。\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840217686","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        ''' stack method1 一个不太干净漂亮的栈\r\n         这里的时间复杂度 time complexity 最坏结果是 O(n^2)\r\n         '''\r\n        stack = []\r\n        for i in s:\r\n            if i == ']':\r\n                volume = ''\r\n                tmp = ''\r\n                while stack:\r\n                    val = stack.pop()\r\n                    if val == '[':\r\n                        while stack:\r\n                            a = stack.pop()\r\n                            if a.isdigit():\r\n                                volume = a + volume\r\n                            else:\r\n                                stack.append(a)\r\n                                break\r\n                        break\r\n                    tmp = val + tmp\r\n                stack.append(int(volume) * tmp)\r\n            else:\r\n                stack.append(i)\r\n        return ''.join(stack)\r\n\r\n        ''' method 2 to make it more elegant '''\r\n        # stack = []\r\n        # curNum = 0\r\n        # curString = ''\r\n        # for i in s:\r\n        #     if i == '[':\r\n        #         stack.append(curString)\r\n        #         stack.append(curNum)\r\n        #         curString = ''\r\n        #         curNum = 0\r\n        #     elif i == ']':\r\n        #         num = stack.pop()\r\n        #         prevString = stack.pop()\r\n        #         curString = prevString + curString * num\r\n        #     elif i.isdigit():\r\n        #         curNum = curNum * 10 + int(i)\r\n        #     else:\r\n        #         curString += i\r\n        # return curString\r\n```\r\n\r\n复杂度分析\r\n\r\n时间复杂度：方法1 O(N^2)，方法2 O(N)\r\n空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"absent1353":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836244897","body":"### 思路：\r\n将list转成数值，求和之后，分别取余/取除数，然后倒序输出\r\n### 代码：\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = 0\r\n        for n in num:\r\n            res = res * 10 + n \r\n        res += k\r\n        result = []\r\n        while(res>=0):\r\n            num = res%10\r\n            res/=10\r\n            result.append(num)\r\n        return result[::-1]\r\n```\r\n### 复杂度\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838397776","body":"## 思路\r\n- 1.空间换时间\r\n 先将给定字符出现的位置保存在一个下标数组中，遍历整个数组，求整个数组的值到下标数组的最小距离绝对值\r\n- 2.双指针方法\r\n#### 方法1\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        num = []\r\n        n = len(s)\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                num.append(i)\r\n        result = []\r\n        for i in range(n):\r\n            result.append(min([abs(i-nu)for nu in num]))\r\n        return result\r\n```\r\n#### 方法2：\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(s):\r\n            if x == c: prev = i\r\n            ans.append(i - prev)\r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans\r\n```\r\n##复杂度分析\r\n- 1.空间换时间复杂度\r\n    时间复杂度为$O(N*K)$\r\n    空间复杂度为$O(N)$\r\n- 2.双指针方法\r\n    时间复杂度为 $O(n)$\r\n    空间复杂度为$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838397776","body":"## 思路\r\n- 1.空间换时间\r\n 先将给定字符出现的位置保存在一个下标数组中，遍历整个数组，求整个数组的值到下标数组的最小距离绝对值\r\n- 2.双指针方法\r\n#### 方法1\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        num = []\r\n        n = len(s)\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                num.append(i)\r\n        result = []\r\n        for i in range(n):\r\n            result.append(min([abs(i-nu)for nu in num]))\r\n        return result\r\n```\r\n#### 方法2：\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(s):\r\n            if x == c: prev = i\r\n            ans.append(i - prev)\r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans\r\n```\r\n##复杂度分析\r\n- 1.空间换时间复杂度\r\n    时间复杂度为$O(N*K)$\r\n    空间复杂度为$O(N)$\r\n- 2.双指针方法\r\n    时间复杂度为 $O(n)$\r\n    空间复杂度为$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840641670","body":"### 思路\r\n构建辅助栈，从后向前遍历字符串s中每个字符，将非数字的字符入栈，后续栈需要反转\r\n### 代码\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack=[]\r\n        length = len(s)\r\n        i = length - 1\r\n        while i>=0:\r\n            if not s[i].isdigit():\r\n                stack.append(s[i])\r\n                i -= 1\r\n            else:\r\n                num = ''\r\n                while s[i].isdigit() and i>=0:\r\n                    num = s[i]+num\r\n                    i -= 1\r\n                sub = ''\r\n                while stack[-1]!=']':\r\n                    tmp = stack.pop()\r\n                    if tmp != '[':\r\n                        sub += tmp\r\n                stack.pop()\r\n                sub = int(num)*sub\r\n                stack.append(sub)\r\n        stack.reverse()\r\n        return ''.join(stack)\r\n```\r\n### 复杂度分析\r\n-- 时间复杂度：O(N)\r\n-- 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aouos":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836268613","body":"## 思路：\r\n从数组尾部取值与 K 相加\r\n\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n  const ans = [];\r\n  let len = num.length;\r\n\r\n  for (let i = len - 1; i >= 0 || k > 0; i--) {\r\n    if (i >= 0) {\r\n      k += num[i];\r\n    }\r\n    ans.push(k % 10);\r\n    k = parseInt(k / 10);\r\n  }\r\n\r\n  return ans.reverse();\r\n};\r\n```\r\n\r\n- 时间复杂度 O(N)\r\n- 空间复杂度 O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838192744","body":"## 代码：\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n  let ans = new Array(s.length).fill(10001);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) {\r\n      ans[i] = 0;\r\n      continue;\r\n    }\r\n    if (s[i - 1] !== void 0) {\r\n      ans[i] = ans[i - 1] + 1;\r\n    }\r\n  }\r\n\r\n  for (let j = s.length - 1; j >= 0; j--) {\r\n    if (s[j + 1] !== void 0) {\r\n      ans[j] = Math.min(ans[j], ans[j + 1] + 1);\r\n    }\r\n  }\r\n\r\n  return ans;\r\n};\r\n```\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838192744","body":"## 代码：\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n  let ans = new Array(s.length).fill(10001);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) {\r\n      ans[i] = 0;\r\n      continue;\r\n    }\r\n    if (s[i - 1] !== void 0) {\r\n      ans[i] = ans[i - 1] + 1;\r\n    }\r\n  }\r\n\r\n  for (let j = s.length - 1; j >= 0; j--) {\r\n    if (s[j + 1] !== void 0) {\r\n      ans[j] = Math.min(ans[j], ans[j + 1] + 1);\r\n    }\r\n  }\r\n\r\n  return ans;\r\n};\r\n```\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840561718","body":"## 思路\r\n\r\n辅助栈\r\n\r\n## 代码\r\n```js\r\nvar decodeString = function (s) {\r\n  const stack = [];\r\n\r\n  for (const char of s) {\r\n    if (char === ']') {\r\n      let repeatStr = '';\r\n      while (stack[stack.length - 1] !== '[') {\r\n        repeatStr = stack.pop() + repeatStr;\r\n      }\r\n      stack.pop();\r\n      let repeatNum = '';\r\n      while (stack[stack.length - 1] >= '0' && stack[stack.length - 1] <= '9') {\r\n        repeatNum = stack.pop() + repeatNum;\r\n      }\r\n      repeatStr = repeatStr.repeat(parseInt(repeatNum));\r\n      stack.push(repeatStr);\r\n    } else {\r\n      stack.push(char);\r\n    }\r\n  }\r\n\r\n  return stack.join('');\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangyi123456":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836270960","body":"## 题目思路\r\n1.拆开每一位，用进位相加\r\n2.当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\r\n\r\n## 代码\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int sum = 0, carry = 0;\r\n        int i = num.length-1;\r\n        List<Integer> res = new LinkedList<Integer>();\r\n        while(i>=0 || k>0){\r\n            int x = i>=0? num[i]:0;\r\n            int y = k>0?  k%10:0;\r\n            sum = x+y+carry;\r\n            carry = sum/10;\r\n            i -= 1;\r\n            k = k/10;\r\n            res.add(0,sum%10);\r\n        }\r\n        if(carry!=0) res.add(0,carry);\r\n        return res;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n时间复杂度 max(n,k) n为数组长度，k为数字位数\r\n空间复杂度 max(n,k) n为数组长度，k为数字位数"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840580971","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr\r\n                # pop 掉 \"[\"\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount\r\n                stack.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzcyx":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836272330","body":"# c++\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int>ans;int carry=0;\r\n        for(int i=num.size()-1;i>=0;i--)\r\n        {\r\n            int a=k%10;k/=10;\r\n            int b=(num[i]+a+carry)%10;\r\n            carry=(num[i]+a+carry)/10;\r\n            ans.push_back(b);\r\n        }\r\n        while(k>0||carry>0)\r\n        {   int b=k%10;k/=10;\r\n            ans.push_back((b+carry)%10);\r\n            carry=(b+carry)/10;\r\n        }\r\n        reverse(ans.begin(),ans.end());\r\n         return ans;\r\n    }\r\n};\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838286251","body":"### 解题思路\r\n参考官方题解，用`pre`存储上一个c出现的位置，当```s[i]=c```时更新```pre=i```\r\n先从左到右遍历，`i-pre`即为到改字符往左到c的距离\r\n在从右到左遍历，`pre-i`即为到改字符往右到c的距离，取左右距离的最小值\r\n### 代码\r\n### c++\r\n```class Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int>ans(s.size());\r\n        int i,pre=-999999;\r\n        for(i=0;i<s.size();i++)\r\n        {\r\n            if(s[i]==c)pre=i;\r\n            ans[i]=i-pre;\r\n        }\r\n        pre=999999;\r\n        for(i=s.size()-1;i>=0;i--)\r\n        {\r\n            if(s[i]==c)pre=i;\r\n            ans[i]=min(ans[i],pre-i);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838286251","body":"### 解题思路\r\n参考官方题解，用`pre`存储上一个c出现的位置，当```s[i]=c```时更新```pre=i```\r\n先从左到右遍历，`i-pre`即为到改字符往左到c的距离\r\n在从右到左遍历，`pre-i`即为到改字符往右到c的距离，取左右距离的最小值\r\n### 代码\r\n### c++\r\n```class Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int>ans(s.size());\r\n        int i,pre=-999999;\r\n        for(i=0;i<s.size();i++)\r\n        {\r\n            if(s[i]==c)pre=i;\r\n            ans[i]=i-pre;\r\n        }\r\n        pre=999999;\r\n        for(i=s.size()-1;i>=0;i--)\r\n        {\r\n            if(s[i]==c)pre=i;\r\n            ans[i]=min(ans[i],pre-i);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840630858","body":"C++\r\n```\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res;\r\n        stack<int>num;\r\n        stack<string>str;\r\n        int curNum=0;\r\n        for(char c:s)\r\n        {\r\n            if(c>='0'&c<='9')\r\n                curNum=curNum*10+c-'0';\r\n            else if(c>='a'&&c<='z')\r\n                res+=c;\r\n            else if(c=='[')\r\n                {num.push(curNum);\r\n                 curNum=0;\r\n                 str.push(res);\r\n                 res=\"\";\r\n                }\r\n            else if(c==']')\r\n                {\r\n                    string tmp=str.top();str.pop();int n=num.top();num.pop();\r\n                    for(int i=0;i<n;i++)\r\n                        tmp+=res;\r\n                    res=tmp;\r\n                }\r\n                \r\n        }\r\n        return res;\r\n    }\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linzeliang1222":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836279098","body":"## 思路\r\n\r\n-   从最低位开始加，满10用carry进1，最后还要判断最终有没有进1位\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        ArrayList<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length - 1;\r\n        int carry = 0;\r\n\r\n        while (n >= 0 || k != 0) {\r\n            int a = n < 0 ? 0 : num[n];\r\n            int b = k % 10;\r\n\r\n            int temp = (a + b + carry) % 10;\r\n            carry = (a+ b + carry) / 10;\r\n            res.add(temp);\r\n            n--;\r\n            k /= 10;\r\n        }\r\n        if (carry == 1) {\r\n            res.add(1);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$\r\n- 空间复杂度：$O(N)$"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838618559","body":"## 思路\r\n\r\n-   使用一个res数组，而且要初始化为Integer.MAX_VALUE\r\n\r\n-   从左到右遍历字符串，直到遇到我们的目标字符时候停下来\r\n\r\n-   以目标字符为中心，pre和next双指针向两边移动，并且给数组赋值，从1开始递增\r\n\r\n-   如果指针再移动过程中遇到当前的值大于等于左边/右边的值，那么就结束该指针的移动\r\n\r\n    ![](https://img2020.cnblogs.com/blog/2067154/202011/2067154-20201102004404706-1773904769.png)\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nimport java.util.Arrays;\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int len = S.length();\r\n        int[] res = new int[len];\r\n        // 填充最大值\r\n        Arrays.fill(res, Integer.MAX_VALUE);\r\n\r\n        for (int i = 0; i < len; i++) {\r\n            //每次遇到e时候，就进行pre和next的移动\r\n            if (S.charAt(i) == C) {\r\n                res[i] = 0;\r\n                int pre = i-1;\r\n                int next = i+1;\r\n                int t = 1;\r\n                // 赋值的条件是t要小于等于前一个/后一个元素的值\r\n                // 进行左移动赋值\r\n                while (pre >= 0 && t < res[pre]) {\r\n                    res[pre--] = t++;\r\n                }\r\n                t = 1;\r\n                // 进行右移动赋值\r\n                while (next < len && t < res[next]) {\r\n                    res[next++] = t++;\r\n                }\r\n            }\r\n        }\r\n        // 得到结果\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N^2)$，其中 N 为字符串长度。\r\n- 空间复杂度：$O(N)$，其中 N 为res数组长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838618559","body":"## 思路1\r\n\r\n-   使用一个res数组，而且要初始化为Integer.MAX_VALUE\r\n\r\n-   从左到右遍历字符串，直到遇到我们的目标字符时候停下来\r\n\r\n-   以目标字符为中心，pre和next双指针向两边移动，并且给数组赋值，从1开始递增\r\n\r\n-   如果指针再移动过程中遇到当前的值大于等于左边/右边的值，那么就结束该指针的移动\r\n\r\n    ![](https://img2020.cnblogs.com/blog/2067154/202011/2067154-20201102004404706-1773904769.png)\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int len = S.length();\r\n        int[] res = new int[len];\r\n        // 填充最大值\r\n        Arrays.fill(res, Integer.MAX_VALUE);\r\n\r\n        for (int i = 0; i < len; i++) {\r\n            //每次遇到e时候，就进行pre和next的移动\r\n            if (S.charAt(i) == C) {\r\n                res[i] = 0;\r\n                int pre = i-1;\r\n                int next = i+1;\r\n                int t = 1;\r\n                // 赋值的条件是t要小于等于前一个/后一个元素的值\r\n                // 进行左移动赋值\r\n                while (pre >= 0 && t < res[pre]) {\r\n                    res[pre--] = t++;\r\n                }\r\n                t = 1;\r\n                // 进行右移动赋值\r\n                while (next < len && t < res[next]) {\r\n                    res[next++] = t++;\r\n                }\r\n            }\r\n        }\r\n        // 得到结果\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N^2)$，其中 N 为字符串长度。\r\n- 空间复杂度：$O(N)$，其中 N 为res数组长度\r\n\r\n## 思路2\r\n\r\n-   正向遍历一次，反向遍历一次\r\n-   用`pre`标记出现目标字符的位置，利用`i`的自增，同时给数组赋值\r\n-   正向遍历是给目标字符之后到下一个目标字符之前进行赋值，反向遍历则相反\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        // 必须要除以2，因为Integer.MIN_VALUE已经是最小值了，又因为i>=0，所以 i-pre 会超过整型最大值\r\n        int pre = Integer.MIN_VALUE / 2;\r\n        \r\n        // 正向遍历\r\n        for (int i = 0; i < len; i++) {\r\n            if (s.charAt(i) == c) {\r\n                pre = i;\r\n            }\r\n            res[i] = i - pre;\r\n        }\r\n\r\n        // 反向遍历\r\n        pre = Integer.MAX_VALUE;\r\n        for (int i = len - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                pre = i;\r\n            }\r\n            res[i] = Math.min(res[i], pre - i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，其中 N 为字符串长度。\r\n- 空间复杂度：$O(N)$，其中 N 为res数组长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840641163","body":"## 思路\r\n\r\n-   创建两个栈进行解题，一个用来存放数字，另一个用来临时存放子字符串\r\n-   由于可能会在`[]`中还包含其他的`[]`，所以我们只要遇到`[`就先将其前面的字符串暂时入栈，稍后再进行计算\r\n-   如果遇到`]` ，则将存放数字的栈和存放子字符串的栈分别出栈一个，然后进行字符串的拼接，然后再将该字符串作为答案的一部分进行下一轮迭代计算\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Deque<Integer> times = new LinkedList<Integer>();\r\n        Deque<String> stringStack = new LinkedList<String>();\r\n        StringBuilder res = new StringBuilder();\r\n        int count = 0;\r\n\r\n        for (Character c : s.toCharArray()) {\r\n            // 如果为数字，则记录数字，数字有可能有十位或者百位\r\n            if (isNum(c)) {\r\n                count = count * 10 + Integer.parseInt(\"\" + c);\r\n            } else if (c == '[') { // 如果为左中括号，则将数字和当前的res进栈\r\n                times.push(count);\r\n                stringStack.push(res.toString());\r\n                // 注意还要将res置空，因为要开始下一轮的字符串统计，上一轮的字符串已经先暂存到栈中去了\r\n                res = new StringBuilder();\r\n                // 次数也要置为0\r\n                count = 0;\r\n            } else if (c == ']') { // 如果为右中括号，则要开始计算本次统计的res，添加到上一个字符串的末尾\r\n                // 获取次数\r\n                count = times.pop();\r\n                StringBuilder curString = new StringBuilder(stringStack.pop());\r\n                for (int i = 0; i < count; i++) {\r\n                    curString.append(res);\r\n                }\r\n                // 将拼接好后的字符串作为结果进行下一轮迭代\r\n                res = curString;\r\n                count = 0;\r\n            } else {\r\n                // 如果都是字母的话仅进行平解字符串即可\r\n                res.append(c);\r\n            }\r\n        }\r\n\r\n        return res.toString();\r\n    }\r\n\r\n    public boolean isNum(char c) {\r\n        // 判断字符是否为数字\r\n        if (c <= '9' && c >= '0') {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$，N为字符串的长度\r\n- 空间复杂度：$O(N)$，N为字符串的长度"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Yvonne1231-Wang":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836281956","body":"### 解题思路\r\n将数组num的最后一位从后往前与k从个位开始依次相加，若加起来后的总数小于10则直接推入栈中；若总数大于10，则将k的进位加1，将总数减去10以后推入栈中。\r\n##需要注意点：\r\n1.不能忘记k的位数或者加起来总数的位数大于原本的数组num的长度点情况，所以数组遍历结束还要判断k是否为0了，若没有，再将k依次推入；\r\n2.不要忘记反转数组，如果改成unshift()则不用；\r\n3.最开始想的办法是将num先转换成数字，与k相加后变成字符串再变成数组，但是忽略了num长度很长变成数字后再相加会溢出的情况。\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let a,res=[];\r\n    for(let i = num.length-1; i >= 0; i--)\r\n    {\r\n        a = num[i] + k % 10;\r\n        k = Math.floor(k/10);\r\n        if(a >= 10){\r\n            ++k;\r\n            a = a-10;\r\n        };\r\n        res.push(a);\r\n    }\r\n    while(k!=0){\r\n        res.push(k%10);\r\n        k = Math.floor(k/10);\r\n    }\r\n    \r\n    return res.reverse();\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n) ----只开辟了两个新数据，a和res，其中a是常量阶的，与数据规模无关。res是一个大小与n有关的数组，所以空间复杂度为O(n)\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838232128","body":"### 解题思路\r\n把字符串s以字符串c作为separator分割为数组，然后计算数组每个元素的长度\r\n第一个元素和最后一个元素离得最近的距离单独推入\r\n数组中间的元素判断长度是偶数还是奇数，两种情况推入距离\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let sArr = s.split(c);\r\n    let len = sArr.length;\r\n    let res = [];\r\n    for(let i = sArr[0].length; i >=0; i--){\r\n        res.push(i);\r\n    }\r\n    for (let i=1; i < len-1; i++){\r\n        if(sArr[i].length % 2 == 0){\r\n            for(let j=1; j <= Math.floor(sArr[i].length/2); j++){\r\n            res.push(j);\r\n            }\r\n            for(let j = Math.floor(sArr[i].length/2); j >=0; j--){\r\n            res.push(j);\r\n            }\r\n        }else{\r\n            for(let j=1; j <= Math.floor(sArr[i].length/2); j++){\r\n            res.push(j);\r\n            }\r\n            res.push(Math.floor(sArr[i].length/2) +1)\r\n            for(let j = Math.floor(sArr[i].length/2); j >=0; j--){\r\n            res.push(j);\r\n            }\r\n        }\r\n    }\r\n    for(let i = 1; i <= sArr[len-1].length; i++){\r\n        res.push(i);\r\n    }\r\n    return res\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n) n为字符串s的长度\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838232128","body":"### 解题思路\r\n把字符串s以字符串c作为separator分割为数组，然后计算数组每个元素的长度\r\n第一个元素和最后一个元素离得最近的距离单独推入\r\n数组中间的元素判断长度是偶数还是奇数，两种情况推入距离\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let sArr = s.split(c);\r\n    let len = sArr.length;\r\n    let res = [];\r\n    for(let i = sArr[0].length; i >=0; i--){\r\n        res.push(i);\r\n    }\r\n    for (let i=1; i < len-1; i++){\r\n        if(sArr[i].length % 2 == 0){\r\n            for(let j=1; j <= Math.floor(sArr[i].length/2); j++){\r\n            res.push(j);\r\n            }\r\n            for(let j = Math.floor(sArr[i].length/2); j >=0; j--){\r\n            res.push(j);\r\n            }\r\n        }else{\r\n            for(let j=1; j <= Math.floor(sArr[i].length/2); j++){\r\n            res.push(j);\r\n            }\r\n            res.push(Math.floor(sArr[i].length/2) +1)\r\n            for(let j = Math.floor(sArr[i].length/2); j >=0; j--){\r\n            res.push(j);\r\n            }\r\n        }\r\n    }\r\n    for(let i = 1; i <= sArr[len-1].length; i++){\r\n        res.push(i);\r\n    }\r\n    return res\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n) n为字符串s的长度\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840478164","body":"# 方法一：只用一个栈\r\n### 解题思路\r\n1.依次扫描字符串s的各个元素，如果遇到数字字符，不能忘记考虑\"100\"这种连续数字的情况；如果是第一次遇到数字字符，则推入栈中，若栈顶已经是数字字符，则把目前的字符拼接到栈顶数字字符的后面；（看到题解中还有一种处理连续数字字符的方法，就是把遇到\"[\"之前的数字字符拼接到一起）\r\n2.如果遇到\"[\"或者字母则直接推入栈中；\r\n3.如果遇到\"]\",则依次从栈中取出字母拼接成临时字符串，直到遇到\"[\"；然后再取出\"[\"前面的一个元素，即这个临时字符串需要重复的次数。最后把重复完的临时字符串推入栈中。\r\n4.遍历结束后，不能忘了要把stack里所有字符串拼接起来，分清楚拼接顺序。\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let stack = [];\r\n    for (i = 0; i < s.length; i++){\r\n        if(s[i]>=\"0\" && s[i]<=\"9\"){\r\n            //考虑”100“这种连续数字字符的可能性\r\n            if(stack[stack.length-1]>=\"0\" && stack[stack.length-1]<=\"9\"){\r\n                stack[stack.length-1] += s[i]\r\n                continue;\r\n            }\r\n            stack.push((s[i]))            \r\n        }else{\r\n            if(s[i] == \"]\"){\r\n                let letter = stack.pop();\r\n                let resPart = \"\";\r\n                let resPartAll = \"\";\r\n                while( letter != '['){\r\n                    resPart = letter + resPart;\r\n                    letter=stack.pop();\r\n                }\r\n                let num = Number(stack.pop());\r\n                for (let i=0; i < num; i++){\r\n                    resPartAll = resPartAll+resPart;\r\n                }\r\n                stack.push(resPartAll);\r\n\r\n            }\r\n            //其他情况即\"[\"或者是字母时，直接入栈\r\n            else {\r\n                stack.push(s[i])\r\n            }\r\n        }\r\n    }\r\n    //最后不能忘了要把stack里所有字符串拼接起来（此处注意，不能直接let res而不赋值，会把\"undefined\"一起拼接上去）\r\n    let res=\"\";\r\n    for(i = 0; i < stack.length; i++){\r\n        res += stack[i];\r\n    }\r\n    return res\r\n    \r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(k)----k是字符串的长度\r\n空间复杂度：O(k)----k是字符串的长度\r\n\r\n# 方法二：双栈\r\n### 解题思路\r\n和一个栈类似，需要注意的是最开始字符串栈strStack会推入一个空字符串！！\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let isNum = (e) =>  e >= \"0\" && e <= \"9\";\r\n    let numStack = [];\r\n    let strStack = [];\r\n    let num = 0; \r\n    let char = \"\";//字母暂存处,等待被处理的字符串\r\n    for(i = 0; i < s.length; i++){\r\n        if (isNum(s[i])){\r\n            num = num * 10 + Number(s[i])\r\n        }else if(s[i] == \"[\"){\r\n            numStack.push(num);\r\n            num = 0;\r\n            strStack.push(char);//如果遇到\"[\"说明是嵌套结构，推入字符串栈，等会处理\r\n            char = \"\";\r\n        }else if(s[i] == \"]\"){\r\n            char = strStack.pop() + char.repeat(numStack.pop());\r\n        }else{\r\n            char += s[i]; //遇到连续的字母要拼接起来 \r\n        }\r\n    }\r\n\r\n    return char\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(k)----k是字符串的长度\r\n空间复杂度：O(k)----k是字符串的长度"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Liuqibaa":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836300543","body":"C++\r\n\r\n### 思路\r\n\r\n将向量编程整数，然后相加，再变成向量\r\n\r\n### 代码\r\n\r\n\r\n```c\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int nums = 0;\r\n        int tens = 1;\r\n        vector<int> result;\r\n        for(int i = num.size() - 1; i >= 0; i --){\r\n            nums += num[i] * tens;\r\n            tens *= 10;\r\n        }\r\n        nums += k;\r\n        while(nums){\r\n            int num1 = nums % 10;\r\n            result.push_back(num1);\r\n            nums /= 10;\r\n        }\r\n        reverse(result.begin(), result.end());\r\n        return result;\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838128260","body":"### 思路\r\n\r\n用双指针法：先新建一个向量，大小为字符串大小，元素值全为1，然后遍历，将为c的位置均为0；再定义两个指针，同时一前一后搜索为0的；之前的代码无法实现，现在这个代码可以实现\r\n代码是C++的\r\n\r\n### 代码\r\n\r\n\r\n``c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int size1 = s.size();\r\n        vector<int> result(size1, 1);\r\n        for(int i = 0; i < size1 ; i ++){\r\n            if(s[i] == c){\r\n                result[i] = 0;\r\n            }\r\n        }\r\n\r\n        for(int k = 0; k < size1; k ++){\r\n            int i = k;\r\n            int j = k;\r\n            if(result[k] != 0){\r\n                while(result[i] != 0 && result[j] != 0){\r\n                    i --; if(i < 0) i = 0;\r\n                    j ++; if(j > size1 - 1) j = size1 - 1;\r\n                }\r\n                if(result[i] == 0) {\r\n                    result[k] = k - i;\r\n                } else{\r\n                    result[k] = j - k;\r\n                }\r\n            } \r\n        }\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838128260","body":"### 思路\r\n\r\n用双指针法：先新建一个向量，大小为字符串大小，元素值全为1，然后遍历，将为c的位置均为0；再定义两个指针，同时一前一后搜索为0的；之前的代码无法实现，现在这个代码可以实现\r\n代码是C++的\r\n\r\n### 代码\r\n\r\n\r\n``c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int size1 = s.size();\r\n        vector<int> result(size1, 1);\r\n        for(int i = 0; i < size1 ; i ++){\r\n            if(s[i] == c){\r\n                result[i] = 0;\r\n            }\r\n        }\r\n\r\n        for(int k = 0; k < size1; k ++){\r\n            int i = k;\r\n            int j = k;\r\n            if(result[k] != 0){\r\n                while(result[i] != 0 && result[j] != 0){\r\n                    i --; if(i < 0) i = 0;\r\n                    j ++; if(j > size1 - 1) j = size1 - 1;\r\n                }\r\n                if(result[i] == 0) {\r\n                    result[k] = k - i;\r\n                } else{\r\n                    result[k] = j - k;\r\n                }\r\n            } \r\n        }\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sitequ":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836300870","body":"**语言：python3**\r\n\r\n### 思路\r\n1.整型数组转化字符数组，再化为非负整数\r\n2.与k相加\r\n3.数字还原成字符数组，再化为整型数组\r\n\r\n### 代码\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num = map(str, num)\r\n        str2int = int(''.join(num)) + k\r\n        Output = list(str(str2int))\r\n        for i in range(0,len(Output)):\r\n            Output[i] = int(Output[i])\r\n        return Output\r\n```\r\n### 复杂度分析\r\n时间复杂度O(n)\r\n空间复杂度O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838443247","body":"**语言：python3**\r\n\r\n### 思路\r\n1. 获得所有c的位置\r\n2. s的每个字符的位置与c的位置做差，排序找到最小，将值作为元素返回\r\n3. 返回最终最短距离列表\r\n\r\n### 代码\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = len(s)\r\n        Output = []\r\n        num_c = []\r\n        for i in range(0,l):\r\n            if s[i] == c :\r\n                num_c.append(i)\r\n\r\n        L = len(num_c)\r\n\r\n        for i in range(0,l):\r\n            K = []\r\n            for m in range(0,L):\r\n                K.append(abs(i - num_c[m]))\r\n            K = sorted(K)\r\n            Output.append(K[0])\r\n\r\n        return Output\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：Worst case O(N^2)\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838443247","body":"**语言：python3**\r\n\r\n### 思路\r\n1. 获得所有c的位置\r\n2. s的每个字符的位置与c的位置做差，排序找到最小，将值作为元素返回\r\n3. 返回最终最短距离列表\r\n\r\n### 代码\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = len(s)\r\n        Output = []\r\n        num_c = []\r\n        for i in range(0,l):\r\n            if s[i] == c :\r\n                num_c.append(i)\r\n\r\n        L = len(num_c)\r\n\r\n        for i in range(0,l):\r\n            K = []\r\n            for m in range(0,L):\r\n                K.append(abs(i - num_c[m]))\r\n            K = sorted(K)\r\n            Output.append(K[0])\r\n\r\n        return Output\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：Worst case O(N^2)\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840414996","body":"**语言：python3**\r\n\r\n### 思路：\r\n1.先将字符串拆分，注意两位数以上的整数情况\r\n2.依次pop字符入栈，同时开辟记录 '[' 和 ']' 的位置的数组\r\n3.当有[出现时，记录需要倍增的字符串入栈，相应的[,]，以及字符出栈，记录相应位置的元素也要清除\r\n4.最终将栈内的字符串reverse并且join，返回结果\r\n\r\n\r\n### 代码：\r\n\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        A_A = re.findall(r'[a-z]+|\\d+|\\[+|\\]+',s)\r\n        a_a = list()\r\n        for p in range(0, len(A_A)):\r\n            if A_A[p].isdigit():\r\n                a_a.append(A_A[p])\r\n            else:\r\n                M = list(A_A[p])\r\n                for q in range(0, len(M)):\r\n                    a_a.append(M[q])\r\n        AA = a_a       \r\n        cache = list()\r\n        mark = list()\r\n        l = len(AA)\r\n        k = 'o'\r\n        for i in range(0,l):\r\n            cache.append(AA[l-1-i])\r\n            if AA[l-1-i] == ']' :\r\n                mark.append(len(cache)-1)\r\n            if AA[l-1-i] == '[':\r\n                mark.append(len(cache)-1)\r\n                K = cache[(mark[len(mark)-2]+1):mark[len(mark)-1]]\r\n                k = ''.join(reversed(K))\r\n                for j in range(0,(mark[len(mark)-1]+1-mark[len(mark)-2])):\r\n                    cache.pop()\r\n                cache.append(k)\r\n                for t in range(0,2):\r\n                    mark.pop()\r\n            if AA[l-1-i].isdigit():\r\n                cache.pop()\r\n                cache.append(k*(int(AA[l-1-i])-1))\r\n        Output = ''.join(reversed(cache))\r\n        return Output\r\n```\r\n\r\n### 复杂度分析：\r\n时间复杂度：O(N^2)\r\n空间复杂度：O(N^2)\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaotuanzi999":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836303348","body":"### 思路 \r\n首先，作为小白，我的第一思路就是将数组转换真正的值，然后与k相加，最后将相加的和转化为List。\r\n```\r\n public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int lenth = num.length;\r\n       List<Integer> res = new ArrayList<>();\r\n       int sum=k;\r\n        int n=1;\r\n        for (int i = lenth-1; i>=0; i--){\r\n            sum+= n*num[i];\r\n            n*=10;\r\n        }\r\n        String temp = Integer.toString(sum);\r\n        for (int i = temp.length()-1; i>=0;i--){\r\n            res.add(Integer.parseInt(temp.substring(i,i+1)));\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n```\r\n\r\n然而结果不尽人意。正常的数字可以得到正确的结果。但当数字特别大的时候会出现下面的情况，我还debug了查看。之后查询才知道是溢出了，超出int的精度范围。\r\n\r\n\r\n从后往前遍历数组，就是从数组的低位开始。与k进行相加，并对k与10取余，得到最低位。然后k%10得到进位。\r\n中间存在num的数组整体的小于k的情况，所以需要对i进行判断。\r\n### 代码\r\n```\r\nclass Solution {\r\n      public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int lenth = num.length;\r\n        List<Integer> res = new ArrayList<>();\r\n        for (int i = lenth-1; i>=0||k>0; i--,k/=10){\r\n            // 如果num数组存在数组，因为存在k>num的情况\r\n            if (i>=0){\r\n                k+=num[i];\r\n            }\r\n            res.add(k%10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838038240","body":"### 思路\r\n从左往右遍历计算离左边最近的距离；\r\n从右往左遍历计算离右边最近的距离。\r\n但是存在初始时，c位置的位置设定。从左往右设置为最小，这样他们之间差值就很大。从而在从右往左遍历时可以更新其的值。\r\n\r\n### 代码\r\n```\r\n public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] res = new int[length];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        for (int i=0; i<length; i++){\r\n            if (s.charAt(i)==c) prev = i;\r\n                res[i] = i-prev;\r\n        }\r\n        prev = Integer.MAX_VALUE/2;\r\n        for (int i = length-1; i>=0; i--){\r\n            if (s.charAt(i)==c) prev = i;\r\n                res[i] = Math.min(res[i],prev-i);\r\n        }\r\n        return res;\r\n    }\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838038240","body":"### 思路\r\n从左往右遍历计算离左边最近的距离；\r\n从右往左遍历计算离右边最近的距离。\r\n但是存在初始时，c位置的位置设定。从左往右设置为最小，这样他们之间差值就很大。从而在从右往左遍历时可以更新其的值。\r\n\r\n### 代码\r\n```\r\n public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] res = new int[length];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        for (int i=0; i<length; i++){\r\n            if (s.charAt(i)==c) prev = i;\r\n                res[i] = i-prev;\r\n        }\r\n        prev = Integer.MAX_VALUE/2;\r\n        for (int i = length-1; i>=0; i--){\r\n            if (s.charAt(i)==c) prev = i;\r\n                res[i] = Math.min(res[i],prev-i);\r\n        }\r\n        return res;\r\n    }\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jmaStella":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836305778","body":"## 解题思路\r\n尝试数字全拿出来然后+K再放回去，结果发现lc有很大的test case，可能就是故意不想让你用这种方法，然后 重新尝试，先把K加到最后一个A的数字，然后取%10的值，循环下去。写了第二遍了还是不能一遍写出来。。。大无语时间发生了。\r\n\r\n\r\n\r\n## 代码\r\n`\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n\r\n    List<Integer> newA = new ArrayList<>();\r\n\r\n    int temp = K;\r\n\r\n    for(int i = A.length-1; i>=0; i--){\r\n\r\n        temp = temp+ A[i];\r\n        newA.add(0, temp%10);\r\n        temp=temp/10;\r\n    }\r\n    while(temp !=0){\r\n        newA.add(0, temp%10);\r\n        temp=temp/10;\r\n    }\r\n    return newA;\r\n    }\r\n`\r\n以为会变得更快，结果并没有\r\n`\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n\r\n    List<Integer> newA = new ArrayList<>();\r\n\r\n    int temp = K;\r\n    int index = A.length-1;\r\n    while(temp !=0 || index >=0){\r\n        if(index >=0){\r\n            temp = temp+ A[index];\r\n        }    \r\n        newA.add(0, temp%10);\r\n        temp=temp/10;\r\n        index --;\r\n    }\r\n\r\n    return newA;\r\n    }\r\n`\r\n\r\n## 复杂度分析\r\n时间复杂度O(max(n, log(K)))\r\n空间复杂度O(max(n, log(K)))\r\n\r\n\r\n喜欢解析里一个人的总结，mark一下。\r\n\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n\r\n作者：lilyunoke\r\n链接：https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/\r\n来源：力扣（LeetCode）\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837949838","body":"## 思路\r\n以为自己写的是暴力，结果好像不是？感觉比较redundant。先在string里搜一遍c，index存下来，然后再双指针（不确定是不是双指针），这个写法非常有问题，要手动handle各种edge case\r\n\r\n## 代码\r\n\r\n`\r\n    public int[] shortestToChar(String s, char c) {\r\n        List<Integer> c_index= new ArrayList<Integer>();\r\n        int result[] = new int[s.length()];\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            if(c ==s.charAt(i)){\r\n                c_index.add(i);\r\n            }\r\n        }\r\n        int first= 0;\r\n        int second = 0;\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            if(c_index.size()>1 && second<c_index.size() && i>=c_index.get(second)){\r\n                 first = second;\r\n                 if(second != c_index.size()-1 ){\r\n                     second++;\r\n                 }\r\n            }\r\n\r\n            if(i <= c_index.get(first)){\r\n                result[i] =Math.abs(c_index.get(first)-i);\r\n            }else if(i>c_index.get(first) && i<c_index.get(second)){\r\n                result[i] =Math.min(Math.abs(c_index.get(first)-i),Math.abs(c_index.get(second)-i));\r\n            }else{\r\n                result[i] =Math.abs(c_index.get(second)-i);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n`\r\n## 复杂度\r\n时间 O(n)\r\n空间O(n)\r\n\r\n\r\n## 思路\r\n看了答案重新写了一遍\r\n最短的距离无非就是左边的或者右边的\r\n先是从左往右loop一遍，记录，然后从右往左loop一遍，比较之前的大小，选更小的\r\n## 代码\r\n\r\n`\r\n    public int[] shortestToChar(String s, char c) {\r\n        int result[] = new int[s.length()];\r\n        int prev = Integer.MIN_VALUE/2;\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            result[i] =i-prev;\r\n        }\r\n\r\n\r\n        for(int i = s.length()-1; i>=0; --i){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            result[i] = Math.min(result[i], Math.abs(prev-i));\r\n        }\r\n        return result;\r\n\r\n    }\r\n`\r\n## 复杂度\r\n时间 O(n)\r\n空间O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837949838","body":"## 思路\r\n以为自己写的是暴力，结果好像不是？感觉比较redundant。先在string里搜一遍c，index存下来，然后再双指针（不确定是不是双指针），这个写法非常有问题，要手动handle各种edge case\r\n\r\n## 代码\r\n\r\n`\r\n    public int[] shortestToChar(String s, char c) {\r\n        List<Integer> c_index= new ArrayList<Integer>();\r\n        int result[] = new int[s.length()];\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            if(c ==s.charAt(i)){\r\n                c_index.add(i);\r\n            }\r\n        }\r\n        int first= 0;\r\n        int second = 0;\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            if(c_index.size()>1 && second<c_index.size() && i>=c_index.get(second)){\r\n                 first = second;\r\n                 if(second != c_index.size()-1 ){\r\n                     second++;\r\n                 }\r\n            }\r\n\r\n            if(i <= c_index.get(first)){\r\n                result[i] =Math.abs(c_index.get(first)-i);\r\n            }else if(i>c_index.get(first) && i<c_index.get(second)){\r\n                result[i] =Math.min(Math.abs(c_index.get(first)-i),Math.abs(c_index.get(second)-i));\r\n            }else{\r\n                result[i] =Math.abs(c_index.get(second)-i);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n`\r\n## 复杂度\r\n时间 O(n)\r\n空间O(n)\r\n\r\n\r\n## 思路\r\n看了答案重新写了一遍\r\n最短的距离无非就是左边的或者右边的\r\n先是从左往右loop一遍，记录，然后从右往左loop一遍，比较之前的大小，选更小的\r\n## 代码\r\n\r\n`\r\n    public int[] shortestToChar(String s, char c) {\r\n        int result[] = new int[s.length()];\r\n        int prev = Integer.MIN_VALUE/2;\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            result[i] =i-prev;\r\n        }\r\n\r\n\r\n        for(int i = s.length()-1; i>=0; --i){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            result[i] = Math.min(result[i], Math.abs(prev-i));\r\n        }\r\n        return result;\r\n\r\n    }\r\n`\r\n## 复杂度\r\n时间 O(n)\r\n空间O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840390737","body":"## 思路\r\n借鉴答案还写了1个小时。。\r\n本来想直接loop一遍，然后遇到“[” 开始存repeatstring，遇到\"]\"停下来，按照数字重复几次，但是忽略了套娃情况 3[a2[c]\r\n借鉴了答案以后，用stack, \r\n遇到数字不知道有几位，先暂时保存下来。\r\n遇到“[”先把数字push上去，再push \"[\"\r\n遇到“]”，开始从stack pop，主要目的是把需要repeat的string pop出来，然后按照repeat time 重复，并最后把repeat过的string push到stack上。\r\n所有string s loop完了后，开始把完整的string pop出来\r\n \r\n## 代码\r\n`java\r\n\r\npublic String decodeString(String s) {\r\n        int repeat_time =0;\r\n        \r\n        Stack<String> stack = new Stack<>();\r\n        StringBuilder result =new StringBuilder();\r\n        for(int i=0; i< s.length(); i++){\r\n            char curr = s.charAt(i);\r\n            if(Character.isDigit(curr)){\r\n                repeat_time = repeat_time*10+ (curr-'0');\r\n                \r\n            }else if(curr =='[' ){\r\n                stack.push(String.valueOf(repeat_time) );\r\n                stack.push(\"[\");\r\n                repeat_time=0;\r\n\r\n            }else if(curr ==']'){\r\n                StringBuilder stringBuilder = new StringBuilder();\r\n                StringBuilder repeatString =new StringBuilder();\r\n                String temp = stack.pop();\r\n                while(temp != \"[\" &&stack.size()>0){\r\n                    stringBuilder.append(temp);\r\n                    temp = stack.pop();\r\n                }\r\n\r\n                repeat_time = Integer.parseInt(stack.pop());\r\n                for(int j =0; j<repeat_time; j++){\r\n                    repeatString.append(stringBuilder.toString());\r\n                }\r\n                stack.push(repeatString.toString());\r\n                repeat_time =0;\r\n            }else{\r\n                stack.push(String.valueOf(curr));\r\n            }\r\n        }\r\n        while(!stack.isEmpty()){\r\n            result.append(stack.pop());\r\n        }\r\n        return result.reverse().toString();\r\n    }\r\n`\r\n\r\n## 复杂度\r\n时间 O(N) N=length of String s\r\n空间 O(N)\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liucy0417":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836309752","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n## 前置知识\r\n\r\n- 数组\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n- 从低位相加，组成一个新的数组\r\n\r\n## 关键点\r\n\r\n-  进位问题\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int l = num.length;\r\n        int sum = 0;\r\n        List<Integer> arr = new ArrayList<>();\r\n        for(int i = l - 1; i>=0; i--) {\r\n            sum = num[i] + k % 10;\r\n            if(sum >= 10) {\r\n                sum =sum - 10;\r\n                k = k + 10;\r\n            }\r\n            arr.add(sum);\r\n            k = k / 10;\r\n        }\r\n        while(k != 0) {\r\n            arr.add(k % 10);\r\n            k = k / 10;\r\n        }\r\n        Collections.reverse(arr);\r\n        return arr; \r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。一个for循环，时间复杂度：$O(n)$，开辟了一个新的数组内存，空间复杂度：$O(n)$。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837680823","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 字符串、数组\r\n\r\n## 思路\r\n- 对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\r\n\r\n## 关键点\r\n\r\n-  从左向右、从右向左分别遍历一遍，找出较小的值\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] res = new int[length];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n        for(int i = 0; i < length; i++) {\r\n            if(s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = i - prev;\r\n        }\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for(int i = length - 1; i >=0; i--) {\r\n            if(s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = Math.min(res[i], prev - i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n\r\n- 时间复杂度：O(n) ，n为数组长度 \r\n- 空间复杂度：O(n) ， 新数组res[]\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837680823","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 字符串、数组\r\n\r\n## 思路\r\n- 对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\r\n\r\n## 关键点\r\n\r\n-  从左向右、从右向左分别遍历一遍，找出较小的值\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] res = new int[length];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n        for(int i = 0; i < length; i++) {\r\n            if(s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = i - prev;\r\n        }\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for(int i = length - 1; i >=0; i--) {\r\n            if(s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = Math.min(res[i], prev - i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n\r\n- 时间复杂度：O(n) ，n为数组长度 \r\n- 空间复杂度：O(n) ， 新数组res[]\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"javanlu123":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836346588","body":"# 思路\r\n1.对每个分位进行叠加（注意进位以及分位存在判断的条件）\r\n2.最后一个进位的判断\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        // 这是一个典型的使用数组（字符串）的加法魔板\r\n        // 使用双向链表储存结果集\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int len = num.length - 1;\r\n        // 定义进位,初始默认为0\r\n        int carry = 0;\r\n        // 进行循环判断\r\n        // 数组下标以0开始，k以0为分界点\r\n        while(len>=0||k!=0){\r\n            // 定义数组num和k 的每个分位\r\n            int x = len>=0 ? num[len] : 0;\r\n            int y = k!=0 ? k%10 : 0;\r\n            int sum  = x + y + carry;\r\n            // 存入双向链表中\r\n            res.addFirst(sum % 10);\r\n            // 更新进位\r\n            carry = sum / 10;\r\n            // 分位进行移动\r\n            len--;\r\n            k /=10;\r\n        }\r\n        // 若最后的进位不为0，则头部补充\r\n        if(carry!=0){\r\n            res.addFirst(carry);\r\n        }\r\n        // 返回结果集\r\n        return res;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837614873","body":"# 思路1\r\n- 暴力解法\r\n把包含字符c的下标储存在零时数组，再遍历原有数组，与零时数组进行比较（取距离最小值）\r\n# 代码\r\n- Java\r\n~~~java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        int[] temp = new int[len];\r\n        int x = 0;\r\n        // 把包含字符c的下标储存在零时数组\r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i)==c){\r\n                temp[x++] = i;\r\n            }\r\n        }\r\n        // 在原字符串中与零时数组进行比较\r\n        int min = len;\r\n        for(int i = 0; i < len; i++){\r\n            // 这里使用x，x是有效位数\r\n            for(int j = 0; j < x; j++){\r\n                min = Math.min(min,Math.abs(i-temp[j]));\r\n            }\r\n            res[i] = min;\r\n//            每次都要重置min值\r\n            min = len;\r\n        }\r\n        return res;\r\n\r\n    }\r\n\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度o(N^2)\r\n- 空间复杂度o(N)\r\n\r\n\r\n# 思路2\r\n- 正反向数组遍历\r\n正向遍历，寻找每个位置到最近的c的最小值（向右搜索），反向遍历，则是向左搜索，更新每个位置到最近的c的最小值\r\n# 代码\r\n- Java\r\n~~~java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        // 使用正向、反向遍历法\r\n        int len = s.length();\r\n        // 定义结果数组\r\n        int[] res = new int[len];\r\n\r\n        // 正向遍历，向右搜索\r\n        // 定义一个标识变量prev，用于标记距离\r\n        int prev = -100000;\r\n        for(int i = 0; i < len; i++){\r\n            // 发现目标字符c，则prev标记为当前的i\r\n            if(s.charAt(i)==c)   prev = i;\r\n            // 标记当前位置距离\r\n            res[i] = i - prev;\r\n        }\r\n        // 反向遍历，向左搜索\r\n        // prev标记为 100000\r\n        prev = 100000;\r\n        for(int i = len - 1; i >= 0; i--){\r\n            // 发现目标字符c，则prev标记为当前的i\r\n            if(s.charAt(i)==c)   prev = i;\r\n            // 使用min函数更新当前位置距离\r\n            res[i] = Math.min(res[i],prev - i);\r\n        }\r\n        // 返回结果集\r\n        return res;\r\n    }\r\n\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度o(N)\r\n- 空间复杂度o(N)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837614873","body":"# 思路1\r\n- 暴力解法\r\n把包含字符c的下标储存在零时数组，再遍历原有数组，与零时数组进行比较（取距离最小值）\r\n# 代码\r\n- Java\r\n~~~java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        int[] temp = new int[len];\r\n        int x = 0;\r\n        // 把包含字符c的下标储存在零时数组\r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i)==c){\r\n                temp[x++] = i;\r\n            }\r\n        }\r\n        // 在原字符串中与零时数组进行比较\r\n        int min = len;\r\n        for(int i = 0; i < len; i++){\r\n            // 这里使用x，x是有效位数\r\n            for(int j = 0; j < x; j++){\r\n                min = Math.min(min,Math.abs(i-temp[j]));\r\n            }\r\n            res[i] = min;\r\n//            每次都要重置min值\r\n            min = len;\r\n        }\r\n        return res;\r\n\r\n    }\r\n\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度o(N^2)\r\n- 空间复杂度o(N)\r\n\r\n\r\n# 思路2\r\n- 正反向数组遍历\r\n正向遍历，寻找每个位置到最近的c的最小值（向右搜索），反向遍历，则是向左搜索，更新每个位置到最近的c的最小值\r\n# 代码\r\n- Java\r\n~~~java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        // 使用正向、反向遍历法\r\n        int len = s.length();\r\n        // 定义结果数组\r\n        int[] res = new int[len];\r\n\r\n        // 正向遍历，向右搜索\r\n        // 定义一个标识变量prev，用于标记距离\r\n        int prev = -100000;\r\n        for(int i = 0; i < len; i++){\r\n            // 发现目标字符c，则prev标记为当前的i\r\n            if(s.charAt(i)==c)   prev = i;\r\n            // 标记当前位置距离\r\n            res[i] = i - prev;\r\n        }\r\n        // 反向遍历，向左搜索\r\n        // prev标记为 100000\r\n        prev = 100000;\r\n        for(int i = len - 1; i >= 0; i--){\r\n            // 发现目标字符c，则prev标记为当前的i\r\n            if(s.charAt(i)==c)   prev = i;\r\n            // 使用min函数更新当前位置距离\r\n            res[i] = Math.min(res[i],prev - i);\r\n        }\r\n        // 返回结果集\r\n        return res;\r\n    }\r\n\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度o(N)\r\n- 空间复杂度o(N)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840536952","body":"# 思路\r\n方法一：使用辅助栈（默写k神代码）\r\n本题难点在于括号内嵌括号，需要从内向外生成于拼接字符串，和栈的先入后出特性一致\r\n- 构建辅助栈，遍历s中每个字符c\r\n   - c为数字，转化为int的数字multi（用于倍数计算）\r\n   - c为字母，在res（零时字符串）尾部加c\r\n   - c为[，将multi和res入栈，后分别置空置0\r\n      - 记录此[ 前的零时结果res入栈，用于发现对应]后的拼接操作\r\n      - 记录此[ 前的multi倍数入栈，用于发现对应]后，获取multi*[....]字符串\r\n      - 进入到新的[后，res和multi重新记录\r\n   - 当c为]，出栈，拼接字符串res = last_res +cur_multi * res\r\n- 返回字符串res\r\n# Java代码\r\n~~~java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        // 方法一：使用辅助栈法\r\n        // 这是一个零时字符串\r\n       StringBuilder res = new StringBuilder(); \r\n    //    默认的数字倍数是0\r\n       int multi = 0;\r\n    //    定义储存数字倍数的双向链表\r\n       LinkedList<Integer> stack_multi = new LinkedList<>();\r\n    //    定义储存临时字符串的双向链表\r\n    LinkedList<String> stack_res = new LinkedList<>();\r\n    // 对字符串s进行逐个字符遍历\r\n    for(Character c : s.toCharArray()){\r\n        if(c == '['){\r\n            // 遇到 [  则将之前的数字倍数multi和临时字符串出入链表中\r\n            stack_multi.addLast(multi);\r\n            stack_res.addLast(res.toString());\r\n            // 重置数字倍数和零时字符串\r\n            multi = 0;\r\n            res = new StringBuilder();\r\n        }else if( c == ']'){\r\n            // 遇到 ] 则将数字倍数和零时字符串的尾端移除，并拼装字符串res\r\n            // 这是内层的零时字符串，用于字符串*倍数\r\n            StringBuilder tmp = new StringBuilder();\r\n            // 获取尾端的倍数\r\n            int cur_multi = stack_multi.removeLast();\r\n            // 进行内层字符*倍数=内层零时字符串\r\n            for(int i = 0; i < cur_multi; i++){\r\n                tmp.append(res);\r\n            }\r\n            // 内层零时字符串于外层res进行拼装\r\n            res = new StringBuilder(stack_res.removeLast()+tmp);\r\n\r\n        }else if(c>='0'&&c<='9'){\r\n            // 字符串可能超过10,  12 = multi * 10 + 2\r\n            multi = multi * 10 +Integer.parseInt(c+\"\");\r\n        }else{\r\n            // 遇到普通字符，则添加到零时字符串中\r\n            res.append(c);\r\n        }\r\n        \r\n    }\r\n    return res.toString();\r\n    }\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度：O（N）\r\n- 空间复杂度:  O（N）\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BryanMiracle":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836356594","body":"**思路**\r\n新建一个链表，存储各位相加的结果。从低位到高位，逐一相加，并将结果返回\r\n\r\n**代码**\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res=new ArrayList<Integer>();\r\n        int n=num.length;\r\n        int sum=0,curr=0,i=n-1;\r\n        while(i>=0 || k!=0){\r\n            int x=i>=0?num[i]:0;\r\n            int y=k!=0?k%10:0;\r\n            sum=x+y+curr;\r\n            curr=sum/10;\r\n            k=k/10;\r\n            i--;\r\n            res.add(0,sum%10);\r\n        }\r\n        if(curr!=0){\r\n            res.add(0,curr);\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837667625","body":"**思路**\r\n针对给定字符串中的每个字符，试图找出距离其 向左/向右 离它最近的字符C的距离 ，并选择最近的距离\r\n-- 从左向右遍历，记录上一个字符C出现的位置 prev，此时距离就是：i-prev\r\n-- 从右向左遍历，记录上一个字符C出现的位置prev，此时距离就是 prev-i\r\n-- 取较小值\r\n**代码**\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n=s.length();\r\n        int[] ans=new int[n];\r\n        int prev=Integer.MIN_VALUE/2;\r\n        //从左向右遍历\r\n        for(int i=0;i<n;i++){\r\n            if(s.charAt(i)==c){\r\n                prev=i;\r\n            }\r\n            ans[i]=i-prev;\r\n        }\r\n        //从右向左遍历\r\n        prev=Integer.MAX_VALUE/2;\r\n        for(int i=n-1;i>=0;i--){\r\n            if(s.charAt(i)==c){\r\n                prev=i;\r\n            }\r\n            ans[i]=Math.min(ans[i],prev-i);\r\n        }\r\n        return ans;\r\n\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：（N）\r\n-- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837667625","body":"**思路**\r\n针对给定字符串中的每个字符，试图找出距离其 向左/向右 离它最近的字符C的距离 ，并选择最近的距离\r\n-- 从左向右遍历，记录上一个字符C出现的位置 prev，此时距离就是：i-prev\r\n-- 从右向左遍历，记录上一个字符C出现的位置prev，此时距离就是 prev-i\r\n-- 取较小值\r\n**代码**\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n=s.length();\r\n        int[] ans=new int[n];\r\n        int prev=Integer.MIN_VALUE/2;\r\n        //从左向右遍历\r\n        for(int i=0;i<n;i++){\r\n            if(s.charAt(i)==c){\r\n                prev=i;\r\n            }\r\n            ans[i]=i-prev;\r\n        }\r\n        //从右向左遍历\r\n        prev=Integer.MAX_VALUE/2;\r\n        for(int i=n-1;i>=0;i--){\r\n            if(s.charAt(i)==c){\r\n                prev=i;\r\n            }\r\n            ans[i]=Math.min(ans[i],prev-i);\r\n        }\r\n        return ans;\r\n\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：（N）\r\n-- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840640094","body":"**思路**\r\n构建辅助栈，遍历字符串s中每个字符，分情况处理\r\n**代码**\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        int multi = 0;\r\n        LinkedList<Integer> stack_multi = new LinkedList<>();\r\n        LinkedList<String> stack_res = new LinkedList<>();\r\n        for(Character c : s.toCharArray()) {\r\n            if(c == '[') {\r\n                stack_multi.addLast(multi);\r\n                stack_res.addLast(res.toString());\r\n                multi = 0;\r\n                res = new StringBuilder();\r\n            }\r\n            else if(c == ']') {\r\n                StringBuilder tmp = new StringBuilder();\r\n                int cur_multi = stack_multi.removeLast();\r\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\r\n                res = new StringBuilder(stack_res.removeLast() + tmp);\r\n            }\r\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\r\n            else res.append(c);\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：O(N)\r\n-- 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DoubleW2w":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836444832","body":"emmmmm，加油，这次看了答案，下次争取不看答案！！！！\r\n不知道空间复杂度怎么分析，就删除了。\r\n## 思路\r\n\r\n加法主要就是判断进位的问题。相加的选择，我们可以从低位往高位相加\r\n\r\n1. 如果没有产生进位，那什么情况才停止相加呢？比如 $123+23=146$和 $123+1234=1367$\r\n2. 如果产生进位，但没有发生数组越界的情况，比如$123+37=160 $和$123+1137=1260$\r\n3. 如果产生进位，但发生了数组越界呢？比如$999+1=1000$\r\n\r\n---\r\n\r\n第一种情况：当我们低位往高位相加的时候，`k=0`的时候或者`遍历完num`，我们就停止了相加。\r\n\r\n第二种情况：就在第一种情况的基础上，在中间增加个进位的处理，其停止的情况还是`k=0`的时候或者`遍历完num`。\r\n\r\n第三种情况：就在第二种情况的基础上，最后增加高位还有进位的处理情况。而停止还是一样的\r\n\r\n因此总结一下：\r\n\r\n来自题解区的一位大佬\r\n\r\n```java\r\n<公式>\r\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\r\n\r\n<加法模板>    \r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code1:\r\n\r\n```java\r\n//官方题解\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //从低位往高位相加\r\n        int n = num.length;\r\n        List<Integer> res = new ArrayList<>();\r\n        //遍历num，但k也在发生变化\r\n        for(int i = n-1;i >= 0; i--){\r\n            int sum = num[i] + k%10;\r\n            k /=10;\r\n            if(sum >= 10){\r\n                //把进位放在k上\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        //如果num的位数>k的位数，此时的k是为0或者是最高位的进位\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n\r\nJava Code2:\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k){\r\n        //当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\r\n        int n = num.length;\r\n        List<Integer> res = new ArrayList<>();\r\n        int carry =0, sum =0,index = n-1;\r\n        while(index >=0 || k!=0){\r\n            // num的当前位\r\n            int x = index >=0 ? num[index] : 0;\r\n            // K的当前位\r\n            int y = k != 0 ? k%10 : 0;\r\n\r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            k = k / 10;\r\n            index --;\r\n            res.add(sum % 10);\r\n        }\r\n        if (carry != 0){\r\n            res.add(carry);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ARe99s":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836448740","body":"**思路**\r\n直接把K加到A上\r\n**代码 python**\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        i = len(A) - 1\r\n        while K:\r\n            A[i] += K\r\n            K, A[i] = A[i] // 10, A[i] % 10\r\n            i -= 1\r\n            if i < 0 and K:\r\n                A.insert(0,0)\r\n                i = 0\r\n        return A\r\n```\r\n**时间复杂度**\r\nO(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"FontEndArt":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836454805","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n## 思路\r\n循环判断k，k存在即代表还需要进行加法计算，每次加k的个数位，然后k抹去个数位的值，最后并判断是否有进一，有则k++。\r\n\r\n如果超出num的长度则使用unshift在数组首位增加。（其他语言如果没有动态数组的，可能需要预先申请足够的空间）\r\n\r\n## 关键点\r\n\r\n-  进一位的处理\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n    let i = num.length - 1\r\n    while (k > 0) {\r\n        let tmp = k % 10;\r\n        k = Math.floor((k - tmp) / 10)\r\n        if (i < 0) {\r\n            num.unshift(tmp)\r\n            // 注意是continue： [0], 10000\r\n            continue\r\n        }\r\n        // 注意是>=而不是>\r\n        if ((num[i] + tmp) >= 10) {\r\n            k++\r\n        }\r\n        num[i] = (num[i] + tmp) % 10\r\n        i--\r\n    }\r\n    return num\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838391375","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 正反遍历\r\n- Infinity\r\n\r\n## 思路\r\n正反遍历，注意res[i]初始值为Infinity\r\n\r\n> 也可以双指针, 考虑正反遍历或单次遍历，只不过单次遍历需要相当于滑动窗口，然后每次指针移动都要去判断赋值\r\n \r\n> 朋友用的中心扩展法也不是不行，只不过复杂度稍微高了一点，需要双端边界都要到头才可以。\r\n> range(0,s.length)或者匹配到与c的字符满足其一是单端边界结束调节。\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n    let cIndex = -1;\r\n    const res = Array(s.length).fill(Infinity)\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] !== c && cIndex < 0) {\r\n            continue\r\n        }\r\n        if (s[i] === c) {\r\n            cIndex = i\r\n            res[i] = 0\r\n        } else {\r\n            res[i] = Math.min(i - cIndex, res[i])\r\n        }\r\n    }\r\n    cIndex = -1;\r\n    for (let i = s.length - 1; i >= 0; i--) {\r\n        if (s[i] !== c && cIndex < 0) {\r\n            continue\r\n        }\r\n        if (s[i] === c) {\r\n            cIndex = i\r\n        } else {\r\n            res[i] = Math.min(cIndex - i, res[i])\r\n        }\r\n    }\r\n    return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838391375","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 正反遍历\r\n- Infinity\r\n\r\n## 思路\r\n正反遍历，注意res[i]初始值为Infinity\r\n\r\n> 也可以双指针, 考虑正反遍历或单次遍历，只不过单次遍历需要相当于滑动窗口，然后每次指针移动都要去判断赋值\r\n \r\n> 朋友用的中心扩展法也不是不行，只不过复杂度稍微高了一点，需要双端边界都要到头才可以。\r\n> range(0,s.length)或者匹配到与c的字符满足其一是单端边界结束调节。\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n    let cIndex = -1;\r\n    const res = Array(s.length).fill(Infinity)\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] !== c && cIndex < 0) {\r\n            continue\r\n        }\r\n        if (s[i] === c) {\r\n            cIndex = i\r\n            res[i] = 0\r\n        } else {\r\n            res[i] = Math.min(i - cIndex, res[i])\r\n        }\r\n    }\r\n    cIndex = -1;\r\n    for (let i = s.length - 1; i >= 0; i--) {\r\n        if (s[i] !== c && cIndex < 0) {\r\n            continue\r\n        }\r\n        if (s[i] === c) {\r\n            cIndex = i\r\n        } else {\r\n            res[i] = Math.min(cIndex - i, res[i])\r\n        }\r\n    }\r\n    return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840406782","body":"\r\n## 题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n\r\n\r\n示例 3：\r\n\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n\r\n\r\n示例 4：\r\n\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n\r\n```\r\n\r\n## 思路\r\n\r\ndfs, 关键点看代码注释。\r\n> repeat部分其他语言可以用伪代码`let j = 0; while(j<(num||1)){str+=tmp}`或`for i in range(num||1)`替代\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s, i = 0) {\r\n    let num = '';\r\n    let str = '';\r\n    while (i < s.length) {\r\n        if (/\\d/.test(s[i])) {\r\n            num += s[i]\r\n            i++\r\n        }\r\n        if (/[a-z]/.test(s[i])) {\r\n            str += s[i]\r\n            i++\r\n        }\r\n        if ('[' === s[i]) {\r\n            // 跳过已经经过的 ']'\r\n            let [tmp, nextIndex] = decodeString(s, i + 1)\r\n            // '进行重复'\r\n            str += tmp.repeat(num || 1)\r\n            i = nextIndex\r\n            num = ''\r\n        }\r\n        // 只会出现在递归的深层中\r\n        if (']' === s[i]) {\r\n            return [str, i + 1]\r\n        }\r\n    }\r\n    return str\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$ n为s.length\r\n- 空间复杂度：$O(n)$\r\n> 额外的空间\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Siomarry":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836474356","body":"- 思路\r\n每次取出K的最后一位以及数组的最后一位进行相加，并且依次进位相加.\r\n\r\n- 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        //建立一个vector<int> K的数组，然后两个vector进行相加.\r\n        queue<int> Kdigit;\r\n        while(k){\r\n            Kdigit.push(k % 10);k = k / 10;\r\n        }\r\n        //第二步，将栈中的元素和num进行相加.\r\n        deque<int> ans;int endpoint = ans.size() - 1;\r\n        //设置一个最大长度的ans.\r\n        int numpoint = num.size() - 1;int plus = 0;\r\n        while(!Kdigit.empty() && numpoint >= 0){\r\n\r\n            ans.push_front((plus + Kdigit.front() + num[numpoint]) % 10);\r\n            plus = (plus + Kdigit.front() + num[numpoint]) / 10;\r\n            Kdigit.pop();numpoint--;endpoint--;\r\n        }\r\n        //结束时判断最后的条件.\r\n        while(!Kdigit.empty()){  //若数字不为空\r\n            ans.push_front((plus + Kdigit.front()) % 10);\r\n            plus = (plus + Kdigit.front()) / 10;\r\n            Kdigit.pop();\r\n        }\r\n\r\n        while(numpoint >= 0){  //若原数组不为空\r\n            ans.push_front((plus + num[numpoint]) % 10);\r\n            plus = (plus + num[numpoint]) / 10;\r\n            numpoint--;\r\n        }\r\n        if(plus)\r\n            ans.push_front(plus);\r\n\r\n        vector<int> result(ans.begin(),ans.end());\r\n        return result;\r\n    }\r\n};\r\n```\r\n- 时间复杂度\r\n    O(max(n，logk))\r\n\r\n- 空间复杂度\r\n    O(max(n,logk))\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838292817","body":"- 思路\r\n对于选定的字符，通过左右双指针来寻找贪心寻找距离最近的字符.\r\n\r\n- 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int ComputerDis(string s,int current,char c){\r\n        //在s中计算c离current最近的字符.\r\n        if(s[current] == c)\r\n            return 0;\r\n        int left = current - 1;int right = current + 1;\r\n        while(left >=0 && right <= s.size() - 1){\r\n            if(s[left] == c || s[right] == c){\r\n                return right - current;\r\n            }\r\n            else{\r\n                left--;right++;\r\n            }\r\n        }\r\n        while(left >= 0){\r\n            if(s[left] == c){\r\n                return current - left;\r\n            }\r\n            else\r\n                left--;\r\n        }\r\n        while(right <= s.size() - 1){\r\n            if(s[right] == c){\r\n                return right - current;\r\n            }else\r\n                right++;\r\n        }\r\n        return -1;\r\n    }\r\n    vector<int> shortestToChar(string s, char c){\r\n        vector<int> ans;\r\n        for(int i = 0;i<s.size();i++){\r\n            ans.push_back(ComputerDis(s,i,c));\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n- 时间复杂度 O(n2)\r\n- 空间复杂度 O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838292817","body":"- 思路\r\n对于选定的字符，通过左右双指针来寻找贪心寻找距离最近的字符.\r\n\r\n- 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int ComputerDis(string s,int current,char c){\r\n        //在s中计算c离current最近的字符.\r\n        if(s[current] == c)\r\n            return 0;\r\n        int left = current - 1;int right = current + 1;\r\n        while(left >=0 && right <= s.size() - 1){\r\n            if(s[left] == c || s[right] == c){\r\n                return right - current;\r\n            }\r\n            else{\r\n                left--;right++;\r\n            }\r\n        }\r\n        while(left >= 0){\r\n            if(s[left] == c){\r\n                return current - left;\r\n            }\r\n            else\r\n                left--;\r\n        }\r\n        while(right <= s.size() - 1){\r\n            if(s[right] == c){\r\n                return right - current;\r\n            }else\r\n                right++;\r\n        }\r\n        return -1;\r\n    }\r\n    vector<int> shortestToChar(string s, char c){\r\n        vector<int> ans;\r\n        for(int i = 0;i<s.size();i++){\r\n            ans.push_back(ComputerDis(s,i,c));\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n- 时间复杂度 O(n2)\r\n- 空间复杂度 O(n)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miqpalzm":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836476818","body":"public class Solution {\r\n    public IList<int> AddToArrayForm(int[] num, int k) {\r\n        var kLen = k.ToString().Length;\r\n            int[] kArr = new int[kLen];\r\n            for (var i = kLen - 1; i >= 0; i--)\r\n            {\r\n                if (k / 10 > 0)\r\n                {\r\n                    kArr[i] = k % 10;\r\n                    k = k / 10;\r\n                }\r\n                else\r\n                {\r\n                    kArr[i] = k;\r\n                }\r\n            }\r\n\r\n            var addExtra = false;\r\n            var nLen = num.Length;\r\n            var list = new List<int>();\r\n            for (int i = nLen - 1, j = kLen - 1; i >= 0 || j >= 0; i--, j--)\r\n            {\r\n                var nValue = (i > nLen - 1 || i < 0) ? 0 : num[i];\r\n                var kValue = (j > kLen - 1 || j < 0) ? 0 : kArr[j];\r\n                var sum = nValue + kValue + (addExtra ? 1 : 0);\r\n                if (sum >= 10)\r\n                {\r\n                    addExtra = true;\r\n                    sum = sum % 10;\r\n                }\r\n                else\r\n                {\r\n                    addExtra = false;\r\n                }\r\n\r\n                list.Add(sum);\r\n            }\r\n\r\n            if (addExtra)\r\n            {\r\n                list.Add(1);\r\n            }\r\n            list.Reverse();\r\n\r\n            return list;\r\n    }\r\n}"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838451850","body":"语言：C#\r\n\r\npublic class Solution {\r\n    public int[] ShortestToChar(string s, char c) {\r\n        var charArr = s.ToCharArray();\r\n            var intArr = new int[charArr.Length];\r\n\r\n            int lastIndex = -1, aheadIndex = s.IndexOf(c);\r\n            for (var i = 0; i < charArr.Length; i++)\r\n            {\r\n                if (i == aheadIndex)\r\n                {\r\n                    lastIndex = aheadIndex;\r\n                    charArr[lastIndex] = '#';\r\n                    aheadIndex = new string(charArr).IndexOf(c);\r\n                }\r\n                var left = Math.Abs(i - (lastIndex == -1 ? aheadIndex : lastIndex));\r\n                var right = Math.Abs((aheadIndex == -1 ? lastIndex : aheadIndex) - i);\r\n                intArr[i] = left < right ? left : right;\r\n            }\r\n\r\n            return intArr;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838451850","body":"语言：C#\r\n\r\npublic class Solution {\r\n    public int[] ShortestToChar(string s, char c) {\r\n        var charArr = s.ToCharArray();\r\n            var intArr = new int[charArr.Length];\r\n\r\n            int lastIndex = -1, aheadIndex = s.IndexOf(c);\r\n            for (var i = 0; i < charArr.Length; i++)\r\n            {\r\n                if (i == aheadIndex)\r\n                {\r\n                    lastIndex = aheadIndex;\r\n                    charArr[lastIndex] = '#';\r\n                    aheadIndex = new string(charArr).IndexOf(c);\r\n                }\r\n                var left = Math.Abs(i - (lastIndex == -1 ? aheadIndex : lastIndex));\r\n                var right = Math.Abs((aheadIndex == -1 ? lastIndex : aheadIndex) - i);\r\n                intArr[i] = left < right ? left : right;\r\n            }\r\n\r\n            return intArr;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840598152","body":"c#\r\n\r\npublic class Solution {\r\n    public string DecodeString(string s)\r\n        {\r\n            var charArr = s.ToCharArray();\r\n            var str = \"\";\r\n            int temp = 0, num = 0, start = 0, symbol = 0, symbol2 = 0;\r\n            for (int i = 0; i < charArr.Length; i++)\r\n            {\r\n                if (!int.TryParse(charArr[i].ToString(), out temp))\r\n                {\r\n                    if (charArr[i] != '[' && charArr[i] != ']' && symbol == 0)\r\n                    {\r\n                        str += s.Substring(i, 1);\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    if (num == 0)\r\n                    {\r\n                        num = temp;\r\n                        start = i + 2;\r\n                    }\r\n                    else if (symbol == 0)\r\n                    {\r\n                        num = int.Parse(num + \"\" + temp);\r\n                        start++;\r\n                    }\r\n                }\r\n\r\n                switch (charArr[i])\r\n                {\r\n                    case '[':\r\n                        symbol++;\r\n                        break;\r\n                    case ']':\r\n                        symbol2++;\r\n                        break;\r\n                }\r\n\r\n                if (symbol > 0 && symbol == symbol2)\r\n                {\r\n                    var subs = s.Substring(start, i - start);\r\n                    for (int j = 0; j < num; j++)\r\n                    {\r\n                        str += subs;\r\n                    }\r\n                    num = 0;\r\n                    symbol = 0;\r\n                    symbol2 = 0;\r\n                }\r\n            }\r\n\r\n            if (str.Contains('['))\r\n            {\r\n                return DecodeString(str);\r\n            }\r\n            else\r\n            {\r\n                return str;\r\n            }\r\n\r\n        }\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"15399618796":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836482820","body":"思路：逐位相加再插入到一个新的数组中\r\n\r\n`class Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n       vector<int> res;\r\n       int a=0,sum=0,b=0;\r\n       for(int i=num.size()-1;i>=0;i--){\r\n           a=k%10;\r\n           k/=10;\r\n           sum=num[i]+a;\r\n           if(sum>=10){\r\n               sum-=10;\r\n               k++;\r\n           }\r\n           res.push_back(sum);\r\n       }\r\n       while(k){\r\n           b=k%10;\r\n           k/=10;\r\n           res.push_back(b);\r\n       }\r\n       reverse(res.begin(),res.end());\r\n       \r\n       return res;\r\n    }\r\n};`\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838288962","body":"思路：分别从前到后，从后到前遍历两次数组\r\n\r\n`class Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res(s.size(),0);\r\n        int size=s.size();\r\n\r\n        int prev=INT_MIN/2;\r\n        for(int i=0;i<size;i++){\r\n            if(s[i]==c) prev=i;\r\n            res[i]=i-prev;\r\n        }\r\n\r\n        prev=INT_MAX/2;\r\n        for(int i=size-1;i>=0;i--){\r\n            if(s[i]==c) prev=i;\r\n            res[i]=min(res[i],prev-i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n};`\r\n\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838288962","body":"思路：分别从前到后，从后到前遍历两次数组\r\n\r\n`class Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res(s.size(),0);\r\n        int size=s.size();\r\n\r\n        int prev=INT_MIN/2;\r\n        for(int i=0;i<size;i++){\r\n            if(s[i]==c) prev=i;\r\n            res[i]=i-prev;\r\n        }\r\n\r\n        prev=INT_MAX/2;\r\n        for(int i=size-1;i>=0;i--){\r\n            if(s[i]==c) prev=i;\r\n            res[i]=min(res[i],prev-i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n};`\r\n\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"st2yang":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836486673","body":"## 思路\r\n从右到左低位循环num，将其每一位与k相加，并依次进位。如果循环完k还有剩，要记得加上。\r\n\r\n## 代码\r\n- python\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        for i in reversed(range(len(num))):\r\n            sum_ = num[i] + k\r\n            k = sum_ // 10\r\n            res.append(sum_ % 10)\r\n        res.reverse()\r\n        if k:\r\n            res = list(map(int, str(k))) + res\r\n        return res\r\n```\r\n\r\n## 复杂度\r\n- time: O(max(n，k))\r\n- space: O(max(n，k))"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837739870","body":"## 思路\r\n左右各循环一遍数组，查找和字符`c`相同的位，以此记录每一位到上一个`c`的距离。然后比较左右距离得到较小值。\r\n\r\n## 代码\r\n- python\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        prev = float('-inf')\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                prev = i\r\n            res.append(i - prev)\r\n        \r\n        prev = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            res[i] = min(res[i], prev - i)\r\n        \r\n        return res\r\n```\r\n\r\n## 复杂度\r\n- time: O(n)\r\n- space: O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837739870","body":"## 思路\r\n左右各循环一遍数组，查找和字符`c`相同的位，以此记录每一位到上一个`c`的距离。然后比较左右距离得到较小值。\r\n\r\n## 代码\r\n- python\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        prev = float('-inf')\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                prev = i\r\n            res.append(i - prev)\r\n        \r\n        prev = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            res[i] = min(res[i], prev - i)\r\n        \r\n        return res\r\n```\r\n\r\n## 复杂度\r\n- time: O(n)\r\n- space: O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Cartie-ZhouMo":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836492706","body":"### 思路\r\n从个位加起，若位数超出原数组，需要进位。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        l = len(num)\r\n        for i in range(l-1, -1, -1):\r\n            a = num[i] + k\r\n            k, num[i] = a // 10, a % 10\r\n        arr = []\r\n        while k:\r\n            arr = [k % 10] + arr\r\n            k = k // 10\r\n        return arr + num\r\n```\r\n### 复杂度分析\r\n时间：O(N)\r\n空间：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837854541","body":"### 思路\r\n暴力法：先遍历获得s中c的位置list，再遍历计算s中每个字符位置与位置list中元素的最小值。\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        arr, ans = [], []\r\n        dis = float(\"inf\") \r\n        for i, ss in enumerate(s):\r\n            if ss == c:\r\n                arr.append(i)\r\n        for i, ss in enumerate(s):\r\n            if ss == c:\r\n                ans.append(0)\r\n            else:\r\n                for a in arr:\r\n                    dis = min(abs(a - i), dis)\r\n                ans.append(dis)\r\n                dis = float(\"inf\") \r\n        return ans\r\n```\r\n### 复杂度：\r\n时间：O(N^2)\r\n空间：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837854541","body":"### 思路\r\n暴力法：先遍历获得s中c的位置list，再遍历计算s中每个字符位置与位置list中元素的最小值。\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        arr, ans = [], []\r\n        dis = float(\"inf\") \r\n        for i, ss in enumerate(s):\r\n            if ss == c:\r\n                arr.append(i)\r\n        for i, ss in enumerate(s):\r\n            if ss == c:\r\n                ans.append(0)\r\n            else:\r\n                for a in arr:\r\n                    dis = min(abs(a - i), dis)\r\n                ans.append(dis)\r\n                dis = float(\"inf\") \r\n        return ans\r\n```\r\n### 复杂度：\r\n时间：O(N^2)\r\n空间：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840412803","body":"### 思路\r\n主要是处理括号嵌套的情况，利用辅助栈存储。\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        num, ans = 0, ''\r\n        # 辅助栈\r\n        stack = []\r\n        for ss in s:    \r\n            if ss == '[':\r\n                # 存 '[' 前的字母和数字\r\n                stack.append([num, ans])\r\n                num, ans = 0, ''\r\n            elif ss == ']':\r\n                if stack:\r\n                    n, a = stack.pop()\r\n                ans = a + n * ans\r\n            elif '0' <= ss <= '9':\r\n                num = num * 10 + int(ss)\r\n            else: ans += ss\r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n- 时间：O(N)\r\n- 空间：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mystoryshine":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836511738","body":"### 思路\r\n\r\n- 用空字符串拼接输入数组\r\n- 转化为整形相加\r\n- 最后再转化为字符串遍历输出\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        tmp = ''\r\n        for n in num:\r\n            tmp += str(n)\r\n        res_int = int(tmp) + k\r\n        res = [int(i) for i in str(res_int)]\r\n        return res\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838438194","body":"### 思路\r\n\r\n- 左右两次遍历\r\n- 每次遍历时用一个临时变量记住最近的一次c的位置，求出距离\r\n- 比较两次遍历结果，取较小值即可\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        # 记第一次c的位置为 -length\r\n        preTargetIndex = - len(s)\r\n        # 正向遍历\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                # 若遍历到了c，将上一次c的位置改为当前位置，这样计算距离才为0\r\n                preTargetIndex = i\r\n            res.append(i - preTargetIndex)\r\n        \r\n        preTargetIndex = 2*len(s)\r\n        # 逆向遍历\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                preTargetIndex = i\r\n            res[i] = min(res[i], preTargetIndex - i)\r\n        return res\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$，其中 $N$ 为数组长度。\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838438194","body":"### 思路\r\n\r\n- 左右两次遍历\r\n- 每次遍历时用一个临时变量记住最近的一次c的位置，求出距离\r\n- 比较两次遍历结果，取较小值即可\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        # 记第一次c的位置为 -length\r\n        preTargetIndex = - len(s)\r\n        # 正向遍历\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                # 若遍历到了c，将上一次c的位置改为当前位置，这样计算距离才为0\r\n                preTargetIndex = i\r\n            res.append(i - preTargetIndex)\r\n        \r\n        preTargetIndex = 2*len(s)\r\n        # 逆向遍历\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                preTargetIndex = i\r\n            res[i] = min(res[i], preTargetIndex - i)\r\n        return res\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$，其中 $N$ 为数组长度。\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840578314","body":"### 思路\r\n\r\n- 利用栈与递归\r\n- 遍历原字符串，遇到非'**]**'压栈，遇到'**]**'弹出构成 **数字+[字符串]** 形式\r\n- 将这个子串解码玩后继续压入到栈中\r\n- 递归\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr\r\n                # pop 掉 \"[\"\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount\r\n                stack.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ezrealcong":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836567186","body":"### **思路**\r\nC实现\r\n- 申请A.length+5个元素的数组空间p[]\r\n- 从后往前遍历数组p[]，计算最低位ktmp=k%10;更新kk=(int)(k/10),在遍历长度小于A.length时，p[i]=nums[i]+ktmp+进位ctmp,大于时p[i]=ktmp+ctmp\r\n- 过程中计数，直到发现nums遍历完，进位为0，k更新为0，那么计数器就是要返回的位数，然后将p指向数组对应位置上返回即可\r\n### **代码**\r\n    \r\n    int* addToArrayForm(int* num, int numSize, int k, int* returnSize){\r\n        int* p = calloc(numSize+5,sizeof(int));\r\n        int j=numSize-1;\r\n        int ktmp;//用来保存模10的值（某一位）\r\n        int atmp;//按位加未处理进位值\r\n        int ctmp=0;//保存进位\r\n        int b=0;\r\n        for(int i=numSize+4;i>=0;i--){\r\n            if(j<0&&k==0&&ctmp==0)\r\n                b++;\r\n            ktmp=k%10;\r\n            k=(int)(k/10);\r\n            if(j>=0)\r\n                atmp=num[j]+ctmp+ktmp;\r\n            else\r\n                {atmp=ctmp+ktmp;\r\n                }\r\n            p[i]=atmp%10;\r\n            ctmp=(int)(atmp/10);\r\n            j-=1;      \r\n        }    \r\n        *returnSize=numSize+5-b;\r\n        return p+b;\r\n    }\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：只遍历了一遍P[]，复杂度为O(N)\r\n\r\n- 空间复杂度：基本是用于返回的空间，O(N)\r\n\r\n> "},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837706343","body":"（python实现）\r\n### 思路：\r\n1.建立相应长度的数组，全部初始化-1，总共遍历两次\r\n2.第一次从左往右遍历，遇到字符匹配的位置，该元素变0，同时启动计数器num\r\n3.其他位置都赋值为num，赋值完后num自加1，一直到第一次遍历完毕，完成右边最近统计\r\n4.第二次从右往左遍历，遇到字符匹配的位置，启动计数器num\r\n5.其他位置都赋值为min{当前值，num}，赋值完后num自加1，一直到第二次遍历完毕，完成最近距离统计\r\n注意：边界处理时要注意最左边的-1，取最小值要避开-1（-1不参与比较）\r\n### 实例题解展示：\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n第一遍：\r\n\r\n>      [-1,-1,-1,0,1,0,0,1,2,3,4,0]\r\n\r\n第二遍：\r\n\r\n>     [ 3, 2, 1,0,1,0,0,4,3,2,1,0]\t不比较最小值\r\n\r\n>     [ 3, 2, 1,0,1,0,0,1,2,2,1,0]\t比较最小值（-1不参与比较）\r\n\r\n### 代码：\r\n\r\n>     \r\n\r\n    class Solution(object):\r\n            def shortestToChar(self, s, c):\r\n                slen=len(s)\r\n                slist=[-1]*slen\r\n                i=0\r\n                num=-1\r\n                while i<slen:\r\n                    if -1!=num:\r\n                        slist[i]=num\r\n                        num+=1\r\n                    if s[i]==c:\r\n                        slist[i]=0\r\n                        num=1\r\n                    i+=1\r\n                i=slen-1\r\n                num=-1    \r\n                while i>=0:\r\n                    if -1!=num:\r\n                        if slist[i]>num or -1==slist[i]:\r\n                            slist[i]=num\r\n                        num+=1\r\n                    if s[i]==c:\r\n                        num=1\r\n                    i-=1\r\n                return slist\r\n\r\n### 复杂度分析\r\n1.时间复杂度：遍历两次数组（列表），时间复杂度O(N)\r\n2.空间复杂度：除去用来返回的列表，空间复杂度O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837706343","body":"（python实现）\r\n### 思路：\r\n1.建立相应长度的数组，全部初始化-1，总共遍历两次\r\n2.第一次从左往右遍历，遇到字符匹配的位置，该元素变0，同时启动计数器num\r\n3.其他位置都赋值为num，赋值完后num自加1，一直到第一次遍历完毕，完成右边最近统计\r\n4.第二次从右往左遍历，遇到字符匹配的位置，启动计数器num\r\n5.其他位置都赋值为min{当前值，num}，赋值完后num自加1，一直到第二次遍历完毕，完成最近距离统计\r\n注意：边界处理时要注意最左边的-1，取最小值要避开-1（-1不参与比较）\r\n### 实例题解展示：\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n第一遍：\r\n\r\n>      [-1,-1,-1,0,1,0,0,1,2,3,4,0]\r\n\r\n第二遍：\r\n\r\n>     [ 3, 2, 1,0,1,0,0,4,3,2,1,0]\t不比较最小值\r\n\r\n>     [ 3, 2, 1,0,1,0,0,1,2,2,1,0]\t比较最小值（-1不参与比较）\r\n\r\n### 代码：\r\n\r\n>     \r\n\r\n    class Solution(object):\r\n            def shortestToChar(self, s, c):\r\n                slen=len(s)\r\n                slist=[-1]*slen\r\n                i=0\r\n                num=-1\r\n                while i<slen:\r\n                    if -1!=num:\r\n                        slist[i]=num\r\n                        num+=1\r\n                    if s[i]==c:\r\n                        slist[i]=0\r\n                        num=1\r\n                    i+=1\r\n                i=slen-1\r\n                num=-1    \r\n                while i>=0:\r\n                    if -1!=num:\r\n                        if slist[i]>num or -1==slist[i]:\r\n                            slist[i]=num\r\n                        num+=1\r\n                    if s[i]==c:\r\n                        num=1\r\n                    i-=1\r\n                return slist\r\n\r\n### 复杂度分析\r\n1.时间复杂度：遍历两次数组（列表），时间复杂度O(N)\r\n2.空间复杂度：除去用来返回的列表，空间复杂度O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840585056","body":"### **思路**\r\n\r\n> 构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\r\n\r\n1. 当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\r\n2. 当 c 为字母时，在 res 尾部添加 c；\r\n3. 当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 00：\r\n    记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\r\n    记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\r\n    进入到新 [ 后，res 和 multi 重新记录。\r\n4. 当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\r\n    last_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\r\n    cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\r\n    返回字符串 res。\r\n\r\n### **代码**\r\n```python\r\n     \r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n### **复杂度分析**\r\n1.  时间复杂度 O(N)\r\n2.  空间复杂度 O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Huzhixin00":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836573445","body":"### 思路\r\n1. 按照最自然的想法，应该是将K的各位切分出来，即：将int类型的K转化为各位为int类型的数组，然后将K的对应位与给定数组的对应位进行相加，并考虑进位的情况。\r\n2. 上述想法需要对K进行处理，而且处理进位的逻辑会影响到下一轮更高位的相加处理，所以应考虑更为通用的算法。\r\n3. 在上述过程中，唯一不能省略的就是进位过程，因为作为”必要项“的进位过程如果可以和相加过程相结合，自然可以得出相对通用的算法。\r\n4. 如果要将进位过程与相加过程结合，那么就应该是”依次从低位开始加起，K与个位相加的结果对10取余，即个位的最终结果，而是否向上进位，则取决于k与个位相加的结果除以十，是否大于0（整数/10即意味着求高1位数的结果，因为小数点后的数字被截掉了）“。\r\n5. 反复进行第4步，即每除1次10，即求得都是K累加和的高一次幂，只要K的累加和除10结果不为零，或是数组的位数没有加到最高位，这样的循环就不会停止。\r\n\r\n### 代码（Java）\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> arr = new ArrayList<>();\r\n        for (int i = num.length - 1; i >= 0 || k > 0; i--, k = k / 10) {\r\n            if (i >= 0) {\r\n                k = k + num[i];\r\n            }\r\n            arr.add(k % 10);\r\n        }\r\n        Collections.reverse(arr);\r\n        return arr;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n时间复杂度：O(max(logK,num.length)) \r\n循环次数取决于k和数组长度的最大值，但比较值得注意的是，当K>0，但i<0时，意味着数组的最高位已经没有了，此时应该出现数组越界异常，只不过leetcode只判定到不越界为止，所以就没有考虑越界的问题。\r\n\r\n空间复杂度：O(1)\r\n没有用到额外的空间，所以空间复杂度为常数\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838368278","body":"## 思路\r\n写在代码注释里面了\r\n## 代码\r\n```\r\n class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        // 创建一个数组来存放各个位置距离字符 c 的最小距离\r\n        int[] minDistances = new int[s.length()];\r\n        /*\r\n        * 每个位置相对于c的情况有三种：\r\n        * 1、该下标只有左边有字符c         [x  c]\r\n        * 2、该下标左右两边都有字符c       [c   x   c]\r\n        * 3、该下标只有右边有字符c         [c  x]\r\n        * 其中只有第二种情况，需要比较两边的字符c究竟哪个距离x更近。\r\n        * 所以取最复杂情况，设置两个指针cursor1和cursor2，分别指向当前下标的左侧c字符和右侧c字符\r\n        * */\r\n        // 先将两个指针指向String中最左侧的字符c，然后从数字0开始迭代\r\n        int cursorFirst = s.indexOf(c), cursorSecond = cursorFirst;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            /*\r\n            * 如果数字下标处，正好是字符c，那么将该位置到字符c的距离必为0，并且更新两个指针的数据\r\n            * 原来的的cursor1，也就是左侧字符c指针，需要更新为当前下标的位置（因为下一次该位置就成为下一个位置的左侧字符c）\r\n            * 原来的cursor2，也就是右侧字符c指针，需要更新为更右边（即从i+1位置开始，找到的下一个字符c位置）的字符c位置*/\r\n            if (s.charAt(i) == c) {    //\r\n                minDistances[i] = 0;\r\n                cursorFirst = i;\r\n                cursorSecond = s.indexOf(c, i + 1);\r\n                // 如果数组下标所处位置的字符不是字符c，则计算该处与最近的左右两侧字符c的距离，并取最小值\r\n            } else {\r\n                minDistances[i] = Math.min(Math.abs(cursorFirst - i), Math.abs(cursorSecond - i));\r\n            }\r\n        }\r\n        return minDistances;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n时间复杂度：O(N) \r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838368278","body":"## 思路\r\n写在代码注释里面了\r\n## 代码\r\n```\r\n class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        // 创建一个数组来存放各个位置距离字符 c 的最小距离\r\n        int[] minDistances = new int[s.length()];\r\n        /*\r\n        * 每个位置相对于c的情况有三种：\r\n        * 1、该下标只有左边有字符c         [x  c]\r\n        * 2、该下标左右两边都有字符c       [c   x   c]\r\n        * 3、该下标只有右边有字符c         [c  x]\r\n        * 其中只有第二种情况，需要比较两边的字符c究竟哪个距离x更近。\r\n        * 所以取最复杂情况，设置两个指针cursor1和cursor2，分别指向当前下标的左侧c字符和右侧c字符\r\n        * */\r\n        // 先将两个指针指向String中最左侧的字符c，然后从数字0开始迭代\r\n        int cursorFirst = s.indexOf(c), cursorSecond = cursorFirst;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            /*\r\n            * 如果数字下标处，正好是字符c，那么将该位置到字符c的距离必为0，并且更新两个指针的数据\r\n            * 原来的的cursor1，也就是左侧字符c指针，需要更新为当前下标的位置（因为下一次该位置就成为下一个位置的左侧字符c）\r\n            * 原来的cursor2，也就是右侧字符c指针，需要更新为更右边（即从i+1位置开始，找到的下一个字符c位置）的字符c位置*/\r\n            if (s.charAt(i) == c) {    //\r\n                minDistances[i] = 0;\r\n                cursorFirst = i;\r\n                cursorSecond = s.indexOf(c, i + 1);\r\n                // 如果数组下标所处位置的字符不是字符c，则计算该处与最近的左右两侧字符c的距离，并取最小值\r\n            } else {\r\n                minDistances[i] = Math.min(Math.abs(cursorFirst - i), Math.abs(cursorSecond - i));\r\n            }\r\n        }\r\n        return minDistances;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n时间复杂度：O(N) \r\n空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Gentlemancj":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836575050","body":"```var addToArrayForm = function(num, k) {\r\n  let isOverflow = false, index = num.length - 1, res = [];\r\n  while(index > -1 || k) {\r\n     const num1 = num[index] || 0, num2 = k % 10;\r\n     let sum = num1 + num2;\r\n     if(isOverflow) {\r\n          sum = sum + 1;\r\n     }\r\n      isOverflow = sum >= 10;\r\n      res.unshift(sum % 10);\r\n      k = (k / 10) | 0;\r\n      index--;\r\n      \r\n  }\r\n  if(isOverflow) res.unshift(1);\r\n  return res;\r\n};\r\n**复杂度分析**\r\n\r\n- 空间复杂度O(n)\r\n- 时间复杂度O(n) "},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837600585","body":"**暴力破解法**\r\n\r\n```\r\nvar shortestToChar = function (s, c) {\r\n  let index = 0, len = s.length, res = [];\r\n  while (index < len) {\r\n    let head = tail = index;\r\n    while (head > -1 || tail < len) {\r\n      const headC = s[head], tailC = s[tail];\r\n      if (headC === c) {\r\n        res.push(index - head);\r\n        break;\r\n      };\r\n      if (tailC === c) {\r\n        res.push(tail - index);\r\n        break;\r\n      }\r\n      head--;\r\n      tail++;\r\n    }\r\n    index++;\r\n  }\r\n  return res\r\n};\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837600585","body":"**暴力破解法**\r\n\r\n```\r\nvar shortestToChar = function (s, c) {\r\n  let index = 0, len = s.length, res = [];\r\n  while (index < len) {\r\n    let head = tail = index;\r\n    while (head > -1 || tail < len) {\r\n      const headC = s[head], tailC = s[tail];\r\n      if (headC === c) {\r\n        res.push(index - head);\r\n        break;\r\n      };\r\n      if (tailC === c) {\r\n        res.push(tail - index);\r\n        break;\r\n      }\r\n      head--;\r\n      tail++;\r\n    }\r\n    index++;\r\n  }\r\n  return res\r\n};\r\n```\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LiangZheCoder":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836576433","body":"思路：模拟进位加法，同样适用于链表\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //用于标识数组的位置\r\n        int len = num.length - 1;\r\n        //用于标识是否发生进位\r\n        int isCarry = 0;\r\n        //统计每一轮的值，提前创建，增加效率\r\n        int val = 0;\r\n        //用于保存结果，使用头插法插入链表\r\n        List<Integer> res = new LinkedList<>();\r\n        while(len > -1 || k > 0){\r\n            if(k > 0){\r\n                val = k % 10;\r\n                k = k / 10;\r\n            }\r\n            if(len > -1){\r\n                val += num[len];\r\n            }\r\n            val += isCarry;\r\n            isCarry = val / 10;\r\n            val = val % 10;\r\n            res.add(0,val);\r\n            len--;\r\n            val = 0;\r\n        }\r\n        if(isCarry > 0){\r\n            res.add(0,1);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n\r\n时间复杂度O(n)\r\n空间复杂度O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837861038","body":"- 思路\r\n\r\n暴力法，判断前后的距离，找到第一个目标字符的位置则停止，然后左右比较大小\r\n```\r\n\r\n- 代码\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] answer = new int[s.length()];\r\n        int min1 = Integer.MAX_VALUE;\r\n        int min2 = Integer.MAX_VALUE;\r\n        for(int i = 0 ; i < s.length() ; i++){\r\n            if(s.charAt(i) == c){\r\n                answer[i] = 0;\r\n                continue;\r\n            }\r\n            for(int j = i ; j < s.length() ; j++){\r\n                if(s.charAt(j) == c){\r\n                    min1 = Math.abs(i-j);\r\n                    break;\r\n                }\r\n            }\r\n            for(int j = i ; j > -1 ; j--){\r\n                if(s.charAt(j) == c){\r\n                    min2 = Math.abs(i-j);\r\n                    break;\r\n                }\r\n            }\r\n            answer[i] = Math.min(min1,min2);\r\n            min1 = Integer.MAX_VALUE;\r\n            min2 = Integer.MAX_VALUE;\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```\r\n\r\n- 复杂度\r\n时间：O(N^2) 外层循环数组长度，内层循环近似数组长度\r\n空间：O(N) 开辟和数组长度相等的数组\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837861038","body":"- 思路\r\n\r\n暴力法，判断前后的距离，找到第一个目标字符的位置则停止，然后左右比较大小\r\n```\r\n\r\n- 代码\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] answer = new int[s.length()];\r\n        int min1 = Integer.MAX_VALUE;\r\n        int min2 = Integer.MAX_VALUE;\r\n        for(int i = 0 ; i < s.length() ; i++){\r\n            if(s.charAt(i) == c){\r\n                answer[i] = 0;\r\n                continue;\r\n            }\r\n            for(int j = i ; j < s.length() ; j++){\r\n                if(s.charAt(j) == c){\r\n                    min1 = Math.abs(i-j);\r\n                    break;\r\n                }\r\n            }\r\n            for(int j = i ; j > -1 ; j--){\r\n                if(s.charAt(j) == c){\r\n                    min2 = Math.abs(i-j);\r\n                    break;\r\n                }\r\n            }\r\n            answer[i] = Math.min(min1,min2);\r\n            min1 = Integer.MAX_VALUE;\r\n            min2 = Integer.MAX_VALUE;\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```\r\n\r\n- 复杂度\r\n时间：O(N^2) 外层循环数组长度，内层循环近似数组长度\r\n空间：O(N) 开辟和数组长度相等的数组\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"w-z-hub":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836584325","body":"语言：java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList<>();\r\n\r\n        for(int i=num.length-1; i>=0; i--){\r\n \r\n            int temp = num[i] + k;\r\n            int temp1 = temp%10;\r\n            ans.add(0, temp1);\r\n            k= temp/10;\r\n            \r\n        }\r\n\r\n        while(k>0){\r\n            ans.add(0, k%10);\r\n            k/=10;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840572016","body":"class Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        num, ans = 0, ''\r\n        # 辅助栈\r\n        stack = []\r\n        for ss in s:    \r\n            if ss == '[':\r\n                # 存 '[' 前的字母和数字\r\n                stack.append([num, ans])\r\n                num, ans = 0, ''\r\n            elif ss == ']':\r\n                if stack:\r\n                    n, a = stack.pop()\r\n                ans = a + n * ans\r\n            elif '0' <= ss <= '9':\r\n                num = num * 10 + int(ss)\r\n            else: ans += ss\r\n        return ans"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Kuroky-Chen":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836597120","body":"#### 思路：逐位将数字加一起\r\n代码：javascript\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yulecc":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836599276","body":"思路\r\n遍历数组,不断做空k,从k的个位数开始提取 , 和数组最后一项开始相加 , 一直往前 , 和大于10, k就加1, 最后遍历k,最后反转数组\r\n\r\n关键点\r\n代码\r\n语言支持：JavaScript\r\nJavaScript Code:\r\n\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n\r\n\r\n复杂度分析\r\n\r\n令 n 为数组长度。\r\n\r\n时间复杂度：O(n)O(n)\r\n空间复杂度：O(1)O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838266285","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n遍历字符串,两个指针从左找一次,从右找一次\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    var res = new Array(s.length).fill(0)\r\n\r\n    for(var i=0;i <s.length; i++) {\r\n        var l = i, r=i, shortest = Infinity\r\n        if(s[i] === c) continue\r\n        while(l>=0){\r\n            if(s[l] === c){\r\n                shortest = Math.min(shortest, i - l)\r\n                break;\r\n            }\r\n            l--\r\n        }\r\n        while(r<s.length){\r\n            if(s[r] === c){\r\n                shortest = Math.min(shortest, r - i)\r\n                break;\r\n            }\r\n            r++\r\n        }\r\n        res[i] = shortest\r\n    }\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838266285","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n遍历字符串,两个指针从左找一次,从右找一次\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    var res = new Array(s.length).fill(0)\r\n\r\n    for(var i=0;i <s.length; i++) {\r\n        var l = i, r=i, shortest = Infinity\r\n        if(s[i] === c) continue\r\n        while(l>=0){\r\n            if(s[l] === c){\r\n                shortest = Math.min(shortest, i - l)\r\n                break;\r\n            }\r\n            l--\r\n        }\r\n        while(r<s.length){\r\n            if(s[r] === c){\r\n                shortest = Math.min(shortest, r - i)\r\n                break;\r\n            }\r\n            r++\r\n        }\r\n        res[i] = shortest\r\n    }\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840505699","body":"\r\n## 题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n\r\n\r\n示例 3：\r\n\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n\r\n\r\n示例 4：\r\n\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\nlet numStack = [];        // 存倍数的栈\r\n    let strStack = [];        // 存 待拼接的str 的栈\r\n    let num = 0;              // 倍数的“搬运工”\r\n    let result = '';          // 字符串的“搬运工”\r\n    for (const char of s) {   // 逐字符扫描\r\n        if (!isNaN(char)) {   // 遇到数字\r\n            num = num * 10 + Number(char); // 算出倍数\r\n        } else if (char == '[') {  // 遇到 [\r\n            strStack.push(result); // result串入栈\r\n            result = '';           // 入栈后清零\r\n            numStack.push(num);    // 倍数num进入栈等待\r\n            num = 0;               // 入栈后清零\r\n        } else if (char == ']') {  // 遇到 ]，两个栈的栈顶出栈\r\n            let repeatTimes = numStack.pop(); // 获取拷贝次数\r\n            result = strStack.pop() + result.repeat(repeatTimes); // 构建子串\r\n        } else {                   \r\n            result += char;        // 遇到字母，追加给result串\r\n        }\r\n    }\r\n    return result;\r\n\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fyyjyx-github":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836606794","body":"### 思路\r\n\r\n先将整数数组A转为一个字符串，再将字符串转为数值类型后与整数K相加，再将得到的数值结果转为int类型的数组。\r\n\r\n### 代码\r\n\r\nPython3\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        # 先将整数数组A转为一个字符串，再将字符串转为数值类型后与整数K相加\r\n        res_num = eval(''.join(map(str, A))) + K\r\n        # 将得到的数值结果先转为字符串，再将其转为int类型的数组\r\n        return list(map(int, str(res_num)))\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n)，其中 n 为数组的长度。\r\n- 空间复杂度：O(1)。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"YuanWenLai":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836610752","body":"### 思路 \r\n \r\n数组的数值操作\r\n1、倒序遍历数组\r\n2、用一个进位数来保存溢出状态carryNum\r\n3、k值每次使用后剔除个位数的值\r\n \r\n \r\n### 代码 \r\n### js\r\n \r\n``` js\r\n \r\n    let len = num.length - 1\r\n    // 用一个进位数来保存上一位的溢出情况\r\n    let carryNum = 0\r\n    let number = []\r\n    while(len >= 0 || k!=0) {\r\n        let sum = carryNum\r\n        if(len >= 0) {\r\n            sum += num[len]\r\n            len--\r\n        }\r\n        if(k!=0) {\r\n            sum += k%10\r\n            // 剔除k的个位\r\n            k = Math.floor(k/10)\r\n        }\r\n        // 保存新的进位数\r\n        carryNum = Math.floor(sum/10)\r\n        number.unshift(sum % 10)\r\n    }\r\n    if(carryNum > 0) {\r\n        number.unshift(carryNum)\r\n    }\r\n    return number\r\n \r\n``` \r\n \r\n**复杂度分析** - 时间复杂度：O(N)，其中 N 为数组⻓度。 - 空间复杂度：O（N）"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837560949","body":"### 思路 \r\n \r\n数组的遍历(正向遍历和反向遍历)\r\n1、先得到一个反向的字符串\r\n2、获取正向反向目标字符的下标\r\n3、正向遍历和反向遍历获取对应距离的数组\r\n4、正向遍历和反向遍历的数组间比较最小值返回\r\n \r\n \r\n### 代码 \r\n \r\n \r\n``` js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    if(s.length === 1) return [0]\r\n    let antiS = s.split('').reverse().join('')\r\n    let antiArr = []\r\n    let arr = []\r\n    let index = s.indexOf(c)\r\n    let antiIndex = antiS.indexOf(c)\r\n    for(let i=0;i<s.length;i++) {\r\n        // 正序数组遍历\r\n        if(s[i] !=c){\r\n            arr.push(Math.abs(i - index))\r\n        }else {\r\n            arr.push(0)\r\n            index = i\r\n        }\r\n\r\n        // 反序数组遍历\r\n        if(antiS[i] != c ){\r\n            antiArr.unshift(Math.abs(i - antiIndex))\r\n        }else {\r\n            antiArr.unshift(0)\r\n            antiIndex = i\r\n        }\r\n    }\r\n    return arr.map((item,index) => Math.min(item,antiArr[index]))\r\n};\r\n``` \r\n \r\n**复杂度分析** - 时间复杂度：O(N)，其中 N 为数组⻓度。 - 空间复杂度：O（N）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837560949","body":"### 思路 \r\n \r\n数组的遍历(正向遍历和反向遍历)\r\n1、先得到一个反向的字符串\r\n2、获取正向反向目标字符的下标\r\n3、正向遍历和反向遍历获取对应距离的数组\r\n4、正向遍历和反向遍历的数组间比较最小值返回\r\n \r\n \r\n### 代码 \r\n \r\n \r\n``` js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    if(s.length === 1) return [0]\r\n    let antiS = s.split('').reverse().join('')\r\n    let antiArr = []\r\n    let arr = []\r\n    let index = s.indexOf(c)\r\n    let antiIndex = antiS.indexOf(c)\r\n    for(let i=0;i<s.length;i++) {\r\n        // 正序数组遍历\r\n        if(s[i] !=c){\r\n            arr.push(Math.abs(i - index))\r\n        }else {\r\n            arr.push(0)\r\n            index = i\r\n        }\r\n\r\n        // 反序数组遍历\r\n        if(antiS[i] != c ){\r\n            antiArr.unshift(Math.abs(i - antiIndex))\r\n        }else {\r\n            antiArr.unshift(0)\r\n            antiIndex = i\r\n        }\r\n    }\r\n    return arr.map((item,index) => Math.min(item,antiArr[index]))\r\n};\r\n``` \r\n \r\n**复杂度分析** - 时间复杂度：O(N)，其中 N 为数组⻓度。 - 空间复杂度：O（N）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840216126","body":"### 思路 \r\n \r\n1、遍历字符串，将数字存入numArr，非数字存入stack\r\n2、如果不是']'，入栈\r\n3、否则计算当前匹配括号内的字符串\r\n \r\n \r\n### 代码 \r\n \r\n \r\n``` js\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\n var decodeString = function(s) {\r\n    let stack = []\r\n    let numArr = []\r\n    for(let i=0;i<s.length;i++) {\r\n        if(Number.isInteger(s[i]*1) && i > 0 && Number.isInteger(s[i-1]*1)) {\r\n            numArr[numArr.length-1] += s[i]\r\n        }else if(Number.isInteger(s[i]*1)) {\r\n            numArr.push(s[i])\r\n        }else if(s[i] != ']') {\r\n            stack.push(s[i])\r\n        }else {\r\n            formatStack(stack,numArr)\r\n        }\r\n    }\r\n    return stack.join('')\r\n};\r\n\r\nfunction formatStack(stack,numArr) {\r\n    let str = ''\r\n    let retStr = ''\r\n    let num = numArr.pop()\r\n    while(s = stack.pop(), s != '[') {\r\n        str = s + str\r\n    }\r\n    retStr = str\r\n    for(let i = 0;i<num*1 -1;i++) {\r\n        retStr += str\r\n    }\r\n    stack.push(retStr)\r\n}\r\n \r\n``` \r\n \r\n**复杂度分析** \r\n- 时间复杂度：O(N) \r\n- 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mengwwww":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836631365","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        queue<int> temp;\r\n        stack<int> res;\r\n        while(k!=0){\r\n            temp.push(k%10);\r\n            k = k/10;\r\n        }\r\n        int i=num.size()-1;\r\n        int jinwei = 0;\r\n        while(i>=0 && !temp.empty()){\r\n            res.push((num[i]+temp.front()+jinwei)%10);\r\n            jinwei = (num[i]+temp.front()+jinwei)/10;\r\n            i--;\r\n            temp.pop();\r\n        }\r\n        if(i>=0){\r\n            for(int k = i;k>=0;k--){\r\n                res.push((num[k]+jinwei)%10);\r\n                jinwei = (num[k]+jinwei)/10;\r\n            }\r\n        }\r\n        if(!temp.empty()){\r\n            while(!temp.empty()){\r\n                res.push((temp.front()+jinwei)%10);\r\n                jinwei = (temp.front()+jinwei)/10;\r\n                temp.pop();\r\n            }\r\n            \r\n        }\r\n        if(jinwei>0){\r\n            res.push(jinwei);\r\n        }\r\n        vector<int> m;\r\n        while(!res.empty()){\r\n            m.push_back(res.top());\r\n            res.pop();\r\n        }\r\n        return m;\r\n    }\r\n};\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837634708","body":"### 思路\r\n使用队列存储对应字符下标所在位置\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        queue<int> q;\r\n        for(int i=0;i<s.length();i++){\r\n            if(c==s[i]){\r\n                q.push(i);\r\n            }\r\n        }\r\n        vector<int> res;\r\n        int a = q.front();\r\n        q.pop();\r\n        for(int i=0;i<s.length();i++){\r\n            if(q.empty() || abs(i-a)<=abs(i-q.front())){\r\n                res.push_back(abs(i-a));                \r\n            }else if(!q.empty() && abs(i-a)>abs(i-q.front())){\r\n                a = q.front();\r\n                q.pop();\r\n                i--;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 o(n)\r\n空间复杂度o(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837634708","body":"### 思路\r\n使用队列存储对应字符下标所在位置\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        queue<int> q;\r\n        for(int i=0;i<s.length();i++){\r\n            if(c==s[i]){\r\n                q.push(i);\r\n            }\r\n        }\r\n        vector<int> res;\r\n        int a = q.front();\r\n        q.pop();\r\n        for(int i=0;i<s.length();i++){\r\n            if(q.empty() || abs(i-a)<=abs(i-q.front())){\r\n                res.push_back(abs(i-a));                \r\n            }else if(!q.empty() && abs(i-a)>abs(i-q.front())){\r\n                a = q.front();\r\n                q.pop();\r\n                i--;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 o(n)\r\n空间复杂度o(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JohnVSD":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836632025","body":"## 思路\r\n\r\n参考了官方题解。\r\n\r\n从低位向高位依次计算。例如：123+912，计算过程是 3+2，2+1，1+9 可以得出结果为 1035；可以转换为如下代码：\r\n\r\n## 代码\r\nJavaScript\r\n\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];\r\n    let n = num.length;\r\n    \r\n    for (let i = n - 1; i>=0; i--) {\r\n        // 利用取余操作，取出k值最后一位进行加运算\r\n        let sum = num[i] + k % 10;\r\n        // 利用向下取整的方式，去掉k最后一位数，依次计算\r\n        k = Math.floor(k / 10);\r\n        \r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        \r\n        res.push(sum);\r\n    }\r\n    \r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    \r\n    res.revers();\r\n    \r\n    return res;\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(max(n, log k))\r\n* 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838735759","body":"## 思路\r\n\r\n分别从字符串左右进行遍历，比较然后取最小值。\r\n\r\n## 代码\r\nTypeScript\r\n\r\n```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n  let res: number[] = Array(s.length).fill(0);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) continue;\r\n\r\n    let l: number = i;\r\n    let r: number = i;\r\n    let shortest: number= Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (s[l] === c) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r<s.length) {\r\n      if (s[r] === c) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(N²)\r\n* 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838735759","body":"## 思路\r\n\r\n分别从字符串左右进行遍历，比较然后取最小值。\r\n\r\n## 代码\r\nTypeScript\r\n\r\n```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n  let res: number[] = Array(s.length).fill(0);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) continue;\r\n\r\n    let l: number = i;\r\n    let r: number = i;\r\n    let shortest: number= Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (s[l] === c) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r<s.length) {\r\n      if (s[r] === c) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(N²)\r\n* 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840614479","body":"## 思路\r\n\r\n利用栈进行实现，遍历字符串，在遇到闭合符号 ']' 之前一直进行入栈操作 --> 直到遇到 ‘]’ 便进行出栈操作 --> 创建变量存储 “需要重复的字符” 和 “重复次数” \r\n 内部使用 while 循环进行逐个判断与出栈。\r\n\r\n## 代码 (TS)\r\n\r\n```typescript\r\nfunction decodeString(s: string): string {\r\n  let stack = [];\r\n  for (let i = 0; i < s.length; i++) {\r\n    // 遇到 ']' 就出栈\r\n    if (s[i] === ']') {\r\n      let repeatStr = ''; // 记录需要重复的字符\r\n      let num = ''; // 记录数字\r\n\r\n      // 将需要重复的字符进行存储\r\n      while (stack[stack.length - 1] !== '[') {\r\n        repeatStr = stack.pop() + repeatStr;\r\n      }\r\n      // 去除 '['\r\n      stack.pop();\r\n\r\n      // 取出数字\r\n      while (!isNaN(stack[stack.length - 1])) {\r\n        num = stack.pop() + num;\r\n      }\r\n\r\n      // 重复 num 次 repeatStr\r\n      repeatStr = repeatStr.repeat(parseInt(num));\r\n      stack.push(repeatStr)\r\n    } else {\r\n      // 值不等于 ']' 就入栈\r\n      stack.push(s[i]);\r\n    }\r\n  }\r\n  \r\n  return stack.join('');\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"QiZhongdd":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836634467","body":"思路\r\n数组的数值操作\r\n1：新建一个数组用于存储变量\r\n2:倒序遍历数组，每个值与K的余数相加，如果和小于0，那么push这个和，如果大于0，那么push该和的个位数，K为十位数。\r\n3：依次遍历，重复第一步骤，等到遍历完后，如果k继续大于0,那么依次将k的值一个个添加进res数组。\r\n4：对结果进行翻转得到数字\r\n\r\nfunction add(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n\r\n复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838362553","body":"思路1\r\n左右各遍历一次,找到相同值的位置，比较左右最快找到值的坐标，然后得到绝对值比较，取小值\r\n\r\nvar shortestToChar = function(s, c) {\r\n   let prev=-Infinity,result=[];\r\n   for(let i=0;i<s.length;i++){\r\n       if(s.charAt(i)===c){\r\n           prev=i\r\n       }\r\n       result[i]=Math.abs(i-prev)\r\n   }\r\n   prev=Infinity\r\n   for(let j=s.length-1;j>=0;--j){\r\n        if(s.charAt(j)===c){\r\n           prev=j\r\n       }\r\n       result[j]=Math.min(result[j],Math.abs(prev-j))\r\n   }\r\n   return result\r\n};\r\n复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n思路2\r\n先循环遍历一次，找到相同值的位置保存在一个数组ans中\r\n再次循环，将坐标与ans中的坐标差的绝对值，取最小的值\r\nvar shortestToChar = function(s, c) {\r\n    let ans=[],result=[];\r\n    for(let i=0;i<s.length;i++){\r\n        if(s.charAt(i)===c){\r\n            ans.push(i)\r\n        }\r\n    }\r\n    for(let i=0;i<s.length;i++){\r\n        let min=Math.abs(i-ans[0])\r\n        for(let j=1;j<ans.length;j++){\r\n            min=Math.min(min,Math.abs(i-ans[j]))\r\n        }\r\n        result[i]=min\r\n    }\r\n    return result\r\n};\r\n复杂度\r\n时间复杂度：O(n2)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838362553","body":"思路1\r\n左右各遍历一次,找到相同值的位置，比较左右最快找到值的坐标，然后得到绝对值比较，取小值\r\n\r\nvar shortestToChar = function(s, c) {\r\n   let prev=-Infinity,result=[];\r\n   for(let i=0;i<s.length;i++){\r\n       if(s.charAt(i)===c){\r\n           prev=i\r\n       }\r\n       result[i]=Math.abs(i-prev)\r\n   }\r\n   prev=Infinity\r\n   for(let j=s.length-1;j>=0;--j){\r\n        if(s.charAt(j)===c){\r\n           prev=j\r\n       }\r\n       result[j]=Math.min(result[j],Math.abs(prev-j))\r\n   }\r\n   return result\r\n};\r\n复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n思路2\r\n先循环遍历一次，找到相同值的位置保存在一个数组ans中\r\n再次循环，将坐标与ans中的坐标差的绝对值，取最小的值\r\nvar shortestToChar = function(s, c) {\r\n    let ans=[],result=[];\r\n    for(let i=0;i<s.length;i++){\r\n        if(s.charAt(i)===c){\r\n            ans.push(i)\r\n        }\r\n    }\r\n    for(let i=0;i<s.length;i++){\r\n        let min=Math.abs(i-ans[0])\r\n        for(let j=1;j<ans.length;j++){\r\n            min=Math.min(min,Math.abs(i-ans[j]))\r\n        }\r\n        result[i]=min\r\n    }\r\n    return result\r\n};\r\n复杂度\r\n时间复杂度：O(n2)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840550016","body":"\r\nvar decodeString = function(s) {\r\n    const stack = [];\r\n    const peek = () => stack[stack.length - 1]; // p.s. 不正经栈\r\n    const reg = /[a-zA-Z]+|[0-9]+|\\[|\\]/g;\r\n    while (reg.lastIndex < s.length) {\r\n        let token = reg.exec(s)[0];\r\n        if (token !== ']') {\r\n            // 数字，字母，左括号通通入栈\r\n            stack.push(token);\r\n        } else {\r\n            // 遇到右括号就开始出栈\r\n            let str = '';\r\n            // [] 中间的就是要重复的模式，把它们全部出栈，拼接起来\r\n            while (peek() !== '[') {\r\n                str = stack.pop() + str;\r\n            }\r\n            // 丢掉左括号\r\n            stack.pop();\r\n            // 左括号前面的一定是模式重复的次数\r\n            const num = +stack.pop();\r\n            // 把复制操作后的字符串放回栈中，作为外层 [] 模式的一部分\r\n            stack.push(str.repeat(num));\r\n        }\r\n    }\r\n    return stack.join('');\r\n};"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LS-King":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836635602","body":"### 思路\r\n\r\n重点关注进位：\r\n\r\n1. 设置中间变量digit，存放数字k、数组num和前位进位到该数位值的和（可以大于9），模10之后作为新的该数位数值，除10后的进位进入下层循环\r\n2. 对于最高位，需要考虑进位的位数增加带来的数组长度改变的问题，设置判断条件插入新的最高位，同时注意下标的改变\r\n\r\n### 代码\r\nC++\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int length = num.size();\r\n        int index = length;\r\n        int digit = 0;\r\n        while (k != 0 || digit != 0) {\r\n            //如果上一轮循环中已更新到num最高位，则在前面添加一个数位，将其值置为0\r\n            if (index == 0) {\r\n                num.insert(num.begin(), 0);\r\n            //下标迭代，每层循环向高位移动1位\r\n            } else {\r\n                index -= 1;\r\n            }\r\n            //上层循环的进位加上本轮循环对应数位上的值构成新的待定数位新值（可能超过9）\r\n            digit += k % 10;\r\n            //k去掉最后一位，等待下一轮循环\r\n            k /= 10;\r\n            //相同数位上数字相加（可能超过9）\r\n            digit += num[index];\r\n            //取个位部分作为该数位的新值\r\n            num[index] = digit % 10;\r\n            //将超过9的部分留到下一次循环\r\n            digit /= 10;\r\n        }\r\n        return num;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)，使用传进来的源数组num的空间。\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838681307","body":"### 思路\r\n\r\n开辟一个数组 chIndex 存放匹配字符的下标，之后遍历字符串，逐字符计算其下标与所有匹配字符下标差的绝对值，取最小值存入res数组\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> chIndex;\r\n        vector<int> res;\r\n        //遍历字符串，将匹配字符下标存入数组chIndex\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] == c) {\r\n                chIndex.push_back(i);\r\n            }\r\n        }\r\n        //遍历数组，逐字符计算其下标与所有匹配字符下标差的绝对值，取最小值存入res数组\r\n        for (int i = 0; i < s.size(); i++) {\r\n            //最大距离不超过10000\r\n            int distance = 10000;\r\n            for (int index : chIndex) {\r\n                distance = min(distance, abs(index - i));\r\n            }\r\n            res.push_back(distance);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N^2)，其中 N 为字符串长度。\r\n- 空间复杂度：O(N)，其中 N 为字符串长度。\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838681307","body":"### 思路\r\n\r\n开辟一个数组 chIndex 存放匹配字符的下标，之后遍历字符串，逐字符计算其下标与所有匹配字符下标差的绝对值，取最小值存入res数组\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> chIndex;\r\n        vector<int> res;\r\n        //遍历字符串，将匹配字符下标存入数组chIndex\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] == c) {\r\n                chIndex.push_back(i);\r\n            }\r\n        }\r\n        //遍历数组，逐字符计算其下标与所有匹配字符下标差的绝对值，取最小值存入res数组\r\n        for (int i = 0; i < s.size(); i++) {\r\n            //最大距离不超过10000\r\n            int distance = 10000;\r\n            for (int index : chIndex) {\r\n                distance = min(distance, abs(index - i));\r\n            }\r\n            res.push_back(distance);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N^2)，其中 N 为字符串长度。\r\n- 空间复杂度：O(N)，其中 N 为字符串长度。\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840569699","body":"### 思路\r\n\r\n开辟一个存放整型的栈 sig 用来匹配和存放前中括号的下标，遇到 [ 将其下标入栈；遇到 ] 则弹栈，并向前寻找出重复次数，将重复后的新子串替换掉”数字+[原子串]“。\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string nums = \"0123456789\", res = s, numstr = \"\", sub = \"\";\r\n        //前括号下标栈\r\n        stack<int> sig;\r\n        int num, front, back, p = 0;\r\n        while (res[p] != '\\0') {\r\n            //若匹配到[，则将下标入栈\r\n            if (res[p] == '[') {\r\n                sig.push(p);\r\n            //若匹配到]，则将sig栈顶下标出栈，并对front, back赋值\r\n            } else if (res[p] == ']') {\r\n                front = sig.top();\r\n                sig.pop();\r\n                back = p;\r\n                //使用q作为下标寻找数字\r\n                int q = front - 1;\r\n                //向前寻找数字，跳出循环时，数字开始下标为q + 1\r\n                while (q >= 0 && nums.find(res[q]) != string::npos) {\r\n                    numstr += res[q];\r\n                    q--;\r\n                }\r\n                //将numstr逆序并转换为整型存入num\r\n                reverse(numstr.begin(), numstr.end());\r\n                num = stoi(numstr);\r\n                //将数字字符串重新置空\r\n                numstr = \"\";\r\n                //替换括号中的字符串\r\n                for (int i = 0; i < num; i++) {\r\n                    sub += res.substr(front + 1, back - front - 1);\r\n                }\r\n                res.replace(q + 1, back - (q + 1) + 1, sub);\r\n                //将字串重新置空\r\n                sub = \"\";\r\n                //修改遍历下标p的位置，使其指向替换后子串的结尾\r\n                p = q + 1 + num * (back - front - 1);\r\n                continue;\r\n            }\r\n            p++;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N), 其中N为字符串s的长度。\r\n- 空间复杂度：O(k), k为原字符串中中括号的对数。\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heartinn":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836635929","body":"思路\r\n列表转数字直接相加再转回列表\r\n\r\n代码\r\nPython3\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        return map(int,str(int(''.join(map(str,A))) + K))\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838007634","body":"算法思想：\r\n前向遍历记录下每个位置和出现在前面的目标字符的距离，后向遍历记录每个位置和出现在后面的目标字符的距离\r\n\r\n代码：\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [len(s)] * len(s)\r\n        previous = -1\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                previous = i\r\n            if previous != -1:\r\n                result[i] = i - previous\r\n        latter = -1\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                latter = i\r\n            if latter != -1:\r\n                result[i] = min(result[i], latter - i)\r\n        return result\r\n\r\n复杂度\r\n时间：o(n)\r\n空间：o(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838007634","body":"算法思想：\r\n前向遍历记录下每个位置和出现在前面的目标字符的距离，后向遍历记录每个位置和出现在后面的目标字符的距离\r\n\r\n代码：\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [len(s)] * len(s)\r\n        previous = -1\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                previous = i\r\n            if previous != -1:\r\n                result[i] = i - previous\r\n        latter = -1\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                latter = i\r\n            if latter != -1:\r\n                result[i] = min(result[i], latter - i)\r\n        return result\r\n\r\n复杂度\r\n时间：o(n)\r\n空间：o(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840651779","body":"思路：\r\n遇到[时push进数字，遇到]时pop出子字符串，push进倍乘后的字符串\r\n\r\n复杂度分析：\r\n时间：单次for O(n)\r\n空间：O(n)\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        num = 0\r\n        string = \"\"\r\n        for token in s:\r\n            if token.isdigit():\r\n                num = num * 10 + int(token)\r\n            elif token == \"[\":\r\n                stack.append(num)\r\n                num = 0\r\n            elif token.isalpha():\r\n                stack.append(token)\r\n            else:\r\n                while isinstance(stack[-1], str):\r\n                    string = stack.pop() + string\r\n                stack.append(stack.pop() * string)\r\n                string = \"\"\r\n        return \"\".join(stack)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"UCASHurui":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836637454","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 思路\r\n先把数组A扩展到和K相加后可能的最长长度，然后模拟加法，每次取K的最低位和A中对应位以及进位相加，然后更新进位并将K除10后取整。（其实也可以把A转换成整数后相加，考虑到其他语言可能不像python能够自动进行大数运算所以还是转换成数组相加更好）\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        carry = 0\r\n        len_K, len_A = len(str(K)), len(A)\r\n        A = [0]*(max(len_A, len_K)-len_A + 1) + A\r\n        pos = len(A) - 1\r\n        while K or carry:\r\n                tmp = A[pos] + K%10 + carry\r\n                carry = tmp // 10\r\n                A[pos] = tmp%10\r\n                K = int(K/10)\r\n                pos -= 1\r\n        if A[0]==0: return A[1:]\r\n        return A\r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837870441","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n两趟遍历分别找到每一个位置左方和右方距离最近的目标字符，取其中最小值计入最终结果。\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        povit = -float('inf')\r\n        res = [0] * len(S)\r\n        for i in range(len(S)):\r\n            if S[i] == C:\r\n                povit = i\r\n            else:\r\n                res[i] = i-povit\r\n        povit = float('inf')\r\n        for i in range(len(S)-1, -1, -1):\r\n            if S[i] == C:\r\n                povit = i\r\n            else:\r\n                res[i] = min(res[i], povit-i)\r\n        return res\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837870441","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n两趟遍历分别找到每一个位置左方和右方距离最近的目标字符，取其中最小值计入最终结果。\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        povit = -float('inf')\r\n        res = [0] * len(S)\r\n        for i in range(len(S)):\r\n            if S[i] == C:\r\n                povit = i\r\n            else:\r\n                res[i] = i-povit\r\n        povit = float('inf')\r\n        for i in range(len(S)-1, -1, -1):\r\n            if S[i] == C:\r\n                povit = i\r\n            else:\r\n                res[i] = min(res[i], povit-i)\r\n        return res\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BraveSage":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836638684","body":"## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n### 思路\r\n\r\n1. 模拟数字加法，倒序遍历数组和每次取得整数K的各位数的值进行相加\r\n2. 判断当前位数的数是否大于10，如果大于10在整数k中进行+1\r\n3. 让k除以10，确保计算的位数与数组一致\r\n\r\n\r\n\r\n### 代码（两种思路一致，不过下方节省了一个while循环）\r\n\r\n- Java\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList();\r\n        for(int i = num.length-1; i >= 0; i--){\r\n            int temp = num[i] + k%10;\r\n            ans.add(temp%10);\r\n            k /= 10;\r\n            if(temp >= 10) k++;\r\n        }\r\n        while(k != 0){\r\n            ans.add(k%10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList();\r\n        for(int i = num.length-1; i >= 0 || k > 0; i--, k/=10){\r\n            if(i >= 0){\r\n                k += num[i];\r\n            }\r\n            ans.add(k%10);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\n时间：O(max(n,log(k))) 整数与数组长度之间取最大\r\n\r\n空间：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838733842","body":"## 题目描述\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n- 字符串 S 的长度范围为 [1, 10000]。\r\n- C 是一个单字符，且保证是字符串 S 里的字符。\r\n- S 和 C 中的所有字母均为小写字母。\r\n```\r\n\r\n\r\n\r\n### 思路\r\n\r\n获取指定string的当前前一个为c的索引位置与当前索引位置的最小值即可，然后记录在res数组当中\r\n\r\n### 代码\r\n\r\n- Java\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int length = S.length();\r\n        int[] res = new int[length];\r\n        int prev = S.indexOf(C),next = S.indexOf(C, prev+1);\r\n        for (int i = 0; i < length; i++){\r\n            res[i] = Math.abs(i-prev);\r\n            if(next!=-1){\r\n                res[i] = Math.min(res[i],next-i);\r\n                if(i==next){\r\n                    prev = next;\r\n                    next = S.indexOf(C,next+1);\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：O(n)\r\n\r\n空间：O(n) 创建了为S.length()长度的数组"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838733842","body":"## 题目描述\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n- 字符串 S 的长度范围为 [1, 10000]。\r\n- C 是一个单字符，且保证是字符串 S 里的字符。\r\n- S 和 C 中的所有字母均为小写字母。\r\n```\r\n\r\n\r\n\r\n### 思路\r\n\r\n获取指定string的当前前一个为c的索引位置与当前索引位置的最小值即可，然后记录在res数组当中\r\n\r\n### 代码\r\n\r\n- Java\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int length = S.length();\r\n        int[] res = new int[length];\r\n        int prev = S.indexOf(C),next = S.indexOf(C, prev+1);\r\n        for (int i = 0; i < length; i++){\r\n            res[i] = Math.abs(i-prev);\r\n            if(next!=-1){\r\n                res[i] = Math.min(res[i],next-i);\r\n                if(i==next){\r\n                    prev = next;\r\n                    next = S.indexOf(C,next+1);\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：O(n)\r\n\r\n空间：O(n) 创建了为S.length()长度的数组"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"KevinWorkSpace":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836639151","body":"## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int index = A.length - 1;\r\n        int add = 0;\r\n        while (index >= 0 || K > 0 || add > 0) {\r\n            int a = 0;\r\n            if (index >= 0) a = A[index];\r\n            int b = K % 10;\r\n            int tmp = (a + b + add) % 10;\r\n            add = (a + b + add) / 10;\r\n            res.add(tmp);\r\n            K /= 10;\r\n            index --;\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838339270","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int index = -1;\r\n        for (int i=0; i<res.length; i++) {\r\n            if (s.charAt(i) == c) {\r\n                res[i] = 0;\r\n                index = i;\r\n            }\r\n            else if (index == -1) res[i] = Integer.MAX_VALUE;\r\n            else res[i] = i - index;\r\n        }\r\n        index = -1;\r\n        for (int i=res.length-1; i>=0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            else if (index == -1) res[i] = Math.min(Integer.MAX_VALUE, res[i]);\r\n            else res[i] = Math.min(index - i, res[i]);\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838339270","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int index = -1;\r\n        for (int i=0; i<res.length; i++) {\r\n            if (s.charAt(i) == c) {\r\n                res[i] = 0;\r\n                index = i;\r\n            }\r\n            else if (index == -1) res[i] = Integer.MAX_VALUE;\r\n            else res[i] = i - index;\r\n        }\r\n        index = -1;\r\n        for (int i=res.length-1; i>=0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            else if (index == -1) res[i] = Math.min(Integer.MAX_VALUE, res[i]);\r\n            else res[i] = Math.min(index - i, res[i]);\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ssxgit":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836641307","body":"# 989. 数组形式的整数加法\r\n主要是需要一个进位的表示，最终要保证三个部分都加完\r\n\r\n## 代码\r\n- 语言：c++\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n\r\n        vector<int> res;\r\n\r\n        int carry_bit = 0;\r\n\r\n        int loc = num.size() - 1;\r\n\r\n        while(loc>-1 || k > 0 || carry_bit > 0){\r\n            int num1 = loc>-1?num[loc]:0;\r\n            int num2 = k % 10;\r\n\r\n            int value = num1 + num2 + carry_bit;\r\n\r\n            res.emplace_back((value % 10));\r\n            carry_bit = value / 10; \r\n\r\n            --loc;\r\n            k /= 10;\r\n        }\r\n        \r\n        reverse(res.begin(),res.end());\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838312453","body":"# 821. 字符的最短距离\r\n[leetcode 821](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n## 思路：\r\n1. 从左到右遍历保存每一个字符距离其左边最近的字符 c 的 距离\r\n2. 从右到左遍历保存每一个字符距离其右边最近的字符 c 的 距离\r\n3. 取上面两个距离的更小值即可，可以只用一个数组来存\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        if(s.empty()) return {};\r\n        vector<int> res(s.size(),INT_MAX);\r\n        int pre_c_loc = -1;\r\n        for(int i=0;i<s.size();++i){\r\n            if(s[i] == c){\r\n                pre_c_loc = i;\r\n                res[i] = 0;\r\n            }\r\n            else if(pre_c_loc != -1) res[i] = i - pre_c_loc;\r\n        }\r\n\r\n        pre_c_loc = s.size();\r\n        for(int i=s.size()-1;i>-1;--i){\r\n            if(s[i] == c) pre_c_loc = i;\r\n            else if(pre_c_loc != s.size()) res[i] = min(res[i],pre_c_loc - i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)  //最终需要返回的结果数组不计算复杂度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838312453","body":"# 821. 字符的最短距离\r\n[leetcode 821](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n## 思路：\r\n1. 从左到右遍历保存每一个字符距离其左边最近的字符 c 的 距离\r\n2. 从右到左遍历保存每一个字符距离其右边最近的字符 c 的 距离\r\n3. 取上面两个距离的更小值即可，可以只用一个数组来存\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        if(s.empty()) return {};\r\n        vector<int> res(s.size(),INT_MAX);\r\n        int pre_c_loc = -1;\r\n        for(int i=0;i<s.size();++i){\r\n            if(s[i] == c){\r\n                pre_c_loc = i;\r\n                res[i] = 0;\r\n            }\r\n            else if(pre_c_loc != -1) res[i] = i - pre_c_loc;\r\n        }\r\n\r\n        pre_c_loc = s.size();\r\n        for(int i=s.size()-1;i>-1;--i){\r\n            if(s[i] == c) pre_c_loc = i;\r\n            else if(pre_c_loc != s.size()) res[i] = min(res[i],pre_c_loc - i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)  //最终需要返回的结果数组不计算复杂度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840552440","body":"# 394. 字符串解码\r\n[leetcode 394](https://leetcode-cn.com/problems/decode-string/)\r\n\r\n## 思路: 栈\r\n1. 遍历字符串，字母、数字、左括号直接入栈（变换为字符串）\r\n2. 遇到右括号，一直出栈直到遇到左括号，弹出左括号，按照出栈顺序反向拼接字符串为s1\r\n3. 此时栈顶为数字字符串，即为s1的出现次数t，将s1重复t次，重复后的字符串再入栈\r\n4. 继续上述过程，直到遍历到编码字符串尾部，将栈中字符串弹出，按照出栈顺序反向拼接字符串为r,即为最终答案\r\n5. 这个思路的关键是遇到左括号直接入栈，遇到右括号需要出栈，一直到左括号，将中间的字符串拼接起来\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res;\r\n        vector<string> stk;\r\n        int i=0;\r\n        while(i<s.size()){\r\n            if((s[i]>='a' && s[i]<='z') || s[i] == '['){\r\n                stk.push_back(string(1,s[i]));\r\n                ++i;\r\n            }\r\n            else if(s[i]>='0' && s[i]<='9'){\r\n                stk.push_back(getTime(s,i));\r\n            }\r\n            else{\r\n                string ret;\r\n                vector<string> st_vec;\r\n                while(stk.back() != \"[\"){\r\n                    st_vec.emplace_back(stk.back());stk.pop_back();\r\n                }\r\n                reverse(st_vec.begin(),st_vec.end());  //反向\r\n                string in_st = getString(st_vec); //拼接\r\n                stk.pop_back();\r\n                int times = stoi(stk.back());stk.pop_back();\r\n                while(times--){\r\n                    ret += in_st;\r\n                }\r\n                stk.push_back(ret);\r\n\r\n                ++i;\r\n            }\r\n        }\r\n        for(auto& st:stk){\r\n            res += st;\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    string getTime(const string& s,int& i){\r\n        string times;\r\n        while(s[i]>='0' && s[i]<='9'){\r\n            times.push_back(s[i]);\r\n            ++i;\r\n        }\r\n        return times;\r\n    }\r\n\r\n    string getString(vector<string> str_vector){\r\n        string st;\r\n        for(auto &str:str_vector){\r\n            st += str;\r\n        }\r\n        return st;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(S)  //S为解码后的字符串长度\r\n空间复杂度：O(S) //"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fenglei110":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836644430","body":"python\r\n\r\npython语言的设计就是太动态了，int和str可以互转。\r\n\r\n列表迭代式 + lambda表达式\r\n平时也是这样写，感觉代码很简洁。但是你要问我这样的代码有什么不足，还真答不上来。\r\n\r\n```py\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        return  list(map(int, str(int(''.join(map(str, num)))+k)))\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839817225","body":"> ### 思路\r\n> 给定一个变量来记录栈顶的位置，更新数据来模拟栈的操作，但因为实质是函数内的数组，所以可以实现对除了栈顶元素外的改动。（后续再优化）\r\n> \r\n> ### 代码\r\n> ```python\r\n> class CustomStack:\r\n> # use array in function makes the each elenments in stack \"visable\"\r\n> \r\n>     def __init__(self, maxSize: int):\r\n>         self.stk = [0]*maxSize\r\n>         self.top = -1\r\n> \r\n>     def push(self, x: int) -> None:\r\n>         # if stack size is smaller than maxSize, push in\r\n>         # maxSize is not defined in this function, so use len of stack instead\r\n>         if self.top < len(self.stk)-1:\r\n>             self.stk[self.top+1] = x\r\n>             self.top += 1\r\n> \r\n>     def pop(self) -> int:\r\n>         # if stack is empty, return -1\r\n>         # if stack is not empty, return the top value and delete it in the stack (no need)\r\n>         if self.top == -1:\r\n>             return -1\r\n>         self.top -= 1\r\n>         return self.stk[self.top + 1]\r\n> \r\n>     def increment(self, k: int, val: int) -> None:\r\n>         # use the minimum value between k and self.stk length, then traverse\r\n>         if k>-1:\r\n>             for i in range(min(self.top+1,k)):\r\n>                 self.stk[i]+=val\r\n> ```\r\n> \r\n> **复杂度分析**\r\n> \r\n> * 时间复杂度：O(min(k, maxSize)),\r\n> * 空间复杂度：O(maxSize)\r\n\r\n跑错场了兄弟"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1998yyh":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836644503","body":"### 思路\r\n循环数组按位相加，同时对应修改k，循环完成后当k大于0，再对k处理。\r\n### 代码\r\njavascript\r\n``` javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const len = num.length;\r\n    const resultArr = [];\r\n    for(let i = len -1; i>=0;i--){\r\n        const _num = k%10;\r\n        k = Math.floor(k/10);\r\n        const sum = _num + num[i];\r\n        if(sum>9){\r\n            k++\r\n        }\r\n        resultArr.unshift(sum%10);\r\n    }\r\n    while(k>0){\r\n        resultArr.unshift(k%10)\r\n        k = Math.floor(k/10);\r\n    }\r\n    return resultArr\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838434616","body":"### 思路\r\n用一个变量保存出现的位置，从左往右，从右往左分别遍历一次，取最小值\r\n### 代码\r\njavascript\r\n``` javascript\r\nvar shortestToChar = function (s, c) {\r\n    let flag = -1;\r\n    const len = s.length;\r\n    const result = new Array(len).fill(Infinity);\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] !== c && flag < 0) continue;\r\n        if (s[i] === c) {\r\n            result[i] = 0;\r\n            flag = i\r\n        } else {\r\n            result[i] = Math.min(i - flag, result[i])\r\n        }\r\n    }\r\n    flag = -1;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] !== c && flag < 0) continue;\r\n        if (s[i] === c) {\r\n            result[i] = 0;\r\n            flag = i\r\n        } else {\r\n            result[i] = Math.min(flag - i, result[i])\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838434616","body":"### 思路\r\n用一个变量保存出现的位置，从左往右，从右往左分别遍历一次，取最小值\r\n### 代码\r\njavascript\r\n``` javascript\r\nvar shortestToChar = function (s, c) {\r\n    let flag = -1;\r\n    const len = s.length;\r\n    const result = new Array(len).fill(Infinity);\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] !== c && flag < 0) continue;\r\n        if (s[i] === c) {\r\n            result[i] = 0;\r\n            flag = i\r\n        } else {\r\n            result[i] = Math.min(i - flag, result[i])\r\n        }\r\n    }\r\n    flag = -1;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] !== c && flag < 0) continue;\r\n        if (s[i] === c) {\r\n            result[i] = 0;\r\n            flag = i\r\n        } else {\r\n            result[i] = Math.min(flag - i, result[i])\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840577967","body":"### 思路\r\n使用两个栈分别存储数字与字母\r\n### 代码\r\njavascript\r\n```javascript\r\nvar decodeString = function (s) {\r\n    const numStack = [];\r\n    const strStack = [];\r\n    const len = s.length;\r\n    let num = 0;\r\n    let result = '';\r\n    for (let i = 0; i < len; i++) {\r\n        if (!isNaN(s[i])) {\r\n            num = num * 10 + Number(s[i])\r\n        } else if (s[i] === '[') {\r\n            strStack.push(result);\r\n            result = ''\r\n            numStack.push(num)\r\n            num = 0\r\n        } else if (s[i] === ']') {\r\n            result = strStack.pop() + result.repeat(numStack.pop())\r\n        } else {\r\n            result += s[i]\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joriscai":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836661706","body":"# 思路\r\n先将k转成数组，再利用双指针分别从k和num的最后一位开始按位计算。注：需要考虑最后一次进位的情况。\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=989 lang=javascript\r\n *\r\n * [989] 数组形式的整数加法\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  const kArr = (k + '').split('')\r\n  const ret = []\r\n\r\n  let i = num.length - 1\r\n  let j = kArr.length - 1\r\n  let tmp = 0\r\n  while (i >= 0 || j >= 0 || tmp) {\r\n    const count = parseInt(num[i] || 0) + parseInt(kArr[j] || 0) + tmp\r\n    ret.unshift(count % 10)\r\n    tmp = parseInt(count / 10)\r\n    i--\r\n    j--\r\n  }\r\n  return ret\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(max(n, log k))，其中 n 为数组的长度。log k为k的位，即log 10(k)，10为底k的对数。\r\n空间复杂度：O(max(n, log k))。"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838475940","body":"# 思路\r\n通过字符串正反向遍历，从两种方式中找到最接近的值。\r\n- 注：正反向遍历时，默认值都为正无穷大\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=821 lang=javascript\r\n *\r\n * [821] 字符的最短距离\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const ret = []\r\n  let near = Infinity\r\n  // 从左到右，记录距离\r\n  for (let i = 0; i < s.length; i++) {\r\n    const char = s[i]\r\n    if (char === c) {\r\n      ret.push(0)\r\n      near = 0\r\n    } else {\r\n      ret.push(++near)\r\n    }\r\n  }\r\n\r\n  // 从右到左了，要将距离设为正无穷大\r\n  near = Infinity\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    const char = s[i]\r\n    if (char === c) {\r\n      near = 0\r\n    } else {\r\n      // 比较当前值和右到左的距离，取最小的那个\r\n      ret[i] = Math.min(ret[i], ++near)\r\n    }\r\n  }\r\n\r\n  return ret\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n)，只遍历了两次字符串\r\n\r\n空间复杂度：O(n)，结果跟字符串长度一样"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838475940","body":"# 思路\r\n通过字符串正反向遍历，从两种方式中找到最接近的值。\r\n- 注：正反向遍历时，默认值都为正无穷大\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=821 lang=javascript\r\n *\r\n * [821] 字符的最短距离\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const ret = []\r\n  let near = Infinity\r\n  // 从左到右，记录距离\r\n  for (let i = 0; i < s.length; i++) {\r\n    const char = s[i]\r\n    if (char === c) {\r\n      ret.push(0)\r\n      near = 0\r\n    } else {\r\n      ret.push(++near)\r\n    }\r\n  }\r\n\r\n  // 从右到左了，要将距离设为正无穷大\r\n  near = Infinity\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    const char = s[i]\r\n    if (char === c) {\r\n      near = 0\r\n    } else {\r\n      // 比较当前值和右到左的距离，取最小的那个\r\n      ret[i] = Math.min(ret[i], ++near)\r\n    }\r\n  }\r\n\r\n  return ret\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n)，只遍历了两次字符串\r\n\r\n空间复杂度：O(n)，结果跟字符串长度一样"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840560534","body":"# 思路\r\n- 使用栈来存放最终的输出的内容\r\n- 遍历字符串\r\n  - 当非]右括号时，直接入栈\r\n  - 当遇到]右括号时，开始出栈，直到遇到[左括号。此时的子字符串是要重复的字符串\r\n  - 继续出栈，取重复次数的数值，考虑到大于9的情况，需要不断取栈的值并判断是否为数字\r\n  - 由于栈是最终的结果，再加上需要考虑2[3[ab]]嵌套括号的情况，故待重复的子字符串在组合后，要重新入栈中\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=394 lang=javascript\r\n *\r\n * [394] 字符串解码\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  let result = ''\r\n  const stack = []\r\n  for (let i = 0; i < s.length; i++) {\r\n    const char = s[i]\r\n    if (char !== ']') {\r\n      stack.push(char)\r\n      continue\r\n    }\r\n\r\n    // 当是]时\r\n    let prev = stack.pop()\r\n    let subStr = ''\r\n    // 找到[]里面的字符串\r\n    while (prev !== '[') {\r\n      subStr = prev + subStr\r\n      prev = stack.pop()\r\n    }\r\n\r\n    // 继续往前找数字\r\n    let num = ''\r\n    prev = stack.pop()\r\n    while (!Number.isNaN(Number(prev))) {\r\n      num = prev + num\r\n      prev = stack.pop()\r\n    }\r\n\r\n    // 上面先出栈一个字符，再判断是否为数字，会多取一个字符了。\r\n    stack.push(prev)\r\n    // 经过上面解开一个[]括号后，将拼接好字符串，重新入栈\r\n    stack.push(subStr.repeat(Number(num)))\r\n  }\r\n  return stack.join('')\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n)，只遍历了一次字符串，当中可能涉及出栈的操作\r\n\r\n空间复杂度：O(n)，只用一个栈来存放最终的结果，当中有重复的字符串，最终是大于s.length"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836666773","body":"## 思路\r\n遍历数组， 因为知道在第i位 数等于 i* 10**(len(num)-1) 可以得到数组的和。分解成数组形式时，可以用python的特性转换int 和 str，也可以使用whole divde 和 modulo 一位一位得分别append 到 数组中。这里使用了第一种方法\r\n## 代码\r\nPython\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        leng = len(num)\r\n        sum = 0\r\n        for i in num:\r\n            sum += i* 10**(leng-1)\r\n            leng-=1\r\n        return [int(i) for i in str(sum+k)]\r\n```\r\n### 复杂度分析\r\n时间：O(n)\r\n空间：O(1)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-840323210","body":"## 思路：\r\n先声明一个 array of infinity，从左向右遍历，用prev记录c出现的index，即每个元素等于curr-prev。再从右向左遍历，用nex 记录c出现的index， 即每个元素等于min(output[curr], next-curr)\r\n## 复杂度：\r\nO(n) 时间，空间\r\n## 代码：\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        output = [float(\"inf\")] * len(s)\r\n        prev = float(\"-inf\")\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                output[i] = 0\r\n                prev = i\r\n            else:\r\n                output[i] = i-prev\r\n        \r\n        j = len(s)-1\r\n        nex = float(\"inf\")\r\n        while j >=0:\r\n            if s[j] == c:\r\n                nex = j\r\n            else:\r\n                if nex-j < output[j]:\r\n                    output[j] = nex-j \r\n            j-=1\r\n        return output\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840657658","body":"## 思路\r\n辅助栈，自己想了好久，感觉到了应该使用 递归和 辅助栈，但是具体操作不太会，参考了力扣题解第一篇：\r\nstack 储存前缀的其他字母和本次res 需要重复的次数，遇到\"]\" 即 开始 更新 res\r\n## 复杂度\r\n空间复杂度： O(N)\r\n时间复杂度：O(N)\r\n## Code\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        # stack is used to remember the nested relation \r\n        stack = []\r\n        res = \"\"\r\n        multi = \"\"\r\n        for i in range(0, len(s)):\r\n            if s[i] == \"[\":\r\n                stack.append((res, multi))\r\n                res = \"\"\r\n                multi = \"\"\r\n            elif \"0\" <= s[i] <= \"9\":\r\n                multi += s[i]\r\n            elif \"a\" <= s[i] <= \"z\" or \"A\" <= s[i] <= \"Z\":\r\n                res += s[i]\r\n            elif s[i] == ']':\r\n                (last_res, last_multi) = stack.pop()\r\n                res = last_res + int(last_multi)*res\r\n        return res\r\n```\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wonderful1234":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836682410","body":"解题思路：数组的末尾与k的末尾相加，分别求出进位与余数。\r\n`class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new ArrayList<>();\r\n    int carry = 0;  \r\n    int len = num.length - 1;\r\n\r\n    while (len >= 0 || k != 0) {\r\n        int sum = 0;\r\n        if (len >= 0) {\r\n            sum += num[len];\r\n            len--;\r\n        }\r\n        sum += k % 10 + carry;\r\n        carry = sum / 10;\r\n        list.add(sum % 10);\r\n       k /= 10;\r\n    }\r\n\r\n    if (carry == 1) {\r\n        list.add(carry);\r\n    }\r\n    Collections.reverse(list);\r\n    return list;\r\n\r\n    }\r\n}`\r\n复杂度分析：\r\n时间：O(n)\r\n空间：O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838630501","body":"思路：定义两个数组，分别用于记录正序与倒序遍历字符串 S 时，各元素与字符元素 C 之间的距离，最后将两个数组进行比较，取最小值。\r\n`public static int[] shortestToChar(String S, char C) {\r\n    int[] ascArr = new int[S.length()];\r\n    int[] descArr = new int[S.length()];\r\n\r\n    char[] sarr = S.toCharArray();\r\n    int count = sarr.length;\r\n\r\n    for (int i = 0; i < sarr.length; i++) {\r\n        if (sarr[i] == C) {\r\n            ascArr[i] = 0;\r\n            count = 0;\r\n        } else {\r\n            ascArr[i] = ++count;\r\n        }\r\n    }\r\n    count = sarr.length;\r\n    for (int i = sarr.length - 1; i >= 0; i--) {\r\n        if (sarr[i] == C) {\r\n            descArr[i] = 0;\r\n            count = 0;\r\n        } else {\r\n            descArr[i] = ++count;\r\n        }\r\n    }\r\n    for (int i = 0; i < ascArr.length; i++) {\r\n        ascArr[i] = Math.min(ascArr[i], descArr[i]);\r\n    }\r\n    return ascArr;\r\n}`\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838630501","body":"思路：定义两个数组，分别用于记录正序与倒序遍历字符串 S 时，各元素与字符元素 C 之间的距离，最后将两个数组进行比较，取最小值。\r\n`public static int[] shortestToChar(String S, char C) {\r\n    int[] ascArr = new int[S.length()];\r\n    int[] descArr = new int[S.length()];\r\n\r\n    char[] sarr = S.toCharArray();\r\n    int count = sarr.length;\r\n\r\n    for (int i = 0; i < sarr.length; i++) {\r\n        if (sarr[i] == C) {\r\n            ascArr[i] = 0;\r\n            count = 0;\r\n        } else {\r\n            ascArr[i] = ++count;\r\n        }\r\n    }\r\n    count = sarr.length;\r\n    for (int i = sarr.length - 1; i >= 0; i--) {\r\n        if (sarr[i] == C) {\r\n            descArr[i] = 0;\r\n            count = 0;\r\n        } else {\r\n            descArr[i] = ++count;\r\n        }\r\n    }\r\n    for (int i = 0; i < ascArr.length; i++) {\r\n        ascArr[i] = Math.min(ascArr[i], descArr[i]);\r\n    }\r\n    return ascArr;\r\n}`\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840622862","body":"  思路：将[]之间的字符串存储在字符串栈中，将数字存储在数字栈中，当遇到]时，出栈。\r\n`class Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string t = \"\";\r\n        stack<int> s_num;\r\n        stack<string> s_str;\r\n        int cnt = 0;\r\n        for (int i = 0; i < s.size(); ++i) {\r\n            if (s[i] >= '0' && s[i] <= '9') {\r\n                cnt = 10 * cnt + s[i] - '0';\r\n            } else if (s[i] == '[') {\r\n                s_num.push(cnt);\r\n                s_str.push(t);\r\n                cnt = 0; t.clear();\r\n            } else if (s[i] == ']') {\r\n                int k = s_num.top(); s_num.pop();\r\n                for (int j = 0; j < k; ++j) s_str.top() += t;\r\n                t = s_str.top(); s_str.pop();\r\n            } else {\r\n                t += s[i];\r\n            }\r\n        }\r\n        return s_str.empty() ? t : s_str.top();\r\n    }\r\n};`\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fzzfgbw":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836683816","body":"### 思路\r\n\r\n循环数组从最低位开始带进位累加，额外考虑k位数比较大的情况，最后处理最高位进位。\r\n\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int c = 0;\r\n        for (int i = num.length-1; i >=0; i--) {\r\n            int add = k% 10;\r\n            k /=10;\r\n            int sum = add + num[i] +c;\r\n            if (sum>= 10) {\r\n                sum = sum%10;\r\n                c = 1;\r\n            } else {\r\n                c = 0;\r\n            }\r\n            res.addFirst(sum);\r\n        }\r\n        \r\n        while (k>0){\r\n            int add = k% 10;\r\n            k /=10;\r\n            int sum = add +c;\r\n            if (sum>= 10) {\r\n                sum = sum%10;\r\n                c = 1;\r\n            } else {\r\n                c = 0;\r\n            }\r\n            res.addFirst(sum);\r\n        }\r\n        if (c>0){\r\n            res.addFirst(c);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(max(N,lg k))，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-836954949","body":"### 思路\r\n\r\n\t从左到右，从右到左。c无非在左或者右。先从左到右找到离左边c的距离，再从右到左找离右边c的距离，并判断大小。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n   class Solution {\r\n  public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        char[] chars = s.toCharArray();\r\n        int[] res = new int[length];\r\n       \r\n        int left = -length;\r\n        for (int i = 0; i <length ; i++) {\r\n            if (chars[i] == c){\r\n                left = i;\r\n                res[i] = 0;\r\n            }else {\r\n               res[i] = i-left;\r\n            }\r\n        }\r\n        int right = 2*length;\r\n        for (int i = length-1; i >=0; i--) {\r\n            if (chars[i] == c){\r\n                right = i;\r\n            }else {\r\n                \r\n                    res[i] = Math.min(right-i,res[i]);\r\n                \r\n            }\r\n\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-836954949","body":"### 思路\r\n\r\n\t从左到右，从右到左。c无非在左或者右。先从左到右找到离左边c的距离，再从右到左找离右边c的距离，并判断大小。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n   class Solution {\r\n  public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        char[] chars = s.toCharArray();\r\n        int[] res = new int[length];\r\n       \r\n        int left = -length;\r\n        for (int i = 0; i <length ; i++) {\r\n            if (chars[i] == c){\r\n                left = i;\r\n                res[i] = 0;\r\n            }else {\r\n               res[i] = i-left;\r\n            }\r\n        }\r\n        int right = 2*length;\r\n        for (int i = length-1; i >=0; i--) {\r\n            if (chars[i] == c){\r\n                right = i;\r\n            }else {\r\n                \r\n                    res[i] = Math.min(right-i,res[i]);\r\n                \r\n            }\r\n\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-839987215","body":"### 思路\r\n\r\n 栈，(写得好笨重)\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n     class Solution {\r\n   public String decodeString(String s) {\r\n        char[] chars = s.toCharArray();\r\n        LinkedList<Character> stackIn = new LinkedList<>();\r\n        LinkedList<Character> stackOut = new LinkedList<>();\r\n        for (int i = 0; i < chars.length; i++) {\r\n            if (chars[i] == ']') {\r\n                while (stackIn.peekFirst() != '[') {\r\n                    stackOut.addFirst(stackIn.pollFirst());\r\n                }\r\n                stackIn.pollFirst();\r\n                int sumK = 0;\r\n                int index=1;\r\n                while (!stackIn.isEmpty() && stackIn.peekFirst() < 58 && stackIn.peekFirst() > 47) {\r\n                    sumK +=   (stackIn.pollFirst() - 48)*index;\r\n                    index *=10;\r\n                }\r\n                index = 1;\r\n                for (int j = 0; j < sumK; j++) {\r\n                    for (Character character : stackOut) {\r\n                        stackIn.addFirst(character);\r\n                    }\r\n                }\r\n                stackOut.clear();\r\n            } else {\r\n                stackIn.addFirst(chars[i]);\r\n            }\r\n        }\r\n        StringBuilder sb = new StringBuilder();\r\n        for (int i = stackIn.size() - 1; i >= 0; i--) {\r\n            sb.append(stackIn.get(i));\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)。\r\n- 空间复杂度：O(N)。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"agentzzz":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836691767","body":"### 思路\r\n\r\n将k从最后一位往前加，每次加法的结果对10取余，压入返回数组。然后除以10，与前一位相加。\r\n\r\n可能忘记讨论的情况：\r\n\r\n1. k可能比num的位数要长，因此，要确保k的剩余位数都压入结果数组\r\n2. 压入结果数组的内容是倒序的，collections.reverse()使其倒序（以前用的是C++刷题，java的collections要去了解一下）\r\n\r\n\r\n\r\n### JAVA\r\n\r\n```java\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n\t\tint fin = num.length - 1;\r\n\t\tList<Integer> res = new ArrayList<Integer>();\r\n\t\tint temp = 0;\r\n\t\tfor (int i = fin; i >= 0; i--) {\r\n\t\t\ttemp = num[i] + k;\r\n\t\t\tres.add(temp % 10);\r\n\t\t\tk = temp / 10;\r\n\t\t}\r\n\t\twhile (k > 0) {\r\n\t\t\tres.add(k % 10);\r\n\t\t\tk /= 10;\r\n\t\t}\r\n\t\tCollections.reverse(res);\r\n\t\treturn res;\r\n\t}\r\n```\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837942324","body":"### 思路\r\n\r\n一开始的思路是用双指针，一个表示左边界，一个表示有边界。但是现实实现的时候，需要考虑的情况太多了。\r\n\r\n第一次遍历数组，记录目标字符的位置。\r\n\r\n第二次遍历数组，记录所有元素与左右边界距离的最小值。\r\n\r\n其中，第二次遍历要考虑左右边界的多种情况，没想明白。\r\n\r\n\r\n\r\n第一次写大概花了25分钟，然后去干其他事情。\r\n\r\n第二次修改+debug花了10分钟。\r\n\r\n结果虽然通过了，思路也比较简单，但是代码的逻辑不是很好。\r\n\r\n写完之后大概看了一下题解，又其他更好的方法，晚一点再学习一下。\r\n\r\n\r\n\r\njava\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n\t\tint m=0;\r\n\t\tint[] res = new int[s.length()];\r\n\t\tList<Integer> list = new ArrayList<>();\r\n\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\tif(s.charAt(i)==c) list.add(i);\r\n\t\t}\r\n\t\tint index1=0,index2=0;\r\n\t\tif(list.size()==1) {\r\n\t\t\tindex1=index2=list.get(0);\r\n\t\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\t\tres[i] = Math.abs(i-index1);\r\n\t\t\t}\r\n\t\t\treturn res;\r\n\t\t}\t\r\n\t\tindex1 = list.get(m);\r\n\t\tindex2 = list.get(m+1);\r\n\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\tres[i] = Math.min(Math.abs(i-index1), Math.abs(i-index2));\r\n\t\t\tif(i==index2) {\r\n\t\t\t\tif(index2!=list.get(list.size()-1)) {\r\n\t\t\t\t\tm++;\r\n\t\t\t\t\tindex1 = list.get(m);\r\n\t\t\t\t\tindex2 = list.get(m+1);\r\n\t\t\t\t}\r\n\t\t\t}\t\r\n\t\t}\r\n\t\treturn res;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(n)\r\n\r\n### 法二：正序倒序两遍遍历\r\n\r\n参考题解后，又用思路更加清晰的方法写了一遍。这个不算是自己的产出内容，不仅看了思路，还看了代码的实现方式。\r\n\r\n用时：15min\r\n\r\n第一次从左向右遍历的时候，第一个元素和谁比较，有两种情况\r\n\r\n- 第一个char就是我的目的char，那么令比较索引temp等于第一个字符，后续的字符与它比较，遇到新的目标字符就更新temp 的索引\r\n- 第一个char不是目标字符，那么就要设置比较索引值temp让第一个目标字符出现之前res记录的值足够大，因此，选择Integer.MIN_VALUE/2，这是一个很小的复数，i-temp就是一个很大的整数。\r\n\r\n第二次从又向左遍历，同理。需要考虑最右边的原色和谁比较的问题。设置temp = Integer.MAX_VALUE/2，这样temp-i就是一个足够大的正数。\r\n\r\njava实现\r\n\r\n```java\r\nint[] shortestToChar1(String s,char c) {\r\n\t\tint[] res = new int[s.length()];\r\n\t\tint temp = Integer.MIN_VALUE/2;\r\n\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\tif(s.charAt(i)==c) temp =i;\r\n\t\t\tres[i]= i-temp;\r\n\t\t}\r\n\t\ttemp = Integer.MAX_VALUE/2;\r\n\t\tfor(int i=s.length()-1;i>=0;i--) {\r\n\t\t\tif(s.charAt(i)==c) temp = i;\r\n\t\t\tres[i] = Math.min(res[i],temp-i);\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n```\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837942324","body":"### 思路\r\n\r\n一开始的思路是用双指针，一个表示左边界，一个表示有边界。但是现实实现的时候，需要考虑的情况太多了。\r\n\r\n第一次遍历数组，记录目标字符的位置。\r\n\r\n第二次遍历数组，记录所有元素与左右边界距离的最小值。\r\n\r\n其中，第二次遍历要考虑左右边界的多种情况，没想明白。\r\n\r\n\r\n\r\n第一次写大概花了25分钟，然后去干其他事情。\r\n\r\n第二次修改+debug花了10分钟。\r\n\r\n结果虽然通过了，思路也比较简单，但是代码的逻辑不是很好。\r\n\r\n写完之后大概看了一下题解，又其他更好的方法，晚一点再学习一下。\r\n\r\n\r\n\r\njava\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n\t\tint m=0;\r\n\t\tint[] res = new int[s.length()];\r\n\t\tList<Integer> list = new ArrayList<>();\r\n\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\tif(s.charAt(i)==c) list.add(i);\r\n\t\t}\r\n\t\tint index1=0,index2=0;\r\n\t\tif(list.size()==1) {\r\n\t\t\tindex1=index2=list.get(0);\r\n\t\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\t\tres[i] = Math.abs(i-index1);\r\n\t\t\t}\r\n\t\t\treturn res;\r\n\t\t}\t\r\n\t\tindex1 = list.get(m);\r\n\t\tindex2 = list.get(m+1);\r\n\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\tres[i] = Math.min(Math.abs(i-index1), Math.abs(i-index2));\r\n\t\t\tif(i==index2) {\r\n\t\t\t\tif(index2!=list.get(list.size()-1)) {\r\n\t\t\t\t\tm++;\r\n\t\t\t\t\tindex1 = list.get(m);\r\n\t\t\t\t\tindex2 = list.get(m+1);\r\n\t\t\t\t}\r\n\t\t\t}\t\r\n\t\t}\r\n\t\treturn res;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(n)\r\n\r\n### 法二：正序倒序两遍遍历\r\n\r\n参考题解后，又用思路更加清晰的方法写了一遍。这个不算是自己的产出内容，不仅看了思路，还看了代码的实现方式。\r\n\r\n用时：15min\r\n\r\n第一次从左向右遍历的时候，第一个元素和谁比较，有两种情况\r\n\r\n- 第一个char就是我的目的char，那么令比较索引temp等于第一个字符，后续的字符与它比较，遇到新的目标字符就更新temp 的索引\r\n- 第一个char不是目标字符，那么就要设置比较索引值temp让第一个目标字符出现之前res记录的值足够大，因此，选择Integer.MIN_VALUE/2，这是一个很小的复数，i-temp就是一个很大的整数。\r\n\r\n第二次从又向左遍历，同理。需要考虑最右边的原色和谁比较的问题。设置temp = Integer.MAX_VALUE/2，这样temp-i就是一个足够大的正数。\r\n\r\njava实现\r\n\r\n```java\r\nint[] shortestToChar1(String s,char c) {\r\n\t\tint[] res = new int[s.length()];\r\n\t\tint temp = Integer.MIN_VALUE/2;\r\n\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\tif(s.charAt(i)==c) temp =i;\r\n\t\t\tres[i]= i-temp;\r\n\t\t}\r\n\t\ttemp = Integer.MAX_VALUE/2;\r\n\t\tfor(int i=s.length()-1;i>=0;i--) {\r\n\t\t\tif(s.charAt(i)==c) temp = i;\r\n\t\t\tres[i] = Math.min(res[i],temp-i);\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n```\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840603298","body":"### 思路\r\n\r\n没有什么思路，提示是用栈编写，我的感觉也是栈的内容，但是没想好到底怎么实现。所以一开始花了25分钟用从前到后遍历的方式写了一个简单的能够识别\"23[ab]\"这样的代码。想着这样笔试的时候，多少也能拿一点分数。\r\n\r\n再思考一下，到了晚上想不出来就参考一下别人的题解。\r\n\r\n### C++\r\n\r\n```c++\r\n#include<iostream>\r\n#include<string>\r\n#include<vector>\r\nusing namespace std;\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        \r\n        //简单的2[a]3[abc]编码\r\n        int n = 0;\r\n        vector<int> temp;\r\n        string res=\"\";\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] >= '0' && s[i] <= '9') {\r\n                int num = s[i] - '0';\r\n                temp.push_back(num);\r\n            }\r\n            if (s[i] == '[') {\r\n                int j = i + 1;\r\n                string sub = \"\";\r\n                while (s[j] != ']') {\r\n                    sub += s[j];\r\n                    j++;\r\n                }\r\n                for (int k = 0; k < temp.size(); k++) {\r\n                    n += temp[k] * pow(10, temp.size()-k-1);\r\n                }\r\n                for (int k = 0; k < n; k++) {\r\n                    res += sub;\r\n                }\r\n                temp.clear();\r\n                i = j;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\nint main() {\r\n    Solution mySolu;\r\n    string res=mySolu.decodeString(\"10[A]\");\r\n    cout << res << endl;\r\n}\r\n```\r\n\r\n###  未完成，先打卡，明早修改"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oborc":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836695695","body":"### 解题思路\r\n刚开始以为这个题是大数相加的简单版，却发现其实是两个题目。\r\n直接遍历数组，用竖式相加的思路，从低位开始加起\r\n初始化一个空数组用来存放结果\r\n1.用加数加上被加数的低位，对和取余 为当前位的结果。\r\n2.对和除以10取整，作为加数向第二低位相加，重复1的步骤，直到数组遍历结束或者加数除以10取整之后为0.\r\n### javascript\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let result = [];\r\n    for(let i = num.length-1;i>=0 || k>0;i--){\r\n        if(i>=0){\r\n            k = k + num[i];\r\n        }\r\n        result.unshift(k%10);\r\n        k = Math.floor(k/10);\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n时间复杂度:\r\no(max(N,K/10)) = > O(N),线性复杂\r\n空间复杂度:\r\no(N)= > O(N),线性复杂"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838275025","body":"### 解题思路\r\n\r\n根据官方题解：\r\n1.初始化一个空数组，记录数组中每个字符到目标字符的距离\r\n2.从左向右遍历数组，遍历到目标字符，记录当前下标为index，用遍历下标 i - index  为当前字符距离它右边边的目标字符的距离 ，记录在 result[i] 中，在下次遍历中作比较。\r\n3.从右向左遍历数组，遍历到目标字符，记录当前下标为index，用index - 遍历下标 i  为当前字符距离它左边的目标字符的距离。取result[i] 和 差值中最小的记录为result[i]。result 即为所求\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let str = s.split(\"\");\r\n    let cIndex = -Infinity;\r\n    let result = [];\r\n    for(let i=0;i<str.length;i++){\r\n        if(str[i] == c ){\r\n            result[i]=0;\r\n            cIndex = i;\r\n        }\r\n        result[i] = i-cIndex;\r\n    }\r\n    cIndex = Infinity;\r\n    for(let i=str.length-1;i>=0;i--){\r\n        if(str[i] == c ){\r\n            result[i]=0;\r\n            cIndex = i;\r\n        }\r\n        result[i] = Math.min(result[i],cIndex-i);\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n时间复杂度：\r\no(2n) => o(n)\r\n空间复杂度：\r\no(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838275025","body":"### 解题思路\r\n\r\n根据官方题解：\r\n1.初始化一个空数组，记录数组中每个字符到目标字符的距离\r\n2.从左向右遍历数组，遍历到目标字符，记录当前下标为index，用遍历下标 i - index  为当前字符距离它右边边的目标字符的距离 ，记录在 result[i] 中，在下次遍历中作比较。\r\n3.从右向左遍历数组，遍历到目标字符，记录当前下标为index，用index - 遍历下标 i  为当前字符距离它左边的目标字符的距离。取result[i] 和 差值中最小的记录为result[i]。result 即为所求\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let str = s.split(\"\");\r\n    let cIndex = -Infinity;\r\n    let result = [];\r\n    for(let i=0;i<str.length;i++){\r\n        if(str[i] == c ){\r\n            result[i]=0;\r\n            cIndex = i;\r\n        }\r\n        result[i] = i-cIndex;\r\n    }\r\n    cIndex = Infinity;\r\n    for(let i=str.length-1;i>=0;i--){\r\n        if(str[i] == c ){\r\n            result[i]=0;\r\n            cIndex = i;\r\n        }\r\n        result[i] = Math.min(result[i],cIndex-i);\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n时间复杂度：\r\no(2n) => o(n)\r\n空间复杂度：\r\no(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liandmin":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836696480","body":"### 思路\r\n\r\n1. 直接遍历数组，从后往前加，满10进位，放入结果数组中\r\n2. 如果 k 比数组的number更大的话，继续遍历 k，放入结果数组\r\n3. 反转结果数组返回即可\r\n\r\n### JS\r\n\r\n```\r\nvar addToArrayForm = function (num, k) {\r\n  const res = [];\r\n  const length = num.length;\r\n\r\n  for (let i = length - 1; i >= 0; i--) {\r\n    let sum = num[i] + (k % 10);\r\n    k = Math.floor(k / 10);\r\n    if (sum >= 10) {\r\n      k++;\r\n      sum -= 10;\r\n    }\r\n    res.push(sum);\r\n  }\r\n\r\n  for (; k > 0; k = Math.floor(k / 10)) {\r\n    res.push(k % 10);\r\n  }\r\n  res.reverse();\r\n\r\n  return res;\r\n};\r\n```\r\n \r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(max(N,lg k))，其中 N 为数组长度。\r\n* 空间复杂度：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838758803","body":"## JavaScript\r\n\r\n### 思路\r\n\r\n正向和反向各遍历一次数组，取两次遍历中最小的值即可\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar shortestToChar = function (s, c) {\r\n  const res = new Array(s.length);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) {\r\n      res[i] = 0;\r\n    } else {\r\n      res[i] = i === 0 ? Infinity : res[i - 1] + 1;\r\n    }\r\n  }\r\n\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) {\r\n      res[i] = res[i + 1] + 1;\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838758803","body":"## JavaScript\r\n\r\n### 思路\r\n\r\n正向和反向各遍历一次数组，取两次遍历中最小的值即可\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar shortestToChar = function (s, c) {\r\n  const res = new Array(s.length);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) {\r\n      res[i] = 0;\r\n    } else {\r\n      res[i] = i === 0 ? Infinity : res[i - 1] + 1;\r\n    }\r\n  }\r\n\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) {\r\n      res[i] = res[i + 1] + 1;\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840655638","body":"## JavaScript\r\n\r\n### 思路\r\n\r\n辅助栈，一个或两个都可以\r\n\r\n### 代码\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  const stack = [];\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] != ']') {\r\n      stack.push(s[i]);\r\n    } else if (s[i] == ']') {\r\n      let temp = '';\r\n      while (stack[stack.length - 1] != '[') {\r\n        temp = stack.pop() + temp;\r\n      }\r\n      stack.pop();\r\n\r\n      let num = '';\r\n      while (stack[stack.length - 1] >= '0' && stack[stack.length - 1] <= '9') {\r\n        num = stack.pop() + num;\r\n      }\r\n\r\n      temp = temp.repeat(parseInt(num));\r\n      stack.push(temp);\r\n    }\r\n  }\r\n  return stack.join('');\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n* 空间复杂度： O(N)\r\n* 时间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"edge-wzw":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836712891","body":"### 思路\r\n\r\n逐位相加\r\n\r\n首先新建一个链表，从数组num尾部和K的低位开始反向遍历，依次求和得到对应的sum，根据求和结果判断是否进位（carry=1表示进位，carry=0表示无进位），将sum对10取模后加入到链表头部。\r\n\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public static List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int carry = 0;      //进位数，1表示进位，0表示无进位\r\n        int sum;    //每次求和的值\r\n        int n = num.length - 1;     //遍历数组时的索引\r\n        while (k != 0 || n >= 0){\r\n            sum = carry + (k % 10);\r\n            if (n >= 0){\r\n                sum += num[n];\r\n            }\r\n\r\n            carry = (sum > 9) ? 1:0;\r\n            res.addFirst(sum % 10);\r\n            n--;\r\n            k = k / 10;\r\n        }\r\n        if (carry == 1){res.addFirst(1);}\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(max(n, k))，其中 n 为数组长度, k为数值K的长度。\r\n- 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838514773","body":"解题思路：暴力寻找，首先生成长度为s.length()的结果数组res。遍历字符串的字符，当遇到不是c的字符时，向左和向右寻找最近的c字符的索引，然后与当前字符索引进行距离计算，取最小值存入结果数组res中；遍历时遇到字符c则存入0。\r\n\r\n代码\r\n\r\n```java\r\npublic class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int l, r;\r\n        int[] res = new int[s.length()];\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) != c) {\r\n                l = r = i;\r\n                while (l > 0 && (s.charAt(l) != c)){\r\n                    l--;\r\n                }\r\n                while (r < s.length()-1 && (s.charAt(r) != c)){\r\n                    r++;\r\n                }\r\n                if (s.charAt(l) != c){\r\n                    res[i] = Math.abs(i - r);\r\n                }else if (s.charAt(r) != c){\r\n                    res[i] = Math.abs(i - l);\r\n                }else {\r\n                    res[i] = Math.min(Math.abs(i - l), Math.abs(i - r));\r\n                }\r\n            }else {\r\n                res[i] = 0;\r\n            }\r\n\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n复杂度分析\r\n\r\n- 时间复杂度：O(n<sup>2</sup>)，其中 n 为字符串长度。\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838514773","body":"解题思路：暴力寻找，首先生成长度为s.length()的结果数组res。遍历字符串的字符，当遇到不是c的字符时，向左和向右寻找最近的c字符的索引，然后与当前字符索引进行距离计算，取最小值存入结果数组res中；遍历时遇到字符c则存入0。\r\n\r\n代码\r\n\r\n```java\r\npublic class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int l, r;\r\n        int[] res = new int[s.length()];\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) != c) {\r\n                l = r = i;\r\n                while (l > 0 && (s.charAt(l) != c)){\r\n                    l--;\r\n                }\r\n                while (r < s.length()-1 && (s.charAt(r) != c)){\r\n                    r++;\r\n                }\r\n                if (s.charAt(l) != c){\r\n                    res[i] = Math.abs(i - r);\r\n                }else if (s.charAt(r) != c){\r\n                    res[i] = Math.abs(i - l);\r\n                }else {\r\n                    res[i] = Math.min(Math.abs(i - l), Math.abs(i - r));\r\n                }\r\n            }else {\r\n                res[i] = 0;\r\n            }\r\n\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n复杂度分析\r\n\r\n- 时间复杂度：O(n<sup>2</sup>)，其中 n 为字符串长度。\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840570391","body":"#### **思路**：栈操作\r\n自己想了半个小时，只想到了使用栈操作，思路和官方解法一有点接近，但是代码还是没能写出来，以下为官方解法一\r\n本题中可能出现括号嵌套的情况，比如 2[a2[bc]]，这种情况下我们可以先转化成 2[abcbc]，在转化成 abcbcabcbc。我们可以把字母、数字和括号看成是独立的 TOKEN，并用栈来维护这些 TOKEN。具体的做法是，遍历这个栈：\r\n\r\n如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\r\n如果当前的字符为字母或者左括号，直接进栈\r\n如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字（此时栈顶一定是数字，想想为什么？），就是这个字符串应该出现的次数，我们根据这个次数和字符串构造出新的字符串并进栈\r\n重复如上操作，最终将栈中的元素按照从栈底到栈顶的顺序拼接起来，就得到了答案。注意：这里可以用不定长数组来模拟栈操作，方便从栈底向栈顶遍历。\r\n\r\n**代码**\r\n\r\n```java\r\nclass Solution {\r\n    int ptr;\r\n\r\n    public String decodeString(String s) {\r\n        LinkedList<String> stk = new LinkedList<String>();\r\n        ptr = 0;\r\n\r\n        while (ptr < s.length()) {\r\n            char cur = s.charAt(ptr);\r\n            if (Character.isDigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                String digits = getDigits(s);\r\n                stk.addLast(digits);\r\n            } else if (Character.isLetter(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \r\n            } else {\r\n                ++ptr;\r\n                LinkedList<String> sub = new LinkedList<String>();\r\n                while (!\"[\".equals(stk.peekLast())) {\r\n                    sub.addLast(stk.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                // 左括号出栈\r\n                stk.removeLast();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = Integer.parseInt(stk.removeLast());\r\n                StringBuffer t = new StringBuffer();\r\n                String o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime-- > 0) {\r\n                    t.append(o);\r\n                }\r\n                // 将构造好的字符串入栈\r\n                stk.addLast(t.toString());\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer ret = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            ret.append(s.charAt(ptr++));\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> v) {\r\n        StringBuffer ret = new StringBuffer();\r\n        for (String s : v) {\r\n            ret.append(s);\r\n        }\r\n        return ret.toString();\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：记解码后得出的字符串长度为 SS，除了遍历一次原字符串 ss，我们还需要将解码后的字符串中的每个字符都入栈，并最终拼接进答案中，故渐进时间复杂度为 O(S+|s|)O(S+∣s∣)，即 O(S)O(S)。\r\n- 空间复杂度：记解码后得出的字符串长度为 SS，这里用栈维护 TOKEN，栈的总大小最终与 SS 相同，故渐进空间复杂度为 O(S)O(S)。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SunStrongChina":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836713429","body":"> # 989. 数组形式的整数加法\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n> \r\n> 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n> \r\n>  \r\n> \r\n> 示例 1：\r\n> \r\n> 输入：A = [1,2,0,0], K = 34\r\n> 输出：[1,2,3,4]\r\n> 解释：1200 + 34 = 1234\r\n> 示例 2：\r\n> \r\n> 输入：A = [2,7,4], K = 181\r\n> 输出：[4,5,5]\r\n> 解释：274 + 181 = 455\r\n> 示例 3：\r\n> \r\n> 输入：A = [2,1,5], K = 806\r\n> 输出：[1,0,2,1]\r\n> 解释：215 + 806 = 1021\r\n> 示例 4：\r\n> \r\n> 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n> 输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n> 解释：9999999999 + 1 = 10000000000\r\n>  \r\n> \r\n> 提示：\r\n> \r\n> 1 <= A.length <= 10000\r\n> 0 <= A[i] <= 9\r\n> 0 <= K <= 10000\r\n> 如果 A.length > 1，那么 A[0] != 0\r\n> \r\n\r\n\r\n> # 989. 数组形式的整数加法\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n> \r\n> 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n> \r\n>  \r\n> \r\n> 示例 1：\r\n> \r\n> 输入：A = [1,2,0,0], K = 34\r\n> 输出：[1,2,3,4]\r\n> 解释：1200 + 34 = 1234\r\n> 示例 2：\r\n> \r\n> 输入：A = [2,7,4], K = 181\r\n> 输出：[4,5,5]\r\n> 解释：274 + 181 = 455\r\n> 示例 3：\r\n> \r\n> 输入：A = [2,1,5], K = 806\r\n> 输出：[1,0,2,1]\r\n> 解释：215 + 806 = 1021\r\n> 示例 4：\r\n> \r\n> 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n> 输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n> 解释：9999999999 + 1 = 10000000000\r\n>  \r\n> \r\n> 提示：\r\n> \r\n> 1 <= A.length <= 10000\r\n> 0 <= A[i] <= 9\r\n> 0 <= K <= 10000\r\n> 如果 A.length > 1，那么 A[0] != 0\r\n> ```\r\n**思路**\r\n1.将k转化为字符串\r\n2.比较k和num那个位数多，先进行少位数的求和相加\r\n3.添加更多的那几位\r\n\r\n**python**\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num, k):\r\n        k_str=str(k)\r\n        result=[]\r\n        if len(k_str)>len(num):\r\n            len1=len(num)\r\n            len2=len(k_str)\r\n            num,k_str=k_str,num\r\n        else:\r\n            len1=len(k_str)\r\n            len2=len(num)\r\n            \r\n        value_2=0    \r\n        for i in range(-1,-len1-1,-1):\r\n            value1=int(num[i])+int(k_str[i])+value_2\r\n          \r\n            if value1>=10:\r\n                value_1=value1%10\r\n                value_2=1\r\n            else:\r\n                value_1=value1\r\n                value_2=0\r\n            result.append(value_1)\r\n        \r\n        for j in range(-len1-1,-len2-1,-1):\r\n            value1=int(num[j])+value_2\r\n            if value1>=10:\r\n                value_1=value1%10\r\n                value_2=1\r\n            else:\r\n                value_1=value1\r\n                value_2=0\r\n            result.append(value_1)\r\n        if value_2!=0:\r\n            result.append(value_2)\r\n        result.reverse()    \r\n        return result\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**复杂度分析**\r\n时间复杂度：O(max(N,k))，其中 N 为数组长度，k为数值k的长度。\r\n空间复杂度：O(N)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839360330","body":"### 1.左右遍历的方法\r\n先从左想右遍历，寻找字符串位置，然后从右向左遍历，与之前位置比较，取更小者\r\n\r\n### 2.python代码\r\n\r\n```\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        k=10000\r\n        position1=[]\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                k=i\r\n            position1.append(abs(k-i))\r\n            \r\n        \r\n        k=10000\r\n        for j in range(-1,-len(s)-1,-1):\r\n            if s[j]==c:\r\n                k=j\r\n            pos2=abs(k-j)\r\n            if position1[j]>pos2:\r\n                position1[j]=pos2\r\n        return position1\r\n            \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836721643","body":"### 思路\r\n\r\n倒叙逐位加，先倒着遍历数组`num`，逐位相加，可以把要保存的进位存储到`k`里面，就不容易造成混乱。要注意的是`k`是可以比`num`大的，这里就和66加一不是很一样\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num, k):\r\n        result = []\r\n        for i in range(len(num)-1, -1, -1):  # 先遍历num\r\n            sum = num[i] + k % 10  # 逐位相加\r\n            k = k // 10  # k降一个位数\r\n            if sum >= 10:  # 这里是一个技巧，进位的时候，不直接处理num，而是k加一\r\n                k += 1\r\n            result.append(sum % 10)  # 不用insert降低复杂度\r\n        while k > 0:  # 若k的值不为0，直接加上去即可，同时也考虑k比num大的情况\r\n            result.append(k % 10)\r\n            k = k // 10\r\n        result.reverse()\r\n        return result\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(max(n,k)) 整数与数组长度之间取最大，为什么官方写的是log(k)？\r\n- 空间复杂度：O(1) 除了返回值result以外，使用的空间为常数。"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838329768","body":"### 思路\r\n\r\n左右各遍历一次。每次遍历，记录`c`的位置，左侧开始遍历就计算每个数到最近的左边的`c`的距离，要注意如果左边没有`c`可以记录无穷大。右侧开始遍历，记录每个数到右边的`c`的距离，是`c`的位置减掉该数的位置。如果右边没有`c`，那应该也是无穷大，所以右侧开始的话`c`初始应该是无穷大。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        result = []\r\n        left_position = float('-inf')\r\n        right_position = float('inf')\r\n        for idx, value in enumerate(s):\r\n            if value == c:\r\n                left_position = idx\r\n            result.append(idx-left_position)\r\n\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                right_position = i\r\n            result[i] = min(right_position-i, result[i])\r\n        return result\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n) 遍历2遍\r\n- 空间复杂度：O(1) 除了返回值result以外，使用的空间为常数。\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838329768","body":"### 思路\r\n\r\n左右各遍历一次。每次遍历，记录`c`的位置，左侧开始遍历就计算每个数到最近的左边的`c`的距离，要注意如果左边没有`c`可以记录无穷大。右侧开始遍历，记录每个数到右边的`c`的距离，是`c`的位置减掉该数的位置。如果右边没有`c`，那应该也是无穷大，所以右侧开始的话`c`初始应该是无穷大。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        result = []\r\n        left_position = float('-inf')\r\n        right_position = float('inf')\r\n        for idx, value in enumerate(s):\r\n            if value == c:\r\n                left_position = idx\r\n            result.append(idx-left_position)\r\n\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                right_position = i\r\n            result[i] = min(right_position-i, result[i])\r\n        return result\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n) 遍历2遍\r\n- 空间复杂度：O(1) 除了返回值result以外，使用的空间为常数。\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840618316","body":"### 思路\r\n\r\n用栈辅助来判断左右括号拆出来的情况。为碰到`]`的时候可以全部进栈，需要注意，数字进栈的时候，要判断是否是连续的数字，如果是连续的，需要和前面的数字拼起来；碰到`[`的时候，用一个辅助的`temp_str`记录拼起来的字符串，这个`temp_str`在碰到数字的时候（其实就是碰到`[`）要乘数字的个数作为拼完的临时字符串。再判断此时栈是否还有`[`有的话说明临时字符串还要继续拼，把现有的临时串先入栈；如果`[`没有在栈中，可以拼到最终结果串中。全部结束，再判断一次栈是否为空，不空的话要拼进结果。这版写太长了，比较挫\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        # 没碰到[的话全部进栈\r\n        stack = []\r\n        temp_str = \"\"\r\n        result = \"\"\r\n        for val in s:\r\n            if val != ']':\r\n                if stack:\r\n                    if val.isdigit() and stack[-1].isdigit():  # 这里处理有可能多个数字的情况，比如100\r\n                        stack[-1] = stack[-1] + val\r\n                    else:\r\n                        stack.append(val)\r\n                else:\r\n                    stack.append(val)\r\n            else:\r\n                while stack:  # 只要碰到]就出栈\r\n                    item = stack.pop()\r\n                    if item != '[' and not item.isdigit():\r\n                        temp_str = item + temp_str\r\n                    elif item.isdigit():\r\n                        temp_str = int(item) * temp_str\r\n                        break\r\n                if '[' not in stack:\r\n                    while stack:\r\n                        temp_str = stack.pop() + temp_str\r\n                    result = result + temp_str\r\n                else:\r\n                    stack.append(temp_str)\r\n                temp_str = \"\"\r\n        while stack:\r\n            temp_str = stack.pop() + temp_str\r\n        result = result + temp_str\r\n        return result\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(N)，遍历一遍 \r\n- 空间复杂度：O(N) 这里用到了一个最大长度为 `N` 的数组作为辅助空间stack，渐进空间复杂度为 O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"newVincentFong":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836729444","body":"# Add to Array-Form of Integer\r\n\r\n## Discuss\r\n\r\n* `num` can be longer than `k`, or can be shorter than k\r\n \r\nso, the times of iterations should be the max between their lengths\r\n\r\n* save the result in the given array\r\n\r\nspace: O(n) -> O(1), less use of `splice`, better timing\r\n\r\n## Code\r\n\r\n```typescript\r\n/**\r\n * @remarks\r\n * * `num` can be longer than `k`, or can be shorter than k\r\n * \r\n * so, the times of iterations should be the max between their lengths\r\n * \r\n * * save the result in the given array\r\n * \r\n * space: O(n) -> O(1), less use of `splice`, better timing\r\n */\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    let shouldCarry = false\r\n    const length = Math.max(num.length, k.toString().length)\r\n    const difference = length - num.length\r\n    for (let i = length - 1; i >= 0; i--) {\r\n        const original = num[i - difference] || 0\r\n        const toAdd = k % 10\r\n        const added = original + toAdd + (shouldCarry ? 1 : 0) as number\r\n        const toSave = added % 10\r\n        if (i - difference >= 0) {\r\n            num[i- difference] = toSave\r\n        } else {\r\n            num.splice(0, 0, toSave)\r\n        }\r\n        shouldCarry = Math.floor(added / 10) === 1\r\n        k = Math.floor(k / 10)\r\n    }\r\n    if (shouldCarry) {\r\n        num.splice(0, 0, 1)\r\n    }\r\n    return num\r\n};\r\n// time O(n)\r\n// space O(1)\r\n``"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838642501","body":"# Shortest Distance to a Character\r\n\r\n## Discuss\r\n\r\n* the min distance of str[i] is only related to the **two** closest c char that are on both sides of str[i]\r\n\r\nBefore:\r\n\r\n`Min(abs(c1 - str[i]), abs(c2 - str[i]), ... abs(cN - str[i]))`\r\n\r\nAfter:\r\n\r\n`Min(abs(cLEFT - str[i]), abs(cRIGHT - str[i]))`\r\n\r\n* iterate forward and then backward\r\n\r\nwatch out for those `empty` Array items\r\n\r\n## Code\r\n\r\n```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    const result = []\r\n    // forwards\r\n    let prevC = -1\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            prevC = i\r\n            result[i] = 0\r\n        } else if (prevC !== -1) {\r\n            result[i] = i - prevC\r\n        }\r\n    }\r\n    prevC = -1\r\n    // backwards\r\n    for (let i = s.length - 1; i >= 0; i--) {\r\n        if (prevC !== -1) {\r\n            // CAUTION\r\n            result[i] = typeof result[i] === 'number' ? Math.min(prevC - i, result[i]) : prevC - i\r\n        }\r\n        if (s[i] === c) {\r\n            prevC = i\r\n        }\r\n    }\r\n    return result\r\n};\r\n// time O(n)\r\n// space O(n)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838642501","body":"# Shortest Distance to a Character\r\n\r\n## Discuss\r\n\r\n* the min distance of str[i] is only related to the **two** closest c char that are on both sides of str[i]\r\n\r\nBefore:\r\n\r\n`Min(abs(c1 - str[i]), abs(c2 - str[i]), ... abs(cN - str[i]))`\r\n\r\nAfter:\r\n\r\n`Min(abs(cLEFT - str[i]), abs(cRIGHT - str[i]))`\r\n\r\n* iterate forward and then backward\r\n\r\nwatch out for those `empty` Array items\r\n\r\n## Code\r\n\r\n```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    const result = []\r\n    // forwards\r\n    let prevC = -1\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            prevC = i\r\n            result[i] = 0\r\n        } else if (prevC !== -1) {\r\n            result[i] = i - prevC\r\n        }\r\n    }\r\n    prevC = -1\r\n    // backwards\r\n    for (let i = s.length - 1; i >= 0; i--) {\r\n        if (prevC !== -1) {\r\n            // CAUTION\r\n            result[i] = typeof result[i] === 'number' ? Math.min(prevC - i, result[i]) : prevC - i\r\n        }\r\n        if (s[i] === c) {\r\n            prevC = i\r\n        }\r\n    }\r\n    return result\r\n};\r\n// time O(n)\r\n// space O(n)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DAXIAdaxia":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836737171","body":"### **思路：**\r\n从个位数开始，每个数从后往前依次相加\r\n\r\n### **代码：**\r\npublic class Solution {\r\n\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        ArrayList<Integer> list = new ArrayList<Integer>();\r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            int temp = num[i] + k % 10;\r\n            k /= 10;\r\n            if (temp >= 10){\r\n                k++;\r\n                temp -= 10;\r\n            }\r\n            list.add(temp);\r\n        }\r\n\r\n        while (k > 0){\r\n            list.add(k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        Collections.reverse(list);\r\n        return list;\r\n    }\r\n}\r\n\r\n### **复杂度分析：**\r\n时间复杂度：最坏的情况下，需要遍历n次，所以时间复杂度为O(n)\r\n空间复杂度：最坏的情况下，需要一个长度为(n+1)的列表来存储结果，所以空间复杂度为O(n)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838528608","body":"### **思路：**\r\n先从左往右计算出当前字符距离上一个字符c的距离（第一个需要用最小整数的一半来代替，保证 i-pre 为正），紧接着就是从右往左计算出当前字符距离上一个字符c的距离（第一个需要用最大整数的一半来代替，保证 post-i 为正），同时比较两个距离的大小，只保留距离短的\r\n### **代码：**\r\npublic class Solution {\r\n\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n\r\n        int pre = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < len; i++) {\r\n            if (c == s.charAt(i)) pre = i;\r\n            res[i] = i - pre;\r\n        }\r\n\r\n        int post = Integer.MAX_VALUE / 2;\r\n        for (int i = len - 1; i >= 0; i--) {\r\n            if (c == s.charAt(i)) post = i;\r\n            res[i] = Integer.min(res[i],post - i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n### **复杂度分析：**\r\n时间复杂度：需要单独进行两个for循环，所以时间复杂度为O(n)，n为字符串长度\r\n空间复杂度：最短距离需要用数组来存，所以空间复杂度为O(n)，n为字符串长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838528608","body":"### **思路：**\r\n先从左往右计算出当前字符距离上一个字符c的距离（第一个需要用最小整数的一半来代替，保证 i-pre 为正），紧接着就是从右往左计算出当前字符距离上一个字符c的距离（第一个需要用最大整数的一半来代替，保证 post-i 为正），同时比较两个距离的大小，只保留距离短的\r\n### **代码：**\r\npublic class Solution {\r\n\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n\r\n        int pre = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < len; i++) {\r\n            if (c == s.charAt(i)) pre = i;\r\n            res[i] = i - pre;\r\n        }\r\n\r\n        int post = Integer.MAX_VALUE / 2;\r\n        for (int i = len - 1; i >= 0; i--) {\r\n            if (c == s.charAt(i)) post = i;\r\n            res[i] = Integer.min(res[i],post - i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n### **复杂度分析：**\r\n时间复杂度：需要单独进行两个for循环，所以时间复杂度为O(n)，n为字符串长度\r\n空间复杂度：最短距离需要用数组来存，所以空间复杂度为O(n)，n为字符串长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840602618","body":"### **思路：**\r\n第一步：把'['左边的数字解析出来，并压入栈\r\n第二步：接着把字母和‘[’以字符串的形式压入栈\r\n第三步：但遇到‘]’时，把栈中的元素出栈，直到遇到“[”，并把出栈后的字符串进行反转、重复后重新压入栈\r\n重复以上的步骤，最后出栈的字符串即为结果。\r\n\r\n### **代码：**\r\nclass Solution {\r\n    int ptr;\r\n\r\n    public String decodeString(String s) {\r\n        LinkedList<String> stk = new LinkedList<String>();\r\n        ptr = 0;\r\n\r\n        while (ptr < s.length()) {\r\n            char cur = s.charAt(ptr);\r\n            if (Character.isDigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                String digits = getDigits(s);\r\n                stk.addLast(digits);\r\n            } else if (Character.isLetter(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \r\n            } else {\r\n                ++ptr;\r\n                LinkedList<String> sub = new LinkedList<String>();\r\n                while (!\"[\".equals(stk.peekLast())) {\r\n                    sub.addLast(stk.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                // 左括号出栈\r\n                stk.removeLast();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = Integer.parseInt(stk.removeLast());\r\n                StringBuffer t = new StringBuffer();\r\n                String o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime-- > 0) {\r\n                    t.append(o);\r\n                }\r\n                // 将构造好的字符串入栈\r\n                stk.addLast(t.toString());\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer ret = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            ret.append(s.charAt(ptr++));\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> v) {\r\n        StringBuffer ret = new StringBuffer();\r\n        for (String s : v) {\r\n            ret.append(s);\r\n        }\r\n        return ret.toString();\r\n    }\r\n}\r\n### **复杂度分析**\r\n时间复杂度：O（n）其中n为字符串的长度\r\n空间复杂度：O（n）其中n为字符串的长度\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"supermeohh":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836744653","body":"\r\n## 思路\r\n进位用k通过加一保存\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //List<Integer>初始化，需要返回值\r\n        int n = num.length;\r\n        List<Integer>res = new ArrayList<>();\r\n        //List<Integer>指的是存int类型数据的列表\r\n        for(int i = n-1;i>=0;i--){\r\n            //%（取余）和 /（取整）\r\n            //取num的最低位和k值的个位\r\n            int sum = num[i]+k%10;\r\n            //取k值的个位以上\r\n            k/=10;\r\n            if (sum>=10){\r\n                //和有进位加一\r\n                k++;\r\n                //sum-10\r\n                sum-=10;\r\n            }\r\n            //赋值到链表\r\n            res.add(sum);\r\n        }\r\n        //多余的k值位数直接加上去\r\n        for(;k>0;k/=10){\r\n            res.add(k%10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838595332","body":"## 思路\r\n1、正向取值为i-prev\r\n2、逆向取值为prev-i\r\n3、比较两个值赋值给ans[]\r\n4、打印\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        //s.length()括号不能丢\r\n        int n = s.length();\r\n        int [] ans = new int[n];\r\n        //prev初始值为int整型的最小值的一半\r\n        //保证有prev参与的加减运算不会溢出。同时起到最小值的效果\r\n        //不知道为什么不能是0呢？\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        //charAt() 方法可返回指定位置的字符\r\n        //语法stringObject.charAt(index)\r\n        //s.charaT(i)\r\n        for(int i = 0;i < n;i++){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            //结果在if外，跟着每一次的for循环而不是if\r\n                ans[i] = i - prev;\r\n        }\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for(int i = n-1;i >= 0;i--){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n                //min和max需要Math调用\r\n                ans[i] =Math.min(ans[i],prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838595332","body":"## 思路\r\n1、正向取值为i-prev\r\n2、逆向取值为prev-i\r\n3、比较两个值赋值给ans[]\r\n4、打印\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        //s.length()括号不能丢\r\n        int n = s.length();\r\n        int [] ans = new int[n];\r\n        //prev初始值为int整型的最小值的一半\r\n        //保证有prev参与的加减运算不会溢出。同时起到最小值的效果\r\n        //不知道为什么不能是0呢？\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        //charAt() 方法可返回指定位置的字符\r\n        //语法stringObject.charAt(index)\r\n        //s.charaT(i)\r\n        for(int i = 0;i < n;i++){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            //结果在if外，跟着每一次的for循环而不是if\r\n                ans[i] = i - prev;\r\n        }\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for(int i = n-1;i >= 0;i--){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n                //min和max需要Math调用\r\n                ans[i] =Math.min(ans[i],prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840655478","body":"\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  不太会啊今天，难顶，主判断\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```Java\r\n\r\nclass Solution {\r\n    int ptr;\r\n\r\n    public String decodeString(String s) {\r\n        LinkedList<String> stk = new LinkedList<String>();\r\n        ptr = 0;\r\n\r\n        while (ptr < s.length()) {\r\n            char cur = s.charAt(ptr);\r\n            if (Character.isDigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                String digits = getDigits(s);\r\n                stk.addLast(digits);\r\n            } else if (Character.isLetter(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \r\n            } else {\r\n                ++ptr;\r\n                LinkedList<String> sub = new LinkedList<String>();\r\n                while (!\"[\".equals(stk.peekLast())) {\r\n                    sub.addLast(stk.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                // 左括号出栈\r\n                stk.removeLast();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = Integer.parseInt(stk.removeLast());\r\n                StringBuffer t = new StringBuffer();\r\n                String o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime-- > 0) {\r\n                    t.append(o);\r\n                }\r\n                // 将构造好的字符串入栈\r\n                stk.addLast(t.toString());\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer ret = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            ret.append(s.charAt(ptr++));\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> v) {\r\n        StringBuffer ret = new StringBuffer();\r\n        for (String s : v) {\r\n            ret.append(s);\r\n        }\r\n        return ret.toString();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bowlofnoodles":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836746047","body":"### 思路\r\n\r\n模拟加法按位逐位相加\r\n\r\n### 代码 js\r\n\r\n\r\n``` javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    const result = [];\r\n    const length = num.length;\r\n    for (let i = length - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        result.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        result.push(k % 10);\r\n    }\r\n    result.reverse();\r\n    return result;\r\n};\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：忽略返回值创建的数组，O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837629522","body":"### 思路\r\n\r\n暴力解法，先存取c下标数组，再遍历数组算s中每个字符的最小距离\r\n### 代码\r\n\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const index = [];\r\n    const result = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            index.push(i);\r\n        }\r\n    }\r\n    for (let j = 0; j < s.length; j++) {\r\n        if (s[j] === c) {\r\n            result.push(0);\r\n        } else {\r\n            result.push(Math.min(...index.map(item => Math.abs(j - item))));\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N*N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837629522","body":"### 思路\r\n\r\n暴力解法，先存取c下标数组，再遍历数组算s中每个字符的最小距离\r\n### 代码\r\n\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const index = [];\r\n    const result = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            index.push(i);\r\n        }\r\n    }\r\n    for (let j = 0; j < s.length; j++) {\r\n        if (s[j] === c) {\r\n            result.push(0);\r\n        } else {\r\n            result.push(Math.min(...index.map(item => Math.abs(j - item))));\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N*N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836746634","body":"#### 思路：\r\n数组逆序遍历，然后从个位数开始相加，将结果push新数组，最后将新数组翻转\r\n要注意进位尤其是最后一位的进位还要注意k位数比num多的情况\r\n#### 代码 JS\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n  let res = []\r\n  for(let i = num.length-1; i>= 0; --i) {\r\n      let sum = num[i] + k%10\r\n      k = Math.floor(k / 10)\r\n\r\n      if(sum >=10) {\r\n          sum = sum % 10   \r\n          k++      \r\n        \r\n      }     \r\n\r\n      res.push(sum) \r\n  }\r\n   \r\n  for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n  for(let i =0; i<Math.floor(res.length/2); i++){\r\n      [res[i], res[res.length-1-i]] =  [res[res.length-1-i], res[i]]\r\n  }\r\n  return res\r\n};\r\n```\r\n#### 复杂度分析：\r\n+ 时间复杂度：O(n)\r\n+ 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838335642","body":"#### 思路\r\n左右各遍历一次，然后看最小距离\r\n\r\n#### 代码 javascript\r\n```javascript\r\nvar shortestToChar = function(s, c) {\r\n   const l = s.length\r\n\r\n   let res = []\r\n   for(let i = 0; i< l; i++) {\r\n      if(s.charAt(i) === c){\r\n          res[i] = 0\r\n      } else {\r\n          res[i] = res[i-1] === void 0 ? Infinity : res[i-1] + 1\r\n      }\r\n   }\r\n   for(let i = l-1; i>=0; i--) {\r\n      if (res[i] === Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1;\r\n   }\r\n   return res\r\n};\r\n```\r\n#### 复杂度\r\n+ 时间复杂度：O(n)\r\n+ 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838335642","body":"#### 思路\r\n左右各遍历一次，然后看最小距离\r\n\r\n#### 代码 javascript\r\n```javascript\r\nvar shortestToChar = function(s, c) {\r\n   const l = s.length\r\n\r\n   let res = []\r\n   for(let i = 0; i< l; i++) {\r\n      if(s.charAt(i) === c){\r\n          res[i] = 0\r\n      } else {\r\n          res[i] = res[i-1] === void 0 ? Infinity : res[i-1] + 1\r\n      }\r\n   }\r\n   for(let i = l-1; i>=0; i--) {\r\n      if (res[i] === Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1;\r\n   }\r\n   return res\r\n};\r\n```\r\n#### 复杂度\r\n+ 时间复杂度：O(n)\r\n+ 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840637417","body":"#### 思路\r\n一个栈解决不了就用两个栈，一个用来存放重复的次数，一个用来存放字符串。比较关键的是入栈和出栈的时机。遇到`[`入栈遇到`]`出栈拼接子字符串，然后返回完整字符串。字符串的栈需要用空字符串占位\r\n#### 代码 JavaScript\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  let strStack = []\r\n  let numStack = []\r\n  let num = 0\r\n  let result = ''\r\n  for(let i =0; i<s.length; i++) {\r\n      let r = s.charAt(i) \r\n      if(isNaN(r) === false) {\r\n        num = num * 10 + Number(r)\r\n      } else if (r === '[') {\r\n        strStack.push(result)\r\n        result = ''\r\n        numStack.push(num)\r\n        num = 0\r\n      } else if (r === ']') {\r\n        result = strStack.pop() + result.repeat(numStack.pop())\r\n      } else {\r\n        result += r\r\n      }\r\n  }\r\n  return result\r\n};\r\n```\r\n#### 复杂度分析\r\n时间复杂度O(n) \r\n空间复杂度O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzdFeiFei":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836747177","body":"**思路**\r\n官方解法\r\n\r\n**代码：**\r\n\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const res = []\r\n    const n = num.length\r\n    for(let i = n-1;i>=0;i--){\r\n        let sum = num[i] + k % 10\r\n        k = Math.floor(k/10)\r\n        if(sum>=10){\r\n            k++\r\n            sum -= 10\r\n        }\r\n        res.push(sum)\r\n    }\r\n    for(;k>0;k = Math.floor(k/10)){\r\n        res.push(k % 10)\r\n    }\r\n    res.reverse()\r\n    return res\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(max(n,log k))，其中 n 为数组的长度。\r\n- 空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838672483","body":"```\r\nclass Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838672483","body":"```\r\nclass Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840631219","body":"```\r\nclass Solution {\r\n    int ptr;\r\n\r\n    public String decodeString(String s) {\r\n        LinkedList<String> stk = new LinkedList<String>();\r\n        ptr = 0;\r\n\r\n        while (ptr < s.length()) {\r\n            char cur = s.charAt(ptr);\r\n            if (Character.isDigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                String digits = getDigits(s);\r\n                stk.addLast(digits);\r\n            } else if (Character.isLetter(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \r\n            } else {\r\n                ++ptr;\r\n                LinkedList<String> sub = new LinkedList<String>();\r\n                while (!\"[\".equals(stk.peekLast())) {\r\n                    sub.addLast(stk.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                // 左括号出栈\r\n                stk.removeLast();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = Integer.parseInt(stk.removeLast());\r\n                StringBuffer t = new StringBuffer();\r\n                String o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime-- > 0) {\r\n                    t.append(o);\r\n                }\r\n                // 将构造好的字符串入栈\r\n                stk.addLast(t.toString());\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer ret = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            ret.append(s.charAt(ptr++));\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> v) {\r\n        StringBuffer ret = new StringBuffer();\r\n        for (String s : v) {\r\n            ret.append(s);\r\n        }\r\n        return ret.toString();\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LASIWan":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836748306","body":"### 思路\r\n采用每一位分别相加，并判断是否进位的方法：\r\n1、声明一个空数组\r\n2、从末位开始循环数组的每一位，并与加数k按位相加\r\n3、判断是否需要进位，当和大于10时，将结果存入下一位\r\n4、通过数组方法将存入顺序颠倒即可\r\n\r\n\r\n\r\n### JavaScript\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838531788","body":"### 思路\r\n\r\n判断目标字符与数组每一位的最小距离，那么则有几种情况\r\n目标在左侧，直接用当前位置减去目标index；\r\n目标在右侧，直接用目标index减去当前位置；\r\n两侧都有目标，则比较两侧之前的距离取最小值。\r\n\r\n\r\n### 代码\r\n\r\n```js\r\nvar shortestToChar = function(s,c){\r\n    let res = Array(s.length).fill(0);\r\n    \r\n\r\n    for(let i=0; i<s.length; i++){\r\n        if (s[i] === c) continue;\r\n\r\n        let l = i;\r\n        let r = i;\r\n        let shortest = Infinity;\r\n\r\n        while(l>=0){\r\n            if(s[l]===c){\r\n                shortest = Math.min(shortest, i-l); \r\n                break;\r\n            }\r\n            l--;\r\n        }\r\n        while(r<s.length){\r\n            if(s[r]===c){\r\n                shortest = Math.min(shortest,r-i);\r\n                break;\r\n            }\r\n            r++;\r\n        }\r\n        res[i]=shortest;\r\n    }\r\n    return res;\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N方)，两层循环。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838531788","body":"### 思路\r\n\r\n判断目标字符与数组每一位的最小距离，那么则有几种情况\r\n目标在左侧，直接用当前位置减去目标index；\r\n目标在右侧，直接用目标index减去当前位置；\r\n两侧都有目标，则比较两侧之前的距离取最小值。\r\n\r\n\r\n### 代码\r\n\r\n```js\r\nvar shortestToChar = function(s,c){\r\n    let res = Array(s.length).fill(0);\r\n    \r\n\r\n    for(let i=0; i<s.length; i++){\r\n        if (s[i] === c) continue;\r\n\r\n        let l = i;\r\n        let r = i;\r\n        let shortest = Infinity;\r\n\r\n        while(l>=0){\r\n            if(s[l]===c){\r\n                shortest = Math.min(shortest, i-l); \r\n                break;\r\n            }\r\n            l--;\r\n        }\r\n        while(r<s.length){\r\n            if(s[r]===c){\r\n                shortest = Math.min(shortest,r-i);\r\n                break;\r\n            }\r\n            r++;\r\n        }\r\n        res[i]=shortest;\r\n    }\r\n    return res;\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N方)，两层循环。\r\n- 空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fakerbaby":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836751618","body":"## [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\r\n\r\n难度:**简单**\r\n\r\n对于非负整数 `X` 而言，*`X`* 的*数组形式*是每位数字按从左到右的顺序形成的数组。例如，如果 `X = 1231`，那么其数组形式为 `[1,2,3,1]`。\r\n\r\n给定非负整数 `X` 的数组形式 `A`，返回整数 `X+K` 的数组形式。\r\n\r\n---\r\n\r\n**思路1**\r\n\r\n首先将原属组转化成字符串，然后转换成整型相加然后在切分成数组。最后返回数组为所求。\r\n\r\n**代码**\r\n\r\n~~~python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        tmp = ''\r\n        for index in num:\r\n            tmp += str(index)\r\n        res_int = int(tmp) + k\r\n        res = [int(x) for x in str(res_int)]\r\n        return res\r\n\r\n\r\n~~~\r\n\r\n\r\n\r\n**复杂度**\r\n\r\n时间：O(n)\r\n\r\n空间：O(1)\r\n\r\n---\r\n\r\n**思路2**\r\n\r\n```\r\n<加法模板>    \r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n\r\n**代码**\r\n\r\n~~~python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        i = len(A) - 1\r\n        while K:\r\n            A[i] += K\r\n            K, A[i] = A[i] // 10, A[i] % 10\r\n            i -= 1\r\n            if i < 0 and K:\r\n                A.insert(0,0)\r\n                i = 0\r\n        return A\r\n\r\n\r\n~~~\r\n\r\n\r\n\r\n**复杂度**\r\n\r\n时间：O(n)\r\n\r\n空间：O(n)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838706823","body":"# [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n#### 难度简单\r\n\r\n给你一个字符串 `s` 和一个字符 `c` ，且 `c` 是 `s` 中出现过的字符。\r\n\r\n返回一个整数数组 `answer` ，其中 `answer.length == s.length` 且 `answer[i]` 是 `s` 中从下标 `i` 到离它 **最近** 的字符 `c` 的 **距离** 。\r\n\r\n两个下标 `i` 和 `j` 之间的 **距离** 为 `abs(i - j)` ，其中 `abs` 是绝对值函数。\r\n\r\n---\r\n\r\n### 思路baseline:\r\n\r\n朴素算法，首先把c字符位置用数组记录，然后依次比较所有来得到最近的距离。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        pos,i = [],0 #pos记录位置\r\n        for e in s:\r\n            if e == c:\r\n                pos.append(i)\r\n            i += 1\r\n        Len = len(s)\r\n        ans = [0]*(Len)\r\n        min = Len\r\n        for b in range(Len):\r\n            min = Len\r\n            for c in pos:\r\n                min = min if min <= abs(b-c) else abs(b-c)\r\n                print(b)\r\n            ans[b] = min\r\n        return ans\r\n        \r\n```\r\n\r\n### 复杂度\r\n\r\n时间：$O(n^2)\r\n\r\n空间：$O(n)\r\n\r\n---\r\n\r\n### 思路strongline:\r\n\r\n从左向右和从右向左分别遍历一边，然后取最小的距离\r\n\r\n### 代码：\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        pre = -10000\r\n        ans = []\r\n        for i in range(len(S)):\r\n            if S[i] == C: pre = i\r\n            ans.append(i - pre)\r\n        pre = 20000\r\n        for i in range(len(S) - 1, -1, -1):\r\n            if S[i] == C: pre = i\r\n            ans[i] = min(ans[i], pre - i)\r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：$O(n)\r\n\r\n空间：$O(n)\r\n\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838706823","body":"# [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n#### 难度简单\r\n\r\n给你一个字符串 `s` 和一个字符 `c` ，且 `c` 是 `s` 中出现过的字符。\r\n\r\n返回一个整数数组 `answer` ，其中 `answer.length == s.length` 且 `answer[i]` 是 `s` 中从下标 `i` 到离它 **最近** 的字符 `c` 的 **距离** 。\r\n\r\n两个下标 `i` 和 `j` 之间的 **距离** 为 `abs(i - j)` ，其中 `abs` 是绝对值函数。\r\n\r\n---\r\n\r\n### 思路baseline:\r\n\r\n朴素算法，首先把c字符位置用数组记录，然后依次比较所有来得到最近的距离。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        pos,i = [],0 #pos记录位置\r\n        for e in s:\r\n            if e == c:\r\n                pos.append(i)\r\n            i += 1\r\n        Len = len(s)\r\n        ans = [0]*(Len)\r\n        min = Len\r\n        for b in range(Len):\r\n            min = Len\r\n            for c in pos:\r\n                min = min if min <= abs(b-c) else abs(b-c)\r\n                print(b)\r\n            ans[b] = min\r\n        return ans\r\n        \r\n```\r\n\r\n### 复杂度\r\n\r\n时间：$O(n^2)\r\n\r\n空间：$O(n)\r\n\r\n---\r\n\r\n### 思路strongline:\r\n\r\n从左向右和从右向左分别遍历一边，然后取最小的距离\r\n\r\n### 代码：\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        pre = -10000\r\n        ans = []\r\n        for i in range(len(S)):\r\n            if S[i] == C: pre = i\r\n            ans.append(i - pre)\r\n        pre = 20000\r\n        for i in range(len(S) - 1, -1, -1):\r\n            if S[i] == C: pre = i\r\n            ans[i] = min(ans[i], pre - i)\r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：$O(n)\r\n\r\n空间：$O(n)\r\n\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840644881","body":"\r\n\r\n# [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\r\n\r\n难度中等\r\n\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 *encoded_string* 正好重复 *k* 次。注意 *k* 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 *k*，例如不会出现像 `3a` 或 `2[4]` 的输入。 \r\n\r\n**示例 1：**\r\n\r\n```\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n```\r\n\r\n**示例 2：**\r\n\r\n```\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n```\r\n\r\n**示例 3：**\r\n\r\n```\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n```\r\n\r\n**示例 4：**\r\n\r\n```\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n```\r\n\r\n---\r\n\r\n### 思路(迭代)\r\n\r\n主要还是利用栈的思想，然后使用迭代的方法。吧“】”前的内容入栈，当遇到“】”需要出栈，结合【】的内容和数字进行不断迭代直到字符串s结尾。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for cha in s:\r\n            if cha == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr\r\n                #pop '['\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount  \r\n                stack.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stack.append(cha)\r\n        return \"\".join(stack)\r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\n时间:$O(n)$\r\n\r\n空间:$O(n)$\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuris304":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836751629","body":"## 思路\r\n从末尾开始依次往前模拟加法运算\r\n\r\n## 关键点\r\n\r\n-  结束条件 num到首位& k加完 & 进位为0\r\n-  每次循环中要判断数组索引是否越界\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res=new LinkedList<Integer>();\r\n        int n=num.length-1;int flag=0;\r\n        while(n>-1||k!=0||flag!=0){\r\n            int tep;\r\n            if(n<0) tep=k%10+flag;\r\n            else tep=k%10+num[n]+flag;\r\n            k/=10;\r\n            flag=tep/10;\r\n            tep=tep%10;\r\n            res.add(0,tep);\r\n            n--;\r\n        }\r\n        return res;      \r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(max(log(k),n))$\r\n- 空间复杂度：$O(1)$"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838315989","body":"## 思路\r\n正反各一次遍历，第一次正向记录每一个字符与上一个目标字符的距离，第二次反向保留距离最小值\r\n\r\n## 关键点\r\n\r\n-  初始化用MAX_VALUE/2的形式，避免越界\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] S=s.toCharArray();\r\n        int[] res=new int[S.length];\r\n        int dis=Integer.MAX_VALUE/2;\r\n        for(int i=0;i<S.length;i++){\r\n            if(S[i]==c) dis=0;\r\n            res[i]=dis++;\r\n        }\r\n        for(int i=S.length-1;i>-1;i--){\r\n            if(S[i]==c) dis=0;\r\n            res[i]=Math.min(dis++,res[i]);\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n```\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838315989","body":"## 思路\r\n正反各一次遍历，第一次正向记录每一个字符与上一个目标字符的距离，第二次反向保留距离最小值\r\n\r\n## 关键点\r\n\r\n-  初始化用MAX_VALUE/2的形式，避免越界\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] S=s.toCharArray();\r\n        int[] res=new int[S.length];\r\n        int dis=Integer.MAX_VALUE/2;\r\n        for(int i=0;i<S.length;i++){\r\n            if(S[i]==c) dis=0;\r\n            res[i]=dis++;\r\n        }\r\n        for(int i=S.length-1;i>-1;i--){\r\n            if(S[i]==c) dis=0;\r\n            res[i]=Math.min(dis++,res[i]);\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n```\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840242460","body":"\r\n```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res=new StringBuilder();\r\n        int times=0;\r\n        Stack<Integer> timesStack=new Stack<Integer>();\r\n        Stack<String> strStack=new Stack<String>();\r\n        for(char c:s.toCharArray()){\r\n            if(c>='0'&&c<='9'){\r\n                times=times*10+c-'0';\r\n            }\r\n            else if(c=='['){\r\n                timesStack.push(times);\r\n                times=0;\r\n                strStack.push(res.toString());\r\n                res=new StringBuilder();\r\n            }\r\n            else if(c==']'){\r\n                int multi=timesStack.pop();\r\n                StringBuilder tem=new StringBuilder();\r\n                for(int i=0;i<multi;i++){\r\n                    tem.append(res);\r\n                }\r\n                res=new StringBuilder(strStack.pop()+tem);\r\n            }\r\n            else{\r\n                res.append(c);\r\n            }\r\n        }\r\n\r\n        return res.toString();\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Hazelnuttt":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836754397","body":"### 思路\r\n把 num 和 k 都转成数组，进行大数相加\r\n\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  k = k.toString().split(\"\").map(item => Number(item));\r\n\r\n  let carry = 0;\r\n  let result = []\r\n  while(num.length || k.length) {\r\n    carry += ~~num.pop() + ~~k.pop();\r\n    if(carry < 10){\r\n      result.unshift(carry);\r\n      carry = 0;\r\n    }else{\r\n      result.unshift(carry - 10);\r\n      carry = 1;\r\n    }\r\n  }\r\n\r\n  if(carry){\r\n    result.unshift(carry);\r\n    return result;\r\n  }else{\r\n    return result;\r\n  }\r\n\r\n\r\n};\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838578435","body":"### 解题思路\r\n贪心算法\r\n左边遍历，最小距离是多少，右边遍历，最小距离是多少，最后遍历取最小值\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar shortestToChar = function (s, c) {\r\n  let n = s.length;\r\n  let dp = new Array(n).fill(0);\r\n  let leftDp = new Array(n).fill(0);\r\n  let rightDp = new Array(n).fill(0);\r\n\r\n  let prev = -Infinity;\r\n  for(let i = 0; i < n; i++) {\r\n    if(s[i] === c) prev = i;\r\n    leftDp[i] = i - prev;\r\n  }\r\n\r\n  prev = Infinity;\r\n  for(let i = n - 1; i >= 0; i--) {\r\n    if(s[i] === c) prev = i;\r\n    rightDp[i] = prev - i;\r\n  }\r\n\r\n  for(let i = 0; i < n; i++){\r\n    dp[i] = Math.min(rightDp[i], leftDp[i])\r\n  };\r\n\r\n  return dp;\r\n\r\n};\r\n\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838578435","body":"### 解题思路\r\n贪心算法\r\n左边遍历，最小距离是多少，右边遍历，最小距离是多少，最后遍历取最小值\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar shortestToChar = function (s, c) {\r\n  let n = s.length;\r\n  let dp = new Array(n).fill(0);\r\n  let leftDp = new Array(n).fill(0);\r\n  let rightDp = new Array(n).fill(0);\r\n\r\n  let prev = -Infinity;\r\n  for(let i = 0; i < n; i++) {\r\n    if(s[i] === c) prev = i;\r\n    leftDp[i] = i - prev;\r\n  }\r\n\r\n  prev = Infinity;\r\n  for(let i = n - 1; i >= 0; i--) {\r\n    if(s[i] === c) prev = i;\r\n    rightDp[i] = prev - i;\r\n  }\r\n\r\n  for(let i = 0; i < n; i++){\r\n    dp[i] = Math.min(rightDp[i], leftDp[i])\r\n  };\r\n\r\n  return dp;\r\n\r\n};\r\n\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840618300","body":"### 解题思路\r\n没有完成栈，暂时实现的没有嵌套的\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  let num = 0;\r\n  let str ;\r\n  let result = \"\";\r\n  for(let i = 0; i < s.length; i++) {\r\n    if(s[i] >= \"0\" && s[i] <= \"9\") {\r\n      num = num * 10 + Number(s[i]);\r\n    }\r\n    if(s[i] === \"[\") {\r\n      str = \"\";\r\n    }\r\n    if(s[i] === \"]\") {\r\n      for(let j = 0; j < num; j++) {\r\n        result += str;\r\n      }\r\n      str = \"\";\r\n      num = 0\r\n    }\r\n    if(s[i] >= \"a\" && s[i] <= \"z\") {\r\n      str += s[i];\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"WIN0624":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836759785","body":"## 思路\r\n\r\n* 把K加入A中，降低空间复杂度\r\n    * 从A的最后一位开始遍历，先将K（carry初始化为K）与最后一位相加，保留余数，整除10之后进位，直至carry为0\r\n    * 时间复杂度：O(N+max(0, K-N))\r\n    * 空间复杂度：O(max(1, K-N))\r\n* 难点：两者长度不等的情况，如何处理\r\n    * 若两者相等，最后多出的carry，新建B，把往A头部补位，变成B和A相加\r\n    * 若A长于B，则carry为0，不影响A继续补位\r\n    * 若B长于A， 则等同于有多出carry，B的补位可以直接通过数组相加，把当前位当做一个数组\r\n\r\n## 代码 | Python\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        carry = k\r\n        for i in range(len(num) - 1, -1, -1):\r\n            num[i], carry = (num[i] + carry) % 10, (num[i] + carry) // 10\r\n\t# deal with remain\r\n        B = []\r\n        while carry > 0:\r\n            B = [carry % 10] + B\r\n            carry //= 10\r\n        \r\n        return B + num\r\n```\r\n\r\n## 复杂度分析\r\n\r\n  * 时间复杂度：O(N+max(0, K-N))\r\n  * 空间复杂度：O(max(1, K-N))"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838717744","body":"## 思路\r\n\r\n  * 从左往右遍历一次，只记录到上一个C元素的距离（即在其右边的C），为`i-prev`\r\n  * 从右往左遍历一次，只记录到上一个C元素的距离(即在其左边的C）, 为`prev-i`\r\n  * 两个数组对应位数取最小值\r\n  * 要点\r\n      * 记住上一个，而非下一个，使得可以一边往后遍历，一边往ans加元素\r\n      * 不必分开两个数组存储，就存到一个，只不过第二次遍历的时候增加一个min的比较\r\n\r\n## 代码 | Python\r\n\r\n```python\r\nClass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        ans = []\r\n        # left to right iteration\r\n        prev = float('-inf')\r\n        for num, val in enumerate(S):\r\n            if val == C:\tprev = num\r\n            ans.append(num - prev)\r\n\t\t\r\n        # right to left iteration\r\n        prev = float('inf')\r\n        for num in range(len(S) - 1, -1, -1):\r\n            if S[num] == C:\tprev = num\r\n            ans[num] = min(ans[num], prev - num)\r\n        \r\n        return ans\r\n```\r\n\r\n## 复杂度分析\r\n\r\n  * 时间复杂度：$O(N)$\r\n  * 空间复杂度：$O(N)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838717744","body":"## 思路\r\n\r\n  * 从左往右遍历一次，只记录到上一个C元素的距离（即在其右边的C），为`i-prev`\r\n  * 从右往左遍历一次，只记录到上一个C元素的距离(即在其左边的C）, 为`prev-i`\r\n  * 两个数组对应位数取最小值\r\n  * 要点\r\n      * 记住上一个，而非下一个，使得可以一边往后遍历，一边往ans加元素\r\n      * 不必分开两个数组存储，就存到一个，只不过第二次遍历的时候增加一个min的比较\r\n\r\n## 代码 | Python\r\n\r\n```python\r\nClass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        ans = []\r\n        # left to right iteration\r\n        prev = float('-inf')\r\n        for num, val in enumerate(S):\r\n            if val == C:\tprev = num\r\n            ans.append(num - prev)\r\n\t\t\r\n        # right to left iteration\r\n        prev = float('inf')\r\n        for num in range(len(S) - 1, -1, -1):\r\n            if S[num] == C:\tprev = num\r\n            ans[num] = min(ans[num], prev - num)\r\n        \r\n        return ans\r\n```\r\n\r\n## 复杂度分析\r\n\r\n  * 时间复杂度：$O(N)$\r\n  * 空间复杂度：$O(N)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840655220","body":"## 思路\r\n\r\n* 四种可能字符\r\n    * 遇到数字，开始累加\r\n    * 遇到左括号，累加数字放入栈，获取括号内部字符串，清空数字\r\n    * 遇到右括号，在当前字符串 * 累加数字（从栈中pop出）\r\n    * 普通字母，直接加到当前函数的解码字符串中\r\n* def：记得更新索引\r\n\r\n## 代码 | Python\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        def get_inner_str(s, i, stack):\r\n            decode_str = ''      # init decode_str\r\n            accum_num = []\r\n            while i < len(s):\r\n                if s[i] >= '0' and s[i] <= '9':\r\n                    accum_num.append(s[i])\r\n                elif s[i] == '[':\r\n                    stack.append(int(''.join(accum_num)))\r\n                    inner_str, i = get_inner_str(s, i+1, stack)\r\n                    decode_str += inner_str\r\n                    accum_num = []\r\n                elif s[i] == ']':\r\n                    return stack.pop() * decode_str, i\r\n                else:\r\n                    decode_str += s[i]\r\n                i += 1\r\n            return decode_str\r\n                    \r\n        return get_inner_str(s, 0, [])\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：O(N)，N为当前字符串长度\r\n* 空间复杂度：O(M)，M为解码后字符串长度"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ShunzWu012":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836761592","body":"### 思路\r\n按位相加，注意k的长度可能比num大\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList<>();\r\n        int n = num.length;\r\n        for(int i = n - 1; i >= 0; i--){\r\n            int sums = num[i] + k % 10;\r\n            k /= 10;\r\n            if(sums >= 10){\r\n                k++;\r\n            }\r\n            ans.add(sums%10);\r\n        }\r\n        while(k != 0){\r\n            ans.add(k%10);\r\n            k /= 10;\r\n        }\r\n        n = ans.size();\r\n        for(int i = 0; i < n/2; i++){\r\n            int temp = ans.get(i);\r\n            ans.set(i, ans.get(n-i-1));\r\n            ans.set(n-i-1, temp);\r\n        }\r\n        return  ans;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n- T:O(max(n, log(10, k)))\r\n- S:O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837715789","body":"### 思路\r\n对于每个字符而言，只需要比较当前字符到两边c的最短距离即可。\r\n\r\n注;为了不讨论左端点和右端点，对索引数组进行预处理，两端加上一个大值。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        List<Integer> idx = new ArrayList<>();\r\n        int n = s.length();\r\n        idx.add(n);\r\n        for(int i = 0; i < n; i++){\r\n            if(s.charAt(i) == c){\r\n                idx.add(i);\r\n            }\r\n        }\r\n        idx.add(n*2);\r\n        int[] ans = new int[n];\r\n        int j = 0;\r\n        for(int i = 0; i < n; i++){\r\n            if(s.charAt(i) == c){\r\n                ans[i] = 0;\r\n                j++;\r\n            }\r\n            else{\r\n                ans[i] = Math.min(Math.abs(i - idx.get(j)), Math.abs(idx.get(j+1) - i));\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n- T:O(n)\r\n- S:O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837715789","body":"### 思路\r\n对于每个字符而言，只需要比较当前字符到两边c的最短距离即可。\r\n\r\n注;为了不讨论左端点和右端点，对索引数组进行预处理，两端加上一个大值。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        List<Integer> idx = new ArrayList<>();\r\n        int n = s.length();\r\n        idx.add(n);\r\n        for(int i = 0; i < n; i++){\r\n            if(s.charAt(i) == c){\r\n                idx.add(i);\r\n            }\r\n        }\r\n        idx.add(n*2);\r\n        int[] ans = new int[n];\r\n        int j = 0;\r\n        for(int i = 0; i < n; i++){\r\n            if(s.charAt(i) == c){\r\n                ans[i] = 0;\r\n                j++;\r\n            }\r\n            else{\r\n                ans[i] = Math.min(Math.abs(i - idx.get(j)), Math.abs(idx.get(j+1) - i));\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n- T:O(n)\r\n- S:O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840430499","body":"### 思路\r\n一个字符栈，一个数字栈。\r\n题目规定了，一定为k[encoding]的形式，\r\n那么，把每一个括号对中的内容提取出来后，和前一个数字做一个乘法运算就搞定啦。\r\n\r\n1. 遇到数字，继续遍历，直到非数字，入数字栈；\r\n2. 遇到 \"]\"，字符栈出栈，直到“[”，重新入栈；\r\n3. 其他情况，入字符栈\r\n\r\n### 代码(Java/Cpp/python3)\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<Character> charStack = new Stack<>();\r\n        Stack<Integer> cnts = new Stack<>();\r\n        int i = 0;\r\n        int n = s.length();\r\n        while(i < n){\r\n            if(Character.isDigit(s.charAt(i))){\r\n                int k = i;\r\n                while(i < n && Character.isDigit(s.charAt(i))){\r\n                    i++;\r\n                }\r\n                int cnt = Integer.parseInt(s.substring(k, i));\r\n                cnts.push(cnt);\r\n            }\r\n            else if(s.charAt(i) == ']'){\r\n                String str = \"\";\r\n                while(!charStack.isEmpty()){\r\n                    if(charStack.peek() == '['){\r\n                        charStack.pop();\r\n                        break;\r\n                    }\r\n                    else{\r\n                        str = charStack.peek() + str;\r\n                        charStack.pop();\r\n                    }\r\n                }\r\n                for(int j = 0; j < cnts.peek(); j++){\r\n                    for(char ch:str.toString().toCharArray()){\r\n                        charStack.push(ch);\r\n                    }\r\n                }\r\n                cnts.pop();\r\n                i++;\r\n\r\n            }\r\n            else {\r\n                charStack.push(s.charAt(i));\r\n                i++;\r\n            }\r\n        }\r\n        String ans  = \"\";\r\n        while(!charStack.isEmpty()){\r\n            ans = charStack.peek() + ans;\r\n            charStack.pop();\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    string decodeString(string decodestrs) {\r\n        stack<string> strs;\r\n        stack<int> nums;\r\n        string res=\"\";\r\n        int times=0;\r\n        for(auto s: decodestrs){\r\n            if('0' <= s && s <= '9'){\r\n                times = times*10 + int(s-'0');\r\n            }\r\n            else if('[' == s){\r\n                nums.push(times);\r\n                times = 0;\r\n                strs.push(res);\r\n                res = \"\";\r\n            }\r\n            else if(('a' <= s && s <= 'z') || ('A' <= s && s <= 'Z') ){\r\n                res += s;\r\n            }\r\n            else{\r\n                int n = nums.top();\r\n                nums.pop();\r\n                for(int i=0;i<n;i++){\r\n                    strs.top() += res;\r\n                }\r\n                res = strs.top();\r\n                strs.pop();\r\n                \r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n};\r\n```\r\n```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        if s:\r\n            stack = [s[0]]\r\n            i = 0\r\n            res = ''\r\n            while stack and i < len(s)-1:\r\n                i += 1\r\n                if s[i] != ']':\r\n                    stack.append(s[i])\r\n                else:\r\n                    tmp = ''\r\n                    # 取字符后缀\r\n                    while stack[-1] != '[':\r\n                        tmp = stack.pop() + tmp\r\n                    stack.pop()\r\n                    n = stack.pop()\r\n                    num = ''\r\n                    # 取数字前缀\r\n                    while '0' <= n and n <= '9' and stack:\r\n                        num = n + num\r\n                        n = stack.pop()\r\n                    if not ('0' <= n and n <= '9'):\r\n                        stack.append(n)\r\n                    else:\r\n                        num = n + num\r\n                    num = int(num)\r\n                    tmp = num*tmp\r\n                    stack.append(tmp)\r\n            res = ''\r\n            for s in stack:\r\n                res += s\r\n            return res\r\n        return s\r\n```\r\n### 复杂度分析\r\n- T:O(n)\r\n- S:O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangpengzhen":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836765721","body":"不会没思路"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837748302","body":"没思路"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837748302","body":"没思路"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840281496","body":"### 思路\r\n辅助栈\r\n### 代码\r\n\r\n` function CodeStr(s) {\r\n    let repeats = 0, res = ''; const strStack = [], numStack = [];\r\n    for (let str of s) {\r\n        if (!isNaN(str)) {//是数字\r\n            repeats = 10 * repeats + +str;\r\n        } else if (str === '[') {\r\n            //进入下一层\r\n            numStack.push(repeats);\r\n            repeats = 0;\r\n            strStack.push(res);\r\n            res = ''\r\n        } else if (str === ']') {\r\n            res = strStack.pop() + res.repeat(numStack.pop())\r\n        } else {\r\n            res += str\r\n        }\r\n    }\r\n        return res\r\n\r\n};`\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yxq1997":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836766743","body":"## 前置知识\r\n\r\n- 数组的遍历，整数的运算\r\n\r\n## 思路\r\n- 从后往前遍历数组，得到的是X的从低到高的每一位\r\n- k%10得到最低位，k/10更新当前k的倒数第二位为最低位\r\n- 通过将k的最低位与X的最低位诸位相加得到新的结果value，并用count = value /10保存当前加法后的进位数值，用value/10保留当前加法后的最低位\r\n\r\n## 关键点\r\n\r\n-  可以吧k当做一个数组来看，本题类似于两个数组的加法运算，加法循环的终止条件是两个数组(k和nuns)都便利了一遍，且进位count为0\r\n- 在本题中直接得到的结果在list中是逆序排列的，因此需要反转\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int count = 0; // 表示进位符\r\n        List<Integer> list = new ArrayList<>();\r\n        int n = num.length;\r\n        int value = 0;\r\n        for(int i=n-1;i>=0;i--){\r\n            int kNum = k % 10;\r\n            value = num[i] + kNum + count;\r\n            count = value / 10;\r\n            list.add(value % 10);\r\n            if(k > 0)\r\n                k /= 10;\r\n        }\r\n        k += count;\r\n        while(k > 0){\r\n            list.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(list);\r\n        return list;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(max(n, log k)$\r\n- 空间复杂度：$O(1)$"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838216276","body":"## 前置知识\r\n\r\n- 数组的遍历\r\n\r\n## 思路\r\n- 由题意可知每个字符的最短距离，即是左边离该字符最近的c字符与右边离该字符最近的c字符的距离的较小值\r\n- 因此通过一次顺序遍历，得到左边离该字符最近的c字符到该字符的距离；然后一次逆序遍历，得到右边离该字符最近的c字符到该字符的距离，两者比较去较小值即可\r\n\r\n## 关键点\r\n\r\n-  怎样实现只取左边最近的c字符的距离与右边最近的c字符的距离 --> 分别通过顺序和逆序遍历得到\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java {15}\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c){\r\n        int n = s.length();\r\n        int[] ans = new int[n];\r\n        int prev = -n;\r\n        for(int i=0;i<n;i++){\r\n            if(s.charAt(i) == c)\r\n                prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = 2 * n;\r\n        for(int i=n-1;i>=0;i--){\r\n            if(s.charAt(i) == c)\r\n                prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n令 n 为数组长度。\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838216276","body":"## 前置知识\r\n\r\n- 数组的遍历\r\n\r\n## 思路\r\n- 由题意可知每个字符的最短距离，即是左边离该字符最近的c字符与右边离该字符最近的c字符的距离的较小值\r\n- 因此通过一次顺序遍历，得到左边离该字符最近的c字符到该字符的距离；然后一次逆序遍历，得到右边离该字符最近的c字符到该字符的距离，两者比较去较小值即可\r\n\r\n## 关键点\r\n\r\n-  怎样实现只取左边最近的c字符的距离与右边最近的c字符的距离 --> 分别通过顺序和逆序遍历得到\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java {15}\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c){\r\n        int n = s.length();\r\n        int[] ans = new int[n];\r\n        int prev = -n;\r\n        for(int i=0;i<n;i++){\r\n            if(s.charAt(i) == c)\r\n                prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = 2 * n;\r\n        for(int i=n-1;i>=0;i--){\r\n            if(s.charAt(i) == c)\r\n                prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n令 n 为数组长度。\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840273846","body":"## 题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 前置知识\r\n- 字符串的判断：是不是数字\r\n- 用栈进行符号匹配\r\n## 思路\r\n- 将s的字符进栈，当碰到‘]’时将栈顶元素去除，直到碰到'['，即得到要重复的字符串，然后继续取出栈顶元素直到碰到‘]’或栈为空，此即为该字符串要重复的次数，然后将重复后的字符串重新入栈。\r\n- 栈的作用即为再不改变字符串相对顺序的情况下，消除s中的 '[' 和 ']' 字符\r\n## 关键点\r\n-  ‘[’ 字符只用作匹配 ']' 字符，一旦匹配成功，则将 '[' 字符出栈\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        int n = s.length();\r\n        Deque<Character> stack = new LinkedList<>();\r\n        StringBuilder res = new StringBuilder();\r\n        for(int i=0;i<n;i++){\r\n            char c = s.charAt(i);\r\n            if(c != ']'){\r\n                stack.push(c);\r\n            }\r\n            else{\r\n                StringBuilder str = new StringBuilder();\r\n                while(!stack.isEmpty() && stack.peek() != '['){\r\n                    str.append(stack.pop());\r\n                }\r\n                stack.pop();\r\n                StringBuilder digit = new StringBuilder();\r\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\r\n                    digit.insert(0, stack.pop());\r\n                }\r\n                int count = Integer.parseInt(digit.toString());\r\n                for(int j=0;j<count;j++){\r\n                    for(int k=str.length()-1;k>=0; k--){\r\n                        char ch = str.charAt(k);\r\n                        stack.push(ch);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        while (!stack.isEmpty()){\r\n            res.append(stack.pop());  //最后反转能降低所用时间 \r\n        }\r\n        return res.reverse().toString();\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n令 n 为数组长度。\r\n- 时间复杂度：$O(n^2)$ --> 每个元素至多进栈和出栈n/2次\r\n- 空间复杂度：$O(n)$  --> 使用了一个stack,容量至多为n；两个StringBuildere类型数据str和digit，长度之和不会超过n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Forschers":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836774703","body":"\r\n## 思路\r\n将k中的数取出一个个加入到数组中\r\n\r\n\r\neg:将【2，3，4】+ k=32 计算 4+32 因为4+32  = 36将6留在当前位 将k/10 以进为的形式加入到下个位中\r\n重复过程计算 【2，3】+ 3\r\n\r\n## 关键点\r\n\r\n-  将k放入到数组后\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> arr = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        //将k以 k/10的形式进位\r\n        for(int i = n-1;i>=0 || k>0;--i,k/=10){\r\n            if(i >= 0){\r\n                k +=num[i];\r\n            }\r\n            //加上k取出来的最后一位\r\n            arr.add(k%10);\r\n        }\r\n        //反转\r\n        Collections.reverse(arr);\r\n        return arr;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(max(n,logk))\r\n- 空间复杂度：O(1)\r\n\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838618318","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n整形反转\r\n\r\n## 思路\r\n对每个字符串 找出左右中c的距离 比较左右的距离 选择最小值\r\n\r\n\r\n左向右：\r\n\r\n上个字符出现的位置prev  距离 : i - prev\r\n\r\n右向左：\r\n\r\n上个字符出现的位置prev 则距离: prev - i\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        //创建新的数组ans\r\n        int[] ans = new int[n];\r\n        int prev = Integer.MIN_VALUE/2;\r\n\r\n        for(int i = 0;i < n;++i){\r\n            //法返回指定索引处的char值\r\n            if(s.charAt(i) == c){\r\n                //当遍历的值和c相等 位置prev为当前i 的位置\r\n                prev = i;\r\n            }\r\n            //左 ==》 右 遍历\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n         prev = Integer.MAX_VALUE/2;\r\n\r\n        for(int i = n-1;i >= 0;--i){\r\n            //法返回指定索引处的char值\r\n            if(s.charAt(i) == c){\r\n                //当遍历的值和c相等 位置prev为当前i 的位置\r\n                prev = i;\r\n            }\r\n            //选择其中最小的\r\n            ans[i] = Math.min(ans[i],prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838618318","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n整形反转\r\n\r\n## 思路\r\n对每个字符串 找出左右中c的距离 比较左右的距离 选择最小值\r\n\r\n\r\n左向右：\r\n\r\n上个字符出现的位置prev  距离 : i - prev\r\n\r\n右向左：\r\n\r\n上个字符出现的位置prev 则距离: prev - i\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        //创建新的数组ans\r\n        int[] ans = new int[n];\r\n        int prev = Integer.MIN_VALUE/2;\r\n\r\n        for(int i = 0;i < n;++i){\r\n            //法返回指定索引处的char值\r\n            if(s.charAt(i) == c){\r\n                //当遍历的值和c相等 位置prev为当前i 的位置\r\n                prev = i;\r\n            }\r\n            //左 ==》 右 遍历\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n         prev = Integer.MAX_VALUE/2;\r\n\r\n        for(int i = n-1;i >= 0;--i){\r\n            //法返回指定索引处的char值\r\n            if(s.charAt(i) == c){\r\n                //当遍历的值和c相等 位置prev为当前i 的位置\r\n                prev = i;\r\n            }\r\n            //选择其中最小的\r\n            ans[i] = Math.min(ans[i],prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"XinlingQiu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836776627","body":"- 语言 python\r\n- 时间复杂度：O(max(n,log(k)))\r\n- 空间复杂度：O(1)\r\n- 无需反转\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n=len(num)\r\n        count=0#进位符\r\n        for i in range(n-1,-1,-1):\r\n            new_i=num[i]+k%10+count\r\n            count=new_i/10\r\n            num[i]=new_i%10\r\n            if k>0:\r\n                k=k/10\r\n        k+=count\r\n        while k>0:\r\n            num.insert(0,k%10)\r\n            k/=10\r\n        return num\r\n```"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840630323","body":"```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        symbol=[]\r\n        for i in s:\r\n            try:\r\n                num=int(i)\r\n                num=symbol.pop()*10+num if symbol and isinstance(symbol[-1],int) else num\r\n                symbol.append(num)\r\n            except ValueError:\r\n                if i==']':\r\n                    s1=''\r\n                    while symbol[-1]!='[':\r\n                        s1=symbol.pop()+s1\r\n                    symbol.pop()\r\n                    symbol.append(symbol.pop()*s1)\r\n                else:\r\n                    symbol.append(i)\r\n        return ''.join(symbol)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suffocatingly0":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836783424","body":"- 语言 java\r\n- 时间复杂度O（n）\r\n- 空间复杂度O（n）\r\n- n = Math.max(num.length, k.length)\r\n```\r\nclass Solution {\r\n   public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res =new ArrayList<>();\r\n        int count=0;\r\n        for(int i=num.length-1;i>=0;i--){\r\n            int sum=num[i]+k%10;\r\n            k=k/10;\r\n            res.add((sum+count)%10);\r\n            count=(sum+count)/10;\r\n        }\r\n        if(count>0) k++;\r\n        for(;k>0;k/=10){\r\n            res.add(k%10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837657821","body":"- 语言：Java\r\n- 时间复杂度：O（N*M）\r\n- 空间复杂度：O（N）\r\n- N是s的长度，M是c在s中重复的个数\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        List<Integer> list=new ArrayList<>();\r\n        for(int i=0;i<s.length();i++){\r\n            if(s.charAt(i)==c){\r\n                list.add(i);\r\n            }\r\n        }\r\n       int [] distance=new int[list.size()];\r\n        for(int i=0;i<list.size();i++){\r\n            distance[i]=list.get(i);\r\n        }\r\n        int [] res =new int[s.length()];\r\n        Arrays.fill(res,Integer.MAX_VALUE);\r\n        for(int i=0;i<s.length();i++){\r\n            for(int j=0;j<distance.length;j++){\r\n                int a=Math.abs(i-distance[j]);\r\n                if(a<res[i]) res[i]=a;\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837657821","body":"- 语言：Java\r\n- 时间复杂度：O（N*M）\r\n- 空间复杂度：O（N）\r\n- N是s的长度，M是c在s中重复的个数\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        List<Integer> list=new ArrayList<>();\r\n        for(int i=0;i<s.length();i++){\r\n            if(s.charAt(i)==c){\r\n                list.add(i);\r\n            }\r\n        }\r\n       int [] distance=new int[list.size()];\r\n        for(int i=0;i<list.size();i++){\r\n            distance[i]=list.get(i);\r\n        }\r\n        int [] res =new int[s.length()];\r\n        Arrays.fill(res,Integer.MAX_VALUE);\r\n        for(int i=0;i<s.length();i++){\r\n            for(int j=0;j<distance.length;j++){\r\n                int a=Math.abs(i-distance[j]);\r\n                if(a<res[i]) res[i]=a;\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"S-T-D":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836785905","body":"# 思路\r\n\r\n对数组 `A` 从后往前遍历，同时对 `K` 取 10 的余数，将遍历的数字和余数相加得到新值，并更新数组对应位置的值，同时注意是否进位。\r\n\r\n注意：`K` 的位数可能比 `A` 的长度要长。\r\n\r\n&nbsp;\r\n\r\n# 代码\r\n\r\n```javascript\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    const len = num.length;    \r\n    let i = len - 1;\r\n    let carry = 0;\r\n    while (i >= 0) {\r\n        let addNum = 0;\r\n        if (k !== 0) {\r\n            addNum = k % 10;\r\n            k = Math.floor(k / 10);\r\n        }\r\n        let sum = num[i] + carry + addNum;\r\n        carry = sum >= 10 ? 1 : 0;\r\n        num[i] = sum % 10;\r\n        i--;\r\n    }\r\n    k += carry;\r\n    while (k !== 0) {\r\n        num.unshift(k % 10);\r\n        k = Math.floor(k / 10);\r\n    }\r\n    return num;\r\n};\r\n```\r\n\r\n&nbsp;\r\n\r\n# 复杂度分析\r\n\r\n令 `n` 为数组长度，`m` 为 `k` 的位数，按最坏情况\r\n\r\n时间：O(n + (m - n)^2)，第一个循环为 O(n)，第二个循环内在数组头部插入元素涉及数组的移动操作\r\n\r\n空间：O(m - n)，如果 `m` 大于 `n`，数组需要增加 `m - n` 的长度"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837706722","body":"## 思路\r\n\r\n可以分两次遍历。\r\n\r\n第一次遍历，从左往右，计算每个字符离左边的最近的 `c` 的距离。\r\n\r\n第二次遍历，从右往左，计算每个字符离右边最近的 `c` 的距离，再取最小值。\r\n\r\n## 代码\r\n\r\n```javascript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    const ans = [];\r\n    const len = s.length;\r\n\r\n    let prev = -10000;\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) {\r\n            prev = i;\r\n        }\r\n        ans.push(i - prev);\r\n    }\r\n\r\n    prev = 20000;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] === c) {\r\n            prev = i;\r\n        }\r\n        ans[i] = Math.min(ans[i], prev - i);\r\n    }\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间：O(n)，`n` 为字符串的长度。  \r\n- 空间：O(1)，忽略返回的数组所占空间。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837706722","body":"## 思路\r\n\r\n可以分两次遍历。\r\n\r\n第一次遍历，从左往右，计算每个字符离左边的最近的 `c` 的距离。\r\n\r\n第二次遍历，从右往左，计算每个字符离右边最近的 `c` 的距离，再取最小值。\r\n\r\n## 代码\r\n\r\n```javascript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    const ans = [];\r\n    const len = s.length;\r\n\r\n    let prev = -10000;\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) {\r\n            prev = i;\r\n        }\r\n        ans.push(i - prev);\r\n    }\r\n\r\n    prev = 20000;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] === c) {\r\n            prev = i;\r\n        }\r\n        ans[i] = Math.min(ans[i], prev - i);\r\n    }\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间：O(n)，`n` 为字符串的长度。  \r\n- 空间：O(1)，忽略返回的数组所占空间。\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsgouwan":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836787849","body":"思路：\r\n    转化为数组， 从末位起，两两相加，\r\n\r\n代码：\r\n```\r\n var addToArrayForm = function(num, k) {\r\n        let result = []\r\n        k = k.toString().split('')\r\n        let carryBit = 0\r\n        let _temp = 0\r\n        while(num.length > 0 || k.length > 0) {\r\n            let num1 = num.pop() \r\n            let num2 = k.pop() \r\n            num1 = num1 ? num1 * 1 : 0\r\n            num2 = num2 ? num2 * 1 : 0\r\n            _temp = num1 + num2 + carryBit\r\n            if(_temp > 9) {\r\n                carryBit = 1\r\n                _temp = _temp - 10\r\n            }else {\r\n                carryBit = 0\r\n            }\r\n            result.unshift(_temp)\r\n        }\r\n\r\n        if(carryBit > 0) {\r\n            result.unshift(1)\r\n        }\r\n        return result;\r\n    };\r\n```\r\nn = Math.max(num.length, k.length)\r\n时间复杂度：O(n)\r\n空间复杂度O(n)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838184466","body":"思路: 字符串转化为数组，找出匹配字符串在数组中的下标存为数组2；遍历数组，找出数组中差值最小的下标并返回\r\n语言: javascript\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    s = s.split('')\r\n    // 先遍历出C在数组中的位置\r\n    let subscript = []\r\n    let result = []\r\n    s.forEach((item, index) => {\r\n        if(item === c) {\r\n            subscript.push(index)\r\n        }\r\n    })\r\n    // \r\n    s.forEach((item, index) => {\r\n        let _min = subscript.reduce((pre, next) => {\r\n            return Math.min(pre, Math.abs(next - index))\r\n        }, Math.abs(subscript[0] - index))\r\n        result.push(_min)\r\n    })\r\n    return result\r\n};\r\n```\r\n\r\n复杂度：\r\n    字符串的长度 为m  \r\n    字符在字符串的个数为n \r\n    时间复杂度：O(m*n)\r\n    空间复杂度：O(m)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838184466","body":"思路: 字符串转化为数组，找出匹配字符串在数组中的下标存为数组2；遍历数组，找出数组中差值最小的下标并返回\r\n语言: javascript\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    s = s.split('')\r\n    // 先遍历出C在数组中的位置\r\n    let subscript = []\r\n    let result = []\r\n    s.forEach((item, index) => {\r\n        if(item === c) {\r\n            subscript.push(index)\r\n        }\r\n    })\r\n    // \r\n    s.forEach((item, index) => {\r\n        let _min = subscript.reduce((pre, next) => {\r\n            return Math.min(pre, Math.abs(next - index))\r\n        }, Math.abs(subscript[0] - index))\r\n        result.push(_min)\r\n    })\r\n    return result\r\n};\r\n```\r\n\r\n复杂度：\r\n    字符串的长度 为m  \r\n    字符在字符串的个数为n \r\n    时间复杂度：O(m*n)\r\n    空间复杂度：O(m)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840321754","body":"思路： 递归 + 栈\r\n自己最开始没有想明白，参考其他同学思路，最终想明白且理解\r\n代码：\r\n```\r\nvar decodeString = function (s) {\r\n    let strStack = []  \r\n    let numStack = []\r\n    let result = ''\r\n    let num = 0\r\n    for(let value of s) {\r\n        if(!isNaN(value)) {\r\n            num =num * 10 + Number(value)\r\n        }else if(value === '[') {\r\n            strStack.push(result); \r\n            result = ''\r\n            numStack.push(num) \r\n            num = 0 \r\n        }else if(value === ']') {\r\n            result = strStack.pop() + result.repeat(numStack.pop())\r\n        }else {\r\n            result += value\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ziwh":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836788224","body":"## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n当前位 = (A 的当前位 + B 的当前位 + 进位) % 10\r\n\r\n注意，AB两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在前面。\r\n\r\n```\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位\r\n    \r\n    // 循环条件调整\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n```\r\n\r\n## 代码\r\nJava\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int i = num.length - 1;\r\n        int sum = 0;\r\n        List<Integer> ans = new ArrayList<>();\r\n        while(i >= 0 || k != 0 || sum != 0) {\r\n            int x = i >= 0 ? num[i] : 0;\r\n            int y = k != 0 ? k % 10 : 0;\r\n            sum += x + y;\r\n            ans.add(sum % 10);\r\n            sum = sum / 10;\r\n            k = k / 10;\r\n            i--;\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(max(n, log(k))\r\n空间复杂度: O(1)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837651373","body":"## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n当前字符距离c最短距离 = Math.min(当前字符距离左边c字符最短距离, 当前字符距离右边边c字符最短距离)\r\n\r\n\r\n## 代码\r\nJava\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] prev = new int[s.length()];\r\n        int[] next = new int[s.length()];\r\n\r\n        int begin = -1;\r\n        int end = s.length();\r\n        for(int i = 0; i < s.length(); i++) {\r\n            int endLoc = s.length() - i - 1;\r\n            if(s.charAt(i) == c) {\r\n                begin = i;\r\n                prev[i] = 0;\r\n            } else {\r\n                if(begin < 0) prev[i] = Integer.MAX_VALUE;\r\n                else prev[i] = i - begin;\r\n            }\r\n            if(s.charAt(endLoc) == c) {\r\n                end = endLoc;\r\n                next[end] = 0;\r\n            } else {\r\n                if(end > s.length() - 1) next[endLoc] = Integer.MAX_VALUE;\r\n                else next[endLoc] = end - endLoc;\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < s.length(); i++) {\r\n            prev[i] = Math.min(prev[i], next[i]);\r\n        }\r\n        return prev;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度: O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837651373","body":"## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n当前字符距离c最短距离 = Math.min(当前字符距离左边c字符最短距离, 当前字符距离右边边c字符最短距离)\r\n\r\n\r\n## 代码\r\nJava\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] prev = new int[s.length()];\r\n        int[] next = new int[s.length()];\r\n\r\n        int begin = -1;\r\n        int end = s.length();\r\n        for(int i = 0; i < s.length(); i++) {\r\n            int endLoc = s.length() - i - 1;\r\n            if(s.charAt(i) == c) {\r\n                begin = i;\r\n                prev[i] = 0;\r\n            } else {\r\n                if(begin < 0) prev[i] = Integer.MAX_VALUE;\r\n                else prev[i] = i - begin;\r\n            }\r\n            if(s.charAt(endLoc) == c) {\r\n                end = endLoc;\r\n                next[end] = 0;\r\n            } else {\r\n                if(end > s.length() - 1) next[endLoc] = Integer.MAX_VALUE;\r\n                else next[endLoc] = end - endLoc;\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < s.length(); i++) {\r\n            prev[i] = Math.min(prev[i], next[i]);\r\n        }\r\n        return prev;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度: O(n)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"CruiseYuGH":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836790900","body":"## 思路\r\n\r\nsum_temp = num[i]+k%10 +temp\r\n分别更新temp 和 num[i]\r\n最后判别下是否有剩余的K or temp\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        temp = 0\r\n        for i in range(len(num)-1,-1,-1):\r\n            if k > 0 or temp>0:\r\n                sum_temp = num[i]+k%10 +temp\r\n                num[i]=sum_temp%10\r\n                temp = sum_temp//10\r\n                k = k//10\r\n        k+=temp\r\n        if k >0 :\r\n            while K:\r\n                num.insert(0,k%10)\r\n                k = k//10\r\n        return num\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838684275","body":"## 思路\r\n找出左右两边距离最近的，再取其中最小的\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        left  = [999 for i in range(len(s))]\r\n        right = [999 for i in range(len(s))]\r\n        for i in range(len(s)):\r\n            #print(i,len(s))\r\n            if s[i]==c:\r\n                left[i]=0\r\n            elif i!=0 and left[i-1]!=999 :\r\n                left[i] = left[i-1]+1\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i]==c:\r\n                right[i]=0\r\n            elif i!=len(s)-1 and right[i+1]!=999 :\r\n                right[i] = right[i+1]+1\r\n        res = [min(right[i],left[i]) for i in range(len(s))]\r\n        return res\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838684275","body":"## 思路\r\n找出左右两边距离最近的，再取其中最小的\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        left  = [999 for i in range(len(s))]\r\n        right = [999 for i in range(len(s))]\r\n        for i in range(len(s)):\r\n            #print(i,len(s))\r\n            if s[i]==c:\r\n                left[i]=0\r\n            elif i!=0 and left[i-1]!=999 :\r\n                left[i] = left[i-1]+1\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i]==c:\r\n                right[i]=0\r\n            elif i!=len(s)-1 and right[i+1]!=999 :\r\n                right[i] = right[i+1]+1\r\n        res = [min(right[i],left[i]) for i in range(len(s))]\r\n        return res\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840618054","body":"1. 用栈实现括号匹配\r\n给定的字符串可以存储到一个栈中\r\n出栈入栈条件为：\r\n如果非]，就入栈\r\n如果是]，那么就循环出栈，直到找到一个匹配的[\r\n注意数字如果是两位数，需要处理，所以为了方便，我们先把数字解析出来，变成一个元素存储在栈中，这样每次匹配左右括号时，可以直接取左括号的上一位元素进行复制操作即可\r\n代码\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        cur_num = 0\r\n        cur_str=\"\"\r\n        for c in s:\r\n            if c.isdigit():\r\n                cur_num = cur_num*10+int(c)\r\n            elif c is \"[\":\r\n                stack.append(cur_str)\r\n                stack.append(cur_num)\r\n                cur_str = ''\r\n                cur_num = 0\r\n            elif c is \"]\":\r\n                temp_num = stack.pop()\r\n                temp_str = stack.pop()\r\n                cur_str = temp_str + temp_num * cur_str\r\n            else:\r\n                cur_str+=c \r\n        return cur_str              \r\n复杂度分析\r\n令N为字符串长度\r\n\r\n时间复杂度：O(N) 只遍历了字符串一次，所以为线性复杂度\r\n\r\n空间复杂度：O(N) 使用了栈存储，所以为线性复杂度"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johanazhu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836791845","body":"## 思路\r\n\r\n#### 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n当前位 = (A 的当前位 + B 的当前位 + 进位) % 10\r\n\r\n注意，AB两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在前面。\r\n\r\n```\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位\r\n    \r\n    // 循环条件调整\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n```\r\n\r\n## 代码\r\n\r\nJavascript\r\n\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    k = k.toString();\r\n    let aLen = num.length, kLen = k.length;\r\n    num.reverse();\r\n    if(aLen > kLen) {\r\n        k = '0'.repeat(aLen - kLen) + k;\r\n    } else if(aLen < kLen) {\r\n        for(let i = 0; i < kLen - aLen; i++) {\r\n            num.push(0);\r\n        }\r\n    }\r\n    k = k.split('').reverse();\r\n    let sum = 0, carry = 0, res = [];\r\n    num.forEach((item, i)=>{\r\n        sum = item + + k[i] + carry;\r\n        carry = parseInt(sum / 10);\r\n        res.push(sum % 10)\r\n    })\r\n    if(carry > 0) {\r\n        res.push(carry)\r\n    }\r\n    return res.reverse();\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(max(n, log(k))\r\n空间复杂度: O(1)"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840621336","body":"## 思路\r\n\r\n#### 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n栈，\r\n\r\n如果是遇到的不是“]”，就往栈里压\r\n\r\n如果遇到“]”，就往栈里压“[]”前的数字*“[]”中的字母\r\n\r\n设置重复的数字为repeatCount，重复的字母为repeatStr，如何获取\r\n\r\n\r\n\r\n\r\n\r\n## 代码\r\n\r\nJavaScript\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n      let stack = []; // 保存需要 repeat 的字符串\r\n    let times = ''; // 乘以的倍数\r\n\r\n    for (let i = 0, len = s.length; i < len; i++) {\r\n        let item = s[i];\r\n\r\n        if (/[0-9]/.test(item)) {\r\n            if (i === 0 || /[0-9]/.test(s[i - 1])) {\r\n                times += item;\r\n            } else {\r\n                times = item\r\n            }\r\n        } else if (item === '[') {\r\n            times && stack.push(Number(times));\r\n            times = '';\r\n        } else if (item === ']') {\r\n            var curr = stack.pop();\r\n            var temp = '';\r\n            while (typeof curr !== 'number') {\r\n                temp = curr + temp;\r\n                curr = stack.pop();\r\n            }\r\n            temp = temp.repeat(curr);\r\n            stack.push(temp);\r\n        } else {\r\n            stack.push(item);\r\n        }\r\n    }\r\n    return stack.join('');\r\n\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度: O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zengwmFE":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836792060","body":"```\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let target = 0\r\n    let sum = 0\r\n    for(let i=num.length-1;i>=0;i--){\r\n        sum = num[i]+k%10+target \r\n        num[i] = sum%10\r\n        target = Math.floor(sum/10)   \r\n         k = Math.floor(k/10)\r\n\r\n    }\r\n    k = target + Number(k)\r\n    if(k){\r\n        let str = String(k)\r\n        for(let i=str.length-1;i>=0;i--){\r\n            num.unshift(str[i])\r\n        }\r\n    }\r\n    return num\r\n};\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838635265","body":"[题解同步到leetcode](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/liang-duan-xun-huan-que-ding-ju-chi-by-z-iryn/)\r\n自己写写思路，希望下次不要忘了，91奥利给\r\n## 思路\r\n令当前起始值为-1，如果第一个值\r\n这里采用，左右两端分别进行循环\r\n这里的关键在于如何处理匹配`c`之后的值：\r\n\r\n> 从右往左循环，可以拿到值离右边最近的`c`的距离\r\n> 如果当前这个值`s[i]`恰好等于`c`的时候，那么这个地方的pos[i] = 0，当然如果当前这个值之前还没有发现有`c`的存在的时候，这个时候，咱也不晓得（🤷‍♂️）这值是啥啊，那就可以先跳过这个位置：**即保留-1的状态值**，当找到了这个值的时候，就拿个东东（current）标识一哈：**current=i**，老铁开始出现了，那么就可以着手去更改位置的值了，那么这个位置是什么呢:?令i=2,current=1,距离是:高减低`current-i`.这样就得出了一个位置表达式\r\n\r\n> 从左往右循环，可以拿到值离左边最近的`c`的距离，一开始需要填填之前没有找到位置的地方，给他填好值吧，然后操作基本跟从右往左是一致的，但是距离表达式为**高减低`i-current`**，而且当遇到不为`-1`值的时候，我们需要判断两者的距离位置，最后肯定是要取一个小小的值！\r\n\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let len = s.length\r\n    let pos = new Array(len).fill(-1)\r\n    let current = -1\r\n    for(let i=len-1;i>=0;i--){\r\n        if(s[i] == c){\r\n            current = i\r\n            pos[i] = 0\r\n        }\r\n        if(current!==-1){\r\n            pos[i] = current-i\r\n        }\r\n\r\n    }\r\n    current = -1\r\n    for(let i=0;i<len;i++){\r\n        if(pos[i]===-1){\r\n            pos[i] = i-current\r\n        }\r\n        if(current!==-1){\r\n            pos[i] = Math.min(i-current,pos[i])\r\n        }\r\n        if(s[i]===c){\r\n            current = i\r\n        }\r\n    }\r\n    return pos\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838635265","body":"[题解同步到leetcode](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/liang-duan-xun-huan-que-ding-ju-chi-by-z-iryn/)\r\n自己写写思路，希望下次不要忘了，91奥利给\r\n## 思路\r\n令当前起始值为-1，如果第一个值\r\n这里采用，左右两端分别进行循环\r\n这里的关键在于如何处理匹配`c`之后的值：\r\n\r\n> 从右往左循环，可以拿到值离右边最近的`c`的距离\r\n> 如果当前这个值`s[i]`恰好等于`c`的时候，那么这个地方的pos[i] = 0，当然如果当前这个值之前还没有发现有`c`的存在的时候，这个时候，咱也不晓得（🤷‍♂️）这值是啥啊，那就可以先跳过这个位置：**即保留-1的状态值**，当找到了这个值的时候，就拿个东东（current）标识一哈：**current=i**，老铁开始出现了，那么就可以着手去更改位置的值了，那么这个位置是什么呢:?令i=2,current=1,距离是:高减低`current-i`.这样就得出了一个位置表达式\r\n\r\n> 从左往右循环，可以拿到值离左边最近的`c`的距离，一开始需要填填之前没有找到位置的地方，给他填好值吧，然后操作基本跟从右往左是一致的，但是距离表达式为**高减低`i-current`**，而且当遇到不为`-1`值的时候，我们需要判断两者的距离位置，最后肯定是要取一个小小的值！\r\n\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let len = s.length\r\n    let pos = new Array(len).fill(-1)\r\n    let current = -1\r\n    for(let i=len-1;i>=0;i--){\r\n        if(s[i] == c){\r\n            current = i\r\n            pos[i] = 0\r\n        }\r\n        if(current!==-1){\r\n            pos[i] = current-i\r\n        }\r\n\r\n    }\r\n    current = -1\r\n    for(let i=0;i<len;i++){\r\n        if(pos[i]===-1){\r\n            pos[i] = i-current\r\n        }\r\n        if(current!==-1){\r\n            pos[i] = Math.min(i-current,pos[i])\r\n        }\r\n        if(s[i]===c){\r\n            current = i\r\n        }\r\n    }\r\n    return pos\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840604606","body":"### 辅助栈法：\r\n思路：\r\n1. 数字首先需要单独取出来  要记住这个地方不是单独取一个，因为可能是10位也可能是百位\r\n2. 然后是`[`,先分析一下这个位置的，有什么内容，我们得到了一串数字，以及上一个集合留下的字符串res,以及`[`前的数字num\r\n     - 如果遇到了`[`，需要做的就是将字符串和数字入栈\r\n     - 同时清空这个字符串，可以避免和下次的重叠，同时将数字置为0\r\n3. 接着`]`，遇到这个内容，很明显就是已经把当前有效的字符都加完了，剩下的事就是按照这串文字前面的数字重复得到真正的明文res，那么这个值在哪？**栈顶**，因为很明显，`[`，肯定是立马有一个对应`]`，不管是`[[]]`还是`[]`，总有一个`[`对应着一个`]`,这个时候刚放进的，肯定是对应我们新的`]`，将栈顶出栈，res.repeat(pop[1])，这个就是我们这一次有效字符的真正解了，然后当然需要将我们之前一部分的有效集合接起来，即：`pop[0]+res.repeat(pop[1])`这样就是一个有效集合如：`a3[b]`的真正的解\r\n4. 最后处理正常的字符直接连接起来\r\n```\r\n let num = 0\r\n    let list = []\r\n    let res = ''\r\n    for(let i=0;i<s.length;i++){\r\n        if(/\\d/.test(s[i])){\r\n            // 数字\r\n            num = num*10+Number(s[i])\r\n            continue\r\n        }\r\n        if(s[i]==='['){\r\n            list.push([res,num])\r\n            res = '',num=0\r\n        }else if(s[i]===']'){\r\n            let top = list.pop()\r\n            res = top[0] + res.repeat(top[1])\r\n            \r\n        }else{\r\n            res += s[i]\r\n        }\r\n    }\r\n    return res\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n### 深度优先遍历\r\n思路：\r\n1. 首先对于数字的处理跟辅助栈是一样的\r\n2. 对`[`进行处理，这个时候标志了一个集合的开始，那么我们就可以从`i+1`的位置开始进行递归，而递归返回的就是这次有效集合的`res`和下次开始的位置，res+=temp.repeat(num)，同时从下一个位置继续循环\r\n3. 对`]`进行处理，这个标志了一个集合的结束，我们得到的`res`就是我们这一次所有的内容，记录结束位置，将[res,i]返回\r\n4.对普通字符处理同上\r\n```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let dfs = function(s,index){\r\n        let res = '',num=0\r\n           while(index<s.length){\r\n               if(/\\d/.test(s[index])){\r\n                   num = num*10+Number(s[index])\r\n               }else if(s[index]==='['){\r\n                   let [temp,i] = dfs(s,index+1)\r\n                   res+=temp.repeat(num)\r\n                   index = i\r\n                   num = 0\r\n               }else if(s[index]===']'){\r\n                   return [res,index]\r\n               }else{\r\n                   res+=s[index]\r\n               }\r\n               index++\r\n           }  \r\n        return res\r\n    }\r\n    return dfs(s,0)\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dorothyDing":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836793890","body":"javascript\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    let numStr = num.join('')\r\n    let maxLength = Math.max(numStr.length, k.toString().length)\r\n    numArr = numStr.padStart(maxLength, '0').split('').reverse()\r\n    kArr = k.toString().padStart(maxLength, '0').split('').reverse()\r\n    let flag = 0\r\n    for(let i = 0; i < maxLength; i++) {\r\n        let sum = Number(numArr[i]) + Number(kArr[i]) + flag\r\n        if (sum >= 10) {\r\n            flag = 1\r\n            sum -= 10\r\n        } else {\r\n            flag = 0\r\n        }\r\n        numArr[i] = sum\r\n    }\r\n    if (flag) {\r\n        numArr.push(flag)\r\n    }\r\n    return numArr.reverse().map(i => Number(i))\r\n};\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度:  O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838686757","body":"javascript\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let indexs = s.split('').map((item, index) => item === c ? index : null).filter(item => item != null)\r\n    return s.split('').map((_, index) => Math.min(...indexs.map(i => Math.abs(i - index))))\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838686757","body":"javascript\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let indexs = s.split('').map((item, index) => item === c ? index : null).filter(item => item != null)\r\n    return s.split('').map((_, index) => Math.min(...indexs.map(i => Math.abs(i - index))))\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mittacy":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836795620","body":"### 思路\r\n\r\n从后往前遍历num，和k进行加法运算并进位，每次存入数组(该数组是从低位往高位存储的)，直到k=0，最后反转数组\r\n\r\n### 代码\r\n\r\n\r\n```go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n    ans := make([]int, 0)\r\n    for i := len(num) - 1; i >= 0 || k > 0; i-- {\r\n        if i >= 0 {\r\n            k += num[i]\r\n        }\r\n        ans = append(ans, k%10)\r\n        k /= 10\r\n    }\r\n\r\n    i, j := 0, len(ans)-1\r\n    for i < j {\r\n        ans[i], ans[j] = ans[j], ans[i]\r\n        i++\r\n        j--\r\n    }\r\n    return ans\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(max(N, logk))，其中 N 为数组长度。(k / 10^n = 1 => logk)\r\n- 空间复杂度：O(1)，除了返回值为数组外，其他都为常量\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838160036","body":"### 思路\r\n\r\n两端遍历\r\n1. 从前往后，res[curIndex] = curIndex - newTargetIndex\r\n2. 从后往前，res[curIndex] = min(res[curIndex], newTargetIndex-curIndex)\r\n其中，newTargetIndex为目标字符最新出现索引位置\r\n\r\n### 代码\r\n\r\n\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    res := make([]int, len(s))\r\n    // 1<=s.length<=10000, targetIndex-10000<0, 所以应该设置targetIndex为-10000\r\n    targetIndex := -10000\r\n    for i := 0; i < len(s); i++ {\r\n        if s[i] == c {\r\n            targetIndex = i\r\n        }\r\n        res[i] = i - targetIndex\r\n    }\r\n\r\n    // 1<=s.length<=10000, targetIndex-10000>10000, 所以应该设置targetIndex为20000\r\n    targetIndex = 20000 \r\n    for i := len(s)-1; i >= 0; i-- {\r\n        if s[i] == c {\r\n            targetIndex = i\r\n        }\r\n        res[i] = min(res[i], targetIndex - i)\r\n    }\r\n    return res\r\n}\r\n\r\nfunc min(i, j int) int {\r\n    if i < j {\r\n        return i\r\n    }\r\n    return j\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串s的长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838160036","body":"### 思路\r\n\r\n两端遍历\r\n1. 从前往后，res[curIndex] = curIndex - newTargetIndex\r\n2. 从后往前，res[curIndex] = min(res[curIndex], newTargetIndex-curIndex)\r\n其中，newTargetIndex为目标字符最新出现索引位置\r\n\r\n### 代码\r\n\r\n\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    res := make([]int, len(s))\r\n    // 1<=s.length<=10000, targetIndex-10000<0, 所以应该设置targetIndex为-10000\r\n    targetIndex := -10000\r\n    for i := 0; i < len(s); i++ {\r\n        if s[i] == c {\r\n            targetIndex = i\r\n        }\r\n        res[i] = i - targetIndex\r\n    }\r\n\r\n    // 1<=s.length<=10000, targetIndex-10000>10000, 所以应该设置targetIndex为20000\r\n    targetIndex = 20000 \r\n    for i := len(s)-1; i >= 0; i-- {\r\n        if s[i] == c {\r\n            targetIndex = i\r\n        }\r\n        res[i] = min(res[i], targetIndex - i)\r\n    }\r\n    return res\r\n}\r\n\r\nfunc min(i, j int) int {\r\n    if i < j {\r\n        return i\r\n    }\r\n    return j\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串s的长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840640798","body":"### 思路\r\n1. 建立栈，遍历字符串往栈内添加字符\r\n2. 如果字符为 ] , 出栈直到找到 [ ,再取数字, 处理字符放回栈中\r\n3. 最后栈即为结果字符串\r\n\r\n### 代码\r\n\r\n```go\r\nfunc decodeString(s string) string {\r\n\tres := Stack{}\r\n\tsByte := []byte(s)\r\n\r\n\tfor _, v := range sByte {\r\n\t\tif v != ']' {\r\n\t\t\tres.Push(v)\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\trepeatStr := \"\"\r\n\t\trepeatCount := \"\"\r\n\t\tfor !res.Empty() && res.Top() != '[' {\r\n\t\t\trepeatStr = string(res.Pop()) + repeatStr\r\n\t\t}\r\n\r\n\t\tres.Pop()\r\n\r\n\t\tfor !res.Empty() && res.Top() >= '0' && res.Top() <= '9' {\r\n\t\t\trepeatCount = string(res.Pop()) + repeatCount\r\n\t\t}\r\n\t\tcount, _ := strconv.Atoi(repeatCount)\r\n\t\ttmp := \"\"\r\n\t\tfor count > 0 {\r\n\t\t\ttmp += repeatStr\r\n\t\t\tcount--\r\n\t\t}\r\n\r\n\t\tres.PushSlice([]byte(tmp))\r\n\t}\r\n\treturn string(res.Val())\r\n}\r\n\r\ntype Stack struct {\r\n\tval []byte\r\n}\r\n\r\nfunc (s *Stack) Val() []byte {\r\n\treturn s.val\r\n}\r\n\r\nfunc (s *Stack) PushSlice(b []byte) {\r\n\ts.val = append(s.val, b...)\r\n}\r\n\r\nfunc (s *Stack) Push(b byte) {\r\n\ts.val = append(s.val, b)\r\n}\r\n\r\nfunc (s *Stack) Pop() byte {\r\n\tb := s.val[len(s.val)-1]\r\n\ts.val = s.val[:len(s.val)-1]\r\n\treturn b\r\n}\r\n\r\nfunc (s *Stack) Top() byte {\r\n\treturn s.val[len(s.val)-1]\r\n}\r\n\r\nfunc (s *Stack) Empty() bool {\r\n\treturn len(s.val) == 0\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 为解码后 s 的长度\r\n- 空间复杂度：O(N)，其中 N 为解码后 s 的长度"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yourspeace":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836797246","body":"语言：Java\r\n\r\n思路：leetcode官方题解的思路：数组和数字最后一位从后往前，对应的位相加，如果产生进位，数字k加1，这样就会在下一位中运 算了，最后如果数字k的长度大于数组的长度，那么就把数字k剩下的进行取余取整操作，加到目标数组中，最后数组反转得到结果\r\n\r\n代码：\r\n\r\n`class Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        // 初始化参数\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = A.length;\r\n\r\n        // 1. 从后往前逐位相加\r\n        for(int i = n - 1;i >= 0;i--){\r\n            // 1.1 逐位相加\r\n            int sum = A[i] + K % 10;         // 每次重置sum\r\n            K /= 10;    \r\n            // 1.2 处理两位相加 进位的情况\r\n            if(sum >= 10){\r\n                K++;                        // 进位到K的末尾\r\n                sum -= 10;                  // 进位清掉\r\n            }\r\n            // 1.2 当前相加的结果 添加到结果集\r\n            res.add(sum);\r\n        }\r\n\r\n        // 2. K的数字长度大于数组的数字长度\r\n        for(;K > 0;K /= 10){                // 每次K左移一位\r\n            res.add(K % 10);                // 添加到结果集\r\n        }\r\n\r\n        // 3. 将结果集翻转即是所求答案\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}`\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838563251","body":"**语言：** Java\r\n\r\n**leetcode官方题解思想：**\r\n\r\n从前往后遍历一遍，记住各个位置离上一个C字符的距离，再从后往前遍历一遍，同样记住离上一个C字符的距离，最后比较两次遍历各个位置离C字符的距离，较小的那个被选用做为最终距离\r\n\r\n**复杂度：**\r\n\r\n时间：O(N)\r\n\r\n空间：O(N) \r\n\r\n**代码：**\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838563251","body":"**语言：** Java\r\n\r\n**leetcode官方题解思想：**\r\n\r\n从前往后遍历一遍，记住各个位置离上一个C字符的距离，再从后往前遍历一遍，同样记住离上一个C字符的距离，最后比较两次遍历各个位置离C字符的距离，较小的那个被选用做为最终距离\r\n\r\n**复杂度：**\r\n\r\n时间：O(N)\r\n\r\n空间：O(N) \r\n\r\n**代码：**\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"paopaohua":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836797976","body":"思路：\n  1、从数组最后一位向前遍历，进行相加，考虑进位操作\n  2、考虑进位超出当前长度的操作\n  3、输出结果进行翻转 collections.reverse（res）\n代码：\n```\npublic List<Integer> addToArrayForm(int[] A, int K) {\n    List<Integer> res = new ArrayList<>();\n    int carry = 0;\n    int l1 = A.length - 1;\n    while (l1 >= 0 || K != 0) {\n        int x = l1 < 0 ? 0 : A[l1];\n        int y = K == 0 ? 0 : K % 10;\n\n        int sum = x + y + carry;\n        res.add(sum % 10);\n        carry = sum / 10;\n\n        l1--;\n        K = K / 10;\n    }\n    if (carry != 0) res.add(carry);\n    Collections.reverse(res);\n    return res;\n}\n\n```\n复杂度分析：（不懂）\n    时间复杂度：Ｏ（n）\n    空间复杂度：Ｏ（n）\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838694006","body":"思路：\n   从左向右遍历，记录字符c出现的位置p，距离为i-p\n   从右向左遍历，记录字符c出现的位置p，距离为p-i\n   得较小值\n代码：\n```\n\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;//防止越界\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);//判断最小值\n        }\n\n        return ans;\n    }\n}\n\n\n```\n复杂度分析：\n   时间复杂度：Ｏ（n）\n   空间复杂度：Ｏ（n）数组 ans 的大小"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838694006","body":"思路：\n   从左向右遍历，记录字符c出现的位置p，距离为i-p\n   从右向左遍历，记录字符c出现的位置p，距离为p-i\n   得较小值\n代码：\n```\n\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;//防止越界\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);//判断最小值\n        }\n\n        return ans;\n    }\n}\n\n\n```\n复杂度分析：\n   时间复杂度：Ｏ（n）\n   空间复杂度：Ｏ（n）数组 ans 的大小"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840632691","body":"#\t思路（官方解法）\n\t1.将括号嵌套转化成 用栈维护 \n\t2.遍历栈 \n当前字符为数位，解析数字并进栈\n字母或者左括号，直接进\n右括号，开始出栈直到左括号出栈，反转拼接为字符串取栈顶数字\n#\t代码 \n```\n\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                // 获取一个数字并进栈\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                // 左括号出栈\n                stk.removeLast();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                // 构造字符串\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                // 将构造好的字符串入栈\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n\n\n```\n\n#\t复杂度分析\n*\t时间复杂度：Ｏ（s） 字符串长度为s\n*\t空间复杂度：Ｏ（s）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Auto-SK":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836800746","body":"## 方法一：逐位相加\r\n\r\n**当前位 = (A 的当前位 + B 的当前位 + 进位 carry) % 10**\r\n\r\n### 算法流程\r\n\r\n```\r\nwhile A 没完 or B 没完\r\n\tA 的当前位\r\n\tB 的当前位 (B % 10)\r\n\r\n\t和 = A 的当前位 + B 的当前位 + 进位 carry\r\n\t进位 = 和 // 10\r\n\r\n\t当前结果位 = 和 % 10\r\n判断还有进位吗\r\n反转数组\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(max(len(num), len(k)))\r\n* 空间复杂度：O(1)\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = len(num) - 1\r\n        sum = 0\r\n        carry = 0\r\n        res = []\r\n        while i >= 0 or k != 0:\r\n            x = num[i] if i >= 0 else 0\r\n            y = k % 10 if k != 0 else 0\r\n            sum = x + y + carry\r\n            carry = sum // 10\r\n\r\n            i -= 1\r\n            k //= 10\r\n\r\n            res.append(sum % 10)\r\n        \r\n        if carry != 0:\r\n            res.append(carry)\r\n        return res[::-1]\r\n```\r\n\r\n\r\n## 方法二：转换+逐位取出\r\n\r\n### 算法流程\r\n\r\n1. 逐位取 num，将其转为字符串\r\n2. 将 num 字符串转为整数\r\n3. 求出 num 和 k 之和 sum\r\n4. 逐位取 sum % 10，sum = sum // 10\r\n5. 反转，res[::-1]\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)\r\n* 空间复杂度：O(1)\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        x = ''\r\n        for i in num:\r\n            x += str(i)\r\n        x = int(x)\r\n        res = x + k\r\n        if res == 0:\r\n            return [0]\r\n        ans = []\r\n        while res != 0:\r\n            ans.append(res % 10)\r\n            res = res // 10\r\n        return ans[::-1]\r\n```\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838717787","body":"## 方法一：两次扫描\r\n\r\n### 算法流程\r\n\r\n从左向右遍历，记录上一个字符 `c` 出现的位置 `prev`，那么答案就是 `i - prev`。\r\n\r\n从右向左遍历，记录上一个字符 `c` 出现的位置 `prev`，那么答案就是 `prev - i`。\r\n\r\n这两个值取最小就是答案。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)，s 数组的长度。\r\n* 空间复杂度：O(n)，ans 数组的大小。\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        prev = float('-inf')\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans.append(i - prev)\r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838717787","body":"## 方法一：两次扫描\r\n\r\n### 算法流程\r\n\r\n从左向右遍历，记录上一个字符 `c` 出现的位置 `prev`，那么答案就是 `i - prev`。\r\n\r\n从右向左遍历，记录上一个字符 `c` 出现的位置 `prev`，那么答案就是 `prev - i`。\r\n\r\n这两个值取最小就是答案。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)，s 数组的长度。\r\n* 空间复杂度：O(n)，ans 数组的大小。\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        prev = float('-inf')\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans.append(i - prev)\r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840627801","body":"## 方法一：辅助栈法\r\n\r\n本题难点在于括号内嵌套括号，需要**从内向外**生成与拼接字符串，这与栈的**先入后出**特性相应。\r\n\r\n### 算法流程\r\n\r\n1. 构建辅助栈`stack`，遍历字符串`s`中每个字符`c`；\r\n   * 当`c`为数字时，将数字字符转换为数字`multi`，用于后续倍数计算；\r\n   * 当`c`为字母时，在`res`尾部添加`c`；\r\n   * 当`c`为`[`时，将当前的`multi`和`res`入栈，并分别置空置0：\r\n     * 记录此`[`前的临时结果`res`至栈，用于发现对应`]`后的拼接操作；\r\n     * 记录此`[`前的倍数`multi`至栈，用于发现对应`]`后，获取`multi * [...]`字符串；\r\n     * 进入到新`[`后，`res`和`multi`重新记录。\r\n   * 当`c`为`]`时，`stack`出栈，拼接字符串`res=last_res + cur_multi * res`，其中：\r\n       * `last_res`是上个`[`到当前`]`的字符串，例如`3[a2[c]]`中的`a`；\r\n       * `cur_multi`是当前`[`到`]`内字符串的重复倍数，例如`3[a2[c]]`中的`2`；\r\n2. 返回字符串`res`。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(N)，一次遍历`s`；\r\n* 空间复杂度：辅助栈在极端情况下需要线性空间，例如`2[2[2[a]]]`。\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], '', 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = '', 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif c.isdigit():\r\n                multi = multi * 10 + int(c)\r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuanaxuan":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836802914","body":"### 思路\r\n\r\n#### 模板\r\n```\r\n当前位=0\r\nwhile ( A 没完 || B 没完)\r\n    //根据下标找到\r\n    A 的当前位\r\n    B 的当前位\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗,进位不为 0 ,加在目标值前面。\r\n```\r\n#### 注意点\r\n1. 循环结束条件\r\n2. 当前位的计算,注意防空\r\n3. 和的计算,carry初始值为0\r\n4. js中取整/后要转整数\r\n  \r\n### 代码\r\n\r\n```js\r\nvar addToArrayForm = function (num, k) {\r\n  let i = num.length - 1,\r\n    carry = 0,\r\n    arr = [];\r\n  while (i >= 0 || k > 0) {\r\n    let n = i>=0 ? num[i] : 0;\r\n    let m = k != 0 ? k % 10 : 0;\r\n    let sum = n + m + carry;\r\n    carry = parseInt(sum / 10);\r\n    arr.unshift(sum % 10);\r\n    i--;\r\n    k = parseInt(k / 10);\r\n  }\r\n  if (carry) arr.unshift(1);\r\n  return arr;\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度:`O(n)` \r\n空间复杂度:`O(n)`\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838288784","body":"### 思路\r\n用变量prevC记录c的下标,初始值为无穷大,当s[i]=c时更新preC=i\r\n遍历字符串,将非c的字符串存入临时栈中,当遇到c时,依次计算栈中字符串到当前c以及prevC的最小距离,注意针对C非S最后一个字符串的情况,需要再清空下临时栈\r\n### 复杂度\r\n时间复杂度：$O(N)$, N 为S数组长度。\r\n空间复杂度：$O(N)$, N 为S数组长度。\r\n### 代码\r\n```\r\nvar shortestToChar = function (S, C) {\r\n  let arr = [],\r\n    prevC = -Infinity,\r\n    map = [];\r\n  //清空暂存栈\r\n  function clear(prev, next = Infinity) {\r\n    for (const targetIndex of map) {\r\n      const Index = Math.min(Math.abs(targetIndex - prev), Math.abs(targetIndex - next));\r\n      arr.push(Index);\r\n    }\r\n    map = [];\r\n  }\r\n  for (let index = 0; index < S.length; index++) {\r\n    const ele = S[index];\r\n    if (ele === C) {\r\n      clear(prevC, index);\r\n      arr.push(0);\r\n      prevC = index;\r\n    } else {\r\n      map.push(index);\r\n    }\r\n  }\r\n  if (map.length > 0) {\r\n    clear(prevC);\r\n  }\r\n  return arr;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838288784","body":"### 思路\r\n用变量prevC记录c的下标,初始值为无穷大,当s[i]=c时更新preC=i\r\n遍历字符串,将非c的字符串存入临时栈中,当遇到c时,依次计算栈中字符串到当前c以及prevC的最小距离,注意针对C非S最后一个字符串的情况,需要再清空下临时栈\r\n### 复杂度\r\n时间复杂度：$O(N)$, N 为S数组长度。\r\n空间复杂度：$O(N)$, N 为S数组长度。\r\n### 代码\r\n```\r\nvar shortestToChar = function (S, C) {\r\n  let arr = [],\r\n    prevC = -Infinity,\r\n    map = [];\r\n  //清空暂存栈\r\n  function clear(prev, next = Infinity) {\r\n    for (const targetIndex of map) {\r\n      const Index = Math.min(Math.abs(targetIndex - prev), Math.abs(targetIndex - next));\r\n      arr.push(Index);\r\n    }\r\n    map = [];\r\n  }\r\n  for (let index = 0; index < S.length; index++) {\r\n    const ele = S[index];\r\n    if (ele === C) {\r\n      clear(prevC, index);\r\n      arr.push(0);\r\n      prevC = index;\r\n    } else {\r\n      map.push(index);\r\n    }\r\n  }\r\n  if (map.length > 0) {\r\n    clear(prevC);\r\n  }\r\n  return arr;\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caoyuyuyu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836813414","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 思路\r\n\r\n-  最终结果由数组变成的数值和数值相加，再转化为数组\r\n-  所以解题过程完全按照结果的生成过程for循环实现\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```Python3\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        a=''\r\n        b=[]\r\n        for i in num:\r\n            a=a+str(i)\r\n        re=str(int(a)+k)\r\n        for j in re:\r\n            b.append(int(j))\r\n        return b\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 还不会分析复杂度,后面补上相关知识～\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838728328","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n\r\n-  题目是求每个字符串到最近到给定字符的距离，\r\n- 逆向思维，先求出给定字符到所有字符的距离，再求出其中的最小值\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        a=[]\r\n        b=[]\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                a.append(i)\r\n\r\n        for i in range(len(s)):\r\n            re=len(s)\r\n            for j in a:\r\n                re=min(re,abs(int(i)-int(j)))\r\n            b.append(re)\r\n        return b\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838728328","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n\r\n-  题目是求每个字符串到最近到给定字符的距离，\r\n- 逆向思维，先求出给定字符到所有字符的距离，再求出其中的最小值\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        a=[]\r\n        b=[]\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                a.append(i)\r\n\r\n        for i in range(len(s)):\r\n            re=len(s)\r\n            for j in a:\r\n                re=min(re,abs(int(i)-int(j)))\r\n            b.append(re)\r\n        return b\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"keepchasing":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836818313","body":"### 思路\r\n+ 遍历数组与K的对应位相加，并记录进位carryNum，carryNum默认值为0\r\n+ 判断K的位数与A对应的数字的位数，如果K的位数更大 取出前边的数据依次加到A中\r\n### 语言：\r\n javascript\r\n\r\n### 复杂度分析\r\n+ 时间复杂度： O(N)\r\n+ 空间复杂度：O(1)\r\n```\r\n/**\r\n * @param {number[]} A\r\n * @param {number} K\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = (A, K) => {\r\n    let len = A.length // 数组A的长度\r\n    let carryNum = 0 // 进位\r\n    A.forEach((item, index) => {\r\n        let curNum = Math.floor(K % Math.pow(10, index + 1) / Math.pow(10, index))\r\n        let tmpCurNum = (curNum + A[len - index -1 ] + carryNum)\r\n        A[len - index - 1] = tmpCurNum % 10\r\n        carryNum = Math.floor(tmpCurNum / 10)\r\n    })\r\n    let kStrLen = (K + '').length\r\n    // 如果K的位数大于A对应的数字的位数\r\n    if (kStrLen >= len) {\r\n        let tmpK = Math.floor(K / Math.pow(10, len)) + carryNum\r\n        let tmpKStrLen = (tmpK + '').length\r\n        for (let i = 0; i < tmpKStrLen; i ++) {\r\n            let tmpNum = Math.floor(tmpK % Math.pow(10, i + 1) / Math.pow(10, i))\r\n            i === tmpKStrLen - 1 && tmpNum === 0 ? '' : A.unshift(tmpNum)\r\n        }\r\n    } else {\r\n        carryNum ? A.unshift(carryNum) : ''\r\n    }\r\n    return A\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838608422","body":"### 思路分析\r\n+ 从左到右遍历数组， res存储当前字符到左边数下标最大的目标C的距离\r\n+ 从右到左遍历，比较下标i对应的字符到从右边数下标最小的目标C的距离与res[i]的大小，取最小值\r\n\r\n### 语言\r\n+ javascript\r\n### 复杂度分析\r\n+ 时间复杂度：O(n)\r\n+ 空间复杂度：O(n)\r\n```\r\nlet S = \"loveleetcode\", C = 'e'\r\nconst shortestToChar = (S, C) => {\r\n    let res = []\r\n    let sLen = S.length\r\n    let leftMaxIndex = -10000\r\n    let rightMinIndex = 20000\r\n    for(let i = 0; i < sLen; i++) {\r\n        if(S[i] === C) {\r\n            leftMaxIndex = i\r\n        }\r\n        res[i] = i - leftMaxIndex\r\n    }\r\n    for(let i = sLen - 1; i >= 0; i--) {\r\n        if(S[i] === C) {\r\n            rightMinIndex = i\r\n        }\r\n        res[i] = Math.min(rightMinIndex - i, res[i])\r\n    }\r\n    return res\r\n}\r\nconsole.log(shortestToChar(S, C))\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838608422","body":"### 思路分析\r\n+ 从左到右遍历数组， res存储当前字符到左边数下标最大的目标C的距离\r\n+ 从右到左遍历，比较下标i对应的字符到从右边数下标最小的目标C的距离与res[i]的大小，取最小值\r\n\r\n### 语言\r\n+ javascript\r\n### 复杂度分析\r\n+ 时间复杂度：O(n)\r\n+ 空间复杂度：O(n)\r\n```\r\nlet S = \"loveleetcode\", C = 'e'\r\nconst shortestToChar = (S, C) => {\r\n    let res = []\r\n    let sLen = S.length\r\n    let leftMaxIndex = -10000\r\n    let rightMinIndex = 20000\r\n    for(let i = 0; i < sLen; i++) {\r\n        if(S[i] === C) {\r\n            leftMaxIndex = i\r\n        }\r\n        res[i] = i - leftMaxIndex\r\n    }\r\n    for(let i = sLen - 1; i >= 0; i--) {\r\n        if(S[i] === C) {\r\n            rightMinIndex = i\r\n        }\r\n        res[i] = Math.min(rightMinIndex - i, res[i])\r\n    }\r\n    return res\r\n}\r\nconsole.log(shortestToChar(S, C))\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840650185","body":"### 语言\r\n+ javascript\r\n### 思路分析\r\n+ 将字符串每个字符从前到后依次压入数组模拟的栈中\r\n+ 判断下一个字符串为’]‘时操作出栈 ，直到下一个’[‘，将这个中间出栈的元素存入一个变量\r\n+ 找到’[‘之后再找出它之前的数字times，然后重复步骤2中的变量times次，然后将它压入栈\r\n+ 最后返回这个栈中所有元素拼起来的字符串\r\n\r\n### 复杂度分析\r\n+ 空间复杂度： O(N)\r\n+ 时间复杂度：\r\n```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nconst decodeString = (s) => {\r\n    let stack = []\r\n    let sLen = s.length\r\n    for (let i = 0; i < sLen; i++) {\r\n        if (s[i] !== ']') {\r\n            stack.push(s[i])\r\n        } else {\r\n            let times = 0\r\n            let tmpItem = ''\r\n            for (let m = stack.length - 1; m >= 0; m--) {\r\n                if (stack[m] === '[') {\r\n                    stack.pop()\r\n                    // 取出数字\r\n                    let num = 0\r\n                    for (let j = m - 1; j >= 0; j--) {\r\n                        if (/\\d/.test(stack[j])) {\r\n                            times += Number(stack.pop())*Math.pow(10, num)\r\n                            num ++\r\n                        } else {\r\n                            break\r\n                        }\r\n                    }\r\n                    break\r\n                } else {\r\n                    tmpItem = `${stack.pop()}${tmpItem}`\r\n                }\r\n            }\r\n            if (i) {\r\n                stack.push(tmpItem.repeat(times))\r\n            }\r\n        }\r\n    }\r\n    return stack.join('')\r\n}\r\nconst s = \"3[a]2[bc]\"\r\nconsole.log(decodeString(s))\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"CurrrryChen":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836821360","body":"**思路**\r\n利用js的BigInt累加\r\n\r\n**代码**\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    return (BigInt(num.join(''))+BigInt(k)).toString().split('').map(Number);\r\n};\r\n```\r\n\r\n**复杂度**\r\n时间复杂度:O(n)\r\n空间复杂度:O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"renziao":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836824996","body":"思路：leetcode官方题解的思路：数组和数字最后一位从后往前，对应的位相加，如果产生进位，数字k加1，这样就会在下一位中运 算了，最后如果数字k的长度大于数组的长度，那么就把数字k剩下的进行取余取整操作，加到目标数组中，最后数组反转得到结果\r\n\r\n代码：\r\n\r\npublic List addToArrayForm(int[] A, int K) {\r\n// 初始化参数\r\nList res = new ArrayList();\r\nint n = A.length;\r\n\r\n    // 1. 从后往前逐位相加\r\n    for(int i = n - 1;i >= 0;i--){\r\n        // 1.1 逐位相加\r\n        int sum = A[i] + K % 10;         // 每次重置sum\r\n        K /= 10;    \r\n        // 1.2 处理两位相加 进位的情况\r\n        if(sum >= 10){\r\n            K++;                        // 进位到K的末尾\r\n            sum -= 10;                  // 进位清掉\r\n        }\r\n        // 1.2 当前相加的结果 添加到结果集\r\n        res.add(sum);\r\n    }\r\n\r\n    // 2. K的数字长度大于数组的数字长度\r\n    for(;K > 0;K /= 10){                // 每次K左移一位\r\n        res.add(K % 10);                // 添加到结果集\r\n    }\r\n\r\n    // 3. 将结果集翻转即是所求答案\r\n    Collections.reverse(res);\r\n    return res;"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Nbambi":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836826525","body":"思路\r\n- 遍历数组num，用k乘当前位的10的幂次，累加结果\r\n\r\n代码\r\n```\r\nvar addToArrayForm = function (num, k) {\r\n    let len = num.length - 1;\r\n    let result = 0;\r\n    for(let i=0; i<num.length; i++) {\r\n        result = result +num[i] * (Math.pow(10, len - i))\r\n    }\r\n    return result + k;\r\n};\r\n```\r\n\r\n复杂度\r\n\r\n- 时间复杂度O(n) 空间复杂度O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837853699","body":"- 思路\r\n中心扩展法\r\n\r\n- 代码：JS\r\n```\r\n/**\r\n * 中心扩展法\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n\r\n    let n = s.length;\r\n    let answer = Array(n).fill(0);\r\n\r\n    for (let i = 0; i < n; i++) {\r\n        // 刚好匹配 不处理\r\n        if (s[i] === c) continue;\r\n        // 定义向左向右两个指针, 初始化 最短距离=Infinity(因为数组默认初始值是0)\r\n        let l = i, r = i, shortest = Infinity;\r\n        // 向左找\r\n        while (l >= 0) {\r\n            if (s[--l] === c) {\r\n                shortest = Math.min(i - l, shortest); //如果left找到了先赋值\r\n            }\r\n        }\r\n        // 向右找\r\n        while (r <= n) {\r\n            if (s[++r] === c) {\r\n                shortest = Math.min(r - i, shortest); //如果left找到了, 会与之比较, 更小就会替换掉\r\n            }\r\n        }\r\n        answer[i] = shortest;\r\n    }\r\n    return answer;\r\n};\r\n```\r\n\r\n- 复杂度\r\n时间复杂度O(n2) 空间复杂度O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837853699","body":"- 思路\r\n中心扩展法\r\n\r\n- 代码：JS\r\n```\r\n/**\r\n * 中心扩展法\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n\r\n    let n = s.length;\r\n    let answer = Array(n).fill(0);\r\n\r\n    for (let i = 0; i < n; i++) {\r\n        // 刚好匹配 不处理\r\n        if (s[i] === c) continue;\r\n        // 定义向左向右两个指针, 初始化 最短距离=Infinity(因为数组默认初始值是0)\r\n        let l = i, r = i, shortest = Infinity;\r\n        // 向左找\r\n        while (l >= 0) {\r\n            if (s[--l] === c) {\r\n                shortest = Math.min(i - l, shortest); //如果left找到了先赋值\r\n            }\r\n        }\r\n        // 向右找\r\n        while (r <= n) {\r\n            if (s[++r] === c) {\r\n                shortest = Math.min(r - i, shortest); //如果left找到了, 会与之比较, 更小就会替换掉\r\n            }\r\n        }\r\n        answer[i] = shortest;\r\n    }\r\n    return answer;\r\n};\r\n```\r\n\r\n- 复杂度\r\n时间复杂度O(n2) 空间复杂度O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AmuroPeng":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836832176","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n = num.length;\r\n        List<Integer> ans = new ArrayList<Integer>();\r\n        for (int i = n - 1; i >=0; i--) {\r\n            int digit = num[i] + k % 10; // for each digit\r\n            k /= 10;\r\n            if (digit >= 10) {\r\n                digit -= 10;\r\n                k++;\r\n            }\r\n            ans.add(digit);\r\n        }\r\n        // if the length of k is more than num\r\n        while (k >= 10){\r\n            ans.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        if (k != 0) {\r\n            ans.add(k);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838810213","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n正向遇到第一个c之前，ans[i]设为无限大\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] ans = new int[len];\r\n        int count = -1;\r\n        // sequentially traverse\r\n        for (int i = 0; i < len; i++) {\r\n            if (s.charAt(i) == c) {\r\n                count = 0;\r\n                ans[i] = 0;\r\n            }else if (count == -1) ans[i] = Integer.MAX_VALUE;\r\n            else {\r\n                count += 1;\r\n                ans[i] = count;\r\n            }\r\n        }\r\n        // reverse\r\n        count = -1;\r\n        for (int i = len - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                count = 0;\r\n            } else if (count == -1) {\r\n                continue;\r\n            } else {\r\n                count += 1;\r\n                ans[i] = Math.min(ans[i], count);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christ36":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836832193","body":"class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n复杂度分析\r\n\r\n时间复杂度：O(max(n,log k))，其中 n 为数组的长度。\r\n\r\n空间复杂度：O(1)。除了返回值以外，使用的空间为常数。\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838755307","body":"public class mindistant {\r\n    public int[] addToArrayForm(String S, char C) {\r\n        int N = S.length();\r\n        int[] res = new int[N];\r\n        for(int i = 0; i <N; i++) {\r\n            if (S.charAt(i) == C) continue;\r\n            int left = i;\r\n            int right = i;\r\n            int dist = 0;\r\n            while (left >= 0 || right <= S.length() - 1) {\r\n                if (S.charAt(left) == C) {\r\n                    dist = i - left;\r\n                    break;\r\n                }\r\n                if (S.charAt(right) == C) {\r\n                    dist = right - i;\r\n                    break;\r\n                }\r\n                if (left > 0) left--;\r\n                if (right < S.length() - 1) right++;\r\n            }\r\n            res[i] = dist;\r\n        }\r\n        return res;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838755307","body":"public class mindistant {\r\n    public int[] addToArrayForm(String S, char C) {\r\n        int N = S.length();\r\n        int[] res = new int[N];\r\n        for(int i = 0; i <N; i++) {\r\n            if (S.charAt(i) == C) continue;\r\n            int left = i;\r\n            int right = i;\r\n            int dist = 0;\r\n            while (left >= 0 || right <= S.length() - 1) {\r\n                if (S.charAt(left) == C) {\r\n                    dist = i - left;\r\n                    break;\r\n                }\r\n                if (S.charAt(right) == C) {\r\n                    dist = right - i;\r\n                    break;\r\n                }\r\n                if (left > 0) left--;\r\n                if (right < S.length() - 1) right++;\r\n            }\r\n            res[i] = dist;\r\n        }\r\n        return res;\r\n    }\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fangyinghua":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836833635","body":"思路:\r\n\r\n* 从右往左 依次遍历 [十进一]\r\n\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const len= num.length;\r\n\r\n   //需要处理 两者长度不一，可能数组的个数小于k的个数\r\n    for (let i = len - 1; (i >= 0 || k > 0); (--i, k = parseInt(k / 10))) {\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```\r\n\r\n复杂度\r\n\r\n* 时间复杂度O(Max(n,k)) \r\n* 空间复杂度O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838753017","body":"思路：\r\n从两个方向扫描，在相同位置进行比较。\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\n var shortestToChar = function (s, c) {\r\n        let N = s.length;\r\n        let ans = new Array(N);\r\n        let prev=Number.MIN_SAFE_INTEGER/2;\r\n        for (let i = 0; i < N; ++i) {\r\n            if (s.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev =Number.MAX_SAFE_INTEGER/2;\r\n        for (let i = N-1; i >= 0; --i) {\r\n            if (s.charAt(i) == c) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n   };\r\n```\r\n复杂度分析\r\n  * 时间复杂度:O(N);\r\n  * 空间复杂度:O(N);"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838753017","body":"思路：\r\n从两个方向扫描，在相同位置进行比较。\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\n var shortestToChar = function (s, c) {\r\n        let N = s.length;\r\n        let ans = new Array(N);\r\n        let prev=Number.MIN_SAFE_INTEGER/2;\r\n        for (let i = 0; i < N; ++i) {\r\n            if (s.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev =Number.MAX_SAFE_INTEGER/2;\r\n        for (let i = N-1; i >= 0; --i) {\r\n            if (s.charAt(i) == c) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n   };\r\n```\r\n复杂度分析\r\n  * 时间复杂度:O(N);\r\n  * 空间复杂度:O(N);"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840594127","body":"\r\n```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let numStack = [];        \r\n    let strStack = [];        \r\n    let num = 0;              \r\n    let result = '';         \r\n    for (const char of s) {   \r\n        if (isInteger(char)) { \r\n            num =num * 10 + Number(char); \r\n        } else if (char == '[') { \r\n            strStack.push(result);\r\n            result = '';          \r\n            numStack.push(num);   \r\n            num = 0;              \r\n        } else if (char == ']') {  \r\n            let repeatTimes = numStack.pop();\r\n            result = strStack.pop() + result.repeat(repeatTimes); \r\n        } else {                   \r\n            result += char;       \r\n        }\r\n    }\r\n    return result;\r\n   \r\n};\r\n\r\nfunction isInteger(obj) {\r\n    return /^[0-9]$/.test(obj);\r\n}\r\n```\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Gjts":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836834532","body":"算法流程\r\n\r\n    获取数组的长度\r\n    将 需要添加的targe赋值给sum\r\n    求出 num 和 k 之和 sum\r\n    逐位取 sum % 10，sum = sum // 10\r\n    反转，res[::-1]\r\n\r\n复杂度分析\r\n\r\n    时间复杂度：O(n)\r\n    空间复杂度：O(n)\r\n\r\n代码\r\n    \r\n    语言支持：c#\r\n    public IList<int> AddToArrayForm(int[] num, int k) {\r\n          int i = num.Length - 1;\r\n          int sum = k;\r\n          List<int> arr = new List<int>();\r\n          while(i >= 0 || sum > 0){\r\n              if(i >= 0){\r\n                  sum += num[i];\r\n              }\r\n              arr.Add(sum % 10);\r\n              sum /= 10;\r\n              i--;\r\n          }\r\n          int[] arr1 = arr.ToArray();\r\n          Array.Reverse(arr1);\r\n          return arr1;\r\n      }：\r\n  "},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838023165","body":"算法流程:\r\n\r\n    获取字符的长度\r\n    定义一个未知数int prev右移一位 int.MinValue>>1 int.MaxValue>>1 \r\n    左移、右移一位是为了定义一个边界值 0-最小值有问题 不会变成一个正整数\r\n    把字符串转换成数组char 判断和target相等 就取代那个未知数prev默认的位置\r\n    二分遍历查询数组，第一轮找到左边离target最近的数\r\n    ，第二轮找到右边离target最近的数，判断谁小把谁放到数组中\r\n\r\n复杂度分析\r\n\r\n    时间复杂度：O(n) 循环遍历数组的长度\r\n    空间复杂度：O(n) 创建了一个数组  复杂度分析不太懂 特别是空间复杂度\r\n\r\n语言支持：c#\r\n\r\n    public int[] ShortestToChar(string s, char c) {\r\n        int N = s.Length;\r\n        var isok = s.ToCharArray();\r\n        int[] ans = new int[N];\r\n        var prev = int.MinValue >> 1;\r\n        for (int i = 0; i < s.Length; i++)\r\n        {\r\n            if (isok[i] == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = int.MaxValue >> 1;\r\n        for (int i = N - 1; i >= 0; --i)\r\n        {\r\n            if (isok[i] == c) prev = i;\r\n            ans[i] = Math.Min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838023165","body":"算法流程:\r\n\r\n    获取字符的长度\r\n    定义一个未知数int prev右移一位 int.MinValue>>1 int.MaxValue>>1 \r\n    左移、右移一位是为了定义一个边界值 0-最小值有问题 不会变成一个正整数\r\n    把字符串转换成数组char 判断和target相等 就取代那个未知数prev默认的位置\r\n    二分遍历查询数组，第一轮找到左边离target最近的数\r\n    ，第二轮找到右边离target最近的数，判断谁小把谁放到数组中\r\n\r\n复杂度分析\r\n\r\n    时间复杂度：O(n) 循环遍历数组的长度\r\n    空间复杂度：O(n) 创建了一个数组  复杂度分析不太懂 特别是空间复杂度\r\n\r\n语言支持：c#\r\n\r\n    public int[] ShortestToChar(string s, char c) {\r\n        int N = s.Length;\r\n        var isok = s.ToCharArray();\r\n        int[] ans = new int[N];\r\n        var prev = int.MinValue >> 1;\r\n        for (int i = 0; i < s.Length; i++)\r\n        {\r\n            if (isok[i] == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = int.MaxValue >> 1;\r\n        for (int i = N - 1; i >= 0; --i)\r\n        {\r\n            if (isok[i] == c) prev = i;\r\n            ans[i] = Math.Min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"doubelejjyy":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836835885","body":"**思路:**\r\n1.从低位开始加\r\n2.可能k的长度大于数组的长度,所以可能for循环结束了但是k没加完,所以最后用while\r\n3.list.add的顺序是队列所以list一开始的顺序是答案从低位到高位的顺序 所以要逆序一下\r\n**代码**\r\n\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new ArrayList<>();\r\n        int length = num.length;\r\n        int value;\r\n        for (int i = length-1; i >=0; i--) {\r\n            value = num[i]+k%10;\r\n            k/=10;\r\n            if(value>9){\r\n                value -=10;\r\n                k++;//进位\r\n            }\r\n            list.add(value);\r\n\r\n        }\r\n\r\n        while(k!=0)\r\n            list.add(k%10);\r\n            k/=10;\r\n        }\r\n\r\n        Collections.reverse(list);\r\n        return list;\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\n**时间复杂度O(n)**\r\n**空间复杂度O(n)**"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837883042","body":"**思路:**\r\n1.从左到右遍历只考虑每个字符和它左边的c的距离\r\n2.从右到左遍历只考虑每个字符和它右边的c的距离\r\n3.然后比较大小\r\n\r\n**代码**\r\nJava Code:\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        \r\n        int length = s.length();\r\n        int pre = Integer.MIN_VALUE / 2;//除2是为了防止 i-pre超过int的最大值\r\n        int[] answer = new int[length];\r\n        //1.先从左边往右找 计算每个字符和上一个c的距离是多少\r\n        for (int i = 0; i < length; i++) {\r\n\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n            answer[i] = i-pre;\r\n        }\r\n\r\n        //从右边往左找 每次计算当前字符和上一个c的距离是多少\r\n        pre = Integer.MAX_VALUE / 2;// \r\n        for (int i = length-1; i >=0; i--) {\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n\r\n            if(answer[i]<pre - i){\r\n\r\n            }else{\r\n                answer[i] = pre - i;\r\n            }\r\n        }\r\n\r\n        return answer;\r\n\r\n    }\r\n}\r\n```\r\n\r\n**时间复杂度O(n)**\r\n**空间复杂度O(1)**"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837883042","body":"**思路:**\r\n1.从左到右遍历只考虑每个字符和它左边的c的距离\r\n2.从右到左遍历只考虑每个字符和它右边的c的距离\r\n3.然后比较大小\r\n\r\n**代码**\r\nJava Code:\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        \r\n        int length = s.length();\r\n        int pre = Integer.MIN_VALUE / 2;//除2是为了防止 i-pre超过int的最大值\r\n        int[] answer = new int[length];\r\n        //1.先从左边往右找 计算每个字符和上一个c的距离是多少\r\n        for (int i = 0; i < length; i++) {\r\n\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n            answer[i] = i-pre;\r\n        }\r\n\r\n        //从右边往左找 每次计算当前字符和上一个c的距离是多少\r\n        pre = Integer.MAX_VALUE / 2;// \r\n        for (int i = length-1; i >=0; i--) {\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n\r\n            if(answer[i]<pre - i){\r\n\r\n            }else{\r\n                answer[i] = pre - i;\r\n            }\r\n        }\r\n\r\n        return answer;\r\n\r\n    }\r\n}\r\n```\r\n\r\n**时间复杂度O(n)**\r\n**空间复杂度O(1)**"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840642199","body":"思路：栈  和计算器那种题目类似\r\n```\r\nclass Solution {\r\n    char[] ch;\r\n    public String decodeString(String s) {\r\n        ch = s.toCharArray();\r\n        return dfs(0)[0];\r\n    }\r\n\r\n    public String[] dfs(int i){\r\n        StringBuilder res = new StringBuilder();\r\n        int num = 0;\r\n        while(i < ch.length){\r\n            if(ch[i] <= '9' && ch[i] >= '0'){\r\n                num = num * 10 + Integer.parseInt(\"\" + ch[i]);\r\n            }else if(ch[i] == '['){\r\n                String[] tmp = dfs(i + 1);\r\n                i = Integer.parseInt(tmp[0]);\r\n                while(num > 0){\r\n                    res.append(tmp[1]);\r\n                    num--;\r\n                }\r\n            }else if(ch[i] == ']'){\r\n                return new String[]{\"\" + i, res.toString()};\r\n            }else{\r\n                res.append(\"\" + ch[i]);\r\n            }\r\n            i++;\r\n        }\r\n        return new String[]{res.toString()};\r\n    }\r\n}\r\n```\r\n时间复杂读O(n)\r\n空间复杂度O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyyangrun":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836844742","body":"```\r\ndef addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n    res = []\r\n    i, carry = len(A) - 1, 0\r\n    while i >= 0 or K != 0:\r\n        x = A[i] if i >= 0 else 0\r\n        y = K % 10 if K != 0 else 0\r\n        sum = x + y + carry\r\n        res.append(sum % 10)\r\n        carry = sum // 10\r\n        i -= 1\r\n        K //= 10\r\n    if carry != 0: res.append(carry)\r\n    return res[::-1]\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tipshal":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836845741","body":"我是码盲，刚开始学Python，先说一下思路吧：\r\n1.把一维数组转换成整数\r\n  s=0\r\n  for i in A\r\n    s=s*10+i\r\n2.整体进行加法运算\r\n  s=s+k\r\n3.将计算结果转成字符串，用列表推导式把每一位字符转换成整数\r\n  s=str(s)\r\n  return[int(x) for x in s]"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838738222","body":"囧迫的我还没搞好Python，先抄了一段Java，大概意思看明白了，就是通过两次遍历，找出c的位置，进行与当前每个字符的比对\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] dist = new int[length];\r\n        \r\n        // 从左向右遍历\r\n        int loc = 10000;\r\n        for(int i=0;i<length;i++){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.abs(i-loc);\r\n        }\r\n\r\n        // 从右向左遍历\r\n        for(int i=length-1;i>=0;i--){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.min(dist[i],Math.abs(i-loc));\r\n        }\r\n\r\n        return dist;\r\n\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838738222","body":"囧迫的我还没搞好Python，先抄了一段Java，大概意思看明白了，就是通过两次遍历，找出c的位置，进行与当前每个字符的比对\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] dist = new int[length];\r\n        \r\n        // 从左向右遍历\r\n        int loc = 10000;\r\n        for(int i=0;i<length;i++){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.abs(i-loc);\r\n        }\r\n\r\n        // 从右向左遍历\r\n        for(int i=length-1;i>=0;i--){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.min(dist[i],Math.abs(i-loc));\r\n        }\r\n\r\n        return dist;\r\n\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840576685","body":"\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack=[] #空栈\r\n        flag = False #设置一个布尔型变量，初始值为假\r\n        for c in s[::-1]+\"/\": #返向循环\r\n            if c.isdigit(): #判断c是否为数字\r\n                flag = True #如果c为数字，flag变为真\r\n            if not c.isdigit() and flag:   #如果c不为数字（即字符）且flag为真\r\n                flag = False #flag为假           \r\n                temp = [] #临时空列表\r\n                while True: \r\n                    t = stack.pop() #出栈字符逐个赋值\r\n                    if t!=\"]\": #如果未遇到]\r\n                        temp.append(t)#将临时列表中的数堆栈\r\n                    else:\r\n                        break\r\n                temp = \"\".join(temp).split(\"[\")#将临时列表里的字符转成字符串，再以\"[\"分割\r\n                stack.append(int(temp[0])*temp[1]) #前面是数值，后面是字符\r\n            stack.append(c) #将结果压栈\r\n        stack.pop()\r\n        return \"\".join(stack[::-1])\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zsjlovelike":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836846214","body":"Class Solution{\r\nList<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n}"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838335540","body":"class Solution { \r\n public  int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        //保证有prev参与的加减运算不会溢出。同时又能起到最小值的效果\r\n        //因为i>=0,不除以2会越界。防止从左向右遍历数组时i-pre越界。\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            if (s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = Math.min(res[i], prev - i);\r\n        }\r\n        return res;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838335540","body":"class Solution { \r\n public  int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        //保证有prev参与的加减运算不会溢出。同时又能起到最小值的效果\r\n        //因为i>=0,不除以2会越界。防止从左向右遍历数组时i-pre越界。\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            if (s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = Math.min(res[i], prev - i);\r\n        }\r\n        return res;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840395899","body":"public class Solution {\r\n    private static int p;\r\n\r\n    public static void main(String[] args) {\r\n        String s = \"3[a2[c]]\";\r\n        System.out.println(decodeString(s));\r\n    }\r\n\r\n    public static String decodeString(String s) {\r\n        LinkedList<String> list = new LinkedList<>();\r\n        p = 0;\r\n\r\n        while (p < s.length()) {\r\n            char c = s.charAt(p);\r\n            if (Character.isDigit(c)) {\r\n                //获取一个数字进栈\r\n                String digits = getDigits(s);\r\n                list.addLast(digits);\r\n            } else if (Character.isLetter(c) || c == '[') {\r\n                //获取一个字母进栈\r\n                list.addLast(String.valueOf(s.charAt(p++)));\r\n            } else {\r\n                ++p;\r\n                LinkedList<String> sub = new LinkedList<>();\r\n                while (!\"[\".equals(list.peekLast())) {\r\n                    sub.addLast(list.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                //左括号出栈\r\n                list.removeLast();\r\n                //此时栈顶为当前sub对应的字符串应该出现的次数\r\n                int n = Integer.parseInt(list.removeLast());\r\n                StringBuffer sb = new StringBuffer();\r\n                String o = getString(sub);\r\n                while (n-- > 0) {\r\n                    sb.append(o);\r\n                }\r\n                list.addLast(sb.toString());\r\n            }\r\n        }\r\n        return getString(list);\r\n    }\r\n\r\n\r\n    public static String getDigits(String s) {\r\n        StringBuilder sb = new StringBuilder();\r\n        while (Character.isDigit(s.charAt(p))) {\r\n            sb.append(s.charAt(p++));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    public static String getString(LinkedList<String> list) {\r\n        StringBuffer sb = new StringBuffer();\r\n        for (String s : list) {\r\n            sb.append(s);\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"daidaidashixiong666":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836860926","body":"class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10) {\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838683020","body":"class Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        \r\n        int N =S.length();\r\n        int[] ans =new int[N];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        for(int i=0;i<N;i++){\r\n            if(S.charAt(i)==C) prev=i;\r\n            ans[i]=i-prev; \r\n        }\r\n        prev=Integer.MAX_VALUE/2;\r\n        for(int i=N-1;i>=0;--i){\r\n            if(S.charAt(i)==C) prev=i;\r\n            ans[i]=Math.min(ans[i],prev-i);\r\n        }\r\n        return ans;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838683020","body":"class Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        \r\n        int N =S.length();\r\n        int[] ans =new int[N];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        for(int i=0;i<N;i++){\r\n            if(S.charAt(i)==C) prev=i;\r\n            ans[i]=i-prev; \r\n        }\r\n        prev=Integer.MAX_VALUE/2;\r\n        for(int i=N-1;i>=0;--i){\r\n            if(S.charAt(i)==C) prev=i;\r\n            ans[i]=Math.min(ans[i],prev-i);\r\n        }\r\n        return ans;\r\n    }\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flagyk5":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836861924","body":"思路：\r\n1.list转换为int，计算加法，再把结果转化为list\r\n2.缺点运行速度太慢，空间一般\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        B = 0\r\n        for i in range(len(A) - 1, -1, -1):\r\n            B += A[i]*(10**(len(A) - i - 1))  \r\n        C = B + K\r\n        \r\n        if C == 0:\r\n            D = [0]\r\n        else:\r\n            D = []\r\n        \r\n        while C:\r\n            D.append(C%10)\r\n            C //=10\r\n        D.reverse()\r\n        return D"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838722787","body":"思路：\r\n两边分别寻找距离，然后对比。一开始不知道怎么处理没找到的情况，solution的方法很简洁，借鉴了一下\r\n\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        \r\n        for i in range(len(s)):\r\n            l = i   \r\n            while l >= 0:\r\n                if s[l] == c:\r\n                    break\r\n                else:\r\n                    l -= 1\r\n                 \r\n            r = i\r\n            while r < len(s):\r\n                if s[r] == c:\r\n                    break\r\n                else:\r\n                    r += 1\r\n                    \r\n            if l == -1: l = -10000\r\n            if r == len(s): r = 10000\r\n            num = min(i-l, r-i)\r\n            ans.append(num)\r\n        return ans\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838722787","body":"思路：\r\n两边分别寻找距离，然后对比。一开始不知道怎么处理没找到的情况，solution的方法很简洁，借鉴了一下\r\n\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        \r\n        for i in range(len(s)):\r\n            l = i   \r\n            while l >= 0:\r\n                if s[l] == c:\r\n                    break\r\n                else:\r\n                    l -= 1\r\n                 \r\n            r = i\r\n            while r < len(s):\r\n                if s[r] == c:\r\n                    break\r\n                else:\r\n                    r += 1\r\n                    \r\n            if l == -1: l = -10000\r\n            if r == len(s): r = 10000\r\n            num = min(i-l, r-i)\r\n            ans.append(num)\r\n        return ans\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840268397","body":"### 思路\r\n栈符号，读str然后写进stack里面，先找 ']' , 再回过来找 '[' \r\n有参考题解的思路\r\n\r\n### 代码 Python3\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for i in s:\r\n            if  i == ']':\r\n                les = ''\r\n                num = ''\r\n                while stack[-1].isalpha():\r\n                    les = stack.pop() + les\r\n                stack.pop()\r\n                while stack != [] and stack[-1].isnumeric():\r\n                    num = stack.pop() + num\r\n                stack.append(les * int(num))\r\n            else:\r\n                stack.append(i)\r\n        return \"\".join(stack)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jennny06":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836864849","body":"一开始用了一个一个加的方法，然后在用 divmod 做，但是发现这样的速度很慢。学习了一下评论里的码，发现python 其实一行code 就可以搞定：先把str 转成int， 然后加减，再转成str：\r\n`return map(int,str(int(''.join(map(str,num))) + k))`"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838731551","body":"### 思路\r\n先找到index，然后一个一个比较\r\n\r\n```\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        ind = [i for i,e in enumerate(s) if e == c ]\r\n        ans = []\r\n        \r\n        for i in range(len(s)):\r\n            minn = 'inf'\r\n            for j in ind:\r\n                dist = abs(i-j)\r\n                if minn > dist:\r\n                    minn = dist\r\n            ans.append(minn)\r\n                \r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：`O(n^2)`"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838731551","body":"### 思路\r\n先找到index，然后一个一个比较\r\n\r\n```\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        ind = [i for i,e in enumerate(s) if e == c ]\r\n        ans = []\r\n        \r\n        for i in range(len(s)):\r\n            minn = 'inf'\r\n            for j in ind:\r\n                dist = abs(i-j)\r\n                if minn > dist:\r\n                    minn = dist\r\n            ans.append(minn)\r\n                \r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：`O(n^2)`"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840587215","body":"## Code in Python\r\n\r\n\r\n`class Solution(object):\r\n    def decodeString(self, s):        \r\n        out = ''\r\n        stack = []\r\n        num = ''\r\n        \r\n        for c in range(len(s)):\r\n            if s[c].isdigit():\r\n                num += s[c]\r\n            elif s[c] == '[':\r\n                stack.append((out, int(num)));\r\n                out,num = \"\", \"\"\r\n            elif s[c] == ']':\r\n                top = stack.pop()\r\n                out = top[0] + out * top[1]\r\n            else: \r\n                out += s[c]\r\n          \r\n        return out`\r\n\r\n## 复杂度\r\n- 时间: `O (n)`\r\n- 空间: `O(n)`\r\n\r\n## 思路\r\n先从头往后，遇到数字先存成string，然后遇到`[` 之后，把现在存在的output 和 数字存起来。注意要把output reset 成null，这样可以遇到后面的括号内的内容，先把里面括号的内容写出来，再加上现在有的。遇到`]`后，把最上面的output 和 数字取出，然后用output + 数字*最新的括号内的内容。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sun-unc":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836866524","body":"var addToArrayForm = function (num, k) {\r\n    return (BigInt(num.join('')) + BigInt(k)).toString().split('')\r\n};"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838373077","body":"    var shortestToChar = function(s, c) {\r\n      let arr = s.split('')\r\n      let answer = []\r\n      for(let i = 0; i < arr.length; i++) {\r\n        if(arr[i] == c) {\r\n          answer.push(0)\r\n          continue\r\n        }\r\n        let arr1 = arr.slice(0, i).reverse()\r\n        let arr2 = arr.slice(i+1, arr.length)\r\n        let leftIndex = arr1.indexOf(c)\r\n        let rightIndex = arr2.indexOf(c)\r\n        if (leftIndex === -1) {\r\n          answer.push(rightIndex + 1)\r\n        } else if(rightIndex === -1) {\r\n          answer.push(leftIndex + 1)\r\n        } else {\r\n          leftIndex <= rightIndex ? answer.push(leftIndex + 1) : answer.push(rightIndex + 1)\r\n        }\r\n      }\r\n      console.log(answer);\r\n      // return answer\r\n    };"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838373077","body":"    var shortestToChar = function(s, c) {\r\n      let arr = s.split('')\r\n      let answer = []\r\n      for(let i = 0; i < arr.length; i++) {\r\n        if(arr[i] == c) {\r\n          answer.push(0)\r\n          continue\r\n        }\r\n        let arr1 = arr.slice(0, i).reverse()\r\n        let arr2 = arr.slice(i+1, arr.length)\r\n        let leftIndex = arr1.indexOf(c)\r\n        let rightIndex = arr2.indexOf(c)\r\n        if (leftIndex === -1) {\r\n          answer.push(rightIndex + 1)\r\n        } else if(rightIndex === -1) {\r\n          answer.push(leftIndex + 1)\r\n        } else {\r\n          leftIndex <= rightIndex ? answer.push(leftIndex + 1) : answer.push(rightIndex + 1)\r\n        }\r\n      }\r\n      console.log(answer);\r\n      // return answer\r\n    };"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Rainjoy66":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836866671","body":"```\r\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        for nu in num:\r\n            res.append(str(nu))\r\n        string = \"\".join(res)\r\n        ans = int(string) + k\r\n        anss = list(str(ans))\r\n        dd = []\r\n        for ansss in anss:\r\n            dd.append(int(ansss))\r\n        return dd\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838734678","body":"### 思路：\r\n正反遍历，然后取最小值\r\n### 代码\r\n```\r\ndef function(self, s, c):\r\n        res = []\r\n        t = len(s)\r\n        for i in s:\r\n            t=0 if i==c else t+1\r\n            res.append(t)\r\n        for idx,i in enumerate(s[::-1]):\r\n            t = 0 if i==c else t+1\r\n            res[-(idx+1)] = min(t,res[-(idx+1)])\r\n        return res\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838734678","body":"### 思路：\r\n正反遍历，然后取最小值\r\n### 代码\r\n```\r\ndef function(self, s, c):\r\n        res = []\r\n        t = len(s)\r\n        for i in s:\r\n            t=0 if i==c else t+1\r\n            res.append(t)\r\n        for idx,i in enumerate(s[::-1]):\r\n            t = 0 if i==c else t+1\r\n            res[-(idx+1)] = min(t,res[-(idx+1)])\r\n        return res\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840619992","body":"### 代码\r\n```\r\ndef decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuo0314":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836867704","body":"#Logic: convert list to str, then to int; add 2 int to get sum; convert int to str; convert str to list\r\n#Code: Python\r\n\r\n```\r\ndef addToArrayForm(self, num,k):\r\n    num_str = \"\"\r\n    for i in num:\r\n        num_str += str(i)\r\n    num_sum = int(num_str)+k\r\n    num_lst = [int(i) for i in str(num_sum)]\r\n    return num_lst\r\n```\r\n\r\n#Complexity: Time: O(n), Space: O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838701859","body":"\"\"\"Logic: iterate through the str, if the character is c, put its position in str in a new list1. After for loop, list1 will\r\n      have all position in str that's c;\r\n      iterate through the str, if the character is c, put 0 in the return list; if not, calculate the absolute value between\r\n      this index and each index in list 1, find the min and put it in the return list\r\n\"\"\"\r\n#Code: Python\r\n```\r\ndef shortestToChar(s, c):\r\n    lst = []\r\n    res_lst=[]\r\n    for i in range(len(s)):\r\n        if s[i] == c:\r\n            lst.append(i)\r\n    for j in range(len(s)):\r\n        if s[j]==c:\r\n            res_lst.append(0)\r\n        else:\r\n            min_dis = len(s)\r\n            for i in lst:\r\n                if abs(i-j) < min_dis:\r\n                    min_dis = abs(i-j)\r\n            res_lst.append(min_dis)\r\n    return res_lst\r\n```\r\n#Complexity: Time: O(n^2), Space: O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838701859","body":"\"\"\"Logic: iterate through the str, if the character is c, put its position in str in a new list1. After for loop, list1 will\r\n      have all position in str that's c;\r\n      iterate through the str, if the character is c, put 0 in the return list; if not, calculate the absolute value between\r\n      this index and each index in list 1, find the min and put it in the return list\r\n\"\"\"\r\n#Code: Python\r\n```\r\ndef shortestToChar(s, c):\r\n    lst = []\r\n    res_lst=[]\r\n    for i in range(len(s)):\r\n        if s[i] == c:\r\n            lst.append(i)\r\n    for j in range(len(s)):\r\n        if s[j]==c:\r\n            res_lst.append(0)\r\n        else:\r\n            min_dis = len(s)\r\n            for i in lst:\r\n                if abs(i-j) < min_dis:\r\n                    min_dis = abs(i-j)\r\n            res_lst.append(min_dis)\r\n    return res_lst\r\n```\r\n#Complexity: Time: O(n^2), Space: O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840298450","body":"#第一次做不太会，参考了题解算法默写了一遍\r\n#Logic: Use of stack; Iterate through string, if character is \"]\" iterate backwards， add character to result string\r\n#until finding \"[\"; Then continue iterating backwards to find numeric char until non-numeric, \r\n#and update result string by repeating itself corresponding times. Join all char in stack to a string and return it\r\n#Code: Python\r\n```\r\ndef decodeString(self, s:str) -> str:\r\n    stack = []\r\n    #res_str = \"\"\r\n    for c in s:\r\n        if c ==\"]\":\r\n            res_str = \"\"\r\n            res_cnt = \"\"\r\n            while stack and stack[-1]!=\"[\":\r\n                res_str = stack.pop() + res_str\r\n            stack.pop()\r\n            while stack and stack[-1].isnumeric():\r\n                res_cnt = stack.pop() + res_cnt\r\n            res_str=res_str*int(res_cnt)\r\n            stack.append(res_str)        \r\n        else:\r\n            stack.append(c)\r\n    return \"\".join(stack)\r\n```\r\n\r\n#Complexity: Time: O(N), N is length of result string\r\n#space: O(N), N is length of result string"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yangjiahao106":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836868252","body":"## 思路\r\n\r\n遍历数组num，用k乘当前位的10的幂次，累加结果\r\n代码\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num = list(reversed(num))\r\n        for i in range(0, len(num)):\r\n            k += num[i]\r\n            num[i] = k %10\r\n            k = k // 10\r\n        \r\n        while k > 0:\r\n            num.append(k%10)\r\n            k  = k // 10\r\n        return list(reversed(num))\r\n```\r\n## 复杂度\r\n\r\n时间复杂度O(n) 空间复杂度O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838740235","body":"```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = 0 \r\n        r = 0\r\n\r\n        res = [1<<31-1 for i in s] \r\n\r\n        while r < len(s):\r\n            if s[r] == c:\r\n               break\r\n            r += 1\r\n\r\n        for l in range(0, len(s)):\r\n            res[l] = r - l \r\n            if l ==r:\r\n                while r < len(s)-1:\r\n                    r += 1\r\n                    if s[r] == c:\r\n                        break\r\n                if s[r] != c:\r\n                    break\r\n        r = len(s) - 1\r\n        while r >=0:\r\n            if s[r] == c:\r\n               break\r\n            r -= 1\r\n    \r\n        for l in range(len(s)-1, -1, -1):\r\n            res[l] = min(res[l],  l-r) \r\n            if l <= r:\r\n                while r > 0:\r\n                    r -= 1\r\n                    if s[r] == c:\r\n                        break\r\n                if s[r] != c:\r\n                    return res \r\n        return res \r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838740235","body":"```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = 0 \r\n        r = 0\r\n\r\n        res = [1<<31-1 for i in s] \r\n\r\n        while r < len(s):\r\n            if s[r] == c:\r\n               break\r\n            r += 1\r\n\r\n        for l in range(0, len(s)):\r\n            res[l] = r - l \r\n            if l ==r:\r\n                while r < len(s)-1:\r\n                    r += 1\r\n                    if s[r] == c:\r\n                        break\r\n                if s[r] != c:\r\n                    break\r\n        r = len(s) - 1\r\n        while r >=0:\r\n            if s[r] == c:\r\n               break\r\n            r -= 1\r\n    \r\n        for l in range(len(s)-1, -1, -1):\r\n            res[l] = min(res[l],  l-r) \r\n            if l <= r:\r\n                while r > 0:\r\n                    r -= 1\r\n                    if s[r] == c:\r\n                        break\r\n                if s[r] != c:\r\n                    return res \r\n        return res \r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840656306","body":"## 思路\r\n使用栈处理括号\r\n## 代码\r\n``` python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        int_stack = []\r\n        stack = []\r\n        i = 0\r\n        while i < len(s):\r\n            if '0' <= s[i] <= '9':\r\n                l = i\r\n                while '0' <=  s[i] <= '9':\r\n                    i += 1\r\n                int_stack.append(int(s[l:i]))\r\n            if s[i] == ']':\r\n                tmp = \"\"\r\n                while True:\r\n                    c = stack.pop()\r\n                    if c == '[':\r\n                        break\r\n                    tmp = c + tmp\r\n                stack.append(tmp * int_stack.pop())\r\n            else:\r\n                stack.append(s[i])\r\n\r\n            i += 1\r\n\r\n        return \"\".join(stack)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bmxbmx3":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836878093","body":"### 思路\r\n\r\n初步思路：\r\n1. 先排除异常情况\r\n2. 将数组变成对应数字，加上一个数后，将相加结果变回数组\r\n\r\n### 代码\r\n\r\n\r\n```python\r\n\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int] 待加数字的数组\r\n        :type k: int 所加的数字\r\n        :rtype: List[int] 加数字后的数组\r\n        \"\"\"\r\n\r\n        # 将num数组转换为对应的数字\r\n        sum = 0\r\n        length = len(num)\r\n        for i in range(len(num)):\r\n            sum += num[i]*10**(length-i-1)  # 逐位相加，比如[1,2]即1*10^1+2*10^0=12\r\n\r\n        sum += k  # 计算相加结果\r\n\r\n        # 将相加后的数字转换为对应的数组（从后往前逐位取数字）\r\n        result = []\r\n        while(sum):\r\n            result.append(sum % 10)\r\n            sum = sum//10  # 双斜杠（//）表示地板除，即先做除法（/），然后向下取整（floor）\r\n        result.reverse() # 结果数组倒序\r\n        return result\r\n\r\n\r\nnum = [9,9,9,9,9,9,9,9,9,9]\r\nk = 1\r\ns = Solution()\r\nresult = s.addToArrayForm(num, k)\r\nprint(result)\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838601737","body":"## 思路\r\n\r\n参考：\r\n- [821.字符的最短距离【4种解法、JS/Cpp/Py】](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/821zi-fu-de-zui-duan-ju-chi-4chong-jie-fa-javascri/)\r\n\r\n思路1（中心扩展法）：\r\n1. 排除异常情况\r\n2. 从原字符串s中每个字符（中心位置i）出发，向两边同时扩展寻找字符c。最先寻找到的字符c，一定距离位置i上的字符最近\r\n思路2（以空间换时间）？\r\n思路3（双向遍历贪心法）？（时间复杂度最优）\r\n## 关键点\r\n\r\n- python数组初始化？（参考：https://www.pythontab.com/html/2020/pythonjichu_0102/1470.html）\r\n- python判断字符串自否为大小写字母？（参考：https://blog.csdn.net/nanhuaibeian/article/details/99472393）\r\n- 双向遍历贪心法？\r\n\r\n## 代码\r\n\r\n- 语言支持：Python\r\n\r\nPython Code:\r\n\r\n```python\r\n\r\nclass Solution(object):\r\n    \"\"\"\r\n    思路1\r\n    \"\"\"\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        length = len(s)\r\n\r\n        \"\"\"\r\n        排除异常\r\n        \"\"\"\r\n        # 数组长度异常\r\n        if(length < 1 or length > 10000):\r\n            print(\"数组s的长度应在1-10000之间！\")\r\n            return\r\n        # 小写字母异常\r\n        if(not (s.islower() and s.isalpha())):\r\n            print(\"数组s必须都是小写字母！\")\r\n            return\r\n        if(c not in s):\r\n            print(\"字符c不在数组s中！\")\r\n            return\r\n\r\n        result = [0]*length  # 初始化结果数组，存放数组s中每个字符到字符c的最近距离\r\n\r\n        for i in range(length):\r\n            # 如果遍历到字符c，则跳过（最近距离为0）\r\n            if s[i] == c:\r\n                continue\r\n\r\n            \"\"\"  \r\n            以当前位置i的字符为中心，向两边扩展寻找最近的字符c\r\n            \"\"\"\r\n            left = i  # 向左寻找，下标不断减小\r\n            right = i  # 向右寻找，下表不断增加\r\n            min_distance = 0  # 记录最近距离（到中心字符s[i]）\r\n            while(left >= 0 or right <= length-1):\r\n                # 向两边同时寻找，一旦找到字符c就停止寻找\r\n                if(s[left] == c):\r\n                    min_distance = i-left\r\n                    break\r\n                if(s[right] == c):\r\n                    min_distance = right-i\r\n                    break\r\n\r\n                \"\"\" \r\n                left（向左标志）左移，同理right（向右标志）右移\r\n                note:\r\n                left若为0，left-1变为-1,到下层循环时不满足外层循环条件left>=0,\r\n                但right却可能依然满足right<length的外层循环条件，这样导致下层循环依然可以执行，\r\n                但此时下层循环中left=-1，使得s[left]即s[-1]因找不到值而发生错误,\r\n                故在这里设置left>0的判断。\r\n                同理，为了保险起见，这里right<length-1。\r\n                \"\"\"\r\n                if(left > 0):\r\n                    left -= 1\r\n                if(right < length-1):\r\n                    right += 1\r\n\r\n            result[i] = min_distance  # 记录字符串s中，当前位置i的字符距字符c的最近距离\r\n\r\n        return result\r\n\r\n\r\ns = Solution()\r\nstr_s = \"1baab\"\r\nc = \"a\"\r\nresult = s.shortestToChar(str_s, c)\r\nprint(result)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$，n为S的长度，两层循环。\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838601737","body":"## 思路\r\n\r\n参考：\r\n- [821.字符的最短距离【4种解法、JS/Cpp/Py】](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/821zi-fu-de-zui-duan-ju-chi-4chong-jie-fa-javascri/)\r\n\r\n思路1（中心扩展法）：\r\n1. 排除异常情况\r\n2. 从原字符串s中每个字符（中心位置i）出发，向两边同时扩展寻找字符c。最先寻找到的字符c，一定距离位置i上的字符最近\r\n思路2（以空间换时间）？\r\n思路3（双向遍历贪心法）？（时间复杂度最优）\r\n## 关键点\r\n\r\n- python数组初始化？（参考：https://www.pythontab.com/html/2020/pythonjichu_0102/1470.html）\r\n- python判断字符串自否为大小写字母？（参考：https://blog.csdn.net/nanhuaibeian/article/details/99472393）\r\n- 双向遍历贪心法？\r\n\r\n## 代码\r\n\r\n- 语言支持：Python\r\n\r\nPython Code:\r\n\r\n```python\r\n\r\nclass Solution(object):\r\n    \"\"\"\r\n    思路1\r\n    \"\"\"\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        length = len(s)\r\n\r\n        \"\"\"\r\n        排除异常\r\n        \"\"\"\r\n        # 数组长度异常\r\n        if(length < 1 or length > 10000):\r\n            print(\"数组s的长度应在1-10000之间！\")\r\n            return\r\n        # 小写字母异常\r\n        if(not (s.islower() and s.isalpha())):\r\n            print(\"数组s必须都是小写字母！\")\r\n            return\r\n        if(c not in s):\r\n            print(\"字符c不在数组s中！\")\r\n            return\r\n\r\n        result = [0]*length  # 初始化结果数组，存放数组s中每个字符到字符c的最近距离\r\n\r\n        for i in range(length):\r\n            # 如果遍历到字符c，则跳过（最近距离为0）\r\n            if s[i] == c:\r\n                continue\r\n\r\n            \"\"\"  \r\n            以当前位置i的字符为中心，向两边扩展寻找最近的字符c\r\n            \"\"\"\r\n            left = i  # 向左寻找，下标不断减小\r\n            right = i  # 向右寻找，下表不断增加\r\n            min_distance = 0  # 记录最近距离（到中心字符s[i]）\r\n            while(left >= 0 or right <= length-1):\r\n                # 向两边同时寻找，一旦找到字符c就停止寻找\r\n                if(s[left] == c):\r\n                    min_distance = i-left\r\n                    break\r\n                if(s[right] == c):\r\n                    min_distance = right-i\r\n                    break\r\n\r\n                \"\"\" \r\n                left（向左标志）左移，同理right（向右标志）右移\r\n                note:\r\n                left若为0，left-1变为-1,到下层循环时不满足外层循环条件left>=0,\r\n                但right却可能依然满足right<length的外层循环条件，这样导致下层循环依然可以执行，\r\n                但此时下层循环中left=-1，使得s[left]即s[-1]因找不到值而发生错误,\r\n                故在这里设置left>0的判断。\r\n                同理，为了保险起见，这里right<length-1。\r\n                \"\"\"\r\n                if(left > 0):\r\n                    left -= 1\r\n                if(right < length-1):\r\n                    right += 1\r\n\r\n            result[i] = min_distance  # 记录字符串s中，当前位置i的字符距字符c的最近距离\r\n\r\n        return result\r\n\r\n\r\ns = Solution()\r\nstr_s = \"1baab\"\r\nc = \"a\"\r\nresult = s.shortestToChar(str_s, c)\r\nprint(result)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$，n为S的长度，两层循环。\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840644890","body":"## 思路\r\n\r\n参考：https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/\r\n1. 构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\r\n- 当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\r\n- 当 c 为字母时，在 res 尾部添加 c；\r\n- 当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 00：\r\n记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\r\n记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\r\n进入到新 [ 后，res 和 multi 重新记录。\r\n2. 当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\r\n- last_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\r\n- cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\r\n返回字符串 res。\r\n\r\n## 关键点\r\n\r\n-  括号匹配\r\n\r\n## 代码\r\n\r\n- 语言支持：Python\r\n\r\nPython Code:\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度 O(N)O(N)，一次遍历s；\r\n- 空间复杂度 O(N)O(N)，辅助栈在极端情况下需要线性空间，例如2[2[2[a]]]。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DADAHUI":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836882177","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n示例 1：\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n示例 2：\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n示例 3：\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n示例 4\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n提示：\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n`\r\n\r\n## 思路\r\nnum与k值逐位相加，大于9时进1，参与下一位运算\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) \r\n    {\r\n      vector <int> res;\r\n      for(int i=num.size()-1;i>=0;i--)\r\n      {\r\n          int sum=num[i]+k%10;\r\n          k/=10;\r\n          if(sum>9)\r\n          {\r\n              sum=sum%10;\r\n              k++;\r\n          }\r\n          res.push_back(sum);\r\n\r\n      }\r\n      for(;k>0;k/=10)\r\n      {\r\n          res.push_back(k%10);\r\n      }\r\n\r\n      reverse(res.begin(),res.end());\r\n      return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838588143","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n数组arr存储s中下标；s的每一个下标与每一个与和c相同的下标做差，取最小值 \r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n    vector <int> vec,answer;\r\n    \r\n    for(int i=0;i<s.size();i++)\r\n    {\r\n        if(s[i]==c) vec.push_back(i);\r\n    }\r\n    int arr[vec.size()];\r\n    \r\n    for(int i=0;i<s.size();i++)\r\n    {\r\n        for(int j=0;j<vec.size();j++)\r\n        {\r\n          arr[j]=abs(i-vec[j]);  \r\n        }\r\n        answer.push_back(*min_element(arr,arr+vec.size()));\r\n    }\r\n   return answer;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838588143","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n数组arr存储s中下标；s的每一个下标与每一个与和c相同的下标做差，取最小值 \r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n    vector <int> vec,answer;\r\n    \r\n    for(int i=0;i<s.size();i++)\r\n    {\r\n        if(s[i]==c) vec.push_back(i);\r\n    }\r\n    int arr[vec.size()];\r\n    \r\n    for(int i=0;i<s.size();i++)\r\n    {\r\n        for(int j=0;j<vec.size();j++)\r\n        {\r\n          arr[j]=abs(i-vec[j]);  \r\n        }\r\n        answer.push_back(*min_element(arr,arr+vec.size()));\r\n    }\r\n   return answer;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qycoder":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836882253","body":"## 思路\r\n\r\n\r\n## 代码\r\nJavaScript\r\n\r\n```js\r\nvar addToArrayForm = function (num, k) {\r\n  let str = '';\r\n  for (let i = 0; i < num.length; i++) {\r\n    if (num[i] < 0 || num[i] > 9) {\r\n      str = '';\r\n      break;\r\n    } else {\r\n      str += num[i];\r\n    }\r\n  }\r\n  let sum = str / 1 + k;\r\n  const result = [];\r\n  let divisor;\r\n  for (let j = 0; j < (sum + '').length; j++) {\r\n    if (j == 0) {\r\n      divisor = 1;\r\n    } else {\r\n      divisor = 10 ** j;\r\n    }\r\n    result.unshift(parseInt((sum % 10 ** (j + 1)) / divisor));\r\n  }\r\n  return result;\r\n};\r\n\r\nconst arr = [1, 2, 0, 1];\r\nconst k = 220;\r\nconsole.log(addToArrayForm(arr, k));\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838736689","body":"## 思路\r\n\r\n## 代码\r\nvar shortestToChar = function (s, c) {\r\n  // 结果数组 res\r\n  var res = Array(s.length).fill(0);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    // 如果当前是目标字符，就什么都不用做\r\n    if (s[i] === c) continue;\r\n\r\n    let l = i,\r\n      r = i,\r\n      shortest = Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (s[l] === c) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r < s.length) {\r\n      if (s[r] === c) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n  return res;\r\n};\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838736689","body":"## 思路\r\n\r\n## 代码\r\nvar shortestToChar = function (s, c) {\r\n  // 结果数组 res\r\n  var res = Array(s.length).fill(0);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    // 如果当前是目标字符，就什么都不用做\r\n    if (s[i] === c) continue;\r\n\r\n    let l = i,\r\n      r = i,\r\n      shortest = Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (s[l] === c) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r < s.length) {\r\n      if (s[r] === c) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n  return res;\r\n};\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840657882","body":"```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  console.log(s, s.length);\r\n  let stack = s.split(']');\r\n  let arr = [];\r\n  stack = stack.map(item => {\r\n    item = item.split('[');\r\n    console.log('item', item);\r\n    let str = ''\r\n    for(let i = 0; i < item[0]; i ++) {\r\n      str += item[1];\r\n    }\r\n    console.log('str', str)\r\n    arr.push(str)\r\n  });\r\n  return arr.join('');\r\n};\r\n\r\nconst a1 = decodeString('3[a]2[bc]');\r\n\r\nconsole.log('a1', a1);\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lanceli424":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836931206","body":"## 代码\r\n```\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    let kArr: number[] = String(k).split('').map(v => parseInt(v, 10));\r\n    let kLength = kArr.length - 1;\r\n    let numLength = num.length - 1;\r\n    let flag: number = 0;\r\n    while(numLength >= 0 || kLength >= 0 || flag > 0) {\r\n        let kItem = kArr[kLength] || 0;\r\n        let numItem = num[numLength] || 0;\r\n        let sum = numItem + kItem + flag;\r\n        flag = 0;\r\n        if(sum >= 10) {\r\n            flag = 1;\r\n            sum -= 10;\r\n        }\r\n        if(numLength < 0) {\r\n            num.unshift(sum);\r\n        }else {            \r\n            num[numLength] = sum;\r\n        }\r\n        numLength--;\r\n        kLength--;\r\n    }\r\n    return num;\r\n};\r\n```\r\n\r\n## 思路\r\n1. 把数据转换成数组相加\r\n2. 两个数组长度可能不一样长，如果长度不够需要在头部插入\r\n\r\n## 复杂度分析\r\n1. 时间复杂度 O(m+n)，其中 m 是 num 数组长度，n 是 k的长度\r\n2. 空间复杂度 O(m+n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838374436","body":"## 思路\r\n找到匹配的字符，判断离上一个节点近还是下一个节点近。第一匹配到的位置之前和最后一个匹配到的位置之后需要单独处理。\r\n\r\n## 代码\r\n```\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    let result: number[] = [];\r\n    if (s.length === 0 || c.length === 0) {\r\n        return result;\r\n    }\r\n    let strArray = Array.from(s);\r\n    let indexs: number[] = [];\r\n    strArray.forEach((element, index) => {\r\n        if (element === c) {\r\n            indexs.push(index);\r\n        }\r\n    });\r\n    for (let i = 0; i <= indexs[0]; i++) {\r\n        result.push(indexs[0] - i);\r\n    }\r\n    for (let i = 0; i <= indexs.length - 2; i++) {\r\n        let start = indexs[i];\r\n        let end = indexs[i + 1];\r\n        for (let i = start + 1; i <= end; i++) {\r\n            let distance = Math.min(i - start, end - i);\r\n            result.push(distance);\r\n        }\r\n    }\r\n    for (let i = indexs[indexs.length - 1] + 1; i < strArray.length; i++) {\r\n        result.push(i - indexs[indexs.length - 1]);\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n1. 时间复杂度 O(N)\r\n2. 空间复杂度 O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838374436","body":"## 思路\r\n找到匹配的字符，判断离上一个节点近还是下一个节点近。第一匹配到的位置之前和最后一个匹配到的位置之后需要单独处理。\r\n\r\n## 代码\r\n```\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    let result: number[] = [];\r\n    if (s.length === 0 || c.length === 0) {\r\n        return result;\r\n    }\r\n    let strArray = Array.from(s);\r\n    let indexs: number[] = [];\r\n    strArray.forEach((element, index) => {\r\n        if (element === c) {\r\n            indexs.push(index);\r\n        }\r\n    });\r\n    for (let i = 0; i <= indexs[0]; i++) {\r\n        result.push(indexs[0] - i);\r\n    }\r\n    for (let i = 0; i <= indexs.length - 2; i++) {\r\n        let start = indexs[i];\r\n        let end = indexs[i + 1];\r\n        for (let i = start + 1; i <= end; i++) {\r\n            let distance = Math.min(i - start, end - i);\r\n            result.push(distance);\r\n        }\r\n    }\r\n    for (let i = indexs[indexs.length - 1] + 1; i < strArray.length; i++) {\r\n        result.push(i - indexs[indexs.length - 1]);\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n1. 时间复杂度 O(N)\r\n2. 空间复杂度 O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lingquan02":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836966361","body":"### 思路\r\n- 位数相加，数组加完后，指针向前移动， 对于k加完后，去掉个位\r\n- 边界 数组len>=0 || k!=0\r\n复杂度：\r\nT= O(n)\r\nS =O(1)\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];// 存放结果\r\n    let len = num.length-1;\r\n    let carry = 0; // 存放进位\r\n\r\n    while(len>=0 || k!=0) {\r\n        const x = len >=0 ? num[len] : 0 // 取最后一位  （个位数）\r\n        const y = k!=0 ? k % 10 : 0; // 取个位数 取模\r\n\r\n        const sum = x+y+carry // 求和  \r\n        res.push(sum%10) // 将个位数放到结果集里\r\n        carry = Math.floor(sum/10) // 存放进位\r\n\r\n        len--;\r\n        k = Math.floor(k/10); // 每次运算完成去掉个位数\r\n    }\r\n\r\n    if(carry) res.push(carry)\r\n    return res.reverse()\r\n};\r\n\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838529295","body":"### 思路分析\r\n- T= O(n)\r\n- S = O(1)\r\n```javascript\r\n// 滑动窗口\r\nconst shortestToChar =(S,C) => {\r\n    let len =S.length;\r\n    let l = S[0] === C ? 0: len-1;\r\n    let r = S.indexOf(C,1); // 从index未1的位置开始找c\r\n    let res = Array(len);\r\n    for(let i=0;i<len;i++) {\r\n        res[i] =Math.min(Math.abs(i-r),Math.abs(l-i))\r\n        // 改变窗口\r\n        if(i===r) {\r\n            l =r; \r\n            r = S.indexOf(C,l+1);\r\n\r\n        }\r\n\r\n    }\r\n    return res\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838529295","body":"### 思路分析\r\n- T= O(n)\r\n- S = O(1)\r\n```javascript\r\n// 滑动窗口\r\nconst shortestToChar =(S,C) => {\r\n    let len =S.length;\r\n    let l = S[0] === C ? 0: len-1;\r\n    let r = S.indexOf(C,1); // 从index未1的位置开始找c\r\n    let res = Array(len);\r\n    for(let i=0;i<len;i++) {\r\n        res[i] =Math.min(Math.abs(i-r),Math.abs(l-i))\r\n        // 改变窗口\r\n        if(i===r) {\r\n            l =r; \r\n            r = S.indexOf(C,l+1);\r\n\r\n        }\r\n\r\n    }\r\n    return res\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"longlonglu":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837017943","body":"```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] answer = new int[length];\r\n        for (int i = 0; i < length; i++) {\r\n            if (s.charAt(i) == c) { answer[i] = 0; continue; }\r\n            int minDistance = Math.min(leftDistance(s, c, i), rightDistance(s, c, i));\r\n            answer[i] = minDistance;\r\n        }\r\n        return answer;\r\n    }\r\n    public int leftDistance(String s, char c, int index) {\r\n        int counter = 0;\r\n        for (int i = index; i >= 0; i--) {\r\n            if (s.charAt(i) == c) { return counter; }\r\n            counter++;\r\n        }\r\n        return s.length() + 1;\r\n    }\r\n    public int rightDistance(String s, char c, int index) {\r\n        int counter = 0;\r\n        for (int i = index; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) { return counter; }\r\n            counter++;\r\n        }\r\n        return s.length() + 1;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837017943","body":"```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] answer = new int[length];\r\n        for (int i = 0; i < length; i++) {\r\n            if (s.charAt(i) == c) { answer[i] = 0; continue; }\r\n            int minDistance = Math.min(leftDistance(s, c, i), rightDistance(s, c, i));\r\n            answer[i] = minDistance;\r\n        }\r\n        return answer;\r\n    }\r\n    public int leftDistance(String s, char c, int index) {\r\n        int counter = 0;\r\n        for (int i = index; i >= 0; i--) {\r\n            if (s.charAt(i) == c) { return counter; }\r\n            counter++;\r\n        }\r\n        return s.length() + 1;\r\n    }\r\n    public int rightDistance(String s, char c, int index) {\r\n        int counter = 0;\r\n        for (int i = index; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) { return counter; }\r\n            counter++;\r\n        }\r\n        return s.length() + 1;\r\n    }\r\n}\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840713732","body":"```java\r\nclass MyQueue {\r\n        /** Initialize your data structure here. */\r\n        Integer peek;\r\n        Stack<Integer> store;\r\n        public MyQueue() {\r\n            peek = null;\r\n            store = new Stack<>();\r\n        }\r\n        \r\n        /** Push element x to the back of queue. */\r\n        public void push(int x) {\r\n            if(store.isEmpty()) { peek = x; }\r\n            store.add(x);    \r\n        }\r\n        \r\n        /** Removes the element from in front of queue and returns that element. */\r\n       public int pop() {\r\n            if(store.isEmpty()) { return -1; }\r\n            Stack<Integer> temp = new Stack<>();\r\n            int size = store.size();\r\n            for(int i = 0; i < size; i++) {\r\n                temp.add(store.pop());\r\n            }\r\n            int returnValue = temp.pop();\r\n            if(!temp.isEmpty()) {\r\n                peek = temp.peek();\r\n            } else { return returnValue; }\r\n            size = temp.size();\r\n            for(int i = 0; i < size; i++) {\r\n                store.add(temp.pop());\r\n            }\r\n            return returnValue;\r\n        }\r\n        /** Get the front element. */\r\n        public int peek() {\r\n            if(peek == null) { return -1; }\r\n            return peek;     \r\n        }\r\n        \r\n        /** Returns whether the queue is empty. */\r\n        public boolean empty() {\r\n            return store.isEmpty();    \r\n        } \r\n    }   \r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"911gt5":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837256654","body":"TC: O(n)\r\nSC: O(n)\r\n\r\n``` python\r\ndef shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        left = [float('inf')]*n\r\n        right = [float('inf')]*n\r\n        stack = collections.deque()\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                while stack:\r\n                    pre_i= stack.popleft()\r\n                    left[pre_i] = i - pre_i\r\n                left[i] = 0\r\n            else:\r\n                stack.append(i)\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                while stack:\r\n                    post_i = stack.popleft()\r\n                    right[post_i] = post_i -i \r\n                right[i] = 0\r\n            else:\r\n                stack.append(i)\r\n        return [min(l,r) for l,r in zip(left, right)]\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837256654","body":"TC: O(n)\r\nSC: O(n)\r\n\r\n``` python\r\ndef shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        left = [float('inf')]*n\r\n        right = [float('inf')]*n\r\n        stack = collections.deque()\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                while stack:\r\n                    pre_i= stack.popleft()\r\n                    left[pre_i] = i - pre_i\r\n                left[i] = 0\r\n            else:\r\n                stack.append(i)\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                while stack:\r\n                    post_i = stack.popleft()\r\n                    right[post_i] = post_i -i \r\n                right[i] = 0\r\n            else:\r\n                stack.append(i)\r\n        return [min(l,r) for l,r in zip(left, right)]\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840115165","body":"TC: 指数级别\r\n```\r\ndef decodeString(self, s: str) -> str:\r\n        u = 0\r\n        def dfs(s):\r\n            nonlocal u\r\n            res = ''\r\n            while u < len(s) and s[u] != ']':\r\n\r\n                if s[u].isalpha():\r\n                    res += s[u]\r\n                    u += 1\r\n                elif s[u].isdigit():\r\n                    k = u\r\n                    while s[k].isdigit():\r\n                        k += 1\r\n\r\n                    x = int(s[u:k])\r\n                    u = k + 1\r\n                    y = dfs(s)\r\n                    u += 1 \r\n\r\n                    while x:\r\n                        res += y\r\n                        x -= 1\r\n            return res\r\n\r\n        return dfs(s)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"prince805962788":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837860923","body":"### 思路\r\n双指针，从每个点出发，想左右搜寻，直到找到等于所给字符的点，然后分别算出距离，取其中最小的记录到数组中\r\n### 代码（js）\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    const res = []\r\n    for(let i=0;i<s.length;i++){\r\n        let left = i\r\n        let right = i\r\n        while(left>=0){\r\n            if(s[left] === c) break\r\n            left--\r\n        }\r\n        while(right<s.length){\r\n            if(s[right] === c) break\r\n            right++\r\n        }\r\n        if(left === -1) left = -Infinity\r\n        if(right === s.length) right = Infinity\r\n        res[i] = Math.min(i-left, right-i)\r\n    }\r\n    return res\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837860923","body":"### 思路\r\n双指针，从每个点出发，想左右搜寻，直到找到等于所给字符的点，然后分别算出距离，取其中最小的记录到数组中\r\n### 代码（js）\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    const res = []\r\n    for(let i=0;i<s.length;i++){\r\n        let left = i\r\n        let right = i\r\n        while(left>=0){\r\n            if(s[left] === c) break\r\n            left--\r\n        }\r\n        while(right<s.length){\r\n            if(s[right] === c) break\r\n            right++\r\n        }\r\n        if(left === -1) left = -Infinity\r\n        if(right === s.length) right = Infinity\r\n        res[i] = Math.min(i-left, right-i)\r\n    }\r\n    return res\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840227944","body":"### 思路(JS)\r\n双指针，一个存数字，一个存当前字符串\r\n````\r\nvar decodeString = function(s) {\r\n    const numStack = []\r\n    const strStack = []\r\n    let num = 0\r\n    let res = ''\r\n    let index = 0\r\n    while(index<s.length){\r\n        if(s[index].match(/[0-9]/)){\r\n            num = num * 10 + Number(s[index])\r\n        }else if(s[index] === '['){\r\n            numStack.push(num)\r\n            strStack.push(res)\r\n            num = 0\r\n            res = ''\r\n        }else if(s[index] === ']'){\r\n            res = strStack.pop() + res.repeat(numStack.pop())\r\n        }else {\r\n            res = res + s[index]\r\n        }\r\n        index++\r\n    }\r\n    return res\r\n};\r\n````\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyk1337":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837931988","body":"# Approach\r\n- Left-to-right: count the distance on the right\r\n- Right-to-left: count the distance on the left\r\n- Take the minimum at each position\r\n\r\n# Python Implementation\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        distance = 10001\r\n        n = len(s)\r\n        res = []\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                distance = 0\r\n            res.append(distance)\r\n            distance += 1\r\n        \r\n        distance = 10001\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                distance = 0\r\n            res[i] = min(distance, res[i])\r\n            distance += 1\r\n        return res\r\n```\r\n\r\n# Complexity analysis\r\n- Time: O(n)\r\n- Space: O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837931988","body":"# Approach\r\n- Left-to-right: count the distance on the right\r\n- Right-to-left: count the distance on the left\r\n- Take the minimum at each position\r\n\r\n# Python Implementation\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        distance = 10001\r\n        n = len(s)\r\n        res = []\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                distance = 0\r\n            res.append(distance)\r\n            distance += 1\r\n        \r\n        distance = 10001\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                distance = 0\r\n            res[i] = min(distance, res[i])\r\n            distance += 1\r\n        return res\r\n```\r\n\r\n# Complexity analysis\r\n- Time: O(n)\r\n- Space: O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840661629","body":"# Approach\r\n- Handle continuous digits, `[`, `]`, and other chars.\r\n\r\n# Python Implementation\r\n```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        stack = []\r\n        n = 0\r\n        res = \"\"\r\n        for c in s:\r\n            if '0' <= c <= '9':\r\n                n = n * 10 + int(c)\r\n            elif c == '[':\r\n                stack.append([n, res])\r\n                n = 0\r\n                res = \"\"\r\n            elif c == ']':\r\n                cur_n, last_res = stack.pop()\r\n                res = last_res + cur_n * res\r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n\r\n# Time Complexity\r\n- Time O(n)\r\n- Space O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840677617","body":"# Approach\r\nUse two stacks to get a queue\r\n\r\n# Python Implementation\r\n```python\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.s1 = []\r\n        self.s2 = []\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.s1.append(x)\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        :rtype: int\r\n        \"\"\"\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop())\r\n        return self.s2.pop()\r\n\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        Get the front element.\r\n        :rtype: int\r\n        \"\"\"\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop())\r\n        return self.s2[-1]\r\n\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        :rtype: bool\r\n        \"\"\"\r\n        return not self.s1 and not self.s2\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n# Complexity Analysis\r\n- Time complexity: push O(1), peek/pop amortized O(1)\r\n- Space complexity O(n)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"YanFaFa":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838156207","body":"\r\nclass Solution {\r\n\r\n    /**\r\n     * @param String $s\r\n     * @param String $c\r\n     * @return Integer[]\r\n     */\r\n    function shortestToChar($s, $c) {\r\n        $target = [];\r\n        $len = strlen($s);\r\n        $targetLen = 0;\r\n        for ($i=0; $i<$len; $i++) {\r\n            if ($s[$i] == $c) {\r\n                array_push($target, $i);\r\n                $targetLen++;\r\n            }\r\n        }\r\n\r\n        for ($i = 0; $i<$len; $i++) {\r\n            if ($s[$i] == $c) {\r\n                $result[] = 0;\r\n            } else {\r\n                $num = $len;\r\n                for ($j = 0; $j<$targetLen;$j++) {\r\n                    $tmp = abs($target[$j] - $i);\r\n                    if ($tmp < $num) {\r\n                        $num = $tmp; \r\n                    } else {\r\n                        continue;\r\n                    }\r\n                }\r\n                $result[] = $num;\r\n            } \r\n        }\r\n        return $result;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838156207","body":"\r\nclass Solution {\r\n\r\n    /**\r\n     * @param String $s\r\n     * @param String $c\r\n     * @return Integer[]\r\n     */\r\n    function shortestToChar($s, $c) {\r\n        $target = [];\r\n        $len = strlen($s);\r\n        $targetLen = 0;\r\n        for ($i=0; $i<$len; $i++) {\r\n            if ($s[$i] == $c) {\r\n                array_push($target, $i);\r\n                $targetLen++;\r\n            }\r\n        }\r\n\r\n        for ($i = 0; $i<$len; $i++) {\r\n            if ($s[$i] == $c) {\r\n                $result[] = 0;\r\n            } else {\r\n                $num = $len;\r\n                for ($j = 0; $j<$targetLen;$j++) {\r\n                    $tmp = abs($target[$j] - $i);\r\n                    if ($tmp < $num) {\r\n                        $num = $tmp; \r\n                    } else {\r\n                        continue;\r\n                    }\r\n                }\r\n                $result[] = $num;\r\n            } \r\n        }\r\n        return $result;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840539820","body":"the function 'str_repeat' should not be used.Waiting for optimization\r\n\r\nclass Solution {\r\n\r\n    /**\r\n     * @param String $s\r\n     * @return String\r\n     */\r\n    function decodeString($s) {\r\n        $len_s = strlen($s);\r\n        $stack = new SplStack();\r\n        for ($i = 0; $i < $len_s; $i++) {\r\n            if ($s[$i] != ']') {\r\n                $stack->push($s[$i]);\r\n                continue;\r\n            }\r\n            $repeat_str = \"\";\r\n            while (!$stack->isEmpty() && $stack->top() != '[') {\r\n                $repeat_str = $stack->pop(). $repeat_str;\r\n            }\r\n            $stack->pop();\r\n            $repeat_times = \"\";\r\n            while (!$stack->isEmpty() && is_numeric($stack->top())) {\r\n                $repeat_times = $stack->pop(). $repeat_times;\r\n            }\r\n            $temp = str_repeat($repeat_str, $repeat_times);\r\n            $stack->push($temp);\r\n        }\r\n\r\n        $res = \"\";\r\n        while (!$stack->isEmpty()) {\r\n            $res = $stack->pop(). $res;\r\n        }\r\n\r\n        return $res;\r\n    }\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"RealDuxy":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838328793","body":"#### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n#### 思路：\r\n\r\n暴力等等方法很简答，我们尝试双指针方法。\r\n构建result数组，由左向右遍历一遍，记录右边离你最近的c字符的距离，遍历 i 时可以利用已经完成的 i-1的结果。\r\n\r\n遍历完毕后，我们由右向左遍历，相当于比较左边和右边最近的c字符的距离哪个更小，取最小的来替代result[i]\r\n\r\n#### 代码 python\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [math.inf] * len(s)\r\n        # 从左至右遍历一遍\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n            elif i > 0:\r\n                result[i] = result[i-1] + 1\r\n       \r\n        # 从右至左\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n            elif i < len(s)-1:\r\n                result[i] = min(result[i+1]+1, result[i])\r\n        return result\r\n```\r\n\r\n\r\n\r\n#### 复杂度分析:\r\n\r\n时间复杂度：\r\n\r\n两次遍历都是N次迭代，每次迭代都是常数操作，显然是O(N)\r\n\r\n空间复杂度:\r\n\r\n除了result外，没有构建额外的数组，均在result原地操作，故O(1)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838328793","body":"#### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n#### 思路：\r\n\r\n暴力等等方法很简答，我们尝试双指针方法。\r\n构建result数组，由左向右遍历一遍，记录右边离你最近的c字符的距离，遍历 i 时可以利用已经完成的 i-1的结果。\r\n\r\n遍历完毕后，我们由右向左遍历，相当于比较左边和右边最近的c字符的距离哪个更小，取最小的来替代result[i]\r\n\r\n#### 代码 python\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [math.inf] * len(s)\r\n        # 从左至右遍历一遍\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n            elif i > 0:\r\n                result[i] = result[i-1] + 1\r\n       \r\n        # 从右至左\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n            elif i < len(s)-1:\r\n                result[i] = min(result[i+1]+1, result[i])\r\n        return result\r\n```\r\n\r\n\r\n\r\n#### 复杂度分析:\r\n\r\n时间复杂度：\r\n\r\n两次遍历都是N次迭代，每次迭代都是常数操作，显然是O(N)\r\n\r\n空间复杂度:\r\n\r\n除了result外，没有构建额外的数组，均在result原地操作，故O(1)\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaofaqian":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838329911","body":"## 思路\r\n双指针吧 从当前位置开始比对 然后往左偏移往比对往右偏移比对\r\n## 代码\r\n```\r\nSarr := []byte{}\r\n\tSP := []int{}\r\n\tfor _, v := range s {\r\n\t\tSarr = append(Sarr, byte(v))\r\n\t}\r\n\tfor i := 0; i < len(Sarr); i++ {\r\n\t\tstep := 0\r\n\r\n\t\tfor true {\r\n\t\t\tif i+step < len(Sarr) && Sarr[i+step] == c {\r\n\t\t\t\tSP = append(SP, step)\r\n\t\t\t\tstep = 1\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tif i-step >= 0 && Sarr[i-step] == c {\r\n\t\t\t\tSP = append(SP, step)\r\n\t\t\t\tstep = 1\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tstep++\r\n\t\t}\r\n\t}\r\n\treturn SP\r\n```\r\n## 复杂度\r\n- 时间复杂度 O(n2)\r\n- 空间复杂度 O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838329911","body":"## 思路\r\n双指针吧 从当前位置开始比对 然后往左偏移往比对往右偏移比对\r\n## 代码\r\n```\r\nSarr := []byte{}\r\n\tSP := []int{}\r\n\tfor _, v := range s {\r\n\t\tSarr = append(Sarr, byte(v))\r\n\t}\r\n\tfor i := 0; i < len(Sarr); i++ {\r\n\t\tstep := 0\r\n\r\n\t\tfor true {\r\n\t\t\tif i+step < len(Sarr) && Sarr[i+step] == c {\r\n\t\t\t\tSP = append(SP, step)\r\n\t\t\t\tstep = 1\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tif i-step >= 0 && Sarr[i-step] == c {\r\n\t\t\t\tSP = append(SP, step)\r\n\t\t\t\tstep = 1\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tstep++\r\n\t\t}\r\n\t}\r\n\treturn SP\r\n```\r\n## 复杂度\r\n- 时间复杂度 O(n2)\r\n- 空间复杂度 O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838409646","body":"# 821.字符的最短距离\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n- [821.字符的最短距离](#821字符的最短距离)\r\n  - [题目描述](#题目描述)\r\n  - [解法 1：中心扩展法](#解法-1中心扩展法)\r\n    - [思路](#思路)\r\n    - [复杂度分析](#复杂度分析)\r\n    - [代码 (JS/C++)](#代码-jsc)\r\n  - [解法 2：空间换时间](#解法-2空间换时间)\r\n    - [思路](#思路-1)\r\n    - [复杂度分析](#复杂度分析-1)\r\n    - [代码 (JS/C++)](#代码-jsc-1)\r\n  - [解法 3：贪心](#解法-3贪心)\r\n    - [思路](#思路-2)\r\n    - [复杂度分析](#复杂度分析-2)\r\n    - [代码 (JS/C++/Python)](#代码-jscpython)\r\n  - [解法 4：窗口](#解法-4窗口)\r\n    - [思路](#思路-3)\r\n    - [复杂度分析](#复杂度分析-3)\r\n    - [代码 (JS/C++/Python)](#代码-jscpython-1)\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n字符串 S 的长度范围为 [1, 10000]。\r\nC 是一个单字符，且保证是字符串 S 里的字符。\r\nS 和 C 中的所有字母均为小写字母。\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n```\r\n\r\n## 解法 1：中心扩展法\r\n\r\n### 思路\r\n\r\n这是最符合直觉的思路，对每个字符分别进行如下处理：\r\n\r\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 `C`。\r\n- 只在一个方向找到的话，直接计算字符距离。\r\n- 两个方向都找到的话，取两个距离的最小值。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_0.png)\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 结果数组 res\r\n  var res = Array(S.length).fill(0);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 如果当前是目标字符，就什么都不用做\r\n    if (S[i] === C) continue;\r\n\r\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\r\n    let l = i,\r\n      r = i,\r\n      shortest = Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (S[l] === C) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r < S.length) {\r\n      if (S[r] === C) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        vector<int> res(S.length());\r\n\r\n        for (int i = 0; i < S.length(); i++) {\r\n            if (S[i] == C) continue;\r\n\r\n            int left = i;\r\n            int right = i;\r\n            int dist = 0;\r\n\r\n            while (left >= 0 || right <= S.length() - 1) {\r\n                if (S[left] == C) {\r\n                    dist = i - left;\r\n                    break;\r\n                }\r\n                if (S[right] == C) {\r\n                    dist = right - i;\r\n                    break;\r\n                }\r\n\r\n                if (left > 0) left--;\r\n                if (right < S.length() - 1) right++;\r\n            }\r\n\r\n            res[i] = dist;\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 解法 2：空间换时间\r\n\r\n### 思路\r\n\r\n空间换时间是编程中很常见的一种 trade-off (反过来，时间换空间也是)。\r\n\r\n因为目标字符 `C` 在 `S` 中的位置是不变的，所以我们可以提前将 `C` 的所有下标记录在一个数组 `cIndices` 中。\r\n\r\n然后遍历字符串 `S` 中的每个字符，到 `cIndices` 中找到距离当前位置最近的下标，计算距离。\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N*K)$，N 是 S 的长度，K 是字符 `C` 在字符串中出现的次数，$K <= N$。\r\n- 空间复杂度：$O(K)$，K 为字符 `C` 出现的次数，这是记录字符 `C` 出现下标的辅助数组消耗的空间。\r\n\r\n### 代码 (JS/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 记录 C 字符在 S 字符串中出现的所有下标\r\n  var cIndices = [];\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) cIndices.push(i);\r\n  }\r\n\r\n  // 结果数组 res\r\n  var res = Array(S.length).fill(Infinity);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 目标字符，距离是 0\r\n    if (S[i] === C) {\r\n      res[i] = 0;\r\n      continue;\r\n    }\r\n\r\n    // 非目标字符，到下标数组中找最近的下标\r\n    for (const cIndex of cIndices) {\r\n      const dist = Math.abs(cIndex - i);\r\n\r\n      // 小小剪枝一下\r\n      // 注：因为 cIndices 中的下标是递增的，后面的 dist 也会越来越大，可以排除\r\n      if (dist >= res[i]) break;\r\n\r\n      res[i] = dist;\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n        vector<int> c_indices;\r\n        // Initialize a vector of size n with default value n.\r\n        vector<int> res(n, n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) c_indices.push_back(i);\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) {\r\n                res[i] = 0;\r\n                continue;\r\n            }\r\n\r\n            for (int j = 0; j < c_indices.size(); j++) {\r\n                int dist = abs(c_indices[j] - i);\r\n                if (dist > res[i]) break;\r\n                res[i] = dist;\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 解法 3：贪心\r\n\r\n### 思路\r\n\r\n其实对于每个字符来说，它只关心离它最近的那个 `C` 字符，其他的它都不管。所以这里还可以用贪心的思路：\r\n\r\n1. 先 `从左往右` 遍历字符串 `S`，用一个数组 left 记录每个字符 `左侧` 出现的最后一个 `C` 字符的下标；\r\n2. 再 `从右往左` 遍历字符串 `S`，用一个数组 right 记录每个字符 `右侧` 出现的最后一个 `C` 字符的下标；\r\n3. 然后同时遍历这两个数组，计算距离最小值。\r\n\r\n**优化 1**\r\n\r\n再多想一步，其实第二个数组并不需要。因为对于左右两侧的 `C` 字符，我们也只关心其中距离更近的那一个，所以第二次遍历的时候可以看情况覆盖掉第一个数组的值：\r\n\r\n1. 字符左侧没有出现过 `C` 字符\r\n2. `i - left` > `right - i` (i 为当前字符下标，left 为字符左侧最近的 `C` 下标，right 为字符右侧最近的 `C` 下标)\r\n\r\n如果出现以上两种情况，就可以进行覆盖，最后再遍历一次数组计算距离。\r\n\r\n**优化 2**\r\n\r\n如果我们是直接记录 `C` 与当前字符的距离，而不是记录 `C` 的下标，还可以省掉最后一次遍历计算距离的过程。\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，N 是 S 的长度。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++/Python)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  var res = Array(S.length);\r\n\r\n  // 第一次遍历：从左往右\r\n  // 找到出现在左侧的 C 字符的最后下标\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) res[i] = i;\r\n    // 如果左侧没有出现 C 字符的话，用 Infinity 进行标记\r\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1];\r\n  }\r\n\r\n  // 第二次遍历：从右往左\r\n  // 找出现在右侧的 C 字符的最后下标\r\n  // 如果左侧没有出现过 C 字符，或者右侧出现的 C 字符距离更近，就更新 res[i]\r\n  for (let i = S.length - 1; i >= 0; i--) {\r\n    if (res[i] === Infinity || res[i + 1] - i < i - res[i]) res[i] = res[i + 1];\r\n  }\r\n\r\n  // 计算距离\r\n  for (let i = 0; i < res.length; i++) {\r\n    res[i] = Math.abs(res[i] - i);\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n**直接计算距离：**\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  var res = Array(S.length);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) res[i] = 0;\r\n    // 记录距离：res[i - 1] + 1\r\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1] + 1;\r\n  }\r\n\r\n  for (let i = S.length - 1; i >= 0; i--) {\r\n    // 更新距离：res[i + 1] + 1\r\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1;\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n        vector<int> dist(n, n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) dist[i] = 0;\r\n            else if (i > 0) dist[i] = dist[i - 1] + 1;\r\n        }\r\n\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (dist[i] == n\r\n                || (i < n - 1 && dist[i + 1] + 1 < dist[i]))\r\n                    dist[i] = dist[i + 1] + 1;\r\n        }\r\n\r\n        return dist;\r\n    }\r\n};\r\n```\r\n\r\nPython Code\r\n\r\n```py\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        res = [0 if s[i] == c else None for i in range(n)]\r\n\r\n        for i in range(1, n):\r\n            if res[i] != 0 and res[i - 1] is not None:\r\n                res[i] = res[i - 1] + 1\r\n\r\n        for i in range(n - 2, -1, -1):\r\n            if res[i] is None or res[i + 1] + 1 < res[i]:\r\n                res[i] = res[i + 1] + 1\r\n        return res\r\n```\r\n\r\n## 解法 4：窗口\r\n\r\n### 思路\r\n\r\n把 `C` 看成分界线，将 `S` 划分成一个个窗口。然后对每个窗口进行遍历，分别计算每个字符到窗口边界的距离最小值。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_1.png)\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，N 是 S 的长度。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++/Python)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 窗口左边界，如果没有就初始化为 Infinity，初始化为 S.length 也可以\r\n  let l = S[0] === C ? 0 : Infinity,\r\n    // 窗口右边界\r\n    r = S.indexOf(C, 1);\r\n\r\n  const res = Array(S.length);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 计算字符到当前窗口左右边界的最小距离\r\n    res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\r\n\r\n    // 遍历完了当前窗口的字符后，将整个窗口右移\r\n    if (i === r) {\r\n      l = r;\r\n      r = S.indexOf(C, l + 1);\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n\r\n        int l = S[0] == C ? 0 : n;\r\n        int r = S.find(C, 1);\r\n\r\n        vector<int> dist(n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            dist[i] = min(abs(i - l), abs(r - i));\r\n            if (i == r) {\r\n                l = r;\r\n                r = S.find(C, r + 1);\r\n            }\r\n        }\r\n\r\n        return dist;\r\n    }\r\n};\r\n```\r\n\r\nPython Code\r\n\r\n```py\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        res = [0 for _ in range(n)]\r\n\r\n        l = 0 if s[0] == c else n\r\n        r = s.find(c, 1)\r\n\r\n        for i in range(n):\r\n            res[i] = min(abs(i - l), abs(r - i))\r\n            if i == r:\r\n                l = r\r\n                r = s.find(c, l + 1)\r\n        return res\r\n```\r\n\r\n更多题解可以访问：[https://github.com/suukii/91-days-algorithm](https://github.com/suukii/91-days-algorithm)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838409646","body":"# 821.字符的最短距离\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n- [821.字符的最短距离](#821字符的最短距离)\r\n  - [题目描述](#题目描述)\r\n  - [解法 1：中心扩展法](#解法-1中心扩展法)\r\n    - [思路](#思路)\r\n    - [复杂度分析](#复杂度分析)\r\n    - [代码 (JS/C++)](#代码-jsc)\r\n  - [解法 2：空间换时间](#解法-2空间换时间)\r\n    - [思路](#思路-1)\r\n    - [复杂度分析](#复杂度分析-1)\r\n    - [代码 (JS/C++)](#代码-jsc-1)\r\n  - [解法 3：贪心](#解法-3贪心)\r\n    - [思路](#思路-2)\r\n    - [复杂度分析](#复杂度分析-2)\r\n    - [代码 (JS/C++/Python)](#代码-jscpython)\r\n  - [解法 4：窗口](#解法-4窗口)\r\n    - [思路](#思路-3)\r\n    - [复杂度分析](#复杂度分析-3)\r\n    - [代码 (JS/C++/Python)](#代码-jscpython-1)\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n字符串 S 的长度范围为 [1, 10000]。\r\nC 是一个单字符，且保证是字符串 S 里的字符。\r\nS 和 C 中的所有字母均为小写字母。\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n```\r\n\r\n## 解法 1：中心扩展法\r\n\r\n### 思路\r\n\r\n这是最符合直觉的思路，对每个字符分别进行如下处理：\r\n\r\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 `C`。\r\n- 只在一个方向找到的话，直接计算字符距离。\r\n- 两个方向都找到的话，取两个距离的最小值。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_0.png)\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 结果数组 res\r\n  var res = Array(S.length).fill(0);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 如果当前是目标字符，就什么都不用做\r\n    if (S[i] === C) continue;\r\n\r\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\r\n    let l = i,\r\n      r = i,\r\n      shortest = Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (S[l] === C) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r < S.length) {\r\n      if (S[r] === C) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        vector<int> res(S.length());\r\n\r\n        for (int i = 0; i < S.length(); i++) {\r\n            if (S[i] == C) continue;\r\n\r\n            int left = i;\r\n            int right = i;\r\n            int dist = 0;\r\n\r\n            while (left >= 0 || right <= S.length() - 1) {\r\n                if (S[left] == C) {\r\n                    dist = i - left;\r\n                    break;\r\n                }\r\n                if (S[right] == C) {\r\n                    dist = right - i;\r\n                    break;\r\n                }\r\n\r\n                if (left > 0) left--;\r\n                if (right < S.length() - 1) right++;\r\n            }\r\n\r\n            res[i] = dist;\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 解法 2：空间换时间\r\n\r\n### 思路\r\n\r\n空间换时间是编程中很常见的一种 trade-off (反过来，时间换空间也是)。\r\n\r\n因为目标字符 `C` 在 `S` 中的位置是不变的，所以我们可以提前将 `C` 的所有下标记录在一个数组 `cIndices` 中。\r\n\r\n然后遍历字符串 `S` 中的每个字符，到 `cIndices` 中找到距离当前位置最近的下标，计算距离。\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N*K)$，N 是 S 的长度，K 是字符 `C` 在字符串中出现的次数，$K <= N$。\r\n- 空间复杂度：$O(K)$，K 为字符 `C` 出现的次数，这是记录字符 `C` 出现下标的辅助数组消耗的空间。\r\n\r\n### 代码 (JS/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 记录 C 字符在 S 字符串中出现的所有下标\r\n  var cIndices = [];\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) cIndices.push(i);\r\n  }\r\n\r\n  // 结果数组 res\r\n  var res = Array(S.length).fill(Infinity);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 目标字符，距离是 0\r\n    if (S[i] === C) {\r\n      res[i] = 0;\r\n      continue;\r\n    }\r\n\r\n    // 非目标字符，到下标数组中找最近的下标\r\n    for (const cIndex of cIndices) {\r\n      const dist = Math.abs(cIndex - i);\r\n\r\n      // 小小剪枝一下\r\n      // 注：因为 cIndices 中的下标是递增的，后面的 dist 也会越来越大，可以排除\r\n      if (dist >= res[i]) break;\r\n\r\n      res[i] = dist;\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n        vector<int> c_indices;\r\n        // Initialize a vector of size n with default value n.\r\n        vector<int> res(n, n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) c_indices.push_back(i);\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) {\r\n                res[i] = 0;\r\n                continue;\r\n            }\r\n\r\n            for (int j = 0; j < c_indices.size(); j++) {\r\n                int dist = abs(c_indices[j] - i);\r\n                if (dist > res[i]) break;\r\n                res[i] = dist;\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 解法 3：贪心\r\n\r\n### 思路\r\n\r\n其实对于每个字符来说，它只关心离它最近的那个 `C` 字符，其他的它都不管。所以这里还可以用贪心的思路：\r\n\r\n1. 先 `从左往右` 遍历字符串 `S`，用一个数组 left 记录每个字符 `左侧` 出现的最后一个 `C` 字符的下标；\r\n2. 再 `从右往左` 遍历字符串 `S`，用一个数组 right 记录每个字符 `右侧` 出现的最后一个 `C` 字符的下标；\r\n3. 然后同时遍历这两个数组，计算距离最小值。\r\n\r\n**优化 1**\r\n\r\n再多想一步，其实第二个数组并不需要。因为对于左右两侧的 `C` 字符，我们也只关心其中距离更近的那一个，所以第二次遍历的时候可以看情况覆盖掉第一个数组的值：\r\n\r\n1. 字符左侧没有出现过 `C` 字符\r\n2. `i - left` > `right - i` (i 为当前字符下标，left 为字符左侧最近的 `C` 下标，right 为字符右侧最近的 `C` 下标)\r\n\r\n如果出现以上两种情况，就可以进行覆盖，最后再遍历一次数组计算距离。\r\n\r\n**优化 2**\r\n\r\n如果我们是直接记录 `C` 与当前字符的距离，而不是记录 `C` 的下标，还可以省掉最后一次遍历计算距离的过程。\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，N 是 S 的长度。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++/Python)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  var res = Array(S.length);\r\n\r\n  // 第一次遍历：从左往右\r\n  // 找到出现在左侧的 C 字符的最后下标\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) res[i] = i;\r\n    // 如果左侧没有出现 C 字符的话，用 Infinity 进行标记\r\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1];\r\n  }\r\n\r\n  // 第二次遍历：从右往左\r\n  // 找出现在右侧的 C 字符的最后下标\r\n  // 如果左侧没有出现过 C 字符，或者右侧出现的 C 字符距离更近，就更新 res[i]\r\n  for (let i = S.length - 1; i >= 0; i--) {\r\n    if (res[i] === Infinity || res[i + 1] - i < i - res[i]) res[i] = res[i + 1];\r\n  }\r\n\r\n  // 计算距离\r\n  for (let i = 0; i < res.length; i++) {\r\n    res[i] = Math.abs(res[i] - i);\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n**直接计算距离：**\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  var res = Array(S.length);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) res[i] = 0;\r\n    // 记录距离：res[i - 1] + 1\r\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1] + 1;\r\n  }\r\n\r\n  for (let i = S.length - 1; i >= 0; i--) {\r\n    // 更新距离：res[i + 1] + 1\r\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1;\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n        vector<int> dist(n, n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) dist[i] = 0;\r\n            else if (i > 0) dist[i] = dist[i - 1] + 1;\r\n        }\r\n\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (dist[i] == n\r\n                || (i < n - 1 && dist[i + 1] + 1 < dist[i]))\r\n                    dist[i] = dist[i + 1] + 1;\r\n        }\r\n\r\n        return dist;\r\n    }\r\n};\r\n```\r\n\r\nPython Code\r\n\r\n```py\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        res = [0 if s[i] == c else None for i in range(n)]\r\n\r\n        for i in range(1, n):\r\n            if res[i] != 0 and res[i - 1] is not None:\r\n                res[i] = res[i - 1] + 1\r\n\r\n        for i in range(n - 2, -1, -1):\r\n            if res[i] is None or res[i + 1] + 1 < res[i]:\r\n                res[i] = res[i + 1] + 1\r\n        return res\r\n```\r\n\r\n## 解法 4：窗口\r\n\r\n### 思路\r\n\r\n把 `C` 看成分界线，将 `S` 划分成一个个窗口。然后对每个窗口进行遍历，分别计算每个字符到窗口边界的距离最小值。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_1.png)\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，N 是 S 的长度。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++/Python)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 窗口左边界，如果没有就初始化为 Infinity，初始化为 S.length 也可以\r\n  let l = S[0] === C ? 0 : Infinity,\r\n    // 窗口右边界\r\n    r = S.indexOf(C, 1);\r\n\r\n  const res = Array(S.length);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 计算字符到当前窗口左右边界的最小距离\r\n    res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\r\n\r\n    // 遍历完了当前窗口的字符后，将整个窗口右移\r\n    if (i === r) {\r\n      l = r;\r\n      r = S.indexOf(C, l + 1);\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n\r\n        int l = S[0] == C ? 0 : n;\r\n        int r = S.find(C, 1);\r\n\r\n        vector<int> dist(n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            dist[i] = min(abs(i - l), abs(r - i));\r\n            if (i == r) {\r\n                l = r;\r\n                r = S.find(C, r + 1);\r\n            }\r\n        }\r\n\r\n        return dist;\r\n    }\r\n};\r\n```\r\n\r\nPython Code\r\n\r\n```py\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        res = [0 for _ in range(n)]\r\n\r\n        l = 0 if s[0] == c else n\r\n        r = s.find(c, 1)\r\n\r\n        for i in range(n):\r\n            res[i] = min(abs(i - l), abs(r - i))\r\n            if i == r:\r\n                l = r\r\n                r = s.find(c, l + 1)\r\n        return res\r\n```\r\n\r\n更多题解可以访问：[https://github.com/suukii/91-days-algorithm](https://github.com/suukii/91-days-algorithm)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SWUFEzyf":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838418829","body":"```\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        result = [0] * n\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n                continue\r\n            left = i-1\r\n            right = i + 1\r\n            while left >= 0 and s[left] != c:\r\n                left -= 1 \r\n            if left == -1:\r\n                left_distance = n\r\n            else:\r\n                left_distance = i - left\r\n            while right < n and s[right] != c:\r\n                right += 1\r\n            if right == n:\r\n                right_distance = n\r\n            else:\r\n                right_distance =  right - i\r\n            result[i] = min(left_distance, right_distance)\r\n        return result\r\n```\r\n复杂度分析\r\n时间复杂度：$O(N^2)$。\r\n空间复杂度：$O(N)$。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838418829","body":"```\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        result = [0] * n\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n                continue\r\n            left = i-1\r\n            right = i + 1\r\n            while left >= 0 and s[left] != c:\r\n                left -= 1 \r\n            if left == -1:\r\n                left_distance = n\r\n            else:\r\n                left_distance = i - left\r\n            while right < n and s[right] != c:\r\n                right += 1\r\n            if right == n:\r\n                right_distance = n\r\n            else:\r\n                right_distance =  right - i\r\n            result[i] = min(left_distance, right_distance)\r\n        return result\r\n```\r\n复杂度分析\r\n时间复杂度：$O(N^2)$。\r\n空间复杂度：$O(N)$。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shmilywh":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838419961","body":"\r\n## 题目分析\r\n\r\n- 字符串长度大于等于1\r\n- 均为小写字母\r\n- c至少出现一次\r\n\r\n## 思路\r\n\r\n 1. **【双指针】找c的位置，分情况讨论**\r\n\r\n    根据c出现的次数不同，计算相对位置的方式也略有出入，给定两个元素，一个是要计算相对位置的a，另一个是目标字符c，二者之间的位置我们可以分三种情况考虑\r\n\r\n    1) c只出现一次，且a在c的两侧\r\n\r\n    这时的相对距离，毋庸置疑应该等于 abs(index(a) - index(c))\r\n\r\n    2) c出现两次，且a在两个c的中间\r\n\r\n    这时的相对距离，应该计算a到两个c的距离然后取较小值\r\n\r\n    3) c出现三次或三次以上，我们可以拆分成上述两种情况来分别计算\r\n\r\n    代码：\r\n\r\n    定义两个指针，移动策略如下\r\n\r\n    - 一开始两指针均指向字符串头部\r\n    - 右指针向前移动，直到遇见一个c，这时满足情况1\r\n    - 更新左指针为右指针，右指针继续向右移动，直到再遇到c（满足情况2）或者走到字符串尾部（满足情况1）\r\n\r\n    几点注意：\r\n\r\n    1. 计算距离的时机应该在右指针更新的时候，右指针第二次之后，直到走到尾部，都按第2种情况计算，右指针第一次更新或者走到尾部，按照第1中情况判断\r\n    2. 要考虑右指针指向尾部以及尾部字符恰好是c的情况，所以条件判断应该有**优先级**\r\n\r\n    执行用时：**40 ms**, 在所有 Python3 提交中击败了**93.41%**的用户\r\n\r\n    内存消耗：**14.9 MB**, 在所有 Python3 提交中击败了**66.05%**的用户\r\n\r\n    ```python\r\n    class Solution:\r\n        def shortestToChar(self, s: str, c: str) -> List[int]:\r\n            # 定义变量 left记录上一个c的位置，如果存在的话\r\n            left = right_cnt = 0\r\n            answer = [0]*len(s)\r\n\r\n            # 循环，找c，计算距离\r\n            for right in range(len(s)):   # 右指针从0遍历到len(s)-1\r\n                if s[right] == c:   # 如果右指针指向的字符是c，那么计算一次距离\r\n                    if not right_cnt:   # 如果右指针第一次更新，说明在c的一侧\r\n                        answer[left:right+1] = [abs(right-i) for i in range(left, right+1)]\r\n                    else:   # 如果右指针不是第一次更新，说明在两个c中间\r\n                        answer[left:right+1] = [min(abs(right-i), abs(i-left)) for i in range(left, right+1)]\r\n                    # 更新左指针以及出现c的次数\r\n                    left = right\r\n                    right_cnt += 1\r\n                else:\r\n                    # 注意这个条件判断要在else里面，以排除最后一个元素是c的情况\r\n                    if right == len(s)-1:\r\n                        answer[left:right+1] = [abs(left-i) for i in range(left, right+1)]\r\n            return answer\r\n    ```\r\n\r\n    复杂度分析\r\n\r\n    令n为字符串长度：\r\n\r\n    时间复杂度：O(N)，这里外层循环，快指针遍历了n次，然后内层，每次遇到一个c，就处理一部分，总的遍历次数也是n，相当于是2n，所示时间复杂度是O(N)\r\n\r\n    空间复杂度：O(1)(不考虑返回占用的空间)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838419961","body":"\r\n## 题目分析\r\n\r\n- 字符串长度大于等于1\r\n- 均为小写字母\r\n- c至少出现一次\r\n\r\n## 思路\r\n\r\n 1. **【双指针】找c的位置，分情况讨论**\r\n\r\n    根据c出现的次数不同，计算相对位置的方式也略有出入，给定两个元素，一个是要计算相对位置的a，另一个是目标字符c，二者之间的位置我们可以分三种情况考虑\r\n\r\n    1) c只出现一次，且a在c的两侧\r\n\r\n    这时的相对距离，毋庸置疑应该等于 abs(index(a) - index(c))\r\n\r\n    2) c出现两次，且a在两个c的中间\r\n\r\n    这时的相对距离，应该计算a到两个c的距离然后取较小值\r\n\r\n    3) c出现三次或三次以上，我们可以拆分成上述两种情况来分别计算\r\n\r\n    代码：\r\n\r\n    定义两个指针，移动策略如下\r\n\r\n    - 一开始两指针均指向字符串头部\r\n    - 右指针向前移动，直到遇见一个c，这时满足情况1\r\n    - 更新左指针为右指针，右指针继续向右移动，直到再遇到c（满足情况2）或者走到字符串尾部（满足情况1）\r\n\r\n    几点注意：\r\n\r\n    1. 计算距离的时机应该在右指针更新的时候，右指针第二次之后，直到走到尾部，都按第2种情况计算，右指针第一次更新或者走到尾部，按照第1中情况判断\r\n    2. 要考虑右指针指向尾部以及尾部字符恰好是c的情况，所以条件判断应该有**优先级**\r\n\r\n    执行用时：**40 ms**, 在所有 Python3 提交中击败了**93.41%**的用户\r\n\r\n    内存消耗：**14.9 MB**, 在所有 Python3 提交中击败了**66.05%**的用户\r\n\r\n    ```python\r\n    class Solution:\r\n        def shortestToChar(self, s: str, c: str) -> List[int]:\r\n            # 定义变量 left记录上一个c的位置，如果存在的话\r\n            left = right_cnt = 0\r\n            answer = [0]*len(s)\r\n\r\n            # 循环，找c，计算距离\r\n            for right in range(len(s)):   # 右指针从0遍历到len(s)-1\r\n                if s[right] == c:   # 如果右指针指向的字符是c，那么计算一次距离\r\n                    if not right_cnt:   # 如果右指针第一次更新，说明在c的一侧\r\n                        answer[left:right+1] = [abs(right-i) for i in range(left, right+1)]\r\n                    else:   # 如果右指针不是第一次更新，说明在两个c中间\r\n                        answer[left:right+1] = [min(abs(right-i), abs(i-left)) for i in range(left, right+1)]\r\n                    # 更新左指针以及出现c的次数\r\n                    left = right\r\n                    right_cnt += 1\r\n                else:\r\n                    # 注意这个条件判断要在else里面，以排除最后一个元素是c的情况\r\n                    if right == len(s)-1:\r\n                        answer[left:right+1] = [abs(left-i) for i in range(left, right+1)]\r\n            return answer\r\n    ```\r\n\r\n    复杂度分析\r\n\r\n    令n为字符串长度：\r\n\r\n    时间复杂度：O(N)，这里外层循环，快指针遍历了n次，然后内层，每次遇到一个c，就处理一部分，总的遍历次数也是n，相当于是2n，所示时间复杂度是O(N)\r\n\r\n    空间复杂度：O(1)(不考虑返回占用的空间)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-839928813","body":"[394\\. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\r\n\r\nDifficulty: **中等**\r\n\r\n### Solution\r\n\r\n### 题目分析\r\n\r\n- k一定是正整数\r\n- 字符串没有额外空格\r\n- 原始数据不包括数字\r\n\r\n### 思路：\r\n\r\n---\r\n\r\n### 1. 用栈实现括号匹配\r\n\r\n- 给定的字符串可以存储到一个栈中\r\n- 出栈入栈条件为：\r\n    - 如果非`]`，就入栈\r\n    - 如果是`]`，那么就循环出栈，直到找到一个匹配的`[`\r\n- 注意数字如果是两位数，需要处理，所以为了方便，我们先把数字解析出来，变成一个元素存储在栈中，这样每次匹配左右括号时，可以直接取左括号的上一位元素进行复制操作即可\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stk = []\r\n\r\n        for i in s:\r\n            try:    # 使用try，可以方便地对当前字符是否是数字进行判断\r\n                num = int(i)    # 这里的int(i)要单独占一行赋值语句\r\n                num = stk.pop()*10 + num if stk and isinstance(stk[-1], int) else num\r\n                stk.append(num)\r\n            except ValueError:\r\n                if i == ']':\r\n                    tmp = i\r\n                    while tmp[0] != '[':    # 循环pop，直到遇到了左括号\r\n                        tmp = stk.pop() + tmp\r\n                    stk.append(stk.pop()*tmp[1:-1])    # 解码后，重新压入栈\r\n                else:\r\n                    stk.append(i)\r\n        return ''.join(stk)\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令N为字符串长度\r\n\r\n时间复杂度：O(N) 只遍历了字符串一次，所以为线性复杂度\r\n\r\n空间复杂度：O(N) 使用了栈存储，所以为线性复杂度\r\n\r\n### 2. DFS\r\n\r\n递归写的不是很熟练，参考西法大佬的题解，将栈版本的代码改动成了递归\r\n\r\n详见代码注释\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        def dfs(i):   # 每次递归，传入的参数是索引， 表示在字符串的位置\r\n            num, ans = 0, ''    # 记得每次递归都将变量重新初始化一下\r\n            while i < len(s):\r\n                try:    # 使用try，不过这里直接加上 num*10，处理多位数字的情况\r\n                    num = num*10 + int(s[i])\r\n                except ValueError:   # 在抛出的异常中，处理字符串\r\n                    if s[i] == '[':   # 左括号的话，进入递归\r\n                        i, tmp = dfs(i+1)   # 更新索引 i\r\n                        ans += num*tmp   # 将当前递归层的ans加上内层的返回结果\r\n                        num = 0\r\n                    elif s[i] == ']':   # 右括号直接返回\r\n                        return i, ans\r\n                    else:\r\n                        ans += s[i]\r\n                i += 1\r\n            return ans\r\n        return dfs(0)\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令N为字符串长度\r\n\r\n时间复杂度：O(N) 递归其实更新了索引，所以还是只遍历了字符串一次，为线性复杂度\r\n\r\n空间复杂度：O(N) 极端情况下，递归调用栈的深度为N/2，比如`[[[[]]]]`，所以为线性复杂度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840668982","body":"### [232\\. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\r\n\r\nDifficulty: **简单**\r\n\r\n### Solution\r\n\r\n### 辅助栈\r\n\r\npush与peek的操作不说，但是pop的操作，如果只定义一个栈的话，想要实现队列的先入先出特性，在pop时，需要先将所有元素拿出来，然后pop掉栈底的元素，再放进去，这样的时间复杂度是线性的，所以我们可以使用空间换取时间\r\n\r\n定义一个辅助栈，然后每次pop时都执行以下操作\r\n\r\n- 辅助栈是否为空，是的话将主栈中所有元素添加到辅助栈中，注意这个添加的过程的倒序的，相当于辅助栈的栈顶就是队列的队首\r\n- 如果辅助栈不为空，或者已经执行完了第一步，那么直接返回辅助栈的栈顶元素即可\r\n\r\n```python\r\nclass MyQueue:\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stk = []\r\n        self.aid = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stk.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.aid:\r\n            while self.stk:\r\n                self.aid.append(self.stk.pop())\r\n        return self.aid.pop()\r\n        \r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.aid: return self.stk[0]\r\n        else: return self.aid[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return True if not self.stk and not self.aid else False\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令队列元素为N个\r\n\r\n时间复杂度：均为O(1)\r\n\r\n空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LeahLuo0903":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838427280","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        \r\n        int n = s.size();\r\n        vector<int> ans(s.size(), -n);\r\n            \r\n        int prev = -n;  \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) prev = i;\r\n            ans[i] = i - prev; \r\n        }\r\n        \r\n        // 不需要从最后开始遍历\r\n        // 从最后一次该字母出现处往前遍历\r\n        for (int i = prev - 1; i >= 0; i--) {\r\n            if (s[i] == c) prev = i;\r\n            ans[i] = min(ans[i], prev - i); \r\n        } \r\n        return ans; \r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838427280","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        \r\n        int n = s.size();\r\n        vector<int> ans(s.size(), -n);\r\n            \r\n        int prev = -n;  \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) prev = i;\r\n            ans[i] = i - prev; \r\n        }\r\n        \r\n        // 不需要从最后开始遍历\r\n        // 从最后一次该字母出现处往前遍历\r\n        for (int i = prev - 1; i >= 0; i--) {\r\n            if (s[i] == c) prev = i;\r\n            ans[i] = min(ans[i], prev - i); \r\n        } \r\n        return ans; \r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"p76":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838435741","body":"> ### 思路\r\n> 1.将字符串转成数组。\r\n2.遍历字符串数组，获取字符c在字符串数组中的坐标，生成坐标数组。\r\n3.再次遍历，获取字符串中其他字符与字符c的最近距离。\r\n \r\n> ### 代码\r\n``` \r\nvar shortestToChar = function (s, c) {\r\n    let sArr = s.split('');\r\n    let itemIndex = [];\r\n    let answerArr = [];\r\n    for (let i = 0; i < sArr.length; i++) {\r\n        if (sArr[i] === c) {\r\n            itemIndex.push(i);\r\n        }\r\n    }\r\n    for (let n = 0; n < sArr.length; n++) {\r\n        if (sArr[n] === c) {\r\n            answerArr.push(0);\r\n        } else {\r\n            let idx = sArr.length;\r\n            for (let j = 0; j < itemIndex.length; j++) {\r\n                let countNum = Math.abs(n - itemIndex[j]);\r\n                if (idx > countNum) {\r\n                    idx = countNum;\r\n                }\r\n            }\r\n            answerArr.push(idx);\r\n        }\r\n    }\r\n    return answerArr;\r\n};\r\n```\r\n> ### 复杂度\r\n时间复杂度O(n);\r\n空间复杂度O(1);"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838435741","body":"> ### 思路\r\n> 1.将字符串转成数组。\r\n2.遍历字符串数组，获取字符c在字符串数组中的坐标，生成坐标数组。\r\n3.再次遍历，获取字符串中其他字符与字符c的最近距离。\r\n \r\n> ### 代码\r\n``` \r\nvar shortestToChar = function (s, c) {\r\n    let sArr = s.split('');\r\n    let itemIndex = [];\r\n    let answerArr = [];\r\n    for (let i = 0; i < sArr.length; i++) {\r\n        if (sArr[i] === c) {\r\n            itemIndex.push(i);\r\n        }\r\n    }\r\n    for (let n = 0; n < sArr.length; n++) {\r\n        if (sArr[n] === c) {\r\n            answerArr.push(0);\r\n        } else {\r\n            let idx = sArr.length;\r\n            for (let j = 0; j < itemIndex.length; j++) {\r\n                let countNum = Math.abs(n - itemIndex[j]);\r\n                if (idx > countNum) {\r\n                    idx = countNum;\r\n                }\r\n            }\r\n            answerArr.push(idx);\r\n        }\r\n    }\r\n    return answerArr;\r\n};\r\n```\r\n> ### 复杂度\r\n时间复杂度O(n);\r\n空间复杂度O(1);"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840655306","body":">### 思路\r\n遍历s字符串，遇到数字时，将字符串转成数字保存至num变量。遇到字符时，将字符进行拼接保存至res变量，遇到‘[’时，res和num分别存入strStack、mulStack栈中，并且将res和num变量分别重置为‘’和[]，遇到']'时，将strStack的栈顶元素出栈，并且进行重复操作。\r\n\r\n>### 代码 \r\n```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s) {\r\n   let mulStack = [], strStack = [], num = 0, res = ''\r\n    for (const c of s) {   \r\n        if (!isNaN(c)) {  \r\n            num = num * 10 + (c - '0')\r\n        } else if (c == '[') {  \r\n            strStack.push(res)\r\n            mulStack.push(num) \r\n            res = '' \r\n            num = 0\r\n        } else if (c == ']') {  \r\n            res = strStack.pop() + res.repeat(mulStack.pop())\r\n        } else {                   \r\n            res += c\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n>### 复杂度\r\n时间复杂度：\r\n空间复杂度：O(s.length)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Ben-Lee95":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838512853","body":"> # 821. 字符的最短距离\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历(正向遍历和反向遍历)\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n> \r\n> 示例 1:\r\n> \r\n> 输入: S = \"loveleetcode\", C = 'e'\r\n> 输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n> 说明:\r\n> \r\n> - 字符串 S 的长度范围为 [1, 10000]。\r\n> - C 是一个单字符，且保证是字符串 S 里的字符。\r\n> - S 和 C 中的所有字母均为小写字母。\r\n> ```\r\n## 思路\r\n- 对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\r\n## 关键点\r\n\r\n-  从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。\r\n从右向左遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。\r\n这两个值取最小就是答案。\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int N = s.length();\r\n        int[] ans = new int[N];\r\n        int prev = -10000;\r\n        \r\n        //从左往右遍历数组\r\n        for(int i = 0; i < N; ++i){\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = 20000;\r\n        //从右往左遍历数组\r\n        for(int i = N-1; i >= 0; --i){\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(1)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838512853","body":"> # 821. 字符的最短距离\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历(正向遍历和反向遍历)\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n> \r\n> 示例 1:\r\n> \r\n> 输入: S = \"loveleetcode\", C = 'e'\r\n> 输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n> 说明:\r\n> \r\n> - 字符串 S 的长度范围为 [1, 10000]。\r\n> - C 是一个单字符，且保证是字符串 S 里的字符。\r\n> - S 和 C 中的所有字母均为小写字母。\r\n> ```\r\n## 思路\r\n- 对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\r\n## 关键点\r\n\r\n-  从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。\r\n从右向左遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。\r\n这两个值取最小就是答案。\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int N = s.length();\r\n        int[] ans = new int[N];\r\n        int prev = -10000;\r\n        \r\n        //从左往右遍历数组\r\n        for(int i = 0; i < N; ++i){\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = 20000;\r\n        //从右往左遍历数组\r\n        for(int i = N-1; i >= 0; --i){\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(1)$\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"RMsboy":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838529779","body":"**思路**\r\n维护一个数组获取c在s中的下标\r\n使用reduce方法对计算最近距离\r\n\r\n**代码**\r\n语言支持：JavaScript\r\nJavaScript Code:\r\n\r\n```\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let resArr = new Array(s.length)\r\n    let temArr = []\r\n    // 包含c字符下标的数组\r\n    for(let i = 0; i < s.length; i++){\r\n        if(s[i] === c){\r\n            temArr.push(i)\r\n        }\r\n    }\r\n    // 使用reduce获取字符串与指定字符串的最短距离\r\n    for(let i = 0; i < s.length; i++){\r\n        resArr[i] = temArr.reduce((value, item) => {\r\n            return Math.min(value, Math.abs(item - i))\r\n        }, 10000)\r\n    }\r\n    return resArr\r\n}\r\n```\r\n\r\n**复杂度分析**\r\nn为s的长度，m为c在s中的重复次数\r\n\r\n时间复杂度：O(mn) \r\n空间复杂度：O(mn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838529779","body":"**思路**\r\n维护一个数组获取c在s中的下标\r\n使用reduce方法对计算最近距离\r\n\r\n**代码**\r\n语言支持：JavaScript\r\nJavaScript Code:\r\n\r\n```\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let resArr = new Array(s.length)\r\n    let temArr = []\r\n    // 包含c字符下标的数组\r\n    for(let i = 0; i < s.length; i++){\r\n        if(s[i] === c){\r\n            temArr.push(i)\r\n        }\r\n    }\r\n    // 使用reduce获取字符串与指定字符串的最短距离\r\n    for(let i = 0; i < s.length; i++){\r\n        resArr[i] = temArr.reduce((value, item) => {\r\n            return Math.min(value, Math.abs(item - i))\r\n        }, 10000)\r\n    }\r\n    return resArr\r\n}\r\n```\r\n\r\n**复杂度分析**\r\nn为s的长度，m为c在s中的重复次数\r\n\r\n时间复杂度：O(mn) \r\n空间复杂度：O(mn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840646642","body":"// 时间不够，先抄一遍，再来仔细琢磨\r\n\r\n```/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  const stack = [];\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] != ']'){\r\n      stack.push(s[i])\r\n    }else if(s[i] == ']'){\r\n      let temp = ''\r\n      while(stack[stack.length - 1] != '['){\r\n        temp = stack.pop() + temp;\r\n      }\r\n      stack.pop() //这一步一定是'['\r\n\r\n      let num = ''\r\n      while(stack[stack.length - 1] >= '0' && stack[stack.length - 1] <= '9'){\r\n        num = stack.pop() + num\r\n      }\r\n\r\n      temp = temp.repeat(parseInt(num))\r\n      stack.push(temp)\r\n    }\r\n  }\r\n  return stack.join('');\r\n};```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"XiaoY0324":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838586771","body":"```js\r\n// 每个元素往两边扫描 取最小值\r\nvar shortestToChar = function(s, c) {\r\n  let stringArr = s.split('');\r\n  let res = [];\r\n  let startIdx = 0; // 起始扫描下标\r\n  \r\n  // 递归开始\r\n  findMinIdx(startIdx, stringArr, c, res);\r\n\r\n  // 结果返回\r\n  return res;\r\n};\r\n\r\nconsole.log(\"baaa\", \"b\");\r\nvar findMinIdx = function(startIdx, stringArr, c, res) {\r\n  // 递归终止条件\r\n  if (res.length == stringArr.length) return;\r\n\r\n  let total;\r\n\r\n  for (let i = startIdx; i < stringArr.length; i++) { // 往右扫\r\n    console.warn(`正向扫startIdx: ${ startIdx }`, `i: ${ i }`);\r\n    if (stringArr[i] == c) {\r\n      let curIdx = Math.abs(i - startIdx);\r\n      total = curIdx; // 移动差值\r\n      break;\r\n    }\r\n  }\r\n\r\n  for (let j = startIdx; j >= 0 ; j--) { // 往左扫 注意 j 为 0 也要扫 扫的是 0 位置的元素 比如 'baaa' 和 'b'，0 位置相等。\r\n    console.error(`反向扫startIdx: ${ startIdx }`, `j: ${ j }`);\r\n    if (stringArr[j] == c) {\r\n      console.error(j, '------------');\r\n      let curIdx = Math.abs(j - startIdx);\r\n      \r\n      if (total) {\r\n        total = total > curIdx ? curIdx : total; // 最小移动差值\r\n      } else { // 如果上一个往右扫没有满足条件，这里 total 就为 undefined，做下兼容。\r\n        total = curIdx;\r\n      }\r\n      \r\n      break;\r\n    }\r\n  }\r\n\r\n  res.push(total);\r\n  return findMinIdx(startIdx + 1, stringArr, c, res);\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838586771","body":"```js\r\n// 每个元素往两边扫描 取最小值\r\nvar shortestToChar = function(s, c) {\r\n  let stringArr = s.split('');\r\n  let res = [];\r\n  let startIdx = 0; // 起始扫描下标\r\n  \r\n  // 递归开始\r\n  findMinIdx(startIdx, stringArr, c, res);\r\n\r\n  // 结果返回\r\n  return res;\r\n};\r\n\r\nconsole.log(\"baaa\", \"b\");\r\nvar findMinIdx = function(startIdx, stringArr, c, res) {\r\n  // 递归终止条件\r\n  if (res.length == stringArr.length) return;\r\n\r\n  let total;\r\n\r\n  for (let i = startIdx; i < stringArr.length; i++) { // 往右扫\r\n    console.warn(`正向扫startIdx: ${ startIdx }`, `i: ${ i }`);\r\n    if (stringArr[i] == c) {\r\n      let curIdx = Math.abs(i - startIdx);\r\n      total = curIdx; // 移动差值\r\n      break;\r\n    }\r\n  }\r\n\r\n  for (let j = startIdx; j >= 0 ; j--) { // 往左扫 注意 j 为 0 也要扫 扫的是 0 位置的元素 比如 'baaa' 和 'b'，0 位置相等。\r\n    console.error(`反向扫startIdx: ${ startIdx }`, `j: ${ j }`);\r\n    if (stringArr[j] == c) {\r\n      console.error(j, '------------');\r\n      let curIdx = Math.abs(j - startIdx);\r\n      \r\n      if (total) {\r\n        total = total > curIdx ? curIdx : total; // 最小移动差值\r\n      } else { // 如果上一个往右扫没有满足条件，这里 total 就为 undefined，做下兼容。\r\n        total = curIdx;\r\n      }\r\n      \r\n      break;\r\n    }\r\n  }\r\n\r\n  res.push(total);\r\n  return findMinIdx(startIdx + 1, stringArr, c, res);\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840540108","body":"```js\r\n/**\r\n * @desc 题解：https://algo91.herokuapp.com/solutionDetail?type=3&id=4&max_id=2 这道题没想出来\r\n * @param {string} s\r\n * @return {string}\r\n */\r\n\r\n// 最符合直觉的版本 利用栈\r\nvar decodeString = function(s) {\r\n  var stack = []; // 栈 字符串首部依次压入栈\r\n  \r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] == ']') {\r\n      let pop = stack.pop(); // 栈顶取出 并记录值 \r\n      let repeatStr = pop; // 要 repeat 的字符串                                \r\n      \r\n      // 栈顶不是 \"[\" 时，再出栈的说明是要 repeat 的字符串\r\n      while(pop !== '[') {\r\n        pop = stack.pop(); // 总会多一次 pop 也就是 pop 为 '['\r\n        pop !== '[' && (repeatStr = pop + repeatStr); // 要 repeat 的字符串 注意要 pop + repeatStr，不能 repeatStr + pop, 不然可能乱序\r\n      }\r\n                                          \r\n      // -------------  要 repeat 的字符串已经出栈, 开始处理要 repeat 的次数   ---------------\r\n      pop = stack.pop();\r\n      let repeatCount = pop; // 要 repeat 的次数\r\n      \r\n      // 栈顶是一个数字的时候\r\n      while(!isNaN(pop)) {\r\n        pop = stack.pop(); // 总会多 pop 一次, 后面要 push 回来\r\n        !isNaN(pop) && (repeatCount = pop + repeatCount); // 字符串形式的数字 直接拼接                                 \r\n      }\r\n      \r\n      pop && stack.push(pop); //  要 Push 回来\r\n      stack.push(repeatStr.repeat(repeatCount));\r\n    } else {\r\n       stack.push(s[i]);\r\n      console.log(stack);\r\n    }\r\n  }\r\n  \r\n  return stack.join('');\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"breadfruit":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838590094","body":"## 思路\r\n遍历当前数组，分别从两边开始寻找，知道两边分别找到指定字符，然后取最小值加入结果数组。\r\n## 代码\r\n语言支持：Python3\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        for i in range(len(s)):\r\n            l = r =i\r\n            while l > -1:\r\n                if s[l] == c: break\r\n                l -= 1\r\n            while r < len(s):\r\n                if s[r] == c: break\r\n                r += 1\r\n            if l == -1: l = -10000\r\n            if r == len(s): r = 20000\r\n            ans.append(min(r-i,i-l))\r\n        return ans\r\n```\r\n## 复杂度\r\n- 时间复杂度：O(N^2)\r\n- 空间复杂度：O(1)\r\n题目的数据范围是 10000，所以 [-10000,20000]"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838590094","body":"## 思路\r\n遍历当前数组，分别从两边开始寻找，知道两边分别找到指定字符，然后取最小值加入结果数组。\r\n## 代码\r\n语言支持：Python3\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        for i in range(len(s)):\r\n            l = r =i\r\n            while l > -1:\r\n                if s[l] == c: break\r\n                l -= 1\r\n            while r < len(s):\r\n                if s[r] == c: break\r\n                r += 1\r\n            if l == -1: l = -10000\r\n            if r == len(s): r = 20000\r\n            ans.append(min(r-i,i-l))\r\n        return ans\r\n```\r\n## 复杂度\r\n- 时间复杂度：O(N^2)\r\n- 空间复杂度：O(1)\r\n题目的数据范围是 10000，所以 [-10000,20000]"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840554020","body":"# 辅助栈\r\n## 思路\r\n首先理清楚，我们要判断的值有哪一些，什么时候进栈，什么时候出栈，栈里面存的是什么\r\n1. 我们首先要判断的参数有四种，分别是'[', ']', 数字，字母。\r\n2. 我们的值是'['的时候进栈，']'的时候出栈\r\n3. 用res 记录括号[]里面的字符串res \r\n4. 栈里面存两个变量一个是两个[ [ 做括号之间的字符串用来与当前res进行拼接，一个是记录当前res需要重复的次数\r\n## 代码\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n# dfs\r\n## 思路\r\n我们要理清dfs的参数是什么，终止条件是什么，递归的工作是什么\r\n1. dfs的参数是当前字符串，开始循环的下标\r\n2. 终止条件是下标超标\r\n3. 递归的工作是从i+1往下继续搜索\r\n## 代码思想\r\n当 s[i] == ']' 时，返回当前括号内记录的 res 字符串与 ] 的索引 i （更新上层递归指针位置）；\r\n当 s[i] == '[' 时，开启新一层递归，记录此 [...] 内字符串 tmp 和递归后的最新索引 i，并执行 res + multi * tmp 拼接字符串。\r\n遍历完毕后返回 res。\r\n## 代码\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        def dfs(s, i):\r\n            res, multi = \"\", 0\r\n            while i < len(s):\r\n                if '0' <= s[i] <= '9':\r\n                    multi = multi * 10 + int(s[i])\r\n                elif s[i] == '[':\r\n                    i, tmp = dfs(s, i + 1)\r\n                    res += multi * tmp\r\n                    multi = 0\r\n                elif s[i] == ']':\r\n                    return i, res\r\n                else:\r\n                    res += s[i]\r\n                i += 1\r\n            return res\r\n        return dfs(s,0)\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luoluomo":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838597001","body":"# 思路\r\n  正向和逆向分别遍历数组，计算和上一个目标字符的最短距离，保留两次遍历中较小的距离\r\n  实现时下面的边界条件，容易出现问题\r\n  let lastC = Number.MIN_SAFE_INTEGER;\r\n  lastC = Number.MAX_SAFE_INTEGER;\r\n# 代码\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const number = new Array(s.length).fill(Number.MAX_SAFE_INTEGER);\r\n    const strs = s.split(\"\");\r\n    let lastC = Number.MIN_SAFE_INTEGER;\r\n    strs.forEach((item, index) => {\r\n        if(item === c){\r\n            number[index] = 0;\r\n            lastC = index;\r\n        }else{\r\n            number[index] = index - lastC;\r\n        }\r\n    })\r\n    lastC = Number.MAX_SAFE_INTEGER;\r\n    for(let i = strs.length - 1; i >= 0; i--){\r\n        if(strs[i] === c){\r\n            number[i] = 0;\r\n            lastC = i;\r\n        }else{\r\n            number[i] = Math.min(number[i], lastC - i);\r\n        }\r\n    }\r\n\r\n    return number;\r\n};\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838597001","body":"# 思路\r\n  正向和逆向分别遍历数组，计算和上一个目标字符的最短距离，保留两次遍历中较小的距离\r\n  实现时下面的边界条件，容易出现问题\r\n  let lastC = Number.MIN_SAFE_INTEGER;\r\n  lastC = Number.MAX_SAFE_INTEGER;\r\n# 代码\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const number = new Array(s.length).fill(Number.MAX_SAFE_INTEGER);\r\n    const strs = s.split(\"\");\r\n    let lastC = Number.MIN_SAFE_INTEGER;\r\n    strs.forEach((item, index) => {\r\n        if(item === c){\r\n            number[index] = 0;\r\n            lastC = index;\r\n        }else{\r\n            number[index] = index - lastC;\r\n        }\r\n    })\r\n    lastC = Number.MAX_SAFE_INTEGER;\r\n    for(let i = strs.length - 1; i >= 0; i--){\r\n        if(strs[i] === c){\r\n            number[i] = 0;\r\n            lastC = i;\r\n        }else{\r\n            number[i] = Math.min(number[i], lastC - i);\r\n        }\r\n    }\r\n\r\n    return number;\r\n};\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"QiuhaoLi":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838597599","body":"## 思路\r\n\r\n使用双指针，分别指向匹配字符。从左向右扫描并更新距离，当发现新的匹配字符更新第二个指针时，进行回溯更新距离（与第一个指针间一半的字符需要更新）。\r\n\r\n要考虑到可能只有一个匹配字符（第二个指针为空）。\r\n\r\n## 代码\r\n\r\n```c\r\n/**\r\n * Note: The returned array must be malloced, assume caller calls free().\r\n */\r\nint* shortestToChar(char * s, char c, int* returnSize){\r\n    size_t string_size = strlen(s);\r\n    *returnSize = string_size;\r\n    if (string_size == 0)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    int *distance = malloc(string_size * sizeof(int));\r\n    //error handling\r\n\r\n    long index_c_first = -1;\r\n    long index_c_second = -1;\r\n\r\n    for (long i = 0; i < string_size; ++i)\r\n    {\r\n        if (s[i] == c)\r\n        {\r\n            if (index_c_first == -1)\r\n            {\r\n                index_c_first = i;\r\n                for (long j = index_c_first; j >=0; --j)\r\n                {\r\n                    distance[j] = index_c_first-j;\r\n                }\r\n            }\r\n            else if (index_c_second == -1)\r\n            {\r\n                index_c_second = i;\r\n                for (long j = index_c_second; j > (index_c_second+index_c_first)/2; --j)\r\n                {\r\n                    distance[j] = index_c_second-j;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                long tmp = index_c_second;\r\n                index_c_second = i;\r\n                index_c_first = tmp;\r\n                for (long j = index_c_second; j > (index_c_second+index_c_first)/2; --j)\r\n                {\r\n                    distance[j] = index_c_second-j;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            long index_c = index_c_second == -1 ? index_c_first : index_c_second;\r\n            if (index_c != -1)\r\n            {\r\n                distance[i] = i - index_c;\r\n            }\r\n        }\r\n    }\r\n\r\n    return distance;\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n时间：O(n)\r\n空间：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838597599","body":"## 思路\r\n\r\n使用双指针，分别指向匹配字符。从左向右扫描并更新距离，当发现新的匹配字符更新第二个指针时，进行回溯更新距离（与第一个指针间一半的字符需要更新）。\r\n\r\n要考虑到可能只有一个匹配字符（第二个指针为空）。\r\n\r\n## 代码\r\n\r\n```c\r\n/**\r\n * Note: The returned array must be malloced, assume caller calls free().\r\n */\r\nint* shortestToChar(char * s, char c, int* returnSize){\r\n    size_t string_size = strlen(s);\r\n    *returnSize = string_size;\r\n    if (string_size == 0)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    int *distance = malloc(string_size * sizeof(int));\r\n    //error handling\r\n\r\n    long index_c_first = -1;\r\n    long index_c_second = -1;\r\n\r\n    for (long i = 0; i < string_size; ++i)\r\n    {\r\n        if (s[i] == c)\r\n        {\r\n            if (index_c_first == -1)\r\n            {\r\n                index_c_first = i;\r\n                for (long j = index_c_first; j >=0; --j)\r\n                {\r\n                    distance[j] = index_c_first-j;\r\n                }\r\n            }\r\n            else if (index_c_second == -1)\r\n            {\r\n                index_c_second = i;\r\n                for (long j = index_c_second; j > (index_c_second+index_c_first)/2; --j)\r\n                {\r\n                    distance[j] = index_c_second-j;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                long tmp = index_c_second;\r\n                index_c_second = i;\r\n                index_c_first = tmp;\r\n                for (long j = index_c_second; j > (index_c_second+index_c_first)/2; --j)\r\n                {\r\n                    distance[j] = index_c_second-j;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            long index_c = index_c_second == -1 ? index_c_first : index_c_second;\r\n            if (index_c != -1)\r\n            {\r\n                distance[i] = i - index_c;\r\n            }\r\n        }\r\n    }\r\n\r\n    return distance;\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n时间：O(n)\r\n空间：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zfaye":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838600080","body":"**思路**：[indexOf](int ch）[indexOf](int ch,  int fromIndex)获取前后两个指针，取小的绝对距离\r\n\r\n代码：\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        //int[] index=new int[s.length()];\r\n        int cur=s.indexOf(c);int pre=cur;\r\n       // Iterator<Integer> it=index.iterator();\r\n        int[] ans=new int[s.length()];\r\n        for(int i=0;i<s.length();i++){\r\n            if(s.charAt(i)== c) {\r\n               ans[i]=0;\r\n               pre=i;\r\n               cur=s.indexOf(c,i+1);\r\n            }else{\r\n                ans[i]=Math.min(Math.abs(i-pre),Math.abs(cur-i));\r\n             }\r\n\r\n\r\n        }\r\n\r\n\r\n    return ans;\r\n\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)?"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838600080","body":"**思路**：[indexOf](int ch）[indexOf](int ch,  int fromIndex)获取前后两个指针，取小的绝对距离\r\n\r\n代码：\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        //int[] index=new int[s.length()];\r\n        int cur=s.indexOf(c);int pre=cur;\r\n       // Iterator<Integer> it=index.iterator();\r\n        int[] ans=new int[s.length()];\r\n        for(int i=0;i<s.length();i++){\r\n            if(s.charAt(i)== c) {\r\n               ans[i]=0;\r\n               pre=i;\r\n               cur=s.indexOf(c,i+1);\r\n            }else{\r\n                ans[i]=Math.min(Math.abs(i-pre),Math.abs(cur-i));\r\n             }\r\n\r\n\r\n        }\r\n\r\n\r\n    return ans;\r\n\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)?"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840356324","body":"思路：使用一个栈实现。在遇到右括号时出栈，使用栈的peek()方法，一直出栈，直到遇到左括号。将字符串和次数相乘后入栈。\r\n\r\n```\r\nclass Solution {\r\n\r\n    public String decodeString(String s) {\r\n\r\n        Stack<String> st= new Stack<>();\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == ']') {\r\n                StringBuilder repeatStr = new StringBuilder();\r\n                while (!st.peek().equals(\"[\")) repeatStr.append(st.pop()) ;\r\n\r\n                st.pop();//删去“[”\r\n                StringBuilder scount = new StringBuilder();\r\n                while ((!st.isEmpty()) && (st.peek().charAt(0) >= '0' && st.peek().charAt(0) <= '9')) {\r\n                    scount.append(st.pop()) ;\r\n                }\r\n                scount=scount.reverse();\r\n                int count = Integer.parseInt(scount.toString());\r\n                StringBuilder res = new StringBuilder();;\r\n                for (int j = 0; j < count; j++) res.append(repeatStr) ;\r\n                st.push(res.toString());\r\n            } else {\r\n                String str = \"\" + s.charAt(i);\r\n                st.push(str);\r\n            }\r\n\r\n        }\r\n        StringBuilder ans=new StringBuilder();\r\n        while(!st.isEmpty()){\r\n            ans.append(st.pop());\r\n        }\r\n        ans.reverse();\r\n        return ans.toString();\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"winterdogdog":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838615479","body":"```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let array = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        array[i] = s.length;\r\n    }\r\n    for (let i = 0; i < s.length; i++){\r\n        if ( s.substring(i, i+1) === c){\r\n            for (let j = 0; j < s.length; j++){\r\n                array[j] = Math.min(Math.abs(i - j),array[j])\r\n            }\r\n        }\r\n    }\r\n    return array;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838615479","body":"```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let array = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        array[i] = s.length;\r\n    }\r\n    for (let i = 0; i < s.length; i++){\r\n        if ( s.substring(i, i+1) === c){\r\n            for (let j = 0; j < s.length; j++){\r\n                array[j] = Math.min(Math.abs(i - j),array[j])\r\n            }\r\n        }\r\n    }\r\n    return array;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840593759","body":"```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let numStack = [], stringStack = [], num = 0, result = '';\r\n    for(let cur of s) {\r\n        if (\"0\" <= cur && cur <= \"9\") {\r\n            num = num * 10 + Number(cur)\r\n        } else if (cur === '[') {\r\n            stringStack.push(result);\r\n            numStack.push(num);\r\n            result = '';\r\n            num = 0;\r\n        } else if (cur === ']') {\r\n            let newNum = numStack.pop();\r\n            result = stringStack.pop() + result.repeat(newNum);\r\n        } else {\r\n            result = result + cur\r\n        }\r\n    }\r\n    return result\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"NealChristmas":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838633616","body":"```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n\r\n    const stackRight = []\r\n    const stackLeft = []\r\n    for (let i = 0; i < s.length; i++) {\r\n        const char = s[i]\r\n        if (char === c) {\r\n            stackRight.unshift(i)\r\n        }\r\n    }\r\n    let i = 0\r\n    const res = []\r\n    while (i < s.length) {\r\n        let topRight = stackRight[stackRight.length - 1]\r\n        if (topRight !== undefined && i > topRight) {\r\n            stackLeft.push(stackRight.pop())\r\n        }\r\n        topRight = stackRight[stackRight.length - 1] === undefined ? Number.MAX_SAFE_INTEGER : stackRight[stackRight.length - 1]\r\n        let topLeft = stackLeft[stackLeft.length - 1] === undefined ? Number.MAX_SAFE_INTEGER : stackLeft[stackLeft.length - 1]\r\n        const minDis = Math.min(Math.abs(i - topLeft), Math.abs(i - topRight))\r\n        i++\r\n        res.push(minDis)\r\n    }\r\n    return res\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838633616","body":"```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n\r\n    const stackRight = []\r\n    const stackLeft = []\r\n    for (let i = 0; i < s.length; i++) {\r\n        const char = s[i]\r\n        if (char === c) {\r\n            stackRight.unshift(i)\r\n        }\r\n    }\r\n    let i = 0\r\n    const res = []\r\n    while (i < s.length) {\r\n        let topRight = stackRight[stackRight.length - 1]\r\n        if (topRight !== undefined && i > topRight) {\r\n            stackLeft.push(stackRight.pop())\r\n        }\r\n        topRight = stackRight[stackRight.length - 1] === undefined ? Number.MAX_SAFE_INTEGER : stackRight[stackRight.length - 1]\r\n        let topLeft = stackLeft[stackLeft.length - 1] === undefined ? Number.MAX_SAFE_INTEGER : stackLeft[stackLeft.length - 1]\r\n        const minDis = Math.min(Math.abs(i - topLeft), Math.abs(i - topRight))\r\n        i++\r\n        res.push(minDis)\r\n    }\r\n    return res\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raoshuang":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838653080","body":"- 暴力解法：遍历找出c字符的所有下标，然后找再次遍历找出最小值\r\n-class Solution {\r\npublic:\r\n    vector<int> s1;\r\n    vector<int> s2;\r\n   \r\n    vector<int> shortestToChar(string s, char c) {\r\n    for(int i=0;i<s.length();++i){\r\n        if(s[i] == c){\r\n            s1.push_back(i);\r\n        }\r\n    } \r\n    \r\n    for(int i=0;i<s.length();++i){\r\n        int len=s.length(),minlen=s.length();\r\n        for(int j=0;j<s1.size();++j){\r\n            len = abs(s1[j]-i);\r\n            minlen = min(len,minlen);\r\n        }\r\n        s2.push_back(minlen);\r\n\r\n    }\r\n    return s2;\r\n    }\r\n};"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838653080","body":"- 暴力解法：遍历找出c字符的所有下标，然后找再次遍历找出最小值\r\n-class Solution {\r\npublic:\r\n    vector<int> s1;\r\n    vector<int> s2;\r\n   \r\n    vector<int> shortestToChar(string s, char c) {\r\n    for(int i=0;i<s.length();++i){\r\n        if(s[i] == c){\r\n            s1.push_back(i);\r\n        }\r\n    } \r\n    \r\n    for(int i=0;i<s.length();++i){\r\n        int len=s.length(),minlen=s.length();\r\n        for(int j=0;j<s1.size();++j){\r\n            len = abs(s1[j]-i);\r\n            minlen = min(len,minlen);\r\n        }\r\n        s2.push_back(minlen);\r\n\r\n    }\r\n    return s2;\r\n    }\r\n};"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840653187","body":"思路：用两个栈来解决\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<string> let;\r\n        stack<int> num;\r\n\r\n        string ans = \"\";\r\n        int cur = 0;\r\n\r\n        for(const char& c : s)\r\n        {\r\n            if(isdigit(c))\r\n                cur = cur*10 + c - '0';\r\n            else if(c == '[')\r\n            {\r\n                let.push(ans);\r\n                num.push(cur);\r\n                cur = 0;\r\n                ans = \"\";\r\n            }\r\n            else if(c == ']')\r\n            {\r\n                string str = ans;\r\n                for(int i = 0; i < num.top()-1; ++i)\r\n                    ans += str;\r\n                ans = let.top() + ans;\r\n                num.pop();\r\n                let.pop();\r\n            }\r\n            else\r\n                ans += c;\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaoyuhai":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838666444","body":"/**\r\n* 找出左右两边距离最近的，再取其中最小的\r\n*/ \r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] result = new int[s.length()];\r\n        int pre = -2000;\r\n        for(int i =0; i < s.length(); i++){\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n            result[i] = i - pre;\r\n        }\r\n        pre = 2000;\r\n        for(int i = s.length() -1 ; i >=0; i--){\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n            result[i] = Math.min(result[i],pre-i);\r\n        }\r\n        return result;\r\n    }"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838666444","body":"/**\r\n* 找出左右两边距离最近的，再取其中最小的\r\n*/ \r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] result = new int[s.length()];\r\n        int pre = -2000;\r\n        for(int i =0; i < s.length(); i++){\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n            result[i] = i - pre;\r\n        }\r\n        pre = 2000;\r\n        for(int i = s.length() -1 ; i >=0; i--){\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n            result[i] = Math.min(result[i],pre-i);\r\n        }\r\n        return result;\r\n    }"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840648761","body":"算法流程：\r\n\r\n构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\r\n\r\n当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\r\n\r\n当 c 为字母时，在 res 尾部添加 c；\r\n\r\n当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 00：\r\n\r\n记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\r\n\r\n记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\r\n\r\n进入到新 [ 后，res 和 multi 重新记录。\r\n\r\n当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\r\n\r\nlast_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\r\n\r\ncur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\r\n\r\n返回字符串 res。\r\n\r\n复杂度分析：\r\n\r\n时间复杂度 O(N)O(N)，一次遍历 s；\r\n\r\n空间复杂度 O(N)O(N)，辅助栈在极端情况下需要线性空间，例如 2[2[2[a]]]\r\n\r\n代码\r\n\r\n    public String decodeString(String s) {\r\n            StringBuilder res = new StringBuilder();\r\n            int multi = 0;\r\n            LinkedList<Integer> stack_multi = new LinkedList<>();\r\n            LinkedList<String> stack_res = new LinkedList<>();\r\n            for (Character c : s.toCharArray()) {\r\n                if (c == '[') {\r\n                    stack_multi.addLast(multi);\r\n                    stack_res.addLast(res.toString());\r\n                    multi = 0;\r\n                    res = new StringBuilder();\r\n                    continue;\r\n                }\r\n                if (c == ']') {\r\n                    StringBuilder tmp = new StringBuilder();\r\n                    int cur_multi = stack_multi.removeLast();\r\n                    for (int i = 0; i < cur_multi; i++) tmp.append(res);\r\n                    res = new StringBuilder(stack_res.removeLast() + tmp);\r\n                    continue;\r\n                }\r\n                if (Character.isDigit(c)) {\r\n                    multi = multi * 10 + Integer.parseInt(c + \"\");\r\n                    continue;\r\n                }\r\n                res.append(c);\r\n            }\r\n            return res.toString();\r\n    \r\n        }\r\n\r\n\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mayu0007":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838671847","body":"### 思路\r\n\r\n参考了参考答案的动态规划。\r\n双次遍历数组 \r\n- dp数组状态量：与上一个c的距离\r\n\r\n  左遍历\r\n    - 状态转移方程：```dp[i] = dp[i-1] + 1 ```\r\n    - 边界条件：```if s[i] == c: dp[i] = 0 ```\r\n\r\n  右遍历\r\n    - 状态转移方程：```dp[i] = min(dp[i+1] + 1, dp[i]) ```\r\n    - 边界条件：```if s[i] == c: dp[i] = 0 ```\r\n\r\n### caveat\r\n不要忘记check index的范围\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        # traverse 2 times \r\n        # left to right: each element store distance to the nearest C met before (on the LEFT).\r\n        # right to left: each element store the distance to the nearest C on the RIGHT. \r\n        # compare the value of both. \r\n        # initialize array with inf\r\n        \"\"\"\r\n        # 参考答案的prev initialization有点难理解\r\n        result = []\r\n        prev = -float('inf')\r\n        for i, elem in enumerate(s):\r\n            if elem == c:\r\n                prev = i \r\n            result[i] = i - prev \r\n\r\n        prev = float('inf')\r\n        for i in range(len(s)-1,0,-1):\r\n            if s[i] == c:\r\n                prev = i \r\n            result[i] = min(prev-i, result[i])\r\n        return result\r\n        \"\"\"\r\n        dp = [float('inf')]*len(s) # float('inf') is a number bigger than all others \r\n        \"\"\"\r\n        num = float('inf')\r\n        print(num > 1000) #True\r\n        print(num + 1 == num) #True \r\n        print(num-1) #inf\r\n        \"\"\"\r\n        for i, elem in enumerate(s):\r\n            if elem == c:\r\n                dp[i] = 0 \r\n            elif i > 0: #index range checking\r\n                dp[i] = dp[i-1] + 1\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                dp[i] = 0 \r\n            elif i < len(s)-1: #index range checking\r\n                dp[i] = min(dp[i+1] + 1, dp[i])\r\n                \r\n        return dp\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，N 为数组`s`的长度，两次遍历\r\n- 空间复杂度：O(N), N 为数组`s`的长度，也是返回值\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838671847","body":"### 思路\r\n\r\n参考了参考答案的动态规划。\r\n双次遍历数组 \r\n- dp数组状态量：与上一个c的距离\r\n\r\n  左遍历\r\n    - 状态转移方程：```dp[i] = dp[i-1] + 1 ```\r\n    - 边界条件：```if s[i] == c: dp[i] = 0 ```\r\n\r\n  右遍历\r\n    - 状态转移方程：```dp[i] = min(dp[i+1] + 1, dp[i]) ```\r\n    - 边界条件：```if s[i] == c: dp[i] = 0 ```\r\n\r\n### caveat\r\n不要忘记check index的范围\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        # traverse 2 times \r\n        # left to right: each element store distance to the nearest C met before (on the LEFT).\r\n        # right to left: each element store the distance to the nearest C on the RIGHT. \r\n        # compare the value of both. \r\n        # initialize array with inf\r\n        \"\"\"\r\n        # 参考答案的prev initialization有点难理解\r\n        result = []\r\n        prev = -float('inf')\r\n        for i, elem in enumerate(s):\r\n            if elem == c:\r\n                prev = i \r\n            result[i] = i - prev \r\n\r\n        prev = float('inf')\r\n        for i in range(len(s)-1,0,-1):\r\n            if s[i] == c:\r\n                prev = i \r\n            result[i] = min(prev-i, result[i])\r\n        return result\r\n        \"\"\"\r\n        dp = [float('inf')]*len(s) # float('inf') is a number bigger than all others \r\n        \"\"\"\r\n        num = float('inf')\r\n        print(num > 1000) #True\r\n        print(num + 1 == num) #True \r\n        print(num-1) #inf\r\n        \"\"\"\r\n        for i, elem in enumerate(s):\r\n            if elem == c:\r\n                dp[i] = 0 \r\n            elif i > 0: #index range checking\r\n                dp[i] = dp[i-1] + 1\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                dp[i] = 0 \r\n            elif i < len(s)-1: #index range checking\r\n                dp[i] = min(dp[i+1] + 1, dp[i])\r\n                \r\n        return dp\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，N 为数组`s`的长度，两次遍历\r\n- 空间复杂度：O(N), N 为数组`s`的长度，也是返回值\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840607195","body":"## 解题思路1\r\n\r\nNested square brackets need to be processed inside out to generate substrings, which aligns with stack's FILO character\r\n\r\n### Code\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        # 1. stack: push all characters and pop when encounter \"]\" to compute the augmented substring, then push the concatenated substring back onto stack \r\n        stack = []\r\n        for c in s:\r\n            if c == \"]\":\r\n                repeatStr = ''\r\n                repeatMul = ''\r\n                while stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr # Caveat: need to concatenate character in reverse order \r\n                # pop off \"[\" \r\n                stack.pop()\r\n\r\n                while stack and stack[-1].isdigit(): # Caveat: stack is popped every iteration, need to terminate loop when stack is empty to ensure indexing is valid \r\n                    repeatMul = stack.pop() + repeatMul # Caveat: need to concatenate character in reverse order \r\n                stack.append(int(repeatMul)*repeatStr) \r\n            else: \r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n\r\n\r\n\r\n\r\n```\r\n\r\n### Complexity\r\n**Time Complexity**: `O(N)` to traverse the string `s` \\\r\n**Space Complexity**: `O(N)` if keeps pushing all elements into stack before enclosing bracket \r\n\r\n## 解题思路2 \r\n\r\nrecursion. (to-do)\r\n\r\n### Code \r\n```python\r\n\r\n```\r\n### Complexity\r\n**Time Complexity**: `O(N)` to traverse the string `s` \\\r\n**Space Complexity**: `O(N)` for max recursion depth "},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838700474","body":"### 思路分析\r\n1. 遍历两次字符串， 一次从左到右遍历，一次从右到左遍历\r\n2. 两次遍历分别记录s[i]对 c 的距离\r\n3. 两者比较, 保留较小值\r\n\r\n\r\n### 代码实现 JavaScript\r\n\r\n```\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const res = new Array(s.length).fill(Infinity)\r\n\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] === c) res[i] = 0;\r\n    else res[i] = i == 0 ? Infinity : res[i - 1] + 1\r\n  }\r\n\r\n  for(let i = s.length - 1; i >= 0; i--){\r\n    if(res[i] == Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：$O(N)$, N为字符串长度\r\n- 空间复杂度：$O(1)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838700474","body":"### 思路分析\r\n1. 遍历两次字符串， 一次从左到右遍历，一次从右到左遍历\r\n2. 两次遍历分别记录s[i]对 c 的距离\r\n3. 两者比较, 保留较小值\r\n\r\n\r\n### 代码实现 JavaScript\r\n\r\n```\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const res = new Array(s.length).fill(Infinity)\r\n\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] === c) res[i] = 0;\r\n    else res[i] = i == 0 ? Infinity : res[i - 1] + 1\r\n  }\r\n\r\n  for(let i = s.length - 1; i >= 0; i--){\r\n    if(res[i] == Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：$O(N)$, N为字符串长度\r\n- 空间复杂度：$O(1)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840630345","body":"### 思路\r\n1. 将字符串从末尾开始遍历\r\n2. 遇到“]”入栈\r\n3. 拼接要出栈的字符串，遇到\"[\"出栈\r\n4. \"[\"后紧跟数据，累计最终的数字\r\n5. 将遍历后入栈的字符串出栈，进行反转拼接，得到最终结果\r\n\r\n### 代码\r\n\r\n```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\n var decodeString = function(s) {\r\n    let stack = []; // 定义存储字符串的栈\r\n    let str = \"\"; // 定义最终返回的字符串\r\n    let num = \"\"; // 定义字符串重复的次数\r\n    const length = s.length;\r\n    for (let i = length - 1; i >= 0; i--) {\r\n      console.log(\"s[i]\", stack, i);\r\n      if (s[i] >= \"0\" && s[i] <= \"9\") {\r\n        // 解析出连续的数字\r\n        while (s[i] >= \"0\" && s[i] <= \"9\") {\r\n          num += s[i];\r\n          i--;\r\n          console.log(\"num\", num);\r\n        }\r\n        stack.push(\r\n          str.repeat(\r\n            Number(\r\n              num\r\n                .split(\"\")\r\n                .reverse()\r\n                .join(\"\")\r\n            )\r\n          )\r\n        ); // 拼接字符\r\n        str = \"\";\r\n        num = \"\"; //清空计数\r\n        i++;\r\n      } else if (s[i] === \"[\") {\r\n        // 遇到\"[\"时，将后续字符出栈\r\n        let curStr = stack.pop();\r\n        while (curStr !== \"]\") {\r\n          str += curStr;\r\n          curStr = stack.pop(); // 拼接出栈的字符串 \"[\"后跟着的一定是数字\r\n        }\r\n      } else {\r\n        // 将字符 或 \"]\"入栈\r\n        stack.push(s[i]);\r\n      }\r\n    }\r\n    return stack.reverse().join(\"\");\r\n  };\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：$O(N)$\r\n- 空间复杂度：$O(N)$"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AutumnDeSea":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838712904","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 数组和字符串的内存管理\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 数组的正向、反向遍历，是一道简单的左右指针的题目\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    // 字符串转数组的逻辑\r\n    // 数组的正向、反向遍历\r\n    sArr = s.split('')\r\n    const sLen = sArr.length\r\n    let arr = []\r\n    \r\n    for(var i = 0; i< sArr.length ; i++) {\r\n        var s = sArr[i]\r\n        var l = r = i\r\n          // 向左遍历\r\n        while(l > -1) {\r\n            if(sArr[l] == c) {\r\n                break\r\n            }\r\n            l--\r\n        }\r\n        // 像右遍历\r\n        while(r <  sLen) {\r\n            if(sArr[r] == c) {\r\n                break\r\n            }\r\n            r++\r\n        }\r\n        if(l === -1) {\r\n            l = -10000\r\n        }\r\n        if(r === sLen) {\r\n            r = 20000\r\n        }\r\n        var result = Math.min(r-i, i-l)\r\n        arr.push(result)\r\n    }\r\n    return arr\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838712904","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 数组和字符串的内存管理\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 数组的正向、反向遍历，是一道简单的左右指针的题目\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    // 字符串转数组的逻辑\r\n    // 数组的正向、反向遍历\r\n    sArr = s.split('')\r\n    const sLen = sArr.length\r\n    let arr = []\r\n    \r\n    for(var i = 0; i< sArr.length ; i++) {\r\n        var s = sArr[i]\r\n        var l = r = i\r\n          // 向左遍历\r\n        while(l > -1) {\r\n            if(sArr[l] == c) {\r\n                break\r\n            }\r\n            l--\r\n        }\r\n        // 像右遍历\r\n        while(r <  sLen) {\r\n            if(sArr[r] == c) {\r\n                break\r\n            }\r\n            r++\r\n        }\r\n        if(l === -1) {\r\n            l = -10000\r\n        }\r\n        if(r === sLen) {\r\n            r = 20000\r\n        }\r\n        var result = Math.min(r-i, i-l)\r\n        arr.push(result)\r\n    }\r\n    return arr\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyaoyao":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838716666","body":"### 思路分析\r\n中心扩展，每遍历一个元素时候，便向两边扩展，取最小值即可\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> res(n);\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c)\r\n                continue;\r\n            int l = i;\r\n            int r = i;\r\n            int len = 0;\r\n            \r\n            while (l >= 0 || r < n) {\r\n                if (s[l] == c) {\r\n                    len = i - l;\r\n                    break;\r\n                }\r\n                if (s[r] == c) {\r\n                    len = r - i;\r\n                    break;\r\n                }\r\n\r\n                if (l > 0) l--;\r\n                if (r < n) r++;\r\n            }\r\n            res[i] = len;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n## 复杂度\r\n+ 时间复杂度$O(N^2)$\r\n+ 空间复杂度$O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838716666","body":"### 思路分析\r\n中心扩展，每遍历一个元素时候，便向两边扩展，取最小值即可\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> res(n);\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c)\r\n                continue;\r\n            int l = i;\r\n            int r = i;\r\n            int len = 0;\r\n            \r\n            while (l >= 0 || r < n) {\r\n                if (s[l] == c) {\r\n                    len = i - l;\r\n                    break;\r\n                }\r\n                if (s[r] == c) {\r\n                    len = r - i;\r\n                    break;\r\n                }\r\n\r\n                if (l > 0) l--;\r\n                if (r < n) r++;\r\n            }\r\n            res[i] = len;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n## 复杂度\r\n+ 时间复杂度$O(N^2)$\r\n+ 空间复杂度$O(1)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mm12344":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838739105","body":"### 思路\r\n\r\n1. 第一遍正序遍历，遇非e保留序号，遇e存储索引进pre变量，再遇e则更新其索引。返回当前非e数到左边e的距离\r\n2. 第二遍倒序遍历，同上，返回当前非e数到右边e的距离\r\n3. 两者比大小，返回最小值\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        pre = -10000\r\n        ans = []\r\n\r\n        for i in range(len(S)):\r\n            if S[i] == C: pre = i\r\n            ans.append(i - pre)\r\n        pre = 20000\r\n        for i in range(len(S) - 1, -1, -1):\r\n            if S[i] == C: pre = i\r\n            ans[i] = min(ans[i], pre - i)\r\n        return ans\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839716817","body":"### 思路\r\n\r\n给定一个变量来记录栈顶的位置，更新数据来模拟栈的操作，但因为实质是函数内的数组，所以可以实现对除了栈顶元素外的改动。（后续再优化）\r\n\r\n### 代码\r\n\r\n\r\n```py3\r\nclass CustomStack:\r\n# use array in function makes the each elenments in stack \"visable\"\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0]*maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        # if stack size is smaller than maxSize, push in\r\n        # maxSize is not defined in this function, so use len of stack instead\r\n        if self.top < len(self.stk)-1:\r\n            self.stk[self.top+1] = x\r\n            self.top += 1\r\n\r\n    def pop(self) -> int:\r\n        # if stack is empty, return -1\r\n        # if stack is not empty, return the top value and delete it in the stack (no need)\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        # use the minimum value between k and self.stk length, then traverse\r\n        if k>-1:\r\n            for i in range(min(self.top+1,k)):\r\n                self.stk[i]+=val\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(min(k, maxSize)),\r\n- 空间复杂度：O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840631703","body":"### 思路\r\n\r\n1. 本题每层只包含三个信息：左括号前的字符串，左括号前的数字，左括号后的字符串\r\n2. 如果出现嵌套，则暂时存储前两个信息，以同样的方式对左括号后的内容嵌套进行分析\r\n3. 以右括号为标志进行嵌套层信息的弹出分解\r\n\r\n### 代码\r\n```py3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = [] # 暂存嵌套层外的前置信息\r\n        res = \"\" # 当前层的字符串\r\n        num = 0  \r\n        if len(s)>0:\r\n            for c in s:\r\n                if c.isdigit():\r\n                    num = 10*num + int(c)\r\n                elif c.isalpha():\r\n                    res += c\r\n                elif c == \"[\": # 遇到左括号就往栈里存入包含两个信息的元组（[前的字符串，[前的数字）\r\n                    stack.append((res,num))\r\n                    res, num = \"\", 0\r\n                else:\r\n                    # if c == \"]\"， 遇到右括号就开始弹出栈顶元组信息，组成当前层解码后的字符串\r\n                    top = stack.pop()\r\n                    res = top[0] + top[1]*res\r\n        return res\r\n\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(S)\r\n- 空间复杂度：O(S)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Yueqi-19":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839061605","body":"Java version\r\n时间复杂度O（N)\r\n空间复杂度O（N）\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        \r\n        int cur = res.length;\r\n        for(int i = 0; i < res.length;i++){\r\n            cur = s.charAt(i) == c ? 0:cur +1;\r\n            res[i] = cur;\r\n        }\r\n        cur = res.length;\r\n        for(int i = res.length - 1;i>=0;i--){\r\n            cur = s.charAt(i) == c ? 0:cur +1;\r\n            res[i] = res[i] >cur?cur:res[i];\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yinfenglin":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839166298","body":"Python\r\n\r\nclass Solution:\r\n\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        char_indices = [i for i, ltr in enumerate(s) if ltr == c]\r\n        \r\n        distances = []\r\n        for i in range(len(s)):\r\n            d_i = [abs(ci - i) for ci in char_indices]\r\n            distances.append(min(d_i))\r\n            \r\n        return distances"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MangoJuicy":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839447196","body":"## 思路\r\n双向遍历，求取小值\r\n\r\n## 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] left = new int[s.length()];\r\n        // int[] right = new int[s.length()];\r\n        int[] res = new int[s.length()];\r\n        \r\n        int lastIndex = -1;\r\n        for (int i = 0; i < left.length; i++) {\r\n            if (s.charAt(i) == c) {\r\n                left[i] = 0;\r\n                lastIndex = i;\r\n            } else {\r\n                left[i] = (lastIndex == -1) ? Integer.MAX_VALUE : i - lastIndex;\r\n            } \r\n        }\r\n        \r\n        lastIndex = -1;\r\n        for (int i = res.length - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                res[i] = 0;\r\n                lastIndex = i;\r\n            } else {\r\n                int dist = (lastIndex == -1) ? Integer.MAX_VALUE : lastIndex - i;\r\n                res[i] = Math.min(left[i], dist);\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n    \r\n}\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ningali":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839475296","body":"Time Complexity: O(N) \r\nSpace Complexity: O(N)\r\n\r\nJava\r\n\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        char[] chars = s.toCharArray();\r\n        int[] res = new int[length];\r\n        \r\n        int left = -length;\r\n        for (int i = 0; i < length; i++) {\r\n            if (chars[i] == c) {\r\n                left = i;\r\n                res[i] = 0;\r\n            } else {\r\n                res[i] = i - left;\r\n            }\r\n        }\r\n        int right = 2 * length;\r\n        for (int i = length - 1; i >= 0; i--) {\r\n            if (chars[i] == c) {\r\n                right = i;\r\n            } else {\r\n                res[i] = Math.min(right - i, res[i]);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chelseachen007":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839574111","body":"### 解法一\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(n^2)\r\n\r\n空间复杂度: O(1)\r\n\r\n两层遍历，第一层定位坐标，第二层向前向后分别找到一个相同的值后进行距离比较\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n    let res = []\r\n    for (let i = 0; i < S.length; i++) {\r\n        if (S[i] === C) {\r\n            res.push(0)\r\n            continue\r\n        }\r\n        let l = i; r = i; short = Infinity\r\n        while (l >= 0) {\r\n            if (S[l] === C) {\r\n                short = i - l\r\n                break\r\n            }\r\n            l--\r\n        }\r\n        while (r < S.length) {\r\n            if (S[r] === C) {\r\n                short = Math.min(short, r - i)\r\n                break\r\n            }\r\n            r++\r\n        }\r\n        res.push(short)\r\n    }\r\n    return res\r\n};\r\n```\r\n\r\n### 解法二\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度: O(1)\r\n\r\n```js\r\nvar shortestToChar = function (s, c) {\r\n    let res = []\r\n    let carry = - Infinity\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) carry = i\r\n        res[i] = Math.min(i - carry, res[i] || Infinity)\r\n\r\n    }\r\n\r\n    let orCarry = Infinity\r\n    for (let i = s.length - 1; i >= 0; i--) {\r\n        if (s[i] === c) orCarry = i\r\n        res[i] = Math.min(orCarry - i, res[i])\r\n    }\r\n    return res\r\n};\r\n```\r\n\r\n\r\n\r\n### 解法二\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度: O(1)\r\n\r\n从上面我们可以看出很多比较都是可以省略的，比如向前找到了以后，没遇到下一个相同字符串前都只需要加一即可,那我们就通过向前向后分别得出距离后比较\r\n\r\n```JavaScript\r\nvar shortestToChar = function (S, C) {\r\n    let arr = Array(S.length)\r\n    for (let i = 0; i < S.length; i++) {\r\n        if (S[i] === C) arr[i] = 0\r\n        else arr[i] = arr[i - 1] === void 0 ? Infinity : arr[i - 1] + 1\r\n    }\r\n    for (let i = S.length - 1; i >= 0; i--) {\r\n        if (arr[i] === Infinity || arr[i + 1] + 1 < arr[i]) arr[i] = arr[i + 1] + 1\r\n    }\r\n\r\n    return arr\r\n};\r\n```\r\n\r\n## "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840232089","body":"### 解法一\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度: O(n)\r\n\r\n突出一个写的丑\r\n\r\n```JavaScript\r\nvar decodeString = function (s) {\r\n    let stack = []\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === \"]\") {\r\n            let pop = stack.pop()\r\n            let newStr = pop\r\n            while (pop !== '[') {\r\n                pop = stack.pop()\r\n                pop !== '[' && (newStr = pop + newStr)\r\n            }\r\n\r\n            pop = stack.pop()\r\n            let num = pop\r\n            while (!isNaN(pop)) {\r\n                pop = stack.pop()\r\n                !isNaN(pop) && (num = pop + num)\r\n            }\r\n            pop && stack.push(pop)\r\n            stack.push(newStr.repeat(num))\r\n        } else {\r\n            stack.push(s[i])\r\n        }\r\n    }\r\n    return stack.join('')\r\n};\r\n```\r\n\r\n## "},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"falconruo":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-840161675","body":"**思路:**\r\n\r\n查找string S里的每个字符离给定字符C的index的最短距离，对于每个字符有以下三种情况：\r\n\r\n。如果等于C则距离=0\r\n。最近的C在其左边\r\n。最近的C在其右边\r\n\r\n。从左到右依次遍历字符串S，比较每个字符与字符C的最短距离并存放到返回数组res中\r\n。从右到左依次遍历字符串S，比较每个字符与字符C的最短距离并与之前存放在数组res中的距离取小值\r\n\r\n**复杂度分析:**\r\n\r\n时间复杂度: O(n), n为string S长度\r\n空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> res(n, INT_MAX);\r\n\r\n        int l;\r\n        // scan string S from left to right to get the distance of each character\r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c)\r\n                l = i;\r\n            res[i] = min(res[i], abs(i - l));\r\n        }\r\n\r\n        // scan string S from right to lef to get the distance of each character, then choose the shortest one via comparing the distance values\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s[i] == c)\r\n                l = i;\r\n            res[i] = min(res[i], abs(i - l));\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"peacejoylove86":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-840252978","body":"import java.util.ArrayList;\r\n\r\npublic class Leetcode821 {\r\n    public int[] shortestToChar(String s, char c) {\r\n        if (s == null)\r\n        {\r\n            return null;\r\n        }\r\n        char[] chars = s.toCharArray();\r\n        int[] output = new int[s.length()];\r\n        if (!s.contains(String.valueOf(c)))\r\n        {\r\n            return output;\r\n        }\r\n        ArrayList indexs = new ArrayList();\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (c == chars[i])\r\n                indexs.add(i);\r\n        }\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (c == chars[i])\r\n                output[i] = 0;\r\n            else\r\n            {\r\n                int temp = Math.abs(i-((Integer) indexs.get(0)).intValue());\r\n                for (int j = 0; j < indexs.size(); j++) {\r\n                    int val = Math.abs(i-((Integer) indexs.get(j)).intValue());\r\n                    if (val < temp)\r\n                        temp = val;\r\n                }\r\n                output[i]=temp;\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Leetcode821 lc = new Leetcode821();\r\n        String s = \"loveleetcode\";\r\n        char c = 'e';\r\n        //输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n        int[] output = lc.shortestToChar(s,c);\r\n        for (int item:output\r\n             ) {\r\n            System.out.println(item);\r\n        }\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840255070","body":"import java.util.ArrayList;\r\nimport java.util.Stack;\r\n\r\nclass Leetcode394 {\r\n    public static String decodeString(String s) {\r\n        Stack sk = new Stack();\r\n        char[] input = s.toCharArray();\r\n        StringBuffer output = new StringBuffer();\r\n        StringBuffer subStr = new StringBuffer();\r\n        StringBuffer number = new StringBuffer();\r\n        for (int i = 0; i <= input.length - 1; i++) {\r\n            String temp = String.valueOf(input[i]);\r\n            if (isNumeric(temp)) {\r\n                number.append(input[i]);\r\n                continue;\r\n            }\r\n            if ('[' == input[i]) {\r\n                sk.push(number.toString());\r\n                number.delete(0, number.length());\r\n                subStr.delete(0, subStr.length());\r\n                for (int j = 1; j <= input.length - i - 1; j++) {\r\n                    if (']' == input[i + j]) {\r\n                        i = i + j;\r\n                        break;\r\n                    } else if (isChar(String.valueOf(input[i + j]))) {\r\n                        subStr.append(input[i + j]);\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            if (!sk.isEmpty()) {\r\n                int repeat = Integer.valueOf((String) sk.pop());\r\n                for (int j = 0; j <= repeat - 1; j++) {\r\n                    output.append(subStr);\r\n                }\r\n            }\r\n        }\r\n        return output.toString();\r\n    }\r\n\r\n    public final static boolean isNumeric(String s) {\r\n        if (s != null && !\"\".equals(s.trim()))\r\n            return s.matches(\"^[0-9]*\");\r\n        else\r\n            return false;\r\n    }\r\n\r\n    public final static boolean isChar(String s) {\r\n        char c = s.charAt(0);\r\n        if (((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(decodeString(\"10[a]2[bc]\"));\r\n    }\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yolo-jane":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840236906","body":"使用正则：执行用时：88 ms (去刷刷讲义后，再来)\r\n```\r\n输入\r\n\"3[z]2[2[y]pq4[2[jk]e1[f]]]ef\"\r\n输出\r\n\"zzzyypqjkjkefjkjkefjkjkefjkjkefyypqjkjkefjkjkefjkjkefjkjkefef\"\r\n预期结果\r\n\"zzzyypqjkjkefjkjkefjkjkefjkjkefyypqjkjkefjkjkefjkjkefjkjkefef\"\r\n\r\n```\r\n\r\n``` javascript\r\n/**\r\n * @param {string} str  \"3[a]2[bc]\"\r\n * @return {string} \"aaabcbc\"\r\n */\r\nvar decodeString = function (str) {\r\n  let result = ''\r\n  function replaceString(str) {\r\n    let res = str.replace(/(\\d+)(\\[(\\w+)\\])/g, (rs, $1, $2) => {\r\n      //  console.log(`rs=`+rs,`$1=`+$1,`$2=`+$2); rs=3[a] $1=3 $2=[a] rs=2[bc] $1=2 $2=[bc]\r\n      let res1 = []; for (let i = 0; i < $1; i++) {\r\n        let notNumber = $2.match(/\\w+/)[0];\r\n        if (notNumber) {\r\n          res1.push($2.match(/\\w+/))\r\n        }\r\n\r\n      }\r\n      return res1.join(\"\");\r\n\r\n    })\r\n\r\n\r\n    return res;\r\n  }\r\n\r\n  result = replaceString(str);\r\n  if (result.match(/(\\d+)(\\[(\\w+)\\])/g)) {\r\n    return decodeString(result);\r\n  } else {\r\n    return result;\r\n  }\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZiyangZ":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840245423","body":"- Using the code from YouTuber AndroidBabies. \r\n- Her code is not perfect. Feels a little clumsy.\r\n- Definitely needs more review.\r\n``` Java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Integer num = 0;\r\n        Stack<Object> stack = new Stack<>();\r\n        \r\n        for (char c: s.toCharArray()) {\r\n            if (Character.isDigit(c)) {\r\n                num = num * 10 + c - '0';\r\n            } else if (c == '[') {\r\n                stack.push(num);\r\n                num = 0;\r\n            } else if (c == ']') {\r\n                String newstr = helper(stack);\r\n                Integer cnt = (Integer) stack.pop();\r\n                for (int i = 0; i < cnt; i++) {\r\n                    stack.push(newstr);\r\n                }\r\n            } else {\r\n                stack.push(String.valueOf(c));\r\n            }\r\n        }\r\n        return helper(stack);\r\n    }\r\n    \r\n    private String helper(Stack<Object> stack) {\r\n        Stack<String> tmp = new Stack<>();\r\n        while (!stack.isEmpty() && stack.peek() instanceof String) {\r\n            tmp.push((String) stack.pop());\r\n        }\r\n        StringBuilder sb = new StringBuilder();\r\n        while (!tmp.isEmpty()) {\r\n            sb.append(tmp.pop());\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Endeavor-Gcl":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840245976","body":"学习ing~"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"QiYang03101994":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840253072","body":" 思路：参考最佳答案，用heap来控制迭代过程，遇到[，push，遇到], pop，通过使用heap来控制递归的开始和终止\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        multi = 0\r\n        res = ''\r\n        last_res= ''\r\n        final_res =''\r\n        stack = []\r\n\r\n        for i in range(len(s)):\r\n            c = s[i]\r\n            if ('0' <= c and c <= '9'):\r\n                multi = multi * 10 + int(c)\r\n            \r\n            elif (c == '['):\r\n                stack.append([res,multi])\r\n                # print(stack)\r\n                multi = 0\r\n                res =''\r\n            \r\n            elif (c == ']'):\r\n                [last_res,cur_multi] = stack.pop()\r\n                res = last_res + cur_multi * res\r\n                \r\n            else:\r\n                res += c\r\n\r\n\r\n        return res\r\n时空复杂度均为：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlesugarman":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840281532","body":"**思路：**\r\n利用栈的后进先出特性展开折叠的字符\r\n\r\n**代码：**\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        s = list(s)\r\n        stack = []\r\n        for k in s:\r\n            if k == ']':\r\n                cnt = ''\r\n                nr = ''\r\n                l = stack.pop()\r\n                while l != '[':\r\n                    nr = l + nr\r\n                    l = stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    cnt = stack.pop() + cnt\r\n                stack.append(nr * int(cnt)) \r\n            else:\r\n                stack.append(k)\r\n        return reduce(lambda x, y: x + y, stack)`\r\n```\r\n\r\n**复杂度分析：**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"baoqin87":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-840343221","body":"## 821.字符的最短距离\r\n\r\n### 思路\r\n向左或者向右距离目标字符最近的距离，取最小值\r\n\r\n### 代码 JavaScript\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  let len = s.length\r\n  let res = []\r\n  let prev = -10000\r\n  for (let i = 0; i < len; ++i) {\r\n    if (s.charAt(i) == c) prev = i\r\n    res[i] = i - prev\r\n  }\r\n  prev = 20000\r\n  for (let i = len - 1; i >= 0; --i) {\r\n    if (s.charAt(i) == c) prev = i\r\n    res[i] = Math.min(res[i], prev - i)\r\n  }\r\n  return res\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n^2)，其中 n 为数组的长度。\r\n* 空间复杂度：O(n)。\r\n* "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840526051","body":"## 394.字符串解码\r\n\r\n### 思路\r\n使用入栈出栈操作，将原字符串解码\r\n\r\n### 代码 JavaScript\r\n\r\n```javascript\r\nvar decodeString = function(s) {\r\n  let res = '';\r\n  let multi = 0;\r\n  let stack_multi = [];\r\n  let stack_res = [];\r\n  for (let i = 0, len = s.length; i < len; i++) {\r\n    c = s.charAt(i)\r\n    if(c == '[') {\r\n      // 把数字和拼接的字母分别压入栈\r\n      stack_multi.push(multi)\r\n      stack_res.push(res)\r\n      multi = 0\r\n      res = ''\r\n    } else if(c == ']') {\r\n      let tmp = ''\r\n      // 数字出栈\r\n      let cur_multi = stack_multi.pop()\r\n      // 数字作为循环次数\r\n      for (let i = 0; i < cur_multi; i++) {\r\n        tmp += res\r\n      }\r\n      res = stack_res.pop() + tmp\r\n    } else if (c >= '0' && c <= '9') {\r\n      multi = multi * 10 + parseInt(c)\r\n    } else {\r\n      res += c\r\n    }\r\n  }\r\n  return res;\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(N)。\r\n* 空间复杂度：O(N)。\r\n* "},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JadeQi":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840315430","body":"## 思路\r\n- 获取字符/获取倍数.\r\n- 括号内嵌套括号，需要从内向外生成与拼接字符.\r\n\r\n```java\r\nclass Solution394 {\r\n    public String decodeString(String s) {\r\n        Stack<Character> stack = new Stack<>();\r\n\r\n        // toCharArray: 字符串转换为字符数组\r\n        for (char c : s.toCharArray()) {\r\n            if (c != ']')\r\n                // 把所有的字母push到栈中，除了]\r\n                stack.push(c);\r\n            else {\r\n                // 取出[] 内的字符串\r\n                StringBuilder sb = new StringBuilder();\r\n                // isLetter: 用于判断指定字符是否为字母; 判断取出的顶部对象是否为字母\r\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\r\n                    // 在第0位插入出栈的对象\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n\r\n                //[ ]内的字符串\r\n                String sub = sb.toString();\r\n                // 去除[\r\n                stack.pop();\r\n\r\n                // 获取倍数数字\r\n                sb = new StringBuilder();\r\n                // isDigit: 判断指定字符是否为数字;  判断取出的顶部对象是否为数字\r\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n                // 倍数\r\n                int count = Integer.valueOf(sb.toString());\r\n\r\n                // 根据倍数把字母再push回去\r\n                while (count > 0) {\r\n                    for (char ch : sub.toCharArray()) {\r\n                        stack.push(ch);\r\n                    }\r\n                    count--;\r\n                }\r\n            }\r\n        }\r\n\r\n        // 把栈里面所有的字母取出来\r\n        StringBuilder retv = new StringBuilder();\r\n        while (!stack.isEmpty()) {\r\n            retv.insert(0, stack.pop());\r\n        }\r\n\r\n        return retv.toString();\r\n    }\r\n}\r\n\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Bochengwan":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840353737","body":"### 思路\r\n\r\n利用两个stack，一个stack存数字，一个stack存字母，遇到左括号时，把当前的数字入数字栈，当前的字母入字母栈，遇到右括号时，则出栈左括号前的数字，也就是数字栈的栈顶，此数字是当前字符的重复次数，并且与字母栈的栈顶拼接作为当前字符\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        bracket_stack = []\r\n        number_stack = []\r\n        c = ''\r\n        n = ''\r\n        for e in s:\r\n            \r\n            if e.isdigit():\r\n                n+=e\r\n            elif e == '[':\r\n                bracket_stack.append(c)\r\n                number_stack.append(n)\r\n                n = ''\r\n                c = ''\r\n            elif e == ']':\r\n                \r\n                c = (bracket_stack.pop() + c*int(number_stack.pop()))\r\n            else:\r\n                c += e\r\n        return c\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suikataro":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840354871","body":"### 代码\r\n```java\r\n    public String decodeString(String s) {\r\n        if (s == null || s.length() == 0) return s;\r\n        String res = \"\";\r\n        Stack<Integer> countStack = new Stack<>();\r\n        Stack<String> resStack = new Stack<>();\r\n        int idx = 0;\r\n        while (idx < s.length()) {\r\n            if (Character.isDigit(s.charAt(idx))) {\r\n                //处理>10的整数\r\n                int count = 0;\r\n                while (Character.isDigit(s.charAt(idx))) {\r\n                    count = count * 10 + (s.charAt(idx) - '0');\r\n                    idx++;\r\n                }\r\n                countStack.push(count);\r\n            } else if (s.charAt(idx) == '[') {\r\n                resStack.push(res);\r\n                res = \"\";\r\n                idx++;\r\n            } else if (s.charAt(idx) == ']') {\r\n                StringBuilder temp = new StringBuilder(resStack.pop());\r\n                int time = countStack.pop();\r\n                for (int i = 0; i < time; i++) {\r\n                    temp.append(res);\r\n                }\r\n                res = temp.toString();\r\n                idx++;\r\n            } else {\r\n                //字母\r\n                res += s.charAt(idx++);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"YuetongYu":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840365976","body":"思路： 正则判断解决。\r\n\r\n```js\r\nlet reg = /(\\d+)\\[([a-zA-Z]+)\\]/g;\r\n    while(s.indexOf('[')>0){\r\n        s = s.replace(reg,(_,...[num,str])=>{\r\n            let result = \"\";\r\n            for(let i=0;i<num-0;i++){\r\n                result += str;\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    return s;\r\n```\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"CelesteXiong":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840503799","body":"#### 思路\r\n需要由内而外读取括号，因此使用栈先进后出的特性\r\n#### 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        # 看题解做的\r\n        stack = []\r\n        multi = 0\r\n        ans = \"\"\r\n        res = \"\"\r\n        for c in s:\r\n            if '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)\r\n            elif c == '[':\r\n                stack.append([multi, ans])\r\n                multi = 0\r\n                ans = \"\"\r\n            elif c == ']':\r\n                last = stack.pop()\r\n                last_multi = last[0]\r\n                last_ans = last[1]\r\n                ans = last_ans + last_multi * ans \r\n            else:\r\n                ans += c\r\n        return ans\r\n\r\n```\r\n#### 复杂度\r\n时间复杂度O(N)：需要遍历一遍`s`\r\n空间复杂度O(N)：最坏的情况下需要线性空间"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flashyy":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840507326","body":"- 思路：\r\n   需要由子问题组合得到原问题，把每一层需要叠加的字母(res)和叠加的次数(multi)记录下来，加到原字符串上，迭代字符串：\r\n1. 遇到数字的时候，将其转化为整数（multi）记录下来，用于后序计算\r\n2. 遇到字母的时候，将该字符串加入当前字符串后面\r\n3. 遇到左括号时候，将需要叠加的字母(res)和叠加的次数(multi)记录下来并放入栈中\r\n4.遇到右括号时候弹出字符串，将字符串组合起来  \r\n```\r\nvar decodeString = function(s) {\r\n     let res=\"\",multi=0,stack=[];\r\n     for(let char of s){\r\n         if(!isNaN(char)){\r\n             multi = multi*10+parseInt(char);\r\n         }\r\n         else if(char === \"[\"){\r\n             stack.push([multi,res]);\r\n             res = \"\";\r\n             multi = 0;\r\n         }\r\n         else if(char === \"]\"){\r\n             let [multi,str] = stack.pop();\r\n             res = str+res.repeat(multi);\r\n         }  \r\n         else{\r\n            res +=char;\r\n         }\r\n     }\r\n     return res;\r\n};\r\n```\r\n- 复杂度：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsj":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840571999","body":" var decodeString = function (s) {\r\n        const isNum = n=>n>='1'&&n<='9'\r\n        const size = s.length \r\n        let stack = []\r\n        for(let i=0;i<size;i++){\r\n            const item = s.charAt(i)\r\n            if(item === '['){\r\n                stack.push('')\r\n                continue\r\n            }\r\n            if(item === ']'){\r\n                let popItem = stack[stack.length - 1]\r\n                const numVal = stack[stack.length - 2]\r\n                const popNum = parseInt(numVal)\r\n                let str = ''\r\n                if(popItem.length){\r\n                    for(let n = 0;n<popNum;n++){\r\n                        str+=popItem\r\n                    }\r\n                }\r\n                if(stack.length){\r\n                    stack.pop()\r\n                    stack.pop()\r\n                    if(stack.length){\r\n                        stack[stack.length - 1] += str\r\n                    }else{\r\n                        stack.push(str)\r\n                    }\r\n                }\r\n                continue\r\n            }\r\n            if(isNum(item)){\r\n                if(isNum(stack[stack.length - 1])){\r\n                    stack[stack.length - 1] += item\r\n                    continue\r\n                }\r\n                stack.push(item)\r\n                continue\r\n            }\r\n            if(!stack.length){\r\n                stack.push(item)\r\n                continue\r\n            }\r\n            stack[stack.length - 1] +=item\r\n        }\r\n        return stack.join('')\r\n    }\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jueran":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840575047","body":"思路：\r\n使用两个栈，一个栈存储数字，一个栈存字母；\r\n代码\r\n\r\n```\r\nclass Solution:\r\n    def decodeString(s:str)->str:\r\n        bracket_stack=[]\r\n        number_stack=[]\r\n        c=''\r\n        n=''\r\n        for e in s:\r\n            if e.isdigit():\r\n                n+=e\r\n            elif e=='[':\r\n                bracket_stack.append(c)\r\n                number_stack.append(n)\r\n                n=''\r\n                c=''\r\n            elif e==']':\r\n                c=(bracket_stack.pop()+c*int(number_stack.pop()))\r\n            else:\r\n                c+=e\r\n        return c\r\n```\r\n\r\n复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Dark-volute":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840590769","body":"### 思路\r\n我们可以利用 stack 来实现这个操作，遍历这个字符串 s，判断每一个字符的类型：\r\n\r\n如果是字母 --> 添加到 stack 当中\r\n如果是数字 --> 先不着急添加到 stack 中 --> 因为有可能有多位\r\n如果是 [ --> 说明重复字符串开始 --> 将数字入栈 --> 并且将数字清零\r\n如果是 ] --> 说明重复字符串结束 --> 将重复字符串重复前一步储存的数字遍\r\n\r\n### 代码\r\n```js\r\nvar decodeString = function(s) {\r\n    let strStack = []\r\n    let numStack = []\r\n    let num = 0\r\n    let str = ''\r\n    for (let i = 0; i< s.length; i++) {\r\n        // 如果是次数\r\n        if (!isNaN(s[i])) {\r\n            // 处理二位及以上次数\r\n            num = num * 10 + +s[i]\r\n        } else if (s[i] === '[') {\r\n            numStack.push(num)\r\n            strStack.push(str)\r\n            num = 0\r\n            str = ''\r\n        } else if (s[i] === ']'){\r\n            let repeatTimes = numStack.pop() // 获取拷贝次数\r\n            str = strStack.pop() + str.repeat(repeatTimes) \r\n        } else {\r\n            str += s[i]\r\n        }\r\n    }\r\n    return str\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：$O(N)$，其中 N 为解码后的 s 的长度。 空间复杂度：$O(N)$，其中 N 为解码后的 s 的长度。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Peg-008":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840594683","body":"字符内所有类型分别为:[  ]  数字   字母四种   数字和字母分别用一个栈存储  用 [ ] 作为入栈 出栈的条件 \r\n\r\n``` java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        if (s == null || \"\".equals(s)){\r\n            return null;\r\n        }\r\n        //数字栈\r\n        Stack<Integer> numStack = new Stack<>();\r\n        //字母栈\r\n        Stack<String> strStack = new Stack<>();\r\n        char[] chars = s.toCharArray();\r\n        int num = 0;\r\n        for(char c : chars){\r\n            if(isNum(c + \"\")){\r\n                num = num * 10 + c - '0';\r\n            } else if(c == '['){\r\n                strStack.push(c + \"\");\r\n                numStack.push(num);\r\n                num = 0;\r\n            } else if(c == ']'){ \r\n                int number = numStack.pop(); \r\n               String str = \"\";\r\n                while(!strStack.peek().equals(\"[\")){\r\n                    str = strStack.pop() + str;\r\n                }\r\n                strStack.pop();\r\n                strStack.push(getMultiWord(str, number));\r\n            } else {\r\n                strStack.push(c + \"\");\r\n            }\r\n        }\r\n        String res = \"\";\r\n        while(! strStack.isEmpty()){\r\n            res = strStack.pop() + res;\r\n        }\r\n        return res;\r\n    }\r\n    public static boolean isNum(String str) {\r\n        String regex = \"^[0-9]+$\";\r\n        return str.matches(regex);\r\n    }\r\n\r\n    private static String getMultiWord(String s, int num){\r\n        StringBuilder sb = new StringBuilder();\r\n        for (int i = 0 ;i < num; i ++){\r\n            sb.append(s);\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zibinanhai":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840626495","body":"\r\n## 题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n\r\n\r\n示例 3：\r\n\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n\r\n\r\n示例 4：\r\n\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n用一个栈来解决\r\n\r\n## 关键点\r\nwhile循环把[]里面的字符串读出来\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        int len = s.length();\r\n        if(len <= 0) {\r\n            return \"\";\r\n        }\r\n        Stack<String> stack = new Stack<>();\r\n        for(int i=0; i<len; i++){\r\n            char mid=s.charAt(i);\r\n            if(mid==']'){\r\n                StringBuilder tmp = new StringBuilder();\r\n                while(!stack.peek().equals(\"[\")){\r\n                    tmp.insert(0,stack.pop());\r\n                }\r\n                stack.pop();\r\n                StringBuilder num=new StringBuilder();\r\n                while(!stack.isEmpty() && (stack.peek().charAt(0) >= '0' \r\n                && stack.peek().charAt(0)<='9')){\r\n                    num.insert(0,stack.pop());\r\n                }\r\n                int number=Integer.parseInt(num.toString());\r\n                StringBuilder sb = new StringBuilder();\r\n                for(int j = 0; j < number; j++){\r\n                    sb.append(tmp);\r\n                }\r\n                stack.push(sb.toString());\r\n            }else{\r\n                StringBuilder sb = new StringBuilder();\r\n                sb.insert(0,mid);\r\n                stack.push(sb.toString());\r\n            }\r\n        }\r\n        StringBuilder res = new StringBuilder();\r\n        while(!stack.isEmpty()){\r\n            res.insert(0,stack.pop());\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wu529778790":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840627651","body":"```\r\nvar decodeString = function(s) {\r\n    let mulStack = [], strStack = [], num = 0, res = ''\r\n    for (const c of s) {   \r\n        if (!isNaN(c)) {  \r\n            num = num * 10 + (c - '0')\r\n        } else if (c == '[') {  \r\n            strStack.push(res)\r\n            mulStack.push(num) \r\n            res = '' \r\n            num = 0\r\n        } else if (c == ']') {  \r\n            res = strStack.pop() + res.repeat(mulStack.pop())\r\n        } else {                   \r\n            res += c\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"scarydemon2":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840634618","body":"## 递归\r\n```\r\n\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        res=\"\"\r\n        s=list(s)\r\n        index=0\r\n        stack=[]\r\n        current_num=0\r\n        while index<len(s):\r\n            if ord(s[index])<=ord('9') and ord(s[index])>=ord('0'):\r\n                num_start=index\r\n                index+=1\r\n                while ord(s[index])<=ord('9') and ord(s[index])>=ord('0'):\r\n                    index+=1\r\n                current_num=int(\"\".join(s[num_start:index]))\r\n                continue\r\n            elif s[index]=='[':\r\n                stack.append('[')\r\n                left=index+1\r\n                while stack!=[]:\r\n                    index += 1\r\n                    if s[index]=='[':\r\n                        stack.append('[')\r\n                        continue\r\n                    if s[index]==']':\r\n                        stack.pop(-1)\r\n                        right=index\r\n                        continue\r\n                tmp=self.decodeString(\"\".join(s[left:right]))\r\n                if current_num!=0:\r\n                    for i in range(current_num):\r\n                        res+=tmp\r\n                    current_num=0\r\n            elif s[index]==']':\r\n                index+=1\r\n                continue\r\n            else:\r\n                res+=s[index]\r\n                index+=1\r\n        return res\r\n\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kendj-staff":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840643716","body":"### 思路\r\n自己写的只能通过部分用例，盖着复现官方题解，看到其他人解答觉得自己写的太屎了\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    int ptr;\r\n    public String decodeString(String s) {\r\n        LinkedList<String> letterStack = new LinkedList<String>();\r\n        LinkedList<Integer> numStack = new LinkedList<Integer>();\r\n        ptr = 0;\r\n        \r\n        while (ptr < s.length()) {\r\n            if (Character.isDigit(s.charAt(ptr))) {\r\n                numStack.addLast(Integer.parseInt(getNumber(s)));\r\n            } else if (Character.isLetter(s.charAt(ptr)) || '[' == s.charAt(ptr)) {\r\n                letterStack.addLast(String.valueOf(s.charAt(ptr++)));\r\n            } else {\r\n                ptr++;\r\n                int count = numStack.removeLast();\r\n                LinkedList<String> subStrList = new LinkedList<String>();\r\n\r\n                while (!\"[\".equals(letterStack.peekLast())) {\r\n                    subStrList.addFirst(letterStack.removeLast());\r\n                    \r\n                }  \r\n\r\n                letterStack.removeLast();\r\n                String subStr = getString(subStrList);\r\n                StringBuffer sb = new StringBuffer();\r\n                while (count > 0) {\r\n                    sb.append(subStr);\r\n                    count --;\r\n                }\r\n\r\n                letterStack.addLast(sb.toString());\r\n            }\r\n        }\r\n        return getString(letterStack);\r\n    }\r\n    public String getNumber(String s) {\r\n        StringBuffer sb = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            sb.append(s.charAt(ptr++));\r\n        }\r\n        return sb.toString();\r\n    }\r\n    public String getString(List<String> s) {\r\n        StringBuffer sb = new StringBuffer();\r\n        for (String str: s) {\r\n            sb.append(str);\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZZWHU":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840646477","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, multi, res = [], 0, ''\r\n        for c in s:\r\n            if c.isdigit():\r\n                multi = multi*10 + int(c)\r\n            elif c == '[':\r\n                stack.append([multi, res])\r\n                multi, res = 0, ''\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi*res\r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n看了下大佬的代码\r\n\r\n- 时间复杂度O(N)\r\n- 空间复杂度O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zbqnb":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840648679","body":"## **91学算法DAY1**\r\n\r\n#### 思路：\r\n\r\n计算器问题，入栈出栈的时机从符号转为“[ ]”\r\n\r\n#### 复杂度分析：\r\n\r\n- 时间：单次for O(n)\r\n- 空间：O(n)\r\n\r\n```c++\r\n#include \"LeetCodeBasic.h\"\r\n#include \"LeetCodeStl.h\"\r\nusing namespace std;\r\n/*\r\n* \r\n*/\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<string> strs;\r\n        stack<int> Muti_operator;\r\n        string res = \"\";\r\n        \r\n        for (size_t i = 0; i < s.size(); i++)\r\n        {   \r\n            int num;\r\n            if (s[i] >= '0' && s[i] <= '9')\r\n            {   \r\n                {\r\n                    num = num * 10 + s[i] - '0';\r\n                }\r\n                //第一次做想到了连续数字问题，但是其实没必要特殊考虑\r\n                /*for (size_t j = 1; j + i < s.size(); j++)\r\n                {\r\n                    if (s[i + j] >= '0' && s[i + j] <= '9')\r\n                    {\r\n                        num = s[i] * 10 + s[i + j];\r\n                    }\r\n                    else {\r\n                        continue;\r\n                    }\r\n                }*/\r\n            }\r\n            else if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z'))\r\n            {\r\n                res = res + s[i];\r\n            }\r\n            else if (s[i] == '[')\r\n            {   \r\n                Muti_operator.push(num);\r\n                num = 0;\r\n                strs.push(res);\r\n                res = \"\";\r\n            }\r\n            else if (s[i] == ']') {\r\n                int times = Muti_operator.top();\r\n                Muti_operator.pop();\r\n                for (size_t i = 0; i < times; i++)\r\n                {\r\n                    strs.top() += res;\r\n                }\r\n                res = strs.top();\r\n                strs.pop();\r\n            }  \r\n        }\r\n    }\r\n};\r\n```\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Jolins":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840656961","body":"### 解题思路\r\n\r\n* 遇到数字保存数字到临时变量\r\n* 遇到字母保存字母到临时变量\r\n* 遇到左括号把数字和字母推到栈中\r\n* 遇到右括号对栈中的数字和字母出栈进行解析\r\n\r\n### 代码\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<int> nums;\r\n        stack<string> strs;\r\n        string res = \"\";\r\n        int num = 0;\r\n\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] >= '0' && s[i] <= '9') {\r\n                num = num * 10 + s[i] - '0';  //字符串转整数\r\n            } else if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z')) {\r\n                res = res + s[i];\r\n            } else if('[' == s[i]) {\r\n                nums.push(num);\r\n                strs.push(res);\r\n                \r\n                //清空num和res\r\n                num = 0;\r\n                res = \"\";\r\n            } else if(']' == s[i]) {\r\n                for (int j = 0; j < nums.top(); j++) {\r\n                   //res += strs.top();\r\n                   strs.top() += res;\r\n                }\r\n\r\n                res = strs.top();\r\n\r\n                nums.pop();\r\n                strs.pop();\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 时间复杂度\r\n\r\n\r\n\r\n### 空间复杂度"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}