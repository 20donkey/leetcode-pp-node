{"azl397985856":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/32#issuecomment-835293321","body":"2121212121"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840280816","body":"### 思路\r\n栈符号，读str然后写进stack里面，先找 ']' , 再回过来找 '[' \r\n有参考题解的思路\r\n\r\n### 代码 Python3\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for i in s:\r\n            if  i == ']':\r\n                les = ''\r\n                num = ''\r\n                while stack[-1].isalpha():\r\n                    les = stack.pop() + les\r\n                stack.pop()\r\n                while stack != [] and stack[-1].isnumeric():\r\n                    num = stack.pop() + num\r\n                stack.append(les * int(num))\r\n            else:\r\n                stack.append(i)\r\n        return \"\".join(stack)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"angusgenius":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835847052","body":"### 思路\r\n- 模拟数字加法，利用 `K` 保存进位，先将对应位置的数字相加，再进行取余操作保留结果。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc addToArrayForm(A []int, K int) (ans []int) {\r\n    for i := len(A) - 1; i >= 0 || K > 0; i-- {\r\n        if i >= 0 {\r\n            K += A[i]\r\n        }\r\n        ans = append(ans, K%10)\r\n        K /= 10\r\n    }\r\n    reverse(ans)\r\n    return\r\n}\r\n\r\nfunc reverse(A []int) {\r\n    for i, n := 0, len(A); i < n/2; i++ {\r\n        A[i], A[n-1-i] = A[n-1-i], A[i]\r\n    }\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(max(n, logk))，其中 n 为数组的长度。\r\n- 空间复杂度：O(1)，常数级别。"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-836995457","body":"### 思路\r\n- 双向遍历，对于每个字符 `S[i]`，找出向左或者向右下一个字符 `C` 的距离，这两个值的较小值即最短距离。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    n := len(s)\r\n    ans := make([]int, 0, n)\r\n    prev := math.MinInt32 / 2\r\n\r\n    for i := 0; i < n; i++ {\r\n        if s[i] == c {\r\n            prev = i\r\n        }\r\n        ans = append(ans, i - prev)\r\n    }\r\n\r\n    prev = math.MaxInt32 / 2\r\n    for i := n-1; i >= 0; i-- {\r\n        if s[i] == c {\r\n            prev = i\r\n        }\r\n        ans[i] = min(ans[i], prev - i)\r\n    }\r\n\r\n    return ans\r\n}\r\n\r\nfunc min(a, b int) int {\r\n    if a > b {\r\n        return b\r\n    }\r\n    return a\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N)，其中 `N` 是 S 的长度。\r\n- 空间复杂度：O(1)，常数级别。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839823744","body":"### 思路\r\n- 利用数组模拟。\r\n\r\n### 代码\r\n- Java\r\n```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int[] add;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        add = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        int ret = stack[top] + add[top];\r\n        if (top != 0) {\r\n            add[top - 1] += add[top];\r\n        }\r\n        add[top] = 0;\r\n        --top;\r\n        return ret;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k - 1, top);\r\n        if (limit >= 0) {\r\n            add[limit] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(1)。\r\n- 空间复杂度：O(maxSize)，辅助数组空间。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840552068","body":"### 思路\r\n- 模拟栈\r\n    - 若当前的字符为数位，解析出一个数字并进栈。\r\n    - 若当前的字符为字母或者左括号，直接进栈.\r\n    - 若当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字，即该字符串出现的次数，据此构造出新的字符串并进栈。\r\n    - 重复如上操作，最终将栈中的元素按照从栈底到栈顶的顺序拼接起来。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc decodeString(s string) string {\r\n    stk := []string{}\r\n    ptr := 0\r\n    for ptr < len(s) {\r\n        cur := s[ptr]\r\n        if cur >= '0' && cur <= '9' {\r\n            digits := getDigits(s, &ptr)\r\n            stk = append(stk, digits)\r\n        } else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <= 'Z') || cur == '[' {\r\n            stk = append(stk, string(cur))\r\n            ptr++\r\n        } else {\r\n            ptr++\r\n            sub := []string{}\r\n            for stk[len(stk)-1] != \"[\" {\r\n                sub = append(sub, stk[len(stk)-1])\r\n                stk = stk[:len(stk)-1]\r\n            }\r\n            for i := 0; i < len(sub)/2; i++ {\r\n                sub[i], sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i]\r\n            }\r\n            stk = stk[:len(stk)-1]\r\n            repTime, _ := strconv.Atoi(stk[len(stk)-1])\r\n            stk = stk[:len(stk)-1]\r\n            t := strings.Repeat(getString(sub), repTime)\r\n            stk = append(stk, t)\r\n        }\r\n    }\r\n    return getString(stk)\r\n}\r\n\r\nfunc getDigits(s string, ptr *int) string {\r\n    ret := \"\"\r\n    for ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++ {\r\n        ret += string(s[*ptr])\r\n    }\r\n    return ret\r\n}\r\n\r\nfunc getString(v []string) string {\r\n    ret := \"\"\r\n    for _, s := range v {\r\n        ret += s\r\n    }\r\n    return ret\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass Solution {\r\n    int ptr;\r\n\r\n    public String decodeString(String s) {\r\n        LinkedList<String> stk = new LinkedList<String>();\r\n        ptr = 0;\r\n\r\n        while (ptr < s.length()) {\r\n            char cur = s.charAt(ptr);\r\n            if (Character.isDigit(cur)) {\r\n                String digits = getDigits(s);\r\n                stk.addLast(digits);\r\n            } else if (Character.isLetter(cur) || cur == '[') {\r\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \r\n            } else {\r\n                ++ptr;\r\n                LinkedList<String> sub = new LinkedList<String>();\r\n                while (!\"[\".equals(stk.peekLast())) {\r\n                    sub.addLast(stk.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                stk.removeLast();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = Integer.parseInt(stk.removeLast());\r\n                StringBuffer t = new StringBuffer();\r\n                String o = getString(sub);\r\n                while (repTime-- > 0) {\r\n                    t.append(o);\r\n                }\r\n                stk.addLast(t.toString());\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer ret = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            ret.append(s.charAt(ptr++));\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> v) {\r\n        StringBuffer ret = new StringBuffer();\r\n        for (String s : v) {\r\n            ret.append(s);\r\n        }\r\n        return ret.toString();\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N)，其中 N 为字符串的长度。\r\n- 空间复杂度：O(N)，其中 N 为字符串的长度。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841234472","body":"### 思路\r\n- 将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于 pop 和 peek 操作。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\ntype MyQueue struct {\r\n    inStack, outStack []int\r\n}\r\n\r\nfunc Constructor() MyQueue {\r\n    return MyQueue{}\r\n}\r\n\r\nfunc (q *MyQueue) Push(x int) {\r\n    q.inStack = append(q.inStack, x)\r\n}\r\n\r\nfunc (q *MyQueue) in2out() {\r\n    for len(q.inStack) > 0 {\r\n        q.outStack = append(q.outStack, q.inStack[len(q.inStack)-1])\r\n        q.inStack = q.inStack[:len(q.inStack)-1]\r\n    }\r\n}\r\n\r\nfunc (q *MyQueue) Pop() int {\r\n    if len(q.outStack) == 0 {\r\n        q.in2out()\r\n    }\r\n    x := q.outStack[len(q.outStack)-1]\r\n    q.outStack = q.outStack[:len(q.outStack)-1]\r\n    return x\r\n}\r\n\r\nfunc (q *MyQueue) Peek() int {\r\n    if len(q.outStack) == 0 {\r\n        q.in2out()\r\n    }\r\n    return q.outStack[len(q.outStack)-1]\r\n}\r\n\r\nfunc (q *MyQueue) Empty() bool {\r\n    return len(q.inStack) == 0 && len(q.outStack) == 0\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass MyQueue {\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n\r\n    public MyQueue() {\r\n        inStack = new LinkedList<Integer>();\r\n        outStack = new LinkedList<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n\r\n    private void in2out() {\r\n        while (!inStack.isEmpty()) {\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(1)。\r\n- 空间复杂度：O(N)，其中 N 是操作总数。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841612498","body":"### 思路\r\n- 滑动窗口。\r\n\r\n### 代码\r\n- Java\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) nonzero--;\r\n            if (count.get(x) == 1) nonzero++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) nonzero++;\r\n            if (count.get(y) == 0) nonzero--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(NlogN)，其中 N 为数组的长度。\r\n- 空间复杂度：O(N)，其中 N 为数组的长度。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"devil-lin":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835849107","body":"\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n\r\n        int n = num.size();\r\n        for(int i = n - 1; i >= 0 || k; i --)\r\n        {\r\n            if(i >= 0)\r\n                k += num[i];\r\n            res.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        reverse(res.begin(), res.end());\r\n\r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838552141","body":"\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n   vector<int> shortestToChar(string S, char C) {\r\n       vector<int> distance(S.size(), 0);\r\n       int prev = INT_MIN/2;\r\n       for(int i = 0; i < S.size(); i ++){\r\n           if(S[i] == C) prev = i;\r\n           distance[i] = i - prev;\r\n       }\r\n       prev = INT_MAX/2;\r\n       for(int i = S.size() - 1; i >= 0; i --){\r\n           if(S[i] == C) prev = i;\r\n           distance[i] = min(distance[i], prev - i);\r\n       }\r\n       return distance;\r\n   }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-838831826","body":"思路没啥的，就是数组模拟而已\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass CustomStack {\r\n    int maxSize;\r\n    int[] stack;\r\n    int index;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n        index = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(index == maxSize){\r\n            return;\r\n        }\r\n        stack[index++] = x;\r\n    }\r\n   \r\n    public int pop() {\r\n        if(index == 0){\r\n            return -1;\r\n        }\r\n        return stack[--index];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        k = Math.min(k, index);\r\n        for(int i = 0; i < k; i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841333545","body":"C++ Code:\r\n\r\n```c++\r\n\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n\r\n    void in2out() {\r\n        while (!inStack.empty()) {\r\n            outStack.push(inStack.top());\r\n            inStack.pop();\r\n        }\r\n    }\r\n\r\npublic:\r\n    MyQueue() {}\r\n\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    int pop() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n\r\n    int peek() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n\r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841621666","body":"Java Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) nonzero--;\r\n            if (count.get(x) == 1) nonzero++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) nonzero++;\r\n            if (count.get(y) == 0) nonzero--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zliu1413":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835862900","body":"思路：add K to each digit of the num. \r\n语言：python\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        i = len(num)-1\r\n        while(i>=0 or k>0):\r\n            if i>=0:\r\n                k += num[i]\r\n            res.append(k%10)\r\n            k = k//10\r\n            i -= 1\r\n        return res[::-1]\r\n\r\n```\r\n\r\n复杂度：\r\n时间：O(max(n,logK)), logK is the how many times that K can be divided by 10 until residual is single digit\r\n空间：O(1）\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837327271","body":"解题思路：\r\n双向遍历。两次遍历的每个位置比较大小。\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        \r\n        \"\"\"\r\n        #first attemp\r\n        cLocs = []\r\n        for idx,elem in enumerate(s):\r\n            if elem == c: \r\n                cLocs.append(idx)\r\n        \r\n        res = []\r\n        for idx, elem in enumerate(s):\r\n            res.append(min(abs(mark - idx) for mark in cLocs))\r\n        \r\n        return res\r\n        \"\"\"\r\n        # second\r\n        ref = float(inf)\r\n        distanceList = []\r\n        for i,val in enumerate(s):\r\n            if val==c: ref = i\r\n            distanceList.append(abs(ref-i))\r\n        \r\n        ref = float(inf)\r\n        for i in range(len(s)-1,-1,-1):\r\n            val = s[i]\r\n            if val==c: ref = i\r\n            distanceList[i] = min(distanceList[i],abs(ref-i))\r\n        \r\n        return distanceList\r\n\r\n```\r\n复杂度：\r\n时间：O(n)\r\n空间：O(n)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-838833786","body":"思路：pop和push都是O(1），inc把增量单独存起来，调用pop时再把增量加上去\r\n\r\n``` python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.delta = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack)<self.maxSize:\r\n            self.stack.append(x)\r\n            self.delta.append(0)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack)>0:\r\n            val = self.stack.pop(-1)\r\n            inc = self.delta.pop(-1)\r\n            if len(self.delta)>0: self.delta[-1] += inc\r\n            return val+inc\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k>len(self.stack): k=len(self.stack)\r\n        if k>0: self.delta[k-1] += val\r\n```\r\n\r\n复杂度: \r\n时间 O(1)\r\n空间O(N）\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840126932","body":"思路：用栈存储乘数和中间结果，写的太笨了，之后再优化\r\n\r\n```Python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        answer = \"\"\r\n        stackElem = []\r\n        multifier = 0\r\n        for i,elem in enumerate(s):\r\n            if elem.isdigit():\r\n                multifier = 10*multifier+int(elem)\r\n            elif elem ==\"[\":\r\n                stackElem.append([multifier,\"\"])\r\n                multifier = 0\r\n            elif elem == \"]\":\r\n                multi,val = stackElem.pop()\r\n                if len(stackElem)!=0:\r\n                    stackElem[-1][1] += multi*val\r\n                else:\r\n                    answer += multi*val\r\n            else:\r\n                if len(stackElem) != 0:\r\n                    stackElem[-1][1] += elem\r\n                else:\r\n                    answer += elem\r\n        \r\n        return answer\r\n\r\n```\r\n复杂度：\r\n时间 O(N)\r\n空间 O(N）\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840705914","body":"思路：use two stacks to implement a queue. inStack will receive data, and outStack and push the data in reverse order.\r\n\r\n```Python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n    def in2out(self):\r\n        while (self.instack!=[]):\r\n            self.outstack.append(self.instack.pop())\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.instack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.outstack == []:\r\n            self.in2out()\r\n        return self.outstack.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.outstack == []:\r\n            self.in2out()\r\n        return self.outstack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return (self.outstack==[]) & (self.instack==[])\r\n\r\n```\r\n\r\n时间复杂度：O(1)\r\n空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841511635","body":"思路: 单调栈。the minimum in the next block must be higher or equal to the max of current block. create a stack to store new max, and if come across a small number, than pop out the stack until the stack peek is smaller or equal to this small number. push the max into the stack.\r\n\r\n```Python\r\n\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for v in arr:\r\n            if stack!=[] and v<stack[-1]:\r\n                head = stack[-1] # max at the moment\r\n                while stack and v<stack[-1]: stack.pop() #if current element < stack peek (previous max, each max represent a block), then merge into a single block\r\n                stack.append(head) # append the max of the newly merged block\r\n            else:\r\n                stack.append(v)\r\n\r\n        return len(stack)\r\n\r\n```\r\n复杂度：\r\n时间空间：O（N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841704089","body":"思路：我写的很蠢，断开中间的node，然后重新拼接\r\n\r\n```Python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n        \r\n        length = 1\r\n        lastNode = head\r\n        \r\n        while lastNode.next:\r\n            lastNode = lastNode.next\r\n            length += 1\r\n        \r\n        if k>=length: k=k%length\r\n\r\n        if k==0: return head\r\n\r\n        numBreak = length-k\r\n\r\n        breakNode = head\r\n        for i in range(numBreak-1):\r\n            breakNode = breakNode.next\r\n        nextListNode = breakNode.next\r\n        \r\n        lastNode.next = head\r\n        breakNode.next = None\r\n\r\n        return nextListNode\r\n```\r\n复杂度：\r\n时间：O(n）\r\n空间：O(1）\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joe-the-plumber":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835868625","body":"思路：using string to convert back and forth\r\n语言：python\r\n复杂度：\r\n时间：O(n)\r\n空间：O(n）\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        \r\n        number_int =  functools.reduce(lambda a,b : str(a)+str(b),num)\r\n        number_int = int(number_int) + k\r\n        \r\n        result_int_array = []\r\n        for i in str(number_int):\r\n            result_int_array.append(int(i))\r\n            \r\n        return result_int_array\r\n```\r\n\r\n            \r\n        "},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837583648","body":"同上： 先将所有目标字符位置找出，再遍历整个列表，计算与前后目标字符的距离绝对值，取值小的。\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        #1. find all currence of c\r\n        position_array = []        \r\n        for i, v in enumerate(s):\r\n            if v == c:\r\n                position_array.append(i)\r\n       \r\n        #duplicate the last element, we can access the right boundary more easily\r\n        position_array.append(position_array[-1])  \r\n                \r\n        #initilize the return value arrary\r\n        shortest_distance_array = [0 for _ in range(len(s))]\r\n        j1 = 0\r\n            \r\n        for i, v in enumerate(s):\r\n            shortest_distance_array[i] = min( abs( i-position_array[j1] )\r\n                                             , abs(i-position_array[j1+1] ) \r\n                                            )\r\n            #if the moving left_p(j1), right_p(j1+1) pair need to be updated    \r\n            if i==position_array[j1+1]:\r\n                # the right_p should not move out of boundary\r\n                if j1+1+1<len(position_array) :\r\n                    j1 += 1\r\n\r\n        return shortest_distance_array\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839406703","body":"Copy 了前排同学的作业。。。。\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack1 = [] # for push and pop\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack1) < self.maxSize:\r\n            self.stack1.append(x)\r\n         \r\n    def pop(self) -> int:\r\n        # check if stack is empty\r\n        if self.stack1:\r\n            #About python list\r\n            #Return Value from pop()\r\n            #The pop() method returns the item present at the given index. This item is also removed from the list.\r\n            return self.stack1.pop(-1)\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(len(self.stack1),k)):\r\n            self.stack1[i]+=val\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840315378","body":"参照答案，写了一遍\r\nhttps://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/medium/394.decode-string\r\n1）答案是在做inplace change。\r\n2）思路是每次遇到]，就处理了到 [, 减少了一个pair。。一直到最后\r\n\r\n复杂度\r\nTime: O(N) \r\nSpace: O(N)\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for char in s:\r\n            #need to decode at the ] , find out repeat string and count\r\n            if char == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n            \r\n                #regular char, notice we use while here\r\n                while stack and stack[-1] != '[':\r\n                        repeatStr = stack.pop() + repeatStr\r\n\r\n                #stack[-1] == '['\r\n                stack.pop()\r\n\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount\r\n\r\n                stack.append(repeatStr*int(repeatCount))\r\n                \r\n            else:\r\n                stack.append(char)\r\n    \r\n        return \"\".join(stack)\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840960537","body":"```python\r\nclass MyQueue:\r\n# 思路\r\n# 用两个栈实现队列，一个栈用来进行读操作(push)，一个栈用来写操作(pop,empty,peek)\r\n\r\n# 栈a进行push操作\r\n# 在进行pop，peek操作的时候，如果栈b有元素，直接pop，没有的话，在栈a有元素的时候，栈a进行pop添加到栈b再进行pop\r\n# 当栈a，b为空的时候才是空的\r\n# 延伸阅读\r\n# 其实使用两个栈来替代一个队列的实现是为了在多进程中分开对同一个队列对读写操作。一个栈是用来读的，另一个是用来写的。当且仅当读栈满时或者写栈为空时，读写操作才会发生冲突。\r\n# 当只有一个线程对栈进行读写操作的时候，总有一个栈是空的。在多线程应用中，如果我们只有一个队列，为了线程安全，我们在读或者写队列的时候都需要锁住整个队列。而在两个栈的实现中，只要写入栈不为空，那么push操作的锁就不会影响到pop。\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack_1 = []\r\n        self.stack_2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stack_2.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.stack_1:\r\n            while self.stack_2:\r\n                self.stack_1.append(self.stack_2.pop())\r\n        return self.stack_1.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.stack_1:\r\n            while self.stack_2:\r\n                self.stack_1.append(self.stack_2.pop())\r\n        return self.stack_1[-1]        \r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.stack_1) + len(self.stack_2)==0\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841604125","body":"抄了前排同学作业\r\n\r\n单调栈\r\n很容易会想到单调栈这以数据结构\r\n维持一个单调递增栈，存储每个块中的最大值，最终单调栈的长度就是可分块的大小。\r\n\r\n**_2、当出现小于栈顶head的值时，保留当前栈顶head，抛出stack中大于arr[i]的值_**\r\nif current element < stack peek (previous max, each max represent a block),\r\nthen merge into a single block\r\n复杂度分析\r\n时间：O(N)\r\n空间：O(N)\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack_max = []\r\n        \r\n        for v in arr:                       \r\n            if stack_max!=[] and v<stack_max[-1]:\r\n                head = stack_max[-1] # max at the moment\r\n                while stack_max and v<stack_max[-1]: \r\n                    stack_max.pop() \r\n                    #if current element < stack peek (previous max, each max represent a block), then merge into a single block\r\n                stack_max.append(head) # append the max of the newly merged block\r\n            else:\r\n                stack_max.append(v)\r\n                \r\n        return len(stack_max)\r\n        \r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841760143","body":"自己做的，edge case需要考虑。\r\n1） k=0, k=length\r\n2)  how to set up a iterator, constructed a virtual head, which caused the calculation of length to be off a bit....\r\n\r\n时间复杂度O(N)\r\n空间复杂度O(N)\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n\r\n        #find out where to break\r\n        length = 0\r\n        p_current = ListNode(-1,head)\r\n\r\n        while(p_current.next):\r\n            p_current = p_current.next\r\n            length += 1 \r\n\r\n        p_last_node = p_current\r\n        \r\n        # we need to break the kth(index from 1) node\r\n        if k!= 0 :\r\n            k = length - k%length\r\n        k =  k%length  \r\n        \r\n        pos = 0\r\n        p_current = ListNode(-1,head)\r\n        new_head = head\r\n        print(length,k)\r\n        \r\n        if k!= 0 :\r\n            while(True):\r\n                if(pos==k):\r\n                    new_head = p_current.next\r\n                    p_current.next = None\r\n                    p_last_node.next = head\r\n                    break\r\n                              \r\n                p_current = p_current.next\r\n                pos += 1 \r\n                \r\n        return new_head\r\n                    \r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Critsu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835891780","body":"思路：add K to each digit\r\n语言：java\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList<>();\r\n\r\n        for(int i=num.length-1; i>=0; i--){\r\n \r\n            int temp = num[i] + k;\r\n            int temp1 = temp%10;\r\n            ans.add(0, temp1);\r\n            k= temp/10;\r\n            \r\n        }\r\n\r\n        while(k>0){\r\n            ans.add(0, k%10);\r\n            k/=10;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837609304","body":"```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int prev = -1;\r\n        \r\n        for(int i=0; i<res.length; i++){\r\n            if(s.charAt(i) == c){\r\n                res[i] = 0;\r\n                prev = i;\r\n            }else if(prev>-1){\r\n                res[i] = i-prev;\r\n            }else {\r\n                res[i] = Integer.MAX_VALUE;\r\n            }\r\n        }\r\n        \r\n        prev=-1;\r\n        \r\n        for(int i=res.length-1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }else if(prev>-1){\r\n                res[i] = Math.min((prev-i), res[i]);\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839379247","body":"```java\r\n\r\nclass CustomStack {\r\n    Stack<Integer> stack;\r\n    int size;\r\n    int count = 0;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        stack = new Stack<>();\r\n        this.size = maxSize;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(count < size) {\r\n            stack.push(x);\r\n            count++;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(stack.empty())\r\n            return -1;\r\n        else {\r\n            count--;\r\n            return stack.pop();\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n\r\n        if(count < k) {\r\n            for(int i=0; i<count; i++) {\r\n                stack.set(i, stack.get(i)+val);\r\n            }\r\n        } else {\r\n            for(int i=0; i<k; i++)\r\n                stack.set(i, stack.get(i)+val);\r\n        }\r\n    }\r\n}\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840132950","body":"```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<Integer> numStack = new Stack<>();\r\n        Stack<String> strStack = new Stack<>();\r\n        StringBuilder res = new StringBuilder();\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            char b = s.charAt(i);\r\n            \r\n            if(Character.isDigit(b)){\r\n                int num = b - '0';\r\n                while( i+1<s.length() && Character.isDigit(s.charAt(i+1))){\r\n                    num = num * 10 + s.charAt(i+1) - '0';\r\n                    i++;\r\n                }\r\n                numStack.push(num);\r\n            }\r\n            else if(b == '['){\r\n                strStack.push(res.toString());\r\n                res = new StringBuilder();\r\n            }\r\n            else if(b==']'){\r\n                StringBuilder temp = new StringBuilder(strStack.pop());\r\n                int k = numStack.pop();\r\n                for(int j=0; j<k; j++){\r\n                    temp.append(res);\r\n                }\r\n                res = temp;\r\n            }\r\n            else{\r\n                res.append(b);\r\n            }\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840923826","body":"```java\r\nclass MyQueue {\r\n    private Stack<Integer> s1;\r\n    private Stack<Integer> s2;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        while(!s1.isEmpty()){\r\n            s2.push(s1.pop());\r\n        }\r\n        s1.push(x);\r\n        while(!s2.isEmpty()){\r\n            s1.push(s2.pop());\r\n        }\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        return s1.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        return s1.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s1.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841579627","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] sort_arr = arr.clone();\r\n        Arrays.sort(sort_arr);\r\n\r\n        int diff = 0;\r\n        int ans = 0;\r\n\r\n        for(int i=0; i<arr.length; i++){\r\n            diff += arr[i] - sort_arr[i];\r\n            if(diff == 0) ans++;\r\n        }\r\n\r\n\r\n        return ans;\r\n\r\n       \r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841746677","body":"```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head==null) return null;\r\n        ListNode temp = head;\r\n        int len = 1;\r\n        while(temp.next!=null) {temp=temp.next; len++;}\r\n        temp.next = head;\r\n        temp = head;\r\n        int moves = len - (k%len);\r\n\r\n        for(int i=1; i<moves; i++){\r\n            temp = temp.next;\r\n        }\r\n        ListNode newHead = null;\r\n        newHead = temp.next;\r\n        temp.next = null;\r\n\r\n\r\n        return newHead;\r\n    }\r\n}\r\n\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835892157","body":"# Logic:\r\n```\r\nGo backward from the end of num (the least significant digit) \r\nwhile num still has unprocessed digits or k still has unprocessed digits:\r\n    get k's lowest digit \r\n    update k (k = 0 would be fine)\r\n    \r\n    # add up the current sum for the current digit\r\n    if (no digit to use in num): no need to add from num \r\n    else: add up the current sum for the current digit, decrement the index in num\r\n    \r\n    get carry\r\n    insert to the sum list\r\n    \r\nif (carry == 1): insert at sum list's head\r\n```\r\n# Caveats:\r\nStart from the least significant digit in num (go backward), consider carry, what if k's len is longer/shorter, use linkedlist.addFirst()\r\n\r\n[0]\r\n23\r\n\r\n# Complexity:\r\nTime: O(max(num.length, num of digits in k))\r\n\r\nSpace: O(max(num.length, num of digits in k)) if we consider the output list; otherwise O(1)\r\n\r\n# Code:\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> sum = new LinkedList<>();\r\n        int index = num.length - 1;\r\n        int carry = 0;\r\n        while (index >= 0 || k != 0) {\r\n            int curDigit = k % 10;\r\n            k = k / 10;\r\n            \r\n            if (index == -1) {\r\n               curDigit += carry; \r\n            } else {\r\n                curDigit += num[index--] + carry;\r\n            }\r\n            carry = curDigit / 10;\r\n            sum.addFirst(curDigit % 10);\r\n        }\r\n        if (carry == 1) {\r\n            sum.addFirst(1);\r\n        }\r\n        return sum;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838725255","body":"# Logic:\r\n```\r\ntraverse from the left to find matchPos (the closest match on the current index's left)\r\n- update for each index in s\r\n\r\ntraverse from the right (the closest match on the current index's right)\r\nno need to update the elements after the matchPos, because they have no match on the right\r\n- update for each index in s\r\n```\r\n\r\ns = \"loveleetcode\", c = \"e\"\r\nIt is guaranteed that c occurs at least once in s.\r\n\r\n\"aaba\"\r\n\"b\"\r\n\r\n# Complexity:\r\nTime: O(2n) -> O(n), n is the length of S\r\nSpace: O(1) - if we do not consider the output array\r\n\r\n# Code:\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] dist = new int[s.length()];\r\n        int matchPos = -s.length(); // the closest c position\r\n        // traverse from the left to find matchPos (the closest match on the current index's left)\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) {\r\n                matchPos = i;\r\n            }\r\n            dist[i] = i - matchPos;\r\n        }\r\n        // traverse from the right (the closest match on the current index's right)\r\n        // no need to update the elements after the matchPos, because they have no match on the right\r\n        for (int i = matchPos - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                matchPos = i;\r\n            }\r\n            dist[i] = Math.min(matchPos - i, dist[i]);\r\n        }\r\n        return dist;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839880724","body":"\r\n# Logic:\r\ncapacity : the max capacity of the stack\r\nsize : the current size of stack\r\nuse array to store elements\r\n\r\nPush: if it is not full, push, size++\r\nPop: if it is empty, return -1; else pop(), size--\r\nIncrement: iterate based on min(k, size) and increment \r\n\r\n// https://www.techiedelight.com/iterate-through-stack-java/\r\n\r\n# Complexity:\r\nTime: Pop, Push O(1); Increment O(min(k, size)) \r\nSpace: O(1)\r\n    \r\n\r\n# Code:\r\n```\r\nclass CustomStack {\r\n\r\n    int capacity;\r\n    int size;\r\n    int[] stack; \r\n\r\n    public CustomStack(int maxSize) {\r\n        capacity = maxSize;\r\n        size = 0;\r\n        stack = new int[capacity];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (size < capacity) {\r\n            stack[size] = x;\r\n            size++;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (size == 0) return -1;\r\n        size--;\r\n        return stack[size];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < Math.min(k, size); i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840653980","body":"# Logic: \r\n\r\nUse two stacks:\r\n(freqStack) to store the integer (freqStack)\r\n(strStack) to store the previous stringbuilders (we append the current string which has been repeated for freqStack.pop() times to strStack.pop())\r\n\r\ncurrent string: use StringBuilder()\r\n```\r\ns contains 3 cases:\r\n1. a digit which comes before '['- make sure to make \"123\" -> 123\r\n\r\n2. [: \r\npush the number to freqStack, push current string to strStack\r\nreset the number, reset the current string\r\n\r\n3. ]: \r\nset temp = cur\r\ncur = strStack.pop()\r\nfreq = freqStack.pop()\r\ncur.append(temp) for freq times\r\n\r\n4. letter: append to the current string\r\n```\r\n# Complexity:\r\nTime: O(n), n is the length of decoded S\r\n\r\nSpace: O(n), n is the length of decoded S\r\n\r\nNote: \"1[a]\" is valid\r\n\r\n# Code:\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<StringBuilder> strStack = new Stack<>();\r\n        Stack<Integer> freqStack = new Stack<>();\r\n        \r\n        StringBuilder cur = new StringBuilder();\r\n        int num = 0;\r\n\r\n        // do not use while to get multi-digit num, e.g. \"321\"\r\n        for (char c : s.toCharArray()) {\r\n            if (Character.isDigit(c)) {\r\n                num = num * 10 + c - '0';\r\n            }\r\n            else if (c == '[') { // reach the end of number str\r\n                freqStack.push(num);\r\n                num = 0;\r\n                // \"abc3[cd]xyz\", deal with cur\r\n                strStack.push(cur);\r\n                cur = new StringBuilder();\r\n            } else if (c == ']') { // \"3[a2[c]]\"\r\n                StringBuilder temp = cur; //\"c\"\r\n                cur = strStack.pop();\r\n                int iter = freqStack.pop();\r\n                for (int i = 0; i < iter; i++) {\r\n                    cur.append(temp);\r\n                }                \r\n            } else { // see a letter\r\n                cur.append(c);\r\n            }\r\n            \r\n        }\r\n        return cur.toString();\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841319623","body":"# Logic:\r\n1. popStack is only responsible for the queue's pop op AND peek op\r\n2. pushStack is only responsible for the queue's push op\r\n\r\nBefore push, feed all elements from popStack if any to pushStack, then push into pushStack\r\nBefore pop/peek, feed all elements from pushStack if any to popStack, then pop/peek from popStack\r\nEmpty: check if both are empty\r\n```\r\ncase: \r\npush 1,2,3,4\r\npop (get 1)\r\npush 5\r\npop (get 2)\r\n```\r\n# Complexities:\r\nTime: \r\nPush/pop/peek: O(N) for N elements, O(1) amortized\r\nisEmpty: O(1)\r\n\r\nSpace: O(N)\r\n\r\n# Code:\r\n```\r\nclass MyQueue {\r\n    \r\n    Stack<Integer> pushStack, popStack;\r\n    \r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        pushStack = new Stack<>();\r\n        popStack = new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        while (!popStack.isEmpty()) {\r\n            pushStack.push(popStack.pop());\r\n        }\r\n        \r\n        pushStack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        while (!pushStack.isEmpty()) {\r\n            popStack.push(pushStack.pop());\r\n        }\r\n        \r\n        return popStack.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n         while (!pushStack.isEmpty()) {\r\n            popStack.push(pushStack.pop());\r\n        }\r\n        \r\n        return popStack.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return pushStack.isEmpty() && popStack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841682692","body":"# Logic:\r\nMonotonic stack: \r\n- if subarray is not monotonically increasing, len to split = subarray.length\r\n- if subarray is not monotonically decreasing, len to split = 1\r\n\r\nEdge case:  [5,3,3,2,1,1]  -> 1\r\n\r\nmake sure the following block's min > min from its precedent blocks\r\n\r\n- \"融合区块\", 栈内每一个元素代表一个块，而栈里面的每一个元素的值就是块的最大值。(西法原创)\r\n\r\n- [2,1,3,4,4]， stack 的变化过程：\r\n\r\n[2]\r\n1 被融合了，保持 [2] 不变\r\n[2,3]\r\n[2,3,4]\r\n[2,3,4,4]\r\n将一个减序列压缩合并成最该序列的最大的值。 \r\n\r\n# Complexity:\r\nTime: O(arr.length)\r\nSpace: O(arr.length)\r\n\r\n# Code:\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        for (int num : arr) {\r\n            if (!stack.isEmpty() && stack.peek() > num) {\r\n                int curMax = stack.pop();\r\n                while (!stack.isEmpty() && stack.peek() > num) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(curMax);\r\n            } else {\r\n                stack.push(num);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanjyumoso":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835903934","body":"### 思路\r\n\r\n1. Convert the array to string\r\n2. convert the string to integer for addition. \r\n3. Convert integer to array.\r\n\r\n### 代码\r\nPython\r\n\r\n\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        a = \"\"\r\n        for i in num:\r\n            a+=str(i)\r\n        x = int(a)+k\r\n        newList = [int(i) for i in str(x)]\r\n        return newList \r\n\r\n```\r\n\r\n**复杂度分析**\r\n- Time：O(n)\r\n- Space：O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839406435","body":"#### 思路\r\n*  increment 注意取当前长度与k的最小值\r\n*  pop, push 后注意更新current position\r\n#### code\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0]*maxSize\r\n        self.maxSize = maxSize\r\n        self.current = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.current < self.maxSize: \r\n            self.stack[self.current] = x\r\n            self.current += 1\r\n            \r\n\r\n    def pop(self) -> int:\r\n        if self.current > 0:\r\n            self.current -= 1\r\n            return self.stack[self.current]\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(self.current, k)):\r\n            self.stack[i] += val\r\n```\r\n\r\n**复杂度分析**\r\n- Time：O(maxSize)\r\n- Space：O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840305939","body":"#### 思路\r\n* 两个栈， 一个存string repeat的次数， 一个存string。 遇到 ]  pop\r\n* code太丑了，脑子没了\r\n\r\n``` python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        times = []\r\n        time = \"\"\r\n        for n, i in enumerate(s):\r\n            current = ''\r\n            if i.isdigit():\r\n                time += i\r\n                if not s[n+1].isdigit():\r\n                    times.append(int(time))\r\n                    time = \"\"\r\n            else:\r\n                if i == ']':\r\n                    t = times.pop()\r\n                    v = stack.pop()\r\n                    for j in range(t):\r\n                        current += v\r\n                    stack.pop()\r\n                    if len(stack)>0 and stack[-1] != '[':\r\n                        stack[-1] += current\r\n                    else:\r\n                        stack.append(current)\r\n                elif i == '[':\r\n                    stack.append(i)\r\n                else:\r\n                    if len(stack) == 0:\r\n                        stack.append('[')\r\n                        stack.append(i)\r\n                        times.append(1)\r\n                    elif(stack[-1] != '['):\r\n                        stack[-1] += i\r\n                    else:\r\n                        stack.append(i)\r\n        return stack[-1]\r\n```\r\n#### 复杂度\r\nTime: O(N) N = len(s)\r\nSpace: O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841009281","body":"### 思路\r\n* 两个栈, 一个作为push的入口，一个作为pop的出口\r\n* pop时，如果出口栈不为空，直接pop。如果为空，入口栈所有元素压入出口栈后，pop出口栈\r\n* peek同pop，返回出口栈最后一个元素\r\n* 如果两个栈都为空返回true\r\n### code\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stackpush = []\r\n        self.stackpop = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stackpush.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        while not self.stackpop:\r\n            while self.stackpush:\r\n                self.stackpop.append(self.stackpush.pop())\r\n        return self.stackpop.pop()\r\n            \r\n        \r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        while not self.stackpop:\r\n            while self.stackpush:\r\n                self.stackpop.append(self.stackpush.pop())\r\n        return self.stackpop[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not(bool(self.stackpop) or bool(self.stackpush))\r\n```\r\n\r\n### 复杂度\r\n* Time：empty = push = O(1), 出口栈不为空时 peek = pop = O(1), 只有不为空时 = O(N)。均摊后为O(1) \r\n* Space：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841608951","body":"#### 思路\r\n* 单调栈\r\n* 每个chunk内部排序后再进行chunk合并后生成sorted array\r\n* 遍历数组\r\n    * 如果栈为空或当前值大于等于栈顶元素值，生成新chunk（压入）\r\n    * 如果小于，储存栈顶元素后执行出栈，直到当前元素大于等于更新后的栈顶元素后停止。压入之前储存的元素\r\n* 遍历结束后，栈中元素个数就为chunk个数\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        monostack = []\r\n        for i in range(len(arr)):\r\n            if not monostack or monostack[-1] <= arr[i]:\r\n                monostack.append(arr[i])\r\n            else:\r\n                tmp = monostack.pop()\r\n                while monostack and monostack[-1] > arr[i]:\r\n                    monostack.pop()\r\n                monostack.append(tmp)\r\n        return len(monostack)\r\n```\r\n\r\n#### 复杂度\r\n* Time = O(N)\r\n* Space = O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841746730","body":"### 思路\r\n* 如果head is None，返回head\r\n* 将链表首位相接变为循环链表并得到链表长度\r\n* 从原head位开始寻找新head（if index == length-k）\r\n* 如果当前位的下一位是新头部，储存新head，并切断当前node与node.next（新head）之间的link。返回新head\r\n\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n\r\n        # if head is null, return head\r\n        if not head:\r\n            return head\r\n        \r\n        # Get length and connect the last and head to change NodeList to a circular NodeList \r\n        length = 1\r\n        newNode = head\r\n        while(newNode.next):\r\n            newNode = newNode.next\r\n            length += 1\r\n        newNode.next = head\r\n\r\n        # get real cut index\r\n        k = k % length\r\n\r\n       # find new head\r\n        index = 0\r\n        returnNode = None\r\n        while(True):\r\n            if index == length-k:\r\n                returnNode = newNode.next\r\n                newNode.next = None\r\n                return returnNode\r\n            index += 1\r\n            newNode = newNode.next \r\n```\r\n\r\n### 复杂度\r\n* Time： O(N)\r\n* Space：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lilyzhaoyilu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835920262","body":"## LC 989. Add to Array-Form of Integer\r\n\r\n### 思路\r\n\r\n循环处理 k 和 num  \r\n让 k 的每一位和 num 对应的 digit 相加  \r\n并且记录是否需要进位  \r\n需要注意一些特殊 case 的处理\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  let i = num.length - 1\r\n  let carry = false;\r\n\r\n  while(k > 0 || i >= 0){\r\n    let curDigit = k % 10\r\n    k = Math.floor(k / 10)\r\n\r\n    //此处注意可能有i <0 的情况，所以 || 0\r\n    //corner case: [0] 233\r\n    let newDigit = curDigit + (num[i]||0)\r\n\r\n    //如果需要进位\r\n    if(carry){\r\n      newDigit++\r\n      carry = false;\r\n    }\r\n\r\n    //判断是否需要进位\r\n    if(newDigit >=10){\r\n      carry = true;\r\n      newDigit = newDigit % 10\r\n    }\r\n\r\n    //同样需要处理 i< 0 的情况\r\n    i >= 0 ? num[i] = newDigit : num.unshift(newDigit)\r\n    i--\r\n  }\r\n\r\n  //最后看看是否需要进位\r\n  //corner case: [9,9] 1\r\n  if(carry) num.unshift(1)\r\n\r\n  return num;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(Math.max(M+N)) 两个长度中的最大值 其实就是 O(N) </br>\r\n空间复杂度：O(1) 只保存了常量\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-836997697","body":"## LC 821. Shortest Distance to a Character\r\n\r\n- Shortest Distance to a Character\r\n  - [遍历两次](#思路-遍历两次)\r\n  - [暴力](#思路-暴力)\r\n  - [双指针](#思路-双指针)\r\n  - [窗口](#思路-窗口)\r\n\r\n### 思路 遍历两次\r\n\r\n漾宝真棒！么么哒  \r\n遍历两次，一次从左到右，另一次反方向  \r\n遍历的时候分别记录从左到右和从右到左的该 s[i]对 c 的距离\r\n并且保留较小的那个\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar shortestToChar = function(s, c) {\r\n  //greedy\r\n  const res = new Array(s.length).fill(Infinity)\r\n\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] === c) res[i] = 0;\r\n    //处理一下i == 0 的情况，不然的话res[i -1] => NaN\r\n    else res[i] = i == 0 ? Infinity : res[i - 1] + 1\r\n  }\r\n\r\n\r\n  for(let i = s.length - 1; i >= 0; i--){\r\n    //res[i + 1] 是这个数组中右边的那一位\r\n    //如果res[i] == Infinity 就说明这个i的左边没有e\r\n    //或者 res[i + 1] + 1 < res[i]说明这个res[i]离右边的更近\r\n    if(res[i] == Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(1)\r\n\r\n### 思路 暴力\r\n\r\n暴力  \r\n先遍历数组，求出所有 c 的 index  \r\n然后再遍历数组，遇到跟 c 不同的时候，遍历 targetIndex 里的数组，求最小值\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  //brutal force\r\n  const res = [];\r\n  const targetIndex = [];\r\n  //iterate through s to get the indexs of c\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] == c) targetIndex.push(i)\r\n  }\r\n  //iterate through s to see wether a character is c\r\n  //if it is c, then the corresponding output should be 0\r\n  //if it is not c, then iterate through the targetIndex array\r\n  //    find the min of current char's index and all the target's index\r\n  //英文写真长啊下次还是打中文吧...\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] != c){\r\n      let temp = Infinity;\r\n      for(let t = 0; t < targetIndex.length; t++){\r\n          temp = Math.min(temp, Math.abs(i - targetIndex[t]))\r\n      }\r\n      res.push(temp)\r\n    }else{\r\n      res.push(0)\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：$O(N * M)$ M 是 c 的在 s 中的次数</br>\r\n空间复杂度：O(M) M 为 s 中 c 的个数\r\n\r\n### 思路 双指针\r\n\r\n双指针  \r\n在遍历 s 中遇到非 c 的时候，  \r\n派两个指针去寻找左边和右边的 c，并且计算最小值\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  //two pointers\r\n  const res = new Array(s.length).fill(Infinity)\r\n  for(let i = 0; i < s.length; i++){\r\n\r\n    if(s[i] == c){\r\n      res[i] = 0\r\n    }else{\r\n      let right = i + 1;\r\n      let left = i - 1\r\n\r\n      while(s[left] != c && left > 0){\r\n        left--\r\n      }\r\n\r\n      while(s[right] != c && right < s.length-1){\r\n        right++\r\n      }\r\n\r\n      //这里进行了边界处理，即处理了left/right越界的情况\r\n      //也处理了如果left/right 只是单纯的到边界停下了的情况\r\n      //比如s='love' 在s[i] = o i=1的时候，left就会是0\r\n      let leftSideC = s[left] != c  ? Infinity : i - left;\r\n      let rightSideC = s[right] != c ? Infinity : right - i\r\n      // console.log(i, s[i], left, leftSideC, right, rightSideC)\r\n      res[i] = Math.min(rightSideC, leftSideC)\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：$O(N^2)$ </br>\r\n空间复杂度：O(1) 只保存了常量\r\n\r\n### 思路 窗口\r\n\r\n\r\n我要请漾宝吃饭！   \r\n滑动的~？窗口  \r\n制造一个窗口，让他的左右两端分别为 c 或者 s 的边界  \r\n当为 s 的边界的时候，让窗口的值等于 Infinity  \r\n因为必然有 c，所以只要处理 i = 0 的时候就好了\r\n然后计算每个 s 到窗口两边的值，取最小\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar shortestToChar = function(s, c) {\r\n  //sliding window\r\n\r\n  let left = s[0] === c ? 0 : Infinity;\r\n  //从index = 1 的位置开始寻找c\r\n  let right = s.indexOf(c, 1);\r\n\r\n  const res = new Array(s.length);\r\n\r\n  for(let i = 0; i < s.length; i++){\r\n    res[i] = Math.min(Math.abs(i - left), Math.abs(i - right))\r\n    //变到下一个窗口\r\n    if(i === right){\r\n      left = right;\r\n      right = s.indexOf(c, left + 1)\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N · (NK)) 其中 n 是 s 的长度，indexof 的时间复杂度是 O(NK),其中 k 是每次找到的目标的长度 </br>\r\n空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-838814104","body":"## LC 1381. Design a Stack With Increment Operation\r\n\r\n- LC 1381. Design a Stack With Increment Operation\r\n  - [O(1)空间](<#思路-O(1)空间>)\r\n  - [O(1)时间](<#思路-O(1)时间>)\r\n\r\n### 思路 O(1)空间\r\n\r\n感觉现在写的比以前顺畅多了 Q_Q  \r\n这是有进步了吧？  \r\n果然跟着 Lucifer 的每日打卡做题就会有进步呢！\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = [];\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if(this.stack.length == this.maxSize) return null;\r\n  this.stack.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  let last = this.stack.pop();\r\n  return last == undefined ? -1 : last;\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  for(let i = 0; (i < k) && (i < this.stack.length); i++){\r\n    this.stack[i] += val\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N) increment is O(N) for iterating through the stack, others are O(1) </br>\r\n空间复杂度：O(1)\r\n\r\n### 思路 O(1)时间\r\n\r\n空间换时间，用一个 O(M)的 hashtable 来记录所有 increment 的操作，并且在要 pop 的时候把操作对弹出栈的小朋友进行运算\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = [];\r\n  this.record = new Map(); // index => total increment amount\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if(this.stack.length == this.maxSize) return null;\r\n  this.stack.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  if(this.stack.length < 1) return -1; //如果长度为0，返回-1\r\n  let curLastIndex = this.stack.length - 1; //现在即将要被pop出去的元素的index\r\n  let last = this.stack.pop(); //last = 被pop的\r\n  if(this.record.has(curLastIndex)){ //如果record有这个index的操作记录\r\n    let temp = this.record.get(curLastIndex) //让temp等于这个index的增加的总值\r\n    last += temp //加到last上去\r\n    //调整相关记录\r\n    this.record.set(curLastIndex - 1, (this.record.get(curLastIndex - 1) || 0 ) + temp )\r\n    //删除已经用过的记录\r\n    this.record.delete(curLastIndex)\r\n  }\r\n\r\n  return last;\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let index = k > this.stack.length - 1 ? this.stack.length - 1 : k - 1;\r\n  this.record.set(index, (this.record.get(index) || 0) + val)\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(1) </br>\r\n空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840172489","body":"## LC 394. Decode String\r\n\r\n- [辅助栈](#思路-辅助栈)\r\n- [辅助栈 2](#思路-辅助栈2)\r\n\r\n### 思路 辅助栈\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  const stack = [];\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] != ']'){\r\n      stack.push(s[i])\r\n    }else if(s[i] == ']'){\r\n      let temp = ''\r\n      while(stack[stack.length - 1] != '['){\r\n        temp = stack.pop() + temp;\r\n      }\r\n      stack.pop() //这一步一定是'['\r\n\r\n      let num = ''\r\n      while(stack[stack.length - 1] >= '0' && stack[stack.length - 1] <= '9'){\r\n        num = stack.pop() + num\r\n      }\r\n\r\n      temp = temp.repeat(parseInt(num))\r\n      stack.push(temp)\r\n    }\r\n  }\r\n  return stack.join('');\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(N)\r\n\r\n### 思路 辅助栈 2\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  const numStack = [], strStack = []\r\n  let num = 0, res = ''\r\n\r\n  for(let char of s){\r\n    if(!isNaN(char)){ // !isNaN() 来判断是否是一个数字\r\n      num = num * 10 + Number(char) // Number(char)转换数字\r\n    }else if(char == '['){\r\n      strStack.push(res); //把之前存的string入栈，进入新的一层\r\n      res = '' //清空之前存的str\r\n      numStack.push(num) //把 [ 前面的 number入栈\r\n      num = 0 //清空 num\r\n    }else if(char == ']'){\r\n      //input: \"3[ab2[d]]\" 此时 ab    +  2 * d\r\n      //现在的res是[]里面的所有字符\r\n      res = strStack.pop() + res.repeat(numStack.pop())\r\n    }else{\r\n      res += char\r\n    }\r\n  }\r\n\r\n  return res\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840832380","body":"## LC 232. Implement Queue using Stacks\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n### 思路\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n     // pretend to be a stack with push, peek, pop, size, and isEmpty\r\n    this.stackleft = []; //[1,2,3]\r\n    this.stackright = []; //[6,5,4]\r\n\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue.\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n  this.stackright.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n  if(this.stackleft.length == 0){\r\n    while(this.stackright.length > 0){\r\n      this.stackleft.push(this.stackright.pop())\r\n    }\r\n  }\r\n  return this.stackleft.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n  if(this.stackleft.length == 0){\r\n    while(this.stackright.length> 0){\r\n      this.stackleft.push(this.stackright.pop())\r\n    }\r\n  }\r\n  return this.stackleft[this.stackleft.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n  return this.stackleft.length == 0 && this.stackright.length == 0\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：时间复杂度均摊为 O(1) push 和 empty 都是 1， pop 和 peek 均摊是 1，对于每个元素之多入栈和出栈两次\r\n</br>\r\n空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841473071","body":"## LC 768. Max Chunks To Make Sorted II\r\n\r\n- [单调递增栈/Monotonic Queue](#思路-单调递增栈/Monotonic-Queue)\r\n- [滑动窗口/Sliding Window](#思路-滑动窗口/Sliding-Window)\r\n\r\n### 思路 单调递增栈/Monotonic Queue\r\n\r\nwant: concatenating chunks == to the sorted array\r\nequavilantly: seeking a data structure represnets a strict increasing order -> monotonic queue\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\n\r\nvar maxChunksToSorted = function(arr) {\r\n  let queue = [];\r\n\r\n  for(let i = 0; i < arr.length; i++){\r\n\r\n    if(queue.length == 0 || (queue[queue.length - 1] <= arr[i])){\r\n      queue.push(arr[i])\r\n    }else{\r\n      //the size of the queue reprensets the size of partition\r\n\r\n      let temp = queue.pop()\r\n      while(queue[queue.length - 1] > arr[i]){\r\n        queue.pop()\r\n      }\r\n\r\n      queue.push(temp)\r\n    }\r\n\r\n  }\r\n  return queue.length\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(N)\r\n\r\n### 思路 滑动窗口/Sliding Window\r\n\r\nThe sum of each sorted chunk equals to the sum of the original chunk regardless of the sort order.  \r\nCredit to Suukii\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\n\r\nvar maxChunksToSorted = function(arr) {\r\n  let sum1 = 0, sum2 = 0;\r\n  let count = 0\r\n\r\n  sorted = arr.slice().sort((a,b) => a - b)\r\n\r\n  for(let i = 0; i < arr.length; i++){\r\n    sum1 += arr[i]\r\n    sum2 += sorted[i]\r\n\r\n    if(sum1 === sum2) count++\r\n  }\r\n\r\n  return count;\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N logN) -> N for iterating through the array, logN for sort </br>\r\n空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841692432","body":"## LC 61. Rotate List\r\n\r\n- [仿照 Lucifer 解的快慢指针](#思路-仿照Lucifer解的快慢指针)\r\n- [快慢指针](#思路-快慢指针)\r\n- [迭代+一点数学](#思路-迭代+一点数学)\r\n- [递归](#思路-递归)\r\n\r\n### 思路 仿照 Lucifer 解的快慢指针\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar rotateRight = function(head, k) {\r\n  if(!head || !head.next || k === 0) return head;\r\n\r\n  let length = 1, cur = head;\r\n\r\n  //找出长度\r\n  while(cur.next){\r\n    cur = cur.next\r\n    length++\r\n  }\r\n\r\n  //找出真实的k的次数\r\n  k = k % length;\r\n\r\n  let fast = head, slow = head\r\n\r\n\r\n  //这时候的slow是newTail，这里Lucifer写的挺elegant Q_Q\r\n  while(fast.next){\r\n    if(k-- <=0) slow = slow.next\r\n    fast = fast.next\r\n  }\r\n\r\n  fast.next = head;\r\n  let newHead = slow.next\r\n\r\n  slow.next = null;\r\n  return newHead\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(1)\r\n\r\n### 思路 快慢指针\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar rotateRight = function(head, k) {\r\n  if(!head || !head.next || k === 0) return head;\r\n\r\n  let length = 1, cur = head;\r\n\r\n  //找出长度\r\n  while(cur.next){\r\n    cur = cur.next\r\n    length++\r\n  }\r\n\r\n  //找出真实的k的次数\r\n  k = k % length;\r\n  //如果次数是0，那么就等于没干，并且如果k = 0 后面会报错\r\n  if(k === 0) return head;\r\n\r\n  //快慢指针，让快的先走 k - 1步，这样慢的就刚好是newHead，快的刚好是现在的尾巴\r\n  let fast = head, slow = head, count = k - 1;\r\n\r\n  while(count > 0){\r\n    fast = fast.next\r\n    count--\r\n  }\r\n\r\n  //pre是newHead之前的节点，也就是newTail\r\n  let pre = null;\r\n  while(fast.next){\r\n    pre = slow\r\n    fast = fast.next\r\n    slow = slow.next\r\n  }\r\n\r\n  //在尾巴后面把这个斩断\r\n  pre.next = null;\r\n  //这里把他接上\r\n  fast.next = head;\r\n  return slow\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(1)\r\n\r\n### 思路 迭代+一点数学\r\n\r\n把 LinkedList 想象成一个 array  \r\n遍历两次，一次求出 length  \r\n第二次通过计算求出 newHead Index，并且设置一个 pre（就是新的尾巴\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar rotateRight = function(head, k) {\r\n  if(k === 0 || !head || !head.next) return head;\r\n\r\n  let length = 1, cur = head\r\n\r\n  while(cur.next){\r\n    cur = cur.next\r\n    length++\r\n  }\r\n\r\n  // 长度为n的列表里，如果index 是0 based，那么倒数第一个，index就是 n-1，倒数第二个，index就是n - 2 \\\r\n  // k % n 是真实的旋转次数\r\n  //那么newHead就是 newHeadIndex = length - k % length\r\n  let newHeadIndex =  length - k % length;\r\n  //\r\n  if(newHeadIndex == 0) return head;\r\n\r\n  let pre = cur;\r\n  cur.next = head;\r\n  cur = cur.next;\r\n  //现在cur 是 head，也就是index = 0 的情况\r\n  while(newHeadIndex > 0){\r\n    pre = cur\r\n    cur = cur.next\r\n    newHeadIndex--\r\n  }\r\n\r\n  //pre 是 newHead前面的一个node，所以它是尾巴\r\n  pre.next = null;\r\n\r\n  return cur;\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(1)\r\n\r\n### 思路 递归\r\n\r\n每次递归一个，模拟操作  \r\n但是要注意要求 k % length 不然会超时\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar rotateRight = function(head, k) {\r\n  if(!head || !head.next) return head;\r\n\r\n  var rotate = function(head){\r\n    let tail = head, preTail = null;\r\n\r\n    while(tail.next){\r\n      preTail = tail\r\n      tail = tail.next\r\n    }\r\n\r\n    preTail.next = null;\r\n    tail.next = head;\r\n\r\n    return tail\r\n  }\r\n\r\n\r\n  let cur = head;\r\n  let length = 1;\r\n  //数一下length\r\n  while(cur.next){\r\n    cur = cur.next\r\n    length++\r\n  }\r\n\r\n  //实际递归的次数\r\n  k = k % length;\r\n\r\n\r\n  let res = head;\r\n\r\n  while(k >0){\r\n    res = rotate(res)\r\n    k--\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度： O(N) </br>\r\n空间复杂度：O(K % Length)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Size-of":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835929595","body":"```javascript\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  const res = []\r\n  let i = num.length - 1\r\n  let carry = 0\r\n  while (i >= 0 || k > 0 || carry > 0) {\r\n    let cur = (num[i] || 0) + k % 10 + carry\r\n    res.push(cur % 10)\r\n    carry = cur / 10 | 0\r\n    i--\r\n    k = k / 10 | 0\r\n  }\r\n  return res.reverse()\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(max(n, logk))$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837506159","body":"## 代码\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const res = new Array(s.length).fill(Infinity)\r\n  for (let i = 0; i < s.length; i++) {\r\n    res[i] = s.substr(i, 1) === c ? 0 : (res[i - 1] != undefined ? res[i - 1] : Infinity) + 1\r\n  }\r\n\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    let prev = res[i + 1] !== undefined ? res[i + 1] : Infinity\r\n    res[i] = prev + 1 < res[i] ? prev + 1 : res[i]\r\n  }\r\n\r\n  return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$, N为s的长度\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839766869","body":"\r\n## 代码\r\n```javascript\r\n\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.list = []\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.list.length === this.maxSize) return\r\n    this.list[this.list.length] = x\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (!this.list.length) return -1\r\n    return this.list.splice(this.list.length - 1, 1)[0]\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for (let i = 0; i < (this.list.length < k ? this.list.length : k); i++) {\r\n         this.list[i] += val\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840563176","body":"\r\n\r\n\r\n\r\n## 代码\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  s = s.split('')\r\n  function dfs(sub, k) {\r\n    let str = ''\r\n    let num = 0\r\n    while (sub.length) {\r\n      let char = sub.shift()\r\n      if (/\\d/.test(char)) {\r\n        num = num * 10 + +char\r\n      } else if (char === '[') {\r\n        str += dfs(sub, num)\r\n        num = 0\r\n      } else if (char === ']') {\r\n        let _str = str\r\n        while (--k) {\r\n          str += _str\r\n        }\r\n        break\r\n      } else {\r\n        str += char\r\n      }\r\n    }\r\n    return str\r\n  }\r\n\r\n  return dfs(s, 0)\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841273939","body":"\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.l1 = []\r\n    this.l2 = []\r\n    this.front \r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n   if (!this.l1.length) {\r\n       this.front = x\r\n   }\r\n   this.l1.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if (this.l2.length) {\r\n        return this.l2.pop()\r\n    }else  if (this.l1.length) {\r\n        while(this.l1.length > 1) {\r\n            this.l2.push(this.l1.pop())\r\n        }\r\n        return this.l1.pop()\r\n    }\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    let target\r\n    if (this.l2.length) {\r\n        target = this.l2.pop()\r\n        this.l2.push(target)\r\n        return target\r\n    }\r\n    \r\n    return this.front\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.l1.length === 0 && this.l2.length === 0\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为队列长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Talent-Rain":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835930598","body":"\r\n## [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/bao-li-xiang-jia-by-jzsq_lyx-pon7/)\r\n\r\n### 分析\r\n1. 给定的 k 值是数字，不好按位来和数组中的值进行比对，而这里最后返回的是一个数组，所以先把数组 k 转成字符数组 -- kArr\r\n2. 根据数组长度，从地位到高位进行相加，用遍历 addOne 表示是否进位\r\n3. 每一次相加都需要判断是否超过 9, 超出时返回余数，并更新遍历 addOne\r\n4. 由于返回的 num，所以先用 ALen 遍历，遍历结束后，根据 KLen 的值判断是否还有 kArr 的值，同时还得注意次数 addOne 是否需要进位\r\n5. 时间复杂度：遍历 k 是 O(k) -- 其中 k 是 KLen，然后是遍历两个数组，所以最后 O(N),其中 N 是 Math.max(KLen,ALen)\r\n6. 空间复杂度: O(K)  -- 其中 k 是 KLen\r\n\r\n```javascript\r\n// 989. 数组形式的整数加法\r\n\r\n/**\r\n * @分析\r\n * 1. 由于最后返回的是数组形式，所以将 k 转成单个字符加到数组中比较合适\r\n * 2. 主要考察字符串切分字符，字符与数字相加转换问题\r\n */\r\n var addToArrayForm = function (num, k) {\r\n\r\n    let addOne = false // 进位\r\n    // 转成 number[]\r\n    const kArr = String(k).split('').map(str => Number(str))\r\n    let ALen = num.length, KLen = kArr.length \r\n    while (ALen--) {\r\n        let sum = num[ALen]\r\n        if (KLen) {\r\n            KLen--\r\n            sum += kArr[KLen]\r\n        }\r\n        if (addOne) {\r\n            sum++\r\n            addOne = false\r\n        }\r\n        if (sum >= 10) {\r\n            num[ALen] = sum % 10\r\n            addOne = true\r\n        } else {\r\n            num[ALen] = sum\r\n        }\r\n    }\r\n    while (KLen--) {\r\n        // 还有的值全部加到后面\r\n        let sum = kArr[KLen]\r\n        if (addOne) {\r\n            sum++\r\n            addOne = false\r\n        } \r\n        if (sum >= 10) {\r\n            num.unshift(sum % 10)\r\n            addOne = true\r\n        } else {\r\n            num.unshift(sum)\r\n        }\r\n    }\r\n    if (addOne) {\r\n        num.unshift(1)\r\n    }\r\n    return num\r\n};\r\n\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837524070","body":"[ 821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/bao-li-mei-ju-by-jzsq_lyx-ya8d/)\r\n### 直接暴力解法\r\n1. 将所有 c 的下标标记出来，用 temp 数组保存\r\n2. 遍历第二次的时候根据 temp 的值作为节点，计算对应的 abs 值\r\n3. 需要特别注意的是第一个节点和最后一个节点\r\n4. 时间复杂度：遍历了两次 s -- O(N) 其中 N 是 s 的长度\r\n5. 空间复杂度： 存储的是 c 出现的次数 -- O(C) -- 其中 C 的值为 [1,N]\r\n```javascript\r\n// 821. 字符的最短距离\r\n\r\n/**\r\n * @分析 -- 暴力解法\r\n */\r\n var shortestToChar = function (s, c) {\r\n    const len = s.length\r\n    //当结果为 c 的时候，就是 0，默认先全是 0\r\n    const ret = new Array(len).fill(0)\r\n    const temp = []\r\n    // 遍历第一次，找出所有 c 对应的 index\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) temp.push(i)\r\n    }\r\n\r\n    let index = 0\r\n    // 再遍历一次，完成所有值\r\n    for (let i = 0; i < temp.length; i++) {\r\n        const right = temp[i]\r\n        if (i === 0) {\r\n            while (index < right) {\r\n                ret[index] = right - index\r\n                index++\r\n            }\r\n        } else {\r\n            const left = temp[i - 1]\r\n            while (index > left && index < right) {\r\n                ret[index] = Math.min(right - index, index - left)\r\n                index++\r\n            }\r\n        }\r\n        // 因为相同的节点直接就是 0，所以直接跳过了\r\n        index++\r\n    }\r\n    // 走完了，如果index<len,做最后一次遍历\r\n    while (index < len) {\r\n        ret[index] = index - temp[temp.length - 1]\r\n        index++\r\n    }\r\n    return ret\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837524070","body":"[ 821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/bao-li-mei-ju-by-jzsq_lyx-ya8d/)\r\n### 直接暴力解法\r\n1. 将所有 c 的下标标记出来，用 temp 数组保存\r\n2. 遍历第二次的时候根据 temp 的值作为节点，计算对应的 abs 值\r\n3. 需要特别注意的是第一个节点和最后一个节点\r\n4. 时间复杂度：遍历了两次 s -- O(N) 其中 N 是 s 的长度\r\n5. 空间复杂度： 存储的是 c 出现的次数 -- O(C) -- 其中 C 的值为 [1,N]\r\n```javascript\r\n// 821. 字符的最短距离\r\n\r\n/**\r\n * @分析 -- 暴力解法\r\n */\r\n var shortestToChar = function (s, c) {\r\n    const len = s.length\r\n    //当结果为 c 的时候，就是 0，默认先全是 0\r\n    const ret = new Array(len).fill(0)\r\n    const temp = []\r\n    // 遍历第一次，找出所有 c 对应的 index\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) temp.push(i)\r\n    }\r\n\r\n    let index = 0\r\n    // 再遍历一次，完成所有值\r\n    for (let i = 0; i < temp.length; i++) {\r\n        const right = temp[i]\r\n        if (i === 0) {\r\n            while (index < right) {\r\n                ret[index] = right - index\r\n                index++\r\n            }\r\n        } else {\r\n            const left = temp[i - 1]\r\n            while (index > left && index < right) {\r\n                ret[index] = Math.min(right - index, index - left)\r\n                index++\r\n            }\r\n        }\r\n        // 因为相同的节点直接就是 0，所以直接跳过了\r\n        index++\r\n    }\r\n    // 走完了，如果index<len,做最后一次遍历\r\n    while (index < len) {\r\n        ret[index] = index - temp[temp.length - 1]\r\n        index++\r\n    }\r\n    return ret\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840183957","body":"## [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/solution/zhan-by-jzsq_lyx-u6lz/)\r\n### 分析\r\n1. 用栈保存临时值，每个 [ 都会入栈，所以栈中数字的值肯定和最后 ] 的值保持一致的；\r\n2. 具体规则如下：当 `遇到数字而临时字符串 temp 是非数字字符串时` 或者遇到 ‘[’ 的时候，栈加一个 temp\r\n3. 当遇到 ] 的时候，表示临时字符串结束，需要判断栈顶是否是数字字符串，如果不是，弹出加在 temp 前面，如果是，repeat 字符串\r\n4. 最后会得到一个全是非数字字符串的栈和最后一个 temp，累加栈中的值并最后加上 temp 便是最终结果\r\n```javascript\r\n// 394. 字符串解码\r\n\r\n/**\r\n * @分析\r\n * 1. 创建栈，保存数字和字符串\r\n * 2. 由题目可知：当 `遇到数字而临时字符串 temp 是非数字字符串时` 或者遇到 ‘[’ 的时候，栈加一个 temp\r\n * 3. 当遇到 ] 的时候，表示临时字符串结束，需要判断栈顶是否是数字字符串，如果不是，弹出加在 temp 前面，如果是，repeat 字符串\r\n */\r\n var decodeString = function (s) {\r\n    let stack =[]; // 当 [ 和 第一次出现数字的时候，存储\r\n    let temp = '' // 临时子串\r\n    for(let i = 0;i<s.length;i++){\r\n        const item = s[i]\r\n        if(item === '['){\r\n            stack.push(temp)\r\n            temp = ''\r\n        }else if (item === ']') {\r\n            // 要一直弹出数字位置\r\n            while(isNaN(stack[stack.length-1])){\r\n                temp = stack.pop()+temp\r\n            }\r\n            temp = temp.repeat(stack.pop())\r\n        }else if (!isNaN(item) && isNaN(temp) && temp !=='') {\r\n            //  item 是数字，temp 是非数字字符串，且 temp 不能为空\r\n            stack.push(temp)\r\n            temp = item\r\n        }  else {\r\n            // 普通字符或者普通数字\r\n            temp += item\r\n        }\r\n    }\r\n    let result = ''\r\n    while(stack.length){\r\n        result+=stack.shift()\r\n    }\r\n    return result+temp\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840931530","body":"### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/yong-shu-zu-mo-ni-zhan-ran-hou-mo-ni-dui-5vow/)\r\n\r\n### 分析\r\n1. 对于 js 来说，本身就是用数组模拟栈，现在要用栈模拟队列，所以就按题意，让 stack 不允许直接 pop，然后用栈的特性来处理\r\n2. 时间复杂度:插入 O(1); pop 和 peak 都需要倾倒stack ，所以是 O(N); empty 是 O(1)\r\n\r\n```javascript\r\n// 232. 用栈实现队列\r\n\r\n/**\r\n * @分析\r\n * 1. 既然说是用栈实现，那么就用 arr 模拟栈，只能是后进先出了\r\n * 2. 其实就是用两个栈转换，实现一个队列\r\n */\r\n\r\nvar MyQueue = function () {\r\n    this.stack = []\r\n};\r\n\r\nMyQueue.prototype.push = function (x) {\r\n    this.stack.push(x)\r\n};\r\n\r\n\r\nMyQueue.prototype.pop = function () {\r\n    // 从队列头中弹出\r\n    const tempStack = []\r\n    while (this.stack.length) {\r\n        tempStack.push(this.stack.pop())\r\n    }\r\n    const result = tempStack.pop()\r\n    while (tempStack.length) {\r\n        this.stack.push(tempStack.pop())\r\n    }\r\n    return result\r\n};\r\n\r\n\r\nMyQueue.prototype.peek = function () {\r\n    return this.stack[0] // 这个直接返回即可，不同语言不一样，不行就按照 pop 方法倒水，一样可行\r\n};\r\n\r\n\r\nMyQueue.prototype.empty = function () {\r\n    return !this.stack.length\r\n};\r\n\r\n\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841761407","body":"[ 61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/solution/lian-biao-de-pin-jie-by-jzsq_lyx-4kl6/)\r\n\r\n### 分析\r\n1. 其实新的链表头，就是第一个走了 steps 之后，走到 null 的节点，所以使用 len-steps 找到它在链表的位置 -- 是第 newK 个节点 -- 其中节点是从 0 开始计算的。比方说 [1,2], steps === 1 ，则新的头节点是 2-1 = 1 ，也就是第 1 的节点。\r\n2. 通过 newK 获取到头节点，同时将前一个节点的 next 设置为 null，截断链表\r\n3. 新节点继续走，走到链表尾后，与旧链表拼接起来，得到新的最终链表.\r\n\r\n```javascript\r\n// 61. 旋转链表\r\n\r\n/**\r\n * @分析\r\n * 1. 先计算出 head 的长度，然后对比 k，找出最终结果相对初始结果位移的步数.\r\n * 2. 根据位移的步数，找出旋转后新的 newHead，同时阶段设置好旋转后的尾节点\r\n */\r\n var rotateRight = function(head, k) {\r\n    //  必须有2个以上节点或者进行了位移的，才可以走下面的程序\r\n    if(!head || !head.next) return head\r\n    let len = 0\r\n    let temp = head\r\n    while(temp){\r\n        temp = temp.next\r\n        len++\r\n    }\r\n    // steps 是走的步数，区间是 [0,len)\r\n    let steps = k % len\r\n    // 如果最后是走了 0 步，直接返回\r\n    if(steps === 0) return head\r\n    \r\n    // 走 newK 步后，得到的值就是新的链表头 newHead\r\n    let newK = len - steps\r\n     temp = head\r\n    while(--newK){\r\n        // 这里先减 k 后走节点，是为了得到根节点 temp\r\n        temp = temp.next\r\n    }\r\n    // 获取新的头节点\r\n    const newHead = temp.next\r\n    // 截断旧的链表，得到尾结点\r\n    temp.next = null\r\n    temp = newHead\r\n    // 遍历旧链表，使得旧链表连接到旧链表头\r\n    while(temp && temp.next){\r\n        temp=temp.next\r\n    }\r\n    temp.next = head\r\n    // 最后返回新的链表头\r\n    return newHead\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kofzhang":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835972664","body":"### 思路\r\n1.先转成整数\r\n2.相加\r\n3.再转成数组\r\n### 代码（Python3）\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        inta = 0\r\n        for i in A:\r\n            inta = inta*10 + i\r\n        inta = inta+K\r\n        res = []\r\n        for i in str(inta):\r\n            res.append(int(i))\r\n        return res\r\n        \r\n```\r\n### 复杂度\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837578403","body":"### 思路\r\n解法1：先将所有目标字符位置找出，再遍历整个列表，计算与前后目标字符的距离绝对值，取值小的。\r\n解法2：正反遍历，取小值\r\n### 代码（Python3）\r\n#### 解法1：\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = []\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                l.append(i)\r\n        k = 0\r\n        res = []\r\n        for i in range(len(s)):\r\n            if k!=len(l)-1 and abs(i-l[k])>abs(i-l[k+1]):\r\n                k += 1\r\n            res.append(abs(i-l[k]))\r\n        return res\r\n```\r\n#### 解法2：\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        t = len(s)\r\n        for i in s:\r\n            t=0 if i==c else t+1\r\n            res.append(t)\r\n        for idx,i in enumerate(s[::-1]):\r\n            t = 0 if i==c else t+1\r\n            res[-(idx+1)] = min(t,res[-(idx+1)])\r\n        return res\r\n        \r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839337499","body":"### 思路\r\n用列表实现栈\r\n### 代码（Python3）\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack)<self.maxSize:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack)>0:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(len(self.stack),k)):\r\n            self.stack[i]+=val\r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n### 复杂度\r\n- 时间复杂度：push O(1)  pop O(1)  increment O(k)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840229636","body":"### 思路\r\n用栈存储，倒着遍历，设置一个标志，初始值为False。\r\n当遇到数字的时候，标志设置为True\r\n当标志为True并且是字符的时候，出栈存储到临时列表里，直到遇到\"]\"\r\n将临时列表里的字符转成字符串，再以\"[\"分割，前面的是数值，后面的是字符，进行运算，并将结果压栈\r\n持续处理，直到结束。\r\n小技巧，最后一个如果是数值的话，最后一部分是不处理的，所以在字符串前面加一个字符，最后再删除可以省很多代码。\r\n### 代码（Python3）\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack=[]\r\n        flag = False\r\n        for c in s[::-1]+\"/\":\r\n            \r\n            if c.isdigit():\r\n                flag = True\r\n            if not c.isdigit() and flag:    \r\n                flag = False            \r\n                temp = []\r\n                while True:\r\n                    t = stack.pop()\r\n                    if t!=\"]\":\r\n                        temp.append(t)\r\n                    else:\r\n                        break\r\n                temp = \"\".join(temp).split(\"[\")\r\n                stack.append(int(temp[0])*temp[1])\r\n            stack.append(c)\r\n        stack.pop()\r\n        return \"\".join(stack[::-1])\r\n\r\n        \r\n                    \r\n```\r\n### 复杂度\r\n- 时间复杂度：不会算O(n)?\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840901033","body":"### 思路\r\n用2个列表实现，一个入一个出，入就一直入，出的时候看出列表里是否有值，如果有，直接出，如果没有，把入队列里的数据全部倒过来。\r\n### 代码（Python3）\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.instack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.outstack:\r\n            while self.instack:\r\n                self.outstack.append(self.instack.pop())\r\n        return self.outstack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.outstack:\r\n            while self.instack:\r\n                self.outstack.append(self.instack.pop())\r\n        return self.outstack[-1]\r\n\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.outstack) + len(self.instack)==0\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841575957","body":"### 思路\r\n单调递增栈\r\n用一个单调栈来记录最大和最小\r\n遍历列表，如果当前值小于最大值（最后一个栈值），那它和前面比它大的值都应该在一块，所以，记录最大值，然后把所有比它大的值都出栈，再把当前最大值入栈，表示这些值都是一块。\r\n如果当前值大于等于最大值，那它就可以单独作为一块。\r\n最后返回栈的长度即为所求。\r\n### 代码(Python)\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for i in arr:\r\n            big = stack[-1] if stack else 0\r\n            if i<big:\r\n                while stack and i<stack[-1]:\r\n                    stack.pop()\r\n                stack.append(big)\r\n            else:\r\n                stack.append(i)\r\n        return len(stack)\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841748579","body":"### 思路\r\n利用虚拟头结点。\r\n先遍历，找到长度。并把最后一个的next设置为头。\r\n再次遍历，到k%length的位置，把虚拟头结点的next设置为最后一个节点的next节点。\r\n把最后一个节点的next设置为None。\r\n\r\n### 代码（Python3）\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        length = 0\r\n        virtualhead = ListNode(-1,head)\r\n        cur = virtualhead\r\n        while cur.next:\r\n            length+=1\r\n            cur = cur.next\r\n        cur.next = head\r\n        k = k%length\r\n        cur = head\r\n        for i in range(length-k-1):\r\n            cur = cur.next\r\n        virtualhead.next=cur.next\r\n        cur.next=None\r\n        return virtualhead.next\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pkuphy":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835973571","body":"```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sum = int(''.join(map(str, num))) + k\r\n        sum = map(int, str(sum))\r\n        return sum\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838010994","body":"思路：单调栈\r\n\r\n代码：\r\n\r\n```py\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        pre = -1e4\r\n        length = len(S)\r\n        result = []\r\n\r\n        for i in range(length):\r\n            if S[i] == C: pre = i\r\n            result.append(i - pre)\r\n        pre = 20000\r\n        for i in range(length - 1, -1, -1):\r\n            if S[i] == C: pre = i\r\n            result[i] = min(result[i], pre - i)\r\n        return result\r\n```\r\n\r\n复杂度：\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839389349","body":"#### 思路\r\n用 list 实现栈\r\n\r\n#### 代码\r\n\r\n```py\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        s = min(len(self.stack), k)\r\n        for x in range(s):\r\n            self.stack[x] += val\r\n```\r\n\r\n#### 复杂度\r\n\r\n* 时间复杂度：O(1)\r\n* 空间复杂度：O(n)\r\n\r\n\r\n#### 优化\r\n\r\n另外使用一个 list 记录当前位置以下的数字应该加多少值。\r\n在 `push()` 时插入`0`，`pop()` 时更新值，传递给下一位。\r\n\r\n```py\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.increments = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n            self.increments.append(0)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            val = self.stack.pop()\r\n            inc = self.increments.pop()\r\n            if self.increments:\r\n                self.increments[-1] += inc\r\n            return val + inc\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        s = min(len(self.increments), k)\r\n        if s:\r\n            self.increments[s-1] += val\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840286758","body":"#### 思路\r\n按顺序处理字符串中的每一个字符。使用一个list模拟栈来处理。\r\n```\r\n如果是数字:\r\n    如果栈顶也是数字，将这两个字符合并为一个数字\r\n    否则将该数字压栈\r\n否则：\r\n    如果不是]字符，则将该字符压栈\r\n    否则:\r\n        往前找到匹配的[字符，将这部分拼接为一个字符串，乘以前面的数字后压栈\r\n合并栈中的所有字符串\r\n```\r\n\r\n#### 代码 Python\r\n```py\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n\r\n        for x in s:\r\n            if x.isnumeric():\r\n                if stack and stack[-1].isnumeric():\r\n                    stack.append(stack.pop() + x)\r\n                else:\r\n                    stack.append(x)\r\n            else:\r\n                if x != ']':\r\n                    stack.append(x)\r\n                else:\r\n                    temp = x\r\n                    while temp[0] != '[':\r\n                        temp = stack.pop() + temp\r\n                    stack.append(int(stack.pop()) * temp[1:-1])\r\n        return ''.join(stack)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840960279","body":"```py\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.in_stack = []\r\n        self.out_stack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.in_stack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.out_stack:\r\n            while self.in_stack:\r\n                self.out_stack.append(self.in_stack.pop())\r\n        return self.out_stack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.out_stack:\r\n            return self.out_stack[-1]\r\n        else:\r\n            return self.in_stack[0]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not (self.in_stack or self.out_stack)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841655707","body":"这题比较难，先抄答案……\r\n```py\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n\r\n        for x in arr:\r\n            if not stack:\r\n                stack.append(x)\r\n            else:\r\n                if stack[-1] > x:\r\n                    current_max = stack[-1]\r\n                    while stack and stack[-1] > x:\r\n                        stack.pop()\r\n                    stack.append(current_max)\r\n                else:\r\n                    stack.append(x)\r\n        return len(stack)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tongxw":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835995408","body":"### 思路\r\n\r\nwhile num[i]存在 或者 k不为0:\r\n    当前位sum = 进位 + nums[i](如果存在) + k mod 10 (如果k不为0)；\r\n    倒序遍历num，同时k = k /10;\r\n    进位 carry = sum / 10;\r\n    当前位 digit = sum mod 10;\r\n    输出数组记录digit;\r\n如果最后一位有进位，添加到输出数组中;\r\n倒序返回输出数组；\r\n\r\n\r\n### 代码\r\n```java\r\n/*\r\n * @lc app=leetcode id=989 lang=java\r\n *\r\n * [989] Add to Array-Form of Integer\r\n */\r\n\r\n// @lc code=start\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int i = num.length - 1;\r\n        int carry = 0;\r\n        ArrayList<Integer> res = new ArrayList<>();\r\n        while (i>=0 || k != 0) {\r\n            int sum = carry;\r\n            if (i >= 0) {\r\n                sum += num[i];\r\n                i--;\r\n            }\r\n            if (k != 0) {\r\n                sum += k % 10;\r\n                k /= 10;\r\n            }\r\n\r\n            carry = sum / 10;\r\n            res.add(sum % 10);\r\n        }\r\n\r\n        if (carry > 0) {\r\n            res.add(carry);\r\n        }\r\n\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n// @lc code=end\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)，其中 N 为数组长度。\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837392702","body":"### 思路\r\n正序遍历字符串,\r\n    当c出现时，记录c的位置\r\n    当前字符与c的距离1 = c上次出现的位置 - 当前位置\r\n\r\n逆序遍历字符串，\r\n    当c出现时，记录c的位置\r\n    当前字符与c的距离2 = 当前位置 - c上次出现的位置 \r\n    同时，最短距离 = min(距离1， 距离2）\r\n\r\n### 代码\r\n\r\n```py\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n\r\n        c_pos = -10000 #s.length < 10^4\r\n        i = 0\r\n        for char in s:\r\n            if char == c:\r\n                c_pos = i\r\n            res.append(i - c_pos)\r\n            i = i + 1\r\n        \r\n        c_pos = 10000 #s.length < 10^4\r\n        i = i - 1\r\n        for char in s[::-1]:\r\n            if char == c:\r\n                c_pos = i;\r\n            res[i] = min(res[i], c_pos - i)\r\n            i = i - 1\r\n        \r\n        return res\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)，不考虑输出数组。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839237025","body":"### 思路\r\n数组记录栈元素\r\n记录最大值\r\n### 代码\r\n\r\n```java\r\nclass CustomStack {\r\n    private ArrayList<Integer> arr;\r\n    private int maxSize = 0;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        this.arr = new ArrayList<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (arr.size() == maxSize) {\r\n            return;\r\n        }\r\n\r\n        arr.add(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (arr.size() > 0) {\r\n            return arr.remove(arr.size() - 1);\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i=0; i<arr.size() && k>0; i++,k--) {\r\n            arr.set(i, arr.get(i) + val);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： push: O(1), pop: O(1), increment: O(N)，其中 N 为栈长度。\r\n- 空间复杂度：O(N)，N为栈长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840167926","body":"### 思路\r\n类似用栈判断括号匹配，每次括号匹配都是一次解析子串的过程。\r\nwhile 遍历字符串：\r\n1. 数字，记录到number中（不能立刻进栈因为数字可能不止一位）\r\n2. 字符，进栈\r\n3. 左侧括号，如果number不为空，进栈，然后number字符串清空；左侧括号也进栈。\r\n4. 右侧括号，栈顶元素依次出栈同时逆向组合到临时的字符串中，碰到左侧括号后，左侧括号的下一位就是重复的次数。之后把这次处理好的字符串压进栈。\r\n遍历结束后，栈里所有解析好的字串依次出栈，逆向组成结果。\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        char[] chars = s.toCharArray();\r\n        Stack<String> stack = new Stack<>();\r\n        String number = \"\";\r\n        \r\n        for (char c: chars) {\r\n            if (c >= '0' && c<= '9') {\r\n                number += c;\r\n            } else if (c == '[') {\r\n                if (!\"\".equals(number)) {\r\n                    stack.push(number);\r\n                    number = \"\";\r\n                }\r\n                stack.push(String.valueOf(c));\r\n            } else if (c == ']') {\r\n                // pop\r\n                String topStr;\r\n                StringBuffer buffer = new StringBuffer();\r\n                while (!\"[\".equals(topStr = stack.pop())) {\r\n                    buffer.insert(0, topStr);\r\n                }\r\n \r\n                String tmp = buffer.toString();\r\n                int repeat = Integer.parseInt(stack.pop()) - 1;\r\n                while (repeat != 0) {\r\n                    buffer.append(tmp);\r\n                    repeat--;\r\n                }\r\n                stack.push(buffer.toString());\r\n            } else {\r\n                // 'a' - 'z'\r\n                stack.push(String.valueOf(c));\r\n            }\r\n        }\r\n\r\n        StringBuffer res = new StringBuffer();\r\n        while (stack.size() != 0) {\r\n            res.insert(0, stack.pop());\r\n        }\r\n\r\n        // \"\"100[a]\"\"\r\n        // \"\"3[2[a]]\"\"\r\n        // \"\"30[22[a]]\"\"\r\n        // \"\"3[b3[a]]\"\"\r\n        return res.toString();\r\n    }\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： O(N), N为解析后字符串长度 。\r\n- 空间复杂度：O(N)，N为解析后字符串长度。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840879664","body":"### 思路\r\n入列时用一个栈来记录所有元素；\r\n因为队列头实际在栈底，所以在出列时需要另外一个辅助栈来把当前栈反转；\r\n因此入列时需要把这个辅助栈再进行反转找到队尾；\r\n判断队列为空的条件时两个栈都为空；\r\n可以在push和pop操作的同时记录队列头，peek直接返回：push时如果队列为空则更新队列头；pop时把辅助栈的栈顶第二个元素更新为队列头。\r\n\r\n### 代码\r\n\r\n```py\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.push_stack = []\r\n        self.pop_stack = []\r\n        self.top = 0\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        if self.empty():\r\n            self.top = x\r\n\r\n        while self.pop_stack:\r\n            self.push_stack.append(self.pop_stack.pop())\r\n        self.push_stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        while self.push_stack:\r\n            self.pop_stack.append(self.push_stack.pop())\r\n        ret = self.pop_stack.pop()\r\n        if self.pop_stack:\r\n            self.top = self.pop_stack.pop()\r\n            self.pop_stack.append(self.top)\r\n        else:\r\n            self.top = 0\r\n        return ret\r\n        \r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.top\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.push_stack and not self.pop_stack\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： push: 最差O(N)，连续push为O(1)； pop: O(N),连续pop为O(1)；peek: O(1)；empty: O(1) 。\r\n- 空间复杂度：O(N)，N为栈长度。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841539143","body":"### 思路\r\n想了30分钟总结不出规律，网上搜的提示……\r\n1. 在数组任意位置i,如果[0...i]的最大值，比[i+1..len-1]的最小值要小，那么就可以算作一个“块”。否则的话，排序的时候从右侧必须要换到左侧来，根据题目要求就不能算作一个块。\r\n2. 根据上述规律，对于数组的任意位置i，先计算[0...i]的最大值max，再计算[i+1...len-1]的最小值min，如果max[i] <= min[i+1]，就可以分出一个“块”。\r\n3. 边界条件是任何数组至少会有一个块。\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int len = arr.length;\r\n        if (len == 1) {\r\n            return 1;\r\n        }\r\n\r\n        int[] maxFromleft = new int[len];\r\n        int[] minFromRight = new int[len];\r\n\r\n        maxFromleft[0] = arr[0];\r\n        for (int i=1; i<len; i++) {\r\n            maxFromleft[i] = Math.max(maxFromleft[i-1], arr[i]);\r\n        }\r\n\r\n        minFromRight[len-1] = arr[len-1];\r\n        for (int i=len-2; i>=0; i--) {\r\n            minFromRight[i] = Math.min(minFromRight[i+1], arr[i]);\r\n        }\r\n\r\n        int count = 1;\r\n        for (int i=0; i<len-1; i++) {\r\n            if (maxFromleft[i] <= minFromRight[i+1]) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        return count;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： O(N)，N为数组长度\r\n- 空间复杂度：O(N)，N为数组长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841724168","body":"### 思路\r\n新的链表头应该是原链表的倒数第k个节点；\r\nk可能大于链表长度，所以首先计算链表长度，再求余计算实际向右移动了多少步\r\n之后求出原链表的倒数第k个节点，它是新链表头，修改原链表相应节点指针后返回新链表头。\r\n当链表为空或者只有一个节点或者k是链表长度整数倍的时候，直接返回原链表头。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n\r\n        // get the length and last node\r\n        ListNode last = head;\r\n        int len = 1;\r\n        while (last.next != null) {\r\n            last = last.next;\r\n            len++;\r\n        }\r\n\r\n        k = k % len;\r\n        if (k == 0) {\r\n            return head;\r\n        }\r\n\r\n        // get the kth node from the last\r\n        ListNode first = head;\r\n        ListNode second = head;\r\n        ListNode preSecond = null;\r\n        while (first != null) {\r\n            first = first.next;\r\n            if (k != 0) {\r\n                k--;\r\n            } else {\r\n                preSecond = second;\r\n                second = second.next;\r\n            }\r\n        }\r\n\r\n        preSecond.next = null;\r\n        last.next = head;\r\n        return second;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为链表长度。\r\n- 空间复杂度：O(1)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bolunzhang2021":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836052238","body":"哈？老哥你不会是发错了吧😂\n\nxmlb88 ***@***.***> 于 2021年5月9日周日 下午9:38写道：\n\n> vector<int> addToArrayForm(vector<int>& num, int k) {\n>     vector<int> res;\n>     for (int i = num.size() - 1; i >= 0; --i) {\n>         int sum = num[i] + (k % 10);\n>         k /= 10;\n>         if (sum / 10) ++k;\n>         res.push_back(sum % 10);\n>     }\n>\n>     while (k) {\n>         res.push_back(k % 10);\n>         k /= 10;\n>     }\n>\n>     reverse(res.begin(), res.end());\n>     return res;\n> }\n>\n> —\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836050621>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AT7X2IERQBJMNHNNMTESUQLTM42KPANCNFSM44PJ5S6A>\n> .\n>\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837866279","body":"代码：JAVA\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int N=s.length\r\n     for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n prev = Integer.MAX_VALUE / 2; //整型反转，防止越界\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n时间复杂度 O（n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839781395","body":"class CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n时间复杂度 O（k)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841295187","body":"语言：JAVA\r\n思路：用输入栈，输出栈实现\r\nclass MyQueue {\r\n    private Stack<Integer> a;// 输入栈\r\n    private Stack<Integer> b;// 输出栈\r\n    \r\n    public MyQueue() {\r\n        a = new Stack<>();\r\n        b = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        a.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(b.isEmpty()){\r\n            while(!a.isEmpty()){\r\n                b.push(a.pop());\r\n            }\r\n        }\r\n        return b.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(b.isEmpty()){\r\n            while(!a.isEmpty()){\r\n                b.push(a.pop());\r\n            }\r\n        }\r\n        return b.peek();\r\n}\r\n    \r\n    public boolean empty() {\r\n        return a.isEmpty() && b.isEmpty();\r\n    }\r\n}\r\n时间复杂度O（1）\r\n空间复杂度O（N）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841681227","body":"思路：并不会，复制的.....\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) nonzero--;\r\n            if (count.get(x) == 1) nonzero++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) nonzero++;\r\n            if (count.get(y) == 0) nonzero--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n时间复杂度 O(NlogN)\r\n空间复杂度：O(N)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xmlb88":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836051481","body":"c++:\r\n```c++\r\nvector<int> addToArrayForm(vector<int>& num, int k) {\r\n    vector<int> res;\r\n    for (int i = num.size() - 1; i >= 0; --i) {\r\n        int sum = num[i] + (k % 10);\r\n        k /= 10;\r\n        if (sum / 10) ++k;\r\n        res.push_back(sum % 10);\r\n    }\r\n\r\n    while (k) {\r\n        res.push_back(k % 10);\r\n        k /= 10;\r\n    }\r\n\r\n    reverse(res.begin(), res.end());\r\n    return res;\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837629554","body":"```c++\r\n// 暴力\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> idx;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) idx.push_back(i);\r\n    }\r\n\r\n    vector<int> res;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        int dis = INT_MAX;\r\n        for (int j = 0; j < idx.size(); ++j) {\r\n            dis = min(dis, abs(i - idx[j]));\r\n        }\r\n        res.push_back(dis);\r\n    }\r\n\r\n    return res;\r\n}\r\n```\r\n\r\n```c++\r\n// 2次遍历\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> res;\r\n    int last_idx = INT_MAX;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) last_idx = i;\r\n        res.push_back(abs(last_idx - i));\r\n    }\r\n\r\n    last_idx = INT_MAX;\r\n    for (int i = s.size() - 1; i >= 0; --i) {\r\n        if (s[i] == c) last_idx = i;\r\n        res[i] = min(res[i], abs(last_idx - i));\r\n    }\r\n    \r\n    return res;\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839383175","body":"#### 数组模拟 ####\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    int max_size;\r\n    vector<int> st;\r\n    CustomStack(int maxSize) {\r\n        max_size = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (st.size() >= max_size) {\r\n            return;\r\n        }\r\n        st.push_back(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if (!st.empty()) {\r\n            int temp = st.back();\r\n            st.pop_back();\r\n            return temp;\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        k = min(k, (int)st.size());\r\n        for (int i = 0; i < k; ++i) {\r\n            st[i] += val;\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n#### 优化increment ####\r\n> 用一个额外的add数组先存储increment操作\r\n> pop的时候再计算结果返回，add中对应的数累加到前一个数上\r\n> 时间复杂度O(1)\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    vector<int> st, add;\r\n    int idx = -1;\r\n    CustomStack(int maxSize) {\r\n        st.resize(maxSize, 0);\r\n        add.resize(maxSize, 0);\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (idx == st.size() - 1) return;\r\n        st[++idx] = x;\r\n    }\r\n    \r\n    int pop() {\r\n        if (idx == -1) return -1;\r\n        int ret = st[idx] + add[idx];\r\n        if (idx >= 1) {\r\n            add[idx - 1] += add[idx];\r\n        }\r\n        add[idx] = 0;\r\n        --idx;\r\n        return ret;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        k = min(k - 1, idx);\r\n        if (k >= 0) {\r\n            add[k] += val;\r\n        }\r\n    }\r\n};\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840500709","body":"```c++\r\nstring decodeString(string s) {\r\n    stack<char> st_c;\r\n    stack<int> st_i;\r\n    \r\n    int num = 0;\r\n    for (char c : s) {\r\n        if (isdigit(c)) {\r\n            num = num * 10 + (c - '0');\r\n        } else {\r\n            if (c == '[') {\r\n                st_i.push(num);\r\n                num = 0;\r\n                st_c.push(c);\r\n            } else if (c == ']') {\r\n                string s;\r\n                while (st_c.top() != '[') {\r\n                    s.push_back(st_c.top());\r\n                    st_c.pop();\r\n                }\r\n                st_c.pop();\r\n                int count = st_i.top();\r\n                st_i.pop();\r\n                string s_repeat;\r\n                while (count--) {\r\n                    s_repeat += s;\r\n                }\r\n                while (!s_repeat.empty()) {\r\n                    st_c.push(s_repeat.back());\r\n                    s_repeat.pop_back();\r\n                }\r\n            } else {\r\n                st_c.push(c);\r\n            }\r\n        }\r\n    }\r\n\r\n    string res;\r\n    while (!st_c.empty()) {\r\n        res.push_back(st_c.top());\r\n        st_c.pop();\r\n    }\r\n    reverse(res.begin(), res.end());\r\n    return res;\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840942859","body":"#### 双栈解法 ####\r\n- 进栈时直接push进输入栈，出栈时若输出栈有元素，直接输出，若没有元素，把输入栈中的所有元素倒入输出栈再输出\r\n- 语言： c++\r\n```c++\r\nclass MyQueue {\r\npublic:\r\n    stack<int> st_in, st_out;\r\n    MyQueue() {\r\n\r\n    }\r\n\r\n    void push(int x) {\r\n        st_in.push(x);\r\n    }\r\n\r\n    void from_in_to_out() {\r\n        if (st_out.empty()) {\r\n            while (!st_in.empty()) {\r\n                st_out.push(st_in.top());\r\n                st_in.pop();\r\n            }\r\n        }\r\n    }\r\n\r\n    int pop() {\r\n        from_in_to_out();\r\n        int res = st_out.top();\r\n        st_out.pop();\r\n        return res;\r\n    }\r\n\r\n    int peek() {\r\n        from_in_to_out();\r\n        return st_out.top();\r\n    }\r\n\r\n    bool empty() {\r\n        return st_in.empty() && st_out.empty();\r\n    }\r\n\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841614740","body":"### 栈保存每部分最大值 ###\r\n```c++\r\nint maxChunksToSorted(vector<int>& arr) {\r\n    stack<int> st;\r\n    for (int num : arr) {\r\n        if (!st.empty() && num < st.top()) {\r\n            int head = st.top();\r\n            st.pop();\r\n            while (!st.empty() && num < st.top()) st.pop();\r\n            st.push(head);\r\n        } else {\r\n            st.push(num);\r\n        }\r\n    }\r\n    return st.size();\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Saberfish":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836053127","body":"## 代码\r\n\r\nC++ :\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int i=num.size()-1;\r\n        while(k>0){\r\n            k=k+num[i];\r\n            num[i]=k%10;\r\n            k=k/10;\r\n            i--;\r\n            if(i<0 && k>0){\r\n                num.insert(num.begin(),0);\r\n                i=0;\r\n            }\r\n        }\r\n        return num;\r\n    }\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837693091","body":"### 思路\r\n\r\n\t先把所有目标字符的下标存到数组里面，再进行遍历查找每个字符的距离。\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int lenS=S.size();\r\n        vector<int> dest={};\r\n        for(int i=0;i<lenS;i++){\r\n            if(C==S[i]){\r\n                dest.insert(dest.end(),i);\r\n            }\r\n        }\r\n        int lenD=dest.size();\r\n        vector<int> output={};\r\n        for(int i=0;i<lenS;i++){\r\n            int a=i;\r\n            int distance=10000;\r\n            for(int j=0;j<lenD;j++){\r\n                int b=dest[j];\r\n                int dis=0;\r\n                if(a<b){\r\n                    dis=b-a;\r\n                }\r\n                else{\r\n                    dis=a-b;\r\n                }\r\n                if(dis<distance){\r\n                    distance=dis;\r\n                }\r\n            }\r\n            output.insert(output.end(),distance);\r\n        }\r\n        return output;\r\n    }\r\n};\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839367190","body":"vector模拟\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass CustomStack {\r\npublic:\r\n    vector<int> modifyStack;//这是声明还是定义？\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        top=-1;\r\n        modifyStack.resize(maxSize);\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top==modifyStack.size()-1){\r\n            return;\r\n        }\r\n        modifyStack[++top]=x;\r\n    }\r\n    \r\n    int pop() {\r\n        if(top==-1){\r\n            return -1;\r\n        }else{\r\n            return modifyStack[top--];\r\n        }\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        if(k>modifyStack.size()) k=modifyStack.size();\r\n        for(int i=0;i<k;i++){\r\n            modifyStack[i]+=val;\r\n        }\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840637813","body":"维护两个栈，一个用来存数字，一个用来存字符串\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<int> k_stack;\r\n        stack<string> s_stack;\r\n        string curStr;\r\n        int length=s.length();\r\n        int temp=0;\r\n        for(int i=0;i<length;i++){\r\n            if(isdigit(s[i])){\r\n                //temp=temp*10+s[i]-'0';\r\n                do{\r\n                    temp=temp*10+s[i]-'0';\r\n                }while(isdigit(s[++i]));\r\n                --i;\r\n            }else if(isalpha(s[i])){\r\n                curStr+=s[i];\r\n            }else if(s[i]=='['){\r\n                k_stack.push(temp);\r\n                temp=0;\r\n                s_stack.push(curStr);\r\n                curStr.clear();\r\n            }else{//s[i]=']'\r\n                int times=k_stack.top();\r\n                k_stack.pop();\r\n                for(int j=0;j<times;j++){\r\n                    s_stack.top()+=curStr;\r\n                }\r\n                curStr=s_stack.top();\r\n                s_stack.pop();\r\n            }\r\n        }\r\n        return curStr;\r\n    }\r\n};\r\n```\r\n复杂度：\r\n时间 O(N)\r\n空间 O(N）\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841192447","body":"## 思路\r\n一个入栈，一个出栈。当进行pop和peak操作的时候先判断出栈是否为空，为空就将入栈的元素倒过去，非空就直接pop返回值。\r\n## 代码\r\n\r\n```C++\r\nclass MyQueue{\r\npublic:\r\n    stack<int> inStack;\r\n    stack<int> outStack;\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if(outStack.empty()){\r\n            while (!inStack.empty())\r\n            {\r\n                outStack.push(inStack.top());\r\n                inStack.pop();\r\n            }\r\n        }\r\n        int temp=outStack.top();\r\n        outStack.pop();\r\n        return temp;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if(outStack.empty()){\r\n            while (!inStack.empty())\r\n            {\r\n                outStack.push(inStack.top());\r\n                inStack.pop();\r\n            }\r\n        }\r\n        return outStack.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        if(inStack.empty()&&outStack.empty()){\r\n            return true;\r\n        }\r\n        else return false;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- ​\t时间复杂度o(1)\r\n- ​\t空间复杂度o(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841661300","body":"### 思路\r\n使用单调栈，栈内保存的是局部最大值，实际上要求达到的效果就是后一个块的最小值大于前一个块的最大值\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        int len=arr.size();\r\n        stack<int> localMaxVal;\r\n        localMaxVal.push(arr[0]);\r\n        for(int i=1;i<len;i++){\r\n            int curVal=max(localMaxVal.top(),arr[i]);\r\n            while (!localMaxVal.empty() && arr[i]<localMaxVal.top())\r\n            {\r\n                localMaxVal.pop();\r\n            }\r\n            localMaxVal.push(curVal);\r\n            \r\n        }\r\n        return localMaxVal.size();\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n）\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiongyujie":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836058937","body":"语言：java\r\n时间复杂度：O(9n) => O(n) ,数组插入\r\n空间复杂度：除去输出结果,空间复杂度O(1)\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int out = 0 ;\r\n        int len = num.length;\r\n        int i = len - 1;\r\n        for(; i >= 0 && k > 0; i--){\r\n            int tmp =out + num[i] +  k % 10;\r\n            out = tmp / 10;\r\n            k = k / 10;\r\n            res.add(0, tmp % 10);\r\n        }\r\n        while(i >= 0){\r\n            int tmp = out + num[i];\r\n            out = tmp / 10;\r\n            res.add(0, tmp % 10);\r\n            i--;\r\n        }\r\n        while(k > 0){\r\n            int tmp = out + k % 10;\r\n            k = k / 10;\r\n            out = tmp / 10;\r\n            res.add(0, tmp % 10);\r\n        }\r\n        if(out > 0){\r\n            res.add(0, out);\r\n        }\r\n        return res ;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837711066","body":"思路：两次遍历，第一次记住字符c的下标，第二次计算与字符c的最近距离。\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        List<Integer> tmp = new ArrayList<>();\r\n        int index = 0 ;\r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i) == c){\r\n                tmp.add(i);\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < len; i++ ){\r\n            int cur =  tmp.get(index);\r\n            if(index < 1){\r\n                res[i] = Math.abs(i - cur);\r\n            }else{\r\n                res[i] = Math.min(Math.abs(i - cur), Math.abs(i - tmp.get(index - 1)));\r\n            }\r\n            if(i == tmp.get(index) && (index + 1) < tmp.size()){\r\n                index ++ ;\r\n            }\r\n        }\r\n        return res ;\r\n\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839383583","body":"思路：就是用数组记录一下\r\n时间复杂度：增量操作O(min(k,top),其他O(1)\r\n空间复杂度：使用数组O(n)\r\n\r\n```\r\nclass CustomStack {\r\n    int[] arr;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        top = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top < arr.length){\r\n            arr[top++] = x;\r\n        }\r\n\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top == 0){\r\n            return -1;\r\n        }\r\n        return arr[--top];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i = 0; i < k && i < top; i++){\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840350994","body":"麻瓜，做了半天\r\n```\r\nclass Solution {\r\n\r\n    public String decodeString(String s) {\r\n        Stack<Integer> sk1 = new Stack<>();\r\n        Stack<String> sk2 = new Stack<>();\r\n        int i = 0;\r\n        int len = s.length();\r\n        StringBuilder sb = new StringBuilder();\r\n        int num = 0;\r\n        while(i < len){\r\n            char ch =  s.charAt(i);    \r\n            i++;    \r\n            if(ch - '0' >= 0 && ch - '0' < 10){\r\n               num = num * 10 + (ch - '0');\r\n            }else if(ch == '['){\r\n                sk1.add(num);\r\n                num = 0;\r\n                while(ch - 'a' >= 0 && ch - 'a' < 26 && i < len){\r\n                    ch = s.charAt(i++);\r\n                    sb.append(ch);\r\n                }\r\n                sk2.add(sb.toString());\r\n                sb = new StringBuilder();\r\n            }else if(ch == ']'){\r\n                int num2 = sk1.pop();\r\n                String str = sk2.pop();\r\n                for(int j = 0; j < num2; j++){\r\n                    sb.append(str);\r\n                }\r\n                if(sk2.isEmpty()){\r\n                    sk2.add(sb.toString());\r\n                }else{\r\n                    sk2.add( sk2.pop() + sb.toString());\r\n                }\r\n                sb = new StringBuilder();\r\n            }else{\r\n                 if(sk2.isEmpty()){\r\n                    sk2.add(\"\" + ch);\r\n                }else{\r\n                    sk2.add(sk2.pop() + \"\" + ch);\r\n                }\r\n            }\r\n\r\n        }\r\n        return sk2.pop();\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840965702","body":"简单题还是好做啊\r\n分析：用两个栈模拟，一个\"出栈\"，一个\"入栈\"。每次入队的时候，判断\"出栈\"是否为空，如果不为空，将出栈的数据压入”入栈“，每次出队的时候，判断”入栈“是否为空，如果不为空，将入栈数据压入出栈。\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> inSk;\r\n    Stack<Integer> outSk;\r\n    public MyQueue() {\r\n        inSk = new Stack<>();\r\n        outSk = new Stack<>();\r\n    }\r\n    \r\n\r\n    public void push(int x) {\r\n        while(!outSk.isEmpty()){\r\n            inSk.add(outSk.pop());\r\n        }\r\n        inSk.add(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        while(!inSk.isEmpty()){\r\n            outSk.add(inSk.pop());\r\n        }\r\n        return outSk.pop();\r\n    }\r\n    public int peek() {\r\n         while(!inSk.isEmpty()){\r\n            outSk.add(inSk.pop());\r\n        }\r\n        return outSk.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n\r\n        return inSk.isEmpty() && outSk.isEmpty();\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Syan115":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836060783","body":"思路：\r\n1. 从低位起按位相加，注意进位问题\r\n2. list反转一下\r\n\r\n复杂度分析\r\n- 时间复杂度O(n)\r\n- 空间复杂度O(n)\r\n\r\n```class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n = num.length;\r\n        int sum = 0;\r\n        List<Integer> res = new ArrayList<>();\r\n        // 按位相加\r\n        for(int i=n-1; i>=0; i--){\r\n            sum = num[i] + k%10;\r\n            if(sum>=10){\r\n                sum = sum%10;\r\n                k = k+10;\r\n            }\r\n            res.add(sum);\r\n            k = k/10;          \r\n        }\r\n        while(k!=0){\r\n            res.add(k%10);\r\n            k = k/10;\r\n        }\r\n\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n} \r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837606516","body":"## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n\r\n## 思路\r\n分别从左向右和从右向左的遍历来获得当前位置字符与目标字符的距离，并取两者中较小的那一个。\r\n\r\n\r\n\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] dist = new int[length];\r\n        \r\n        // 从左遍历\r\n        int loc = 10000;\r\n        for(int i=0;i<length;i++){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.abs(i-loc);\r\n        }\r\n\r\n        // 从右遍历\r\n        for(int i=length-1;i>=0;i--){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.min(dist[i],Math.abs(i-loc));\r\n        }\r\n\r\n        return dist;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为字符串长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839404224","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n\r\n\r\n## 思路\r\n\r\n用数组来实现，设置一个指针top标识栈顶元素\r\n\r\n\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass CustomStack {\r\n    int[]stack;\r\n    int top; // 标识栈顶\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1; //最开始栈为空\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top < stack.length-1){\r\n            top++;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top == -1) return top;\r\n        top--;\r\n        return stack[top+1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        // 这是栈顶的K个元素 救命\r\n        // int start = Math.max(0,top-k+1);\r\n        // for(int i=start;i<=top;i++){\r\n        //     stack[i] += val;\r\n        // }\r\n\r\n        // 栈底的k个元素\r\n        int end = Math.min(top+1,k);\r\n        for(int i=0;i<end;i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840459584","body":"\r\n## 题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n\r\n```\r\n\r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n\r\n```\r\n\r\n\r\n## 思路\r\n- 题目主要是涉及到了括号嵌套的问题，先从内从括号展开，再展开外层，这一方式联想到使用栈来解决\r\n- 利用两个栈来分别存储信息，一个存储重复次数，一个存储内容\r\n\r\n\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        int times = 0; // 重复次数\r\n        StringBuilder res = new StringBuilder(); // 结果记录\r\n        Deque<Integer> numStack = new LinkedList<>();\r\n        Deque<StringBuilder> strStack = new LinkedList<>();\r\n\r\n        for(char c:s.toCharArray()){ \r\n            if(Character.isDigit(c)){ // 是数字的话记录重复次数（可能有多位数字\r\n                times = times*10 + c -'0';\r\n            }\r\n            else if(Character.isAlphabetic(c)){  // 是字母的话记录进res中\r\n                res.append(c);\r\n            }\r\n            else if(c == '['){ // 左括号的话把字母和次数都入栈\r\n                numStack.push(times);\r\n                strStack.push(res);\r\n                times = 0;\r\n                res = new StringBuilder(); //相当于把二者都清空\r\n            }else{ // 相当于c == ']'\r\n                int n = numStack.pop(); // 字符串要重复的次数\r\n                StringBuilder tmp = strStack.pop(); \r\n                for(int i=0;i<n;i++){\r\n                    tmp.append(res);\r\n                }\r\n                res = tmp;\r\n            } \r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为字符串长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841120667","body":"\r\n## 题目地址(232. 用栈实现队列)\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\r\n\r\n实现 MyQueue 类：\r\n\r\nvoid push(int x) 将元素 x 推到队列的末尾\r\nint pop() 从队列的开头移除并返回元素\r\nint peek() 返回队列开头的元素\r\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\r\n\r\n\r\n```\r\n\r\n\r\n## 思路\r\n-  利用两个栈 stackIn stackOut来实现队列先进先出的特性\r\n\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass MyQueue {\r\n    Deque<Integer> stackIn;\r\n    Deque<Integer> stackOut;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stackIn = new LinkedList<Integer>();\r\n        stackOut = new LinkedList<Integer>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        stackIn.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(stackOut.isEmpty()){\r\n            while(!stackIn.isEmpty()){\r\n            stackOut.push(stackIn.pop());\r\n            }\r\n        }\r\n        return stackOut.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(stackOut.isEmpty()){\r\n            while(!stackIn.isEmpty()){\r\n            stackOut.push(stackIn.pop());\r\n            }\r\n        }\r\n        return stackOut.peek();\r\n\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        if(stackIn.isEmpty() && stackOut.isEmpty()) return true;\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841680241","body":"\r\n## 题目地址(768. 最多能完成排序的块 II)\r\n\r\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\r\n\r\n## 题目描述\r\n\r\n```\r\n这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\r\n\r\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\r\n\r\n我们最多能将数组分成多少块？\r\n\r\n示例 1:\r\n\r\n输入: arr = [5,4,3,2,1]\r\n输出: 1\r\n解释:\r\n将数组分成2块或者更多块，都无法得到所需的结果。\r\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \r\n\r\n\r\n注意:\r\n\r\narr的长度在[1, 2000]之间。\r\narr[i]的大小在[0, 10**8]之间。\r\n```\r\n\r\n## 思路\r\n-  对输入数组进行排序，如果数组前k项与排序后前k项相同，则可以分块\r\n\r\n## 代码\r\n\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) nonzero--;\r\n            if (count.get(x) == 1) nonzero++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) nonzero++;\r\n            if (count.get(y) == 0) nonzero--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841696200","body":"\r\n## 题目地址(61. 旋转链表)\r\n\r\nhttps://leetcode-cn.com/problems/rotate-list/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\r\n\r\n\r\n\r\n示例 1：\r\n\r\n输入：head = [1,2,3,4,5], k = 2\r\n输出：[4,5,1,2,3]\r\n\r\n\r\n```\r\n\r\n\r\n## 思路\r\n- 用快慢指针做，快指针比慢指针先走K步\r\n- fast指向尾节点时，slow指向newHead的prev。此时令fast.next = head;  slow.next为旋转后的newHead； slow.next = null\r\n\r\n```java\r\n\r\n\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null || k == 0) return head;\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n\r\n        // 得到链表长度\r\n        ListNode node = head;\r\n        int size = 0;\r\n        while(node!=null){\r\n            size++;\r\n            node = node.next;\r\n        }\r\n\r\n        // 快指针先走K步,注意k可能大于size，故对其取余\r\n        if(k%size == 0) return head; //考虑k是size倍数的情况\r\n        for(int i=0;i<k%size;i++){\r\n            fast = fast.next;\r\n        }\r\n\r\n        while(fast.next != null){\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n\r\n        // 此时fast指向尾节点，slow指向倒数第K+1个节点，也就是新的头节点的prev\r\n        ListNode newHead = slow.next;\r\n        slow.next = null;\r\n        fast.next = head;\r\n\r\n        return newHead;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为链表长度\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"NorthSeacoder":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836063398","body":"## 思路\r\n利用 BigInt 计算\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n    \r\n    return (BigInt(num.join('')) + BigInt(k)).toString().split('')\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(1),没遍历数组....\r\n- 空间复杂度：O(n), 直接把数组转成 BigInt,不确定这里对不对...."},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838453454","body":"## 思路\r\n- 字符串拆成数组,并查询c 的所有下标\r\n- 遍历数组查询每个下标到 c 的最短距离\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n    const res=[],sIndexs=[];\r\n    \r\n    s.split('').forEach((char,index)=>{\r\n        if(char===c)sIndexs.push(index)\r\n    })\r\n    for(let i = 0;i<s.length;i++){\r\n        let tem = sIndexs.map(item=>Math.abs(i-item)).sort((a,b)=>a-b).shift();\r\n        res.push(tem)\r\n    }\r\n    return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n*m) m为字符 c 在 s 中的重复次数\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839371890","body":"## 思路\r\n\r\n-   直接利用数组模拟\r\n\r\n## 代码\r\n\r\n<details>\r\n<summary>展开查看</summary>\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n    this.maxSize = maxSize;\r\n    this.stack = [];\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n    if (this.stack.length < this.maxSize) {\r\n        this.stack.unshift(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n    return this.stack.shift() || -1;\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n    const n = this.stack.length;\r\n    for (let i = n - 1; i >= 0 && n - 1 - i < k; i--) {\r\n        this.stack[i] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n</details>\r\n\r\n## 复杂度分析\r\n\r\n-   时间复杂度:push/pop:O(1);inc:O(k)\r\n-   空间复杂度:O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840240878","body":"## 思路\r\n辅助栈\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s) {\r\n    let repeats = 0, res = ''; const strStack = [], numStack = [];\r\n    for (let str of s) {\r\n        if (!isNaN(str)) {//是数字\r\n            repeats = 10 * repeats + +str;\r\n        } else if (str === '[') {\r\n            //进入下一层\r\n            numStack.push(repeats);\r\n            repeats = 0;\r\n            strStack.push(res);\r\n            res = ''\r\n        } else if (str === ']') {\r\n            res = strStack.pop() + res.repeat(numStack.pop())\r\n        } else {\r\n            res += str\r\n        }\r\n    }\r\n        return res\r\n\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840939664","body":"## 思路\r\n\r\n-   用栈模拟,则数组只能调用 push()和 pop()\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function () {\r\n    this.stack = [];\r\n    this._stack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n    this.stack.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n    let cur = null;\r\n    while (cur = this.stack.pop()) {\r\n        this._stack.push(cur)\r\n    }\r\n    const res = this._stack.pop();\r\n    while (cur = this._stack.pop()) {\r\n        this.stack.push(cur)\r\n    }\r\n    return res\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n    return this.stack[0]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n    return this.stack.length === 0\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：push/peek/empty:O(1);pop:O(n)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841661238","body":"## 思路\r\n单调栈,具体见注释\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function (arr) {\r\n    let stack = [];\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        if (stack.length === 0 || stack[stack.length - 1] <= arr[i]) {\r\n            //单调递增栈,栈中的每个值就是一个分块中的极大值\r\n            stack.push(arr[i])\r\n        } else {//当前值小于栈顶元素即tem<arr[i]\r\n            //临时保存单调栈中最大值(当前值可以加入栈顶元素所代表的块)\r\n            let tem = stack.pop();\r\n            //一个元素代表一个块,当前值此时压入最大值所在的块中,该块的区间为[当前值,最大值]\r\n            //剩下单调栈中不应该存在大于当前值的元素\r\n            //因此剩余单调栈中大于当前值的元素意味着可以压入新块中\r\n            while (stack[stack.length - 1] > arr[i]) {\r\n                stack.pop()\r\n            }\r\n            stack.push(tem)\r\n        }\r\n    }\r\n        return stack.length\r\n};\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shizukanaskytree":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836063868","body":"\r\n## 题目地址(989. Add to Array-Form of Integer)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\nThe array-form of an integer num is an array representing its digits in left to right order.\r\n\r\nFor example, for num = 1321, the array form is [1,3,2,1].\r\n\r\nGiven num, the array-form of an integer, and an integer k, return the array-form of the integer num + k.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: num = [1,2,0,0], k = 34\r\nOutput: [1,2,3,4]\r\nExplanation: 1200 + 34 = 1234\r\n\r\n\r\nExample 2:\r\n\r\nInput: num = [2,7,4], k = 181\r\nOutput: [4,5,5]\r\nExplanation: 274 + 181 = 455\r\n\r\n\r\nExample 3:\r\n\r\nInput: num = [2,1,5], k = 806\r\nOutput: [1,0,2,1]\r\nExplanation: 215 + 806 = 1021\r\n\r\n\r\nExample 4:\r\n\r\nInput: num = [9,9,9,9,9,9,9,9,9,9], k = 1\r\nOutput: [1,0,0,0,0,0,0,0,0,0,0]\r\nExplanation: 9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\nConstraints:\r\n\r\n1 <= num.length <= 104\r\n0 <= num[i] <= 9\r\nnum does not contain any leading zeros except for the zero itself.\r\n1 <= k <= 104\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nfrom typing import List \r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_val = 0\r\n\r\n        for n in num:\r\n            num_val += n            \r\n            num_val = num_val * 10\r\n        num_val //= 10\r\n        \r\n        new_val = num_val + k\r\n        \r\n        if new_val == 0:\r\n            return [0]\r\n        \r\n        res = []\r\n        last_digit = 0\r\n            \r\n        while new_val != 0:\r\n            last_digit = new_val % 10\r\n            res.append(last_digit)    \r\n            new_val = new_val // 10\r\n\r\n        res.reverse()\r\n        return res\r\n\r\na = [0]\r\ns = Solution()\r\nres = s.addToArrayForm(a, k=0)\r\nprint(res)\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838260266","body":"\r\n## 题目地址(821. Shortest Distance to a Character)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\nGiven a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\r\n\r\nThe distance between two indices i and j is abs(i - j), where abs is the absolute value function.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"loveleetcode\", c = \"e\"\r\nOutput: [3,2,1,0,1,0,0,1,2,2,1,0]\r\nExplanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed).\r\nThe closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3.\r\nThe closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 3.\r\nFor index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.\r\nThe closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2.\r\n\r\n\r\nExample 2:\r\n\r\nInput: s = \"aaab\", c = \"b\"\r\nOutput: [3,2,1,0]\r\n\r\n\r\n \r\n\r\nConstraints:\r\n\r\n1 <= s.length <= 104\r\ns[i] and c are lowercase English letters.\r\nIt is guaranteed that c occurs at least once in s.\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n\"\"\"\r\nloveleetco d  e\r\n0123456789 10 11\r\n+++0100123 4  0\r\n3210100432 1  0\r\n3210100122 1  0\r\n\r\n 3 2 1 0 1 0 0 1 2 2 1 0\r\n[3,2,1,0,1,0,0,1,2,2,1,0]\r\n\r\n\"\"\"\r\n\r\n# 1.\r\n# https://stackoverflow.com/questions/6810036/whats-better-the-reverse-method-or-the-reversed-built-in-function#:~:text=reverse()%20actually%20reverses%20the,than%20actually%20reversing%20the%20elements.\r\n\r\n# 2.\r\n# https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode/\r\n\r\n# 3.\r\n# range(start, stop, step)\r\n# 左闭右开! []start, stop)\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        anchor = float('-inf')\r\n        # distance = left - righ\r\n        # distance = curr_val - anchor\r\n        # distance = postive_val - float('-inf')\r\n        dist = []\r\n        for i, l in enumerate(s):\r\n            if l == c:\r\n                dist[i] = prev\r\n            else:\r\n                dist[i] = i - prev\r\n        for i, l in enumerate(reversed(s)):\r\n            if l == c:\r\n                dist[i] = min(dist[i], )\r\n\r\n        \r\n\"\"\"\r\nclass Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n\r\n作者：LeetCode\r\n链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode/\r\n来源：力扣（LeetCode）\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n\"\"\"\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838260266","body":"\r\n## 题目地址(821. Shortest Distance to a Character)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\nGiven a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\r\n\r\nThe distance between two indices i and j is abs(i - j), where abs is the absolute value function.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"loveleetcode\", c = \"e\"\r\nOutput: [3,2,1,0,1,0,0,1,2,2,1,0]\r\nExplanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed).\r\nThe closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3.\r\nThe closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 3.\r\nFor index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.\r\nThe closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2.\r\n\r\n\r\nExample 2:\r\n\r\nInput: s = \"aaab\", c = \"b\"\r\nOutput: [3,2,1,0]\r\n\r\n\r\n \r\n\r\nConstraints:\r\n\r\n1 <= s.length <= 104\r\ns[i] and c are lowercase English letters.\r\nIt is guaranteed that c occurs at least once in s.\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n\"\"\"\r\nloveleetco d  e\r\n0123456789 10 11\r\n+++0100123 4  0\r\n3210100432 1  0\r\n3210100122 1  0\r\n\r\n 3 2 1 0 1 0 0 1 2 2 1 0\r\n[3,2,1,0,1,0,0,1,2,2,1,0]\r\n\r\n\"\"\"\r\n\r\n# 1.\r\n# https://stackoverflow.com/questions/6810036/whats-better-the-reverse-method-or-the-reversed-built-in-function#:~:text=reverse()%20actually%20reverses%20the,than%20actually%20reversing%20the%20elements.\r\n\r\n# 2.\r\n# https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode/\r\n\r\n# 3.\r\n# range(start, stop, step)\r\n# 左闭右开! []start, stop)\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        anchor = float('-inf')\r\n        # distance = left - righ\r\n        # distance = curr_val - anchor\r\n        # distance = postive_val - float('-inf')\r\n        dist = []\r\n        for i, l in enumerate(s):\r\n            if l == c:\r\n                dist[i] = prev\r\n            else:\r\n                dist[i] = i - prev\r\n        for i, l in enumerate(reversed(s)):\r\n            if l == c:\r\n                dist[i] = min(dist[i], )\r\n\r\n        \r\n\"\"\"\r\nclass Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n\r\n作者：LeetCode\r\n链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode/\r\n来源：力扣（LeetCode）\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n\"\"\"\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840417194","body":"\r\n## 题目地址(394. Decode String)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 题目描述\r\n\r\n```\r\nGiven an encoded string, return its decoded string.\r\n\r\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\r\n\r\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\r\n\r\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"3[a]2[bc]\"\r\nOutput: \"aaabcbc\"\r\n\r\n\r\nExample 2:\r\n\r\nInput: s = \"3[a2[c]]\"\r\nOutput: \"accaccacc\"\r\n\r\n\r\nExample 3:\r\n\r\nInput: s = \"2[abc]3[cd]ef\"\r\nOutput: \"abcabccdcdcdef\"\r\n\r\n\r\nExample 4:\r\n\r\nInput: s = \"abc3[cd]xyz\"\r\nOutput: \"abccdcdcdxyz\"\r\n\r\n\r\n \r\n\r\nConstraints:\r\n\r\n1 <= s.length <= 30\r\ns consists of lowercase English letters, digits, and square brackets '[]'.\r\ns is guaranteed to be a valid input.\r\nAll the integers in s are in the range [1, 300].\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/solution/java-di-gui-si-lu-qing-xi-dai-ma-yi-dong-t6mn/\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def onlyString(self, s):\r\n        index = 0\r\n        while index != len(s):\r\n            c = s[index]\r\n            if c == '[' or c == ']':\r\n                return False\r\n            index += 1\r\n        \r\n        return True\r\n\r\n    def decodeString(self, s: str) -> str:\r\n        if self.onlyString(s):\r\n            return s \r\n\r\n        i = 0\r\n        len_s = len(s)\r\n\r\n        res = ''\r\n\r\n        while i < len_s:\r\n            c = s[i]\r\n            if 'a' < c < 'z':\r\n                res += c\r\n                i += 1\r\n            else:\r\n                n = 0\r\n                left = i \r\n                right = i \r\n                while right < len_s and '0' <= s[right] <= '9':\r\n                    right += 1\r\n                \r\n                n = int(s[left:right+1])\r\n                left = right + 1\r\n                right += 1\r\n                leftP = 1\r\n                while leftP != 0:\r\n                    t = s[right]\r\n                    if t == '[':\r\n                        leftP += 1\r\n                    elif t == ']'\r\n                        leftP -= 1\r\n                    \r\n                    if leftP == 0:\r\n                        break\r\n                    right += 1\r\n                \r\n                smallFrac = decodeString(s[left + 1, right])\r\n                res += smallFrac*n\r\n                i = right + 1\r\n\r\n        return res \r\n\r\n    \r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：递归不知道\r\n- 空间复杂度：取决于问题吧, 如果 10000000[abc] \r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BeBraveBeCurious":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836072235","body":"``` Python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n\r\n        i, carry = len(num) - 1, 0\r\n        while i >= 0 or k != 0:\r\n            x = num[i] if i >= 0 else 0\r\n            y = k % 10 if k != 0 else 0\r\n\r\n            sum = x + y + carry\r\n            res.append(sum % 10)\r\n            carry = sum // 10\r\n\r\n            i -= 1\r\n            k //= 10\r\n\r\n        if carry != 0:\r\n            res.append(carry)\r\n            \r\n        return res[::-1]\r\n```\r\n**复杂度分析**\r\nn 为数组长度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838401294","body":"### 解题思路\r\n- 从左向右遍历, 记录 `i - prev`, `prev`为前一次`c`出现的下标\r\n- 从右向左遍历, 记录 `prev - i`, `prev`为靠右的`c`出现的下标\r\n\r\n### 代码\r\n\r\n```python3\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = []\r\n\r\n        for i, x in enumerate(s):\r\n            if x == c: prev = i \r\n            ans.append(i - prev)\r\n        \r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i \r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans \r\n```\r\n\r\n### 复杂度分析\r\n- **时间复杂度**：$O(n)$, 两次遍历`2n`化简为`n`\r\n- **空间复杂度**：$O(n)$, `n`为ans数组的长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839745404","body":"### 解题思路\r\n- 普通栈有`push`和`pop`功能\r\n- 增加普通栈没有的`inc`功能\r\n- `push`函数判断当前的元素个数是否达到上限，没达到上限时，将`top + 1`后移一位，同时添加一个元素\r\n```python3\r\ndef push(self, x: int) -> None:\r\n    if self.top != len(self.stk) - 1:\r\n        self.top += 1\r\n        self.stk[self.top] = x\r\n```\r\n- `pop`函数首先判断当前函数是否为空，非空返回栈顶元素，并将`top`前移一位，否则返回 -1\r\n```python3\r\ndef pop(self) -> int:\r\n    if self.top == -1: return -1\r\n    self.top -= 1\r\n    return self.stk[self.top]\r\n```\r\n- `inc`函数直接多栈底**最多**`k`个元素加上`val`\r\n```python3\r\ndef increment(self, k: int, val: int) -> None:\r\n    lim = min(k, self.top + 1)\r\n    for i in range(lim):\r\n        self.stk[i] += val\r\n```\r\n\r\n\r\n\r\n\r\n### 代码\r\n\r\n```python3\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1: return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：`push`和`pop`操作的渐进时间复杂度为$O(1)$, `inc`操作的渐进时间复杂度为$O(k)$\r\n- 空间复杂度：用到了一个`maxSize`的数组作为辅助空间，渐进空间复杂度为$O(maxSize)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840237710","body":"### 解题思路\r\n- 数字处理, `multi`初始化为0\r\n```python3\r\nmulti = 0\r\nif '0' <= c <= '9:\r\nmulti = multi * 10 + int(c)\r\n```\r\n- 左括号'['入栈'[multi, res]'\r\n```python3\r\nif c == '[':\r\n    stack.append([multi, res])\r\n    res, multi = '', 0\r\n```\r\n- 右括号`]`出栈\r\n```python3\r\nif c == ']':\r\n    cur_multi, last_res = stack.pop()\r\n    res = last_res + cur_multi * res \r\n```\r\n- 其余为数字的情况，将`c`添加至`res`\r\n``` python3\r\nelse:\r\n    res += c\r\n```\r\n\r\n### 代码\r\n\r\n```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], '', 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = '', 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res \r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)\r\n            else:\r\n                res += c\r\n        return res \r\n\r\n```\r\n[参考K神题解](https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/)\r\n\r\n![5.jpg](https://pic.leetcode-cn.com/1620871801-OsAwvq-5.jpg)\r\n**复杂度分析**\r\n- 时间复杂度: $O(n)$, 一次遍历s\r\n- 空间复杂度: $O(n)$, 极端情况下辅助栈需要线性空间，`2[3[4[a]]]`\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840918992","body":"### 解题思路\r\n- 初始化两个栈，一主一辅\r\n```python3\r\ndef __init__(self):\r\n    self.stack = []\r\n    self.help_stack = []\r\n```\r\n- `push`入栈时使用`help_stack`进行顺序调整\r\n```python3\r\ndef push(self, x: int) -> None:\r\n    while self.stack:\r\n        self.help_stack.append(self.stack.pop())\r\n    self.help_stack.append(x)\r\n    while self.help_stack:\r\n        self.stack.append(self.help_stack.pop())\r\n```\r\n- `pop`函数\r\n```python3\r\ndef pop(self) -> int:\r\n    return self.stack.pop()\r\n```\r\n- `peek`函数\r\n```python3\r\ndef peek(self) -> int:\r\n    return self.stack[-1]\r\n```\r\n- `empty`函数\r\n```python3\r\ndef empty(self) -> bool:\r\n    return not bool(self.stack)\r\n```\r\n\r\n\r\n### 代码\r\n\r\n```python3\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack = []\r\n        self.help_stack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stack:\r\n            self.help_stack.append(self.stack.pop())\r\n        self.help_stack.append(x)\r\n        while self.help_stack:\r\n            self.stack.append(self.help_stack.pop())\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.stack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.stack)\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841624167","body":"### 解题思路\r\n- `head`记为当前排序块的最大值\r\n- `stack`记录每个排序块的最大值`head`\r\n- 依次遍历`arr`, 得到`num`值，与栈顶值`stack[-1]`(上一个排序块的最大值`head`)\r\n- 当`stack`非空 + 当前`num`影响前面的排序块时，\r\n    - `head`暂存前一个排序块的最大值\r\n    - 将栈内小于当前`num`的值(之前排序块的最大值) 全部弹出\r\n    - 将当前的`head`值加入stack\r\n- 当`stack`空 or 当前`num`不影响前面的排序块时\r\n    - 单独成块 `num > stack[-1]`\r\n    - 直接加入`stack`中\r\n- `stack`中的值为所有排序块的`head`值，返回长度即结果\r\n \r\n### 代码\r\n```python3\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            # 当前数 num < 栈顶元素, 即前一个排序块的 head 最大值\r\n            if stack and num < stack[-1]:\r\n                # 暂存前一个排序块的 head 最大值\r\n                head = stack.pop()\r\n                # 需要将当前 num 小于前面的排序块的 head 值都弹出 \r\n                while stack and num < stack[-1]:\r\n                    stack.pop()\r\n                # 将受到当前 num 影响的前排序块的 head 值加入stack\r\n                # 相当于将前面的排序块和此 num 合并\r\n                stack.append(head)\r\n            # 栈为空 or 当前数字 num >= 栈顶值时 \r\n            # -----> 此num不影响前面排序块的分布\r\n            else:\r\n                stack.append(num)\r\n        # 所有排序块的 head d都在栈里面\r\n        return len(stack)\r\n```\r\n[参考K神题解](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/zui-duo-neng-wan-cheng-pai-xu-de-kuai-ii-deng-jie-/)\r\n\r\n### 复杂度分析\r\n- 时间复杂度$O(N)$：一次遍历`arr`为$O(N)$,修正排序块最多遍历一遍`arr`为$O(N)$ \r\n- 空间复杂度$O(N)$：极端情况下，排序块数量等于数组长度，此时`stack`占用线性大小额外空间。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"watermelonDrip":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836072251","body":"## 思路\r\n- 转int 和 k 相加\r\n- 取余逐位加到res_list里\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n         \r\n        str_num = ''.join(str(x) for x in num)\r\n        tmp = int(str_num)\r\n        int_res = tmp + k\r\n        list_res = []\r\n        if int_res == 0:\r\n            return [0]\r\n        while int_res>0:\r\n            list_res.append(int_res%10)\r\n            int_res = int_res//10\r\n        return list_res[::-1]\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837668088","body":"## 思路\r\n\r\n- 模拟\r\n- 先统计s出现的位置，两个位置的距离是odd,递增序列+递减序列。如果是even，就去掉一个中间数。\r\n如果统计s 的位置不是最后一位，最后再加一个递减序列\r\n \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        list_c = list()\r\n        for i, item in enumerate(s):\r\n            if item == c:\r\n                list_c.append(i)\r\n     \r\n        left = 0\r\n        right = 0\r\n        \r\n      \r\n        res = list()\r\n         \r\n        while  right <  len(list_c):\r\n     \r\n            if left == right:\r\n                \r\n                for i in range(list_c[right],-1,-1):\r\n                    res.append(i)\r\n                right+=1\r\n            elif list_c[right] < len(s) and left < right:\r\n                tmp = list_c[right] - list_c[left]\r\n                distance = tmp //2\r\n                distance_num = tmp%2\r\n                for i in range( 1,distance+distance_num ):\r\n                    res.append(i)\r\n                for i in range(distance,-1,-1):\r\n                    res.append(i)\r\n                right+=1\r\n                left+=1\r\n             \r\n            else:\r\n                break\r\n        len_s = len(s)\r\n       \r\n        if list_c[-1] < len_s -1:\r\n            for i in range(1, len_s - list_c[-1] ):\r\n                res.append(i)\r\n            \r\n        return res \r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839372099","body":"## 思路\r\n\r\n- 模拟， stack 用来push 和pop  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack1 = [] # for push and pop\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack1) < self.maxSize:\r\n            self.stack1.append(x)\r\n         \r\n    def pop(self) -> int:\r\n        if self.stack1:\r\n            return self.stack1.pop(-1)\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        cur = min(k,len(self.stack1))\r\n        cur -=1\r\n        while cur>=0:\r\n            self.stack1[cur]+=val\r\n            cur-=1\r\n        \r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840366228","body":"## 思路\r\n \r\n-  辅助栈 \r\n-   这个题里好多的细节啊\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack =[]\r\n        res = ''\r\n        k = 0\r\n        for elem in s:\r\n            if '0' <=  elem  <= '9':\r\n                k  = k*10+ int(elem)\r\n            elif elem == '[':\r\n                stack.append([res, k])\r\n                res = ''\r\n                k =0\r\n \r\n            elif elem == ']':\r\n                tmp_str, tmp_k = stack.pop()\r\n                \r\n                res = tmp_str + res * tmp_k \r\n \r\n                \r\n            else:\r\n                res =  res + elem \r\n              \r\n        return res\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840942770","body":"## 思路\r\n\r\n - 两个stack ,一个帮助pop，一个帮助Push\r\n \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack1 = [] # input stack\r\n        self.stack2 = [] # output stack\r\n        \r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stack1.append(x)\r\n\r\n\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2[-1]\r\n\r\n\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.stack1 and not self.stack2\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841631350","body":"#   思路\r\n - 单调栈\r\n#   Python3 Code:\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        # Monotonous stack\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]:\r\n                head = stack.pop(-1)\r\n                while stack and head > num:\r\n                    head = stack.pop(-1)\r\n\r\n            stack.append(num)\r\n```\r\n -   复杂度分析  \r\n    +    时间复杂度：$O( n)$  \r\n    +    空间复杂度：$O(n)$  \r\n\r\n "},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cecilia-vu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836079487","body":"### 思路\r\n\r\n从低位按位计算，注意处理最高位进位的情况\r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int add = 0;\r\n        for (int i = num.size() - 1; i>=0; i--) {\r\n            int digit = k % 10;\r\n            k = k / 10;\r\n            int tmp = num[i] + digit + add;\r\n            if (tmp > 9) {\r\n                res.push_back(tmp - 10);\r\n                add = 1;\r\n            } else {\r\n                res.push_back(tmp);\r\n                add = 0;\r\n            }\r\n        }\r\n        while (k > 0) {\r\n            int tmp = k % 10 + add;\r\n            if (tmp > 9) {\r\n                res.push_back(tmp - 10);\r\n                add = 1;\r\n            } else {\r\n                res.push_back(tmp);\r\n                add = 0;\r\n            }\r\n            k = k / 10;\r\n        }\r\n        if (add == 1) {\r\n            res.push_back(1);\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838562572","body":"### 思路\r\n\r\n正向和逆向分别遍历数组，计算和上一个目标字符的最短距离，保留两次遍历中较小的距离\r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.size();\r\n        vector<int> ans(n);\r\n        int prec = INT_MIN / 2;\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) {\r\n                ans[i] = 0;\r\n                prec = i;\r\n            } else {\r\n                ans[i] = i - prec;\r\n            }\r\n        }\r\n\r\n        prec = INT_MAX / 2;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s[i] == c) {\r\n                s[i] = 0;\r\n                prec = i;\r\n            } else {\r\n                ans[i] = min(ans[i], prec - i);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839431494","body":"### 思路\r\n\r\n数组模拟栈\r\n\r\n### 代码\r\n\r\n* 代码支持：C++\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    vector<int> st;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        st.resize(maxSize);\r\n        top = - 1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top != st.size() - 1) {\r\n            st[++top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        } else {\r\n            return st[top--];\r\n        }\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int n = st.size() < k ? st.size() : k;\r\n        for (int i=0; i<n; i++) {\r\n            st[i] += val;\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push, pop: O(1), increment: O(N)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840266167","body":"### 思路\r\n\r\n用 vector 模拟栈操作，顺序遍历输入字符串，遇到 ']' 时进行 pop 操作，并将 ']'  和 '[' 之间的字符串复制所需次数后入栈  \r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n\r\n    vector<char> st;\r\n    int top = -1;\r\n\r\n    string decodeString(string s) {\r\n        for (auto c : s) {\r\n            if (c == ']') {\r\n                string tmp;\r\n                while (st[top] != '[') {\r\n                    if (isalpha(st[top])) {\r\n                        tmp += st[top];\r\n                    }   \r\n                    top--;   \r\n                }\r\n                top--;\r\n                reverse(tmp.begin(), tmp.end());\r\n                string cnt_tmp;\r\n                while (top > - 1 && isdigit(st[top])) {\r\n                    cnt_tmp += st[top];\r\n                    top--;\r\n                }\r\n                reverse(cnt_tmp.begin(), cnt_tmp.end());\r\n                int cnt = std::stoi(cnt_tmp);\r\n                string res_tmp;\r\n                for (int i=0; i<cnt; i++) {\r\n                    res_tmp.append(tmp);\r\n                }\r\n                for (auto c : res_tmp) {\r\n                    if (top + 1 < st.size()) {\r\n                        ++top;\r\n                        st[top] = c;\r\n                    } else {\r\n                        st.push_back(c);\r\n                        top++;\r\n                    }\r\n                }\r\n            } else {\r\n                    if (top + 1 < st.size()) {\r\n                        ++top;\r\n                        st[top] = c;\r\n                    } else {\r\n                        st.push_back(c);\r\n                        top++;\r\n                    }\r\n            }\r\n        }\r\n        string res;\r\n        int n = top + 1 < st.size() ? top + 1 : st.size();\r\n        for (int i=0; i<n; i++) {\r\n            res += st[i];\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841197060","body":"### 思路\r\n\r\n* push 操作总放入第一个栈，push 前清空第二个栈\r\n* pop 和 peek 操作总在第二个栈进行，pop 前清空第一个栈\r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n\r\n```c++\r\nclass MyQueue {\r\npublic:\r\n    stack<int> st1, st2;\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        while (!st2.empty()) {\r\n            int tmp = st2.top();\r\n            st2.pop();\r\n            st1.push(tmp);\r\n        }\r\n        st1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        while (!st1.empty()) {\r\n            int tmp = st1.top();\r\n            st1.pop();\r\n            st2.push(tmp);\r\n        }\r\n        int res = st2.top();\r\n        st2.pop();\r\n        return res;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        while (!st1.empty()) {\r\n            int tmp = st1.top();\r\n            st1.pop();\r\n            st2.push(tmp);\r\n        }\r\n        return st2.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return st1.empty() && st2.empty();\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841585409","body":"### 思路\r\n\r\n* 参考题解，使用单调栈\r\n* 使用单调栈维护每个分块的最大值\r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> st;\r\n        st.push(arr[0]);\r\n        int n = arr.size();\r\n        for (int i=1; i<n; i++) {\r\n            if (arr[i] < st.top()) {\r\n                int head = st.top();\r\n                while (!st.empty() && arr[i] < st.top()) {\r\n                    st.pop();\r\n                }\r\n                st.push(head);\r\n            } else {\r\n                st.push(arr[i]);\r\n            }\r\n        }\r\n        return st.size();\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)，极端情况下，栈中元素为数组所有元素"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Davont":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836079739","body":"### 思路\r\n1.先反转数组\r\n2.上下相加\r\n3.再反转成正常数组\r\n\r\n### 代码（JavaScript）\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  /**\r\n   * 大数相加，先将两个数反转\r\n   */\r\n  let numAStr = num.reverse();\r\n  let numBStr = k.toString().split('').reverse();\r\n  let temp = 0;\r\n  let result = [];\r\n  for (let i = 0; i < Math.max(numAStr.length, numBStr.length); i++) {\r\n    if (!numAStr[i]) {\r\n      numAStr[i] = 0;\r\n    }\r\n    if (!numBStr[i]) {\r\n      numBStr[i] = 0;\r\n    }\r\n    result[i] = numAStr[i] + +numBStr[i] + temp;\r\n    if (result[i] > 9) {\r\n      result[i] -= 10;\r\n      temp = 1;\r\n    } else{\r\n        temp = 0;\r\n    }\r\n  }\r\n  if (temp === 1) {\r\n    result.push(temp);\r\n  }\r\n  return result.reverse();\r\n};\r\n``` \r\n\r\n        \r\n### 复杂度\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838734919","body":"### 思路\r\n先存入index，然后比较每个index和遍历到数的最小距离，进行输出\r\n\r\n### 代码\r\n```js\r\nvar shortestToChar = function(S, C) {\r\n    let len = S.length;\r\n    let cArr = [];\r\n    let res = [];\r\n    for (let i = 0; i < len; i++) {\r\n        if (S[i] === C) {\r\n            cArr.push(i)\r\n        }\r\n    }\r\n    for (let i = 0; i < len; i++) {\r\n        let distance = Math.abs(i - cArr[0]);\r\n        for (let j = 0; j < cArr.length; j++) {\r\n            if (distance > Math.abs(i - cArr[j])) {\r\n                distance = Math.abs(i - cArr[j])\r\n            }\r\n        }\r\n        res.push(distance)\r\n    }\r\n    return res;\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838734919","body":"### 思路\r\n先存入index，然后比较每个index和遍历到数的最小距离，进行输出\r\n\r\n### 代码\r\n```js\r\nvar shortestToChar = function(S, C) {\r\n    let len = S.length;\r\n    let cArr = [];\r\n    let res = [];\r\n    for (let i = 0; i < len; i++) {\r\n        if (S[i] === C) {\r\n            cArr.push(i)\r\n        }\r\n    }\r\n    for (let i = 0; i < len; i++) {\r\n        let distance = Math.abs(i - cArr[0]);\r\n        for (let j = 0; j < cArr.length; j++) {\r\n            if (distance > Math.abs(i - cArr[j])) {\r\n                distance = Math.abs(i - cArr[j])\r\n            }\r\n        }\r\n        res.push(distance)\r\n    }\r\n    return res;\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LangqiZhao":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836081583","body":"### 思路\r\n\r\n把数组从末尾开始，和k进行加法运算，并通过进位更新需要加的数值。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        ans = list()\r\n\r\n        add_value = k\r\n        for idx in range(len(num)):\r\n            val = num[len(num) - 1 - idx] + add_value\r\n            add_value = val // 10\r\n            ans.append(val % 10)\r\n\r\n            if add_value == 0:\r\n                break\r\n\r\n        while add_value > 0:\r\n            ans.append(add_value % 10)\r\n            add_value = add_value // 10\r\n\r\n        ans = ans[::-1]\r\n\r\n        if idx < len(num) - 1:\r\n            ans = num[:len(num) - idx - 1] + ans\r\n        return ans\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837627118","body":"### 思路\r\n\r\n通过类似单调栈的方法，计算到C的距离。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = [0] * len(s)\r\n        stack = list()\r\n        sig = None\r\n\r\n        for idx in range(len(s)):\r\n            while stack and (s[stack[-1]] != c) and (s[idx] == c):\r\n                temp_index = stack.pop(-1)\r\n                if sig is None:\r\n                    ans[temp_index] = abs(idx - temp_index)\r\n                else:\r\n                    ans[temp_index] = min(abs(idx - temp_index), abs(sig - temp_index))\r\n            if s[idx] == c:\r\n                sig = idx\r\n            stack.append(idx)\r\n\r\n        while stack and s[stack[-1]] != c:\r\n            temp_index = stack.pop(-1)\r\n            ans[temp_index] = abs(temp_index - sig)\r\n        return ans\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839370882","body":"### 思路\r\n\r\n通过建立一个数组，实现栈的功能。increment考虑长度。\r\n\r\n### 代码\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = list()\r\n        self.max_len = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_len:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            val = self.stack[-1]\r\n            self.stack = self.stack[:-1]\r\n            return val\r\n        return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        add_len = min(k, len(self.stack))\r\n        for idx in range(add_len):\r\n            self.stack[idx] += val\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push和pop为O(1), increment为O(min(k, maxSize))\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840240046","body":"### 思路\r\n\r\n建立栈，判断是否是\"]\"，如果不是，入栈；如果是，字符串复制。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        num_list = [str(num) for num in range(10)]\r\n        stack_list = list()\r\n        for item in s:\r\n            if item != ']':\r\n                stack_list.append(item)\r\n                continue\r\n            repeat_string = ''\r\n            while stack_list and stack_list[-1] != '[':\r\n                cur_string = stack_list.pop(-1)\r\n                repeat_string = cur_string + repeat_string\r\n            if stack_list[-1] == '[':\r\n                stack_list = stack_list[:-1]\r\n            num_string = ''\r\n            while stack_list and stack_list[-1] in num_list:\r\n                cur_string = stack_list.pop(-1)\r\n                num_string = cur_string + num_string\r\n            if repeat_string and num_string:\r\n                stack_list.append(int(num_string) * repeat_string)\r\n        return ''.join(stack_list)\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840973556","body":"### 思路\r\n\r\n建立两个栈，分别记录push和pop的操作。如果pop为空时，就将push逐步出栈、并存入pop栈内。出栈转入时，顺序是相反的。\r\n\r\n### 代码\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.push_stack = list()\r\n        self.pop_stack = list()\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.push_stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.pop_stack:\r\n            while self.push_stack:\r\n                self.pop_stack.append(self.push_stack.pop(-1))\r\n        return self.pop_stack.pop(-1)\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.pop_stack:\r\n            while self.push_stack:\r\n                self.pop_stack.append(self.push_stack.pop(-1))\r\n        return self.pop_stack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        if not self.push_stack and not self.pop_stack:\r\n            return True\r\n        return False\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841657273","body":"### 思路\r\n\r\n通过栈实现，确保栈中的数据是递增的。如果不是，可以出栈后，将较大的数重新入栈。\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = list()\r\n        for item in arr:\r\n            val = item\r\n            while stack and item < stack[-1]:\r\n                pop_val = stack.pop(-1)\r\n                val = max(val, pop_val, item)\r\n            stack.append(val)\r\n        return len(stack)\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841746112","body":"### 思路\r\n\r\n链表快慢指针间隔是k，首尾连接重组链表\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if k <= 0:\r\n            return head\r\n        pointer = head\r\n        length = 0\r\n        while pointer is not None:\r\n            length += 1\r\n            pointer = pointer.next\r\n\r\n        if length < 2:\r\n            return head\r\n\r\n        gap_val = k % length\r\n        if gap_val == 0:\r\n            return head\r\n        dummy_node = ListNode(0, next=head)\r\n        fast_pointer = dummy_node.next\r\n        slow_pointer = dummy_node\r\n        count = 1\r\n        while fast_pointer is not None:\r\n            if count <= gap_val:\r\n                fast_pointer = fast_pointer.next\r\n                count += 1\r\n            else:\r\n                fast_pointer = fast_pointer.next\r\n                slow_pointer = slow_pointer.next\r\n        ans = slow_pointer.next\r\n        slow_pointer.next = None\r\n        ans_pointer = ans\r\n        while ans_pointer.next is not None:\r\n            ans_pointer = ans_pointer.next\r\n        ans_pointer.next = dummy_node.next\r\n        return ans\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taozi-taozi":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836083170","body":"### 思路：\r\n数组遍历\r\n### 代码：\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        re = 0\r\n        for i in num[:-1]:\r\n            re = (re + i) * 10\r\n        re = re + num[-1] + k\r\n        return [int(x) for x in str(re)]\r\n```\r\n### 复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837649030","body":"### 思路\r\n双指针.....😮\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        re = [0]*n\r\n        slow, fast = 0,0\r\n        pre = inf\r\n        while fast<n:\r\n            while s[fast] != c:\r\n                if fast == n-1:\r\n                    break\r\n                fast+=1\r\n            while slow<=fast:\r\n                if s[fast]!=c:\r\n                    re[slow] = abs(slow-pre)\r\n                else:\r\n                    re[slow] = min(abs(slow-pre),abs(slow-fast))\r\n                slow+=1\r\n            pre = fast\r\n            fast+=1\r\n        return re\r\n```\r\n### 复杂度分析😖\r\n时间复杂度：O(n)?\r\n空间复杂度：O(n)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837649030","body":"### 思路\r\n双指针.....😮\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        re = [0]*n\r\n        slow, fast = 0,0\r\n        pre = inf\r\n        while fast<n:\r\n            while s[fast] != c:\r\n                if fast == n-1:\r\n                    break\r\n                fast+=1\r\n            while slow<=fast:\r\n                if s[fast]!=c:\r\n                    re[slow] = abs(slow-pre)\r\n                else:\r\n                    re[slow] = min(abs(slow-pre),abs(slow-fast))\r\n                slow+=1\r\n            pre = fast\r\n            fast+=1\r\n        return re\r\n```\r\n### 复杂度分析😖\r\n时间复杂度：O(n)?\r\n空间复杂度：O(n)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840243834","body":"### 思路\r\n栈，括号匹配\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for i in range(len(s)):\r\n            if s[i] == ']':\r\n                zong = ''\r\n                re = stack.pop()\r\n                while re != '[':\r\n                    zong = zong + re[::-1]\r\n                    re = stack.pop()\r\n                shu = ''\r\n                re = stack.pop()\r\n                while re.isdigit():\r\n                    shu = shu + re\r\n                    if len(stack) == 0:\r\n                        break\r\n                    else:\r\n                        re = stack.pop()\r\n                if not re.isdigit():\r\n                    stack.append(re)\r\n                stack.append(zong[::-1]*int(shu[::-1]))\r\n            else:\r\n                stack.append(s[i])\r\n        return ''.join(stack)\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840978666","body":"### 思路\r\n辅助栈\r\n### 代码\r\n```python\r\nclass MyQueue:\r\n    def __init__(self):\r\n       self.stack_1 = []\r\n       self.stack_2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack_2:\r\n            while self.stack_1:\r\n                self.stack_2.append(self.stack_1.pop())\r\n        return self.stack_2.pop()\r\n        \r\n    def peek(self) -> int:\r\n        if not self.stack_2:\r\n            while self.stack_1:\r\n                self.stack_2.append(self.stack_1.pop())\r\n        return self.stack_2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        if not self.stack_1 and not self.stack_2:\r\n            return True\r\n        else:\r\n            return False\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841602397","body":"### 思路\r\n哈希表，与排好序的数组进行比较\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        s_arr = sorted(arr)\r\n        count = 0\r\n        dic = {}\r\n        j = 0\r\n        for i in range(len(arr)):\r\n            if s_arr[i] != arr[j]:\r\n                dic[s_arr[i]] = 1\r\n            elif dic and s_arr[i] == arr[j]:\r\n                j+=1\r\n                while j <= i and arr[j] in dic:\r\n                    j+=1\r\n                if j-1 == i:\r\n                    count+=1\r\n            else:\r\n                count+=1\r\n                j+=1\r\n        return count\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DIUDIU110":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836088010","body":"### 思路\r\n    模拟数字加法，利用 K 保存进位，先将对应位置的数字相加，再进行取余操作保留结果。\r\n### 程序 C++\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& a, int k) {\r\n        vector<int>res;\r\n        vector<int>b;\r\n        while(k)\r\n        {\r\n            b.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(b.begin(),b.end());\r\n        int fl=0;\r\n        int i,j;\r\n        for(i=a.size()-1,j=b.size()-1;i>=0&&j>=0;i--,j--)\r\n        {\r\n            int te=a[i]+b[j]+fl;\r\n            fl=te/10;\r\n            res.push_back(te%10);\r\n        }\r\n        while(i>=0)\r\n        {\r\n            int te=a[i]+fl;\r\n            fl=te/10;\r\n            res.push_back(te%10);\r\n            i--;\r\n        }\r\n        while(j>=0)\r\n        {\r\n            int te=b[j]+fl;\r\n            fl=te/10;\r\n            res.push_back(te%10);\r\n            j--;\r\n        }\r\n        if(fl)\r\n            res.push_back(fl);\r\n        reverse(res.begin(),res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n   时间: o(max(n,m)) \r\n   空间: o(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837967947","body":"### 算法思想：\r\n首先遍历一遍数组记录c的位置  为了处理方便 最好在最前面和最后面加上一个特殊位置\r\n再遍历一遍数组求解当前字符前后c位置差的最小值即可 注意最后一个区间里的遍历需要控制一下 不让其再变动区间\r\n### 代码：\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n=s.size();\r\n        int v1[10005];\r\n        int cnt=0;\r\n        v1[cnt++]=n+1;\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            if(s[i]==c)\r\n                v1[cnt++]=i;\r\n        }\r\n        v1[cnt++]=-n-1;\r\n        vector<int>res(n);\r\n        cnt=1;\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            if(i<=v1[cnt])\r\n                res[i]=min(abs(i-v1[cnt-1]),abs(i-v1[cnt]));\r\n\r\n            else\r\n            {\r\n                if(v1[cnt]!=-n-1)\r\n                    cnt++;\r\n                res[i]=min(abs(i-v1[cnt-1]),abs(i-v1[cnt]));\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间：o(n)\r\n空间：o(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839350672","body":"### 思路：\r\n需要注意两种边界即可：\r\n       1.push不能大于maxsize \r\n       2.pop栈不能为空\r\n### 代码C++：\r\n```\r\nclass CustomStack {\r\npublic:\r\n    int *st;\r\n    int cnt;\r\n    int maxx;\r\n    CustomStack(int maxSize) {\r\n        st=(int*)malloc(sizeof(int)*maxSize);\r\n        cnt=-1;\r\n        maxx=maxSize;\r\n    }\r\n    void push(int x) {\r\n        if(cnt!=maxx-1)\r\n            st[++cnt]=x;\r\n    }\r\n    int pop() {\r\n        if(cnt!=-1)\r\n            return st[cnt--];\r\n        else\r\n            return -1;\r\n    }\r\n    void increment(int k, int val) {\r\n        k=min(k,cnt+1);\r\n        for(int i=0;i<k;i++)\r\n        {\r\n            st[i]+=val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```\r\n### 复杂度\r\n时间复杂度：push O(1) pop O(1) increment O(k)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840373383","body":"### 解题思路\r\n#### 数字处理, multi初始化为0\r\nmulti = 0\r\nif '0' <= c <= '9:\r\nmulti = multi * 10 + int(c)\r\n#### 左括号'['入栈'[multi, res]'\r\nif c == '[':\r\n    stack.append([multi, res])\r\n    res, multi = '', 0\r\n#### 右括号]出栈\r\nif c == ']':\r\n    cur_multi, last_res = stack.pop()\r\n    res = last_res + cur_multi * res \r\n#### 其余为数字的情况，将c添加至res\r\nelse:\r\n    res += c\r\n### Code C++\r\n```\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<int>s1;\r\n        stack<string>s2;\r\n        string res=\"\";\r\n        int mul=0;\r\n        for(auto c:s)\r\n        {\r\n            if(c>='0'&&c<='9')//0-9之间 需要记录一下当前mul\r\n            {\r\n                mul=mul*10+c-'0';\r\n            }\r\n            else if(c=='[')\r\n            {\r\n                s1.push(mul);\r\n                s2.push(res);\r\n                res=\"\";\r\n                mul=0;\r\n            }\r\n            else if(c==']')\r\n            {\r\n                int cur_mul=s1.top();\r\n                s1.pop();\r\n                string last_res=s2.top();\r\n                s2.pop();\r\n                for(int i=0;i<cur_mul;i++)\r\n                {\r\n                    last_res+=res;\r\n                }\r\n                res=last_res;\r\n            }\r\n            else\r\n                res+=c;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：o(n)\r\n空间复杂度：o(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840958709","body":"### 思路\r\n两个栈s1，s2（辅助栈） 实现队列\r\n#### push操作\r\npush操作符合栈的逻辑 直接push进s1即可\r\n时间复杂度：o(1)\r\n#### pop操作\r\npop操作队列需要在队头出队  不符合栈的逻辑 需要用到辅助栈s2\r\n具体操作：先全pop到s2 再pop s2栈顶 然后处理完之后记得转移到s1\r\n时间复杂度：o(n)\r\n#### empty操作\r\n看看s1为不为空就可以了\r\n时间复杂度：o(1)\r\n#### peek操作\r\n取得是队头 不符合栈的逻辑 需要用到辅助栈s2\r\n具体操作：先全pop到s2 再取s2栈顶进行记录 之后记得转移至s1\r\n时间复杂度：o(n)\r\n\r\nover！\r\n\r\n空间复杂度：两个栈 o(n) 额外 o(1) \r\n### 代码\r\n```\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    stack<int>s1;\r\n    stack<int>s2;\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        // while(!s2.empty())\r\n        // {\r\n        //     s1.push(s2.top());\r\n        //     s2.pop();\r\n        // }\r\n        s1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        while(!s1.empty())\r\n        {\r\n            s2.push(s1.top());\r\n            s1.pop();\r\n        }\r\n        int x=s2.top();\r\n        s2.pop();\r\n        while(!s2.empty())\r\n        {\r\n            s1.push(s2.top());\r\n            s2.pop();\r\n        }\r\n        return x;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        while(!s1.empty())\r\n        {\r\n            s2.push(s1.top());\r\n            s1.pop();\r\n        }\r\n        int x=s2.top();\r\n        while(!s2.empty())\r\n        {\r\n            s1.push(s2.top());\r\n            s2.pop();\r\n        }\r\n        return x;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return s1.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rfhklwt":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836091338","body":"## 思路\r\n* 模拟竖式加法，逐位相加，并记录`carry`位\r\n```伪代码\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n## 代码\r\n* Python3\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        n = len(num)\r\n        res = []\r\n        i, Sum, carry = n - 1, 0, 0\r\n        \r\n        while i >= 0 or k != 0:\r\n            x = num[i] if i >= 0 else 0\r\n            y = k % 10 if k != 0 else 1\r\n\r\n            Sum = x + y + carry\r\n            # 当前位\r\n            res.append(Sum % 10)\r\n            # 进位\r\n            carry = Sum // 10\r\n            i, k = i - 1, k // 10\r\n        \r\n        # 最后检查进位是否为１\r\n        if carry > 0:\r\n            res.append(carry)\r\n        \r\n        return res[::-1]\r\n```\r\n* Julia\r\n```julia\r\nfunction add_to_array_form(num::Vector{Int}, k::Int)::Vector{Int}\r\n    n = length(num)\r\n    i, val, carry = n, 0, 0\r\n    res = Int[]\r\n\r\n    while i > 0 || k != 0\r\n        x = i > 0 ? num[i] : 0\r\n        y = k != 0 ? k % 10 : 0\r\n\r\n        val = x + y + carry\r\n        append!(res, val % 10)\r\n        carry = val ÷ 10\r\n        i, k = i - 1, k ÷ 10\r\n    end\r\n\r\n    if carry > 0\r\n        append!(res, carry)\r\n    end\r\n\r\n    return reverse(res)\r\nend\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：`O(max(n,log k))`，其中`n`为数组的长度。\r\n\r\n* 空间复杂度：`O(1)`，不考虑返回数组。\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838237568","body":"## 思路\r\n1. 首先正向遍历一遍，求出往右找的最短距离；\r\n2. 接着反向遍历一遍，求出往左找的最短距离；\r\n3. 算出他们的最小值就是最短距离了。\r\n\r\n## 代码\r\n* Python3\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n, pos = len(s), float('-inf')\r\n        res = [n] * n\r\n        for i in list(range(n)) + list(range(n)[::-1]):\r\n            if s[i] == c:\r\n                pos = i\r\n            res[i] = min(res[i], abs(i - pos))\r\n        \r\n        return res\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：`O(n)`\r\n\r\n* 空间复杂度：`O(n)`"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839394272","body":"## 思路\r\n采用数组模拟即可\r\n\r\n## 代码\r\n* Python3\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [-1] * maxSize\r\n        self.point = 0\r\n        self.maxSize = maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.point < self.maxSize:\r\n            self.stack[self.point] = x\r\n            self.point += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.point == 0:\r\n            return -1\r\n        else:\r\n            self.point -= 1\r\n            return self.stack[self.point]\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, self.point)):\r\n            self.stack[i] += val\r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：`O(min(k, maxSize))`\r\n\r\n* 空间复杂度：`O(maxSize)`"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840249650","body":"## 思路\r\n当遇到`[`符号时，我们知道要将括号里面的字符串重复`k`遍，所以用一个**栈**来存放`(current_string, k)`，而当遇到`]`符号的时候就可以把里面的字符串重复`k`遍。\r\n\r\n## 代码\r\n* Python3\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        current_string = \"\"\r\n        k = 0\r\n\r\n        for char in s:\r\n            if char == '[':\r\n                stack.append((current_string, k))\r\n                current_string = \"\"\r\n                k = 0\r\n            elif char == ']':\r\n                last_string, last_k = stack.pop()\r\n                current_string = last_string + last_k * current_string\r\n            elif char.isdigit():\r\n                k = k * 10 + int(char)\r\n            else:\r\n                current_string += char\r\n        \r\n        return current_string\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：`O(S)`，其中`S`为解码后的字符串长度\r\n* 空间复杂度：`O(S)`，其中`S`为解码后的字符串长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840993799","body":"## 思路\r\n\r\n将一个栈当作输入栈，用于压入`push`传入的数据；另一个栈当作输出栈，用于`pop`和`peek`操作。\r\n\r\n每次`pop`或`peek`时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。\r\n\r\n## 代码\r\n\r\n* Python3\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.inStack = []\r\n        self.outStack = []\r\n\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.inStack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        self.peek()\r\n        return self.outStack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.outStack:\r\n            while self.inStack:\r\n                self.outStack.append(self.inStack.pop())\r\n        return self.outStack[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return (not self.inStack) and (not self.outStack)\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：`push`和`empty`为 `O(1)`，`pop`和 `peek`为均摊`O(1)`。对于每个元素，至多入栈和出栈各两次，故均摊复杂度为 `O(1)`。\r\n* 空间复杂度：`O(n)`，其中`n`是操作总数。对于有`n`次`push`操作的情况，队列中会有`n`个元素，故空间复杂度为`O(n)`。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841600672","body":"## 思路\r\n\r\n* 排序前和排序后的数组，其**计数信息**是一致的，故可通过这一信息来分块。把所有`计数信息一致的块`分成一个`块`即可。\r\n\r\n## 代码\r\n\r\n* Python 3\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        count = collections.defaultdict(int)\r\n        non_zeros, res = 0, 0\r\n\r\n        for a, b in zip(arr, sorted(arr)):\r\n            count[a] += 1\r\n            if count[a] == 0: non_zeros -= 1\r\n            elif count[a] == 1: non_zeros += 1\r\n\r\n            count[b] -= 1\r\n            if count[b] == 0: non_zeros -= 1\r\n            elif count[b] == -1: non_zeros += 1\r\n\r\n            if non_zeros == 0: res += 1\r\n        \r\n        return res\r\n```\r\n\r\n* Julia\r\n\r\n```julia\r\nusing DataStructures\r\n\r\nfunction max_chunks_to_sorted(arr::Vector{Int})::Int\r\n    count = DefaultDict(1)\r\n    non_zeros, res = 0, 0\r\n\r\n    for (a, b) in zip(arr, sort(arr))\r\n        count[a] += 1\r\n        if count[a] == 0\r\n            non_zeros -= 1\r\n        elseif count[a] == 1\r\n            non_zeros += 1\r\n        end\r\n\r\n        count[b] -= 1\r\n        if count[b] == 0\r\n            non_zeros -= 1\r\n        elseif count[b] == -1\r\n            non_zeros += 1\r\n        end\r\n\r\n        (non_zeros == 0) && (res += 1)\r\n    end\r\n\r\n    return res\r\nend\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：`O(NlogN)`，其中`N`为数组的长度。\r\n\r\n* 空间复杂度：`O(N)`。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841755019","body":"## 思路\r\n\r\n* 首先计算出链表的长度，并且头尾相连\r\n* 接着算出在哪个位置断开即可代码\r\n\r\n* Python 3\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head:\r\n            return None\r\n\r\n        lastElement = head\r\n        length = 1\r\n        # 计算链表长度\r\n        while lastElement.next:\r\n            lastElement = lastElement.next\r\n            length += 1\r\n        # 首尾相连\r\n        lastElement.next = head\r\n        k = k % length\r\n\r\n        tempNode = head\r\n        for _ in range(length - k - 1):\r\n            tempNode = tempNode.next\r\n        \r\n        res = tempNode.next\r\n        # 断开尾巴\r\n        tempNode.next = None\r\n\r\n        return res\r\n```\r\n\r\n* Julia\r\n\r\n```julia\r\nfunction rotate_right(head::ListNode, k::Int)::ListNode\r\n    isnothing(head) && return head\r\n\r\n    last_element, length = head, 1\r\n    while !isnothing(next(last_element))\r\n        last_element = next(last_element)\r\n        length += 1\r\n    end\r\n\r\n    k = k % length\r\n    next!(last_element, head)\r\n\r\n    temp_element = head\r\n    for _ = 0:(length-k-2)\r\n        temp_element = next(temp_element)\r\n    end\r\n\r\n    answer = next(temp_element)\r\n    next!(temp_element, nothing)\r\n\r\n    return answer\r\nend\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：`O(N)`，其中`N`为链表的长度。\r\n\r\n* 空间复杂度：`O(1)`。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HTian1997":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836091664","body":"思路：模拟加法\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = k\r\n        for i in range(len(num) - 1, -1, -1):\r\n            num[i] += carry\r\n            carry = num[i] // 10\r\n            num[i] %= 10\r\n        \r\n        while carry:\r\n            num.insert(0, carry % 10)\r\n            carry //= 10\r\n        \r\n        return num\r\n```\r\n\r\n复杂度：time O(N), space O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837649590","body":"思路：从左到右和从右到左遍历两边\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        ans = [float('inf') for i in range(n)]\r\n\r\n        pos = s.index(c)\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                pos = i\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(ans[i], abs(i - pos))\r\n        \r\n        pos = s.rindex(c)\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                pos = i\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(ans[i], abs(i - pos))\r\n        \r\n        return ans\r\n```\r\n\r\nComplexity: time O(N), space O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839414697","body":"思路：数组模拟栈进行操作\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            return self.stack.pop(-1)\r\n        return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        size = min(k, len(self.stack))\r\n        for i in range(size):\r\n            self.stack[i] += val\r\n```\r\n\r\nComplexity: \r\ntime: push: O(1), pop O(1), increment: O(n)\r\nspace: O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840200523","body":"思路：判断当前字符是否为\"]\"，如果不是就直接push进栈，是就开始一系列操作：不断弹出栈顶元素直到为\"[\"，翻转这部分然后再根据数字入栈。需要注意数字可能多位，需要累积。\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        ans = \"\"\r\n        stack = []\r\n\r\n        for char in s:\r\n            # pop up\r\n            if char == \"]\":\r\n                repeat = \"\"\r\n                while stack[-1] != \"[\":\r\n                    repeat += stack.pop(-1)\r\n                \r\n                # reverse the repeat\r\n                repeat = repeat[::-1]\r\n                stack.pop(-1)\r\n\r\n                number = \"\"\r\n                while stack and stack[-1].isnumeric():\r\n                    number += stack.pop(-1)\r\n                \r\n                number = int(number[::-1])\r\n                \r\n                for i in range(number):\r\n                    for elem in repeat: \r\n                        stack.append(elem)\r\n            \r\n            else:\r\n                stack.append(char)\r\n        \r\n        return \"\".join(stack)\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841289685","body":"思路：双栈模拟\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.inStack = []\r\n        self.outStack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.inStack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.outStack:\r\n            self.reverse()\r\n        \r\n        return self.outStack.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.outStack:\r\n            self.reverse()\r\n        \r\n        return self.outStack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return not self.inStack and not self.outStack\r\n    \r\n    def reverse(self):\r\n        while self.inStack:\r\n            self.outStack.append(self.inStack.pop())\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841579226","body":"思路：单调栈\r\n```python3\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]:\r\n                head = stack.pop(-1)\r\n                while stack and num < stack[-1]:\r\n                    stack.pop(-1)\r\n                \r\n                stack.append(head)\r\n            else:\r\n                stack.append(num)\r\n\r\n        return len(stack)\r\n```\r\nComplexity: time O(N), space O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"terrylijiayang":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836094791","body":"**思路**\r\n两个循环。第一个循环先统一到一个数组，第二个循环再做进位处理。\r\n**代码**\r\n```\r\nvar addToArrayForm = function (A, K) {\r\n    count = 0;\r\n    len = K.toString().length;\r\n    for (let i = 0; i < len; i++) {\r\n        if (A.length < len) {\r\n            A.unshift(0);\r\n        }\r\n        count = K % 10;\r\n        K = parseInt(K / 10);\r\n        A[A.length - 1 - i] += count;\r\n    }\r\n    for (let i = 0; i < A.length; i++) {\r\n        if (A[0] > 9) {\r\n            A.unshift(0);\r\n        }\r\n        if (A[A.length - 1 - i] > 9) {\r\n            A[A.length - 2 - i]++;\r\n            A[A.length - 1 - i] = A[A.length - 1 - i] % 10;\r\n        }\r\n    }\r\n    return A;\r\n};\r\n```\r\n**复杂度**\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838562657","body":"**思路**\r\n先用数组存储距离位置，再通过外循环找位置，再内循环找最小值。\r\n\r\n**代码**\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    let array = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        array[i] = s.length;\r\n    }\r\n    for (let i = 0; i < s.length; i++){\r\n        if ( s.substring(i, i+1) === c){\r\n            for (let j = 0; j < s.length; j++){\r\n                array[j] = Math.min(Math.abs(i - j),array[j])\r\n            }\r\n        }\r\n    }\r\n    return array;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n时间复杂度：O（n²）\r\n空间复杂度：O（n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839813869","body":"**思路**\r\n用数组来存栈，实现增量操作\r\n**代码**\r\n```\r\nvar CustomStack = function(maxSize) {\r\n    s = []\r\n    t=0\r\n    n = maxSize\r\n};\r\nCustomStack.prototype.push = function(x) {\r\n    if(t<n) s[++t]=x\r\n    return s\r\n\r\n};\r\nCustomStack.prototype.pop = function() {\r\n    if(t)return s[t--]\r\n    return -1\r\n};\r\nCustomStack.prototype.increment = function(k, val) {\r\n    while(k) s[k--]+=val\r\n\r\n};\r\n\r\n```\r\n**复杂度分析**\r\n空间复杂度O（n）\r\n时间复杂度O（n）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Xyxy1722":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836098804","body":"思路\r\n每次取num的最后一位和k运算并保存最后一位的结果\r\n\r\n代码\r\n语言支持：Python3\r\nPython3 Code:\r\n\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = len(num) - 1\r\n        result = []\r\n        while(i >= 0 or k != 0):\r\n            if i >= 0:\r\n                k = k + num[i]\r\n            result.insert(0, k % 10)\r\n            k = int(k / 10)\r\n            i = i - 1\r\n        return result\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837654968","body":"## 思路\r\ndis值只和最近的c的位置有关 从左向右遍历一遍再从右向左遍历一遍\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        c_loc = -10000\r\n        dis = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                c_loc = i\r\n            dis.append(abs(i - c_loc))\r\n        c_loc = 20000\r\n        while(i >= 0):\r\n            if s[i] == c:\r\n                c_loc = i\r\n            if dis[i] > abs(i - c_loc):\r\n                dis[i] = abs(i - c_loc)\r\n            i = i - 1\r\n        return dis\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839384712","body":"\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.index = 0\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.index < self.maxSize:\r\n            self.stack.append(x)\r\n            self.index += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.index > 0:\r\n            self.index -= 1\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(k):\r\n            if i >= self.index:\r\n                break\r\n            self.stack[i] += val\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(k)\r\n- 空间复杂度：O(maxsize)\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eachless":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836098983","body":"\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n =  num.length;\r\n        int cur = k;\r\n        List<Integer> ans = new ArrayList();\r\n        \r\n        int i = n;\r\n        \r\n        while(--i >=0 || cur > 0){\r\n            if( i >= 0){\r\n                cur +=num[i];\r\n            }\r\n            \r\n            ans.add(cur % 10);\r\n            cur /= 10;\r\n        }\r\n        \r\n        \r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837305634","body":"\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] arr = new int[len];\r\n        int cpos = -len;\r\n        \r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i) == c){\r\n                cpos = i;\r\n            }\r\n            \r\n            arr[i] = i - cpos;\r\n        }\r\n        \r\n        for ( int i =len -1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                cpos=i;\r\n            }\r\n            arr[i] = Math.min(arr[i],Math.abs(i-cpos));\r\n        }\r\n        \r\n        return arr;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837305634","body":"\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] arr = new int[len];\r\n        int cpos = -len;\r\n        \r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i) == c){\r\n                cpos = i;\r\n            }\r\n            \r\n            arr[i] = i - cpos;\r\n        }\r\n        \r\n        for ( int i =len -1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                cpos=i;\r\n            }\r\n            arr[i] = Math.min(arr[i],Math.abs(i-cpos));\r\n        }\r\n        \r\n        return arr;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840083896","body":"class Solution {\r\n    public String decodeString(String s) {\r\n        int num = 0;\r\n        Stack <Object> stack = new Stack<>();\r\n        for(char c : s.toCharArray()){\r\n            //1 number\r\n            if(Character.isDigit(c)){\r\n                num = num * 10 + c - '0';\r\n            }else if( c == '['){\r\n                stack.push(Integer.valueOf(num));\r\n                num = 0;\r\n            }else if(c == ']'){\r\n                String newstr = dfs(stack);\r\n                Integer cnt = (Integer)stack.pop();\r\n                for(int i=0; i<cnt; i++){\r\n                    stack.push(newstr);\r\n                }\r\n            }else{//4. character\r\n                stack.push(String.valueOf(c));\r\n            }\r\n            //2 letter\r\n        }\r\n        return dfs(stack);\r\n    }\r\n    \r\n    private String dfs(Stack<Object> stack){\r\n        Stack<String> tmp = new Stack<>();\r\n        while(!stack.isEmpty()&& stack.peek() instanceof String){\r\n            tmp.push((String)stack.pop());\r\n        }\r\n        \r\n        StringBuilder sb = new StringBuilder();\r\n        while(!tmp.isEmpty()){\r\n            sb.append(tmp.pop());\r\n        }\r\n        return sb.toString();\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841299738","body":"```java\r\n class MyQueue {\r\n        Stack <Integer> fstack = new Stack();\r\n        Stack <Integer> output = new Stack();\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        Stack <Integer> fstack = new Stack();\r\n        Stack <Integer> output = new Stack();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        fstack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        peek();\r\n       return output.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (output.empty())\r\n            while(!fstack.empty())\r\n                output.push(fstack.pop());\r\n        return output.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return fstack.empty() && output.empty();\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linearindep":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836108570","body":"【思路】记住加法进位数量，一级一级加\r\n\r\n【代码】java\r\n\r\n`        int ans = 0;\r\n        List<Integer> arr = new ArrayList<Integer>();\r\n        int i = num.length-1;\r\n       \r\n        while( k>0||i>=0){  \r\n            if(i>=0){\r\n                k = num[i]+k; \r\n            } \r\n                    \r\n            int temp = k%10;\r\n            k = k/10;\r\n            arr.add(temp);\r\n            i--;\r\n        }\r\n        Collections.reverse(arr);\r\n        return arr;\r\n    }`\r\n\r\n【复杂度】时间O(n),空间O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837697742","body":"【思路】先找出所有的index存起来，再从右往左比较每个数前后两个index的距离，如果碰到了这个数，就remove掉它的index。\r\n               这么做可以，但是太慢了。其实跟从左找一遍再从右找一遍思路差不多，而且后者会更快\r\n【复杂度】 时间O(N) 空间O(N)\r\n\r\n     `public int[] shortestToChar(String s, char c) {\r\n        ArrayList<Integer> index = new ArrayList<Integer>() ;\r\n        int[] ans = new int[s.length()] ;\r\n        int i = 0;\r\n        for(i =0;i<s.length();i++){\r\n            if(s.charAt(i)==c){\r\n                index.add(i);\r\n                ans[i]=0;\r\n            }\r\n        }\r\n        int lastIdx = 99999;\r\n        for(i = s.length()-1; i>=0 ;i--){\r\n            int dis = 0;\r\n            if(index.size()==0){\r\n                dis = Math.abs(lastIdx-i);\r\n                \r\n            }else{\r\n            int curr = index.get(index.size()-1);\r\n            dis =Math.min(Math.abs(curr-i),Math.abs(i-lastIdx));\r\n                if(i == curr){\r\n                    index.remove(index.size()-1);\r\n                    lastIdx = curr;\r\n                }\r\n            }\r\n            ans[i] = dis;\r\n            \r\n\r\n        }\r\n        \r\n        return ans;\r\n\r\n    }`"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839437752","body":"思路：一开始就想着暴力写，inc是O(n),这样可以做但是很慢。 看了官方题解才发现只需要在pop的时候算出结果就可以了，因为其他操作是不会涉及到计算value的。就可以进化成为O(1)了\r\n复杂度:O(N)\r\n\r\n``` class CustomStack {\r\n    int occp = 0;\r\n    int size = 0;\r\n    int acc = 0;\r\n    ArrayList<Integer> ans = new ArrayList<Integer>();\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.occp=maxSize;\r\n\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(this.size<occp){\r\n        this.ans.add(x);\r\n        this.size++;\r\n        }\r\n\r\n    }\r\n    \r\n    public int pop() {\r\n        if(size==0){ return -1;}\r\n        this.size--;\r\n        return ans.remove(size);\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i = 0; i<k ;i++){\r\n            if(i>=this.size) return;\r\n            this.ans.set(i, val +this.ans.get(i));\r\n        }\r\n    }```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yeanli95":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836112944","body":"## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\nFirst Idea is to convert the array into Integer, then  sum up the array and k, then convert into desire result format.\r\n\r\nBut when array size gets larger, it is easy to get overflow when converting into integer.\r\n\r\nThen we need to go through the long way, adding bits from least significant to most significant, \r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```Java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> result = new ArrayList<>();\r\n\r\n        int carry = 0;\r\n        int numindex = num.length -1;\r\n        \r\n        while(numindex >=0 || k > 0 ){\r\n            int nums = numindex >=0 ? num[numindex] : 0;\r\n            int results = k > 0 ? k % 10 : 0;\r\n                                                      \r\n            int tempval = results + nums + carry;\r\n            int remainder = tempval % 10;\r\n            \r\n            carry = tempval / 10;\r\n            \r\n            result.add(0, remainder);\r\n            numindex--;\r\n            k /=10;\r\n        }\r\n        \r\n        if(carry > 0){\r\n            result.add(0, carry);\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837685280","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\nIterate the array from left to right, then from right to left to find optimal solution\r\n## 关键点\r\nInitialized Array to Integer.MAX_VALUE since we will be using Math.min function;\r\nWhen we first start iterating , assume the matching character will be on the other end.\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```Java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int [] result = new int[s.length()];\r\n        int cur = s.length() - 1;\r\n        Arrays.fill(result,Integer.MAX_VALUE);\r\n        for(int i =0; i < s.length(); i ++){\r\n            if(s.charAt(i) == c){\r\n                cur = i;\r\n            }\r\n            \r\n            result[i] = Math.min(result[i], Math.abs(cur - i));\r\n        }\r\n        \r\n        cur = 0;\r\n        for(int i =s.length() - 1; i >=0; i--){\r\n            if(s.charAt(i) == c){\r\n                cur = i;\r\n            }\r\n            result[i] = Math.min(result[i], Math.abs(cur - i));\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839399944","body":"## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\nSince it is a fixed size stack, it would be easier to use an array, so that both insert and get operation is O(1)\r\n\r\n## 关键点\r\n\r\nbe careful about the index on what it should be.\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```Java\r\nclass CustomStack {\r\n    int size;\r\n    int position;\r\n    int [] mystack;\r\n    public CustomStack(int maxSize) {\r\n        mystack = new int[maxSize];\r\n        size = maxSize; \r\n        position = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(position+1 < size){\r\n            mystack[position+1] = x;\r\n            position++;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(position > -1)\r\n            return mystack[position--];\r\n        else\r\n            return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(k > position){\r\n            k = position+ 1;\r\n        }\r\n        for(int i =0; i < k; i ++){\r\n            mystack[i] = mystack[i] + val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840270723","body":" * - ## 394. Decode String\r\n\r\n     https://leetcode.com/problems/decode-string/\r\n\r\n      ## 题目描述\r\n\r\n      ```\r\n     Given an encoded string, return its decoded string.\r\n     \r\n     The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\r\n     \r\n     You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\r\n     \r\n     Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\r\n     \r\n      \r\n     \r\n     Example 1:\r\n     \r\n     Input: s = \"3[a]2[bc]\"\r\n     Output: \"aaabcbc\"\r\n     Example 2:\r\n     \r\n     Input: s = \"3[a2[c]]\"\r\n     Output: \"accaccacc\"\r\n     Example 3:\r\n     \r\n     Input: s = \"2[abc]3[cd]ef\"\r\n     Output: \"abcabccdcdcdef\"\r\n     Example 4:\r\n     \r\n     Input: s = \"abc3[cd]xyz\"\r\n     Output: \"abccdcdcdxyz\"\r\n      ```\r\n\r\n      ## 前置知识\r\n\r\n      - \r\n\r\n      ## 公司\r\n\r\n      - 暂无\r\n\r\n      ## 思路\r\n\r\n     没想明白。参考leetcode官方题解\r\n\r\n     使用两个Stack 一个存次数 一个存string \r\n\r\n     因为这个规律是不变的 所以如果看到[ ， 就知道这是新的开始 也是旧的结束 所以把数字跟string 都放进stack \r\n\r\n     如果看到 ]  就知道， string已经完结 可以看看有多少重复 都列入去\r\n\r\n      ## 关键点\r\n\r\n      \r\n\r\n      ## 代码\r\n\r\n      - 语言支持：Java\r\n\r\n      Java Code:\r\n\r\n      ```Java\r\n     class Solution {\r\n         public String decodeString(String s) {\r\n             Stack<Integer> number = new Stack<>();\r\n             Stack<StringBuilder> sb = new Stack<>();\r\n             int k = 0;\r\n             StringBuilder currentString = new StringBuilder();\r\n             for(char ch : s.toCharArray()){\r\n                 if(Character.isDigit(ch)){\r\n                     k = k* 10 + ch -'0';\r\n                 }\r\n                 else if(ch == '['){\r\n                     number.push(k);\r\n                     \r\n                     sb.push(currentString);\r\n                     \r\n                     currentString = new StringBuilder();\r\n                     \r\n                     k = 0;\r\n                 }\r\n                 else if( ch ==']'){\r\n                     StringBuilder temp = sb.pop();\r\n                     for(int i = number.pop(); i > 0; i --){\r\n                         temp.append(currentString);\r\n                     }\r\n                     \r\n                     currentString = temp;\r\n                 }\r\n                 else{\r\n                     currentString.append(ch);\r\n                 }\r\n             }\r\n             \r\n             return currentString.toString();\r\n         }\r\n     }\r\n      ```\r\n\r\n\r\n      **复杂度分析**\r\n    \r\n      令 n 为数组长度。\r\n    \r\n      - 时间复杂度：$O(maxK * n)$\r\n      - 空间复杂度：$O(m+n)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840982845","body":" * ## 232. Implement Queue using Stacks\r\n\r\n   https://leetcode.com/problems/implement-queue-using-stacks/\r\n\r\n   ## 题目描述\r\n\r\n   ```\r\n   Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).\r\n   \r\n   Implement the MyQueue class:\r\n   \r\n   void push(int x) Pushes element x to the back of the queue.\r\n   int pop() Removes the element from the front of the queue and returns it.\r\n   int peek() Returns the element at the front of the queue.\r\n   boolean empty() Returns true if the queue is empty, false otherwise.\r\n   Notes:\r\n   \r\n   You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.\r\n   Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.\r\n   Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer.\r\n   \r\n    \r\n   \r\n   Example 1:\r\n   \r\n   Input\r\n   [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\r\n   [[], [1], [2], [], [], []]\r\n   Output\r\n   [null, null, null, 1, 1, false]\r\n   \r\n   Explanation\r\n   MyQueue myQueue = new MyQueue();\r\n   myQueue.push(1); // queue is: [1]\r\n   myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\n   myQueue.peek(); // return 1\r\n   myQueue.pop(); // return 1, queue is [2]\r\n   myQueue.empty(); // return false\r\n    \r\n   \r\n   Constraints:\r\n   \r\n   1 <= x <= 9\r\n   At most 100 calls will be made to push, pop, peek, and empty.\r\n   All the calls to pop and peek are valid.\r\n   ```\r\n\r\n   ## 前置知识\r\n\r\n    - \r\n\r\n   ## 公司\r\n\r\n    - 暂无\r\n\r\n   ## 思路\r\n\r\n   一个Stack 为主Stack\r\n\r\n   另一个为副\r\n\r\n   \r\n\r\n   如果要用到Pop 或者Peek  就把两个Stack 倒过去就能看到最低的那个元素\r\n\r\n   之后完成之后再倒回来\r\n\r\n   ## 关键点\r\n\r\n    \r\n\r\n   ## 代码\r\n\r\n    - 语言支持：Java\r\n\r\n    Java Code:\r\n\r\n   ```Java\r\n   class MyQueue {\r\n       Stack<Integer> stack1;\r\n       Stack<Integer> stack2;\r\n       /** Initialize your data structure here. */\r\n       public MyQueue() {\r\n           stack1 = new Stack<>();\r\n           stack2 = new Stack<>();\r\n       }\r\n       \r\n       /** Push element x to the back of queue. */\r\n       public void push(int x) {\r\n           stack1.push(x);\r\n       }\r\n       \r\n       /** Removes the element from in front of queue and returns that element. */\r\n       public int pop() {\r\n           while(stack1.size() != 1){\r\n               stack2.push(stack1.pop());\r\n           }\r\n           int result = stack1.pop();\r\n           \r\n           while(!stack2.isEmpty()){\r\n               stack1.push(stack2.pop());\r\n           }\r\n           \r\n           return result;\r\n       }\r\n       \r\n       /** Get the front element. */\r\n       public int peek() {\r\n           while(!stack1.isEmpty()){\r\n               stack2.push(stack1.pop());\r\n           }\r\n           \r\n           int result = stack2.peek();\r\n           \r\n           while(!stack2.isEmpty()){\r\n               stack1.push(stack2.pop());\r\n           }\r\n           return result;\r\n       }\r\n       \r\n       /** Returns whether the queue is empty. */\r\n       public boolean empty() {\r\n           return stack1.isEmpty();\r\n       }\r\n   }\r\n   \r\n   /**\r\n    * Your MyQueue object will be instantiated and called as such:\r\n    * MyQueue obj = new MyQueue();\r\n    * obj.push(x);\r\n    * int param_2 = obj.pop();\r\n    * int param_3 = obj.peek();\r\n    * boolean param_4 = obj.empty();\r\n    */\r\n   ```\r\n\r\n\r\n      **复杂度分析**\r\n    \r\n      令 n 为数组长度。\r\n    \r\n      - 时间复杂度：$O(n)$\r\n      - 空间复杂度：$O(1)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841595277","body":"## 768. Max Chunks To Make Sorted II\r\n\r\n  https://leetcode.com/problems/max-chunks-to-make-sorted-ii/\r\n\r\n  ## 题目描述\r\n\r\n  ```\r\n This question is the same as \"Max Chunks to Make Sorted\" except the integers of the given array are not necessarily distinct, the input array could be up to length 2000, and the elements could be up to 10**8.\r\n\r\nGiven an array arr of integers (not necessarily distinct), we split the array into some number of \"chunks\" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array.\r\n\r\nWhat is the most number of chunks we could have made?\r\n\r\nExample 1:\r\n\r\nInput: arr = [5,4,3,2,1]\r\nOutput: 1\r\nExplanation:\r\nSplitting into two or more chunks will not return the required result.\r\nFor example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.\r\nExample 2:\r\n\r\nInput: arr = [2,1,3,4,4]\r\nOutput: 4\r\nExplanation:\r\nWe can split into two chunks, such as [2, 1], [3, 4, 4].\r\nHowever, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.\r\nNote:\r\n\r\narr will have length in range [1, 2000].\r\narr[i] will be an integer in range [0, 10**8].\r\n  ```\r\n\r\n  ## 前置知识\r\n\r\n   - \r\n\r\n  ## 公司\r\n\r\n   - 暂无\r\n\r\n  ## 思路\r\n\r\n 创建另外一个数组， 把它排序\r\n\r\n之后就对比两个数据 如果两边的总和一样 他们的的块就能分裂然后排倒升序\r\n\r\n  ## 关键点\r\n\r\n   \r\n\r\n  ## 代码\r\n\r\n   - 语言支持：Java\r\n\r\n   Java Code:\r\n\r\n  ```Java\r\n class Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] sorted = arr.clone();\r\n        Arrays.sort(sorted);\r\n        int result = 0;\r\n        int sumarr= 0;\r\n        int sumsorted = 0;\r\n        for(int i =0; i < arr.length; i ++){\r\n            \r\n            sumarr += arr[i];\r\n            sumsorted += sorted[i];\r\n                \r\n            if(sumarr == sumsorted)\r\n                result++;\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n  ```\r\n\r\n\r\n      **复杂度分析**\r\n    \r\n      令 n 为数组长度。\r\n    \r\n      - 时间复杂度：$O(n)$\r\n      - 空间复杂度：$O(n)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841760336","body":"## 61. Rotate List\r\n\r\n  https://leetcode.com/problems/rotate-list/\r\n\r\n  ## 题目描述\r\n\r\n  ```\r\nGiven the head of a linked list, rotate the list to the right by k places.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: head = [1,2,3,4,5], k = 2\r\nOutput: [4,5,1,2,3]\r\nExample 2:\r\n\r\n\r\nInput: head = [0,1,2], k = 4\r\nOutput: [2,0,1]\r\n \r\n\r\nConstraints:\r\n\r\nThe number of nodes in the list is in the range [0, 500].\r\n-100 <= Node.val <= 100\r\n0 <= k <= 2 * 109\r\n  ```\r\n\r\n  ## 前置知识\r\n\r\n   - \r\n\r\n  ## 公司\r\n\r\n   - 暂无\r\n\r\n  ## 思路\r\n\r\n 找出新的head。\r\n\r\n砍开两半\r\n\r\n新的head 接旧的head  注意旧的head 就终止node 不然会形成环\r\n\r\n  ## 关键点\r\n\r\n注意边界条件\r\n\r\nhead == null \r\n\r\nhead.next ==null\r\n\r\nK == 0\r\n\r\nK == list.length\r\n\r\n以上都是List 维持不变的\r\n\r\n如果K大于length  就等于K绕了一个圈  那个圈可以直接忽略 所以用 K % count\r\n\r\n  ## 代码\r\n\r\n   - 语言支持：Java\r\n\r\n   Java Code:\r\n\r\n  ```Java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null ) return head;\r\n        \r\n        ListNode countList = head;\r\n        int count = 0;\r\n        while(countList != null){\r\n            countList = countList.next;\r\n            count++;\r\n        }\r\n        \r\n        k %= count;\r\n        k = count - k;\r\n        //if(k == 0 || k == count) return head;\r\n        \r\n        ListNode current = head;\r\n        ListNode prev = null;\r\n        for(int i =0; i < k; i ++){\r\n            prev = current;\r\n            current = current.next;\r\n        }\r\n        ListNode rotatedhead = current;\r\n        prev.next = null;\r\n        \r\n        ListNode endofRotatedhead = rotatedhead;\r\n        while(endofRotatedhead != null){\r\n            prev = endofRotatedhead;\r\n            endofRotatedhead = endofRotatedhead.next;\r\n        }\r\n        prev.next = head;\r\n        \r\n        return rotatedhead;\r\n    }\r\n}\r\n  ```\r\n\r\n\r\n      **复杂度分析**\r\n    \r\n      令 n 为数组长度。\r\n    \r\n      - 时间复杂度：$O(n)$\r\n      - 空间复杂度：$O(1)$\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"minuet-red":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836115382","body":"### **题目地址(989. 数组形式的整数加法)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 数组转数字\r\n1. 数字相加\r\n2. 数字转数组\r\n```\r\n\r\n### **代码**\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        tmp = 0\r\n        for i in num:\r\n            tmp = tmp * 10 + i   # 数组转数字\r\n        tmp += k      # 加法运算\r\n        result = []\r\n        for j in str(tmp):    # 数字转数组\r\n            result.append(int(j))\r\n        \r\n        return result\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(n)\r\n1. 空间复杂度：O(n)\r\n```\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838285144","body":"### **题目地址(821. 字符的最短距离)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n- 字符串 S 的长度范围为 [1, 10000]。\r\n- C 是一个单字符，且保证是字符串 S 里的字符。\r\n- S 和 C 中的所有字母均为小写字母。\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 考察数组的遍历(正向遍历和反向遍历)\r\n我的思路\r\n1. 对于字符串s的每一个字符，如果该字符等于c，输出0，进行下一个循环\r\n2. 对于字符串s的每一个字符，如果该字符不等于c，往前往后分别查找c,\r\n\t- 一方找不到c，输出另一方距离\r\n\t- 都找得到c，记录两个距离\r\n3. 输出两个距离中的最小值\r\n```\r\n\r\n### **代码**\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        slength = len(s)\r\n        res = []\r\n        for i in range(slength):\r\n            if s[i] == c:\r\n                res.append(0)\r\n                continue\r\n            j = i\r\n            k = i\r\n            while(s[j] != c):\r\n                j -= 1\r\n                if j < 0:\r\n                    break  \r\n                \r\n            while(s[k] != c):\r\n                k += 1\r\n                if k >= slength:\r\n                    break\r\n                    \r\n            la = i-j    \r\n            lb = k-i    \r\n            if j < 0: \r\n                res.append(lb)\r\n            elif k >= slength:\r\n                res.append(la) \r\n            else:\r\n                res.append(min(la, lb))\r\n        return res\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(n·k)，n是字符串的长度，k是查找到字符c的长度\r\n1. 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839440151","body":"### **题目地址(1381. 设计一个支持增量操作的栈)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1); // 栈变为 [1]\r\ncustomStack.push(2); // 栈变为 [1, 2]\r\ncustomStack.pop(); // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2); // 栈变为 [1, 2]\r\ncustomStack.push(3); // 栈变为 [1, 2, 3]\r\ncustomStack.push(4); // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100); // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100); // 栈变为 [201, 202, 103]\r\ncustomStack.pop(); // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop(); // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop(); // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop(); // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 考察栈、入栈、出栈、类、前缀和\r\n1. push \r\n   栈到达最大值时不能再append \r\n   if 列表长度 < 最大长度\r\n   \t\tappend\r\n2. pop\r\n   else：栈为空即栈长度为0 return 0；if 列表长度 > 0: 栈顶 = pop(-1)\r\n3. increment\r\n   if 取值 > 列表长度：\r\n   \t  取值 = 列表长度\r\n4. 解法一：以时间换空间 常规解法\r\n遍历列表k个数，都加val\r\n5. 解法二：以空间换时间 辅助列表解法\r\n创建一个辅助栈，主栈append的同时辅助栈append(0)，increment时在第k个元素保存val，在pop的时候主栈和辅助栈末尾元素相加输出，然后辅助栈末尾元素向前传递，加给pop后的辅助栈末尾元素\r\n```\r\n\r\n### **代码**\r\n\r\n```python\r\n解法一：以时间换空间 常规解法\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) > 0:\r\n            top = self.stack.pop(-1)\r\n            return top\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k > len(self.stack):\r\n            k = len(self.stack)\r\n        for i in range(k):\r\n            self.stack[i] += val\r\n\r\n解法二：以空间换时间 辅助列表解法\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.add_stack = []  \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n            self.add_stack.append(0)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) > 0:\r\n            top = self.stack.pop(-1)\r\n            add_top = self.add_stack.pop(-1)\r\n            if len(self.add_stack) > 0:\r\n                self.add_stack[-1] += add_top\r\n            res = top + add_top\r\n            return res\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k > len(self.stack):\r\n            k = len(self.stack)\r\n        if len(self.add_stack) > 0:\r\n            self.add_stack[k-1] += val\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n解法一\r\n0. 时间复杂度：O(n)\r\n1. 空间复杂度：O(1)\r\n解法二\r\n0. 时间复杂度：O(1)\r\n1. 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840394919","body":"### **题目地址(394. 字符串解码)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n示例 3：\r\n\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n示例 4：\r\n\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 考察栈、入栈、出栈、括号匹配显然是一种栈问题\r\n1. 遍历字符串：\r\n\t若不是']': 入栈\r\n\t若是']': 创建两个字符串分别记录括号内字符串和括号前数字\r\n\t\t\t若栈末尾不是'['就循环:出栈，记录出栈的字符\r\n\t\t\t弹出'[' 找出了匹配的'['并在栈中消除了该'[', 未干扰后面的']'\r\n\t\t\t若栈末尾是数字且栈不为空就循环:出栈，记录出栈的数字\r\n\t\t\t入栈:数×括号内字符串\r\n\t栈列表转字符串\r\n```\r\n\r\n### **代码**\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for i in s:\r\n            if i == ']':\r\n                saveStr = ''\r\n                saveNum = ''\r\n                while stack[-1] != '[':\r\n                    saveStr = stack.pop() + saveStr\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    saveNum = stack.pop() + saveNum \r\n                stack.append(int(saveNum) * saveStr)\r\n            else:\r\n                stack.append(i)\r\n        return \"\".join(stack)\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(n²)\r\n1. 空间复杂度：O(n)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840969872","body":"### **题目地址(232. 用栈实现队列)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n使用栈实现队列的下列操作：\r\n\r\npush(x) -- 将一个元素放入队列的尾部。\r\npop() -- 从队列首部移除元素。\r\npeek() -- 返回队列首部的元素。\r\nempty() -- 返回队列是否为空。\r\n示例:\r\n\r\nMyQueue queue = new MyQueue();\r\n\r\nqueue.push(1);\r\nqueue.push(2);\r\nqueue.peek(); // 返回 1\r\nqueue.pop(); // 返回 1\r\nqueue.empty(); // 返回 false\r\n说明:\r\n\r\n你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n假设所有操作都是有效的、 （例如，一个空的队列不会调用 pop 或者 peek 操作）。\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 考察栈、入栈、出栈、用栈模拟队列\r\n1. 解法一：用pop(0)直接弹出第一个数  \r\n2. 解法二：辅助栈\r\n```\r\n\r\n### **代码**\r\n\r\n```python\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.queue = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.queue.append(x)\r\n\r\n    def pop(self) -> int:\r\n        first_pop = self.queue.pop(0)\r\n        return first_pop\r\n\r\n    def peek(self) -> int:\r\n        first = self.queue[0]\r\n        return first\r\n\r\n    def empty(self) -> bool: \r\n        return self.queue == []\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(1)\r\n1. 空间复杂度：O(n)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841592514","body":"### **题目地址(768. 最多能完成排序的块)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\r\n\r\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\r\n\r\n我们最多能将数组分成多少块？\r\n\r\n示例 1:\r\n\r\n输入: arr = [5,4,3,2,1]\r\n输出: 1\r\n解释:\r\n将数组分成2块或者更多块，都无法得到所需的结果。\r\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。\r\n示例 2:\r\n\r\n输入: arr = [2,1,3,4,4]\r\n输出: 4\r\n解释:\r\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\r\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。\r\n注意:\r\n\r\narr的长度在[1, 2000]之间。\r\narr[i]的大小在[0, 10**8]之间。\r\n\r\n\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 考察栈、单调栈、栈内元素单调增加\r\n1. 前面数字比后面数字小且更前面没更大的，这两个必然是两块，分开\r\n   更前面有更大的，着该数与那个更大的数必然一块\r\n   stack里面放的是各个块的最大值\r\n2. 创建一个栈，遍历原数组\r\n\r\n   若栈为空，当前最大值是0\r\n   若栈不为空，当前最大值是栈最后一个数\r\n   \r\n   若元素大于当前最大值，入栈\r\n   若元素小于当前最大值，循环出栈直到栈为空或者元素大于栈尾，将当前最大值入栈\r\n   返回栈长度，也就是各个块最大值数，也就是块数\r\n```\r\n\r\n### **代码**\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for i in arr:\r\n            if stack:\r\n                max = stack[-1]\r\n            else:\r\n                max = 0\r\n            if i < max:\r\n                while stack and i < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(max)\r\n            else:\r\n                stack.append(i)\r\n        return len(stack)\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(n)\r\n1. 空间复杂度：O(n)\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841752893","body":"### **题目地址( 61. 旋转链表)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/rotate-list/\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。\r\n\r\n示例 1:\r\n\r\n输入: 1->2->3->4->5->NULL, k = 2\r\n输出: 4->5->1->2->3->NULL\r\n解释:\r\n向右旋转 1 步: 5->1->2->3->4->NULL\r\n向右旋转 2 步: 4->5->1->2->3->NULL\r\n示例 2:\r\n\r\n输入: 0->1->2->NULL, k = 4\r\n输出: 2->0->1->NULL\r\n解释:\r\n向右旋转 1 步: 2->0->1->NULL\r\n向右旋转 2 步: 1->2->0->NULL\r\n向右旋转 3 步: 0->1->2->NULL\r\n向右旋转 4 步: 2->0->1->NULL\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 链表  不太会，链表知识待补课\r\n1. 如果head is None，返回head\r\n2. 将链表首位相接变为循环链表并得到链表长度\r\n3. 从原head位开始寻找新head（if index == length-k）\r\n4. 如果当前位的下一位是新头部，储存新head，并切断当前node与node.next（新head）之间的link。返回新head\r\n```\r\n\r\n### **代码**\r\n\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n\r\n        # if head is null, return head\r\n        if not head:\r\n            return head\r\n        \r\n        # Get length and connect the last and head to change NodeList to a circular NodeList \r\n        length = 1\r\n        newNode = head\r\n        while(newNode.next):\r\n            newNode = newNode.next\r\n            length += 1\r\n        newNode.next = head\r\n\r\n        # get real cut index\r\n        k = k % length\r\n\r\n       # find new head\r\n        index = 0\r\n        returnNode = None\r\n        while(True):\r\n            if index == length-k:\r\n                returnNode = newNode.next\r\n                newNode.next = None\r\n                return returnNode\r\n            index += 1\r\n            newNode = newNode.next \r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(n)\r\n1. 空间复杂度：O(1)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LexieLiu01":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836117591","body":"`\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        carry = 0\r\n        for i in range(len(A) - 1, -1, -1):\r\n        A[i], carry = (carry + A[i] + K % 10) % 10, (carry + A[i] + K % 10) // 10\r\n        K //= 10\r\n        B = []\r\n        carry = carry + K\r\n        while carry:\r\n        B = [(carry) % 10] + B\r\n        carry //= 10\r\n    return B + A\r\n\r\n`"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838334269","body":"class Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        for i in range(len(s)):\r\n            l = r = i\r\n            \r\n            while l > -1:\r\n                if s[l] == c: break\r\n                l -= 1\r\n            while r < len(s):\r\n                if s[r] == c: break\r\n                r += 1\r\n            \r\n            if l == -1:\r\n                l = -10000\r\n            if r == len(s):\r\n                r = 20000\r\n            ans.append(min(r-i,i-l))\r\n            \r\n        return ans"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838334269","body":"class Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        for i in range(len(s)):\r\n            l = r = i\r\n            \r\n            while l > -1:\r\n                if s[l] == c: break\r\n                l -= 1\r\n            while r < len(s):\r\n                if s[r] == c: break\r\n                r += 1\r\n            \r\n            if l == -1:\r\n                l = -10000\r\n            if r == len(s):\r\n                r = 20000\r\n            ans.append(min(r-i,i-l))\r\n            \r\n        return ans"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HackBL":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836118591","body":"* 思路：Array从后往前遍历，每遍历一次，加上k，取总和的个位数，存入到list中。k /= 10，为下一个元素做准备。 遍历整个数组，如果k还存在数字（即 != 0)，继续遍历k，一一存入到list中\r\n* 误区：最开始使用int，把数组和k的数字相加在一起，导致integer overflow\r\n* 语言：Java\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new LinkedList<>();\r\n        \r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            k += num[i];\r\n            list.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        while (k != 0) {\r\n            list.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n        return list;\r\n    }\r\n}\r\n```\r\n* 时间：O(n), n: max(nums.length, k的长度)\r\n* Space: O(n), n: max(nums.length, k的长度)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837785007","body":"* 思路：先正序，再倒序\r\n正序：所有在s中的元素（除了c元素），以其左边的c为参照物，求出距离，并存在answer中。若元素的左边没有参照物c，则存入string.length()与当前index的差值。\r\n倒序：所有在s中的元素（除了c元素），以其右边的c为参照物，求出最小距离（min(answer[o], pos-1)），并存在answer中。\r\n若当前元素为c，answer当前index的元素为0\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int pos = -n;\r\n        int[] answer = new int[n];\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) pos = i;\r\n            answer[i] = i - pos;\r\n        }\r\n        \r\n        for (int i = pos; i >= 0; i--) {\r\n            if (s.charAt(i) == c) pos = i;\r\n            answer[i] = Math.min(answer[i], pos - i);\r\n        }\r\n        \r\n        return answer;\r\n    }\r\n}\r\n```\r\n* 时间：O(n)， n为s的长度\r\n* 空间：O(n)， 建立新数组answer，长度为n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839428969","body":"* 思路：第一想法，用ArrayList存储所有数据\r\n```\r\nclass CustomStack {\r\n    List<Integer> stack = new ArrayList();\r\n    int maxSize;\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (stack.size() == maxSize) return;\r\n        stack.add(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (stack.isEmpty()) return -1;\r\n        int val = stack.remove(stack.size()-1);\r\n        return val;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < k; i++) {\r\n            if (i >= stack.size()) break;\r\n            stack.set(i, stack.get(i) + val);\r\n            \r\n        }\r\n    }\r\n}\r\n```\r\n* 时间： Push: O(1), Pop: O(1), increment: O(n)\r\n* 空间: O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840297389","body":"Will do"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841652112","body":"will do"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixi-jiu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836121004","body":"### 思路\r\n\r\n利用 加一 那道题的思路 从个位加起\r\n最后还要处理 k 大于 0 的情况\r\n例如：num = [0];k = 23 \r\n\r\n不明白为什么耗时很多 200+ms\r\n### 代码\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    const len = num.length;\r\n    let res = [];\r\n    for (let i = len - 1;i >= 0;i--) {\r\n        let sum = num[i] + (k % 10);\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n            res.unshift(sum);\r\n        } else {\r\n            res.unshift(sum);\r\n        }\r\n    }\r\n    while (k > 0) {\r\n        res.unshift(k % 10);\r\n        k = Math.floor(k / 10);\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837644356","body":"/* 思路\r\n- 遍历字符串\r\n- 从每个字符的左边和右边分别开始寻找目标字符\r\n- 如果找到了, 结束遍历\r\n- 如果没有找到, 给下标赋值无穷大\r\n- 选择较近的距离即可\r\n*/ \r\n// 代码\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let res = [];\r\n    for (let i = 0;i < s.length;i++) {\r\n        let left = i, right = i;\r\n        while (left >= 0) {\r\n            if (s[left] === c) {\r\n                break;\r\n            }\r\n            left--;\r\n        }\r\n        while (right < s.length) {\r\n            if (s[right] === c) {\r\n                break;\r\n            }\r\n            right++;\r\n        }\r\n        // 如果没有找到\r\n        if (left === -1) left = -Infinity;\r\n        if (right === s.length) right = Infinity;\r\n        // 选择较近的距离\r\n        res[i] = Math.min((i - left), (right - i));\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(N ^ 2)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n*/"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839377460","body":"/* 思路\r\n- js 中本身就有栈这种结构因此比较简单\r\n*/ \r\n// 代码\r\n```js\r\nvar CustomStack = function(maxSize) {\r\n    this.arr = [];\r\n    this.len = maxSize;\r\n};\r\n\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.arr.length < this.len) {\r\n        this.arr.push(x);\r\n    }\r\n};\r\n\r\nCustomStack.prototype.pop = function() {\r\n    if (this.arr.length === 0) {\r\n        return -1;\r\n    } else {\r\n        return this.arr.pop();\r\n    }\r\n};\r\n\r\nCustomStack.prototype.increment = function(k, val) {\r\n    if (k < this.arr.length) {\r\n        for (let i = 0;i < k;i++) {\r\n            this.arr[i] += val;\r\n        } \r\n    } else {\r\n        for (let i = 0;i <  this.arr.length;i++) {\r\n            this.arr[i] += val;\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(n)，其中 n 为数组长度。\r\n- 空间复杂度：O(n)\r\n*/"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840222483","body":"/* 思路\r\n- 用两个栈, 一个是存倍数的栈, 一个是存待拼接的字符串的栈\r\n- num 用来表示临时倍数\r\n- result 用来表示结果字符串\r\n- 如果碰到数字 -> 计算出倍数 -> 注意如果是连续多个数字, 要处理倍数\r\n- 如果碰到 '[' -> result 入栈(保存之前的) 并清零, num 入栈并清零\r\n- 把之前的 result 和 num 入栈, 开始寻找新的\r\n- 如果碰到 ']' -> 两个栈的栈顶元素出栈并计算\r\n- 之前的 + 现在的\r\n*/ \r\n// 代码\r\n```js\r\nvar decodeString = function(s) {\r\n    let numStack = [];\r\n    let strStack = [];\r\n    let num = 0;\r\n    let result = \"\";\r\n    for (const char of s) {\r\n        if (!isNaN(char)) {\r\n            num = num * 10 + Number(char);\r\n        } else if (char === '[') {\r\n            numStack.push(num);\r\n            num = 0;\r\n            strStack.push(result);\r\n            result = \"\";\r\n        } else if (char === ']') {\r\n            let repeatTimes = numStack.pop();\r\n            result = strStack.pop() + result.repeat(repeatTimes);\r\n        } else {\r\n            result += char;\r\n        }\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(n)，其中 n 为数组长度。\r\n- 空间复杂度：O(n)\r\n*/"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840995386","body":"/* 思路\r\n- 用两个栈，关键是 push 操作时要使用到辅助栈\r\n*/ \r\n// 代码\r\n```js\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n    this.stackHelper = [];\r\n};\r\n\r\nMyQueue.prototype.push = function(x) {\r\n    while (this.stack.length) {\r\n        this.stackHelper.push(this.stack.pop());\r\n    }\r\n    this.stack.push(x);\r\n    while (this.stackHelper.length) {\r\n        this.stack.push(this.stackHelper.pop());\r\n    }\r\n};\r\n\r\nMyQueue.prototype.pop = function() {\r\n    return this.stack.pop();\r\n};\r\n\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[this.stack.length - 1];\r\n};\r\n\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack.length === 0;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(n)，其中 n 为数组长度。\r\n- 空间复杂度：O(n)\r\n*/"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841683491","body":"/* 思路\r\n- 单调栈思路, 转化为单调递增的栈\r\n- 将递减的元素合并, 例如 2, 1 合并为 2, 相当于是一个标杆\r\n- 递增的元素进栈, 维持单调栈\r\n- 例如: 0 2 1\r\n- 则 1 先与 2 合并, 然后还要判断 1 和 0 的大小关系, 如果 1 > 0 说明还要进行合并\r\n- 因为相当于是一个块, 所以要将 0 进行出栈, 类推\r\n- 最后返回的栈的长度就是最多的块数\r\n*/ \r\n// 代码\r\n```js\r\nvar maxChunksToSorted = function(arr) {\r\n    let stack = [];\r\n    for (let i = 0;i < arr.length;i++) {\r\n        const num = arr[i];\r\n        if (stack.length > 0 && num < stack[stack.length - 1]) {\r\n            const cur = stack[stack.length - 1];\r\n            while (stack.length > 0 && num < stack[stack.length - 1]) {\r\n                stack.pop();\r\n            }\r\n            stack.push(cur);\r\n        } else {\r\n            stack.push(arr[i]);\r\n        }\r\n    }\r\n    return stack.length;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(n)，其中 n 为数组长度。\r\n- 空间复杂度：O(n)\r\n*/"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Daniel-Zheng":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836131939","body":"### 思路\r\n\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int length = num.size();\r\n        int current = k;\r\n        \r\n        while (--length >=0 || current > 0) {\r\n            if (length >= 0) current += num[length];\r\n            res.push_back(current % 10);\r\n            current /= 10;\r\n        }\r\n        \r\n        reverse(res.begin(), res.end());\r\n        return res; \r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837622983","body":"### 思路\r\n\r\n正反遍历\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res(s.size());\r\n        int current = 99999;\r\n        \r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] == c) current = i;\r\n            res[i] = abs(i - current);\r\n        }\r\n        \r\n        current = 99999;\r\n        for (int j = s.size() - 1; j >= 0; j--) {\r\n            if (s[j] == c) current = j;\r\n            res[j] = min(abs(j - current), res[j]);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839502679","body":"### 思路\r\n\r\n### 代码(C++)\r\n```C++\r\nclass CustomStack {\r\npublic:\r\n    int array[1000];\r\n    int count = 0;\r\n    int size = 0;\r\n    \r\n    CustomStack(int maxSize) {\r\n        size = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (count < size) array[count++] = x;\r\n    }\r\n    \r\n    int pop() {\r\n        if (count > 0) {\r\n            return array[--count];\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for (int i = 0; i < min(k, count); i++) {\r\n            array[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840348543","body":"### 思路\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<int> numberCount;\r\n        stack<string> tempString;\r\n        int index = 0;\r\n        string result = \"\";\r\n        string temp = \"\";\r\n        \r\n        while (index < s.length()) { \r\n            if (isdigit(s[index])) {\r\n                int numberIndex = 0;\r\n                while (isdigit(s[index])) {\r\n                    numberIndex = numberIndex * 10 + s[index] - '0';\r\n                    index++;\r\n                }\r\n                numberCount.push(numberIndex);\r\n            }\r\n            else if (s[index] == '[') {\r\n                tempString.push(result);\r\n                result = \"\";\r\n                index++;\r\n            }\r\n            else if (s[index] == ']') {\r\n                int number = numberCount.top();\r\n                numberCount.pop();\r\n                temp = tempString.top();\r\n                tempString.pop();\r\n                for (int i = 0; i < number; i++) {\r\n                    temp += result;\r\n                }\r\n                result = temp;\r\n                index++;\r\n            }\r\n            else {\r\n                result += s[index];\r\n                index++;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841014898","body":"### 思路\r\n\r\n### 代码(C++)\r\n```C++\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n        \r\n    }\r\n    \r\n    stack<int> res;\r\n    stack<int> help;\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        while (res.size() != 0) {\r\n            help.push(res.top());\r\n            res.pop();\r\n        }\r\n        res.push(x);\r\n        while (help.size() != 0) {\r\n            res.push(help.top());\r\n            help.pop();\r\n        }\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        int firstElement = res.top();\r\n        res.pop();\r\n        return firstElement;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        return res.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        if (res.size() == 0) return true;\r\n        return false;\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841522817","body":"### 思路\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> res;\r\n        for (int i = 0; i< arr.size(); i++) {\r\n            if (!res.empty() && arr[i] < res.top()) {\r\n                int curMax = res.top();\r\n                while (!res.empty() && arr[i] < res.top()) res.pop();\r\n                res.push(curMax);\r\n            } else {\r\n                res.push(arr[i]);\r\n            }\r\n        }\r\n        return res.size();\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hannahliu-github":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836142144","body":"思路：先把str变成int；加上k；再转回str，放进list里\r\n\r\n代码：python\r\n\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        x = int(''.join([str(s) for s in num]))\r\n        ans = x + k\r\n        array_form = [int(s) for s in str(ans)]\r\n        return array_form\r\n\r\n复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839403780","body":"cr. breadfruit (最近考试，先抄上一个好看的，交个作业，镇定一下。。)\r\n\r\n思路\r\n需要两个判断变量，一个是记录当前栈顶元素位置p，另一个是记录最大栈空间的位置q。\r\npush的时候判断当前栈顶元素位置p是否会大于最大栈空间的位置q\r\npop判断当前栈中是否有元素\r\nincrement判断k和当前栈顶元素位置p的大小\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.top = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top > len(self.stack):\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack: \r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, len(self.stack))\r\n        for i in range(lim):\r\n            self.stack[i] += val\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841250774","body":"cr. zliu1314 & kofzhang\r\n\r\n思路：\r\nself.instack\r\nself.outstack\r\n用2个列表实现，一个入一个出，入就一直入，出的时候看出列表里是否有值，如果有，直接出，如果没有，把入队列里的数据全部倒过来。\r\n\r\n\r\n代码：\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n    def in2out(self):\r\n        while (self.instack!=[]):\r\n            self.outstack.append(self.instack.pop())\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.instack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.outstack == []:\r\n            self.in2out()\r\n        return self.outstack.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.outstack == []:\r\n            self.in2out()\r\n        return self.outstack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return (self.outstack==[]) & (self.instack==[])\r\n\r\n复杂度：\r\n时间O(1)\r\n空间O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841679057","body":"cr. zliu1314 & breadfruit\r\n思路：构建一个单调栈，单调栈里只储存一个模块内最大的那个数字，栈里有几个数字，就是几个模块。后一个模块内，最小的数字，应大于或等于前一个模块内最大的数字。the minimum in the next block must be higher or equal to the max of current block. create a stack to store new max, and if come across a small number, than pop out the stack until the stack peek is smaller or equal to this small number. push the max into the stack.\r\n\r\n代码python：\r\nclass Solution:\r\n    def maxChunksToSorted(self, A: [int]) -> int:\r\n        stack = []\r\n        for i in A :\r\n            if stack and stack[-1] > i:\r\n                cur = stack[-1]\r\n                while stack and stack[-1] > i:\r\n                    stack.pop()\r\n                stack.append(cur)\r\n            else:\r\n                stack.append(i)\r\n        return len(stack)\r\n\r\n复杂度：\r\n时间N(O)\r\n空间N(O)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yunli2015":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836150346","body":"**思路**： 和add string一样，从末尾往前遍历，用sum， carry 记录\r\n**代码**：java\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int carry = 0, sum =0;\r\n        List<Integer> list = new ArrayList<>();\r\n        if(num.length == 0) return list;\r\n        int i= num.length - 1;\r\n        while(i>=0 || k != 0) {\r\n            sum = carry;\r\n            if(i >= 0) {\r\n                sum += num[i];\r\n                i--;\r\n            }\r\n            if(k != 0) {\r\n                sum += k %10;\r\n                k = k/10;\r\n            }\r\n            list.add(0, sum %10);\r\n            carry = sum /10;\r\n        }\r\n\r\n        if(carry != 0) list.add(0, carry);\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析：**\r\n时间复杂度：O（n）\r\n空间复杂度：O（1）"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839290372","body":"**思路**:   用一个增量数组记录增量，pop时加上increment[count-1]\r\n**代码：**\r\njava\r\n```\r\nclass CustomStack {\r\n    int[] increment;\r\n    Stack<Integer> s;\r\n    int count;\r\n    int size;\r\n    public CustomStack(int maxSize) {\r\n        size = maxSize;\r\n        increment = new int[size + 1];\r\n        s = new Stack<Integer>();\r\n        count = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(count == size) return;\r\n        s.push(x);\r\n        count++;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(s.isEmpty()) return -1;\r\n        int extra = increment[count -1];\r\n        if(count >= 2) increment[count - 2] += extra;\r\n        increment[count - 1] = 0;\r\n        count--;\r\n        return s.pop() + extra;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(count == 0) return;\r\n        increment[Math.min(k, count) - 1] += val;\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n**复杂度：**\r\nT： O（1）\r\nS：O（k）k == maxSize"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840349815","body":"O(n)\r\nO(n)\r\n\r\n```\r\nclass Solution {\r\n    \r\n    class elem{\r\n        int n;\r\n        String s;\r\n        elem (int n, String s) {\r\n            this.n = n;\r\n            this.s = s;\r\n        }\r\n    }\r\n    public String decodeString(String s) {\r\n        Stack<elem> stack = new Stack<>();\r\n        \r\n        int number = 0;\r\n        for(int i=0; i<s.length(); i++) {\r\n            char c = s.charAt(i);\r\n            if(Character.isDigit(c)) {\r\n                number = number * 10 + c - '0';\r\n            } else if (c == '[') {\r\n                stack.push(new elem(number, \"\"));\r\n                //System.out.println(number);\r\n                number = 0;\r\n                stack.push(new elem(0, Character.toString(c)));\r\n            } else if (c == ']') {\r\n                Stack<String> temp = new Stack<>();\r\n                while(!stack.peek().s.equals(\"[\")) {\r\n                    temp.push(stack.pop().s);\r\n                }\r\n                \r\n                stack.pop();\r\n                int num = stack.pop().n;\r\n                StringBuilder sb = new StringBuilder();\r\n                while(!temp.isEmpty()) {\r\n                    sb.append(temp.pop());\r\n                }\r\n                \r\n                for(int j=0; j<num; j++) {\r\n                    stack.push(new elem(0, sb.toString()));\r\n                }\r\n            } else {\r\n                stack.push(new elem(0, Character.toString(c)));\r\n            }\r\n        }\r\n        \r\n        Stack<String> temp2 = new Stack<>();\r\n        while(!stack.isEmpty()) {\r\n            temp2.push(stack.pop().s);\r\n        }\r\n        StringBuilder sb = new StringBuilder();\r\n        while(!temp2.isEmpty()) {\r\n            sb.append(temp2.pop());\r\n        }\r\n        \r\n        return sb.toString();\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840798120","body":"```java\r\n\r\nclass MyQueue {\r\n    Stack<Integer> s1;\r\n    Stack<Integer> s2;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n//O(1)\r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n//O(1)\r\n    public int pop() {\r\n        if(s2.isEmpty()) {\r\n            popStack();\r\n        }\r\n        return s2.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(s2.isEmpty()) {\r\n            popStack();\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n    \r\n    private void popStack() {\r\n        while(!s1.isEmpty()) {\r\n            s2.push(s1.pop());\r\n        }\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841608936","body":"单调栈\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> s = new Stack<>();\r\n        for(int n:arr) {\r\n            if(!s.isEmpty() && n < s.peek()) {\r\n                int cur = s.pop();\r\n                while(!s.isEmpty() && n < s.peek()) {\r\n                    s.pop();\r\n                }\r\n                s.push(cur);\r\n            } else {\r\n                s.push(n);\r\n            }\r\n        }\r\n        return s.size();\r\n    }\r\n}\r\n```\r\n\r\nT：O(N)\r\nS：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Xeraphinite":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836152663","body":"### 思路\r\n模拟即可，需要注意最终返回数组的长度\r\n\r\n### 时空复杂度\r\n**时间复杂度**：O(max(log(k), n))，只进行了一次遍历\r\n**空间复杂度**：O(1)，除了存储结果的 `vector` 之外没有用到额外的变量\r\n\r\n### Code\r\n\r\n#### C++\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n      reverse(num.begin(), num.end());\r\n      int n = num.size(), i = 0;\r\n      vector<int> ans(max(n, (int)to_string(k).size()) + 1, 0);\r\n      while (i < n || k) {\r\n        ans[i] += (i < n ? num[i] : 0) + k % 10; \r\n        ans[i + 1] += ans[i] / 10, ans[i] %= 10;\r\n        k /= 10, i++;\r\n      }\r\n      if (ans.back() == 0) ans.pop_back();\r\n      return vector<int>(ans.rbegin(), ans.rend());\r\n    }\r\n};\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838309562","body":"### 思路\r\n记录下标，并从前后两次遍历分别更新值。\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n      int n = s.size();\r\n      vector<int> res(n, 0), nextC;\r\n      for (int i = 0; i < n; i++)\r\n        if (s[i] == c) nextC.emplace_back(i);\r\n      int m = nextC.size();\r\n      for (int i = 0, j = 0; i < n; i++) {\r\n        res[i] = abs(nextC[j] - i);\r\n        if (j < m - 1 && nextC[j] == i) j++;\r\n      }\r\n      for (int i = n - 1, j = m - 1; i >= 0; i--) {\r\n        res[i] = min(abs(nextC[j] - i), res[i]);\r\n        if (j > 0 && nextC[j] == i) j--;\r\n      }\r\n      return res;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839457645","body":"### 思路\r\n\r\n在线处理即可（这道题与其说是前缀和，不如说只是一个从后往前的累加）。\r\n需要注意每一个变量代表的意义，不然很容易调炸。\r\n\r\n**时间复杂度：** O(n)，每个操作都是 O(1) 的，因此这里的 n 是操作个数。\r\n**空间复杂度：** O(max{k, maxSize})，其中 k 是栈中元素最多时候的个数。\r\n\r\n### 代码\r\n```C++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : maxSize(maxSize) {}\r\n    \r\n    void push(int x) {\r\n      if (stk.size() >= maxSize) {\r\n        return;\r\n      }\r\n      stk.emplace_back(x);\r\n      inc.emplace_back(0);\r\n    }\r\n    \r\n    int pop() {\r\n      if (stk.empty()) {\r\n        return -1;\r\n      }\r\n      int curTop = stk.back();\r\n      stk.pop_back();\r\n      int curInc = inc.back();\r\n      inc.pop_back();\r\n      if (!inc.empty()) {\r\n        inc.back() += curInc;\r\n      }\r\n      return curTop + curInc;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n      if (stk.empty()) {\r\n        return;\r\n      }\r\n      int n = stk.size();\r\n      inc[(k >= n ? n - 1 : k - 1)] += val;\r\n    }\r\n\r\nprivate:\r\n  int maxSize;\r\n  vector<int> stk;\r\n  vector<int> inc;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840589861","body":"### 思路\r\n\r\n写栈不知道为啥写炸了，明天再调调看\r\n\r\n一个普通的递归下降分析。(参考官方代码写的）\r\n\r\n时间复杂度：O(n)， n 为字符串长度\r\n空间复杂度：O(n)，最多需要用到长度为 n 的系统栈储存\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int getNum() {\r\n      int repeatTimes = 0;\r\n      while (idx < src.size() && isdigit(src[idx])) {\r\n        repeatTimes *= 10;\r\n        repeatTimes += (src[idx++] - '0');\r\n      }\r\n      return repeatTimes;\r\n    }\r\n\r\n    string getString() {\r\n      if (idx >= src.size() || src[idx] == ']') {\r\n        return \"\";\r\n      }\r\n      string ret;\r\n      char cur = src[idx]; \r\n      int repTime = 1;\r\n      if (isdigit(cur)) {\r\n        repTime = getNum(); \r\n        idx++;\r\n        string str = getString(); \r\n        idx++;\r\n        while (repTime--) ret += str; \r\n      } else if (isalpha(cur)) {\r\n        ret = string(1, src[idx++]);\r\n      }\r\n      return ret + getString();\r\n    }\r\n\r\n    string decodeString(string s) {\r\n      src = s, idx = 0;\r\n      return getString();\r\n    }\r\nprivate:\r\n    size_t idx;\r\n    string src;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841280780","body":"### 思路\r\n\r\n模拟即可。\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n### 代码\r\n```C++\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    stack<int> st, st2;\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n      while (!st2.empty()) {\r\n        st.push(st2.top());\r\n        st2.pop();\r\n      }\r\n      st.push(x);\r\n    }\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n      auto val = peek();\r\n      st2.pop();\r\n      return val;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n      while (!st.empty()) {\r\n        auto val = st.top();\r\n        st.pop();\r\n        st2.push(val);\r\n      }\r\n      return st2.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n      return st2.empty() && st.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841673299","body":"### 思路\r\n\r\n我是傻逼。\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n      vector<int> res = arr;\r\n      sort(res.begin(), res.end());\r\n      int ans = 0;\r\n      long long sum1 = 0, sum2 = 0;\r\n      for (int i = 0; i < arr.size(); i++) {\r\n        sum1 += res[i], sum2 += arr[i];\r\n        if (sum1 == sum2) ans++;\r\n      }\r\n      return ans;\r\n    }\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sumukeio":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836153578","body":"思路：由低位到高位将数字逐位相加\r\nwhile(A没完 ||B没完)\r\n     A的当前位\r\n     B的当前位\r\n\r\n    和 = A的当前位 + B的当前位 + 进位carry;\r\n\r\n当前位  = 和 % 10;\r\n进位 = 和/10;\r\n\r\n判断还有进位么？\r\n\r\n代码：\r\nint* addToArrayForm(int* A, int ASize, int K, int* returnSize)\r\n{\r\n     int len = fmax(ASize, 5) + 1;//防止越界\r\n     int *res = (int*)malloc(sizeof(int) * len);\r\n     int i = ASize - 1;\r\n     int idx = 0;\r\n//k不为0，数组数据未处理完，继续处理\r\nwhile(k !=0 || i>=0)\r\n{\r\n    k += ( i >= 0) ? A[ i--]  : 0;\r\n    res[ --len] = k % 10;\r\n    k /= 10;\r\n    idx++;\r\n}\r\n*returnSize = idx;\r\nreturn res + len;\r\n}\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838112294","body":"思路：第一次从左到右遍历到最左端最短的距离，第二次从右到左遍历到最右端最短的距离\r\n代码：\r\nint* shortestToChar(char* s, char c, int* returnSize){\r\nint len=strlens(s);\r\nint* a=(int*)malloc(sizeof(int)*len);\r\nint count=0;\r\nfor(int i=0;i<len;i++){\r\nif(s[i]==c){\r\na[count++]=0;\r\n}else{\r\nint left=10001,right=10001;\r\nfor(int j=i+1;j<len;j++){\r\nif(s[j]==c){\r\nright=j;\r\nbreak;\r\n}\r\n}\r\nfor(int x=i-1;x>=0;x--){\r\nif(s[x]==c){\r\nleft=x;\r\nbreak;\r\n}\r\n}\r\nright=fmin(abs(i-left),abs(i-right));\r\na[count++]=right;\r\n}\r\n}\r\n*returnSize=len;\r\nreturn a;\r\n}\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839684947","body":"代码：\r\ntypedef struct {\r\n    int key;\r\n    int value;\r\n    UT_hash_handle hh;\r\n} CustomStack;\r\n\r\nint g_size;\r\nint g_key = 0;\r\nCustomStack *g_hash = NULL;\r\n\r\nCustomStack* customStackCreate(int maxSize) {\r\n    g_size = maxSize;\r\n    return g_hash;\r\n}\r\n\r\nvoid customStackPush(CustomStack* obj, int x) {\r\n    int count = HASH_COUNT(g_hash);\r\n    if (count == g_size) {\r\n        return;\r\n    }\r\n    g_key++;\r\n    CustomStack *s = (CustomStack *)malloc(sizeof(CustomStack));\r\n    s->key = g_key;\r\n    s->value = x;\r\n    HASH_ADD_INT(g_hash, key, s);\r\n}\r\n\r\nint customStackPop(CustomStack* obj) {\r\n    int count = HASH_COUNT(g_hash);\r\n    int pos = 0;\r\n    if (count > 0) {\r\n        CustomStack *current, *tmp;\r\n        HASH_ITER(hh, g_hash, current, tmp) {\r\n            pos++;\r\n            if (pos == count) {\r\n                HASH_DEL(g_hash, current);\r\n                int value = current->value;\r\n                free(current);\r\n                return value;\r\n            }\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n\r\nvoid customStackIncrement(CustomStack* obj, int k, int val) {\r\n    CustomStack *current, *tmp;\r\n    int count = 0;\r\n    HASH_ITER(hh, g_hash, current, tmp) {\r\n        if (count == k) {\r\n            break;\r\n        }\r\n        current->value += val;\r\n        count++;\r\n    }\r\n}\r\n\r\nvoid customStackFree(CustomStack* obj) {\r\n    CustomStack *current, *tmp;\r\n    HASH_ITER(hh, g_hash, current, tmp) {\r\n        HASH_DEL(g_hash, current);\r\n        free(current);\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack struct will be instantiated and called as such:\r\n * CustomStack* obj = customStackCreate(maxSize);\r\n * customStackPush(obj, x);\r\n \r\n * int param_2 = customStackPop(obj);\r\n \r\n * customStackIncrement(obj, k, val);\r\n \r\n * customStackFree(obj);\r\n*/"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841615362","body":"int maxChunksToSorted(int* arr, int arrSize){\r\n    int stack[2000]={0};\r\n    int index=1;\r\n    stack[1]=arr[0];\r\n    int tmp=0;\r\n    for(int i=1;i<arrSize;i++){\r\n        if(stack[index]<=arr[i]){\r\n            index+=1;\r\n            stack[index]=arr[i];\r\n        }\r\n        else{\r\n                tmp=stack[index];\r\n                while(arr[i]<stack[index]){\r\n                    index--;\r\n                }\r\n                index+=1;\r\n                stack[index]=tmp;\r\n        }\r\n    }\r\n    return index;\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Mvbbb":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836163931","body":"# 思路\r\n\r\n按照竖式的个位加法来相加\r\n\r\n\r\n# 代码\r\n\r\n```java\r\nclass Solution{\r\n    public List<Integer> addToArrayForm(int[] num,int k){\r\n        int len = num.length;\r\n        int lastNum = k;\r\n        int i = len-1;\r\n        LinkedList<Integer> list = new LinkedList<>();\r\n        while(i>=0||lastNum>0){  // 循环条件: 没有遍历完num或者lastNum中的数还没有全部插入到 list 中\r\n            if(i>=0){ \r\n                lastNum+=num[i]; // 加上一个个位数\r\n            }\r\n            list.addFirst(lastNum%10); // 每一次循环都需要从 lastNum 末尾取一个数放到 list 中\r\n            lastNum/=10;\r\n            i--;\r\n        }\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度\r\n\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838027915","body":"**刚开始的思路：**\r\n\r\n遍历一遍数组， 找到 c 的位置的集合。\r\n在遍历一次数组，如果当前元素不是 c，就计算出当前元素下标到哪个c下标最近。\r\n\r\n时间复杂度 O(Nk) 。k 是 c 出现的次数\r\n\r\n**看了题解之后的思路：**\r\n\r\n\r\n离一个字符最近的 c 要不然是它右边最近的一个 c，要不然在它左边最近的一个 c\r\n\r\n遍历两次字符串\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] left = new int[s.length()]; \r\n        int[] right = new int[s.length()];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        int behind = Integer.MAX_VALUE/2;\r\n        for(int i=0,j=s.length()-1;i<s.length();i++,j--){\r\n            if(s.charAt(i)==c){\r\n                prev = i;\r\n                left[i]=0;\r\n            }else{\r\n                left[i]=i-prev;\r\n            }\r\n            if(s.charAt(j)==c){\r\n                behind = j;\r\n                right[j]=0;\r\n            }else{\r\n                right[j]=behind-j;\r\n            }            \r\n        }\r\n\r\n        for(int i=0;i<left.length;i++){\r\n            left[i]= Math.min(left[i],right[i]);\r\n        }\r\n        return left;\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度 O(N）\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839806624","body":"```java\r\nclass CustomStack {\r\n\r\n    int[] arr ;\r\n    int maxSize ;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.arr = new int[maxSize+1];\r\n        this.maxSize=maxSize;\r\n        this.top = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top==maxSize){\r\n            return;\r\n        }\r\n        this.arr[top++]=x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top==0){\r\n            return -1;\r\n        }\r\n        return this.arr[--top];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        k = k>top?top:k;\r\n        for(int i=0;i<k;i++){\r\n            this.arr[i]+=val;\r\n        }\r\n    }\r\n}\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840266496","body":"```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n    \tDeque<Integer> numStack = new ArrayDeque<>();\r\n    \tDeque<String> strStack = new ArrayDeque<>();\r\n    \t\r\n    \tStringBuilder tail = new StringBuilder();\r\n\r\n        int n = s.length();\r\n        for(int i=0;i<n;i++){\r\n            char c = s.charAt(i);\r\n            if(Character.isDigit(c)){\r\n            \t// 将数字放入到操作数栈中\r\n                int num = c-'0';\r\n                while(i+1<n&&Character.isDigit(s.charAt(i+1))){\r\n                    num = num*10+s.charAt(i+1)-'0';\r\n                    i++;\r\n                }\r\n                numStack.push(num);\r\n            }\r\n            else if(c=='['){\r\n            \t// 将处于 ] 和 [ 之间的字符串放进 strStack 中\r\n                strStack.push(tail.toString());\r\n                tail = new StringBuilder();\r\n            }\r\n            else if(c==']'){\r\n            \t// 从 strStack 中取出字符串, numStack 中取出重复次数\r\n                StringBuilder tmp = new StringBuilder(strStack.pop());\r\n                int repeatedTimes = numStack.pop();\r\n                for(int j=0;j<repeatedTimes;j++){\r\n                    tmp.append(tail);\r\n                }\r\n                tail = tmp;\r\n            }\r\n            else{\r\n            \t// 当前 c 一定还没有被 [] 包围\r\n                tail.append(c);\r\n            }\r\n            \r\n        }\r\n        return tail.toString();\r\n    }\r\n}\r\n\r\n```\r\n时间复杂度 和 空间复杂度都是 O(S). S 是字符串解码之后的长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841282924","body":"# 双栈实现\r\n- 一个 in 栈\r\n-  一个 out 栈\r\n\r\n入栈负责接收 push 的数\r\n\r\npop 的时候先检查 out 栈是否为空,如果为空,就将 in 栈中的数转移到 out 栈。之后将 out 栈顶弹出\r\n\r\npush 的时候直接将数放到 in 栈\r\n\r\n# 代码\r\n\r\n```java\r\nclass MyQueue{\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n    public MyQueue(){\r\n        inStack = new LinkedList<Integer>();\r\n        outStack = new LinkedList<Integer>();\r\n    }\r\n\r\n    public void push(int x){\r\n        inStack.push(x);\r\n    }\r\n\r\n    public int pop(){\r\n        if(outStack.isEmpty()){\r\n            in2out();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n\r\n    public int peek(){\r\n        if(outStack.isEmpty()){\r\n            in2out();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n    public boolean empty(){\r\n        return inStack.isEmpty()&&outStack.isEmpty();\r\n    }\r\n\r\n    private void in2out(){\r\n        while(!inStack.isEmpty()){\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度\r\n\r\n对于每个元素，至多在 inStack 和 outStack 之间被操作两次。时间复杂度为 O(1)\r\n\r\n空间复杂度 O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841666158","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] stack = new int[2010];\r\n        int top = 0;\r\n        for(int i=0;i<arr.length;i++){                   \r\n        \t\r\n\r\n        \tif(top==0||arr[i]>=stack[top-1]) {\r\n        \t\tstack[top++]=arr[i];\r\n        \t}else {\r\n        \t\tint topx= stack[--top];\r\n        \t\twhile(top!=0&&arr[i]<stack[top-1]) {\r\n        \t\t\ttop--;\r\n        \t\t}\r\n        \t\tstack[top++]=topx;\r\n        \t}\r\n        }\r\n        return top;\r\n    }\r\n}\r\n```\r\n# 时间复杂度\r\n\r\n每个元素最多只会入栈出栈各一次, 时间复杂度是 O(n)\r\n空间复杂度 O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thisisandy":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836172220","body":"# 思路\r\n各位依次相加\r\n\r\n# 代码\r\n```typescript\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    const num2 = []\r\n    const result = []\r\n    let diff = k\r\n    while(diff){\r\n        const unit = diff%10\r\n        num2.unshift(unit)\r\n        diff = Math.floor(diff/10)\r\n    }\r\n    let a;\r\n    let b;\r\n    let bonus = 0;\r\n    while(bonus || num.length || num2.length){\r\n        a = num.pop() || 0 \r\n        b = num2.pop() || 0\r\n        const sum = a + b + bonus\r\n        const unit = (sum) % 10\r\n        bonus = Math.floor((sum)/10)\r\n        result.unshift(unit)\r\n    }\r\n    return result\r\n};\r\n```\r\n# 复杂度\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837700548","body":"```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    let lastPosition = - Infinity;\r\n    const result = []\r\n    for(let i =0; i< s.length; i++){\r\n        if(s[i] === c){\r\n            lastPosition = i\r\n        }\r\n        result[i] = i - lastPosition\r\n    }\r\n    for(let i =s.length-1; i>=0; i--){\r\n        if(s[i] === c){\r\n            lastPosition = i\r\n        }\r\n        result[i] = Math.min(Math.abs(i-lastPosition),result[i])\r\n    }\r\n    return result\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837700548","body":"```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    let lastPosition = - Infinity;\r\n    const result = []\r\n    for(let i =0; i< s.length; i++){\r\n        if(s[i] === c){\r\n            lastPosition = i\r\n        }\r\n        result[i] = i - lastPosition\r\n    }\r\n    for(let i =s.length-1; i>=0; i--){\r\n        if(s[i] === c){\r\n            lastPosition = i\r\n        }\r\n        result[i] = Math.min(Math.abs(i-lastPosition),result[i])\r\n    }\r\n    return result\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840478234","body":"```typescript\r\nfunction decodeString(s: string): string {\r\n    const stack = []\r\n    for(let i =0;i<s.length; i++){\r\n        if(/[[\\d\\w]/.test(s[i])){\r\n            stack.push(s[i])\r\n        }\r\n        if(/\\]/.test(s[i])){\r\n            let str = ''\r\n            for(let j = stack.length-1; j>=0; j--){\r\n                const char = stack.pop()\r\n                if(char!=='['){\r\n                    str = char + str\r\n                }else{\r\n                    break;\r\n                }\r\n            }\r\n            let rep = ''\r\n            for(let j = stack.length-1; j>=0; j--){\r\n                const char = stack.pop()\r\n                if(!/\\d/.test(char)){\r\n                    stack.push(char)\r\n                    break;\r\n                }else{\r\n                    rep = char +rep\r\n                }\r\n            }\r\n            stack.push(str.repeat(Number(rep)))\r\n        }\r\n    }\r\n    return stack.join('')\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841234171","body":"```typescript\r\nclass MyQueue {\r\n    private arr1 = []\r\n    private arr2 = []\r\n\r\n    push(x: number): void {\r\n        this.arr1.push(x)\r\n    }\r\n\r\n    pop(): number {\r\n        while(this.arr1.length!==1){\r\n            this.arr2.push(this.arr1.pop())\r\n        }\r\n        const value = this.arr1.pop()\r\n        while(this.arr2.length){\r\n            this.arr1.push(this.arr2.pop())\r\n        }\r\n        return value\r\n    }\r\n\r\n    peek(): number {\r\n        while(this.arr1.length!==1){\r\n            this.arr2.push(this.arr1.pop())\r\n        }\r\n        const value = this.arr1.pop()\r\n        this.arr2.push(value)\r\n        while(this.arr2.length){\r\n            this.arr1.push(this.arr2.pop())\r\n        }\r\n        return value\r\n    }\r\n\r\n    empty(): boolean {\r\n        return !this.arr1.length\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzqnb":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836191824","body":"语言： java\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n\tint i = len - 1, sum = 0, carry = 0, res = 0;\r\n\tList<Integer> list = new ArrayList<>();\r\n\twhile (i >= 0 || k != 0) {\r\n\t\tsum = (i >= 0 ? num[i] : 0) + (k != 0 ? k % 10 : 0) + carry;\r\n\t\tcarry = sum / 10;\r\n\t\tres = sum % 10;\r\n\t\tlist.add(res);\r\n\t\tk /= 10;\r\n\t\ti--;\r\n\t}\r\n        if (carry!=0) list.add(carry);\r\n\tCollections.reverse(list);\r\n\treturn list;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837839988","body":"左右两次遍历，参考了官方的解题方法加入了自己的思路\r\n\r\n**java**\r\n```\r\nclass Solution {\r\n\tpublic int[] shortestToChar(String s, char c) {\r\n\t\tint len = s.length(), prev = s.indexOf(c);\r\n\t\tint[] res = new int[len];\r\n\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\tif (s.charAt(i) == c) prev = i;\r\n\t\t\tint tmp = i - prev;\r\n\t\t\tres[i] = tmp >= 0 ? tmp : -tmp;\r\n\t\t}\r\n\t\tprev = s.lastIndexOf(c);\r\n\t\tfor (int i = len - 1; i >= 0; i--) {\r\n\t\t\tif (s.charAt(i) == c) prev = i;\r\n\t\t\tint tmp = i - prev;\r\n\t\t\ttmp = tmp >= 0 ? tmp : -tmp;\r\n\t\t\tres[i] = tmp >= res[i] ? res[i] : tmp;\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839432610","body":"数组模拟栈\r\n```java\r\nclass CustomStack {\r\n\r\n        int[] satck;\r\n        int top;\r\n\r\n\tpublic CustomStack(int maxSize) {\r\n\t\tsatck = new int[maxSize];\r\n\t\ttop = -1;\r\n\t}\r\n\r\n\tpublic void push(int x) {\r\n\t\tif (top != satck.length - 1) {\r\n\t\t\ttop++;\r\n\t\t\tsatck[top] = x;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic int pop() {\r\n\t\tif (top == -1) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\ttop--;\r\n\t\treturn satck[top + 1];\r\n\t}\r\n\r\n\tpublic void increment(int k, int val) {\r\n\t\tint limit = k > (top + 1) ? (top + 1) : k;\r\n\t\tfor (int i = 0; i < limit; i++) {\r\n\t\t\tsatck[i] += val;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841004308","body":"```java\r\nclass MyQueue {\r\n\r\n    Deque<Integer> inStack;\r\n\tDeque<Integer> outStack;\r\n\r\n\tpublic MyQueue() {\r\n\t\tinStack = new LinkedList<Integer>();\r\n\t\toutStack = new LinkedList<Integer>();\r\n\t}\r\n\r\n\tpublic void push(int x) {\r\n\t\tinStack.push(x);\r\n\t}\r\n\r\n\tpublic int pop() {\r\n\t\tif (outStack.isEmpty()) {\r\n\t\t\tin2out();\r\n\t\t}\r\n\t\treturn outStack.pop();\r\n\t}\r\n\r\n\tpublic int peek() {\r\n\t\tif (outStack.isEmpty()) {\r\n\t\t\tin2out();\r\n\t\t}\r\n\t\treturn outStack.peek();\r\n\t}\r\n\r\n\tpublic boolean empty() {\r\n\t\treturn inStack.isEmpty() && outStack.isEmpty();\r\n\t}\r\n\r\n\tprivate void in2out() {\r\n\t\twhile (!inStack.isEmpty()) {\r\n\t\t\toutStack.push(inStack.pop());\r\n\t\t}\r\n\t}\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841631470","body":"找不到思路，参考题解\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int tmp = arr[0],len = arr.length,count = 1;\r\n\t\tfor (int i = 1; i < len; i++) {\r\n\t\t\tif (tmp < arr[i]) {\r\n\t\t\t\tcount++;\r\n\t\t\t\ttmp = arr[i];\r\n\t\t\t}\r\n\t\t\tif (i == len - 1 && tmp == arr[len - 1]) {\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count;\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengyi666":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836198313","body":"**思路：**\r\n• 判断长度\r\n• 考虑进位\r\n• 考虑越位开辟新空间\r\n• 正序输入，倒序输出\r\n### \r\n**力扣python打卡**\r\n\r\n\r\n```\r\n#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\nvoid  addToArrayForm(int* A, int ASize, int K)\r\n{\r\n\t//计算K的位数\r\n\tint len = 0;\r\n\tint tmp = K;\r\n\twhile (tmp)\r\n\t{\r\n\t\tlen++;\r\n\t\ttmp /= 10;\r\n\t}\r\n\t//开辟空间，注意最高位可能存在进位的情况\r\n\tint arrLen = ASize > len ? ASize + 1 : len + 1;\r\n\tint* arr = (int*)malloc(sizeof(int) * arrLen);\r\n\t//逐位相加\r\n\tint index = 0;\r\n\tint end = ASize - 1;\r\n\tint step = 0;\r\n\twhile (end >= 0 || K > 0)\r\n\t{\r\n\t\tint cursum = step;\r\n\t\tif (end >= 0)\r\n\t\t{\r\n\t\t\tcursum += A[end];\r\n\t\t}\r\n\t\tif (K > 0)\r\n\t\t{\r\n\t\t\tcursum += (K % 10);\r\n\t\t}\r\n\t\t//如果位数的值超过9需要进位\r\n\t\tif (cursum > 9)\r\n\t\t{\r\n\t\t\tstep = 1;\r\n\t\t\tcursum -= 10;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tstep = 0;\r\n\t\t}\r\n\t\tarr[index++] = cursum;\r\n\t\tend--;\r\n\t\tK /= 10;\r\n\t}\r\n\t//判断最高位是否存在进位\r\n\tif (step == 1)\r\n\t{\r\n\t\tarr[index++] = step;\r\n\t}\r\n\t//为了方便对数组进行尾插，所以数据是逆序存储，故要对数组进行逆序操作。\r\n\tint start = 0;\r\n\tend = index - 1;\r\n\twhile (start < end)\r\n\t{\r\n\t\tint tmp = arr[start];\r\n\t\tarr[start] = arr[end];\r\n\t\tarr[end] = tmp;\r\n\t\tstart++;\r\n\t\tend--;\r\n\t}\r\n\tfor (int i = 0; i < index; ++i)\r\n\t\tprintf(\"%d \", *(arr + i));\r\n}\r\n//主函数\r\nint main() {\r\n\t\tint a[10] = {};\r\n\t\tint Asize, k;\r\n\t\tprintf(\"想输入几位数组？：\\n\");\r\n\t\tscanf_s(\"%d\", &Asize);\r\n\t\tprintf(\"请输入数组：\\n\");\r\n\t\tfor (int i = 0; i < Asize; i++) {\r\n\t\t\tscanf_s(\"%d\", &a[i]);\r\n\t\t}\r\n\t\tprintf(\"请输入0~10000的整数：\\n\");\r\n\t\tscanf_s(\"%d\", &k);\r\n\taddToArrayForm(a, Asize, k);\r\n\treturn 0;\r\n}\r\n//分为1.判断位数2.逐位相加3.进位4.越位5.逆序\r\n```\r\n**复杂度**\r\n\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837733723","body":"**思路**\r\n1.获取目标在s中的下标\r\n2.从头开始，比较相邻2个的目标\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        location = []\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                location.append(i) # 获取目标在s中的下标\r\n        k = 0\r\n        whole = len(location)-1\r\n        res = []\r\n        for i in range(len(s)):\r\n            if k!=whole and abs(i-location[k])>abs(i-location[k+1]):\r\n                k += 1\r\n            res.append(abs(i-location[k]))\r\n        return res\r\n```\r\n**复杂度分析**\r\n\r\n- 时间:O(n)\r\n\r\n- 空间:O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839442207","body":"**思路：**\r\n我只管pop出的结果\r\n放弃空间要时间\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n        self.assist = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack)<self.maxSize:\r\n            self.stack.append(x)\r\n            self.assist.append(0) # 辅助栈\r\n\r\n    def pop(self) -> int:\r\n        if len(self.assist)>0:\r\n            temp = self.assist.pop()\r\n            res = self.stack.pop() + temp\r\n            if self.assist:\r\n                self.assist[-1] += temp\r\n            return res\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k>len(self.stack):\r\n            k = len(self.stack)\r\n        if k > 0:\r\n            self.assist[k-1] += val \r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840512151","body":"**思路**\r\n栈\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = [] # 定义空栈\r\n        res = ''\r\n        num = 0\r\n        for c in s:\r\n            if c == \"[\":\r\n                stack.append([num,res])\r\n                res = ''\r\n                num = 0\r\n            elif c == \"]\":\r\n                last_num,last_res = stack.pop()\r\n                res = last_res + last_num * res\r\n            elif c.isdigit():\r\n                num = num * 10 + int(c)\r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n复杂度\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840911309","body":"**思路**\r\n申请一个辅助栈\r\n```\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self. accpectstack = []\r\n        self. outputstack = []\r\n\r\n    def push(self, a: int):  #将一个元素放入队列的尾部。\r\n        self.accpectstack.append(a)\r\n\r\n    def pop(self) -> int:  #从队列首部移除元素。\r\n        while len(self.accpectstack) > 1:\r\n            self.outputstack.append(self.accpectstack.pop())\r\n        res = self.accpectstack.pop()\r\n        while len(self.outputstack) > 0:\r\n            self.accpectstack.append(self.outputstack.pop())\r\n        return res\r\n\r\n    def peek(self) -> int:  #返回队列首部的元素。\r\n        return self.accpectstack[0]\r\n\r\n    def empty(self) -> bool:  #返回队列是否为空。\r\n        return len(self.accpectstack) == 0\r\n```\r\n**复杂度**\r\n\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nanwy":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836213176","body":"思路\r\n1.各位相加，如果进位，将k加1，把相加后的数对10取余放入数组，最后反转数组\r\n\r\n代码（js）\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [],carry=0;\r\n    for(let i=num.length-1;i>=0;i--){\r\n        let sum = num[i] + k % 10\r\n        k = k / 10 | 0\r\n        if(sum > 9){\r\n            k++\r\n        }\r\n        res.push(sum % 10)\r\n    }\r\n    while(k != 0){\r\n        res.push(k % 10)\r\n        k = k / 10 | 0\r\n    }\r\n    return res.reverse()\r\n};\r\n```\r\n        \r\n复杂度\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837737014","body":"## 思路：先进行遍历，碰到c后，派出两个指针分别向左向右，取最小值。\r\n```js\r\nvar shortestToChar = function (s, c) {\r\n        let i = 0,res = Array(s.length).fill(Infinity);\r\n        while (i < s.length) {\r\n                if (s[i] !== c) {\r\n                        let l = i - 1,\r\n                                r = i + 1;\r\n                        while (s[l] != c && l > 0) {\r\n                                l--;\r\n                        }\r\n                        while (s[r] != c && r < s.length - 1) {\r\n                                r++;\r\n                        }\r\n                        let left = s[l] == c ? i - l : Infinity;\r\n                        let right = s[r] == c ? r - i : Infinity;\r\n                        let ans = Math.min(left, right);\r\n                        // console.log(ans)\r\n                        res[i] = ans;\r\n                } else {\r\n                        res[i] = 0;\r\n                }\r\n                i++;\r\n        }\r\n        // console.log(res)\r\n        return res;\r\n};\r\n```\r\n## 复杂度分析\r\n\r\n- 时间：O(n^2)\r\n- 空间：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839790812","body":"思路：\r\n用数组模拟栈的推入弹出\r\n代码：\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.stack = []\r\n    this.max = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.stack.length == this.max){\r\n        return \r\n    }\r\n    this.stack.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(!this.stack.length){\r\n        return -1\r\n    }\r\n    return this.stack.pop()\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(let i=0;i<k && i<this.stack.length;i++){\r\n        this.stack[i] += val\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840426835","body":"思路：\r\n用两个栈分别存入重复的次数和被重复的字符串，遍历数组遇到'['将数字和字符串压入栈，遇到']'将两个栈分别弹出，并赋值给新的str。\r\n```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let numStack = [], strStack = [],str = '', num=0\r\n    for(let i=0;i<s.length;i++){\r\n        if(/[0-9]/.test(s[i])){\r\n            // numStack.push(s[i])\r\n            num = num * 10 + +s[i]\r\n        }else if(s[i] == '['){\r\n            strStack.push(str)\r\n            str = ''\r\n            numStack.push(num)\r\n            num = 0\r\n        }else if(s[i] == ']'){\r\n            let newStr = str.repeat(numStack.pop())\r\n            // strStack.push(newStr)\r\n            // console.log(newStr)\r\n            str = strStack.pop() +  newStr\r\n        }else{\r\n            str += s[i]\r\n        }\r\n    }\r\n    // console.log(strStack,numStack,str)\r\n    return str\r\n};\r\n```\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(2n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841086194","body":"思路：使用两个栈，用栈的先进后出特性，颠倒一下就是队列的先进先出了\r\n代码：\r\n```js\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\nthis.stack1 = []\r\nthis.stack2 = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack1.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if(this.stack2.length)return this.stack2.pop()\r\n    while(this.stack1.length){\r\n        this.stack2.push(this.stack1.pop())\r\n    }\r\n    return this.stack2.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if(this.stack2.length)return this.stack2[this.stack2.length-1]\r\n    while(this.stack1.length){\r\n        this.stack2.push(this.stack1.pop())\r\n    }\r\n    return this.stack2[this.stack2.length-1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n      while(this.stack1.length){\r\n        this.stack2.push(this.stack1.pop())\r\n    }\r\n    return !this.stack2.length\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(2n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"surahe":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836217045","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  将k 转换为数组 k_arr\r\n-  比较 k_arr 和 num 长度，将其中较长的一个的长度+1，定义为 max_length\r\n-  创建数组digit，长度为max_length，用来存储进位\r\n-  将 k_arr 和 num 长度补长到与 max_length相同\r\n-  从低位开始逐位计算，超过10则在digit 对应位置进1\r\n-  如果最高为是0，去除\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\nvar addToArrayForm = function (num, k) {\r\n  var result = []\r\n  var k_arr = k.toString().split('')\r\n  var max_length = num.length > k_arr.length ? num.length + 1 : k_arr.length + 1\r\n  var digit = Array(max_length).fill(0)\r\n  var now_res\r\n\r\n  for (var i = num.length; i < max_length; i++) {\r\n    num.unshift(0)\r\n  }\r\n  for (var i = k_arr.length; i < max_length; i++) {\r\n    k_arr.unshift(0)\r\n  }\r\n\r\n  for (var i = max_length - 1; i >= 0; i--) {\r\n    if (digit[i] + num[i] + +k_arr[i] >= 10) {\r\n      digit[i-1] = 1\r\n      now_res = digit[i] + num[i] + +k_arr[i] - 10\r\n    } else {\r\n      now_res = digit[i] + num[i] + +k_arr[i]\r\n    }\r\n    result.unshift(now_res)\r\n  }\r\n\r\n  if (result[0] === 0) {\r\n    result.shift()\r\n  } \r\n\r\n  return result\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(Max(num, k)+1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837820712","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  用两个数组分别存储从左遍历向左比较（→）和从左遍历向右比较（←）的情况\r\n-  对于向右查找，如果数组长度不够，需要补99999\r\n- 对于向左查找，情况更复杂点。没遇到 c前都需要补99999，只要遇到一次以后就不需要再补99999。如果遍历结束，right 长度还不够，需要把k 遍历 push 进right\r\n- 比较 left、right 各项大小，取较小的\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  var length = s.length\r\n\r\n  var left = []\r\n  var i = 0\r\n  var j = 0\r\n\r\n  var right = []\r\n  var k = 0\r\n  var l = 0\r\n\r\n  while (i < length) {\r\n    if (s[i]!== c) {\r\n      j++\r\n    } else {\r\n      for (var index = j; index >= 0; index--) {\r\n        left.push(index)\r\n        j = 0\r\n      }\r\n    }\r\n    i++\r\n  }\r\n  for (var t1 = left.length; t1 < length; t1++) {\r\n    left.push(99999)\r\n  }\r\n\r\n  let flag = true\r\n  while (k < length) {\r\n    if (s[k] !== c) {\r\n      if (flag) {\r\n        right.push(99999)\r\n      } else {\r\n        l++\r\n      }\r\n    } else {\r\n      flag = false\r\n      for (var index = 1; index <= l; index++) {\r\n        right.push(index)\r\n      }\r\n      right.push(0)\r\n      l = 0\r\n    }\r\n    k++\r\n    if (k === length && l !== 0) {\r\n      for (var index = 1; index <= l; index++) {\r\n        right.push(index)\r\n      }\r\n    }\r\n  }\r\n\r\n  for (var i = 0; i < length ; i++) {\r\n    if (right[i] < left[i]) {\r\n      left[i] = right[i]\r\n    }\r\n  }\r\n  return left\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837820712","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  用两个数组分别存储从左遍历向左比较（→）和从左遍历向右比较（←）的情况\r\n-  对于向右查找，如果数组长度不够，需要补99999\r\n- 对于向左查找，情况更复杂点。没遇到 c前都需要补99999，只要遇到一次以后就不需要再补99999。如果遍历结束，right 长度还不够，需要把k 遍历 push 进right\r\n- 比较 left、right 各项大小，取较小的\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  var length = s.length\r\n\r\n  var left = []\r\n  var i = 0\r\n  var j = 0\r\n\r\n  var right = []\r\n  var k = 0\r\n  var l = 0\r\n\r\n  while (i < length) {\r\n    if (s[i]!== c) {\r\n      j++\r\n    } else {\r\n      for (var index = j; index >= 0; index--) {\r\n        left.push(index)\r\n        j = 0\r\n      }\r\n    }\r\n    i++\r\n  }\r\n  for (var t1 = left.length; t1 < length; t1++) {\r\n    left.push(99999)\r\n  }\r\n\r\n  let flag = true\r\n  while (k < length) {\r\n    if (s[k] !== c) {\r\n      if (flag) {\r\n        right.push(99999)\r\n      } else {\r\n        l++\r\n      }\r\n    } else {\r\n      flag = false\r\n      for (var index = 1; index <= l; index++) {\r\n        right.push(index)\r\n      }\r\n      right.push(0)\r\n      l = 0\r\n    }\r\n    k++\r\n    if (k === length && l !== 0) {\r\n      for (var index = 1; index <= l; index++) {\r\n        right.push(index)\r\n      }\r\n    }\r\n  }\r\n\r\n  for (var i = 0; i < length ; i++) {\r\n    if (right[i] < left[i]) {\r\n      left[i] = right[i]\r\n    }\r\n  }\r\n  return left\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840658514","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  用栈分别存储重复次数、字符串内容\r\n- 记录左括号、右括号匹配次数\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s) {\r\n  var state\r\n  var multi = 1\r\n  var left = 0\r\n  var right = 0\r\n\r\n  var str = ''\r\n  var strStack = []\r\n\r\n  var repeatStack = []\r\n\r\n  var a2z = /[a-z]/\r\n  var one2nine = /[1-9]/\r\n  for (var i = 0; i < s.length; i++) {\r\n    if (a2z.test(s[i])) {\r\n      if (i === 0 || s[i - 1] === ']') {\r\n        repeatStack.push(1)\r\n      }\r\n      str += s[i]\r\n      if (i == s.length -1 && str) {\r\n        strStack.push(str)\r\n      }\r\n    }\r\n    if (one2nine.test(Number(s[i]))) {\r\n      multi = multi * Number(s[i])\r\n      if (state === 'on') {\r\n        repeatStack.push(multi)\r\n      } else {\r\n        repeatStack.push(Number(s[i]))\r\n      }\r\n      if ( str) {\r\n        strStack.push(str)\r\n        str = ''\r\n      }\r\n    }\r\n    if (s[i] === '[') {\r\n      if (state === 'on' && str) {\r\n        strStack.push(str)\r\n        str = ''\r\n      }\r\n      left ++\r\n      state = 'on'\r\n    }\r\n    if (s[i] === ']' && str) {\r\n      strStack.push(str)\r\n      str = ''\r\n      right ++\r\n      state = 'off'\r\n      if (left === right) {\r\n        multi = 1\r\n      }\r\n    }\r\n  }\r\n  var result = ''\r\n  for (var i = 0; i < repeatStack.length; i ++) {\r\n    for(var j = 0; j < repeatStack[j]; j++) {\r\n      result+=strStack[j]\r\n    }\r\n  }\r\n  return result\r\n};\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为字符串长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841244636","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  构建2个栈 a，b\r\n- push操作将所有元素放到a\r\n- 每次pop操作时，a将所有元素pop，然后push到b。将b的元素pop出来，再将b的其他所有元素pop，并push到a。\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function () {\r\n  this.mainStack = []\r\n  this.subStack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n  return this.mainStack.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n  while (this.mainStack.length) {\r\n    this.subStack.push(this.mainStack.pop())\r\n  }\r\n\r\n  let top = this.subStack.pop()\r\n  while (this.subStack.length) {\r\n    this.mainStack.push(this.subStack.pop())\r\n  }\r\n  return top\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n  while (this.mainStack.length) {\r\n    this.subStack.push(this.mainStack.pop())\r\n  }\r\n\r\n  let top = this.subStack.pop()\r\n  this.subStack.push(top)\r\n  while (this.subStack.length) {\r\n    this.mainStack.push(this.subStack.pop())\r\n  }\r\n  return top\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n  return !this.mainStack.length && !this.subStack.length\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\nvar myQueue = new MyQueue();\r\nmyQueue.push(1); // queue is: [1]\r\n\r\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\n\r\nconsole.log(myQueue.peek())\r\n// return 1\r\n\r\nconsole.log(myQueue.pop() )\r\n// return 1, queue is [2]\r\n\r\nmyQueue.empty(); // return false\r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841665051","body":"\r\n## 思路\r\n\r\n## 关键点\r\n\r\n- 参考suukii题解\r\n-  若数组拆分结果符合升序数组要求，则其前n项和与升序数组的前n项和是相同的\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n  var sortArr = [...arr]\r\n  var sumA = 0\r\n  var sumB = 0\r\n  var result = 0\r\n  sortArr = sortArr.sort((a, b) => a-b)\r\n  \r\n  for (var i = 0; i < arr.length; i++) {\r\n    sumA += arr[i]\r\n    sumB += sortArr[i]\r\n\r\n    if (sumA === sumB) {\r\n      result++\r\n    }\r\n  }\r\n  return result\r\n};\r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：需要进行一次排序和遍历数组arr一次，$O(n)$\r\n- 空间复杂度：需要创建一个和arr等长的数组，$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Serrust":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836227745","body":"```import java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\n/*\r\n * @lc app=leetcode id=989 lang=java\r\n *\r\n * [989] Add to Array-Form of Integer\r\n */\r\n\r\n// @lc code=start\r\nclass Solution {\r\n    /**\r\n     * Explanation:\r\n     * create an arraylist to store the answer.\r\n     * loop starting from the last element of input,\r\n     * here i use an example:\r\n     * for 123 + 912, where 123 is the integer represented by A and 912 is K\r\n     * we start with [1, 2, 3+912]. \r\n     * Then we perform the addition 3+912, leaving 915. \r\n     * The 5 stays as the digit, while we 'carry' 910 into the next column which becomes 91.\r\n     * We repeat this process with [1, 2+91, 5]. \r\n     * We have 93, where 3 stays and 90 is carried over as 9. \r\n     * Again, we have [1+9, 3, 5] which transforms into [1, 0, 3, 5].\r\n     * Complexity Analysis:\r\n     * Todo: why?\r\n     * Time: O(max(N, log K)) where N is the length of A\r\n     * Space: O(max(N,log K))\r\n     * @param A\r\n     * @param K\r\n     * @return\r\n     */\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        \r\n        int N = A.length;\r\n        int temp = K;\r\n        List<Integer> ans = new ArrayList<>();\r\n        \r\n        int i = N-1;\r\n        // Note: we are not sure if the integer that A represents is larger or k is larger\r\n        while (i >= 0 || temp > 0) {\r\n            // Note: we add this if condition because i can be negative if K is larger than the integer represented by A\r\n            if (i >= 0) {\r\n                temp += A[i];\r\n            }\r\n            ans.add(temp % 10);\r\n            temp /= 10;\r\n            i -= 1;\r\n        }\r\n        Collections.reverse(ans);\r\n\r\n        return ans;\r\n    }\r\n}\r\n// @lc code=end```\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838668830","body":"```/*\r\n * @lc app=leetcode id=821 lang=java\r\n *\r\n * [821] Shortest Distance to a Character\r\n */\r\n\r\n// @lc code=start\r\nclass Solution {\r\n    /**\r\n     * Explanation:\r\n     * create an array to store the answers\r\n     * create int c_position and set it to a negative number\r\n     * iterate through the existing string by each character twice\r\n     * in the first loop, loop from the front\r\n     * in each iteration, the distance (from the left char c) = current position - c_position\r\n     * once char c is found, update c_position to the position of c\r\n     * then set c_position to a very large positive integer and start the second loop\r\n     * in the second loop, loop from the end\r\n     * in each iteration, the distance (from the right char c) = c_position - current position IF this distance is smaller than the distance we calculated in the first iteration\r\n     * return the array with the shortest distance\r\n     * \r\n     * Complexity Analysis:\r\n     * Time: O(n) since 2 iterations, each iteration length is n\r\n     * Space: O(n) since only an array with the length of input string is used\r\n     * \r\n     * @param S\r\n     * @param C\r\n     * @return\r\n     */\r\n    public int[] shortestToChar(String S, char C) {\r\n\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        \r\n        // NOTE: for this kind of problem, remember to use Interger.MIN_VALUE or Integer.MAX_VALUE to set min/max values\r\n        int cPosition = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < N; i++) {\r\n            if (S.charAt(i) == C) {\r\n                cPosition = i;\r\n            }\r\n            ans[i] = i - cPosition;\r\n        }\r\n\r\n        cPosition = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; i--) {\r\n            if (S.charAt(i) == C) {\r\n                cPosition = i;\r\n            }\r\n            // NOTE: cPosition is larger or equal to current index i\r\n            ans[i] = Math.min(ans[i], cPosition - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n// @lc code=end\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838668830","body":"```/*\r\n * @lc app=leetcode id=821 lang=java\r\n *\r\n * [821] Shortest Distance to a Character\r\n */\r\n\r\n// @lc code=start\r\nclass Solution {\r\n    /**\r\n     * Explanation:\r\n     * create an array to store the answers\r\n     * create int c_position and set it to a negative number\r\n     * iterate through the existing string by each character twice\r\n     * in the first loop, loop from the front\r\n     * in each iteration, the distance (from the left char c) = current position - c_position\r\n     * once char c is found, update c_position to the position of c\r\n     * then set c_position to a very large positive integer and start the second loop\r\n     * in the second loop, loop from the end\r\n     * in each iteration, the distance (from the right char c) = c_position - current position IF this distance is smaller than the distance we calculated in the first iteration\r\n     * return the array with the shortest distance\r\n     * \r\n     * Complexity Analysis:\r\n     * Time: O(n) since 2 iterations, each iteration length is n\r\n     * Space: O(n) since only an array with the length of input string is used\r\n     * \r\n     * @param S\r\n     * @param C\r\n     * @return\r\n     */\r\n    public int[] shortestToChar(String S, char C) {\r\n\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        \r\n        // NOTE: for this kind of problem, remember to use Interger.MIN_VALUE or Integer.MAX_VALUE to set min/max values\r\n        int cPosition = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < N; i++) {\r\n            if (S.charAt(i) == C) {\r\n                cPosition = i;\r\n            }\r\n            ans[i] = i - cPosition;\r\n        }\r\n\r\n        cPosition = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; i--) {\r\n            if (S.charAt(i) == C) {\r\n                cPosition = i;\r\n            }\r\n            // NOTE: cPosition is larger or equal to current index i\r\n            ans[i] = Math.min(ans[i], cPosition - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n// @lc code=end\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cicihou":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836239329","body":"思路：\r\n将 array -> str -> int, 相加之后重新转换成array[int]\r\n\r\n代码：\r\n\r\n> class Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        # method 1 list iteration\r\n        # return [int(j) for j in str(int(''.join([str(i) for i in num])) + k)]\r\n\r\n        # method 2, same as method 1, use for-loop explicitly to analyze the complexity\r\n        # as following, the time complexity is O(n)\r\n        # the space complexity is O(1)\r\n        res = []\r\n        for i in num:\r\n            res.append(str(i))\r\n        res = str(int(''.join(res)) + k)\r\n        res = [int(i) for i in res]\r\n        return res\r\n\r\n\r\n\r\n复杂度分析：\r\n\r\n令 n 为数组长度。\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n\r\n![Uploading image.png…]()\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837653863","body":"思路\r\n遍历数组，将数组中命中c的值设为0并获得命中的c的index_list，其他值设为无穷大。\r\n再次遍历数组，将其与命中c的list index 做比较，获取绝对值大小\r\n\r\nPython Code:\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str):\r\n        res = []\r\n        zero_point = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                res.append(0)\r\n                zero_point.append(i)\r\n            else:\r\n                res.append(float('inf'))\r\n        for i in range(len(res)):\r\n            for j in zero_point:\r\n                if i != j:\r\n                    res[i] = min(res[i], abs(i-j))\r\n        return res\r\n```\r\n\r\n复杂度分析\r\n\r\n令 n 为字符串长度。\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839413437","body":"思路\r\n通过建立一个数组，实现栈的功能。increment考虑长度。\r\n\r\n代码\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max_size = maxSize\r\n        self.item = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.item) < self.max_size:\r\n            self.item.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.item:\r\n            return self.item.pop()\r\n        return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        length = len(self.item)\r\n        for i in range(length):\r\n            # attention: it should be <, cannot equals to\r\n            # k is the volume starts from 1, while index start from 0\r\n            if i < min(k, length):\r\n                self.item[i] += val\r\n```\r\n\r\n复杂度分析\r\n时间复杂度：push为O(1)；pop为O(1)，python 中内置的pop last是O(1), increment为O(n))\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840217686","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        ''' stack method1 一个不太干净漂亮的栈\r\n         这里的时间复杂度 time complexity 最坏结果是 O(n^2)\r\n         '''\r\n        stack = []\r\n        for i in s:\r\n            if i == ']':\r\n                volume = ''\r\n                tmp = ''\r\n                while stack:\r\n                    val = stack.pop()\r\n                    if val == '[':\r\n                        while stack:\r\n                            a = stack.pop()\r\n                            if a.isdigit():\r\n                                volume = a + volume\r\n                            else:\r\n                                stack.append(a)\r\n                                break\r\n                        break\r\n                    tmp = val + tmp\r\n                stack.append(int(volume) * tmp)\r\n            else:\r\n                stack.append(i)\r\n        return ''.join(stack)\r\n\r\n        ''' method 2 to make it more elegant '''\r\n        # stack = []\r\n        # curNum = 0\r\n        # curString = ''\r\n        # for i in s:\r\n        #     if i == '[':\r\n        #         stack.append(curString)\r\n        #         stack.append(curNum)\r\n        #         curString = ''\r\n        #         curNum = 0\r\n        #     elif i == ']':\r\n        #         num = stack.pop()\r\n        #         prevString = stack.pop()\r\n        #         curString = prevString + curString * num\r\n        #     elif i.isdigit():\r\n        #         curNum = curNum * 10 + int(i)\r\n        #     else:\r\n        #         curString += i\r\n        # return curString\r\n```\r\n\r\n复杂度分析\r\n\r\n时间复杂度：方法1 O(N^2)，方法2 O(N)\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840925211","body":"```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.item = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.item.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.item.pop(0)\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.item[0]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.item) == 0\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n时间复杂度O(1)\r\n空间复杂度O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841587977","body":"代码\r\n```\r\n\r\n    def maxChunksToSorted(self, A):\r\n        res, s1, s2 = 0, 0, 0\r\n        for a, b in zip(A, sorted(A)):\r\n            s1 += a\r\n            s2 += b\r\n            res += s1 == s2\r\n        return res\r\n```\r\n\r\n时间复杂度 O(n^2): for 内部嵌套了一个 sorted\r\n空间复杂度 O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841750285","body":"思路：\r\n这题不太会，链表的内容待补课\r\n\r\n代码：\r\n```\r\nclass Solution(object):\r\ndef rotateRight(self, head, k):\r\n    \"\"\"\r\n    :type head: ListNode\r\n    :type k: int\r\n    :rtype: ListNode\r\n    \"\"\"\r\n    if not head:\r\n        return None\r\n    \r\n    if head.next == None:\r\n        return head\r\n        \r\n    pointer = head\r\n    length = 1\r\n    \r\n    while pointer.next:\r\n        pointer = pointer.next\r\n        length += 1\r\n    \r\n    rotateTimes = k%length\r\n    \r\n    if k == 0 or rotateTimes == 0:\r\n        return head\r\n    \r\n    fastPointer = head\r\n    slowPointer = head\r\n    \r\n    for a in range (rotateTimes):\r\n        fastPointer = fastPointer.next\r\n    \r\n    \r\n    while fastPointer.next:\r\n        slowPointer = slowPointer.next\r\n        fastPointer = fastPointer.next\r\n    \r\n    temp = slowPointer.next\r\n    \r\n    slowPointer.next = None\r\n    fastPointer.next = head\r\n    head = temp\r\n    \r\n    return head\r\n```\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"absent1353":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836244897","body":"### 思路：\r\n将list转成数值，求和之后，分别取余/取除数，然后倒序输出\r\n### 代码：\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = 0\r\n        for n in num:\r\n            res = res * 10 + n \r\n        res += k\r\n        result = []\r\n        while(res>=0):\r\n            num = res%10\r\n            res/=10\r\n            result.append(num)\r\n        return result[::-1]\r\n```\r\n### 复杂度\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838397776","body":"## 思路\r\n- 1.空间换时间\r\n 先将给定字符出现的位置保存在一个下标数组中，遍历整个数组，求整个数组的值到下标数组的最小距离绝对值\r\n- 2.双指针方法\r\n#### 方法1\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        num = []\r\n        n = len(s)\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                num.append(i)\r\n        result = []\r\n        for i in range(n):\r\n            result.append(min([abs(i-nu)for nu in num]))\r\n        return result\r\n```\r\n#### 方法2：\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(s):\r\n            if x == c: prev = i\r\n            ans.append(i - prev)\r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans\r\n```\r\n##复杂度分析\r\n- 1.空间换时间复杂度\r\n    时间复杂度为$O(N*K)$\r\n    空间复杂度为$O(N)$\r\n- 2.双指针方法\r\n    时间复杂度为 $O(n)$\r\n    空间复杂度为$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839788489","body":"### 思路\r\n使用数组模拟栈，定义变量top记录当前数组中元素的数量\r\n### 代码\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack=[0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top < len(self.stack)-1:\r\n            self.top += 1\r\n            self.stack[self.top] = x \r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stack[self.top+1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k,self.top+1)\r\n        for i in range(lim):\r\n            self.stack[i] += val\r\n```\r\n### 复杂度分析\r\n\r\n时间复杂度：pop函数、push函数为O(1), increment函数为O(k)\r\n空间复杂度：O（maxSize）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840641670","body":"### 思路\r\n构建辅助栈，从后向前遍历字符串s中每个字符，将非数字的字符入栈，后续栈需要反转\r\n### 代码\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack=[]\r\n        length = len(s)\r\n        i = length - 1\r\n        while i>=0:\r\n            if not s[i].isdigit():\r\n                stack.append(s[i])\r\n                i -= 1\r\n            else:\r\n                num = ''\r\n                while s[i].isdigit() and i>=0:\r\n                    num = s[i]+num\r\n                    i -= 1\r\n                sub = ''\r\n                while stack[-1]!=']':\r\n                    tmp = stack.pop()\r\n                    if tmp != '[':\r\n                        sub += tmp\r\n                stack.pop()\r\n                sub = int(num)*sub\r\n                stack.append(sub)\r\n        stack.reverse()\r\n        return ''.join(stack)\r\n```\r\n### 复杂度分析\r\n-- 时间复杂度：O(N)\r\n-- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841110585","body":"### 思路：\r\n两个栈，辅助栈主要是用于pop和peek时使用，保证pop和peek都是O(1)\r\n### 代码：\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.s1=[]\r\n        self.s2=[]\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.s1.append(x)\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.s2:\r\n            return self.s2.pop()\r\n        while self.s1:\r\n            self.s2.append(self.s1.pop())\r\n        return self.s2.pop()\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.s2:\r\n            return self.s2[-1]\r\n        while self.s1:\r\n            self.s2.append(self.s1.pop())\r\n        return self.s2[-1]\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.s1 and not self.s2\r\n\r\n```\r\n### 复杂度\r\n时间复杂度: O(N)\r\n空间复杂度: O(N）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841666681","body":"### 思路\r\n单调栈，注意，分成块前提是前一个块的最大值，小于后一个块的最小值\r\n维护一个单调栈，遇到大雨等于栈顶元素的数字压入栈，遇到小于栈顶元素数字后，首先是取出栈顶元素缓存，然后循环，如果栈不为空，且新的栈顶元素大于当前数字，移除栈顶元素(单调栈元素个数实际上是遍历到当前数字之前可以拆分成的块的个数)。\r\n### 代码 python\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if not stack or stack[-1] <= num:\r\n                stack.append(num)\r\n            else:\r\n                cur_max = stack.pop()\r\n                while stack and stack[-1]>num:\r\n                    stack.pop()\r\n                stack.append(cur_max)\r\n        return len(stack)\r\n```\r\n### 复杂度\r\n时间复杂度为 O(N)\r\n空间复杂度为O(N)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aouos":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836268613","body":"## 思路：\r\n从数组尾部取值与 K 相加\r\n\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n  const ans = [];\r\n  let len = num.length;\r\n\r\n  for (let i = len - 1; i >= 0 || k > 0; i--) {\r\n    if (i >= 0) {\r\n      k += num[i];\r\n    }\r\n    ans.push(k % 10);\r\n    k = parseInt(k / 10);\r\n  }\r\n\r\n  return ans.reverse();\r\n};\r\n```\r\n\r\n- 时间复杂度 O(N)\r\n- 空间复杂度 O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838192744","body":"## 代码：\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n  let ans = new Array(s.length).fill(10001);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) {\r\n      ans[i] = 0;\r\n      continue;\r\n    }\r\n    if (s[i - 1] !== void 0) {\r\n      ans[i] = ans[i - 1] + 1;\r\n    }\r\n  }\r\n\r\n  for (let j = s.length - 1; j >= 0; j--) {\r\n    if (s[j + 1] !== void 0) {\r\n      ans[j] = Math.min(ans[j], ans[j + 1] + 1);\r\n    }\r\n  }\r\n\r\n  return ans;\r\n};\r\n```\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839741958","body":"```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nclass CustomStack {\r\n  constructor(n) {\r\n    this.maxTop = n;\r\n    this.top = 0;\r\n    this.stack = [];\r\n  }\r\n\r\n  push(element) {\r\n    if (this.top < this.maxTop) {\r\n      this.stack.push(element);\r\n      this.top++;\r\n    }\r\n  }\r\n\r\n  pop() {\r\n    if (this.top > 0) {\r\n      this.top--;\r\n      return this.stack.pop();\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  increment(k, val) {\r\n    k = Math.min(k, this.top);\r\n    for (let i = 0; i < k; i++) {\r\n      this.stack[i] += val;\r\n    }\r\n  }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840561718","body":"## 思路\r\n\r\n辅助栈\r\n\r\n## 代码\r\n```js\r\nvar decodeString = function (s) {\r\n  const stack = [];\r\n\r\n  for (const char of s) {\r\n    if (char === ']') {\r\n      let repeatStr = '';\r\n      while (stack[stack.length - 1] !== '[') {\r\n        repeatStr = stack.pop() + repeatStr;\r\n      }\r\n      stack.pop();\r\n      let repeatNum = '';\r\n      while (stack[stack.length - 1] >= '0' && stack[stack.length - 1] <= '9') {\r\n        repeatNum = stack.pop() + repeatNum;\r\n      }\r\n      repeatStr = repeatStr.repeat(parseInt(repeatNum));\r\n      stack.push(repeatStr);\r\n    } else {\r\n      stack.push(char);\r\n    }\r\n  }\r\n\r\n  return stack.join('');\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841189740","body":"```js\r\nclass MyQueue {\r\n  constructor() {\r\n    this.pushStack = []\r\n    this.popStack = []\r\n  }\r\n\r\n  push(element) {\r\n    this.pushStack.push(element);\r\n  }\r\n\r\n  pop() {\r\n    if (!this.popStack.length) {\r\n      while (this.pushStack.length) {\r\n        this.popStack.push(this.pushStack.pop());\r\n      }\r\n    }\r\n    return this.popStack.pop();\r\n  }\r\n\r\n  peek() {\r\n    if (!this.popStack.length) {\r\n      while (this.pushStack.length) {\r\n        this.popStack.push(this.pushStack.pop());\r\n      }\r\n    }\r\n    return this.popStack[this.popStack.length - 1];\r\n  }\r\n\r\n  empty() {\r\n    return !this.pushStack.length && !this.popStack.length;\r\n  }\r\n\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangyi123456":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836270960","body":"## 题目思路\r\n1.拆开每一位，用进位相加\r\n2.当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\r\n\r\n## 代码\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int sum = 0, carry = 0;\r\n        int i = num.length-1;\r\n        List<Integer> res = new LinkedList<Integer>();\r\n        while(i>=0 || k>0){\r\n            int x = i>=0? num[i]:0;\r\n            int y = k>0?  k%10:0;\r\n            sum = x+y+carry;\r\n            carry = sum/10;\r\n            i -= 1;\r\n            k = k/10;\r\n            res.add(0,sum%10);\r\n        }\r\n        if(carry!=0) res.add(0,carry);\r\n        return res;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n时间复杂度 max(n,k) n为数组长度，k为数字位数\r\n空间复杂度 max(n,k) n为数组长度，k为数字位数"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839766929","body":"`class CustomStack:\r\n\r\n    def __init__(self, size: int):\r\n        self.st = []\r\n        self.cnt = 0\r\n        self.size = size\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.size:\r\n            self.st.append(x)\r\n            self.cnt += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt == 0: return -1\r\n        self.cnt -= 1\r\n        return self.st.pop()\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(self.cnt, k)):\r\n            self.st[i] += val`"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840580971","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr\r\n                # pop 掉 \"[\"\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount\r\n                stack.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841225412","body":"不想学习啊怎么办"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzcyx":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836272330","body":"# c++\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int>ans;int carry=0;\r\n        for(int i=num.size()-1;i>=0;i--)\r\n        {\r\n            int a=k%10;k/=10;\r\n            int b=(num[i]+a+carry)%10;\r\n            carry=(num[i]+a+carry)/10;\r\n            ans.push_back(b);\r\n        }\r\n        while(k>0||carry>0)\r\n        {   int b=k%10;k/=10;\r\n            ans.push_back((b+carry)%10);\r\n            carry=(b+carry)/10;\r\n        }\r\n        reverse(ans.begin(),ans.end());\r\n         return ans;\r\n    }\r\n};\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838286251","body":"### 解题思路\r\n参考官方题解，用`pre`存储上一个c出现的位置，当```s[i]=c```时更新```pre=i```\r\n先从左到右遍历，`i-pre`即为到改字符往左到c的距离\r\n在从右到左遍历，`pre-i`即为到改字符往右到c的距离，取左右距离的最小值\r\n### 代码\r\n### c++\r\n```class Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int>ans(s.size());\r\n        int i,pre=-999999;\r\n        for(i=0;i<s.size();i++)\r\n        {\r\n            if(s[i]==c)pre=i;\r\n            ans[i]=i-pre;\r\n        }\r\n        pre=999999;\r\n        for(i=s.size()-1;i>=0;i--)\r\n        {\r\n            if(s[i]==c)pre=i;\r\n            ans[i]=min(ans[i],pre-i);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839617277","body":"### C++\r\n```\r\nclass CustomStack {\r\npublic:\r\n    vector<int>st;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        st.resize(maxSize);top=-1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top!=st.size()-1)st[++top]=x;\r\n    }\r\n    \r\n    int pop() {\r\n        if(top==-1)return -1;\r\n        top--;return st[top+1];\r\n       // return st[top--];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int lim=min(k,top+1);\r\n        //int lim=top+1<k?top+1:k;\r\n        for(int i=0;i<lim;i++)\r\n            st[i]+=val;\r\n    }\r\n};\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840630858","body":"C++\r\n```\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res;\r\n        stack<int>num;\r\n        stack<string>str;\r\n        int curNum=0;\r\n        for(char c:s)\r\n        {\r\n            if(c>='0'&c<='9')\r\n                curNum=curNum*10+c-'0';\r\n            else if(c>='a'&&c<='z')\r\n                res+=c;\r\n            else if(c=='[')\r\n                {num.push(curNum);\r\n                 curNum=0;\r\n                 str.push(res);\r\n                 res=\"\";\r\n                }\r\n            else if(c==']')\r\n                {\r\n                    string tmp=str.top();str.pop();int n=num.top();num.pop();\r\n                    for(int i=0;i<n;i++)\r\n                        tmp+=res;\r\n                    res=tmp;\r\n                }\r\n                \r\n        }\r\n        return res;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840979822","body":"```\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    stack<int>st1,st2;\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        st1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        int t;\r\n       if(st2.empty())\r\n       {\r\n           while(!st1.empty())\r\n           {\r\n               t=st1.top();\r\n               st1.pop();\r\n               st2.push(t);\r\n           }\r\n       }\r\n       t=st2.top();st2.pop();\r\n       return t;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n      int t;\r\n       if(st2.empty())\r\n       {\r\n           while(!st1.empty())\r\n           {\r\n               t=st1.top();\r\n               st1.pop();\r\n               st2.push(t);\r\n           }\r\n       }\r\n       t=st2.top();\r\n       return t;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return st1.empty()&&st2.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linzeliang1222":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836279098","body":"## 思路\r\n\r\n-   从最低位开始加，满10用carry进1，最后还要判断最终有没有进1位\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        ArrayList<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length - 1;\r\n        int carry = 0;\r\n\r\n        while (n >= 0 || k != 0) {\r\n            int a = n < 0 ? 0 : num[n];\r\n            int b = k % 10;\r\n\r\n            int temp = (a + b + carry) % 10;\r\n            carry = (a+ b + carry) / 10;\r\n            res.add(temp);\r\n            n--;\r\n            k /= 10;\r\n        }\r\n        if (carry == 1) {\r\n            res.add(1);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$\r\n- 空间复杂度：$O(N)$"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838618559","body":"## 思路\r\n\r\n-   使用一个res数组，而且要初始化为Integer.MAX_VALUE\r\n\r\n-   从左到右遍历字符串，直到遇到我们的目标字符时候停下来\r\n\r\n-   以目标字符为中心，pre和next双指针向两边移动，并且给数组赋值，从1开始递增\r\n\r\n-   如果指针再移动过程中遇到当前的值大于等于左边/右边的值，那么就结束该指针的移动\r\n\r\n    ![](https://img2020.cnblogs.com/blog/2067154/202011/2067154-20201102004404706-1773904769.png)\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nimport java.util.Arrays;\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int len = S.length();\r\n        int[] res = new int[len];\r\n        // 填充最大值\r\n        Arrays.fill(res, Integer.MAX_VALUE);\r\n\r\n        for (int i = 0; i < len; i++) {\r\n            //每次遇到e时候，就进行pre和next的移动\r\n            if (S.charAt(i) == C) {\r\n                res[i] = 0;\r\n                int pre = i-1;\r\n                int next = i+1;\r\n                int t = 1;\r\n                // 赋值的条件是t要小于等于前一个/后一个元素的值\r\n                // 进行左移动赋值\r\n                while (pre >= 0 && t < res[pre]) {\r\n                    res[pre--] = t++;\r\n                }\r\n                t = 1;\r\n                // 进行右移动赋值\r\n                while (next < len && t < res[next]) {\r\n                    res[next++] = t++;\r\n                }\r\n            }\r\n        }\r\n        // 得到结果\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N^2)$，其中 N 为字符串长度。\r\n- 空间复杂度：$O(N)$，其中 N 为res数组长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839479151","body":"## 思路\r\n\r\n-   利用数组来存储栈的元素\r\n-   通过一个point指针的移动完成栈的操作\r\n-   进行增量操作时，需要判断操作的元素个数k是否大于当前栈中的元素容量\r\n\r\n### 代码\r\n\r\n```java\r\nclass CustomStack {\r\n\r\n    private int size;\r\n    private int[] stack;\r\n    private int point;\r\n\r\n    public CustomStack(int maxSize) {\r\n        size = maxSize;\r\n        stack = new int[size];\r\n        point = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (point < size) {\r\n            stack[point++] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (point > 0) {\r\n            return stack[--point];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < k && i < point; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n-   时间复杂度：O(1)\r\n-   空间复杂度：O(N)，N为栈的大小"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840641163","body":"## 思路\r\n\r\n-   创建两个栈进行解题，一个用来存放数字，另一个用来临时存放子字符串\r\n-   由于可能会在`[]`中还包含其他的`[]`，所以我们只要遇到`[`就先将其前面的字符串暂时入栈，稍后再进行计算\r\n-   如果遇到`]` ，则将存放数字的栈和存放子字符串的栈分别出栈一个，然后进行字符串的拼接，然后再将该字符串作为答案的一部分进行下一轮迭代计算\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Deque<Integer> times = new LinkedList<Integer>();\r\n        Deque<String> stringStack = new LinkedList<String>();\r\n        StringBuilder res = new StringBuilder();\r\n        int count = 0;\r\n\r\n        for (Character c : s.toCharArray()) {\r\n            // 如果为数字，则记录数字，数字有可能有十位或者百位\r\n            if (isNum(c)) {\r\n                count = count * 10 + Integer.parseInt(\"\" + c);\r\n            } else if (c == '[') { // 如果为左中括号，则将数字和当前的res进栈\r\n                times.push(count);\r\n                stringStack.push(res.toString());\r\n                // 注意还要将res置空，因为要开始下一轮的字符串统计，上一轮的字符串已经先暂存到栈中去了\r\n                res = new StringBuilder();\r\n                // 次数也要置为0\r\n                count = 0;\r\n            } else if (c == ']') { // 如果为右中括号，则要开始计算本次统计的res，添加到上一个字符串的末尾\r\n                // 获取次数\r\n                count = times.pop();\r\n                StringBuilder curString = new StringBuilder(stringStack.pop());\r\n                for (int i = 0; i < count; i++) {\r\n                    curString.append(res);\r\n                }\r\n                // 将拼接好后的字符串作为结果进行下一轮迭代\r\n                res = curString;\r\n                count = 0;\r\n            } else {\r\n                // 如果都是字母的话仅进行平解字符串即可\r\n                res.append(c);\r\n            }\r\n        }\r\n\r\n        return res.toString();\r\n    }\r\n\r\n    public boolean isNum(char c) {\r\n        // 判断字符是否为数字\r\n        if (c <= '9' && c >= '0') {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$，N为字符串的长度\r\n- 空间复杂度：$O(N)$，N为字符串的长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841318784","body":"## 思路\r\n\r\n-   即然是使用两个栈，那么一个栈就用来做辅助栈，一个栈用来存元素\r\n-   我们将栈顶作为队头，将栈底作为队尾，所以如果要push数据的话，先将stack1栈的数据暂时存到stack2辅助栈中，然后将要插入的数据push进入stack1，最后再将stack2的暂存的数据填回到stack1中**（注意，回填元素时顺序不能乱）**\r\n-   pop时，就是将栈的元素最后一个pop出去，由于我们将队头做为栈顶，所以stack1的pop其实就是出队操作\r\n-   empty：要判断队列是否为空，直接判断stack1是否为空即可\r\n-   由于栈是基于LinkedList实现的，peek时即查看的是栈顶的元素，所以直接peek就是查看队头的元素\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nimport java.util.LinkedList;\r\nclass MyQueue {\r\n\r\n    LinkedList<Integer> stack1;\r\n    LinkedList<Integer> stack2;\r\n\r\n    public MyQueue() {\r\n        stack1 = new LinkedList<>();\r\n        stack2 = new LinkedList<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        while (!stack1.isEmpty()) {\r\n            stack2.push(stack1.pop());\r\n        }\r\n        stack1.push(x);\r\n        while (!stack2.isEmpty()) {\r\n            stack1.push(stack2.pop());\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        return stack1.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        return stack1.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stack1.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：\r\n    - push: $O(N)$\r\n    - pop: $O(1)$\r\n    - peek: $O(1)$\r\n    - empty: $O(1)$\r\n- 空间复杂度：$O(N)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841667123","body":"## 思路\r\n\r\n-   利用**单调递增栈**来解题\r\n    -   遍历数组，将元素存入栈中，再利用max记录当前栈顶的最大值\r\n    -   如果遇到比当前栈元素大的值，那么可以**直接入栈**，因为可以单独分一块；但是如果遇到比当前栈顶元素小的值，那么应该将之前的元素**依次出栈**，直到遇到**小于等于**该值的元素停止出栈，然后将max再push入栈（push的这个max就代表了这一个块）\r\n        -   例如：有该数组 {1, 1, 3, 4, 5, 2, 6, 7}，此时栈为{1, 1, 3, 4, 5}\r\n        -   接下来遍历到2了，2比max即5小，所以开始出栈，顺序是：5、4、3，由于1小于2，所以停止出栈，接下来将max(5)入栈，此时栈为：{1, 1, 5}\r\n    -   不断遍历，直到数组遍历结束，此时栈中有多少个元素就代表有多少个块了\r\n-   分块规则：**后一块元素的最小值大于等于前一块元素的最大值**\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nimport java.util.LinkedList;\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        LinkedList<Integer> stack = new LinkedList<>();\r\n        int max = arr[0];\r\n\r\n        for (int i = 0; i < arr.length; i++) {\r\n            if (!stack.isEmpty() && arr[i] < max) {\r\n                while (!stack.isEmpty() && arr[i] < stack.peek()) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(max);\r\n            } else {\r\n                stack.push(arr[i]);\r\n                max = stack.peek();\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$， N 为数组长度\r\n- 空间复杂度：$O(N)$，N为栈的大小"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Yvonne1231-Wang":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836281956","body":"### 解题思路\r\n将数组num的最后一位从后往前与k从个位开始依次相加，若加起来后的总数小于10则直接推入栈中；若总数大于10，则将k的进位加1，将总数减去10以后推入栈中。\r\n##需要注意点：\r\n1.不能忘记k的位数或者加起来总数的位数大于原本的数组num的长度点情况，所以数组遍历结束还要判断k是否为0了，若没有，再将k依次推入；\r\n2.不要忘记反转数组，如果改成unshift()则不用；\r\n3.最开始想的办法是将num先转换成数字，与k相加后变成字符串再变成数组，但是忽略了num长度很长变成数字后再相加会溢出的情况。\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let a,res=[];\r\n    for(let i = num.length-1; i >= 0; i--)\r\n    {\r\n        a = num[i] + k % 10;\r\n        k = Math.floor(k/10);\r\n        if(a >= 10){\r\n            ++k;\r\n            a = a-10;\r\n        };\r\n        res.push(a);\r\n    }\r\n    while(k!=0){\r\n        res.push(k%10);\r\n        k = Math.floor(k/10);\r\n    }\r\n    \r\n    return res.reverse();\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n) ----只开辟了两个新数据，a和res，其中a是常量阶的，与数据规模无关。res是一个大小与n有关的数组，所以空间复杂度为O(n)\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838232128","body":"### 解题思路\r\n把字符串s以字符串c作为separator分割为数组，然后计算数组每个元素的长度\r\n第一个元素和最后一个元素离得最近的距离单独推入\r\n数组中间的元素判断长度是偶数还是奇数，两种情况推入距离\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let sArr = s.split(c);\r\n    let len = sArr.length;\r\n    let res = [];\r\n    for(let i = sArr[0].length; i >=0; i--){\r\n        res.push(i);\r\n    }\r\n    for (let i=1; i < len-1; i++){\r\n        if(sArr[i].length % 2 == 0){\r\n            for(let j=1; j <= Math.floor(sArr[i].length/2); j++){\r\n            res.push(j);\r\n            }\r\n            for(let j = Math.floor(sArr[i].length/2); j >=0; j--){\r\n            res.push(j);\r\n            }\r\n        }else{\r\n            for(let j=1; j <= Math.floor(sArr[i].length/2); j++){\r\n            res.push(j);\r\n            }\r\n            res.push(Math.floor(sArr[i].length/2) +1)\r\n            for(let j = Math.floor(sArr[i].length/2); j >=0; j--){\r\n            res.push(j);\r\n            }\r\n        }\r\n    }\r\n    for(let i = 1; i <= sArr[len-1].length; i++){\r\n        res.push(i);\r\n    }\r\n    return res\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n) n为字符串s的长度\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839672335","body":"### 解题思路\r\n此处撰写解题思路\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.arr = [];\r\n    this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.arr.length < this.maxSize){\r\n        this.arr.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(this.arr.length != 0){return this.arr.pop()}\r\n    return -1\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    if(this.arr.length < k){\r\n        for(i=0; i<this.arr.length; i++){\r\n            this.arr[i] += val\r\n        }\r\n    }else{\r\n            for(i=0; i<k; i++){\r\n            this.arr[i] += val\r\n        }\r\n    }\r\n    \r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(N)-----increment操作的时候是O(N),其他时候是O(1)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840478164","body":"# 方法一：只用一个栈\r\n### 解题思路\r\n1.依次扫描字符串s的各个元素，如果遇到数字字符，不能忘记考虑\"100\"这种连续数字的情况；如果是第一次遇到数字字符，则推入栈中，若栈顶已经是数字字符，则把目前的字符拼接到栈顶数字字符的后面；（看到题解中还有一种处理连续数字字符的方法，就是把遇到\"[\"之前的数字字符拼接到一起）\r\n2.如果遇到\"[\"或者字母则直接推入栈中；\r\n3.如果遇到\"]\",则依次从栈中取出字母拼接成临时字符串，直到遇到\"[\"；然后再取出\"[\"前面的一个元素，即这个临时字符串需要重复的次数。最后把重复完的临时字符串推入栈中。\r\n4.遍历结束后，不能忘了要把stack里所有字符串拼接起来，分清楚拼接顺序。\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let stack = [];\r\n    for (i = 0; i < s.length; i++){\r\n        if(s[i]>=\"0\" && s[i]<=\"9\"){\r\n            //考虑”100“这种连续数字字符的可能性\r\n            if(stack[stack.length-1]>=\"0\" && stack[stack.length-1]<=\"9\"){\r\n                stack[stack.length-1] += s[i]\r\n                continue;\r\n            }\r\n            stack.push((s[i]))            \r\n        }else{\r\n            if(s[i] == \"]\"){\r\n                let letter = stack.pop();\r\n                let resPart = \"\";\r\n                let resPartAll = \"\";\r\n                while( letter != '['){\r\n                    resPart = letter + resPart;\r\n                    letter=stack.pop();\r\n                }\r\n                let num = Number(stack.pop());\r\n                for (let i=0; i < num; i++){\r\n                    resPartAll = resPartAll+resPart;\r\n                }\r\n                stack.push(resPartAll);\r\n\r\n            }\r\n            //其他情况即\"[\"或者是字母时，直接入栈\r\n            else {\r\n                stack.push(s[i])\r\n            }\r\n        }\r\n    }\r\n    //最后不能忘了要把stack里所有字符串拼接起来（此处注意，不能直接let res而不赋值，会把\"undefined\"一起拼接上去）\r\n    let res=\"\";\r\n    for(i = 0; i < stack.length; i++){\r\n        res += stack[i];\r\n    }\r\n    return res\r\n    \r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(k)----k是字符串的长度\r\n空间复杂度：O(k)----k是字符串的长度\r\n\r\n# 方法二：双栈\r\n### 解题思路\r\n和一个栈类似，需要注意的是最开始字符串栈strStack会推入一个空字符串！！\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let isNum = (e) =>  e >= \"0\" && e <= \"9\";\r\n    let numStack = [];\r\n    let strStack = [];\r\n    let num = 0; \r\n    let char = \"\";//字母暂存处,等待被处理的字符串\r\n    for(i = 0; i < s.length; i++){\r\n        if (isNum(s[i])){\r\n            num = num * 10 + Number(s[i])\r\n        }else if(s[i] == \"[\"){\r\n            numStack.push(num);\r\n            num = 0;\r\n            strStack.push(char);//如果遇到\"[\"说明是嵌套结构，推入字符串栈，等会处理\r\n            char = \"\";\r\n        }else if(s[i] == \"]\"){\r\n            char = strStack.pop() + char.repeat(numStack.pop());\r\n        }else{\r\n            char += s[i]; //遇到连续的字母要拼接起来 \r\n        }\r\n    }\r\n\r\n    return char\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(k)----k是字符串的长度\r\n空间复杂度：O(k)----k是字符串的长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841121866","body":"### 解题思路\r\n双栈，一个栈是用来模拟队列，push的时间直接push进去；另一个栈负责在pop和peek操作时，先把栈里所有元素依此倒腾出来，取出栈底元素后，再倒腾回去。\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.stackA = [];\r\n    this.stackB = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stackA.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    while(this.stackA.length){\r\n        this.stackB.push(this.stackA.pop())\r\n    };\r\n    let res = this.stackB.pop();\r\n    while(this.stackB.length){\r\n        this.stackA.push(this.stackB.pop())\r\n    };\r\n    return res;\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    while(this.stackA.length){\r\n        this.stackB.push(this.stackA.pop())\r\n    };\r\n    let res = this.stackB.pop();\r\n    this.stackA.push(res)\r\n    while(this.stackB.length){\r\n        this.stackA.push(this.stackB.pop())\r\n    };\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    if(this.stackA.length){return false}\r\n    return true\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：push,empty操作时为O(1),pop和peek操作时为O(N),N为操作总数\r\n空间复杂度：push,empty操作时为O(1),pop和peek操作时为O(N),N为操作总数"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Liuqibaa":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836300543","body":"C++\r\n\r\n### 思路\r\n\r\n将向量编程整数，然后相加，再变成向量\r\n\r\n### 代码\r\n\r\n\r\n```c\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int nums = 0;\r\n        int tens = 1;\r\n        vector<int> result;\r\n        for(int i = num.size() - 1; i >= 0; i --){\r\n            nums += num[i] * tens;\r\n            tens *= 10;\r\n        }\r\n        nums += k;\r\n        while(nums){\r\n            int num1 = nums % 10;\r\n            result.push_back(num1);\r\n            nums /= 10;\r\n        }\r\n        reverse(result.begin(), result.end());\r\n        return result;\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838128260","body":"### 思路\r\n\r\n用双指针法：先新建一个向量，大小为字符串大小，元素值全为1，然后遍历，将为c的位置均为0；再定义两个指针，同时一前一后搜索为0的；之前的代码无法实现，现在这个代码可以实现\r\n代码是C++的\r\n\r\n### 代码\r\n\r\n\r\n``c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int size1 = s.size();\r\n        vector<int> result(size1, 1);\r\n        for(int i = 0; i < size1 ; i ++){\r\n            if(s[i] == c){\r\n                result[i] = 0;\r\n            }\r\n        }\r\n\r\n        for(int k = 0; k < size1; k ++){\r\n            int i = k;\r\n            int j = k;\r\n            if(result[k] != 0){\r\n                while(result[i] != 0 && result[j] != 0){\r\n                    i --; if(i < 0) i = 0;\r\n                    j ++; if(j > size1 - 1) j = size1 - 1;\r\n                }\r\n                if(result[i] == 0) {\r\n                    result[k] = k - i;\r\n                } else{\r\n                    result[k] = j - k;\r\n                }\r\n            } \r\n        }\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838128260","body":"### 思路\r\n\r\n用双指针法：先新建一个向量，大小为字符串大小，元素值全为1，然后遍历，将为c的位置均为0；再定义两个指针，同时一前一后搜索为0的；之前的代码无法实现，现在这个代码可以实现\r\n代码是C++的\r\n\r\n### 代码\r\n\r\n\r\n``c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int size1 = s.size();\r\n        vector<int> result(size1, 1);\r\n        for(int i = 0; i < size1 ; i ++){\r\n            if(s[i] == c){\r\n                result[i] = 0;\r\n            }\r\n        }\r\n\r\n        for(int k = 0; k < size1; k ++){\r\n            int i = k;\r\n            int j = k;\r\n            if(result[k] != 0){\r\n                while(result[i] != 0 && result[j] != 0){\r\n                    i --; if(i < 0) i = 0;\r\n                    j ++; if(j > size1 - 1) j = size1 - 1;\r\n                }\r\n                if(result[i] == 0) {\r\n                    result[k] = k - i;\r\n                } else{\r\n                    result[k] = j - k;\r\n                }\r\n            } \r\n        }\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841119335","body":"### 思路\r\n\r\n画图模拟，要实现先入先出的队列的话，需要两个先入先出的堆栈；一个栈用来输入，一个用来输出；接着弹出的时候如果输出占非空，就弹出，等输出栈空了就将输入栈所有元素压入输出栈；代码是 C++\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass MyQueue {\r\npublic:\r\n    stack<int> stkIn;\r\n    stack<int> stkOut;\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        stkIn.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if(stkOut.empty()){\r\n            while(!stkIn.empty()){\r\n                stkOut.push(stkIn.top());\r\n                stkIn.pop();\r\n            }\r\n        }\r\n        int result = stkOut.top();\r\n        stkOut.pop();\r\n        return result;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        int result = this->pop();\r\n        stkOut.push(result);\r\n        return result;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return stkOut.empty() && stkIn.empty();\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push() 和 peek(), empty() 都是O(1)，pop() 是 O(N)?\r\n- 空间复杂度：O(N)，\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841660557","body":"### 思路\r\n\r\n好烦，看官方题解一知半解，只能是默下 C++ 的代码了\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> stk;\r\n        for(int i = 0; i < arr.size(); i ++){\r\n            if(!stk.empty() && stk.top() > arr[i]){\r\n                int cur = stk.top();\r\n                while(!stk.empty() && stk.top() > arr[i]){\r\n                    stk.pop();\r\n                }\r\n                stk.push(cur);\r\n            }\r\n            else{\r\n                stk.push(arr[i]);\r\n            }\r\n        }\r\n        return stk.size();\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sitequ":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836300870","body":"**语言：python3**\r\n\r\n### 思路\r\n1.整型数组转化字符数组，再化为非负整数\r\n2.与k相加\r\n3.数字还原成字符数组，再化为整型数组\r\n\r\n### 代码\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num = map(str, num)\r\n        str2int = int(''.join(num)) + k\r\n        Output = list(str(str2int))\r\n        for i in range(0,len(Output)):\r\n            Output[i] = int(Output[i])\r\n        return Output\r\n```\r\n### 复杂度分析\r\n时间复杂度O(n)\r\n空间复杂度O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838443247","body":"**语言：python3**\r\n\r\n### 思路\r\n1. 获得所有c的位置\r\n2. s的每个字符的位置与c的位置做差，排序找到最小，将值作为元素返回\r\n3. 返回最终最短距离列表\r\n\r\n### 代码\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = len(s)\r\n        Output = []\r\n        num_c = []\r\n        for i in range(0,l):\r\n            if s[i] == c :\r\n                num_c.append(i)\r\n\r\n        L = len(num_c)\r\n\r\n        for i in range(0,l):\r\n            K = []\r\n            for m in range(0,L):\r\n                K.append(abs(i - num_c[m]))\r\n            K = sorted(K)\r\n            Output.append(K[0])\r\n\r\n        return Output\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：Worst case O(N^2)\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839728882","body":"**语言：python3**\r\n\r\n### 思路：\r\n开辟空数组，按要求执行不同函数\r\n\r\n\r\n### 代码：\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxsize = maxSize\r\n        self.Stack = list()\r\n        return None\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.Stack) < self.maxsize:\r\n            self.Stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.Stack) == 0:\r\n            return -1\r\n        else:\r\n            return self.Stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.Stack) <= k:\r\n            for i in range(0,len(self.Stack)):\r\n                self.Stack[i] += val\r\n        else:\r\n            for i in range(0,k):\r\n                self.Stack[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n\r\n### 复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840414996","body":"**语言：python3**\r\n\r\n### 思路：\r\n1.先将字符串拆分，注意两位数以上的整数情况\r\n2.依次pop字符入栈，同时开辟记录 '[' 和 ']' 的位置的数组\r\n3.当有[出现时，记录需要倍增的字符串入栈，相应的[,]，以及字符出栈，记录相应位置的元素也要清除\r\n4.最终将栈内的字符串reverse并且join，返回结果\r\n\r\n\r\n### 代码：\r\n\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        A_A = re.findall(r'[a-z]+|\\d+|\\[+|\\]+',s)\r\n        a_a = list()\r\n        for p in range(0, len(A_A)):\r\n            if A_A[p].isdigit():\r\n                a_a.append(A_A[p])\r\n            else:\r\n                M = list(A_A[p])\r\n                for q in range(0, len(M)):\r\n                    a_a.append(M[q])\r\n        AA = a_a       \r\n        cache = list()\r\n        mark = list()\r\n        l = len(AA)\r\n        k = 'o'\r\n        for i in range(0,l):\r\n            cache.append(AA[l-1-i])\r\n            if AA[l-1-i] == ']' :\r\n                mark.append(len(cache)-1)\r\n            if AA[l-1-i] == '[':\r\n                mark.append(len(cache)-1)\r\n                K = cache[(mark[len(mark)-2]+1):mark[len(mark)-1]]\r\n                k = ''.join(reversed(K))\r\n                for j in range(0,(mark[len(mark)-1]+1-mark[len(mark)-2])):\r\n                    cache.pop()\r\n                cache.append(k)\r\n                for t in range(0,2):\r\n                    mark.pop()\r\n            if AA[l-1-i].isdigit():\r\n                cache.pop()\r\n                cache.append(k*(int(AA[l-1-i])-1))\r\n        Output = ''.join(reversed(cache))\r\n        return Output\r\n```\r\n\r\n### 复杂度分析：\r\n时间复杂度：O(N^2)\r\n空间复杂度：O(N^2)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840960840","body":"**语言：python3**\r\n\r\n### 代码：\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.queue = list()\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.queue.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.queue.pop(0)\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.queue[0]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return self.queue == []\r\n```\r\n\r\n### 复杂度分析;\r\n\r\n时间复杂度：O(1)\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841680502","body":"**语言：python3**\r\n\r\n### 思路：\r\n1.将原数组排序\r\n2.依次比较两个数组的切片，相同加一\r\n3.返回结果\r\n\r\n### 代码：\r\n```\r\nclass Solution:\r\n    def MAxChunks(self,arr):\r\n        AA = sorted(arr)\r\n        chunks = 0\r\n        for i in range(0,len(arr)):\r\n            if sorted(arr[:i+1]) == AA[:i+1]:\r\n                chunks += 1\r\n        return chunks\r\n```\r\n\r\n### 复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaotuanzi999":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836303348","body":"### 思路 \r\n首先，作为小白，我的第一思路就是将数组转换真正的值，然后与k相加，最后将相加的和转化为List。\r\n```\r\n public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int lenth = num.length;\r\n       List<Integer> res = new ArrayList<>();\r\n       int sum=k;\r\n        int n=1;\r\n        for (int i = lenth-1; i>=0; i--){\r\n            sum+= n*num[i];\r\n            n*=10;\r\n        }\r\n        String temp = Integer.toString(sum);\r\n        for (int i = temp.length()-1; i>=0;i--){\r\n            res.add(Integer.parseInt(temp.substring(i,i+1)));\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n```\r\n\r\n然而结果不尽人意。正常的数字可以得到正确的结果。但当数字特别大的时候会出现下面的情况，我还debug了查看。之后查询才知道是溢出了，超出int的精度范围。\r\n\r\n\r\n从后往前遍历数组，就是从数组的低位开始。与k进行相加，并对k与10取余，得到最低位。然后k%10得到进位。\r\n中间存在num的数组整体的小于k的情况，所以需要对i进行判断。\r\n### 代码\r\n```\r\nclass Solution {\r\n      public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int lenth = num.length;\r\n        List<Integer> res = new ArrayList<>();\r\n        for (int i = lenth-1; i>=0||k>0; i--,k/=10){\r\n            // 如果num数组存在数组，因为存在k>num的情况\r\n            if (i>=0){\r\n                k+=num[i];\r\n            }\r\n            res.add(k%10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838038240","body":"### 思路\r\n从左往右遍历计算离左边最近的距离；\r\n从右往左遍历计算离右边最近的距离。\r\n但是存在初始时，c位置的位置设定。从左往右设置为最小，这样他们之间差值就很大。从而在从右往左遍历时可以更新其的值。\r\n\r\n### 代码\r\n```\r\n public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] res = new int[length];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        for (int i=0; i<length; i++){\r\n            if (s.charAt(i)==c) prev = i;\r\n                res[i] = i-prev;\r\n        }\r\n        prev = Integer.MAX_VALUE/2;\r\n        for (int i = length-1; i>=0; i--){\r\n            if (s.charAt(i)==c) prev = i;\r\n                res[i] = Math.min(res[i],prev-i);\r\n        }\r\n        return res;\r\n    }\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839373330","body":"### 思路\r\n\r\n利用数组模拟栈，设置一个标志位用来模拟栈顶。pop() 需判断栈顶是否到达栈底；push() 需判断是否超过栈的大小。increment（）则需判断需要修改位数与栈中元素比较取最小者。\r\n\r\n### 代码\r\n```\r\nclass CustomStack {\r\n\r\n    int[] stack;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top!=stack.length-1){\r\n//            ++top;\r\n            stack[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top==-1) return -1;\r\n        --top;\r\n        return stack[top+1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k,top+1);\r\n        for (int i=0; i<limit; i++){\r\n            stack[i] +=val;\r\n        }\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jmaStella":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836305778","body":"## 解题思路\r\n尝试数字全拿出来然后+K再放回去，结果发现lc有很大的test case，可能就是故意不想让你用这种方法，然后 重新尝试，先把K加到最后一个A的数字，然后取%10的值，循环下去。写了第二遍了还是不能一遍写出来。。。大无语时间发生了。\r\n\r\n\r\n\r\n## 代码\r\n`\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n\r\n    List<Integer> newA = new ArrayList<>();\r\n\r\n    int temp = K;\r\n\r\n    for(int i = A.length-1; i>=0; i--){\r\n\r\n        temp = temp+ A[i];\r\n        newA.add(0, temp%10);\r\n        temp=temp/10;\r\n    }\r\n    while(temp !=0){\r\n        newA.add(0, temp%10);\r\n        temp=temp/10;\r\n    }\r\n    return newA;\r\n    }\r\n`\r\n以为会变得更快，结果并没有\r\n`\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n\r\n    List<Integer> newA = new ArrayList<>();\r\n\r\n    int temp = K;\r\n    int index = A.length-1;\r\n    while(temp !=0 || index >=0){\r\n        if(index >=0){\r\n            temp = temp+ A[index];\r\n        }    \r\n        newA.add(0, temp%10);\r\n        temp=temp/10;\r\n        index --;\r\n    }\r\n\r\n    return newA;\r\n    }\r\n`\r\n\r\n## 复杂度分析\r\n时间复杂度O(max(n, log(K)))\r\n空间复杂度O(max(n, log(K)))\r\n\r\n\r\n喜欢解析里一个人的总结，mark一下。\r\n\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n\r\n作者：lilyunoke\r\n链接：https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/\r\n来源：力扣（LeetCode）\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837949838","body":"## 思路\r\n以为自己写的是暴力，结果好像不是？感觉比较redundant。先在string里搜一遍c，index存下来，然后再双指针（不确定是不是双指针），这个写法非常有问题，要手动handle各种edge case\r\n\r\n## 代码\r\n\r\n`\r\n    public int[] shortestToChar(String s, char c) {\r\n        List<Integer> c_index= new ArrayList<Integer>();\r\n        int result[] = new int[s.length()];\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            if(c ==s.charAt(i)){\r\n                c_index.add(i);\r\n            }\r\n        }\r\n        int first= 0;\r\n        int second = 0;\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            if(c_index.size()>1 && second<c_index.size() && i>=c_index.get(second)){\r\n                 first = second;\r\n                 if(second != c_index.size()-1 ){\r\n                     second++;\r\n                 }\r\n            }\r\n\r\n            if(i <= c_index.get(first)){\r\n                result[i] =Math.abs(c_index.get(first)-i);\r\n            }else if(i>c_index.get(first) && i<c_index.get(second)){\r\n                result[i] =Math.min(Math.abs(c_index.get(first)-i),Math.abs(c_index.get(second)-i));\r\n            }else{\r\n                result[i] =Math.abs(c_index.get(second)-i);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n`\r\n## 复杂度\r\n时间 O(n)\r\n空间O(n)\r\n\r\n\r\n## 思路\r\n看了答案重新写了一遍\r\n最短的距离无非就是左边的或者右边的\r\n先是从左往右loop一遍，记录，然后从右往左loop一遍，比较之前的大小，选更小的\r\n## 代码\r\n\r\n`\r\n    public int[] shortestToChar(String s, char c) {\r\n        int result[] = new int[s.length()];\r\n        int prev = Integer.MIN_VALUE/2;\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            result[i] =i-prev;\r\n        }\r\n\r\n\r\n        for(int i = s.length()-1; i>=0; --i){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            result[i] = Math.min(result[i], Math.abs(prev-i));\r\n        }\r\n        return result;\r\n\r\n    }\r\n`\r\n## 复杂度\r\n时间 O(n)\r\n空间O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839609477","body":"## 思路\r\n感觉用array比较简单, 用array然后用一个last index来追踪stack最上面的index， 来实现push和pop的方法。inc值得注意的是，如果K>stack.size()， 只加stack里有的，这个是个edge case，从output上完全看不出来，看了答案caizhidao\r\n\r\n## 代码\r\n`  int stack[];\r\n    int last_index;\r\n\r\n    public CustomStack(int maxSize) {\r\n        //List<Integer> stack = new ArrayList<>();\r\n        stack = new int[maxSize];\r\n        last_index = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(last_index == (stack.length-1)){\r\n            return;\r\n        }\r\n        last_index++;\r\n        stack[last_index]=x;\r\n        \r\n    }\r\n    \r\n    public int pop() {\r\n        if(last_index == -1){\r\n            return -1;\r\n        }\r\n        int result = stack[last_index];\r\n        last_index--;\r\n        return result;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i=0; i<k; i++){\r\n            if(i<=last_index){\r\n                stack[i]+=val;\r\n            }\r\n            \r\n        }\r\n    }\r\n`\r\n## 复杂度\r\n时间 push popO(1), inc O(n)\r\n空间 O(1) （这个不确定）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840390737","body":"## 思路\r\n借鉴答案还写了1个小时。。\r\n本来想直接loop一遍，然后遇到“[” 开始存repeatstring，遇到\"]\"停下来，按照数字重复几次，但是忽略了套娃情况 3[a2[c]\r\n借鉴了答案以后，用stack, \r\n遇到数字不知道有几位，先暂时保存下来。\r\n遇到“[”先把数字push上去，再push \"[\"\r\n遇到“]”，开始从stack pop，主要目的是把需要repeat的string pop出来，然后按照repeat time 重复，并最后把repeat过的string push到stack上。\r\n所有string s loop完了后，开始把完整的string pop出来\r\n \r\n## 代码\r\n`java\r\n\r\npublic String decodeString(String s) {\r\n        int repeat_time =0;\r\n        \r\n        Stack<String> stack = new Stack<>();\r\n        StringBuilder result =new StringBuilder();\r\n        for(int i=0; i< s.length(); i++){\r\n            char curr = s.charAt(i);\r\n            if(Character.isDigit(curr)){\r\n                repeat_time = repeat_time*10+ (curr-'0');\r\n                \r\n            }else if(curr =='[' ){\r\n                stack.push(String.valueOf(repeat_time) );\r\n                stack.push(\"[\");\r\n                repeat_time=0;\r\n\r\n            }else if(curr ==']'){\r\n                StringBuilder stringBuilder = new StringBuilder();\r\n                StringBuilder repeatString =new StringBuilder();\r\n                String temp = stack.pop();\r\n                while(temp != \"[\" &&stack.size()>0){\r\n                    stringBuilder.append(temp);\r\n                    temp = stack.pop();\r\n                }\r\n\r\n                repeat_time = Integer.parseInt(stack.pop());\r\n                for(int j =0; j<repeat_time; j++){\r\n                    repeatString.append(stringBuilder.toString());\r\n                }\r\n                stack.push(repeatString.toString());\r\n                repeat_time =0;\r\n            }else{\r\n                stack.push(String.valueOf(curr));\r\n            }\r\n        }\r\n        while(!stack.isEmpty()){\r\n            result.append(stack.pop());\r\n        }\r\n        return result.reverse().toString();\r\n    }\r\n`\r\n\r\n## 复杂度\r\n时间 O(N) N=length of String s\r\n空间 O(N)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840984686","body":"## 思路\r\n\r\n用arraylist代表queue，然后用top_index来keep track到哪里了\r\n\r\n## 代码\r\n`java\r\n    List<Integer> queue;\r\n    int top_index;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        queue =new ArrayList<Integer>();\r\n        top_index =0;\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        queue.add(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        int temp = queue.get(top_index);\r\n        top_index++;\r\n        return temp;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        return queue.get(top_index);\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return top_index == queue.size();\r\n    }\r\n`\r\n## 复杂度\r\n时间 O(1)\r\n空间 O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liucy0417":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836309752","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n## 前置知识\r\n\r\n- 数组\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n- 从低位相加，组成一个新的数组\r\n\r\n## 关键点\r\n\r\n-  进位问题\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int l = num.length;\r\n        int sum = 0;\r\n        List<Integer> arr = new ArrayList<>();\r\n        for(int i = l - 1; i>=0; i--) {\r\n            sum = num[i] + k % 10;\r\n            if(sum >= 10) {\r\n                sum =sum - 10;\r\n                k = k + 10;\r\n            }\r\n            arr.add(sum);\r\n            k = k / 10;\r\n        }\r\n        while(k != 0) {\r\n            arr.add(k % 10);\r\n            k = k / 10;\r\n        }\r\n        Collections.reverse(arr);\r\n        return arr; \r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。一个for循环，时间复杂度：$O(n)$，开辟了一个新的数组内存，空间复杂度：$O(n)$。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837680823","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 字符串、数组\r\n\r\n## 思路\r\n- 对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\r\n\r\n## 关键点\r\n\r\n-  从左向右、从右向左分别遍历一遍，找出较小的值\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] res = new int[length];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n        for(int i = 0; i < length; i++) {\r\n            if(s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = i - prev;\r\n        }\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for(int i = length - 1; i >=0; i--) {\r\n            if(s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = Math.min(res[i], prev - i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n\r\n- 时间复杂度：O(n) ，n为数组长度 \r\n- 空间复杂度：O(n) ， 新数组res[]\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839798688","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 栈\r\n\r\n## 思路\r\n\r\n-  可以发现题目要求我们实现的 push、pop 和 inc 三个功能中，前两个功能就是普通的栈所具有的功能，为什么普通的栈没有 inc 功能呢？因为普通的栈只有栈顶元素是「可见」的，所以要实现的这个功能，我们就要让栈中的所有元素「可见」。\r\n\r\n使用数组模拟栈，用一个变量 top 来记录当前栈顶的位置。\r\n\r\n对于 push 操作，首先判断当前元素的个数是否达到上限，如果没有达到，就把 top 后移一个位置并添加一个元素。\r\n\r\n对于 pop 操作，首先判断当前栈是否为空，非空返回栈顶元素并将 top 前移一位，否则返回 -1−1。\r\n\r\n对于 inc 操作，直接对栈底的最多 k 个元素加上 val。\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n时间复杂度：初始化（构造函数）、push 操作和 pop 操作的渐进时间复杂度为 O(1)，inc 操作的渐进时间复杂度为 O(k)。\r\n\r\n空间复杂度：这里用到了一个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为 O(maxSize)。\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"javanlu123":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836346588","body":"# 思路\r\n1.对每个分位进行叠加（注意进位以及分位存在判断的条件）\r\n2.最后一个进位的判断\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        // 这是一个典型的使用数组（字符串）的加法魔板\r\n        // 使用双向链表储存结果集\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int len = num.length - 1;\r\n        // 定义进位,初始默认为0\r\n        int carry = 0;\r\n        // 进行循环判断\r\n        // 数组下标以0开始，k以0为分界点\r\n        while(len>=0||k!=0){\r\n            // 定义数组num和k 的每个分位\r\n            int x = len>=0 ? num[len] : 0;\r\n            int y = k!=0 ? k%10 : 0;\r\n            int sum  = x + y + carry;\r\n            // 存入双向链表中\r\n            res.addFirst(sum % 10);\r\n            // 更新进位\r\n            carry = sum / 10;\r\n            // 分位进行移动\r\n            len--;\r\n            k /=10;\r\n        }\r\n        // 若最后的进位不为0，则头部补充\r\n        if(carry!=0){\r\n            res.addFirst(carry);\r\n        }\r\n        // 返回结果集\r\n        return res;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837614873","body":"# 思路1\r\n- 暴力解法\r\n把包含字符c的下标储存在零时数组，再遍历原有数组，与零时数组进行比较（取距离最小值）\r\n# 代码\r\n- Java\r\n~~~java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        int[] temp = new int[len];\r\n        int x = 0;\r\n        // 把包含字符c的下标储存在零时数组\r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i)==c){\r\n                temp[x++] = i;\r\n            }\r\n        }\r\n        // 在原字符串中与零时数组进行比较\r\n        int min = len;\r\n        for(int i = 0; i < len; i++){\r\n            // 这里使用x，x是有效位数\r\n            for(int j = 0; j < x; j++){\r\n                min = Math.min(min,Math.abs(i-temp[j]));\r\n            }\r\n            res[i] = min;\r\n//            每次都要重置min值\r\n            min = len;\r\n        }\r\n        return res;\r\n\r\n    }\r\n\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度o(N^2)\r\n- 空间复杂度o(N)\r\n\r\n\r\n# 思路2\r\n- 正反向数组遍历\r\n正向遍历，寻找每个位置到最近的c的最小值（向右搜索），反向遍历，则是向左搜索，更新每个位置到最近的c的最小值\r\n# 代码\r\n- Java\r\n~~~java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        // 使用正向、反向遍历法\r\n        int len = s.length();\r\n        // 定义结果数组\r\n        int[] res = new int[len];\r\n\r\n        // 正向遍历，向右搜索\r\n        // 定义一个标识变量prev，用于标记距离\r\n        int prev = -100000;\r\n        for(int i = 0; i < len; i++){\r\n            // 发现目标字符c，则prev标记为当前的i\r\n            if(s.charAt(i)==c)   prev = i;\r\n            // 标记当前位置距离\r\n            res[i] = i - prev;\r\n        }\r\n        // 反向遍历，向左搜索\r\n        // prev标记为 100000\r\n        prev = 100000;\r\n        for(int i = len - 1; i >= 0; i--){\r\n            // 发现目标字符c，则prev标记为当前的i\r\n            if(s.charAt(i)==c)   prev = i;\r\n            // 使用min函数更新当前位置距离\r\n            res[i] = Math.min(res[i],prev - i);\r\n        }\r\n        // 返回结果集\r\n        return res;\r\n    }\r\n\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度o(N)\r\n- 空间复杂度o(N)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837614873","body":"# 思路1\r\n- 暴力解法\r\n把包含字符c的下标储存在零时数组，再遍历原有数组，与零时数组进行比较（取距离最小值）\r\n# 代码\r\n- Java\r\n~~~java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        int[] temp = new int[len];\r\n        int x = 0;\r\n        // 把包含字符c的下标储存在零时数组\r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i)==c){\r\n                temp[x++] = i;\r\n            }\r\n        }\r\n        // 在原字符串中与零时数组进行比较\r\n        int min = len;\r\n        for(int i = 0; i < len; i++){\r\n            // 这里使用x，x是有效位数\r\n            for(int j = 0; j < x; j++){\r\n                min = Math.min(min,Math.abs(i-temp[j]));\r\n            }\r\n            res[i] = min;\r\n//            每次都要重置min值\r\n            min = len;\r\n        }\r\n        return res;\r\n\r\n    }\r\n\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度o(N^2)\r\n- 空间复杂度o(N)\r\n\r\n\r\n# 思路2\r\n- 正反向数组遍历\r\n正向遍历，寻找每个位置到最近的c的最小值（向右搜索），反向遍历，则是向左搜索，更新每个位置到最近的c的最小值\r\n# 代码\r\n- Java\r\n~~~java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        // 使用正向、反向遍历法\r\n        int len = s.length();\r\n        // 定义结果数组\r\n        int[] res = new int[len];\r\n\r\n        // 正向遍历，向右搜索\r\n        // 定义一个标识变量prev，用于标记距离\r\n        int prev = -100000;\r\n        for(int i = 0; i < len; i++){\r\n            // 发现目标字符c，则prev标记为当前的i\r\n            if(s.charAt(i)==c)   prev = i;\r\n            // 标记当前位置距离\r\n            res[i] = i - prev;\r\n        }\r\n        // 反向遍历，向左搜索\r\n        // prev标记为 100000\r\n        prev = 100000;\r\n        for(int i = len - 1; i >= 0; i--){\r\n            // 发现目标字符c，则prev标记为当前的i\r\n            if(s.charAt(i)==c)   prev = i;\r\n            // 使用min函数更新当前位置距离\r\n            res[i] = Math.min(res[i],prev - i);\r\n        }\r\n        // 返回结果集\r\n        return res;\r\n    }\r\n\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度o(N)\r\n- 空间复杂度o(N)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840536952","body":"# 思路\r\n方法一：使用辅助栈（默写k神代码）\r\n本题难点在于括号内嵌括号，需要从内向外生成于拼接字符串，和栈的先入后出特性一致\r\n- 构建辅助栈，遍历s中每个字符c\r\n   - c为数字，转化为int的数字multi（用于倍数计算）\r\n   - c为字母，在res（零时字符串）尾部加c\r\n   - c为[，将multi和res入栈，后分别置空置0\r\n      - 记录此[ 前的零时结果res入栈，用于发现对应]后的拼接操作\r\n      - 记录此[ 前的multi倍数入栈，用于发现对应]后，获取multi*[....]字符串\r\n      - 进入到新的[后，res和multi重新记录\r\n   - 当c为]，出栈，拼接字符串res = last_res +cur_multi * res\r\n- 返回字符串res\r\n# Java代码\r\n~~~java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        // 方法一：使用辅助栈法\r\n        // 这是一个零时字符串\r\n       StringBuilder res = new StringBuilder(); \r\n    //    默认的数字倍数是0\r\n       int multi = 0;\r\n    //    定义储存数字倍数的双向链表\r\n       LinkedList<Integer> stack_multi = new LinkedList<>();\r\n    //    定义储存临时字符串的双向链表\r\n    LinkedList<String> stack_res = new LinkedList<>();\r\n    // 对字符串s进行逐个字符遍历\r\n    for(Character c : s.toCharArray()){\r\n        if(c == '['){\r\n            // 遇到 [  则将之前的数字倍数multi和临时字符串出入链表中\r\n            stack_multi.addLast(multi);\r\n            stack_res.addLast(res.toString());\r\n            // 重置数字倍数和零时字符串\r\n            multi = 0;\r\n            res = new StringBuilder();\r\n        }else if( c == ']'){\r\n            // 遇到 ] 则将数字倍数和零时字符串的尾端移除，并拼装字符串res\r\n            // 这是内层的零时字符串，用于字符串*倍数\r\n            StringBuilder tmp = new StringBuilder();\r\n            // 获取尾端的倍数\r\n            int cur_multi = stack_multi.removeLast();\r\n            // 进行内层字符*倍数=内层零时字符串\r\n            for(int i = 0; i < cur_multi; i++){\r\n                tmp.append(res);\r\n            }\r\n            // 内层零时字符串于外层res进行拼装\r\n            res = new StringBuilder(stack_res.removeLast()+tmp);\r\n\r\n        }else if(c>='0'&&c<='9'){\r\n            // 字符串可能超过10,  12 = multi * 10 + 2\r\n            multi = multi * 10 +Integer.parseInt(c+\"\");\r\n        }else{\r\n            // 遇到普通字符，则添加到零时字符串中\r\n            res.append(c);\r\n        }\r\n        \r\n    }\r\n    return res.toString();\r\n    }\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度：O（N）\r\n- 空间复杂度:  O（N）\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840920465","body":"# 思路\r\n- 使用两个栈s1和s2,\r\n- s1栈实际是倒序的队列，s2实际是正序的队列\r\n- 进队要保证s2是空的，出队要保证s1是空（这样才能实现最终结果是正序的队列）\r\n# Java代码\r\n~~~java\r\nclass MyQueue {\r\n\r\n    /** Initialize your data structure here. */\r\n\r\n    // 定义两个栈\r\n    Stack<Integer> s1 ;\r\n    Stack<Integer> s2 ;\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        while(!s2.isEmpty()){\r\n            // 若s2是不空，先把s2的元素弹入s1中\r\n            s1.push(s2.pop());\r\n        }\r\n        // s2为空了，可以进队了\r\n        s1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        while(!s1.isEmpty()){\r\n            // 若s1是不空，则说明可以进行出队操作\r\n            int x = s1.pop();\r\n            s2.push(x);\r\n        }\r\n        // 返回s2的栈顶元素（出队）\r\n        return s2.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        while(!s1.isEmpty()){\r\n          s2.push(s1.pop());\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        if(s1.isEmpty()&&s2.isEmpty()){\r\n            // s1和s2同时为空，那么队列就空\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度：O（N），每次都要倒腾栈中元素\r\n- 空间复杂度：O（N），申请了两个栈"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841587073","body":"# 思路\r\n使用单调栈\r\n- 排序块的定义：此块中最大数字为head，若此块后面数字都>=head,则此块为排序块\r\n- 非排序快内部进行合并操作，需要进行循环判断（弹栈）\r\n- 最后返回栈内个数（排序块的个数）\r\n# Java代码\r\n~~~java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        // 使用单调栈解决问题\r\n        /**\r\n        首先是排序块的概念，（后一个值>=前一个值，就会成立一个新的排序块）\r\n        否则，就要进行融合（内部分块），在内部分块的时候，需要进行判断分块里最大值临界点\r\n        （不可以大于上一个块内的max值，因为这会是一个新的排序块）\r\n        */\r\n\r\n        Stack<Integer> s = new Stack<>();\r\n        // 进行遍历判断(栈不空，并且后一个值<前一个值,则进入内部分块环节)\r\n        for(int num : arr)\r\n        if(!s.empty()&&num<s.peek()){\r\n            // 临时储存head值\r\n            int head = s.peek();\r\n            // 进行内部的循环分块\r\n            while(!s.empty()&&num<s.peek()){\r\n                // 把栈内元素弹出（因为在内部，这不是最大的max值）\r\n                s.pop();\r\n            }\r\n            // 将最大值head储存到栈中\r\n            s.push(head);\r\n\r\n        }else{\r\n            // 否则就是入栈，是一个新的排序块\r\n            s.push(num);\r\n        }\r\n\r\n        // 返回栈内元素个数\r\n        return s.size();\r\n\r\n    }\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度：O（N）\r\n- 空间复杂度：O（N）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BryanMiracle":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836356594","body":"**思路**\r\n新建一个链表，存储各位相加的结果。从低位到高位，逐一相加，并将结果返回\r\n\r\n**代码**\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res=new ArrayList<Integer>();\r\n        int n=num.length;\r\n        int sum=0,curr=0,i=n-1;\r\n        while(i>=0 || k!=0){\r\n            int x=i>=0?num[i]:0;\r\n            int y=k!=0?k%10:0;\r\n            sum=x+y+curr;\r\n            curr=sum/10;\r\n            k=k/10;\r\n            i--;\r\n            res.add(0,sum%10);\r\n        }\r\n        if(curr!=0){\r\n            res.add(0,curr);\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837667625","body":"**思路**\r\n针对给定字符串中的每个字符，试图找出距离其 向左/向右 离它最近的字符C的距离 ，并选择最近的距离\r\n-- 从左向右遍历，记录上一个字符C出现的位置 prev，此时距离就是：i-prev\r\n-- 从右向左遍历，记录上一个字符C出现的位置prev，此时距离就是 prev-i\r\n-- 取较小值\r\n**代码**\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n=s.length();\r\n        int[] ans=new int[n];\r\n        int prev=Integer.MIN_VALUE/2;\r\n        //从左向右遍历\r\n        for(int i=0;i<n;i++){\r\n            if(s.charAt(i)==c){\r\n                prev=i;\r\n            }\r\n            ans[i]=i-prev;\r\n        }\r\n        //从右向左遍历\r\n        prev=Integer.MAX_VALUE/2;\r\n        for(int i=n-1;i>=0;i--){\r\n            if(s.charAt(i)==c){\r\n                prev=i;\r\n            }\r\n            ans[i]=Math.min(ans[i],prev-i);\r\n        }\r\n        return ans;\r\n\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：（N）\r\n-- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839614668","body":"**思路**\r\n借用数组模拟栈\r\n**代码**\r\n```\r\nclass CustomStack {\r\n    //数组模拟栈\r\n    int[] stack;\r\n    int top;//记录栈顶元素\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack=new int[maxSize];\r\n        top=-1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top!=stack.length-1){\r\n            top++;\r\n            stack[top]=x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top==-1){\r\n            return -1;\r\n        }\r\n        top--;\r\n        return stack[top+1];\r\n\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int size=Math.min(k,top+1);\r\n        for(int i=0;i<size;i++){\r\n            stack[i]+=val;\r\n        }\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：push/pop:O(1) , increment: O（k）\r\n-- 空间复杂度：O（maxSize）\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840640094","body":"**思路**\r\n构建辅助栈，遍历字符串s中每个字符，分情况处理\r\n**代码**\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        int multi = 0;\r\n        LinkedList<Integer> stack_multi = new LinkedList<>();\r\n        LinkedList<String> stack_res = new LinkedList<>();\r\n        for(Character c : s.toCharArray()) {\r\n            if(c == '[') {\r\n                stack_multi.addLast(multi);\r\n                stack_res.addLast(res.toString());\r\n                multi = 0;\r\n                res = new StringBuilder();\r\n            }\r\n            else if(c == ']') {\r\n                StringBuilder tmp = new StringBuilder();\r\n                int cur_multi = stack_multi.removeLast();\r\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\r\n                res = new StringBuilder(stack_res.removeLast() + tmp);\r\n            }\r\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\r\n            else res.append(c);\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：O(N)\r\n-- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841093548","body":"**思路**\r\n双栈：进栈：**inStack**、出栈：**outStack**\r\n**push()** 时，直接压入inStack栈：inStack.push\r\n**pop()/peek()** 时，要判断outStack栈中出否还有元素：如果还有，就直接处理outStack；\r\n如果没有，就先把inStack栈里所有元素**一次性全部**弹出，并**一次性全部**压入outStack栈中。然后对outStack栈进行相应操作。\r\n**empty()** 时，只有两个栈都为空时，此时队列才为空\r\n\r\n**代码**\r\n```\r\nclass MyQueue {\r\n    private Stack<Integer> inStack;\r\n    private Stack<Integer> outStack;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        inStack=new Stack<Integer>();\r\n        outStack=new Stack<Integer>();\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        inStack.push(x);\r\n\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        //如果outStack为空，则将inStack栈全部弹出并压入outStack栈中，然后弹出\r\n        if(outStack.isEmpty()){\r\n            while(!inStack.isEmpty()){\r\n                outStack.push(inStack.pop());\r\n            }\r\n        }\r\n        return outStack.pop();\r\n        \r\n\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(outStack.isEmpty()){\r\n            while(!inStack.isEmpty()){\r\n                outStack.push(inStack.pop());\r\n            }\r\n        }\r\n        return outStack.peek();\r\n        }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：O(1)\r\n-- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841679831","body":"**思路**\r\n前后两次遍历：\r\n先遍历一遍，记录到当前数为止的最大值head；\r\n然后从后往前遍历，如果遍历过的arr数组里的最小值比前一个分块的最大值head要大，块的数量 + 1；\r\n遍历时要维护一下遍历过的arr里的最小值\r\n**代码**\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] head = new int[arr.length];\r\n        head[0] = arr[0];\r\n        for(int i = 1; i < arr.length; i++){\r\n            head[i] = Math.max(head[i - 1], arr[i]);\r\n        }\r\n        int tail = Integer.MAX_VALUE, res = 0;\r\n        for(int i = arr.length - 1; i >= 0; i--){\r\n            if(tail >= head[i]){\r\n                res++;\r\n            }\r\n            tail = Math.min(tail, arr[i]);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：O(N)\r\n-- 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DoubleW2w":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836444832","body":"emmmmm，加油，这次看了答案，下次争取不看答案！！！！\r\n不知道空间复杂度怎么分析，就删除了。\r\n## 思路\r\n\r\n加法主要就是判断进位的问题。相加的选择，我们可以从低位往高位相加\r\n\r\n1. 如果没有产生进位，那什么情况才停止相加呢？比如 $123+23=146$和 $123+1234=1367$\r\n2. 如果产生进位，但没有发生数组越界的情况，比如$123+37=160 $和$123+1137=1260$\r\n3. 如果产生进位，但发生了数组越界呢？比如$999+1=1000$\r\n\r\n---\r\n\r\n第一种情况：当我们低位往高位相加的时候，`k=0`的时候或者`遍历完num`，我们就停止了相加。\r\n\r\n第二种情况：就在第一种情况的基础上，在中间增加个进位的处理，其停止的情况还是`k=0`的时候或者`遍历完num`。\r\n\r\n第三种情况：就在第二种情况的基础上，最后增加高位还有进位的处理情况。而停止还是一样的\r\n\r\n因此总结一下：\r\n\r\n来自题解区的一位大佬\r\n\r\n```java\r\n<公式>\r\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\r\n\r\n<加法模板>    \r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code1:\r\n\r\n```java\r\n//官方题解\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //从低位往高位相加\r\n        int n = num.length;\r\n        List<Integer> res = new ArrayList<>();\r\n        //遍历num，但k也在发生变化\r\n        for(int i = n-1;i >= 0; i--){\r\n            int sum = num[i] + k%10;\r\n            k /=10;\r\n            if(sum >= 10){\r\n                //把进位放在k上\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        //如果num的位数>k的位数，此时的k是为0或者是最高位的进位\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n\r\nJava Code2:\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k){\r\n        //当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\r\n        int n = num.length;\r\n        List<Integer> res = new ArrayList<>();\r\n        int carry =0, sum =0,index = n-1;\r\n        while(index >=0 || k!=0){\r\n            // num的当前位\r\n            int x = index >=0 ? num[index] : 0;\r\n            // K的当前位\r\n            int y = k != 0 ? k%10 : 0;\r\n\r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            k = k / 10;\r\n            index --;\r\n            res.add(sum % 10);\r\n        }\r\n        if (carry != 0){\r\n            res.add(carry);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839873063","body":"## 思路\r\n\r\n1. 用数组来模拟栈\r\n2. 解决`increment`功能\r\n   - 第一种：遍历循环，在数组里面提前`increment`，时间复杂度$O(n)$\r\n   - 第二种：只在**要pop出来的元素**`increment`，时间复杂度$O(1)$\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n/**\r\n * int[] stack: 初始化的栈\r\n * int top：栈顶位置\r\n * int[] add: 增量数组\r\n */\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n    int[] add;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        add = new int[maxSize];\r\n        top = -1;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if(top!= stack.length-1){\r\n            ++top;\r\n            stack[top]=x;\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if(top!=-1){\r\n            top--;\r\n        }else{\r\n            return -1;\r\n        }\r\n        return stack[top+1];\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int num = Math.min(k,top+1);\r\n        for(int i=0;i<num;i++){\r\n            stack[i] +=val;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 maxSize 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(maxSize)$\r\n\r\n---\r\n\r\nJava Code:\r\n\r\n```java\r\n/**\r\n * int[] stack: 初始化的栈\r\n * int top：栈顶位置\r\n * int[] add: 增量数组\r\n */\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n    int[] add;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        add = new int[maxSize];\r\n        top = -1;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if(top!= stack.length-1){\r\n            ++top;\r\n            stack[top]=x;\r\n        }\r\n    }\r\n\r\n    public int pop(){\r\n        if(top==-1){\r\n            return -1;\r\n        }\r\n        int res = stack[top] + add[top];\r\n        if(top!=0){\r\n            add[top-1] += add[top];\r\n        }\r\n        add[top]=0;\r\n        top--;\r\n        return res;\r\n    }\r\n\r\n    //优化inc操作\r\n    public void increment(int k, int val) {\r\n        //k：要操作的元素个数 top+1:栈的元素个数\r\n        //limitIndex为要操作的最上面元素下标（不一定是栈顶元素）\r\n        int limitIndex = Math.min(k-1,top);\r\n        if(limitIndex>=0){\r\n            add[limitIndex]+=val;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 maxSize 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(maxSize)$"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841322477","body":"## 思路\r\n\r\n1. 摊还分析\r\n\r\n最坏情况下的操作一旦发生了一次，那么在未来很长一段时间都不会再次发生，这样就会均摊每次操作的代价。\r\n\r\n2. 利用另外一个栈来辅助，用来翻转栈的元素顺序，就可以实现出栈时的时间复杂度为O（1）\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> pushStack = new Stack<>();\r\n    Stack<Integer> popStack = new Stack<>();\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        while(!popStack.isEmpty()){\r\n            pushStack.push(popStack.pop());\r\n        }\r\n        pushStack.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        while(!pushStack.isEmpty()){\r\n            popStack.push(pushStack.pop());\r\n        }\r\n        return popStack.pop();\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        while(!pushStack.isEmpty()){\r\n            popStack.push(pushStack.pop());\r\n        }\r\n        return popStack.peek();\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return popStack.isEmpty() && pushStack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841680338","body":"## 思路\r\n\r\n第一种思路：单调栈\r\n\r\n一直在寻找下一个比当前小的元素，当找到了以后，就进行融合。\r\n\r\n**栈存储的每一个元素就代表一个块，而栈里面的每一个元素的值就是块的最大值**\r\n\r\n\r\n\r\n第二种思路：计数\r\n\r\n**如果两个数组的计数信息是一致的，那么两个数组排序后的结果也是一致的。**\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJavaCode：\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr){\r\n        LinkedList<Integer> stack = new LinkedList<Integer>();\r\n        //遍历每个数字num\r\n        for (int num : arr) {\r\n            // 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\r\n            // 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\r\n            if (!stack.isEmpty() && num < stack.getLast()) {\r\n                // 我们需要将融合后的区块的最大值重新放回栈\r\n                // 而 stack 是递增的，因此 stack[-1] 是最大的\r\n                int head = stack.removeLast();\r\n                // 维持栈的单调递增\r\n                //判断加入 num 需要合并的所有排序块，每pop()一个head代表合并一个块\r\n                while (!stack.isEmpty() && num < stack.getLast()) {\r\n                    stack.removeLast();\r\n                }\r\n                //将head重新加入，作为新排序块的最大值\r\n                stack.addLast(head);\r\n                //当栈为空或者num>=栈顶值时,把num压入栈---->加入了单个元素的排序块[num]\r\n            }else {\r\n                stack.addLast(num);\r\n            }\r\n        }\r\n        // 栈存的是块信息，因此栈的大小就是块的数量\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n---\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) nonzero--;\r\n            if (count.get(x) == 1) nonzero++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) nonzero++;\r\n            if (count.get(y) == 0) nonzero--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n        return ans;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(n)$\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ARe99s":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836448740","body":"**思路**\r\n直接把K加到A上\r\n**代码 python**\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        i = len(A) - 1\r\n        while K:\r\n            A[i] += K\r\n            K, A[i] = A[i] // 10, A[i] % 10\r\n            i -= 1\r\n            if i < 0 and K:\r\n                A.insert(0,0)\r\n                i = 0\r\n        return A\r\n```\r\n**时间复杂度**\r\nO(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"FontEndArt":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836454805","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n## 思路\r\n循环判断k，k存在即代表还需要进行加法计算，每次加k的个数位，然后k抹去个数位的值，最后并判断是否有进一，有则k++。\r\n\r\n如果超出num的长度则使用unshift在数组首位增加。（其他语言如果没有动态数组的，可能需要预先申请足够的空间）\r\n\r\n## 关键点\r\n\r\n-  进一位的处理\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n    let i = num.length - 1\r\n    while (k > 0) {\r\n        let tmp = k % 10;\r\n        k = Math.floor((k - tmp) / 10)\r\n        if (i < 0) {\r\n            num.unshift(tmp)\r\n            // 注意是continue： [0], 10000\r\n            continue\r\n        }\r\n        // 注意是>=而不是>\r\n        if ((num[i] + tmp) >= 10) {\r\n            k++\r\n        }\r\n        num[i] = (num[i] + tmp) % 10\r\n        i--\r\n    }\r\n    return num\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838391375","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 正反遍历\r\n- Infinity\r\n\r\n## 思路\r\n正反遍历，注意res[i]初始值为Infinity\r\n\r\n> 也可以双指针, 考虑正反遍历或单次遍历，只不过单次遍历需要相当于滑动窗口，然后每次指针移动都要去判断赋值\r\n \r\n> 朋友用的中心扩展法也不是不行，只不过复杂度稍微高了一点，需要双端边界都要到头才可以。\r\n> range(0,s.length)或者匹配到与c的字符满足其一是单端边界结束调节。\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n    let cIndex = -1;\r\n    const res = Array(s.length).fill(Infinity)\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] !== c && cIndex < 0) {\r\n            continue\r\n        }\r\n        if (s[i] === c) {\r\n            cIndex = i\r\n            res[i] = 0\r\n        } else {\r\n            res[i] = Math.min(i - cIndex, res[i])\r\n        }\r\n    }\r\n    cIndex = -1;\r\n    for (let i = s.length - 1; i >= 0; i--) {\r\n        if (s[i] !== c && cIndex < 0) {\r\n            continue\r\n        }\r\n        if (s[i] === c) {\r\n            cIndex = i\r\n        } else {\r\n            res[i] = Math.min(cIndex - i, res[i])\r\n        }\r\n    }\r\n    return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839694826","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n## 思路\r\n\r\n利用数组\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n    this.arr = []\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n    if (this.arr.length < this.maxSize) {\r\n        this.arr.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n    let val = this.arr.pop()\r\n    return val === undefined ? -1 : val\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n    for (let i = 0; i < k && i < this.arr.length; i++) {\r\n        this.arr[i] += val\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n- push\r\n    - 时间复杂度：$O(1)$\r\n    - 空间复杂度：$O(1)$\r\n\r\n- pop\r\n    - 时间复杂度：$O(1)$\r\n    - 空间复杂度：$O(1)$\r\n\r\n- increment\r\n    - 时间复杂度：$O(n)$ n为max(k, this.arr.length)\r\n    - 空间复杂度：$O(1)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840406782","body":"\r\n## 题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n\r\n\r\n示例 3：\r\n\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n\r\n\r\n示例 4：\r\n\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n\r\n```\r\n\r\n## 思路\r\n\r\ndfs, 关键点看代码注释。\r\n> repeat部分其他语言可以用伪代码`let j = 0; while(j<(num||1)){str+=tmp}`或`for i in range(num||1)`替代\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s, i = 0) {\r\n    let num = '';\r\n    let str = '';\r\n    while (i < s.length) {\r\n        if (/\\d/.test(s[i])) {\r\n            num += s[i]\r\n            i++\r\n        }\r\n        if (/[a-z]/.test(s[i])) {\r\n            str += s[i]\r\n            i++\r\n        }\r\n        if ('[' === s[i]) {\r\n            // 跳过已经经过的 ']'\r\n            let [tmp, nextIndex] = decodeString(s, i + 1)\r\n            // '进行重复'\r\n            str += tmp.repeat(num || 1)\r\n            i = nextIndex\r\n            num = ''\r\n        }\r\n        // 只会出现在递归的深层中\r\n        if (']' === s[i]) {\r\n            return [str, i + 1]\r\n        }\r\n    }\r\n    return str\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$ n为s.length\r\n- 空间复杂度：$O(n)$\r\n> 额外的空间\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Siomarry":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836474356","body":"- 思路\r\n每次取出K的最后一位以及数组的最后一位进行相加，并且依次进位相加.\r\n\r\n- 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        //建立一个vector<int> K的数组，然后两个vector进行相加.\r\n        queue<int> Kdigit;\r\n        while(k){\r\n            Kdigit.push(k % 10);k = k / 10;\r\n        }\r\n        //第二步，将栈中的元素和num进行相加.\r\n        deque<int> ans;int endpoint = ans.size() - 1;\r\n        //设置一个最大长度的ans.\r\n        int numpoint = num.size() - 1;int plus = 0;\r\n        while(!Kdigit.empty() && numpoint >= 0){\r\n\r\n            ans.push_front((plus + Kdigit.front() + num[numpoint]) % 10);\r\n            plus = (plus + Kdigit.front() + num[numpoint]) / 10;\r\n            Kdigit.pop();numpoint--;endpoint--;\r\n        }\r\n        //结束时判断最后的条件.\r\n        while(!Kdigit.empty()){  //若数字不为空\r\n            ans.push_front((plus + Kdigit.front()) % 10);\r\n            plus = (plus + Kdigit.front()) / 10;\r\n            Kdigit.pop();\r\n        }\r\n\r\n        while(numpoint >= 0){  //若原数组不为空\r\n            ans.push_front((plus + num[numpoint]) % 10);\r\n            plus = (plus + num[numpoint]) / 10;\r\n            numpoint--;\r\n        }\r\n        if(plus)\r\n            ans.push_front(plus);\r\n\r\n        vector<int> result(ans.begin(),ans.end());\r\n        return result;\r\n    }\r\n};\r\n```\r\n- 时间复杂度\r\n    O(max(n，logk))\r\n\r\n- 空间复杂度\r\n    O(max(n,logk))\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838292817","body":"- 思路\r\n对于选定的字符，通过左右双指针来寻找贪心寻找距离最近的字符.\r\n\r\n- 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int ComputerDis(string s,int current,char c){\r\n        //在s中计算c离current最近的字符.\r\n        if(s[current] == c)\r\n            return 0;\r\n        int left = current - 1;int right = current + 1;\r\n        while(left >=0 && right <= s.size() - 1){\r\n            if(s[left] == c || s[right] == c){\r\n                return right - current;\r\n            }\r\n            else{\r\n                left--;right++;\r\n            }\r\n        }\r\n        while(left >= 0){\r\n            if(s[left] == c){\r\n                return current - left;\r\n            }\r\n            else\r\n                left--;\r\n        }\r\n        while(right <= s.size() - 1){\r\n            if(s[right] == c){\r\n                return right - current;\r\n            }else\r\n                right++;\r\n        }\r\n        return -1;\r\n    }\r\n    vector<int> shortestToChar(string s, char c){\r\n        vector<int> ans;\r\n        for(int i = 0;i<s.size();i++){\r\n            ans.push_back(ComputerDis(s,i,c));\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n- 时间复杂度 O(n2)\r\n- 空间复杂度 O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839606626","body":"- 思路\r\n使用一个vector<int>进行模拟\r\n- 代码\r\n```c++\r\nclass CustomStack {\r\n    vector<int> stackvector;\r\n    int top = -1;\r\n    int maxSize = 0;\r\npublic:\r\n    CustomStack(int maxSize){\r\n        this->maxSize = maxSize;\r\n        top = -1;\r\n    }\r\n    void push(int x){\r\n        if(top != maxSize - 1){\r\n            stackvector.push_back(x);\r\n            top++;\r\n        }\r\n    }\r\n\r\n    int pop(){\r\n        if(top == -1)\r\n            return -1;\r\n        int result = stackvector[top--];\r\n        stackvector.pop_back();\r\n        return result;\r\n    }\r\n\r\n    void increment(int k, int val) {\r\n        for(int i = 0;i< min(k,top + 1);i++){\r\n            stackvector[i]+=val;\r\n        }\r\n    }\r\n};\r\n```\r\n- 时间复杂度: O(1)\r\n- 空间复杂度: O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miqpalzm":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836476818","body":"public class Solution {\r\n    public IList<int> AddToArrayForm(int[] num, int k) {\r\n        var kLen = k.ToString().Length;\r\n            int[] kArr = new int[kLen];\r\n            for (var i = kLen - 1; i >= 0; i--)\r\n            {\r\n                if (k / 10 > 0)\r\n                {\r\n                    kArr[i] = k % 10;\r\n                    k = k / 10;\r\n                }\r\n                else\r\n                {\r\n                    kArr[i] = k;\r\n                }\r\n            }\r\n\r\n            var addExtra = false;\r\n            var nLen = num.Length;\r\n            var list = new List<int>();\r\n            for (int i = nLen - 1, j = kLen - 1; i >= 0 || j >= 0; i--, j--)\r\n            {\r\n                var nValue = (i > nLen - 1 || i < 0) ? 0 : num[i];\r\n                var kValue = (j > kLen - 1 || j < 0) ? 0 : kArr[j];\r\n                var sum = nValue + kValue + (addExtra ? 1 : 0);\r\n                if (sum >= 10)\r\n                {\r\n                    addExtra = true;\r\n                    sum = sum % 10;\r\n                }\r\n                else\r\n                {\r\n                    addExtra = false;\r\n                }\r\n\r\n                list.Add(sum);\r\n            }\r\n\r\n            if (addExtra)\r\n            {\r\n                list.Add(1);\r\n            }\r\n            list.Reverse();\r\n\r\n            return list;\r\n    }\r\n}"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838451850","body":"语言：C#\r\n\r\npublic class Solution {\r\n    public int[] ShortestToChar(string s, char c) {\r\n        var charArr = s.ToCharArray();\r\n            var intArr = new int[charArr.Length];\r\n\r\n            int lastIndex = -1, aheadIndex = s.IndexOf(c);\r\n            for (var i = 0; i < charArr.Length; i++)\r\n            {\r\n                if (i == aheadIndex)\r\n                {\r\n                    lastIndex = aheadIndex;\r\n                    charArr[lastIndex] = '#';\r\n                    aheadIndex = new string(charArr).IndexOf(c);\r\n                }\r\n                var left = Math.Abs(i - (lastIndex == -1 ? aheadIndex : lastIndex));\r\n                var right = Math.Abs((aheadIndex == -1 ? lastIndex : aheadIndex) - i);\r\n                intArr[i] = left < right ? left : right;\r\n            }\r\n\r\n            return intArr;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839758358","body":"c#\r\n\r\npublic class CustomStack {\r\n\r\n    private int[] intArr;\r\n    private int index;\r\n\r\n    public CustomStack(int maxSize) {\r\n        intArr = new int[maxSize];\r\n        index = 0;\r\n    }\r\n    \r\n    public void Push(int x)\r\n        {\r\n            if (index == intArr.Length)\r\n            {\r\n                return;\r\n            }\r\n\r\n            intArr[index] = x;\r\n            index++;\r\n        }\r\n\r\n        public int Pop()\r\n        {\r\n            if (index == 0)\r\n            {\r\n                return -1;\r\n            }\r\n\r\n            index--;\r\n            var temp = intArr[index];\r\n            intArr[index] = 0;\r\n            return temp;\r\n        }\r\n\r\n        public void Increment(int k, int val)\r\n        {\r\n            var max = k <= intArr.Length ? k : intArr.Length;\r\n            for (var i = 0; i < max; i++)\r\n            {\r\n                if (intArr[i] == 0)\r\n                {\r\n                    break;\r\n                }\r\n\r\n                intArr[i] += val;\r\n            }\r\n        }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840598152","body":"c#\r\n\r\npublic class Solution {\r\n    public string DecodeString(string s)\r\n        {\r\n            var charArr = s.ToCharArray();\r\n            var str = \"\";\r\n            int temp = 0, num = 0, start = 0, symbol = 0, symbol2 = 0;\r\n            for (int i = 0; i < charArr.Length; i++)\r\n            {\r\n                if (!int.TryParse(charArr[i].ToString(), out temp))\r\n                {\r\n                    if (charArr[i] != '[' && charArr[i] != ']' && symbol == 0)\r\n                    {\r\n                        str += s.Substring(i, 1);\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    if (num == 0)\r\n                    {\r\n                        num = temp;\r\n                        start = i + 2;\r\n                    }\r\n                    else if (symbol == 0)\r\n                    {\r\n                        num = int.Parse(num + \"\" + temp);\r\n                        start++;\r\n                    }\r\n                }\r\n\r\n                switch (charArr[i])\r\n                {\r\n                    case '[':\r\n                        symbol++;\r\n                        break;\r\n                    case ']':\r\n                        symbol2++;\r\n                        break;\r\n                }\r\n\r\n                if (symbol > 0 && symbol == symbol2)\r\n                {\r\n                    var subs = s.Substring(start, i - start);\r\n                    for (int j = 0; j < num; j++)\r\n                    {\r\n                        str += subs;\r\n                    }\r\n                    num = 0;\r\n                    symbol = 0;\r\n                    symbol2 = 0;\r\n                }\r\n            }\r\n\r\n            if (str.Contains('['))\r\n            {\r\n                return DecodeString(str);\r\n            }\r\n            else\r\n            {\r\n                return str;\r\n            }\r\n\r\n        }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841234671","body":"c#\r\n\r\npublic class MyQueue {\r\n\r\n    public List<int> intList;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        intList = new List<int>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void Push(int x) {\r\n        intList.Add(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int Pop() {\r\n        int e = intList[0];\r\n        intList.RemoveAt(0);\r\n        return e;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int Peek() {\r\n        return intList[0];\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public bool Empty() {\r\n        return intList.Count == 0;\r\n    }\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"15399618796":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836482820","body":"思路：逐位相加再插入到一个新的数组中\r\n\r\n`class Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n       vector<int> res;\r\n       int a=0,sum=0,b=0;\r\n       for(int i=num.size()-1;i>=0;i--){\r\n           a=k%10;\r\n           k/=10;\r\n           sum=num[i]+a;\r\n           if(sum>=10){\r\n               sum-=10;\r\n               k++;\r\n           }\r\n           res.push_back(sum);\r\n       }\r\n       while(k){\r\n           b=k%10;\r\n           k/=10;\r\n           res.push_back(b);\r\n       }\r\n       reverse(res.begin(),res.end());\r\n       \r\n       return res;\r\n    }\r\n};`\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838288962","body":"思路：分别从前到后，从后到前遍历两次数组\r\n\r\n`class Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res(s.size(),0);\r\n        int size=s.size();\r\n\r\n        int prev=INT_MIN/2;\r\n        for(int i=0;i<size;i++){\r\n            if(s[i]==c) prev=i;\r\n            res[i]=i-prev;\r\n        }\r\n\r\n        prev=INT_MAX/2;\r\n        for(int i=size-1;i>=0;i--){\r\n            if(s[i]==c) prev=i;\r\n            res[i]=min(res[i],prev-i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n};`\r\n\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839339769","body":"思路：用数组来模拟栈\r\n语言：c++\r\n\r\n`class CustomStack {\r\npublic:\r\n    int size=0,capacity=0;\r\n    vector<int> v;\r\n\r\n    CustomStack(int maxSize) {\r\n        capacity=maxSize;\r\n        v.resize(maxSize);\r\n        size=0;\r\n    }\r\n    \r\n    \r\n\r\n    void push(int x) {\r\n        if(size<capacity){\r\n            v[size]=x;\r\n             size++;\r\n        }\r\n       \r\n        return ;\r\n    }\r\n    \r\n    int pop() {\r\n        if(size==0) return -1;\r\n        size--;\r\n        return v[size];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int n=min(size,k);\r\n        for(int i=0;i<n;i++){\r\n            v[i]+=val;\r\n        }\r\n    }\r\n};`\r\n\r\n时间复杂度：O（1）和  O（n）\r\n空间复杂度：O（n）"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840934520","body":"思路：用两个栈来模拟队列\r\n语言： c++\r\n`class MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    stack<int> s1,s2;\r\n    MyQueue() {\r\n    }\r\n    \r\n    void pushStack(){\r\n        while(!s1.empty()){\r\n            s2.push(s1.top());\r\n            s1.pop();\r\n        }\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if(s2.empty()) pushStack();\r\n\r\n        int temp=s2.top();\r\n        s2.pop();\r\n        return temp;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if(s2.empty()) pushStack();\r\n        return s2.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return s1.empty()&&s2.empty();\r\n    }\r\n};`\r\n时间复杂度：O（1）和O（n）\r\n空间复杂度：O（n）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"st2yang":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836486673","body":"## 思路\r\n从右到左低位循环num，将其每一位与k相加，并依次进位。如果循环完k还有剩，要记得加上。\r\n\r\n## 代码\r\n- python\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        for i in reversed(range(len(num))):\r\n            sum_ = num[i] + k\r\n            k = sum_ // 10\r\n            res.append(sum_ % 10)\r\n        res.reverse()\r\n        if k:\r\n            res = list(map(int, str(k))) + res\r\n        return res\r\n```\r\n\r\n## 复杂度\r\n- time: O(max(n，k))\r\n- space: O(max(n，k))"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837739870","body":"## 思路\r\n左右各循环一遍数组，查找和字符`c`相同的位，以此记录每一位到上一个`c`的距离。然后比较左右距离得到较小值。\r\n\r\n## 代码\r\n- python\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        prev = float('-inf')\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                prev = i\r\n            res.append(i - prev)\r\n        \r\n        prev = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            res[i] = min(res[i], prev - i)\r\n        \r\n        return res\r\n```\r\n\r\n## 复杂度\r\n- time: O(n)\r\n- space: O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837739870","body":"## 思路\r\n左右各循环一遍数组，查找和字符`c`相同的位，以此记录每一位到上一个`c`的距离。然后比较左右距离得到较小值。\r\n\r\n## 代码\r\n- python\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        prev = float('-inf')\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                prev = i\r\n            res.append(i - prev)\r\n        \r\n        prev = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            res[i] = min(res[i], prev - i)\r\n        \r\n        return res\r\n```\r\n\r\n## 复杂度\r\n- time: O(n)\r\n- space: O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840848724","body":"## 思路\r\n用两个stack(`self.push_stack`和`self.pop_stack`)分别用于push和pop操作。当pop而`self.pop_stack`为空时，把`self.push_stack`里的元素全部转移到`self.pop_stack`里。\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.push_stack = []\r\n        self.pop_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.push_stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.pop_stack:\r\n            while self.push_stack:\r\n                self.pop_stack.append(self.push_stack.pop())\r\n        return self.pop_stack.pop() \r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.pop_stack:\r\n            return self.pop_stack[-1]\r\n        return self.push_stack[0]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.push_stack)==0 and len(self.pop_stack)==0\r\n```\r\n\r\n## 复杂度\r\n- 时间: peek()和empty()为O(1)，push()和pop() 均摊是O( 1)，因为每个元素最多入栈和出栈两次\r\n- 空间: O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Cartie-ZhouMo":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836492706","body":"### 思路\r\n从个位加起，若位数超出原数组，需要进位。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        l = len(num)\r\n        for i in range(l-1, -1, -1):\r\n            a = num[i] + k\r\n            k, num[i] = a // 10, a % 10\r\n        arr = []\r\n        while k:\r\n            arr = [k % 10] + arr\r\n            k = k // 10\r\n        return arr + num\r\n```\r\n### 复杂度分析\r\n时间：O(N)\r\n空间：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837854541","body":"### 思路\r\n暴力法：先遍历获得s中c的位置list，再遍历计算s中每个字符位置与位置list中元素的最小值。\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        arr, ans = [], []\r\n        dis = float(\"inf\") \r\n        for i, ss in enumerate(s):\r\n            if ss == c:\r\n                arr.append(i)\r\n        for i, ss in enumerate(s):\r\n            if ss == c:\r\n                ans.append(0)\r\n            else:\r\n                for a in arr:\r\n                    dis = min(abs(a - i), dis)\r\n                ans.append(dis)\r\n                dis = float(\"inf\") \r\n        return ans\r\n```\r\n### 复杂度：\r\n时间：O(N^2)\r\n空间：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839390701","body":"### 思路\r\npython中list作为栈\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxsize = maxSize\r\n        self.length = 0\r\n        self.stack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.length < self.maxsize:\r\n            self.stack.append(x)\r\n            self.length += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.length == 0: return -1\r\n        self.length -= 1\r\n        return self.stack.pop()\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, self.length)):\r\n            self.stack[i] += val\r\n\r\n```\r\n\r\n### 复杂度\r\nk = maxSize\r\n- 时间：push、pop: O(1); increment: O(k)\r\n- 空间：O(k)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840412803","body":"### 思路\r\n主要是处理括号嵌套的情况，利用辅助栈存储。\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        num, ans = 0, ''\r\n        # 辅助栈\r\n        stack = []\r\n        for ss in s:    \r\n            if ss == '[':\r\n                # 存 '[' 前的字母和数字\r\n                stack.append([num, ans])\r\n                num, ans = 0, ''\r\n            elif ss == ']':\r\n                if stack:\r\n                    n, a = stack.pop()\r\n                ans = a + n * ans\r\n            elif '0' <= ss <= '9':\r\n                num = num * 10 + int(ss)\r\n            else: ans += ss\r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n- 时间：O(N)\r\n- 空间：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840940404","body":"### 思路\r\n两个栈实现队列\r\n\r\n### 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stack1:\r\n            self.stack2.append(self.stack1.pop())\r\n        self.stack2.append(x)\r\n        while self.stack2:\r\n            self.stack1.append(self.stack2.pop())\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.stack1.pop()\r\n\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stack1[-1]\r\n\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.stack1)\r\n\r\n\r\n```\r\n### 复杂度\r\n时间：pop:O(n), 其余O(1)\r\n空间：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841611648","body":"### 思路\r\n单调栈，栈中存每排序块中的最大值\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for i, a in enumerate(arr):\r\n            if stack and stack[-1] > a:\r\n                m = stack.pop()\r\n                while stack and stack[-1] > a:\r\n                    stack.pop()\r\n                stack.append(m)\r\n            else: stack.append(a)\r\n        return len(stack)\r\n```\r\n\r\n### 复杂度\r\n- 时间：O(N)\r\n- 空间：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mystoryshine":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836511738","body":"### 思路\r\n\r\n- 用空字符串拼接输入数组\r\n- 转化为整形相加\r\n- 最后再转化为字符串遍历输出\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        tmp = ''\r\n        for n in num:\r\n            tmp += str(n)\r\n        res_int = int(tmp) + k\r\n        res = [int(i) for i in str(res_int)]\r\n        return res\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838438194","body":"### 思路\r\n\r\n- 左右两次遍历\r\n- 每次遍历时用一个临时变量记住最近的一次c的位置，求出距离\r\n- 比较两次遍历结果，取较小值即可\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        # 记第一次c的位置为 -length\r\n        preTargetIndex = - len(s)\r\n        # 正向遍历\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                # 若遍历到了c，将上一次c的位置改为当前位置，这样计算距离才为0\r\n                preTargetIndex = i\r\n            res.append(i - preTargetIndex)\r\n        \r\n        preTargetIndex = 2*len(s)\r\n        # 逆向遍历\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                preTargetIndex = i\r\n            res[i] = min(res[i], preTargetIndex - i)\r\n        return res\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$，其中 $N$ 为数组长度。\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839761598","body":"### 思路\r\n\r\n- 使用list实现栈\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.capacity = maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.capacity:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) == 0:\r\n            return -1\r\n        return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k < len(self.stack):\r\n            for i in range(k):\r\n                self.stack[i] += val\r\n        else:\r\n            for i in range(len(self.stack)):\r\n                self.stack[i] += val\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(1)$，$O(k)$\r\n- 空间复杂度：$O(1)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840578314","body":"### 思路\r\n\r\n- 利用栈与递归\r\n- 遍历原字符串，遇到非'**]**'压栈，遇到'**]**'弹出构成 **数字+[字符串]** 形式\r\n- 将这个子串解码玩后继续压入到栈中\r\n- 递归\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr\r\n                # pop 掉 \"[\"\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount\r\n                stack.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841249374","body":"### 思路\r\n\r\n- 利用2个栈，inStack和outStack\r\n- push时push到inStack中\r\n- pop时，若outStack非空，outStack弹出栈顶；若空，将inStack每个元素弹出并依次压入到outStack中\r\n- peek，若outStack非空，获得outStack栈顶;若空，同上\r\n- empty，两个栈均空才为空\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.inStack = []\r\n        self.outStack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.inStack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.empty():\r\n            if self.outStack:\r\n                return self.outStack.pop()\r\n            elif self.inStack:\r\n                while self.inStack:\r\n                    self.outStack.append(self.inStack.pop())\r\n                return self.outStack.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.empty():\r\n            if self.outStack:\r\n                return self.outStack[-1]\r\n            elif self.inStack:\r\n                while self.inStack:\r\n                    self.outStack.append(self.inStack.pop())\r\n                return self.outStack[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        if not self.inStack and not self.outStack:\r\n            return True\r\n        else:\r\n            return False\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(N)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ezrealcong":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836567186","body":"### **思路**\r\nC实现\r\n- 申请A.length+5个元素的数组空间p[]\r\n- 从后往前遍历数组p[]，计算最低位ktmp=k%10;更新kk=(int)(k/10),在遍历长度小于A.length时，p[i]=nums[i]+ktmp+进位ctmp,大于时p[i]=ktmp+ctmp\r\n- 过程中计数，直到发现nums遍历完，进位为0，k更新为0，那么计数器就是要返回的位数，然后将p指向数组对应位置上返回即可\r\n### **代码**\r\n    \r\n    int* addToArrayForm(int* num, int numSize, int k, int* returnSize){\r\n        int* p = calloc(numSize+5,sizeof(int));\r\n        int j=numSize-1;\r\n        int ktmp;//用来保存模10的值（某一位）\r\n        int atmp;//按位加未处理进位值\r\n        int ctmp=0;//保存进位\r\n        int b=0;\r\n        for(int i=numSize+4;i>=0;i--){\r\n            if(j<0&&k==0&&ctmp==0)\r\n                b++;\r\n            ktmp=k%10;\r\n            k=(int)(k/10);\r\n            if(j>=0)\r\n                atmp=num[j]+ctmp+ktmp;\r\n            else\r\n                {atmp=ctmp+ktmp;\r\n                }\r\n            p[i]=atmp%10;\r\n            ctmp=(int)(atmp/10);\r\n            j-=1;      \r\n        }    \r\n        *returnSize=numSize+5-b;\r\n        return p+b;\r\n    }\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：只遍历了一遍P[]，复杂度为O(N)\r\n\r\n- 空间复杂度：基本是用于返回的空间，O(N)\r\n\r\n> "},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837706343","body":"（python实现）\r\n### 思路：\r\n1.建立相应长度的数组，全部初始化-1，总共遍历两次\r\n2.第一次从左往右遍历，遇到字符匹配的位置，该元素变0，同时启动计数器num\r\n3.其他位置都赋值为num，赋值完后num自加1，一直到第一次遍历完毕，完成右边最近统计\r\n4.第二次从右往左遍历，遇到字符匹配的位置，启动计数器num\r\n5.其他位置都赋值为min{当前值，num}，赋值完后num自加1，一直到第二次遍历完毕，完成最近距离统计\r\n注意：边界处理时要注意最左边的-1，取最小值要避开-1（-1不参与比较）\r\n### 实例题解展示：\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n第一遍：\r\n\r\n>      [-1,-1,-1,0,1,0,0,1,2,3,4,0]\r\n\r\n第二遍：\r\n\r\n>     [ 3, 2, 1,0,1,0,0,4,3,2,1,0]\t不比较最小值\r\n\r\n>     [ 3, 2, 1,0,1,0,0,1,2,2,1,0]\t比较最小值（-1不参与比较）\r\n\r\n### 代码：\r\n\r\n>     \r\n\r\n    class Solution(object):\r\n            def shortestToChar(self, s, c):\r\n                slen=len(s)\r\n                slist=[-1]*slen\r\n                i=0\r\n                num=-1\r\n                while i<slen:\r\n                    if -1!=num:\r\n                        slist[i]=num\r\n                        num+=1\r\n                    if s[i]==c:\r\n                        slist[i]=0\r\n                        num=1\r\n                    i+=1\r\n                i=slen-1\r\n                num=-1    \r\n                while i>=0:\r\n                    if -1!=num:\r\n                        if slist[i]>num or -1==slist[i]:\r\n                            slist[i]=num\r\n                        num+=1\r\n                    if s[i]==c:\r\n                        num=1\r\n                    i-=1\r\n                return slist\r\n\r\n### 复杂度分析\r\n1.时间复杂度：遍历两次数组（列表），时间复杂度O(N)\r\n2.空间复杂度：除去用来返回的列表，空间复杂度O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839785105","body":"### **思路**\r\n\r\n1. 多创建一个delta列表（开始全是零），随着栈列表一起增长，每当有increase操作时，min(k-1,top)位置就增加val\r\n2. push时，top+=1，栈和delta列表的top位置分别变为x和0\r\n3. pop时， 取出栈和delta列表top位置的值a和b，top-=1，delta的新top（减过之后的）位置的值加上刚旧top取出来的值a，返回a+b\r\n4. increase时，min（k-1，top）位置的值加上val即可\r\n\r\n### **代码**\r\n```python\r\nclass CustomStack:\r\n    def __init__(self, maxSize: int):\r\n        self.stack=[0]*maxSize\r\n        self.delta=[0]*maxSize\r\n        self.top=-1\r\n        self.maxSize=maxSize-1\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if(self.top < self.maxSize):\r\n            self.top+=1\r\n            self.stack[self.top]=x\r\n            self.delta[self.top]=0\r\n\r\n\r\n    def pop(self) -> int:\r\n        if -1 == self.top:\r\n            return -1\r\n        a = self.stack[self.top]\r\n        b = self.delta[self.top]\r\n        self.top-=1\r\n        self.delta[self.top]+=b\r\n        return a+b \r\n       \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if -1 == self.top:\r\n            return\r\n        k_top=min(self.top,k-1)\r\n        self.delta[k_top]+=val\r\n```\r\n\r\n\r\n### **复杂度分析**\r\n\r\n1. 时间复杂度：均为O(1)\r\n2. 空间复杂度:O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840585056","body":"### **思路**\r\n\r\n> 构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\r\n\r\n1. 当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\r\n2. 当 c 为字母时，在 res 尾部添加 c；\r\n3. 当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 00：\r\n    记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\r\n    记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\r\n    进入到新 [ 后，res 和 multi 重新记录。\r\n4. 当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\r\n    last_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\r\n    cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\r\n    返回字符串 res。\r\n\r\n### **代码**\r\n```python\r\n     \r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n### **复杂度分析**\r\n1.  时间复杂度 O(N)\r\n2.  空间复杂度 O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841324750","body":"\r\n### **思路**\r\n1. 辅助栈\r\n\r\n### **代码**\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.size=0\r\n        self.stack=[]\r\n        self.help_stack=[]\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack.append(x)\r\n        self.size+=1\r\n\r\n\r\n    def pop(self) -> int:\r\n        self.size-=1\r\n        for i in range(self.size):\r\n            self.help_stack.append(self.stack.pop())\r\n        tmp=self.stack.pop()\r\n        for i in range(self.size):\r\n            self.stack.append(self.help_stack.pop())\r\n        return tmp\r\n\r\n    def peek(self) -> int:\r\n        for i in range(self.size-1):\r\n            self.help_stack.append(self.stack.pop())\r\n        tmp=self.stack.pop()\r\n        self.stack.append(tmp)\r\n        for i in range(self.size-1):\r\n            self.stack.append(self.help_stack.pop())\r\n        return tmp\r\n\r\n\r\n    def empty(self) -> bool:\r\n        if(self.size):\r\n            return False\r\n        else:\r\n            return True\r\n\r\n```\r\n\r\n\r\n### **复杂度分析**\r\n1. 时间复杂度：O(N)\r\n2. 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Huzhixin00":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836573445","body":"### 思路\r\n1. 按照最自然的想法，应该是将K的各位切分出来，即：将int类型的K转化为各位为int类型的数组，然后将K的对应位与给定数组的对应位进行相加，并考虑进位的情况。\r\n2. 上述想法需要对K进行处理，而且处理进位的逻辑会影响到下一轮更高位的相加处理，所以应考虑更为通用的算法。\r\n3. 在上述过程中，唯一不能省略的就是进位过程，因为作为”必要项“的进位过程如果可以和相加过程相结合，自然可以得出相对通用的算法。\r\n4. 如果要将进位过程与相加过程结合，那么就应该是”依次从低位开始加起，K与个位相加的结果对10取余，即个位的最终结果，而是否向上进位，则取决于k与个位相加的结果除以十，是否大于0（整数/10即意味着求高1位数的结果，因为小数点后的数字被截掉了）“。\r\n5. 反复进行第4步，即每除1次10，即求得都是K累加和的高一次幂，只要K的累加和除10结果不为零，或是数组的位数没有加到最高位，这样的循环就不会停止。\r\n\r\n### 代码（Java）\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> arr = new ArrayList<>();\r\n        for (int i = num.length - 1; i >= 0 || k > 0; i--, k = k / 10) {\r\n            if (i >= 0) {\r\n                k = k + num[i];\r\n            }\r\n            arr.add(k % 10);\r\n        }\r\n        Collections.reverse(arr);\r\n        return arr;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n时间复杂度：O(max(logK,num.length)) \r\n循环次数取决于k和数组长度的最大值，但比较值得注意的是，当K>0，但i<0时，意味着数组的最高位已经没有了，此时应该出现数组越界异常，只不过leetcode只判定到不越界为止，所以就没有考虑越界的问题。\r\n\r\n空间复杂度：O(1)\r\n没有用到额外的空间，所以空间复杂度为常数\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838368278","body":"## 思路\r\n写在代码注释里面了\r\n## 代码\r\n```\r\n class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        // 创建一个数组来存放各个位置距离字符 c 的最小距离\r\n        int[] minDistances = new int[s.length()];\r\n        /*\r\n        * 每个位置相对于c的情况有三种：\r\n        * 1、该下标只有左边有字符c         [x  c]\r\n        * 2、该下标左右两边都有字符c       [c   x   c]\r\n        * 3、该下标只有右边有字符c         [c  x]\r\n        * 其中只有第二种情况，需要比较两边的字符c究竟哪个距离x更近。\r\n        * 所以取最复杂情况，设置两个指针cursor1和cursor2，分别指向当前下标的左侧c字符和右侧c字符\r\n        * */\r\n        // 先将两个指针指向String中最左侧的字符c，然后从数字0开始迭代\r\n        int cursorFirst = s.indexOf(c), cursorSecond = cursorFirst;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            /*\r\n            * 如果数字下标处，正好是字符c，那么将该位置到字符c的距离必为0，并且更新两个指针的数据\r\n            * 原来的的cursor1，也就是左侧字符c指针，需要更新为当前下标的位置（因为下一次该位置就成为下一个位置的左侧字符c）\r\n            * 原来的cursor2，也就是右侧字符c指针，需要更新为更右边（即从i+1位置开始，找到的下一个字符c位置）的字符c位置*/\r\n            if (s.charAt(i) == c) {    //\r\n                minDistances[i] = 0;\r\n                cursorFirst = i;\r\n                cursorSecond = s.indexOf(c, i + 1);\r\n                // 如果数组下标所处位置的字符不是字符c，则计算该处与最近的左右两侧字符c的距离，并取最小值\r\n            } else {\r\n                minDistances[i] = Math.min(Math.abs(cursorFirst - i), Math.abs(cursorSecond - i));\r\n            }\r\n        }\r\n        return minDistances;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n时间复杂度：O(N) \r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839861272","body":"## 思路\r\n1. 用数组模拟栈，设定一个top变量模拟栈顶\r\n## 代码（Java）\r\n```\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            top++;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        top--;\r\n        return stack[top + 1];\r\n\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n1. 时间复杂度：\r\n定义栈，put和pop操作均为O(1)，而increment操作为O(k)\r\n\r\n2. 空间复杂度：\r\n用到了一个数组长度为maxsize的数组，所以复杂度为O(maxsize)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Gentlemancj":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836575050","body":"```var addToArrayForm = function(num, k) {\r\n  let isOverflow = false, index = num.length - 1, res = [];\r\n  while(index > -1 || k) {\r\n     const num1 = num[index] || 0, num2 = k % 10;\r\n     let sum = num1 + num2;\r\n     if(isOverflow) {\r\n          sum = sum + 1;\r\n     }\r\n      isOverflow = sum >= 10;\r\n      res.unshift(sum % 10);\r\n      k = (k / 10) | 0;\r\n      index--;\r\n      \r\n  }\r\n  if(isOverflow) res.unshift(1);\r\n  return res;\r\n};\r\n**复杂度分析**\r\n\r\n- 空间复杂度O(n)\r\n- 时间复杂度O(n) "},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837600585","body":"**暴力破解法**\r\n\r\n```\r\nvar shortestToChar = function (s, c) {\r\n  let index = 0, len = s.length, res = [];\r\n  while (index < len) {\r\n    let head = tail = index;\r\n    while (head > -1 || tail < len) {\r\n      const headC = s[head], tailC = s[tail];\r\n      if (headC === c) {\r\n        res.push(index - head);\r\n        break;\r\n      };\r\n      if (tailC === c) {\r\n        res.push(tail - index);\r\n        break;\r\n      }\r\n      head--;\r\n      tail++;\r\n    }\r\n    index++;\r\n  }\r\n  return res\r\n};\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839365646","body":"```\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\nthis.stack = new Array(maxSize);\r\n  this.maxSize = maxSize;\r\n  this.currentSize = 0;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\nif (this.currentSize < this.maxSize) {\r\n    this.currentSize++;\r\n    this.stack[this.currentSize - 1] = x;\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  if (this.currentSize > 0) {\r\n    const val = this.stack[this.currentSize - 1];\r\n    this.currentSize--;\r\n    return val;\r\n  }\r\n  return -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\nconst size = Math.min(k, this.currentSize);\r\n  for (let i = 0; i < size; i++) {\r\n    this.stack[i] = this.stack[i] + val;\r\n  }\r\n};\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841127080","body":"```\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function () {\r\n  this.outStack = [];\r\n  this.inStack = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n  this.inStack.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n  if (!this.outStack.length) {\r\n    this.popStack();\r\n  }\r\n  return this.outStack.pop();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n  if (!this.outStack.length) {\r\n    this.popStack();\r\n  }\r\n  return this.outStack[this.outStack.length - 1];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n  return !this.inStack.length && !this.outStack.length\r\n};\r\n\r\nMyQueue.prototype.popStack = function () {\r\n  while (this.inStack.length) {\r\n    this.outStack.push(this.inStack.pop());\r\n  }\r\n};"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LiangZheCoder":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836576433","body":"思路：模拟进位加法，同样适用于链表\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //用于标识数组的位置\r\n        int len = num.length - 1;\r\n        //用于标识是否发生进位\r\n        int isCarry = 0;\r\n        //统计每一轮的值，提前创建，增加效率\r\n        int val = 0;\r\n        //用于保存结果，使用头插法插入链表\r\n        List<Integer> res = new LinkedList<>();\r\n        while(len > -1 || k > 0){\r\n            if(k > 0){\r\n                val = k % 10;\r\n                k = k / 10;\r\n            }\r\n            if(len > -1){\r\n                val += num[len];\r\n            }\r\n            val += isCarry;\r\n            isCarry = val / 10;\r\n            val = val % 10;\r\n            res.add(0,val);\r\n            len--;\r\n            val = 0;\r\n        }\r\n        if(isCarry > 0){\r\n            res.add(0,1);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n\r\n时间复杂度O(n)\r\n空间复杂度O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837861038","body":"- 思路\r\n\r\n暴力法，判断前后的距离，找到第一个目标字符的位置则停止，然后左右比较大小\r\n```\r\n\r\n- 代码\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] answer = new int[s.length()];\r\n        int min1 = Integer.MAX_VALUE;\r\n        int min2 = Integer.MAX_VALUE;\r\n        for(int i = 0 ; i < s.length() ; i++){\r\n            if(s.charAt(i) == c){\r\n                answer[i] = 0;\r\n                continue;\r\n            }\r\n            for(int j = i ; j < s.length() ; j++){\r\n                if(s.charAt(j) == c){\r\n                    min1 = Math.abs(i-j);\r\n                    break;\r\n                }\r\n            }\r\n            for(int j = i ; j > -1 ; j--){\r\n                if(s.charAt(j) == c){\r\n                    min2 = Math.abs(i-j);\r\n                    break;\r\n                }\r\n            }\r\n            answer[i] = Math.min(min1,min2);\r\n            min1 = Integer.MAX_VALUE;\r\n            min2 = Integer.MAX_VALUE;\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```\r\n\r\n- 复杂度\r\n时间：O(N^2) 外层循环数组长度，内层循环近似数组长度\r\n空间：O(N) 开辟和数组长度相等的数组\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837861038","body":"- 思路\r\n\r\n暴力法，判断前后的距离，找到第一个目标字符的位置则停止，然后左右比较大小\r\n```\r\n\r\n- 代码\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] answer = new int[s.length()];\r\n        int min1 = Integer.MAX_VALUE;\r\n        int min2 = Integer.MAX_VALUE;\r\n        for(int i = 0 ; i < s.length() ; i++){\r\n            if(s.charAt(i) == c){\r\n                answer[i] = 0;\r\n                continue;\r\n            }\r\n            for(int j = i ; j < s.length() ; j++){\r\n                if(s.charAt(j) == c){\r\n                    min1 = Math.abs(i-j);\r\n                    break;\r\n                }\r\n            }\r\n            for(int j = i ; j > -1 ; j--){\r\n                if(s.charAt(j) == c){\r\n                    min2 = Math.abs(i-j);\r\n                    break;\r\n                }\r\n            }\r\n            answer[i] = Math.min(min1,min2);\r\n            min1 = Integer.MAX_VALUE;\r\n            min2 = Integer.MAX_VALUE;\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```\r\n\r\n- 复杂度\r\n时间：O(N^2) 外层循环数组长度，内层循环近似数组长度\r\n空间：O(N) 开辟和数组长度相等的数组\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"w-z-hub":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836584325","body":"语言：java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList<>();\r\n\r\n        for(int i=num.length-1; i>=0; i--){\r\n \r\n            int temp = num[i] + k;\r\n            int temp1 = temp%10;\r\n            ans.add(0, temp1);\r\n            k= temp/10;\r\n            \r\n        }\r\n\r\n        while(k>0){\r\n            ans.add(0, k%10);\r\n            k/=10;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839797486","body":"class CustomStack {  \r\n    int[] ans;  \r\n    int cursor;  \r\n  \r\n    public CustomStack(int maxSize) {  \r\n        ans = new int[maxSize];  \r\n        cursor = -1;  \r\n    }  \r\n  \r\n    public void push(int x) {  \r\n        if (cursor == ans.length - 1) return;  \r\n        cursor += 1;  \r\n        ans[cursor] = x;  \r\n    }  \r\n  \r\n    public int pop() {  \r\n        if (cursor == -1) return -1;  \r\n        cursor -= 1;  \r\n        return ans[cursor + 1];  \r\n    }  \r\n  \r\n    public void increment(int k, int val) {  \r\n        int max_inc = Math.min(k, cursor + 1);  \r\n        for (int i = 0; i < max_inc; i++) {  \r\n            ans[i] += val;  \r\n        }  \r\n    }  \r\n}  "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840572016","body":"class Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        num, ans = 0, ''\r\n        # 辅助栈\r\n        stack = []\r\n        for ss in s:    \r\n            if ss == '[':\r\n                # 存 '[' 前的字母和数字\r\n                stack.append([num, ans])\r\n                num, ans = 0, ''\r\n            elif ss == ']':\r\n                if stack:\r\n                    n, a = stack.pop()\r\n                ans = a + n * ans\r\n            elif '0' <= ss <= '9':\r\n                num = num * 10 + int(ss)\r\n            else: ans += ss\r\n        return ans"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Kuroky-Chen":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836597120","body":"#### 思路：逐位将数字加一起\r\n代码：javascript\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yulecc":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836599276","body":"思路\r\n遍历数组,不断做空k,从k的个位数开始提取 , 和数组最后一项开始相加 , 一直往前 , 和大于10, k就加1, 最后遍历k,最后反转数组\r\n\r\n关键点\r\n代码\r\n语言支持：JavaScript\r\nJavaScript Code:\r\n\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n\r\n\r\n复杂度分析\r\n\r\n令 n 为数组长度。\r\n\r\n时间复杂度：O(n)O(n)\r\n空间复杂度：O(1)O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838266285","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n遍历字符串,两个指针从左找一次,从右找一次\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    var res = new Array(s.length).fill(0)\r\n\r\n    for(var i=0;i <s.length; i++) {\r\n        var l = i, r=i, shortest = Infinity\r\n        if(s[i] === c) continue\r\n        while(l>=0){\r\n            if(s[l] === c){\r\n                shortest = Math.min(shortest, i - l)\r\n                break;\r\n            }\r\n            l--\r\n        }\r\n        while(r<s.length){\r\n            if(s[r] === c){\r\n                shortest = Math.min(shortest, r - i)\r\n                break;\r\n            }\r\n            r++\r\n        }\r\n        res[i] = shortest\r\n    }\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839600534","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.list = []\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.list.length < this.maxSize) {\r\n        this.list.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    const item = this.list.pop()\r\n    return item === void 0 ? -1 : item\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(var i=0; i<k && i<this.list.length;i++){\r\n        this.list[i] +=val\r\n    }\r\n    \r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840505699","body":"\r\n## 题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n\r\n\r\n示例 3：\r\n\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n\r\n\r\n示例 4：\r\n\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\nlet numStack = [];        // 存倍数的栈\r\n    let strStack = [];        // 存 待拼接的str 的栈\r\n    let num = 0;              // 倍数的“搬运工”\r\n    let result = '';          // 字符串的“搬运工”\r\n    for (const char of s) {   // 逐字符扫描\r\n        if (!isNaN(char)) {   // 遇到数字\r\n            num = num * 10 + Number(char); // 算出倍数\r\n        } else if (char == '[') {  // 遇到 [\r\n            strStack.push(result); // result串入栈\r\n            result = '';           // 入栈后清零\r\n            numStack.push(num);    // 倍数num进入栈等待\r\n            num = 0;               // 入栈后清零\r\n        } else if (char == ']') {  // 遇到 ]，两个栈的栈顶出栈\r\n            let repeatTimes = numStack.pop(); // 获取拷贝次数\r\n            result = strStack.pop() + result.repeat(repeatTimes); // 构建子串\r\n        } else {                   \r\n            result += char;        // 遇到字母，追加给result串\r\n        }\r\n    }\r\n    return result;\r\n\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841175391","body":"\r\n## 题目地址(232. 用栈实现队列)\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\r\n\r\n实现 MyQueue 类：\r\n\r\nvoid push(int x) 将元素 x 推到队列的末尾\r\nint pop() 从队列的开头移除并返回元素\r\nint peek() 返回队列开头的元素\r\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\r\n\r\n \r\n\r\n说明：\r\n\r\n你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n\r\n \r\n\r\n进阶：\r\n\r\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\r\n[[], [1], [2], [], [], []]\r\n输出：\r\n[null, null, null, 1, 1, false]\r\n\r\n解释：\r\nMyQueue myQueue = new MyQueue();\r\nmyQueue.push(1); // queue is: [1]\r\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\nmyQueue.peek(); // return 1\r\nmyQueue.pop(); // return 1, queue is [2]\r\nmyQueue.empty(); // return false\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= x <= 9\r\n最多调用 100 次 push、pop、peek 和 empty\r\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.stack = []\r\n    this.helpStack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    var cur = null\r\n    while(cur = this.stack.pop()){\r\n        this.helpStack.push(cur)\r\n    }\r\n    this.helpStack.push(x)\r\n    while(cur = this.helpStack.pop()){\r\n        this.stack.push(cur)\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.stack.pop()\r\n    \r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[this.stack.length-1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack.length === 0\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fyyjyx-github":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836606794","body":"### 思路\r\n\r\n先将整数数组A转为一个字符串，再将字符串转为数值类型后与整数K相加，再将得到的数值结果转为int类型的数组。\r\n\r\n### 代码\r\n\r\nPython3\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        # 先将整数数组A转为一个字符串，再将字符串转为数值类型后与整数K相加\r\n        res_num = eval(''.join(map(str, A))) + K\r\n        # 将得到的数值结果先转为字符串，再将其转为int类型的数组\r\n        return list(map(int, str(res_num)))\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n)，其中 n 为数组的长度。\r\n- 空间复杂度：O(1)。"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841665056","body":"### 思路\r\n\r\n根据分块的思想得到前一个块的最大值应该小于等于后一个块的最小值，因此，想到数组中如果索引i所在的元素及之前的元素的最大值小于索引i所在的元素之后的元素的最小值，那么就可以分成一个块，如果整个数组中都没有这样的i，那么整个数组可分成的最大块数就是1，先想到的是递归，然后想到可以用递推。\r\n\r\n### 代码\r\n\r\nPython3\r\n\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        # arrlen = len(arr)\r\n        # if arrlen == 1:\r\n        #     return 1\r\n        # for i in range(1,arrlen):\r\n        #     if max(arr[:i]) <= min(arr[i:]):\r\n        #         return self.maxChunksToSorted(arr[:i]) +self.maxChunksToSorted(arr[i:])\r\n        # return 1\r\n        arrlen = len(arr)\r\n        f = [0 for _ in range(arrlen)]\r\n        f[0] = 1\r\n        for i in range(1,arrlen):\r\n            if max(arr[:i]) <= min(arr[i:]):\r\n                f[i] = f[i-1] + 1\r\n            else:\r\n                f[i] = f[i-1]\r\n        return f[-1]\r\n\r\n```\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n^2)\r\n- 空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"YuanWenLai":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836610752","body":"### 思路 \r\n \r\n数组的数值操作\r\n1、倒序遍历数组\r\n2、用一个进位数来保存溢出状态carryNum\r\n3、k值每次使用后剔除个位数的值\r\n \r\n \r\n### 代码 \r\n### js\r\n \r\n``` js\r\n \r\n    let len = num.length - 1\r\n    // 用一个进位数来保存上一位的溢出情况\r\n    let carryNum = 0\r\n    let number = []\r\n    while(len >= 0 || k!=0) {\r\n        let sum = carryNum\r\n        if(len >= 0) {\r\n            sum += num[len]\r\n            len--\r\n        }\r\n        if(k!=0) {\r\n            sum += k%10\r\n            // 剔除k的个位\r\n            k = Math.floor(k/10)\r\n        }\r\n        // 保存新的进位数\r\n        carryNum = Math.floor(sum/10)\r\n        number.unshift(sum % 10)\r\n    }\r\n    if(carryNum > 0) {\r\n        number.unshift(carryNum)\r\n    }\r\n    return number\r\n \r\n``` \r\n \r\n**复杂度分析** - 时间复杂度：O(N)，其中 N 为数组⻓度。 - 空间复杂度：O（N）"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837560949","body":"### 思路 \r\n \r\n数组的遍历(正向遍历和反向遍历)\r\n1、先得到一个反向的字符串\r\n2、获取正向反向目标字符的下标\r\n3、正向遍历和反向遍历获取对应距离的数组\r\n4、正向遍历和反向遍历的数组间比较最小值返回\r\n \r\n \r\n### 代码 \r\n \r\n \r\n``` js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    if(s.length === 1) return [0]\r\n    let antiS = s.split('').reverse().join('')\r\n    let antiArr = []\r\n    let arr = []\r\n    let index = s.indexOf(c)\r\n    let antiIndex = antiS.indexOf(c)\r\n    for(let i=0;i<s.length;i++) {\r\n        // 正序数组遍历\r\n        if(s[i] !=c){\r\n            arr.push(Math.abs(i - index))\r\n        }else {\r\n            arr.push(0)\r\n            index = i\r\n        }\r\n\r\n        // 反序数组遍历\r\n        if(antiS[i] != c ){\r\n            antiArr.unshift(Math.abs(i - antiIndex))\r\n        }else {\r\n            antiArr.unshift(0)\r\n            antiIndex = i\r\n        }\r\n    }\r\n    return arr.map((item,index) => Math.min(item,antiArr[index]))\r\n};\r\n``` \r\n \r\n**复杂度分析** - 时间复杂度：O(N)，其中 N 为数组⻓度。 - 空间复杂度：O（N）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839307877","body":"### 思路 \r\n \r\n数组模拟栈\r\n1、初始化记录数据的数组和最大值\r\n2、判断入栈时是否超出maxSize的长度\r\n3、判断出栈时，栈是否为空\r\n4、增量时，判断当前k值和栈的长度大小\r\n \r\n \r\n### 代码 \r\n \r\n \r\n``` js\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function(maxSize) {\r\n    this.data = []\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.data.length < this.maxSize) {\r\n        this.data.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(this.data.length === 0) return -1\r\n    return this.data.pop()\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    k = this.data.length < k ? this.data.length : k\r\n    for(let i=0;i<k;i++) {\r\n        this.data[i] += val\r\n    }\r\n};\r\n\r\n \r\n``` \r\n \r\n**复杂度分析** \r\n- 时间复杂度：O(N) \r\n- 空间复杂度：O（N）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840216126","body":"### 思路 \r\n \r\n1、遍历字符串，将数字存入numArr，非数字存入stack\r\n2、如果不是']'，入栈\r\n3、否则计算当前匹配括号内的字符串\r\n \r\n \r\n### 代码 \r\n \r\n \r\n``` js\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\n var decodeString = function(s) {\r\n    let stack = []\r\n    let numArr = []\r\n    for(let i=0;i<s.length;i++) {\r\n        if(Number.isInteger(s[i]*1) && i > 0 && Number.isInteger(s[i-1]*1)) {\r\n            numArr[numArr.length-1] += s[i]\r\n        }else if(Number.isInteger(s[i]*1)) {\r\n            numArr.push(s[i])\r\n        }else if(s[i] != ']') {\r\n            stack.push(s[i])\r\n        }else {\r\n            formatStack(stack,numArr)\r\n        }\r\n    }\r\n    return stack.join('')\r\n};\r\n\r\nfunction formatStack(stack,numArr) {\r\n    let str = ''\r\n    let retStr = ''\r\n    let num = numArr.pop()\r\n    while(s = stack.pop(), s != '[') {\r\n        str = s + str\r\n    }\r\n    retStr = str\r\n    for(let i = 0;i<num*1 -1;i++) {\r\n        retStr += str\r\n    }\r\n    stack.push(retStr)\r\n}\r\n \r\n``` \r\n \r\n**复杂度分析** \r\n- 时间复杂度：O(N) \r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840900103","body":"### 思路 \r\n \r\n1、用数组来维护一个队列\r\n \r\n \r\n### 代码 \r\n \r\n \r\n``` js\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\n /**\r\n * Initialize your data structure here.\r\n */\r\n var MyQueue = function() {\r\n    this.queue = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    if(x) this.queue.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.queue.shift()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.queue[0]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.queue.length == 0\r\n};\r\n \r\n``` \r\n \r\n**复杂度分析** \r\n- 时间复杂度：O(1) \r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841583446","body":"### 思路 \r\n \r\n1、利用求栈stack的最大值的思想，储存可分块的最大值\r\n2、当出现小于栈顶head的值时，保留当前栈顶head，抛出stack中大于arr[i]的值\r\n3、最终得出stack的长度的就可分块的最大值\r\n\r\n思想和 769. 最多能完成排序的块 的题目一致\r\n \r\n \r\n### 代码 \r\n \r\n \r\n``` js\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted2 = function(arr) {\r\n    let stack = []\r\n    for(let i=0;i<arr.length;i++) {\r\n        let len = stack.length\r\n        // 栈为空 or 栈顶小于当前值\r\n        if(len == 0 || stack[len-1] <= arr[i]) {\r\n            stack.push(arr[i])\r\n        }else {\r\n            // 保存栈顶的最大值为头，抛出大于当前值的栈内元素\r\n            const head = stack.pop()\r\n            while(stack[stack.length-1] > arr[i]) {\r\n                stack.pop()\r\n            }\r\n            stack.push(head)\r\n        }\r\n    }\r\n    return stack.length\r\n};\r\n \r\n``` \r\n \r\n**复杂度分析** \r\n- 时间复杂度：O(N) \r\n- 空间复杂度：O（N）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mengwwww":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836631365","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        queue<int> temp;\r\n        stack<int> res;\r\n        while(k!=0){\r\n            temp.push(k%10);\r\n            k = k/10;\r\n        }\r\n        int i=num.size()-1;\r\n        int jinwei = 0;\r\n        while(i>=0 && !temp.empty()){\r\n            res.push((num[i]+temp.front()+jinwei)%10);\r\n            jinwei = (num[i]+temp.front()+jinwei)/10;\r\n            i--;\r\n            temp.pop();\r\n        }\r\n        if(i>=0){\r\n            for(int k = i;k>=0;k--){\r\n                res.push((num[k]+jinwei)%10);\r\n                jinwei = (num[k]+jinwei)/10;\r\n            }\r\n        }\r\n        if(!temp.empty()){\r\n            while(!temp.empty()){\r\n                res.push((temp.front()+jinwei)%10);\r\n                jinwei = (temp.front()+jinwei)/10;\r\n                temp.pop();\r\n            }\r\n            \r\n        }\r\n        if(jinwei>0){\r\n            res.push(jinwei);\r\n        }\r\n        vector<int> m;\r\n        while(!res.empty()){\r\n            m.push_back(res.top());\r\n            res.pop();\r\n        }\r\n        return m;\r\n    }\r\n};\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837634708","body":"### 思路\r\n使用队列存储对应字符下标所在位置\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        queue<int> q;\r\n        for(int i=0;i<s.length();i++){\r\n            if(c==s[i]){\r\n                q.push(i);\r\n            }\r\n        }\r\n        vector<int> res;\r\n        int a = q.front();\r\n        q.pop();\r\n        for(int i=0;i<s.length();i++){\r\n            if(q.empty() || abs(i-a)<=abs(i-q.front())){\r\n                res.push_back(abs(i-a));                \r\n            }else if(!q.empty() && abs(i-a)>abs(i-q.front())){\r\n                a = q.front();\r\n                q.pop();\r\n                i--;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 o(n)\r\n空间复杂度o(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839496224","body":"```\r\nclass CustomStack {\r\npublic:\r\nvector<int> s;\r\nint top;\r\n    CustomStack(int maxSize) {\r\n        s.resize(maxSize);\r\n        top = 0;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top!=s.size()){\r\n            s[top]=x;\r\n            top++;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if(top>0){\r\n            top--;\r\n            return s[top];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for(int i=0;i<min(k,top);i++){\r\n            s[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841064627","body":"```\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    stack<int> s;\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        s.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        stack<int> temp;\r\n        while(!s.empty()){\r\n            temp.push(s.top());\r\n            s.pop();\r\n        }\r\n        int res = temp.top();\r\n        temp.pop();\r\n        while(!temp.empty()){\r\n            s.push(temp.top());\r\n            temp.pop();\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        stack<int> temp;\r\n        while(!s.empty()){\r\n            temp.push(s.top());\r\n            s.pop();\r\n        }\r\n        int res = temp.top();\r\n        //temp.pop();\r\n        while(!temp.empty()){\r\n            s.push(temp.top());\r\n            temp.pop();\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return s.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JohnVSD":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836632025","body":"## 思路\r\n\r\n参考了官方题解。\r\n\r\n从低位向高位依次计算。例如：123+912，计算过程是 3+2，2+1，1+9 可以得出结果为 1035；可以转换为如下代码：\r\n\r\n## 代码\r\nJavaScript\r\n\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];\r\n    let n = num.length;\r\n    \r\n    for (let i = n - 1; i>=0; i--) {\r\n        // 利用取余操作，取出k值最后一位进行加运算\r\n        let sum = num[i] + k % 10;\r\n        // 利用向下取整的方式，去掉k最后一位数，依次计算\r\n        k = Math.floor(k / 10);\r\n        \r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        \r\n        res.push(sum);\r\n    }\r\n    \r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    \r\n    res.revers();\r\n    \r\n    return res;\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(max(n, log k))\r\n* 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838735759","body":"## 思路\r\n\r\n分别从字符串左右进行遍历，比较然后取最小值。\r\n\r\n## 代码\r\nTypeScript\r\n\r\n```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n  let res: number[] = Array(s.length).fill(0);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) continue;\r\n\r\n    let l: number = i;\r\n    let r: number = i;\r\n    let shortest: number= Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (s[l] === c) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r<s.length) {\r\n      if (s[r] === c) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(N²)\r\n* 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839493322","body":"## 思路\r\n\r\n使用数组方法模拟栈操作。\r\n\r\n## 代码 (TS)\r\n\r\n```typescript\r\nclass CustomStack {\r\n    maxSize: number;\r\n    stack: number[];\r\n\r\n    constructor(maxSize: number) {\r\n        this.maxSize = maxSize;\r\n        this.stack = new Array();\r\n    }\r\n    \r\n    push(x: number): void {\r\n        if (this.stack.length < this.maxSize) {\r\n            this.stack.push(x);\r\n        }\r\n    }\r\n\r\n    pop(): number {\r\n        if (this.stack.length > 0) {\r\n            return this.stack.pop();\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    increment(k: number, val: number): void {\r\n        for (let i = 0; i<this.stack.length; i++) {\r\n            if (i < k) {\r\n                this.stack[i] = this.stack[i] + val;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：push、pop 都是 O(1), increment 为O(n) n为stact长度\r\n* 空间复杂度：O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840614479","body":"## 思路\r\n\r\n利用栈进行实现，遍历字符串，在遇到闭合符号 ']' 之前一直进行入栈操作 --> 直到遇到 ‘]’ 便进行出栈操作 --> 创建变量存储 “需要重复的字符” 和 “重复次数” \r\n 内部使用 while 循环进行逐个判断与出栈。\r\n\r\n## 代码 (TS)\r\n\r\n```typescript\r\nfunction decodeString(s: string): string {\r\n  let stack = [];\r\n  for (let i = 0; i < s.length; i++) {\r\n    // 遇到 ']' 就出栈\r\n    if (s[i] === ']') {\r\n      let repeatStr = ''; // 记录需要重复的字符\r\n      let num = ''; // 记录数字\r\n\r\n      // 将需要重复的字符进行存储\r\n      while (stack[stack.length - 1] !== '[') {\r\n        repeatStr = stack.pop() + repeatStr;\r\n      }\r\n      // 去除 '['\r\n      stack.pop();\r\n\r\n      // 取出数字\r\n      while (!isNaN(stack[stack.length - 1])) {\r\n        num = stack.pop() + num;\r\n      }\r\n\r\n      // 重复 num 次 repeatStr\r\n      repeatStr = repeatStr.repeat(parseInt(num));\r\n      stack.push(repeatStr)\r\n    } else {\r\n      // 值不等于 ']' 就入栈\r\n      stack.push(s[i]);\r\n    }\r\n  }\r\n  \r\n  return stack.join('');\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840977986","body":"## 思路\r\n\r\njs中使用数组模拟栈操作。\r\n\r\n## 代码（TS）\r\n```TypeScript\r\nclass MyQueue {\r\n    stack: number[];\r\n\r\n    constructor() {\r\n        this.stack = [];\r\n    }\r\n\r\n    push(x: number): void {\r\n        this.stack.push(x);\r\n    }\r\n\r\n    pop(): number {\r\n        return this.stack.shift()\r\n    }\r\n\r\n    peek(): number {\r\n        return this.stack[0]\r\n    }\r\n\r\n    empty(): boolean {\r\n        return !this.stack.length\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：push、pop、peek、empty 都是 O(1)\r\n* 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"QiZhongdd":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836634467","body":"思路\r\n数组的数值操作\r\n1：新建一个数组用于存储变量\r\n2:倒序遍历数组，每个值与K的余数相加，如果和小于0，那么push这个和，如果大于0，那么push该和的个位数，K为十位数。\r\n3：依次遍历，重复第一步骤，等到遍历完后，如果k继续大于0,那么依次将k的值一个个添加进res数组。\r\n4：对结果进行翻转得到数字\r\n\r\nfunction add(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n\r\n复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838362553","body":"思路1\r\n左右各遍历一次,找到相同值的位置，比较左右最快找到值的坐标，然后得到绝对值比较，取小值\r\n\r\nvar shortestToChar = function(s, c) {\r\n   let prev=-Infinity,result=[];\r\n   for(let i=0;i<s.length;i++){\r\n       if(s.charAt(i)===c){\r\n           prev=i\r\n       }\r\n       result[i]=Math.abs(i-prev)\r\n   }\r\n   prev=Infinity\r\n   for(let j=s.length-1;j>=0;--j){\r\n        if(s.charAt(j)===c){\r\n           prev=j\r\n       }\r\n       result[j]=Math.min(result[j],Math.abs(prev-j))\r\n   }\r\n   return result\r\n};\r\n复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n思路2\r\n先循环遍历一次，找到相同值的位置保存在一个数组ans中\r\n再次循环，将坐标与ans中的坐标差的绝对值，取最小的值\r\nvar shortestToChar = function(s, c) {\r\n    let ans=[],result=[];\r\n    for(let i=0;i<s.length;i++){\r\n        if(s.charAt(i)===c){\r\n            ans.push(i)\r\n        }\r\n    }\r\n    for(let i=0;i<s.length;i++){\r\n        let min=Math.abs(i-ans[0])\r\n        for(let j=1;j<ans.length;j++){\r\n            min=Math.min(min,Math.abs(i-ans[j]))\r\n        }\r\n        result[i]=min\r\n    }\r\n    return result\r\n};\r\n复杂度\r\n时间复杂度：O(n2)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839449634","body":"思路：暴力求解\r\nvar CustomStack = function (maxSize) {\r\n  this.stack = []\r\n  this.maxSize = maxSize\r\n};\r\n\r\n\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.stack.length < this.maxSize) {\r\n    this.stack.push(x)\r\n  }\r\n};\r\n\r\n\r\nCustomStack.prototype.pop = function () {\r\n if(this.stack.length){\r\n     return this.stack.pop()\r\n }else{\r\n     return -1\r\n }\r\n};\r\n\r\n\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (let i = 0; i < k && i < this.stack.length; i++) {\r\n    this.stack[i] += val\r\n  }\r\n};\r\n时间复杂度：o(n),空间复杂度o(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840550016","body":"\r\nvar decodeString = function(s) {\r\n    const stack = [];\r\n    const peek = () => stack[stack.length - 1]; // p.s. 不正经栈\r\n    const reg = /[a-zA-Z]+|[0-9]+|\\[|\\]/g;\r\n    while (reg.lastIndex < s.length) {\r\n        let token = reg.exec(s)[0];\r\n        if (token !== ']') {\r\n            // 数字，字母，左括号通通入栈\r\n            stack.push(token);\r\n        } else {\r\n            // 遇到右括号就开始出栈\r\n            let str = '';\r\n            // [] 中间的就是要重复的模式，把它们全部出栈，拼接起来\r\n            while (peek() !== '[') {\r\n                str = stack.pop() + str;\r\n            }\r\n            // 丢掉左括号\r\n            stack.pop();\r\n            // 左括号前面的一定是模式重复的次数\r\n            const num = +stack.pop();\r\n            // 把复制操作后的字符串放回栈中，作为外层 [] 模式的一部分\r\n            stack.push(str.repeat(num));\r\n        }\r\n    }\r\n    return stack.join('');\r\n};"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841220184","body":"解题思路：运用两个栈\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.stackOne=[]\r\n    this.stackTwo=[]\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stackOne.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    let index=this.stackOne.length-1;\r\n    while(index>0){\r\n        this.stackTwo.push(this.stackOne.pop())\r\n        index--\r\n    }\r\n    let temp=this.stackOne.pop()\r\n    let length=this.stackTwo.length;\r\n    while(length){\r\n        this.stackOne.push(this.stackTwo.pop())\r\n        length--\r\n    }\r\n    return temp\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stackOne[0]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stackOne.length===0\r\n};\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LS-King":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836635602","body":"### 思路\r\n\r\n重点关注进位：\r\n\r\n1. 设置中间变量digit，存放数字k、数组num和前位进位到该数位值的和（可以大于9），模10之后作为新的该数位数值，除10后的进位进入下层循环\r\n2. 对于最高位，需要考虑进位的位数增加带来的数组长度改变的问题，设置判断条件插入新的最高位，同时注意下标的改变\r\n\r\n### 代码\r\nC++\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int length = num.size();\r\n        int index = length;\r\n        int digit = 0;\r\n        while (k != 0 || digit != 0) {\r\n            //如果上一轮循环中已更新到num最高位，则在前面添加一个数位，将其值置为0\r\n            if (index == 0) {\r\n                num.insert(num.begin(), 0);\r\n            //下标迭代，每层循环向高位移动1位\r\n            } else {\r\n                index -= 1;\r\n            }\r\n            //上层循环的进位加上本轮循环对应数位上的值构成新的待定数位新值（可能超过9）\r\n            digit += k % 10;\r\n            //k去掉最后一位，等待下一轮循环\r\n            k /= 10;\r\n            //相同数位上数字相加（可能超过9）\r\n            digit += num[index];\r\n            //取个位部分作为该数位的新值\r\n            num[index] = digit % 10;\r\n            //将超过9的部分留到下一次循环\r\n            digit /= 10;\r\n        }\r\n        return num;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)，使用传进来的源数组num的空间。\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838681307","body":"### 思路\r\n\r\n开辟一个数组 chIndex 存放匹配字符的下标，之后遍历字符串，逐字符计算其下标与所有匹配字符下标差的绝对值，取最小值存入res数组\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> chIndex;\r\n        vector<int> res;\r\n        //遍历字符串，将匹配字符下标存入数组chIndex\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] == c) {\r\n                chIndex.push_back(i);\r\n            }\r\n        }\r\n        //遍历数组，逐字符计算其下标与所有匹配字符下标差的绝对值，取最小值存入res数组\r\n        for (int i = 0; i < s.size(); i++) {\r\n            //最大距离不超过10000\r\n            int distance = 10000;\r\n            for (int index : chIndex) {\r\n                distance = min(distance, abs(index - i));\r\n            }\r\n            res.push_back(distance);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N^2)，其中 N 为字符串长度。\r\n- 空间复杂度：O(N)，其中 N 为字符串长度。\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839881313","body":"### 思路\r\n\r\n\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass CustomStack {\r\n    vector<int> customstack;\r\n    int top = -1, maxSize = 0;\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        if (maxSize >= 0) {\r\n            this->maxSize = maxSize;\r\n        }\r\n    }\r\n    //压栈\r\n    void push(int x) {\r\n        if (top + 1 < maxSize) {\r\n            customstack.push_back(x);\r\n            top += 1;\r\n        }\r\n        return;\r\n    }\r\n    //弹栈\r\n    int pop() {\r\n        if (top + 1 > 0) {\r\n            int back = customstack.at(top);\r\n            customstack.pop_back();\r\n            top -= 1;\r\n            return back;\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for (int i = 0; i < k && i < top + 1; i++) {\r\n            customstack.at(i) += val;\r\n        }\r\n        return;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：increment函数 O(min(maxSize, k)), 其余 O(1)。\r\n- 空间复杂度：O(1)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840569699","body":"### 思路\r\n\r\n开辟一个存放整型的栈 sig 用来匹配和存放前中括号的下标，遇到 [ 将其下标入栈；遇到 ] 则弹栈，并向前寻找出重复次数，将重复后的新子串替换掉”数字+[原子串]“。\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string nums = \"0123456789\", res = s, numstr = \"\", sub = \"\";\r\n        //前括号下标栈\r\n        stack<int> sig;\r\n        int num, front, back, p = 0;\r\n        while (res[p] != '\\0') {\r\n            //若匹配到[，则将下标入栈\r\n            if (res[p] == '[') {\r\n                sig.push(p);\r\n            //若匹配到]，则将sig栈顶下标出栈，并对front, back赋值\r\n            } else if (res[p] == ']') {\r\n                front = sig.top();\r\n                sig.pop();\r\n                back = p;\r\n                //使用q作为下标寻找数字\r\n                int q = front - 1;\r\n                //向前寻找数字，跳出循环时，数字开始下标为q + 1\r\n                while (q >= 0 && nums.find(res[q]) != string::npos) {\r\n                    numstr += res[q];\r\n                    q--;\r\n                }\r\n                //将numstr逆序并转换为整型存入num\r\n                reverse(numstr.begin(), numstr.end());\r\n                num = stoi(numstr);\r\n                //将数字字符串重新置空\r\n                numstr = \"\";\r\n                //替换括号中的字符串\r\n                for (int i = 0; i < num; i++) {\r\n                    sub += res.substr(front + 1, back - front - 1);\r\n                }\r\n                res.replace(q + 1, back - (q + 1) + 1, sub);\r\n                //将字串重新置空\r\n                sub = \"\";\r\n                //修改遍历下标p的位置，使其指向替换后子串的结尾\r\n                p = q + 1 + num * (back - front - 1);\r\n                continue;\r\n            }\r\n            p++;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N), 其中N为字符串s的长度。\r\n- 空间复杂度：O(k), k为原字符串中中括号的对数。\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840998573","body":"### 思路\r\n\r\n做到均摊时间复杂度O(1)，关键在于将双栈看作整体，两者一起组成队列，而非一个模拟队列，一个作为辅助。\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> in, out;\r\n    void intoout () {\r\n        while (!in.empty()) {\r\n            out.push(in.top());\r\n            in.pop();\r\n        }\r\n    }\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {}\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        in.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if (out.empty()) {\r\n            intoout();\r\n        }\r\n        int res = out.top();\r\n        out.pop();\r\n        return res;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if (out.empty()) {\r\n            intoout();\r\n        }\r\n        return out.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return in.empty() && out.empty();\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(1), push和pop操作的均摊时间复杂度为O(1)，因为对于每个元素，从其入队到出队，一共经历两次入栈两次出栈，操作次数固定。\r\n- 空间复杂度：O(N)。\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heartinn":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836635929","body":"思路\r\n列表转数字直接相加再转回列表\r\n\r\n代码\r\nPython3\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        return map(int,str(int(''.join(map(str,A))) + K))\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838007634","body":"算法思想：\r\n前向遍历记录下每个位置和出现在前面的目标字符的距离，后向遍历记录每个位置和出现在后面的目标字符的距离\r\n\r\n代码：\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [len(s)] * len(s)\r\n        previous = -1\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                previous = i\r\n            if previous != -1:\r\n                result[i] = i - previous\r\n        latter = -1\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                latter = i\r\n            if latter != -1:\r\n                result[i] = min(result[i], latter - i)\r\n        return result\r\n\r\n复杂度\r\n时间：o(n)\r\n空间：o(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839381199","body":"思路\r\n使用一个额外的数组记录末尾的增量，在弹出时将增量往前传递\r\n\r\npython\r\nfrom collections import deque\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max_size = maxSize\r\n        self.top = -1\r\n        self.stack = deque()\r\n        self.add = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n            self.add.append(0)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            if len(self.add) > 1:\r\n                self.add[-2] += self.add[-1]\r\n            return self.stack.pop() + self.add.pop()\r\n        return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        idx = min(k, len(self.add)) - 1\r\n        if idx >= 0:\r\n            self.add[idx] += val\r\n\r\n复杂度分析\r\n时间复杂度：O(1)\r\n空间复杂度:O(n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840651779","body":"思路：\r\n遇到[时push进数字，遇到]时pop出子字符串，push进倍乘后的字符串\r\n\r\n复杂度分析：\r\n时间：单次for O(n)\r\n空间：O(n)\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        num = 0\r\n        string = \"\"\r\n        for token in s:\r\n            if token.isdigit():\r\n                num = num * 10 + int(token)\r\n            elif token == \"[\":\r\n                stack.append(num)\r\n                num = 0\r\n            elif token.isalpha():\r\n                stack.append(token)\r\n            else:\r\n                while isinstance(stack[-1], str):\r\n                    string = stack.pop() + string\r\n                stack.append(stack.pop() * string)\r\n                string = \"\"\r\n        return \"\".join(stack)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"UCASHurui":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836637454","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 思路\r\n先把数组A扩展到和K相加后可能的最长长度，然后模拟加法，每次取K的最低位和A中对应位以及进位相加，然后更新进位并将K除10后取整。（其实也可以把A转换成整数后相加，考虑到其他语言可能不像python能够自动进行大数运算所以还是转换成数组相加更好）\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        carry = 0\r\n        len_K, len_A = len(str(K)), len(A)\r\n        A = [0]*(max(len_A, len_K)-len_A + 1) + A\r\n        pos = len(A) - 1\r\n        while K or carry:\r\n                tmp = A[pos] + K%10 + carry\r\n                carry = tmp // 10\r\n                A[pos] = tmp%10\r\n                K = int(K/10)\r\n                pos -= 1\r\n        if A[0]==0: return A[1:]\r\n        return A\r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837870441","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n两趟遍历分别找到每一个位置左方和右方距离最近的目标字符，取其中最小值计入最终结果。\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        povit = -float('inf')\r\n        res = [0] * len(S)\r\n        for i in range(len(S)):\r\n            if S[i] == C:\r\n                povit = i\r\n            else:\r\n                res[i] = i-povit\r\n        povit = float('inf')\r\n        for i in range(len(S)-1, -1, -1):\r\n            if S[i] == C:\r\n                povit = i\r\n            else:\r\n                res[i] = min(res[i], povit-i)\r\n        return res\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837870441","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n两趟遍历分别找到每一个位置左方和右方距离最近的目标字符，取其中最小值计入最终结果。\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        povit = -float('inf')\r\n        res = [0] * len(S)\r\n        for i in range(len(S)):\r\n            if S[i] == C:\r\n                povit = i\r\n            else:\r\n                res[i] = i-povit\r\n        povit = float('inf')\r\n        for i in range(len(S)-1, -1, -1):\r\n            if S[i] == C:\r\n                povit = i\r\n            else:\r\n                res[i] = min(res[i], povit-i)\r\n        return res\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841762508","body":"\r\n## 题目地址(61. 旋转链表)\r\n\r\nhttps://leetcode-cn.com/problems/rotate-list/\r\n\r\n## 思路\r\n首先一趟遍历找到链表末尾并找到链表的长度length，因为k有可能比链表的长度要大，所以对长度求模一下，如果求模后的k为0的话就直接返回head即可，否则从头开始遍历length-k-1个位置找到切割节点，将切割节点的下一个节点设置为新的head，之前找到的链表末尾节点的next设置为原本的head，切割节点的next设置为空即可。\r\n\r\n## 关键点\r\n\r\n- 认识到旋转链表就是找到一个切割点将链表切成两部分，并把前一段拼到后一段的后面。\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head or not head.next or k==0: return head\r\n        tail = p = head\r\n        length = 1\r\n        while tail.next:\r\n            tail = tail.next\r\n            length += 1\r\n        k %= length\r\n        if k == 0: return head\r\n        for _ in range(length - k - 1):\r\n            p = p.next\r\n        new_head = p.next\r\n        p.next = None\r\n        tail.next = head\r\n        return new_head\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BraveSage":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836638684","body":"## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n### 思路\r\n\r\n1. 模拟数字加法，倒序遍历数组和每次取得整数K的各位数的值进行相加\r\n2. 判断当前位数的数是否大于10，如果大于10在整数k中进行+1\r\n3. 让k除以10，确保计算的位数与数组一致\r\n\r\n\r\n\r\n### 代码（两种思路一致，不过下方节省了一个while循环）\r\n\r\n- Java\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList();\r\n        for(int i = num.length-1; i >= 0; i--){\r\n            int temp = num[i] + k%10;\r\n            ans.add(temp%10);\r\n            k /= 10;\r\n            if(temp >= 10) k++;\r\n        }\r\n        while(k != 0){\r\n            ans.add(k%10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList();\r\n        for(int i = num.length-1; i >= 0 || k > 0; i--, k/=10){\r\n            if(i >= 0){\r\n                k += num[i];\r\n            }\r\n            ans.add(k%10);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\n时间：O(max(n,log(k))) 整数与数组长度之间取最大\r\n\r\n空间：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838733842","body":"## 题目描述\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n- 字符串 S 的长度范围为 [1, 10000]。\r\n- C 是一个单字符，且保证是字符串 S 里的字符。\r\n- S 和 C 中的所有字母均为小写字母。\r\n```\r\n\r\n\r\n\r\n### 思路\r\n\r\n获取指定string的当前前一个为c的索引位置与当前索引位置的最小值即可，然后记录在res数组当中\r\n\r\n### 代码\r\n\r\n- Java\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int length = S.length();\r\n        int[] res = new int[length];\r\n        int prev = S.indexOf(C),next = S.indexOf(C, prev+1);\r\n        for (int i = 0; i < length; i++){\r\n            res[i] = Math.abs(i-prev);\r\n            if(next!=-1){\r\n                res[i] = Math.min(res[i],next-i);\r\n                if(i==next){\r\n                    prev = next;\r\n                    next = S.indexOf(C,next+1);\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：O(n)\r\n\r\n空间：O(n) 创建了为S.length()长度的数组"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839873183","body":"## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1); // 栈变为 [1]\r\ncustomStack.push(2); // 栈变为 [1, 2]\r\ncustomStack.pop(); // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2); // 栈变为 [1, 2]\r\ncustomStack.push(3); // 栈变为 [1, 2, 3]\r\ncustomStack.push(4); // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100); // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100); // 栈变为 [201, 202, 103]\r\ncustomStack.pop(); // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop(); // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop(); // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop(); // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n### 思路\r\n\r\n使用数组实现一个简单的栈\r\n\r\n\r\n\r\n### 代码\r\n\r\n- java\r\n\r\n```java\r\nclass CustomStack {\r\n\r\n    int [] stack;\r\n    int size = 0;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(size == stack.length){\r\n            return ;\r\n        }\r\n        stack[size++] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(size == 0) return -1;\r\n        return stack[--size];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i = 0; i < stack.length && i < k; i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\n- push：\r\n\r\n时间：O(1)\r\n\r\n空间：O(1)\r\n\r\n- push：\r\n\r\n时间：O(1)\r\n\r\n空间：O(1)\r\n\r\n- push：\r\n\r\n时间：O(min(n,m)) n为数组长度，m为k的大小\r\n\r\n空间：O(1)"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841656439","body":"## 题目描述\r\n\r\n```\r\n这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\r\n\r\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\r\n\r\n我们最多能将数组分成多少块？\r\n\r\n示例 1:\r\n\r\n输入: arr = [5,4,3,2,1]\r\n输出: 1\r\n解释:\r\n将数组分成2块或者更多块，都无法得到所需的结果。\r\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。\r\n示例 2:\r\n\r\n输入: arr = [2,1,3,4,4]\r\n输出: 4\r\n解释:\r\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\r\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。\r\n注意:\r\n\r\narr的长度在[1, 2000]之间。\r\narr[i]的大小在[0, 10**8]之间。\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 思路\r\n\r\n该题本质上就是求出正序排序的个数，在遍历数组的同时，如果当前栈顶没有大于当前下标数组元素，就可以组成两块，否则就只有一块。通过求出每次的当前下标是否是栈顶最大值即可求出最多的块数\r\n\r\n\r\n\r\n### 代码\r\n\r\n- java\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack();\r\n        for(int i = 0; i < arr.length; i++){\r\n            int num = arr[i];\r\n            if(stack.isEmpty() || stack.peek() <= num){\r\n                stack.push(num);\r\n            }else{\r\n                if(!stack.isEmpty() && stack.peek() > num){\r\n                    stack.pop();\r\n                }\r\n                stack.push(num);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\n时间：O(N)\r\n\r\n空间：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"KevinWorkSpace":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836639151","body":"## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int index = A.length - 1;\r\n        int add = 0;\r\n        while (index >= 0 || K > 0 || add > 0) {\r\n            int a = 0;\r\n            if (index >= 0) a = A[index];\r\n            int b = K % 10;\r\n            int tmp = (a + b + add) % 10;\r\n            add = (a + b + add) / 10;\r\n            res.add(tmp);\r\n            K /= 10;\r\n            index --;\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838339270","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int index = -1;\r\n        for (int i=0; i<res.length; i++) {\r\n            if (s.charAt(i) == c) {\r\n                res[i] = 0;\r\n                index = i;\r\n            }\r\n            else if (index == -1) res[i] = Integer.MAX_VALUE;\r\n            else res[i] = i - index;\r\n        }\r\n        index = -1;\r\n        for (int i=res.length-1; i>=0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            else if (index == -1) res[i] = Math.min(Integer.MAX_VALUE, res[i]);\r\n            else res[i] = Math.min(index - i, res[i]);\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838339270","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int index = -1;\r\n        for (int i=0; i<res.length; i++) {\r\n            if (s.charAt(i) == c) {\r\n                res[i] = 0;\r\n                index = i;\r\n            }\r\n            else if (index == -1) res[i] = Integer.MAX_VALUE;\r\n            else res[i] = i - index;\r\n        }\r\n        index = -1;\r\n        for (int i=res.length-1; i>=0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            else if (index == -1) res[i] = Math.min(Integer.MAX_VALUE, res[i]);\r\n            else res[i] = Math.min(index - i, res[i]);\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841182191","body":"\r\n## 题目地址(232. 用栈实现队列)\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass MyQueue {\r\n\r\n    Stack<Integer> s1 = new Stack<>();\r\n    Stack<Integer> s2 = new Stack<>();\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (!s2.isEmpty()) return s2.pop();\r\n        else {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (!s2.isEmpty()) return s2.peek();\r\n        else {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.peek();\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841752932","body":"\r\n## 题目地址(61. 旋转链表)\r\n\r\nhttps://leetcode-cn.com/problems/rotate-list/\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) return null;\r\n        int cnt = 0;\r\n        ListNode n = head;\r\n        while (n != null) {\r\n            cnt ++;\r\n            n = n.next;\r\n        }\r\n        if (k % cnt == 0) return head;\r\n        ListNode node = head;\r\n        for (int i=0; i<k%cnt; i++) {\r\n            node = node.next;\r\n        }\r\n        ListNode pre = null;\r\n        ListNode tmp = head;\r\n        ListNode last = null;\r\n        while (node != null) {\r\n            pre = tmp;\r\n            tmp = tmp.next;\r\n            last = node;\r\n            node = node.next;\r\n        }\r\n        last.next = head;\r\n        pre.next = null;\r\n        return tmp;\r\n    }\r\n}\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ssxgit":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836641307","body":"# 989. 数组形式的整数加法\r\n主要是需要一个进位的表示，最终要保证三个部分都加完\r\n\r\n## 代码\r\n- 语言：c++\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n\r\n        vector<int> res;\r\n\r\n        int carry_bit = 0;\r\n\r\n        int loc = num.size() - 1;\r\n\r\n        while(loc>-1 || k > 0 || carry_bit > 0){\r\n            int num1 = loc>-1?num[loc]:0;\r\n            int num2 = k % 10;\r\n\r\n            int value = num1 + num2 + carry_bit;\r\n\r\n            res.emplace_back((value % 10));\r\n            carry_bit = value / 10; \r\n\r\n            --loc;\r\n            k /= 10;\r\n        }\r\n        \r\n        reverse(res.begin(),res.end());\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838312453","body":"# 821. 字符的最短距离\r\n[leetcode 821](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n## 思路：\r\n1. 从左到右遍历保存每一个字符距离其左边最近的字符 c 的 距离\r\n2. 从右到左遍历保存每一个字符距离其右边最近的字符 c 的 距离\r\n3. 取上面两个距离的更小值即可，可以只用一个数组来存\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        if(s.empty()) return {};\r\n        vector<int> res(s.size(),INT_MAX);\r\n        int pre_c_loc = -1;\r\n        for(int i=0;i<s.size();++i){\r\n            if(s[i] == c){\r\n                pre_c_loc = i;\r\n                res[i] = 0;\r\n            }\r\n            else if(pre_c_loc != -1) res[i] = i - pre_c_loc;\r\n        }\r\n\r\n        pre_c_loc = s.size();\r\n        for(int i=s.size()-1;i>-1;--i){\r\n            if(s[i] == c) pre_c_loc = i;\r\n            else if(pre_c_loc != s.size()) res[i] = min(res[i],pre_c_loc - i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)  //最终需要返回的结果数组不计算复杂度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839728875","body":"# 1381. 设计一个支持增量操作的栈\r\n[leetcode 1381](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\r\n\r\n## 思路\r\n1. 最直观的想法就是用可变长数组来模拟\r\n2. 但是这样inc操作的时间复杂度是O(k)\r\n3. 所以要新加一个数组来表示加val,而且只能是一位加,不断往前推\r\n\r\n### 代码\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    int top;\r\n    vector<int> sta,increase;\r\n    CustomStack(int maxSize) {\r\n        top = -1;\r\n        sta.resize(maxSize);  //resize之后默认全0\r\n        increase.resize(maxSize);\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top < (int)sta.size()-1){   //必须转int,因为size_type是无符号整数\r\n            sta[++top] = x;\r\n        } \r\n    }\r\n    \r\n    int pop() {\r\n        if(top == -1) return -1;\r\n\r\n        if(top > 0) increase[top-1] += increase[top];  //增量往前推\r\n\r\n        int res = sta[top] + increase[top];\r\n        increase[top] = 0;\r\n\r\n        --top;\r\n\r\n        return res;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n       int d = min(k-1,top);\r\n       if(d > -1 && d < (int)sta.size()) increase[d] += val; \r\n       //可能在数组没有元素的时候调用inc\r\n       //可能在数组满的时候调用inc\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```\r\n### 复杂度分析\r\n时间复杂度：push:O(1),pop:O(1),inc:O(1)\r\n空间复杂度：O(maxsize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840552440","body":"# 394. 字符串解码\r\n[leetcode 394](https://leetcode-cn.com/problems/decode-string/)\r\n\r\n## 思路: 栈\r\n1. 遍历字符串，字母、数字、左括号直接入栈（变换为字符串）\r\n2. 遇到右括号，一直出栈直到遇到左括号，弹出左括号，按照出栈顺序反向拼接字符串为s1\r\n3. 此时栈顶为数字字符串，即为s1的出现次数t，将s1重复t次，重复后的字符串再入栈\r\n4. 继续上述过程，直到遍历到编码字符串尾部，将栈中字符串弹出，按照出栈顺序反向拼接字符串为r,即为最终答案\r\n5. 这个思路的关键是遇到左括号直接入栈，遇到右括号需要出栈，一直到左括号，将中间的字符串拼接起来\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res;\r\n        vector<string> stk;\r\n        int i=0;\r\n        while(i<s.size()){\r\n            if((s[i]>='a' && s[i]<='z') || s[i] == '['){\r\n                stk.push_back(string(1,s[i]));\r\n                ++i;\r\n            }\r\n            else if(s[i]>='0' && s[i]<='9'){\r\n                stk.push_back(getTime(s,i));\r\n            }\r\n            else{\r\n                string ret;\r\n                vector<string> st_vec;\r\n                while(stk.back() != \"[\"){\r\n                    st_vec.emplace_back(stk.back());stk.pop_back();\r\n                }\r\n                reverse(st_vec.begin(),st_vec.end());  //反向\r\n                string in_st = getString(st_vec); //拼接\r\n                stk.pop_back();\r\n                int times = stoi(stk.back());stk.pop_back();\r\n                while(times--){\r\n                    ret += in_st;\r\n                }\r\n                stk.push_back(ret);\r\n\r\n                ++i;\r\n            }\r\n        }\r\n        for(auto& st:stk){\r\n            res += st;\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    string getTime(const string& s,int& i){\r\n        string times;\r\n        while(s[i]>='0' && s[i]<='9'){\r\n            times.push_back(s[i]);\r\n            ++i;\r\n        }\r\n        return times;\r\n    }\r\n\r\n    string getString(vector<string> str_vector){\r\n        string st;\r\n        for(auto &str:str_vector){\r\n            st += str;\r\n        }\r\n        return st;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(S)  //S为解码后的字符串长度\r\n空间复杂度：O(S) //"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841193008","body":"# 223. 用两个栈实现队列\r\n[leetcode 232](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\r\n用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。\r\n\r\n\r\n## 思路\r\n1. 栈先进后出，队列先进先出，那么需要想办法将先进入栈stack1的元素先拿出来\r\n2. 再将其放到另一个栈stack2中，则最前面进去的元素就在stack2的栈顶了，弹出即可\r\n3. 但是需要注意当stack2为空时将stack1的全部元素放到stack2中才行\r\n\r\n### 代码\r\n```c++\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    stack<int> stack1;\r\n    stack<int> stack2;\r\n    MyQueue() {\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        stack2.push(x);\r\n\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        int res = peek();\r\n        stack1.pop();\r\n\r\n        return res;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if(stack1.empty()){\r\n            while(!stack2.empty()){\r\n                stack1.push(stack2.top());\r\n                stack2.pop();\r\n            }\r\n        }\r\n\r\n        return stack1.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n\r\n        return stack1.empty() && stack2.empty();\r\n\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(1)  //push的复杂度为O(1),pop,peek操作的均摊复杂度为O(1)\r\n空间复杂度：O(n)  //两个栈存储元素 "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841647662","body":"# 768. 最多能完成排序的块 II\r\n\r\n## 思路：\r\n1. 直观来说，就是把数组划分为几个块，使得块之间有序，问最多能划分为几个块\r\n2. 考虑arr[:j]已经生成几个块b[0],b[1],..,b[k],再加入arr[j]之后能有多少个块？\r\n3. 当arr[j]>b[m].max,arr[j] < b[m+1].max, 则b[m+1:k]与arr[j]可以合并成一个块\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        if(arr.empty()) return 0;\r\n\r\n        vector<vector<int> > tmp{{arr[0],arr[0]}};\r\n\r\n        for(int i=1;i<arr.size();++i){\r\n            //可以自成一个块\r\n            if(arr[i] >= tmp.back()[1]) tmp.push_back({arr[i],arr[i]});\r\n            else{\r\n                int minValue = tmp.back()[0],maxValue=tmp.back()[1];\r\n                //一直找到可以合并的块\r\n                while(!tmp.empty() && arr[i] < tmp.back()[1]){\r\n                    minValue = tmp.back()[0];\r\n                    tmp.pop_back();\r\n                }\r\n                minValue  = min(minValue,arr[i]);\r\n                tmp.push_back({minValue,maxValue});\r\n            }\r\n            \r\n        }\r\n\r\n        return tmp.size();\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n) //均摊时间复杂度O(n)\r\n空间复杂度：O(n) "},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fenglei110":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836644430","body":"python\r\n\r\npython语言的设计就是太动态了，int和str可以互转。\r\n\r\n列表迭代式 + lambda表达式\r\n平时也是这样写，感觉代码很简洁。但是你要问我这样的代码有什么不足，还真答不上来。\r\n\r\n```py\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        return  list(map(int, str(int(''.join(map(str, num)))+k)))\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839817225","body":"> ### 思路\r\n> 给定一个变量来记录栈顶的位置，更新数据来模拟栈的操作，但因为实质是函数内的数组，所以可以实现对除了栈顶元素外的改动。（后续再优化）\r\n> \r\n> ### 代码\r\n> ```python\r\n> class CustomStack:\r\n> # use array in function makes the each elenments in stack \"visable\"\r\n> \r\n>     def __init__(self, maxSize: int):\r\n>         self.stk = [0]*maxSize\r\n>         self.top = -1\r\n> \r\n>     def push(self, x: int) -> None:\r\n>         # if stack size is smaller than maxSize, push in\r\n>         # maxSize is not defined in this function, so use len of stack instead\r\n>         if self.top < len(self.stk)-1:\r\n>             self.stk[self.top+1] = x\r\n>             self.top += 1\r\n> \r\n>     def pop(self) -> int:\r\n>         # if stack is empty, return -1\r\n>         # if stack is not empty, return the top value and delete it in the stack (no need)\r\n>         if self.top == -1:\r\n>             return -1\r\n>         self.top -= 1\r\n>         return self.stk[self.top + 1]\r\n> \r\n>     def increment(self, k: int, val: int) -> None:\r\n>         # use the minimum value between k and self.stk length, then traverse\r\n>         if k>-1:\r\n>             for i in range(min(self.top+1,k)):\r\n>                 self.stk[i]+=val\r\n> ```\r\n> \r\n> **复杂度分析**\r\n> \r\n> * 时间复杂度：O(min(k, maxSize)),\r\n> * 空间复杂度：O(maxSize)\r\n\r\n跑错场了兄弟"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1998yyh":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836644503","body":"### 思路\r\n循环数组按位相加，同时对应修改k，循环完成后当k大于0，再对k处理。\r\n### 代码\r\njavascript\r\n``` javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const len = num.length;\r\n    const resultArr = [];\r\n    for(let i = len -1; i>=0;i--){\r\n        const _num = k%10;\r\n        k = Math.floor(k/10);\r\n        const sum = _num + num[i];\r\n        if(sum>9){\r\n            k++\r\n        }\r\n        resultArr.unshift(sum%10);\r\n    }\r\n    while(k>0){\r\n        resultArr.unshift(k%10)\r\n        k = Math.floor(k/10);\r\n    }\r\n    return resultArr\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838434616","body":"### 思路\r\n用一个变量保存出现的位置，从左往右，从右往左分别遍历一次，取最小值\r\n### 代码\r\njavascript\r\n``` javascript\r\nvar shortestToChar = function (s, c) {\r\n    let flag = -1;\r\n    const len = s.length;\r\n    const result = new Array(len).fill(Infinity);\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] !== c && flag < 0) continue;\r\n        if (s[i] === c) {\r\n            result[i] = 0;\r\n            flag = i\r\n        } else {\r\n            result[i] = Math.min(i - flag, result[i])\r\n        }\r\n    }\r\n    flag = -1;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] !== c && flag < 0) continue;\r\n        if (s[i] === c) {\r\n            result[i] = 0;\r\n            flag = i\r\n        } else {\r\n            result[i] = Math.min(flag - i, result[i])\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839752845","body":"### 思路\r\n### 代码\r\njavascript\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.stack = [];\r\n    this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    const len = this.stack.length;\r\n    if(len < this.maxSize){\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    const result = this.stack.pop();\r\n    return result || -1\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const len = Math.min(k,this.stack.length);\r\n    for(let i = 0;i < len;i++){\r\n        this.stack[i] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840577967","body":"### 思路\r\n使用两个栈分别存储数字与字母\r\n### 代码\r\njavascript\r\n```javascript\r\nvar decodeString = function (s) {\r\n    const numStack = [];\r\n    const strStack = [];\r\n    const len = s.length;\r\n    let num = 0;\r\n    let result = '';\r\n    for (let i = 0; i < len; i++) {\r\n        if (!isNaN(s[i])) {\r\n            num = num * 10 + Number(s[i])\r\n        } else if (s[i] === '[') {\r\n            strStack.push(result);\r\n            result = ''\r\n            numStack.push(num)\r\n            num = 0\r\n        } else if (s[i] === ']') {\r\n            result = strStack.pop() + result.repeat(numStack.pop())\r\n        } else {\r\n            result += s[i]\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841215878","body":"### 思路\r\n### 代码\r\nJavaScript\r\n```javascript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n    this.restack = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if(this.restack.length === 0){\r\n        while(this.stack.length){\r\n            this.restack.push(this.stack.pop())\r\n        }\r\n    }\r\n    return this.restack.pop();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if(this.restack.length === 0){\r\n        while(this.stack.length){\r\n            this.restack.push(this.stack.pop())\r\n        }\r\n    }\r\n    return this.restack[this.restack.length-1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.restack.length === 0 && this.stack.length === 0;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joriscai":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836661706","body":"# 思路\r\n先将k转成数组，再利用双指针分别从k和num的最后一位开始按位计算。注：需要考虑最后一次进位的情况。\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=989 lang=javascript\r\n *\r\n * [989] 数组形式的整数加法\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  const kArr = (k + '').split('')\r\n  const ret = []\r\n\r\n  let i = num.length - 1\r\n  let j = kArr.length - 1\r\n  let tmp = 0\r\n  while (i >= 0 || j >= 0 || tmp) {\r\n    const count = parseInt(num[i] || 0) + parseInt(kArr[j] || 0) + tmp\r\n    ret.unshift(count % 10)\r\n    tmp = parseInt(count / 10)\r\n    i--\r\n    j--\r\n  }\r\n  return ret\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(max(n, log k))，其中 n 为数组的长度。log k为k的位，即log 10(k)，10为底k的对数。\r\n空间复杂度：O(max(n, log k))。"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838475940","body":"# 思路\r\n通过字符串正反向遍历，从两种方式中找到最接近的值。\r\n- 注：正反向遍历时，默认值都为正无穷大\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=821 lang=javascript\r\n *\r\n * [821] 字符的最短距离\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const ret = []\r\n  let near = Infinity\r\n  // 从左到右，记录距离\r\n  for (let i = 0; i < s.length; i++) {\r\n    const char = s[i]\r\n    if (char === c) {\r\n      ret.push(0)\r\n      near = 0\r\n    } else {\r\n      ret.push(++near)\r\n    }\r\n  }\r\n\r\n  // 从右到左了，要将距离设为正无穷大\r\n  near = Infinity\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    const char = s[i]\r\n    if (char === c) {\r\n      near = 0\r\n    } else {\r\n      // 比较当前值和右到左的距离，取最小的那个\r\n      ret[i] = Math.min(ret[i], ++near)\r\n    }\r\n  }\r\n\r\n  return ret\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n)，只遍历了两次字符串\r\n\r\n空间复杂度：O(n)，结果跟字符串长度一样"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839821696","body":"# 思路\r\n- push方法要限制超过长度时不入栈\r\n- pop方法为了让所有操作都为O(1)的话，在出栈时再进行增加操作\r\n  - 出栈时要取出对应的增加值，并与栈顶值相加\r\n  - 由于数据出栈了，对应位置的加值无用，故对应位置的加值设为0，即默认值\r\n  - 由于inc方法的k是指栈底的 k 个元素，故此时下一位的加值要加上此次取出的加值，inc方法是栈底k个元素都增加val。\r\n- increment方法在对应的位置累加上加值即可 O(1)\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=1381 lang=javascript\r\n *\r\n * [1381] 设计一个支持增量操作的栈\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.size = maxSize\r\n  this.stack = []\r\n  this.add = []\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.stack.length < this.size) {\r\n    this.stack.push(x)\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  // 方法一\r\n  // return this.stack.pop() || -1\r\n\r\n  // 方法二\r\n  const len = this.stack.length\r\n  if (len === 0) {\r\n    return -1\r\n  }\r\n\r\n  const add = this.add[len] || 0\r\n  // 由于只记录当前栈顶的增加值\r\n  // 故要更新下一个栈顶\r\n  this.add[len - 1] = this.add[len - 1] || 0\r\n  this.add[len - 1] += add\r\n  // 出栈后，对应位置的增加值无用，重置为0\r\n  this.add[len] = 0\r\n\r\n  const curr = this.stack.pop()\r\n\r\n  return curr + add\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  // 方法一\r\n  // const len = Math.min(this.stack.length, k)\r\n  // for (let i = 0; i < len; i++) {\r\n  //   this.stack[i] += val\r\n  // }\r\n\r\n  // 方法二\r\n  const index = Math.min(this.stack.length, k)\r\n  this.add[index] = this.add[index] || 0\r\n  this.add[index] += val\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(1)，三个方法都是O(1)\r\n\r\n空间复杂度：O(n)，一个栈空间和一个加值存放空间，两个都是n的长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840560534","body":"# 思路\r\n- 使用栈来存放最终的输出的内容\r\n- 遍历字符串\r\n  - 当非]右括号时，直接入栈\r\n  - 当遇到]右括号时，开始出栈，直到遇到[左括号。此时的子字符串是要重复的字符串\r\n  - 继续出栈，取重复次数的数值，考虑到大于9的情况，需要不断取栈的值并判断是否为数字\r\n  - 由于栈是最终的结果，再加上需要考虑2[3[ab]]嵌套括号的情况，故待重复的子字符串在组合后，要重新入栈中\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=394 lang=javascript\r\n *\r\n * [394] 字符串解码\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  let result = ''\r\n  const stack = []\r\n  for (let i = 0; i < s.length; i++) {\r\n    const char = s[i]\r\n    if (char !== ']') {\r\n      stack.push(char)\r\n      continue\r\n    }\r\n\r\n    // 当是]时\r\n    let prev = stack.pop()\r\n    let subStr = ''\r\n    // 找到[]里面的字符串\r\n    while (prev !== '[') {\r\n      subStr = prev + subStr\r\n      prev = stack.pop()\r\n    }\r\n\r\n    // 继续往前找数字\r\n    let num = ''\r\n    prev = stack.pop()\r\n    while (!Number.isNaN(Number(prev))) {\r\n      num = prev + num\r\n      prev = stack.pop()\r\n    }\r\n\r\n    // 上面先出栈一个字符，再判断是否为数字，会多取一个字符了。\r\n    stack.push(prev)\r\n    // 经过上面解开一个[]括号后，将拼接好字符串，重新入栈\r\n    stack.push(subStr.repeat(Number(num)))\r\n  }\r\n  return stack.join('')\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n)，只遍历了一次字符串，当中可能涉及出栈的操作\r\n\r\n空间复杂度：O(n)，只用一个栈来存放最终的结果，当中有重复的字符串，最终是大于s.length"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841256843","body":"# 思路\r\n使用双栈，在push方法时，将数据反序再插入，即存放数据的栈出栈放入另一个栈实现反序，最后还原原来的顺序。\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=232 lang=javascript\r\n *\r\n * [232] 用栈实现队列\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n  this.stack = []\r\n  this.helpStack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue.\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n  let cur = null;\r\n  while ((cur = this.stack.pop())) {\r\n    this.helpStack.push(cur)\r\n  }\r\n  this.helpStack.push(x)\r\n\r\n  while ((cur = this.helpStack.pop())) {\r\n    this.stack.push(cur)\r\n  }\r\n};\r\n\r\n/**\r\n * Removes the element from in front of the queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n  return this.stack.pop();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n  return this.stack[this.stack.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n  return this.stack.length === 0\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n// @lc code=end\r\n\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n)，在push方法需要全部出栈入栈，故为O(n)，其他都是O(1)\r\n\r\n空间复杂度：O(n)，两个栈，但是同时只有一个栈不为空"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841665160","body":"# 思路\r\n- 滑动窗口\r\n- 一段区间内，若原数组的总和与排序后的数组的总和相等，则说明该区间排序后所在的位置与全部排序后相对应\r\n- 判断可以分块后，故要将重新保持一致，找下一个分块\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=768 lang=javascript\r\n *\r\n * [768] 最多能完成排序的块 II\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n  const sortArr = [...arr].sort((a, b) => a - b)\r\n  let sum1 = 0\r\n  let sum2 = 0\r\n  let count = 0\r\n  for (let i = 0; i < arr.length; i++) {\r\n    // 判断原数组与排序后的数组的总和是否一样\r\n    sum1 += arr[i]\r\n    sum2 += sortArr[i]\r\n    // 若一样，则说明当前区间可以排序最终的结果，可以分块\r\n    if (sum1 === sum2) {\r\n      count += 1\r\n      // 由于已经分块，故要将重新保持一致，找下一个分块\r\n      // 其实两个结果都相等才能成立分块，已经保持一致了，下面的可不用置零\r\n      // 考虑到可以溢出的问题，建议设置为零\r\n      sum1 = 0\r\n      sum2 = 0\r\n    }\r\n  }\r\n  return count\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(NlogN)，只遍历一次数组，但是数组的排序更加耗时，数组排序大概是O(NlogN)\r\n\r\n空间复杂度：O(N)，用了三个变量，还有存放排序后的数组，故为O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836666773","body":"## 思路\r\n遍历数组， 因为知道在第i位 数等于 i* 10**(len(num)-1) 可以得到数组的和。分解成数组形式时，可以用python的特性转换int 和 str，也可以使用whole divde 和 modulo 一位一位得分别append 到 数组中。这里使用了第一种方法\r\n## 代码\r\nPython\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        leng = len(num)\r\n        sum = 0\r\n        for i in num:\r\n            sum += i* 10**(leng-1)\r\n            leng-=1\r\n        return [int(i) for i in str(sum+k)]\r\n```\r\n### 复杂度分析\r\n时间：O(n)\r\n空间：O(1)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-840323210","body":"## 思路：\r\n先声明一个 array of infinity，从左向右遍历，用prev记录c出现的index，即每个元素等于curr-prev。再从右向左遍历，用nex 记录c出现的index， 即每个元素等于min(output[curr], next-curr)\r\n## 复杂度：\r\nO(n) 时间，空间\r\n## 代码：\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        output = [float(\"inf\")] * len(s)\r\n        prev = float(\"-inf\")\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                output[i] = 0\r\n                prev = i\r\n            else:\r\n                output[i] = i-prev\r\n        \r\n        j = len(s)-1\r\n        nex = float(\"inf\")\r\n        while j >=0:\r\n            if s[j] == c:\r\n                nex = j\r\n            else:\r\n                if nex-j < output[j]:\r\n                    output[j] = nex-j \r\n            j-=1\r\n        return output\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840657658","body":"## 思路\r\n辅助栈，自己想了好久，感觉到了应该使用 递归和 辅助栈，但是具体操作不太会，参考了力扣题解第一篇：\r\nstack 储存前缀的其他字母和本次res 需要重复的次数，遇到\"]\" 即 开始 更新 res\r\n## 复杂度\r\n空间复杂度： O(N)\r\n时间复杂度：O(N)\r\n## Code\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        # stack is used to remember the nested relation \r\n        stack = []\r\n        res = \"\"\r\n        multi = \"\"\r\n        for i in range(0, len(s)):\r\n            if s[i] == \"[\":\r\n                stack.append((res, multi))\r\n                res = \"\"\r\n                multi = \"\"\r\n            elif \"0\" <= s[i] <= \"9\":\r\n                multi += s[i]\r\n            elif \"a\" <= s[i] <= \"z\" or \"A\" <= s[i] <= \"Z\":\r\n                res += s[i]\r\n            elif s[i] == ']':\r\n                (last_res, last_multi) = stack.pop()\r\n                res = last_res + int(last_multi)*res\r\n        return res\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840991023","body":"## 思路：\r\n一开始自己想的时候用了一个时间空间都为O(N) 的方式，即每次push 都需要使用一个辅助栈，pop，peek 都为 O(1)。看了热评思路，知道了所有代码可以达到 amortized O(1)。每次push element 只需要push到 辅助栈，**pop时，因为我们不care 后面来的 element （因为 FIFO)， 我们只需要return 已经 push 到主栈 的top element （主栈的顺序是 我们想达到的FIFO)**，只有当主栈为空时，我们就可以通过辅助栈更新主栈。 peek 类似\r\n\r\n## Code：\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.inStack = []\r\n        self.outStack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.inStack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.outStack:\r\n            while self.inStack:\r\n                self.outStack.append(self.inStack.pop())\r\n        return self.outStack.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.outStack:\r\n            while self.inStack:\r\n                self.outStack.append(self.inStack.pop())\r\n        return self.outStack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return True if not self.outStack and not self.inStack else False\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n## Time Complexity:\r\npeek, pop: amortized O(1)\r\npush: O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841635629","body":"## 思路一：\r\n如果所有这个块后面的数都大于块的最大数head，即块成立\r\n参考了高赞题解的思路一：遍历arr，初始化window 为一个element，判断每个块是否成立； 如果不成立则右扩window，如果成立则count+=1 并右移window\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        p1,p2 = 0,0\r\n        count = 0\r\n        while p2 < len(arr):\r\n            head = max(arr[p1:p2+1])\r\n            if p2 == len(arr) -1:        # window reaches the last element, it must be a valid block\r\n                count+=1\r\n                p2+=1\r\n            for j in range(p2+1, len(arr)):\r\n\r\n                if j == len(arr) -1 and arr[j] >= head:\r\n                    p1,p2 = p2+1, p2+1\r\n                    count += 1\r\n                elif arr[j]<head:\r\n                    p2+=1\r\n                    break\r\n        return count\r\n```\r\n时间O(N^2) 空间O(1)\r\n\r\n## 思路2：\r\n参考了高赞题解的思路二：排序块的成立只需要使用到head，那我们可以利用栈来记录可能的排序块的head，遍历所有元素，如果当前数字大于等于栈顶，则说明当前数字对上一个块没有影响，单独push这个数字入栈。 如果当前数字小于栈顶，说明当前数字对当前栈顶 块有影响，先pop出这个块的head（先pop并标记为head是为了记忆更新后的块的最大值也会为 head，这个head 一定是更新后的块的最大值），再遍历pop出会被当前数字影响的head，即pop 意味着 块的合并，当块再也不能被合并时（即当前数字大于栈顶head 时），说明当前栈顶不会被当前数字给影响，就再次push 记忆的head。\r\n## 代码\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        i = 0\r\n        stack = []\r\n        while i < len(arr):\r\n            # arr[i] has no impact on the block\r\n            if (not stack) or (arr[i] >= stack[-1]):\r\n                stack.append(arr[i])\r\n            # arr[i] has impact\r\n            elif stack and arr[i] < stack[-1]:\r\n                head = stack.pop()\r\n                # determine where does this arr[i] will impact\r\n                # this will ends when arr[i] >= stack[-1]: which means no further impact\r\n                while stack and arr[i] < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(head)\r\n            i += 1\r\n\r\n        return len(stack)\r\n```\r\n## 复杂度\r\n时间 O(n) 因为只需要遍历一次array\r\n空间 O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wonderful1234":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836682410","body":"解题思路：数组的末尾与k的末尾相加，分别求出进位与余数。\r\n`class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new ArrayList<>();\r\n    int carry = 0;  \r\n    int len = num.length - 1;\r\n\r\n    while (len >= 0 || k != 0) {\r\n        int sum = 0;\r\n        if (len >= 0) {\r\n            sum += num[len];\r\n            len--;\r\n        }\r\n        sum += k % 10 + carry;\r\n        carry = sum / 10;\r\n        list.add(sum % 10);\r\n       k /= 10;\r\n    }\r\n\r\n    if (carry == 1) {\r\n        list.add(carry);\r\n    }\r\n    Collections.reverse(list);\r\n    return list;\r\n\r\n    }\r\n}`\r\n复杂度分析：\r\n时间：O(n)\r\n空间：O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838630501","body":"思路：定义两个数组，分别用于记录正序与倒序遍历字符串 S 时，各元素与字符元素 C 之间的距离，最后将两个数组进行比较，取最小值。\r\n`public static int[] shortestToChar(String S, char C) {\r\n    int[] ascArr = new int[S.length()];\r\n    int[] descArr = new int[S.length()];\r\n\r\n    char[] sarr = S.toCharArray();\r\n    int count = sarr.length;\r\n\r\n    for (int i = 0; i < sarr.length; i++) {\r\n        if (sarr[i] == C) {\r\n            ascArr[i] = 0;\r\n            count = 0;\r\n        } else {\r\n            ascArr[i] = ++count;\r\n        }\r\n    }\r\n    count = sarr.length;\r\n    for (int i = sarr.length - 1; i >= 0; i--) {\r\n        if (sarr[i] == C) {\r\n            descArr[i] = 0;\r\n            count = 0;\r\n        } else {\r\n            descArr[i] = ++count;\r\n        }\r\n    }\r\n    for (int i = 0; i < ascArr.length; i++) {\r\n        ascArr[i] = Math.min(ascArr[i], descArr[i]);\r\n    }\r\n    return ascArr;\r\n}`\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839872956","body":"思路：利用数组来进行操作。\r\n`class CustomStack {\r\n    int idx = 0, s, count = 0, v, i;\r\n    vector<int> a;\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        a.resize(maxSize);\r\n        s = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(count < s)\r\n        {\r\n            a[idx++] = x;\r\n            count++;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if(count)\r\n        {\r\n            v = a[idx-1];\r\n            idx--;\r\n            count--;\r\n            return v;\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        k = min(k, count);\r\n        for(i = 0; i < k; ++i)\r\n            a[i] += val;\r\n    }\r\n};\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840622862","body":"  思路：将[]之间的字符串存储在字符串栈中，将数字存储在数字栈中，当遇到]时，出栈。\r\n`class Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string t = \"\";\r\n        stack<int> s_num;\r\n        stack<string> s_str;\r\n        int cnt = 0;\r\n        for (int i = 0; i < s.size(); ++i) {\r\n            if (s[i] >= '0' && s[i] <= '9') {\r\n                cnt = 10 * cnt + s[i] - '0';\r\n            } else if (s[i] == '[') {\r\n                s_num.push(cnt);\r\n                s_str.push(t);\r\n                cnt = 0; t.clear();\r\n            } else if (s[i] == ']') {\r\n                int k = s_num.top(); s_num.pop();\r\n                for (int j = 0; j < k; ++j) s_str.top() += t;\r\n                t = s_str.top(); s_str.pop();\r\n            } else {\r\n                t += s[i];\r\n            }\r\n        }\r\n        return s_str.empty() ? t : s_str.top();\r\n    }\r\n};`\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841294438","body":"思路：利用两个栈来实现，一个栈为输入栈，一个为中间栈，进栈时，直接加入到输入栈，出栈时，把输入栈中的数据加入到中间栈，然后再还原输入栈。访问队首元素时，与出栈相同。\r\n`class MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n     stack<int> s1;\r\n     stack<int> s2;\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        s1.push(x);\r\n\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        while (!s1.empty())\r\n        {\r\n            int temp = s1.top();\r\n            s1.pop();\r\n            s2.push(temp);\r\n        }\r\n        int result = s2.top();\r\n        s2.pop();\r\n        while (!s2.empty())\r\n        {\r\n            int temp = s2.top();\r\n            s2.pop();\r\n            s1.push(temp);\r\n        }\r\n        return result;\r\n\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        while (!s1.empty())\r\n        {\r\n            int temp = s1.top();\r\n            s1.pop();\r\n            s2.push(temp);\r\n        }\r\n        int result = s2.top();\r\n        while (!s2.empty())\r\n        {\r\n            int temp = s2.top();\r\n            s2.pop();\r\n            s1.push(temp);\r\n        }\r\n        return result;\r\n\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n         if (!s1.empty())\r\n        {\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            return true;\r\n        }\r\n\r\n    }\r\n};`\r\n复杂度分析：\r\n时间复杂度：O(1)\r\n时间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841684154","body":"思路：如果遇到比当前栈元素大的值，那么可以直接入栈，但是如果遇到比当前栈顶元素小的值，那么应该将之前的元素依次出栈，直到遇到小于等于该值的元素停止出栈，然后将max再push入栈。利用单调栈。\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        LinkedList<Integer> stack = new LinkedList<>();\r\n        int max = arr[0];\r\n\r\n        for (int i = 0; i < arr.length; i++) {\r\n            if (!stack.isEmpty() && arr[i] < max) {\r\n                while (!stack.isEmpty() && arr[i] < stack.peek()) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(max);\r\n            } else {\r\n                stack.push(arr[i]);\r\n                max = stack.peek();\r\n            }\r\n        }\r\n        return stack.size();\r\n\r\n    }\r\n}\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fzzfgbw":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836683816","body":"### 思路\r\n\r\n循环数组从最低位开始带进位累加，额外考虑k位数比较大的情况，最后处理最高位进位。\r\n\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int c = 0;\r\n        for (int i = num.length-1; i >=0; i--) {\r\n            int add = k% 10;\r\n            k /=10;\r\n            int sum = add + num[i] +c;\r\n            if (sum>= 10) {\r\n                sum = sum%10;\r\n                c = 1;\r\n            } else {\r\n                c = 0;\r\n            }\r\n            res.addFirst(sum);\r\n        }\r\n        \r\n        while (k>0){\r\n            int add = k% 10;\r\n            k /=10;\r\n            int sum = add +c;\r\n            if (sum>= 10) {\r\n                sum = sum%10;\r\n                c = 1;\r\n            } else {\r\n                c = 0;\r\n            }\r\n            res.addFirst(sum);\r\n        }\r\n        if (c>0){\r\n            res.addFirst(c);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(max(N,lg k))，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-836954949","body":"### 思路\r\n\r\n\t从左到右，从右到左。c无非在左或者右。先从左到右找到离左边c的距离，再从右到左找离右边c的距离，并判断大小。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n   class Solution {\r\n  public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        char[] chars = s.toCharArray();\r\n        int[] res = new int[length];\r\n       \r\n        int left = -length;\r\n        for (int i = 0; i <length ; i++) {\r\n            if (chars[i] == c){\r\n                left = i;\r\n                res[i] = 0;\r\n            }else {\r\n               res[i] = i-left;\r\n            }\r\n        }\r\n        int right = 2*length;\r\n        for (int i = length-1; i >=0; i--) {\r\n            if (chars[i] == c){\r\n                right = i;\r\n            }else {\r\n                \r\n                    res[i] = Math.min(right-i,res[i]);\r\n                \r\n            }\r\n\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839356693","body":"### 思路\r\n\r\n\t数组加栈顶下标\r\n\r\n### 代码\r\n\r\n\r\n```java\r\npublic class CustomStack {\r\n    private int[] arr;\r\n    private int index;\r\n\r\n    public CustomStack(int maxSize) {\r\n        index = -1;\r\n        arr = new int[maxSize];\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (index < arr.length-1) {\r\n            arr[++index] = x;\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if (index == -1){\r\n            return -1;\r\n        }else {\r\n            return arr[index--];\r\n        }\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int min = Math.min(k,index+1);\r\n        for (int i = 0; i <min ; i++) {\r\n            arr[i]+=val;\r\n        }\r\n    }\r\n\r\n}\r\n\t\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)、除了increment O(k)。\r\n- 空间复杂度：O(maxsize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-839987215","body":"### 思路\r\n\r\n 栈，(写得好笨重)\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n     class Solution {\r\n   public String decodeString(String s) {\r\n        char[] chars = s.toCharArray();\r\n        LinkedList<Character> stackIn = new LinkedList<>();\r\n        LinkedList<Character> stackOut = new LinkedList<>();\r\n        for (int i = 0; i < chars.length; i++) {\r\n            if (chars[i] == ']') {\r\n                while (stackIn.peekFirst() != '[') {\r\n                    stackOut.addFirst(stackIn.pollFirst());\r\n                }\r\n                stackIn.pollFirst();\r\n                int sumK = 0;\r\n                int index=1;\r\n                while (!stackIn.isEmpty() && stackIn.peekFirst() < 58 && stackIn.peekFirst() > 47) {\r\n                    sumK +=   (stackIn.pollFirst() - 48)*index;\r\n                    index *=10;\r\n                }\r\n                index = 1;\r\n                for (int j = 0; j < sumK; j++) {\r\n                    for (Character character : stackOut) {\r\n                        stackIn.addFirst(character);\r\n                    }\r\n                }\r\n                stackOut.clear();\r\n            } else {\r\n                stackIn.addFirst(chars[i]);\r\n            }\r\n        }\r\n        StringBuilder sb = new StringBuilder();\r\n        for (int i = stackIn.size() - 1; i >= 0; i--) {\r\n            sb.append(stackIn.get(i));\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)。\r\n- 空间复杂度：O(N)。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840922187","body":"### 思路\r\n\r\n\t2个栈，1个pop，1个push，pop队列空了，就迁移push队列数据到pop。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass MyQueue {\r\n    private Stack<Integer> stackIn;\r\n    private Stack<Integer> stackOut;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stackIn = new Stack<>();\r\n        stackOut = new Stack<>();\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        stackIn.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (stackOut.isEmpty()){\r\n            while (!stackIn.isEmpty()){\r\n                stackOut.push(stackIn.pop());\r\n            }\r\n        }\r\n        return stackOut.pop();\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (stackOut.isEmpty()){\r\n            while (!stackIn.isEmpty()){\r\n                stackOut.push(stackIn.pop());\r\n            }\r\n        }\r\n        return stackOut.peek();\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return stackOut.isEmpty() && stackIn.isEmpty();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)。\r\n- 空间复杂度：O(N)。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841665005","body":"### 思路\r\n\r\n单调栈，大于等于最大值就入栈，小于需要重新审视栈中比栈顶小的元素(出栈)。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr){\r\n        Stack<Integer> stack = new Stack<>();\r\n        for (int i = 0; i < arr.length; i++) {\r\n            if (stack.isEmpty() || arr[i]>=stack.peek()){\r\n                stack.push(arr[i]);\r\n            }else {\r\n                Integer top = stack.pop();\r\n                while (!stack.isEmpty()&&stack.peek()>arr[i]){\r\n                    stack.pop();\r\n                }\r\n                stack.push(top);\r\n            }\r\n\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(NlgN)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"agentzzz":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836691767","body":"### 思路\r\n\r\n将k从最后一位往前加，每次加法的结果对10取余，压入返回数组。然后除以10，与前一位相加。\r\n\r\n可能忘记讨论的情况：\r\n\r\n1. k可能比num的位数要长，因此，要确保k的剩余位数都压入结果数组\r\n2. 压入结果数组的内容是倒序的，collections.reverse()使其倒序（以前用的是C++刷题，java的collections要去了解一下）\r\n\r\n\r\n\r\n### JAVA\r\n\r\n```java\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n\t\tint fin = num.length - 1;\r\n\t\tList<Integer> res = new ArrayList<Integer>();\r\n\t\tint temp = 0;\r\n\t\tfor (int i = fin; i >= 0; i--) {\r\n\t\t\ttemp = num[i] + k;\r\n\t\t\tres.add(temp % 10);\r\n\t\t\tk = temp / 10;\r\n\t\t}\r\n\t\twhile (k > 0) {\r\n\t\t\tres.add(k % 10);\r\n\t\t\tk /= 10;\r\n\t\t}\r\n\t\tCollections.reverse(res);\r\n\t\treturn res;\r\n\t}\r\n```\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837942324","body":"### 思路\r\n\r\n一开始的思路是用双指针，一个表示左边界，一个表示有边界。但是现实实现的时候，需要考虑的情况太多了。\r\n\r\n第一次遍历数组，记录目标字符的位置。\r\n\r\n第二次遍历数组，记录所有元素与左右边界距离的最小值。\r\n\r\n其中，第二次遍历要考虑左右边界的多种情况，没想明白。\r\n\r\n\r\n\r\n第一次写大概花了25分钟，然后去干其他事情。\r\n\r\n第二次修改+debug花了10分钟。\r\n\r\n结果虽然通过了，思路也比较简单，但是代码的逻辑不是很好。\r\n\r\n写完之后大概看了一下题解，又其他更好的方法，晚一点再学习一下。\r\n\r\n\r\n\r\njava\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n\t\tint m=0;\r\n\t\tint[] res = new int[s.length()];\r\n\t\tList<Integer> list = new ArrayList<>();\r\n\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\tif(s.charAt(i)==c) list.add(i);\r\n\t\t}\r\n\t\tint index1=0,index2=0;\r\n\t\tif(list.size()==1) {\r\n\t\t\tindex1=index2=list.get(0);\r\n\t\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\t\tres[i] = Math.abs(i-index1);\r\n\t\t\t}\r\n\t\t\treturn res;\r\n\t\t}\t\r\n\t\tindex1 = list.get(m);\r\n\t\tindex2 = list.get(m+1);\r\n\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\tres[i] = Math.min(Math.abs(i-index1), Math.abs(i-index2));\r\n\t\t\tif(i==index2) {\r\n\t\t\t\tif(index2!=list.get(list.size()-1)) {\r\n\t\t\t\t\tm++;\r\n\t\t\t\t\tindex1 = list.get(m);\r\n\t\t\t\t\tindex2 = list.get(m+1);\r\n\t\t\t\t}\r\n\t\t\t}\t\r\n\t\t}\r\n\t\treturn res;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(n)\r\n\r\n### 法二：正序倒序两遍遍历\r\n\r\n参考题解后，又用思路更加清晰的方法写了一遍。这个不算是自己的产出内容，不仅看了思路，还看了代码的实现方式。\r\n\r\n用时：15min\r\n\r\n第一次从左向右遍历的时候，第一个元素和谁比较，有两种情况\r\n\r\n- 第一个char就是我的目的char，那么令比较索引temp等于第一个字符，后续的字符与它比较，遇到新的目标字符就更新temp 的索引\r\n- 第一个char不是目标字符，那么就要设置比较索引值temp让第一个目标字符出现之前res记录的值足够大，因此，选择Integer.MIN_VALUE/2，这是一个很小的复数，i-temp就是一个很大的整数。\r\n\r\n第二次从又向左遍历，同理。需要考虑最右边的原色和谁比较的问题。设置temp = Integer.MAX_VALUE/2，这样temp-i就是一个足够大的正数。\r\n\r\njava实现\r\n\r\n```java\r\nint[] shortestToChar1(String s,char c) {\r\n\t\tint[] res = new int[s.length()];\r\n\t\tint temp = Integer.MIN_VALUE/2;\r\n\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\tif(s.charAt(i)==c) temp =i;\r\n\t\t\tres[i]= i-temp;\r\n\t\t}\r\n\t\ttemp = Integer.MAX_VALUE/2;\r\n\t\tfor(int i=s.length()-1;i>=0;i--) {\r\n\t\t\tif(s.charAt(i)==c) temp = i;\r\n\t\t\tres[i] = Math.min(res[i],temp-i);\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n```\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839432343","body":"### 思路\r\n\r\n一开始就想到用一个vector模拟栈，因为increment需要能够访问所有元素。\r\n\r\n总体思路还是比较简单的。\r\n\r\n构造函数，将容器最大值记录。\r\n\r\npush：先判断容器容量是否超限，然后决定是否将元素压栈。\r\n\r\npop：判断容器是否为空，为空返回-1；不为空返回vector尾部元素\r\n\r\nincrement：先判断k和容器容量大小，再简单的遍历。\r\n\r\n\r\n\r\n### 用时\r\n\r\n思路+代码 20min\r\n\r\ndebug 5min\r\n\r\n### C++\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    vector<int>mem;\r\n    int _size;\r\n    \r\n    CustomStack(int maxSize) {\r\n        this->_size = maxSize;\r\n    }\r\n\r\n    void push(int x) {\r\n        if (mem.size() < _size) mem.push_back(x);\r\n    }\r\n\r\n    int pop() {\r\n        if (mem.empty()) return -1;\r\n        else {           \r\n            int ret = mem.back();\r\n            mem.pop_back();\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    void increment(int k, int val) {\r\n        if (k > mem.size()) {\r\n            for (int i = 0; i < mem.size(); i++) {\r\n                mem[i] += val;\r\n            }\r\n        }\r\n        else {\r\n            for (int i = 0; i < k; i++) {\r\n                mem[i] += val;\r\n            }\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n\r\n空间复杂度O(n)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840603298","body":"### 思路\r\n\r\n没有什么思路，提示是用栈编写，我的感觉也是栈的内容，但是没想好到底怎么实现。所以一开始花了25分钟用从前到后遍历的方式写了一个简单的能够识别\"23[ab]\"这样的代码。想着这样笔试的时候，多少也能拿一点分数。\r\n\r\n再思考一下，到了晚上想不出来就参考一下别人的题解。\r\n\r\n### C++\r\n\r\n```c++\r\n#include<iostream>\r\n#include<string>\r\n#include<vector>\r\nusing namespace std;\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        \r\n        //简单的2[a]3[abc]编码\r\n        int n = 0;\r\n        vector<int> temp;\r\n        string res=\"\";\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] >= '0' && s[i] <= '9') {\r\n                int num = s[i] - '0';\r\n                temp.push_back(num);\r\n            }\r\n            if (s[i] == '[') {\r\n                int j = i + 1;\r\n                string sub = \"\";\r\n                while (s[j] != ']') {\r\n                    sub += s[j];\r\n                    j++;\r\n                }\r\n                for (int k = 0; k < temp.size(); k++) {\r\n                    n += temp[k] * pow(10, temp.size()-k-1);\r\n                }\r\n                for (int k = 0; k < n; k++) {\r\n                    res += sub;\r\n                }\r\n                temp.clear();\r\n                i = j;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\nint main() {\r\n    Solution mySolu;\r\n    string res=mySolu.decodeString(\"10[A]\");\r\n    cout << res << endl;\r\n}\r\n```\r\n\r\n###  未完成，先打卡，明早修改"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841124879","body":"### 思路\r\n\r\npush设置一个栈\r\n\r\npop和peak设置一个栈\r\n\r\nempty由两个栈共同决定\r\n\r\n这一题在牛客做过原题，10分钟\r\n\r\n\r\n\r\n```c++\r\nclass MyQueue {\r\npublic:\r\n\tstack<int>stk1,stk2;\r\n\tvoid push(int x) {\r\n\t\tstk1.push(x);\r\n\t}\r\n\r\n\tint pop() {\r\n\t\tif (stk2.empty()) {\r\n\t\t\twhile (!stk1.empty()) {\r\n\t\t\t\tstk2.push(stk1.top());\r\n\t\t\t\tstk1.pop();\r\n\t\t\t}\r\n\t\t}\r\n\t\tint ret = stk2.top();\r\n\t\tstk2.pop();\r\n\t\treturn ret;\r\n\t\t\r\n\t}\r\n\r\n\tint peek() {\r\n\t\tif (stk2.empty()) {\r\n\t\t\twhile (!stk1.empty()) {\r\n\t\t\t\tstk2.push(stk1.top());\r\n\t\t\t\tstk1.pop();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn stk2.top();\r\n\t}\r\n\r\n\tbool empty() {\r\n\t\treturn stk1.empty() && stk2.empty();\r\n\t}\r\n};\r\n```\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度： push,empty是O(1)； pop,peek 是 O(n)\r\n\r\n空间复杂度： 都是O(n)\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oborc":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836695695","body":"### 解题思路\r\n刚开始以为这个题是大数相加的简单版，却发现其实是两个题目。\r\n直接遍历数组，用竖式相加的思路，从低位开始加起\r\n初始化一个空数组用来存放结果\r\n1.用加数加上被加数的低位，对和取余 为当前位的结果。\r\n2.对和除以10取整，作为加数向第二低位相加，重复1的步骤，直到数组遍历结束或者加数除以10取整之后为0.\r\n### javascript\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let result = [];\r\n    for(let i = num.length-1;i>=0 || k>0;i--){\r\n        if(i>=0){\r\n            k = k + num[i];\r\n        }\r\n        result.unshift(k%10);\r\n        k = Math.floor(k/10);\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n时间复杂度:\r\no(max(N,K/10)) = > O(N),线性复杂\r\n空间复杂度:\r\no(N)= > O(N),线性复杂"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838275025","body":"### 解题思路\r\n\r\n根据官方题解：\r\n1.初始化一个空数组，记录数组中每个字符到目标字符的距离\r\n2.从左向右遍历数组，遍历到目标字符，记录当前下标为index，用遍历下标 i - index  为当前字符距离它右边边的目标字符的距离 ，记录在 result[i] 中，在下次遍历中作比较。\r\n3.从右向左遍历数组，遍历到目标字符，记录当前下标为index，用index - 遍历下标 i  为当前字符距离它左边的目标字符的距离。取result[i] 和 差值中最小的记录为result[i]。result 即为所求\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let str = s.split(\"\");\r\n    let cIndex = -Infinity;\r\n    let result = [];\r\n    for(let i=0;i<str.length;i++){\r\n        if(str[i] == c ){\r\n            result[i]=0;\r\n            cIndex = i;\r\n        }\r\n        result[i] = i-cIndex;\r\n    }\r\n    cIndex = Infinity;\r\n    for(let i=str.length-1;i>=0;i--){\r\n        if(str[i] == c ){\r\n            result[i]=0;\r\n            cIndex = i;\r\n        }\r\n        result[i] = Math.min(result[i],cIndex-i);\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n时间复杂度：\r\no(2n) => o(n)\r\n空间复杂度：\r\no(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839694066","body":"### 解题思路\r\n数组的操作，根据数组的特性和API 实现\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n    this.stack = [];\r\n    this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n    if (this.maxSize > this.stack.length) {\r\n        this.stack.push(x)\r\n    } else {\r\n        return null\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n    return this.stack.length > 0 ? this.stack.pop() : -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n    for (let i = 0; i < Math.min(k ,this.stack.length); i++) {\r\n        this.stack[i] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841215711","body":"### 解题思路\r\njs数组本身就是一个队列。\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.data = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.data.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.data.shift();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.data[0];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.data.length >0 ? false : true;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n### 复杂度分析\r\n空间复杂度o(N)\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841759595","body":"### 解题思路一\r\n将链表置为一个环，用位移的个数对链表长度取余计算要断开的位置，在断开的位置置为null.\r\n（因为是只有一个头指针的链表，所以如果要位移的话，无论如何都要遍历一遍全链表。）\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\n\r\nvar rotateRight = function(head, k) {\r\n    let tail = head;\r\n    if(k == 0 || head == null || head.next == null){\r\n        return head;\r\n    }\r\n    let count = 1;\r\n    while(tail.next!=null){\r\n        tail = tail.next;\r\n        count++;\r\n    }\r\n    let actk = count - k % count;\r\n    if(actk == 0){\r\n        return head;\r\n    }\r\n    tail.next = head;\r\n    while(actk > 0){\r\n        tail = tail.next;\r\n        actk -- ;\r\n    }\r\n    let newHead = tail.next;\r\n    tail.next = null;\r\n    return newHead;\r\n}\r\n```\r\n### 复杂度分析\r\n时间复杂度o(N+K)\r\n空间复杂度 o（1)\r\n\r\n\r\n### 思路二\r\n和思路一大致一样，\r\n通过计算要截断的位置，先截断成两个链表，再将第二个链表的taile指向第一个链表的头，\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar rotateRight = function(head, k) {\r\n    let tail = head;\r\n    if(k == 0 || head == null || head.next == null){\r\n        return head;\r\n    }\r\n    let count = 1;\r\n    while(tail.next!=null){\r\n        tail = tail.next;\r\n        count++;\r\n    }\r\n    let actk = count - k % count;\r\n    if(actk == 0 || actk == count){\r\n        return head;\r\n    }\r\n\r\n    let tempTail = head;\r\n    actk --;\r\n    while(actk > 0){\r\n        head = head.next;\r\n        actk -- ;\r\n    }\r\n    let newHead = head.next;\r\n    head.next = null;\r\n    tail.next = tempTail;\r\n    return newHead;\r\n}\r\n\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度o(N+K)\r\n空间复杂度 o（1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liandmin":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836696480","body":"### 思路\r\n\r\n1. 直接遍历数组，从后往前加，满10进位，放入结果数组中\r\n2. 如果 k 比数组的number更大的话，继续遍历 k，放入结果数组\r\n3. 反转结果数组返回即可\r\n\r\n### JS\r\n\r\n```\r\nvar addToArrayForm = function (num, k) {\r\n  const res = [];\r\n  const length = num.length;\r\n\r\n  for (let i = length - 1; i >= 0; i--) {\r\n    let sum = num[i] + (k % 10);\r\n    k = Math.floor(k / 10);\r\n    if (sum >= 10) {\r\n      k++;\r\n      sum -= 10;\r\n    }\r\n    res.push(sum);\r\n  }\r\n\r\n  for (; k > 0; k = Math.floor(k / 10)) {\r\n    res.push(k % 10);\r\n  }\r\n  res.reverse();\r\n\r\n  return res;\r\n};\r\n```\r\n \r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(max(N,lg k))，其中 N 为数组长度。\r\n* 空间复杂度：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838758803","body":"## JavaScript\r\n\r\n### 思路\r\n\r\n正向和反向各遍历一次数组，取两次遍历中最小的值即可\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar shortestToChar = function (s, c) {\r\n  const res = new Array(s.length);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) {\r\n      res[i] = 0;\r\n    } else {\r\n      res[i] = i === 0 ? Infinity : res[i - 1] + 1;\r\n    }\r\n  }\r\n\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) {\r\n      res[i] = res[i + 1] + 1;\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838758803","body":"## JavaScript\r\n\r\n### 思路\r\n\r\n正向和反向各遍历一次数组，取两次遍历中最小的值即可\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar shortestToChar = function (s, c) {\r\n  const res = new Array(s.length);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) {\r\n      res[i] = 0;\r\n    } else {\r\n      res[i] = i === 0 ? Infinity : res[i - 1] + 1;\r\n    }\r\n  }\r\n\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) {\r\n      res[i] = res[i + 1] + 1;\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840655638","body":"## JavaScript\r\n\r\n### 思路\r\n\r\n辅助栈，一个或两个都可以\r\n\r\n### 代码\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  const stack = [];\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] != ']') {\r\n      stack.push(s[i]);\r\n    } else if (s[i] == ']') {\r\n      let temp = '';\r\n      while (stack[stack.length - 1] != '[') {\r\n        temp = stack.pop() + temp;\r\n      }\r\n      stack.pop();\r\n\r\n      let num = '';\r\n      while (stack[stack.length - 1] >= '0' && stack[stack.length - 1] <= '9') {\r\n        num = stack.pop() + num;\r\n      }\r\n\r\n      temp = temp.repeat(parseInt(num));\r\n      stack.push(temp);\r\n    }\r\n  }\r\n  return stack.join('');\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n* 空间复杂度： O(N)\r\n* 时间复杂度：O(N)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841680006","body":"## JS\r\n\r\n### 思路\r\n\r\n看了官方题解，没想到还能用单调栈来解\r\n\r\n### 代码\r\n\r\n```js\r\nvar maxChunksToSorted = function (arr) {\r\n  const stack = [];\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const num = arr[i];\r\n\r\n    if (stack.length && stack[stack.length - 1] > num) {\r\n      const cur = stack[stack.length - 1];\r\n      while (stack.length && stack[stack.length - 1] > num) stack.pop();\r\n      stack.push(cur);\r\n    } else {\r\n      stack.push(num);\r\n    }\r\n  }\r\n\r\n  return stack.length;\r\n};\r\n```\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"edge-wzw":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836712891","body":"### 思路\r\n\r\n逐位相加\r\n\r\n首先新建一个链表，从数组num尾部和K的低位开始反向遍历，依次求和得到对应的sum，根据求和结果判断是否进位（carry=1表示进位，carry=0表示无进位），将sum对10取模后加入到链表头部。\r\n\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public static List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int carry = 0;      //进位数，1表示进位，0表示无进位\r\n        int sum;    //每次求和的值\r\n        int n = num.length - 1;     //遍历数组时的索引\r\n        while (k != 0 || n >= 0){\r\n            sum = carry + (k % 10);\r\n            if (n >= 0){\r\n                sum += num[n];\r\n            }\r\n\r\n            carry = (sum > 9) ? 1:0;\r\n            res.addFirst(sum % 10);\r\n            n--;\r\n            k = k / 10;\r\n        }\r\n        if (carry == 1){res.addFirst(1);}\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(max(n, k))，其中 n 为数组长度, k为数值K的长度。\r\n- 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838514773","body":"解题思路：暴力寻找，首先生成长度为s.length()的结果数组res。遍历字符串的字符，当遇到不是c的字符时，向左和向右寻找最近的c字符的索引，然后与当前字符索引进行距离计算，取最小值存入结果数组res中；遍历时遇到字符c则存入0。\r\n\r\n代码\r\n\r\n```java\r\npublic class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int l, r;\r\n        int[] res = new int[s.length()];\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) != c) {\r\n                l = r = i;\r\n                while (l > 0 && (s.charAt(l) != c)){\r\n                    l--;\r\n                }\r\n                while (r < s.length()-1 && (s.charAt(r) != c)){\r\n                    r++;\r\n                }\r\n                if (s.charAt(l) != c){\r\n                    res[i] = Math.abs(i - r);\r\n                }else if (s.charAt(r) != c){\r\n                    res[i] = Math.abs(i - l);\r\n                }else {\r\n                    res[i] = Math.min(Math.abs(i - l), Math.abs(i - r));\r\n                }\r\n            }else {\r\n                res[i] = 0;\r\n            }\r\n\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n复杂度分析\r\n\r\n- 时间复杂度：O(n<sup>2</sup>)，其中 n 为字符串长度。\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839785134","body":"思路\r\n使用数组模拟栈，定义变量size记录当前数组中元素的数量\r\n\r\n代码\r\nclass CustomStack {\r\n\r\n    private int[] stack;\r\n    private int size;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        size = 0;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (size < stack.length){\r\n            stack[size] = x;\r\n            size++;\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if (size == 0) {\r\n            return -1;\r\n        }\r\n        int res = stack[size - 1];\r\n        stack[size - 1] = 0;\r\n        size--;\r\n        return res;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < k && i < stack.length; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n复杂度分析\r\n\r\n时间复杂度：构造函数、pop函数、push函数为O(1), increment函数为O(k)\r\n空间复杂度：O（maxSize）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840570391","body":"#### **思路**：栈操作\r\n自己想了半个小时，只想到了使用栈操作，思路和官方解法一有点接近，但是代码还是没能写出来，以下为官方解法一\r\n本题中可能出现括号嵌套的情况，比如 2[a2[bc]]，这种情况下我们可以先转化成 2[abcbc]，在转化成 abcbcabcbc。我们可以把字母、数字和括号看成是独立的 TOKEN，并用栈来维护这些 TOKEN。具体的做法是，遍历这个栈：\r\n\r\n如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\r\n如果当前的字符为字母或者左括号，直接进栈\r\n如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字（此时栈顶一定是数字，想想为什么？），就是这个字符串应该出现的次数，我们根据这个次数和字符串构造出新的字符串并进栈\r\n重复如上操作，最终将栈中的元素按照从栈底到栈顶的顺序拼接起来，就得到了答案。注意：这里可以用不定长数组来模拟栈操作，方便从栈底向栈顶遍历。\r\n\r\n**代码**\r\n\r\n```java\r\nclass Solution {\r\n    int ptr;\r\n\r\n    public String decodeString(String s) {\r\n        LinkedList<String> stk = new LinkedList<String>();\r\n        ptr = 0;\r\n\r\n        while (ptr < s.length()) {\r\n            char cur = s.charAt(ptr);\r\n            if (Character.isDigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                String digits = getDigits(s);\r\n                stk.addLast(digits);\r\n            } else if (Character.isLetter(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \r\n            } else {\r\n                ++ptr;\r\n                LinkedList<String> sub = new LinkedList<String>();\r\n                while (!\"[\".equals(stk.peekLast())) {\r\n                    sub.addLast(stk.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                // 左括号出栈\r\n                stk.removeLast();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = Integer.parseInt(stk.removeLast());\r\n                StringBuffer t = new StringBuffer();\r\n                String o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime-- > 0) {\r\n                    t.append(o);\r\n                }\r\n                // 将构造好的字符串入栈\r\n                stk.addLast(t.toString());\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer ret = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            ret.append(s.charAt(ptr++));\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> v) {\r\n        StringBuffer ret = new StringBuffer();\r\n        for (String s : v) {\r\n            ret.append(s);\r\n        }\r\n        return ret.toString();\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：记解码后得出的字符串长度为 SS，除了遍历一次原字符串 ss，我们还需要将解码后的字符串中的每个字符都入栈，并最终拼接进答案中，故渐进时间复杂度为 O(S+|s|)O(S+∣s∣)，即 O(S)O(S)。\r\n- 空间复杂度：记解码后得出的字符串长度为 SS，这里用栈维护 TOKEN，栈的总大小最终与 SS 相同，故渐进空间复杂度为 O(S)O(S)。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841263081","body":"#### **思路**\r\n\r\n题目要求仅使用两个栈实现先入先出队列，那么首先想到的方法就是一个栈s1存储数据，一个栈s2中转数据，为了减少操作，可以设置一个变量存储栈顶元素。这里有一个技巧是在弹出一次数据时，将数据存到s2中，这样一来s2的栈顶相当于队首，之后push的数据存入s1，直到s2中的数据清空。\r\n\r\n**代码**\r\n\r\n```java\r\npublic class MyQueue3 {\r\n\r\n    private Stack<Integer> s1;\r\n    private Stack<Integer> s2;\r\n    private int front;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue3() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        if (s1.isEmpty()) {\r\n            front = x;\r\n        }\r\n        s1.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (s2.isEmpty()) {\r\n            while (!s1.isEmpty()){\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (!s2.isEmpty()){\r\n            return s2.peek();\r\n        }\r\n        return front;\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n\r\n\r\n    public static void main(String[] args) {\r\n        MyQueue3 myQueue = new MyQueue3();\r\n        myQueue.push(1);\r\n        myQueue.push(2);\r\n        System.out.println(myQueue.peek());\r\n        System.out.println(myQueue.pop());\r\n        System.out.println(myQueue.empty());\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：弹出数据时的时间复杂度为O(1)~O(n), 其他操作均为O(1)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841660245","body":"#### **思路**\r\n自己没解出来\r\n采用官方题解的思路一：\r\n\t首先还是要找到从左边开始最小的块。\r\n\t我们知道数组 arr 在排序之后一定跟整个数组排序后相应的地方完全相同，即 expect = sorted(arr)。如果前 k 个元素的个数减去排序后前 k 个元素的个数都为 0 的话，那这前 k 个元素是可以成为一个合法的分块的。对于整个数组可以重复这一过程。\r\n\r\n用变量 nonzero 来计数目前差值不等于 0 的字符的个数。\r\n\r\n**代码**\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) nonzero--;\r\n            if (count.get(x) == 1) nonzero++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) nonzero++;\r\n            if (count.get(y) == 0) nonzero--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：*O*(*N*log*N*)，其中 *N* 为 `arr` 的长度。\r\n- 空间复杂度：*O*(*N*)。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SunStrongChina":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836713429","body":"> # 989. 数组形式的整数加法\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n> \r\n> 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n> \r\n>  \r\n> \r\n> 示例 1：\r\n> \r\n> 输入：A = [1,2,0,0], K = 34\r\n> 输出：[1,2,3,4]\r\n> 解释：1200 + 34 = 1234\r\n> 示例 2：\r\n> \r\n> 输入：A = [2,7,4], K = 181\r\n> 输出：[4,5,5]\r\n> 解释：274 + 181 = 455\r\n> 示例 3：\r\n> \r\n> 输入：A = [2,1,5], K = 806\r\n> 输出：[1,0,2,1]\r\n> 解释：215 + 806 = 1021\r\n> 示例 4：\r\n> \r\n> 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n> 输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n> 解释：9999999999 + 1 = 10000000000\r\n>  \r\n> \r\n> 提示：\r\n> \r\n> 1 <= A.length <= 10000\r\n> 0 <= A[i] <= 9\r\n> 0 <= K <= 10000\r\n> 如果 A.length > 1，那么 A[0] != 0\r\n> \r\n\r\n\r\n> # 989. 数组形式的整数加法\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n> \r\n> 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n> \r\n>  \r\n> \r\n> 示例 1：\r\n> \r\n> 输入：A = [1,2,0,0], K = 34\r\n> 输出：[1,2,3,4]\r\n> 解释：1200 + 34 = 1234\r\n> 示例 2：\r\n> \r\n> 输入：A = [2,7,4], K = 181\r\n> 输出：[4,5,5]\r\n> 解释：274 + 181 = 455\r\n> 示例 3：\r\n> \r\n> 输入：A = [2,1,5], K = 806\r\n> 输出：[1,0,2,1]\r\n> 解释：215 + 806 = 1021\r\n> 示例 4：\r\n> \r\n> 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n> 输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n> 解释：9999999999 + 1 = 10000000000\r\n>  \r\n> \r\n> 提示：\r\n> \r\n> 1 <= A.length <= 10000\r\n> 0 <= A[i] <= 9\r\n> 0 <= K <= 10000\r\n> 如果 A.length > 1，那么 A[0] != 0\r\n> ```\r\n**思路**\r\n1.将k转化为字符串\r\n2.比较k和num那个位数多，先进行少位数的求和相加\r\n3.添加更多的那几位\r\n\r\n**python**\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num, k):\r\n        k_str=str(k)\r\n        result=[]\r\n        if len(k_str)>len(num):\r\n            len1=len(num)\r\n            len2=len(k_str)\r\n            num,k_str=k_str,num\r\n        else:\r\n            len1=len(k_str)\r\n            len2=len(num)\r\n            \r\n        value_2=0    \r\n        for i in range(-1,-len1-1,-1):\r\n            value1=int(num[i])+int(k_str[i])+value_2\r\n          \r\n            if value1>=10:\r\n                value_1=value1%10\r\n                value_2=1\r\n            else:\r\n                value_1=value1\r\n                value_2=0\r\n            result.append(value_1)\r\n        \r\n        for j in range(-len1-1,-len2-1,-1):\r\n            value1=int(num[j])+value_2\r\n            if value1>=10:\r\n                value_1=value1%10\r\n                value_2=1\r\n            else:\r\n                value_1=value1\r\n                value_2=0\r\n            result.append(value_1)\r\n        if value_2!=0:\r\n            result.append(value_2)\r\n        result.reverse()    \r\n        return result\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**复杂度分析**\r\n时间复杂度：O(max(N,k))，其中 N 为数组长度，k为数值k的长度。\r\n空间复杂度：O(N)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839377844","body":"### 思路\r\npython的数组本身就是栈，只需要设定栈元素总量就行\r\n### python\r\n\r\n```\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.size=maxSize\r\n        self.stack=[]\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack)!=self.size:\r\n            self.stack.append(x)\r\n         \r\n\r\n\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.stack)>=1:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack)<k:\r\n            self.stack=[value1+val for value1 in self.stack]\r\n        else:\r\n            for i in range(k):\r\n                self.stack[i]=self.stack[i]+val\r\n        return self.stack\r\n\r\n```\r\n\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度:O(n）\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841308053","body":"### 思路\r\n队列每次弹出一个值时，弹出第一个值，并更新\r\n### python代码\r\n```\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.queue1=[]\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.queue1.append(x)\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.queue1)!=0:\r\n            a=self.queue1[0]\r\n            self.queue1=self.queue1[1:]\r\n            return a\r\n        else:\r\n            return -1\r\n\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        Get the front element.\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.queue1)!=0:\r\n            return self.queue1[0]\r\n        else:\r\n            return -1\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        :rtype: bool\r\n        \"\"\"\r\n        if len(self.queue1)==0:\r\n            return True\r\n        else:\r\n            return False\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836721643","body":"### 思路\r\n\r\n倒叙逐位加，先倒着遍历数组`num`，逐位相加，可以把要保存的进位存储到`k`里面，就不容易造成混乱。要注意的是`k`是可以比`num`大的，这里就和66加一不是很一样\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num, k):\r\n        result = []\r\n        for i in range(len(num)-1, -1, -1):  # 先遍历num\r\n            sum = num[i] + k % 10  # 逐位相加\r\n            k = k // 10  # k降一个位数\r\n            if sum >= 10:  # 这里是一个技巧，进位的时候，不直接处理num，而是k加一\r\n                k += 1\r\n            result.append(sum % 10)  # 不用insert降低复杂度\r\n        while k > 0:  # 若k的值不为0，直接加上去即可，同时也考虑k比num大的情况\r\n            result.append(k % 10)\r\n            k = k // 10\r\n        result.reverse()\r\n        return result\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(max(n,k)) 整数与数组长度之间取最大，为什么官方写的是log(k)？\r\n- 空间复杂度：O(1) 除了返回值result以外，使用的空间为常数。"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838329768","body":"### 思路\r\n\r\n左右各遍历一次。每次遍历，记录`c`的位置，左侧开始遍历就计算每个数到最近的左边的`c`的距离，要注意如果左边没有`c`可以记录无穷大。右侧开始遍历，记录每个数到右边的`c`的距离，是`c`的位置减掉该数的位置。如果右边没有`c`，那应该也是无穷大，所以右侧开始的话`c`初始应该是无穷大。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        result = []\r\n        left_position = float('-inf')\r\n        right_position = float('inf')\r\n        for idx, value in enumerate(s):\r\n            if value == c:\r\n                left_position = idx\r\n            result.append(idx-left_position)\r\n\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                right_position = i\r\n            result[i] = min(right_position-i, result[i])\r\n        return result\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n) 遍历2遍\r\n- 空间复杂度：O(1) 除了返回值result以外，使用的空间为常数。\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839698463","body":"### 思路\r\n\r\n用数组（在python中一个list）模拟栈\r\n\r\n### 代码\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max_size = maxSize\r\n        self.stack = list()\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        else:\r\n            pop_item = self.stack[-1]\r\n            self.stack = self.stack[:-1]\r\n            return pop_item\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i] += val\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：push O(1)；pop O(1); increment O(N) \r\n- 空间复杂度：O(N) 这里用到了一个长度为 `maxSize` 的数组作为辅助空间，渐进空间复杂度为 O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840618316","body":"### 思路\r\n\r\n用栈辅助来判断左右括号拆出来的情况。为碰到`]`的时候可以全部进栈，需要注意，数字进栈的时候，要判断是否是连续的数字，如果是连续的，需要和前面的数字拼起来；碰到`[`的时候，用一个辅助的`temp_str`记录拼起来的字符串，这个`temp_str`在碰到数字的时候（其实就是碰到`[`）要乘数字的个数作为拼完的临时字符串。再判断此时栈是否还有`[`有的话说明临时字符串还要继续拼，把现有的临时串先入栈；如果`[`没有在栈中，可以拼到最终结果串中。全部结束，再判断一次栈是否为空，不空的话要拼进结果。这版写太长了，比较挫\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        # 没碰到[的话全部进栈\r\n        stack = []\r\n        temp_str = \"\"\r\n        result = \"\"\r\n        for val in s:\r\n            if val != ']':\r\n                if stack:\r\n                    if val.isdigit() and stack[-1].isdigit():  # 这里处理有可能多个数字的情况，比如100\r\n                        stack[-1] = stack[-1] + val\r\n                    else:\r\n                        stack.append(val)\r\n                else:\r\n                    stack.append(val)\r\n            else:\r\n                while stack:  # 只要碰到]就出栈\r\n                    item = stack.pop()\r\n                    if item != '[' and not item.isdigit():\r\n                        temp_str = item + temp_str\r\n                    elif item.isdigit():\r\n                        temp_str = int(item) * temp_str\r\n                        break\r\n                if '[' not in stack:\r\n                    while stack:\r\n                        temp_str = stack.pop() + temp_str\r\n                    result = result + temp_str\r\n                else:\r\n                    stack.append(temp_str)\r\n                temp_str = \"\"\r\n        while stack:\r\n            temp_str = stack.pop() + temp_str\r\n        result = result + temp_str\r\n        return result\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(N)，遍历一遍 \r\n- 空间复杂度：O(N) 这里用到了一个最大长度为 `N` 的数组作为辅助空间stack，渐进空间复杂度为 O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840982607","body":"### 思路\r\n\r\n两个栈倒来倒去的感觉。在`pop`和`peak`的时候，把左栈的元素全部倒入右栈，取栈顶即可\r\n\r\n### 代码\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack_left = []\r\n        self.stack_right = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stack_left.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        result = None\r\n        while self.stack_left:  # 左栈非空的时候，全部倒到右栈\r\n            self.stack_right.append(self.stack_left.pop())\r\n        if self.stack_right:\r\n            result = self.stack_right.pop()\r\n        while self.stack_right: # 右栈非空的时候，全部倒回左栈\r\n            self.stack_left.append(self.stack_right.pop())\r\n        return result\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        result = None\r\n        while self.stack_left:\r\n            self.stack_right.append(self.stack_left.pop())\r\n        if self.stack_right:\r\n            result = self.stack_right[-1]\r\n        while self.stack_right:\r\n            self.stack_left.append(self.stack_right.pop())\r\n        return result\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        length = len(self.stack_right) + len(self.stack_left)\r\n        if not length:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：push O(1) pop O(N) peak O(N) empty O(1)\r\n- 空间复杂度：O(N) 这里用到了一个最大长度为 `N` 的栈作为辅助空间，渐进空间复杂度为 O(N)\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"newVincentFong":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836729444","body":"# Add to Array-Form of Integer\r\n\r\n## Discuss\r\n\r\n* `num` can be longer than `k`, or can be shorter than k\r\n \r\nso, the times of iterations should be the max between their lengths\r\n\r\n* save the result in the given array\r\n\r\nspace: O(n) -> O(1), less use of `splice`, better timing\r\n\r\n## Code\r\n\r\n```typescript\r\n/**\r\n * @remarks\r\n * * `num` can be longer than `k`, or can be shorter than k\r\n * \r\n * so, the times of iterations should be the max between their lengths\r\n * \r\n * * save the result in the given array\r\n * \r\n * space: O(n) -> O(1), less use of `splice`, better timing\r\n */\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    let shouldCarry = false\r\n    const length = Math.max(num.length, k.toString().length)\r\n    const difference = length - num.length\r\n    for (let i = length - 1; i >= 0; i--) {\r\n        const original = num[i - difference] || 0\r\n        const toAdd = k % 10\r\n        const added = original + toAdd + (shouldCarry ? 1 : 0) as number\r\n        const toSave = added % 10\r\n        if (i - difference >= 0) {\r\n            num[i- difference] = toSave\r\n        } else {\r\n            num.splice(0, 0, toSave)\r\n        }\r\n        shouldCarry = Math.floor(added / 10) === 1\r\n        k = Math.floor(k / 10)\r\n    }\r\n    if (shouldCarry) {\r\n        num.splice(0, 0, 1)\r\n    }\r\n    return num\r\n};\r\n// time O(n)\r\n// space O(1)\r\n``"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838642501","body":"# Shortest Distance to a Character\r\n\r\n## Discuss\r\n\r\n* the min distance of str[i] is only related to the **two** closest c char that are on both sides of str[i]\r\n\r\nBefore:\r\n\r\n`Min(abs(c1 - str[i]), abs(c2 - str[i]), ... abs(cN - str[i]))`\r\n\r\nAfter:\r\n\r\n`Min(abs(cLEFT - str[i]), abs(cRIGHT - str[i]))`\r\n\r\n* iterate forward and then backward\r\n\r\nwatch out for those `empty` Array items\r\n\r\n## Code\r\n\r\n```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    const result = []\r\n    // forwards\r\n    let prevC = -1\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            prevC = i\r\n            result[i] = 0\r\n        } else if (prevC !== -1) {\r\n            result[i] = i - prevC\r\n        }\r\n    }\r\n    prevC = -1\r\n    // backwards\r\n    for (let i = s.length - 1; i >= 0; i--) {\r\n        if (prevC !== -1) {\r\n            // CAUTION\r\n            result[i] = typeof result[i] === 'number' ? Math.min(prevC - i, result[i]) : prevC - i\r\n        }\r\n        if (s[i] === c) {\r\n            prevC = i\r\n        }\r\n    }\r\n    return result\r\n};\r\n// time O(n)\r\n// space O(n)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838642501","body":"# Shortest Distance to a Character\r\n\r\n## Discuss\r\n\r\n* the min distance of str[i] is only related to the **two** closest c char that are on both sides of str[i]\r\n\r\nBefore:\r\n\r\n`Min(abs(c1 - str[i]), abs(c2 - str[i]), ... abs(cN - str[i]))`\r\n\r\nAfter:\r\n\r\n`Min(abs(cLEFT - str[i]), abs(cRIGHT - str[i]))`\r\n\r\n* iterate forward and then backward\r\n\r\nwatch out for those `empty` Array items\r\n\r\n## Code\r\n\r\n```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    const result = []\r\n    // forwards\r\n    let prevC = -1\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            prevC = i\r\n            result[i] = 0\r\n        } else if (prevC !== -1) {\r\n            result[i] = i - prevC\r\n        }\r\n    }\r\n    prevC = -1\r\n    // backwards\r\n    for (let i = s.length - 1; i >= 0; i--) {\r\n        if (prevC !== -1) {\r\n            // CAUTION\r\n            result[i] = typeof result[i] === 'number' ? Math.min(prevC - i, result[i]) : prevC - i\r\n        }\r\n        if (s[i] === c) {\r\n            prevC = i\r\n        }\r\n    }\r\n    return result\r\n};\r\n// time O(n)\r\n// space O(n)\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841220028","body":"# Implement Queue using Stacks\r\n\r\n## Discuss\r\n\r\n* a stack can only `push()` and `pop()`\r\n\r\nnot allowed to `shift()`\r\n\r\nuse another reverse stack\r\n\r\nthen `shift()` can be performed by `pop()`\r\n\r\n## Code\r\n\r\n```typescript\r\nclass MyQueue {\r\n    toPush: number[]\r\n    toPop: number[]\r\n    constructor() {\r\n        this.toPush = []\r\n        this.toPop = []\r\n    }\r\n\r\n    push(x: number): void {\r\n        this.toPush.push(x)\r\n    }\r\n\r\n    pop(): number {\r\n        if (this.toPop.length === 0) {\r\n            this.pour()\r\n        }\r\n        return this.toPop.pop() as unknown as number\r\n    }\r\n\r\n    peek(): number {\r\n        if (this.toPop.length === 0) {\r\n            this.pour()\r\n        }\r\n        return this.toPop[this.toPop.length - 1]\r\n    }\r\n\r\n    empty(): boolean {\r\n        return this.toPop.length + this.toPush.length === 0\r\n    }\r\n\r\n    /**\r\n     * transfer items from toPush to toPop\r\n     */\r\n    private pour(): void {\r\n        for (let i = this.toPush.length - 1; i >= 0; i--) {\r\n            this.toPop.push(this.toPush.pop() as unknown as number)\r\n        }\r\n    }\r\n}\r\n// time amortized O(n)\r\n// space O(n)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DAXIAdaxia":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836737171","body":"### **思路：**\r\n从个位数开始，每个数从后往前依次相加\r\n\r\n### **代码：**\r\npublic class Solution {\r\n\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        ArrayList<Integer> list = new ArrayList<Integer>();\r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            int temp = num[i] + k % 10;\r\n            k /= 10;\r\n            if (temp >= 10){\r\n                k++;\r\n                temp -= 10;\r\n            }\r\n            list.add(temp);\r\n        }\r\n\r\n        while (k > 0){\r\n            list.add(k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        Collections.reverse(list);\r\n        return list;\r\n    }\r\n}\r\n\r\n### **复杂度分析：**\r\n时间复杂度：最坏的情况下，需要遍历n次，所以时间复杂度为O(n)\r\n空间复杂度：最坏的情况下，需要一个长度为(n+1)的列表来存储结果，所以空间复杂度为O(n)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838528608","body":"### **思路：**\r\n先从左往右计算出当前字符距离上一个字符c的距离（第一个需要用最小整数的一半来代替，保证 i-pre 为正），紧接着就是从右往左计算出当前字符距离上一个字符c的距离（第一个需要用最大整数的一半来代替，保证 post-i 为正），同时比较两个距离的大小，只保留距离短的\r\n### **代码：**\r\npublic class Solution {\r\n\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n\r\n        int pre = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < len; i++) {\r\n            if (c == s.charAt(i)) pre = i;\r\n            res[i] = i - pre;\r\n        }\r\n\r\n        int post = Integer.MAX_VALUE / 2;\r\n        for (int i = len - 1; i >= 0; i--) {\r\n            if (c == s.charAt(i)) post = i;\r\n            res[i] = Integer.min(res[i],post - i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n### **复杂度分析：**\r\n时间复杂度：需要单独进行两个for循环，所以时间复杂度为O(n)，n为字符串长度\r\n空间复杂度：最短距离需要用数组来存，所以空间复杂度为O(n)，n为字符串长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839753729","body":"### **思路：**\r\n因为栈需要存储，所以先定义一个整型数组来存储push的数据，定义变量stackSize来指定栈的最大长度，变量currentSize来表示当前栈实际已经存储的位置。由于定义了数组没有初始化，所以在构造函数中需要对数组进行初始化，并显示指定栈的最大容量。在push()中需要考虑的是当栈已经满了，就不可以往栈加入数据。在pop()函数中需要考虑的是当所有元素出栈之后，要返回-1。在increment()函数中需要考虑的是在k和currentSize取最小值来完成加值操作。\r\n\r\n### **代码：**\r\npublic class CustomStack {\r\n\r\n    private int stackSize;\r\n    private int currentSize = 0;\r\n    private int[] stack;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stackSize = maxSize;\r\n        stack = new int[maxSize];\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (currentSize < stackSize){\r\n            stack[currentSize++] = x;\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if (currentSize >0 && currentSize <= stackSize){\r\n            return stack[--currentSize];\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        if (currentSize >= k){\r\n            for (int i = 0; i < k; i++) {\r\n                stack[i] += val;\r\n            }\r\n        }else {\r\n            for (int i = 0; i < currentSize; i++) {\r\n                stack[i] += val;\r\n            }\r\n        }\r\n    }\r\n}\r\n### **复杂度分析：**\r\n时间复杂度：构造函数、push()、pop()函数的时间复杂度为O(1)，而increment()函数的空间复杂度为O( min(k , currentSize) )\r\n空间复杂度：需要一个数组来存储数据，所以空间复杂度为O(stackSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840602618","body":"### **思路：**\r\n第一步：把'['左边的数字解析出来，并压入栈\r\n第二步：接着把字母和‘[’以字符串的形式压入栈\r\n第三步：但遇到‘]’时，把栈中的元素出栈，直到遇到“[”，并把出栈后的字符串进行反转、重复后重新压入栈\r\n重复以上的步骤，最后出栈的字符串即为结果。\r\n\r\n### **代码：**\r\nclass Solution {\r\n    int ptr;\r\n\r\n    public String decodeString(String s) {\r\n        LinkedList<String> stk = new LinkedList<String>();\r\n        ptr = 0;\r\n\r\n        while (ptr < s.length()) {\r\n            char cur = s.charAt(ptr);\r\n            if (Character.isDigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                String digits = getDigits(s);\r\n                stk.addLast(digits);\r\n            } else if (Character.isLetter(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \r\n            } else {\r\n                ++ptr;\r\n                LinkedList<String> sub = new LinkedList<String>();\r\n                while (!\"[\".equals(stk.peekLast())) {\r\n                    sub.addLast(stk.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                // 左括号出栈\r\n                stk.removeLast();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = Integer.parseInt(stk.removeLast());\r\n                StringBuffer t = new StringBuffer();\r\n                String o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime-- > 0) {\r\n                    t.append(o);\r\n                }\r\n                // 将构造好的字符串入栈\r\n                stk.addLast(t.toString());\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer ret = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            ret.append(s.charAt(ptr++));\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> v) {\r\n        StringBuffer ret = new StringBuffer();\r\n        for (String s : v) {\r\n            ret.append(s);\r\n        }\r\n        return ret.toString();\r\n    }\r\n}\r\n### **复杂度分析**\r\n时间复杂度：O（n）其中n为字符串的长度\r\n空间复杂度：O（n）其中n为字符串的长度\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841284660","body":"### **思路：**\r\n用ArrayList来充当一个队列，队列头在左边，队列为在右边，每次添加使用ArrayList封装的函数add()，每次出栈使用remove()函数，队列头移除一个元素，查询使用get()函数。\r\n\r\n### **代码：**\r\nclass MyQueue {\r\n    private int top;\r\n    private ArrayList<Integer> queue;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        top = -1;\r\n        queue = new ArrayList<Integer>();\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        queue.add(x);\r\n        top++;\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(top == -1) return 0;\r\n        Integer res = queue.remove(0);\r\n        top--;\r\n        return res;\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(top == -1) return 0;\r\n        int res = queue.get(0);\r\n        return res;\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        if (queue.size()==0) return true;\r\n        return false;\r\n    }\r\n}\r\n### **复杂度分析：**\r\n时间复杂度：O(1)\r\n空间复杂度：需要定义一个ArrayList数组来存储入队列的数据，所以空间复杂度为O(n)，n为入队列数据的长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841659345","body":"### **思路：**\r\n排序后的数组和排序前的数组进行比较，若在同个索引下，两个元素的值相等，则可以分桶。\r\n\r\n### **代码：**\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, count= 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) count--;\r\n            if (count.get(x) == 1) count++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) count++;\r\n            if (count.get(y) == 0) count--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n\r\n### **复杂度分析：**\r\n时间复杂度：O( nlg(n) )\r\n空间复杂度：最坏的情况下，需要存储n个数据，所以空间复杂度为O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"supermeohh":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836744653","body":"\r\n## 思路\r\n进位用k通过加一保存\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //List<Integer>初始化，需要返回值\r\n        int n = num.length;\r\n        List<Integer>res = new ArrayList<>();\r\n        //List<Integer>指的是存int类型数据的列表\r\n        for(int i = n-1;i>=0;i--){\r\n            //%（取余）和 /（取整）\r\n            //取num的最低位和k值的个位\r\n            int sum = num[i]+k%10;\r\n            //取k值的个位以上\r\n            k/=10;\r\n            if (sum>=10){\r\n                //和有进位加一\r\n                k++;\r\n                //sum-10\r\n                sum-=10;\r\n            }\r\n            //赋值到链表\r\n            res.add(sum);\r\n        }\r\n        //多余的k值位数直接加上去\r\n        for(;k>0;k/=10){\r\n            res.add(k%10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838595332","body":"## 思路\r\n1、正向取值为i-prev\r\n2、逆向取值为prev-i\r\n3、比较两个值赋值给ans[]\r\n4、打印\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        //s.length()括号不能丢\r\n        int n = s.length();\r\n        int [] ans = new int[n];\r\n        //prev初始值为int整型的最小值的一半\r\n        //保证有prev参与的加减运算不会溢出。同时起到最小值的效果\r\n        //不知道为什么不能是0呢？\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        //charAt() 方法可返回指定位置的字符\r\n        //语法stringObject.charAt(index)\r\n        //s.charaT(i)\r\n        for(int i = 0;i < n;i++){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            //结果在if外，跟着每一次的for循环而不是if\r\n                ans[i] = i - prev;\r\n        }\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for(int i = n-1;i >= 0;i--){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n                //min和max需要Math调用\r\n                ans[i] =Math.min(ans[i],prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839821304","body":"\r\n## 思路\r\n\r\n本身只有栈顶是可见的，该题为让栈中的所有元素都可见\r\n每一次的进出栈都会被模拟记录在stack中\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n//自定义栈类\r\nclass CustomStack {\r\n    int[] stack;\r\n    //栈顶\r\n    int top;\r\n    //构造器\r\n    public CustomStack(int maxSize) {\r\n        //给定stack长度\r\n        stack = new int[maxSize];\r\n        //栈为空时赋值top给定栈顶为-1\r\n        top = -1;\r\n    }\r\n    //定义push方法\r\n    public void push(int x) {\r\n        //判断是否达到上限，每次push都会判断总会有一次top会等于的\r\n        //因为-1为初始值，所以不等于的时候都是小于，不存在大于的情况\r\n        if(top != (stack.length - 1)){\r\n            //后移top一位\r\n            top++;\r\n            //赋值push\r\n            stack[top] =x;\r\n        }\r\n    }\r\n    //定义pop方法\r\n    public int pop() {\r\n        //判断栈是否为空\r\n        if (top == -1){\r\n            return-1;\r\n        }\r\n        //不为空，则出栈-1\r\n        top--;\r\n        //返回top-1之前的top值\r\n        return stack[top+1];\r\n    }\r\n    //定义inc方法\r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k,top+1);\r\n        for(int i = 0;i<limit;i++){\r\n            stack[i] +=val; \r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840655478","body":"\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  不太会啊今天，难顶，主判断\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```Java\r\n\r\nclass Solution {\r\n    int ptr;\r\n\r\n    public String decodeString(String s) {\r\n        LinkedList<String> stk = new LinkedList<String>();\r\n        ptr = 0;\r\n\r\n        while (ptr < s.length()) {\r\n            char cur = s.charAt(ptr);\r\n            if (Character.isDigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                String digits = getDigits(s);\r\n                stk.addLast(digits);\r\n            } else if (Character.isLetter(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \r\n            } else {\r\n                ++ptr;\r\n                LinkedList<String> sub = new LinkedList<String>();\r\n                while (!\"[\".equals(stk.peekLast())) {\r\n                    sub.addLast(stk.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                // 左括号出栈\r\n                stk.removeLast();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = Integer.parseInt(stk.removeLast());\r\n                StringBuffer t = new StringBuffer();\r\n                String o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime-- > 0) {\r\n                    t.append(o);\r\n                }\r\n                // 将构造好的字符串入栈\r\n                stk.addLast(t.toString());\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer ret = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            ret.append(s.charAt(ptr++));\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> v) {\r\n        StringBuffer ret = new StringBuffer();\r\n        for (String s : v) {\r\n            ret.append(s);\r\n        }\r\n        return ret.toString();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bowlofnoodles":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836746047","body":"### 思路\r\n\r\n模拟加法按位逐位相加\r\n\r\n### 代码 js\r\n\r\n\r\n``` javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    const result = [];\r\n    const length = num.length;\r\n    for (let i = length - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        result.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        result.push(k % 10);\r\n    }\r\n    result.reverse();\r\n    return result;\r\n};\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：忽略返回值创建的数组，O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837629522","body":"### 思路\r\n\r\n暴力解法，先存取c下标数组，再遍历数组算s中每个字符的最小距离\r\n### 代码\r\n\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const index = [];\r\n    const result = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            index.push(i);\r\n        }\r\n    }\r\n    for (let j = 0; j < s.length; j++) {\r\n        if (s[j] === c) {\r\n            result.push(0);\r\n        } else {\r\n            result.push(Math.min(...index.map(item => Math.abs(j - item))));\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N*N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839500604","body":"### 思路\r\n\r\n似乎不需要什么思路，不过需要一个maxSize的类成员变量，作为push判断的存储依据.\r\n### 代码\r\n\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.list = [];\r\n    this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.list.length >= this.maxSize) return;\r\n    this.list.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (this.list.length === 0) return -1;\r\n    return this.list.pop();\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const length = this.list.length;\r\n    for (let i = 0; i < length; i ++) {\r\n        if (i <= k - 1) {\r\n            this.list[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：其他O(1)，increment则是O(N)\r\n- 空间复杂度：O(N)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840974886","body":"## 思路\r\n内部维护两个栈，一个为基础栈，一个为缓冲的栈，当pop peek的时候将左边的倒到右边的栈，然后取出栈顶元素即是原来的队头元素，pop的时候还要额外的倒回。empty就判断基础栈是否为空即可\r\n## 代码\r\n``` javascript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.leftStack = [];\r\n    this.rightStack = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.leftStack.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    const leftLength = this.leftStack.length;\r\n    this.rightStack = [];\r\n    for (let i = leftLength - 1; i >= 0; i--) {\r\n        this.rightStack.push(this.leftStack[i]);\r\n    }\r\n    const pop = this.rightStack.pop();\r\n    this.leftStack = [];\r\n    const rightLength = this.rightStack.length;\r\n    for (let i = rightLength - 1; i >= 0; i--) {\r\n        this.leftStack.push(this.rightStack[i]);\r\n    }\r\n    return pop;\r\n\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    const leftLength = this.leftStack.length;\r\n    this.rightStack = [];\r\n    for (let i = leftLength - 1; i >= 0; i--) {\r\n        this.rightStack.push(this.leftStack[i]);\r\n    }\r\n    return this.rightStack[leftLength - 1];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    const length = this.leftStack.length;\r\n    return length === 0;\r\n};\r\n\r\n```\r\n## 复杂度分析\r\n+ 时间复杂度：pop和peek是O(N) 其他是O(1)\r\n+ 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836746634","body":"#### 思路：\r\n数组逆序遍历，然后从个位数开始相加，将结果push新数组，最后将新数组翻转\r\n要注意进位尤其是最后一位的进位还要注意k位数比num多的情况\r\n#### 代码 JS\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n  let res = []\r\n  for(let i = num.length-1; i>= 0; --i) {\r\n      let sum = num[i] + k%10\r\n      k = Math.floor(k / 10)\r\n\r\n      if(sum >=10) {\r\n          sum = sum % 10   \r\n          k++      \r\n        \r\n      }     \r\n\r\n      res.push(sum) \r\n  }\r\n   \r\n  for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n  for(let i =0; i<Math.floor(res.length/2); i++){\r\n      [res[i], res[res.length-1-i]] =  [res[res.length-1-i], res[i]]\r\n  }\r\n  return res\r\n};\r\n```\r\n#### 复杂度分析：\r\n+ 时间复杂度：O(n)\r\n+ 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838335642","body":"#### 思路\r\n左右各遍历一次，然后看最小距离\r\n\r\n#### 代码 javascript\r\n```javascript\r\nvar shortestToChar = function(s, c) {\r\n   const l = s.length\r\n\r\n   let res = []\r\n   for(let i = 0; i< l; i++) {\r\n      if(s.charAt(i) === c){\r\n          res[i] = 0\r\n      } else {\r\n          res[i] = res[i-1] === void 0 ? Infinity : res[i-1] + 1\r\n      }\r\n   }\r\n   for(let i = l-1; i>=0; i--) {\r\n      if (res[i] === Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1;\r\n   }\r\n   return res\r\n};\r\n```\r\n#### 复杂度\r\n+ 时间复杂度：O(n)\r\n+ 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839693953","body":"#### 思路\r\n用js写栈还是比较简单的\r\n\r\n#### javascript\r\n``` javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n   this.data=[]\r\n   this.top = 0\r\n   this.length = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n   if(this.top>=this.length) {\r\n       return -1\r\n   }else {\r\n       this.data[this.top++] = x\r\n   }\r\n   \r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n   return this.top === 0 ? -1 : this.data[--this.top]\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(let i = 0; i < this.top && i < k; i++){\r\n      this.data[i]+= val\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n#### 复杂度\r\n+ 时间复杂度 O(n)\r\n+ 空间复杂度O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840637417","body":"#### 思路\r\n一个栈解决不了就用两个栈，一个用来存放重复的次数，一个用来存放字符串。比较关键的是入栈和出栈的时机。遇到`[`入栈遇到`]`出栈拼接子字符串，然后返回完整字符串。字符串的栈需要用空字符串占位\r\n#### 代码 JavaScript\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  let strStack = []\r\n  let numStack = []\r\n  let num = 0\r\n  let result = ''\r\n  for(let i =0; i<s.length; i++) {\r\n      let r = s.charAt(i) \r\n      if(isNaN(r) === false) {\r\n        num = num * 10 + Number(r)\r\n      } else if (r === '[') {\r\n        strStack.push(result)\r\n        result = ''\r\n        numStack.push(num)\r\n        num = 0\r\n      } else if (r === ']') {\r\n        result = strStack.pop() + result.repeat(numStack.pop())\r\n      } else {\r\n        result += r\r\n      }\r\n  }\r\n  return result\r\n};\r\n```\r\n#### 复杂度分析\r\n时间复杂度O(n) \r\n空间复杂度O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841301485","body":"#### 思路\r\n用两个栈，一个存输入相关，一个存输出相关。输出为空时，就遍历输入栈压入输出栈，pop的正好是队列先入的元素\r\n#### 代码 javascript\r\n```javascript\r\nvar MyQueue = function() {\r\n    this.data = []\r\n    this.temp = []\r\n};\r\n\r\nMyQueue.prototype.push = function(x) {\r\n    this.data.push(x)\r\n};\r\n\r\nMyQueue.prototype.pop = function() {\r\n    if(!this.temp.length){\r\n        while(this.data.length){\r\n             this.temp.push(this.data.pop())\r\n        }\r\n       \r\n    } \r\n    return this.temp.pop()\r\n};\r\n\r\nMyQueue.prototype.peek = function() {\r\n   if(!this.temp.length){\r\n        while(this.data.length){\r\n             this.temp.push(this.data.pop())\r\n        }\r\n    } \r\n    return this.temp[this.temp.length-1]\r\n};\r\n\r\nMyQueue.prototype.empty = function() {\r\n   return !this.data.length && !this.temp.length\r\n};\r\n```\r\n#### 复杂度分析\r\n空间复杂度：O(n)\r\n时间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzdFeiFei":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836747177","body":"**思路**\r\n官方解法\r\n\r\n**代码：**\r\n\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const res = []\r\n    const n = num.length\r\n    for(let i = n-1;i>=0;i--){\r\n        let sum = num[i] + k % 10\r\n        k = Math.floor(k/10)\r\n        if(sum>=10){\r\n            k++\r\n            sum -= 10\r\n        }\r\n        res.push(sum)\r\n    }\r\n    for(;k>0;k = Math.floor(k/10)){\r\n        res.push(k % 10)\r\n    }\r\n    res.reverse()\r\n    return res\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(max(n,log k))，其中 n 为数组的长度。\r\n- 空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838672483","body":"```\r\nclass Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839832262","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840631219","body":"```\r\nclass Solution {\r\n    int ptr;\r\n\r\n    public String decodeString(String s) {\r\n        LinkedList<String> stk = new LinkedList<String>();\r\n        ptr = 0;\r\n\r\n        while (ptr < s.length()) {\r\n            char cur = s.charAt(ptr);\r\n            if (Character.isDigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                String digits = getDigits(s);\r\n                stk.addLast(digits);\r\n            } else if (Character.isLetter(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \r\n            } else {\r\n                ++ptr;\r\n                LinkedList<String> sub = new LinkedList<String>();\r\n                while (!\"[\".equals(stk.peekLast())) {\r\n                    sub.addLast(stk.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                // 左括号出栈\r\n                stk.removeLast();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = Integer.parseInt(stk.removeLast());\r\n                StringBuffer t = new StringBuffer();\r\n                String o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime-- > 0) {\r\n                    t.append(o);\r\n                }\r\n                // 将构造好的字符串入栈\r\n                stk.addLast(t.toString());\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer ret = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            ret.append(s.charAt(ptr++));\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> v) {\r\n        StringBuffer ret = new StringBuffer();\r\n        for (String s : v) {\r\n            ret.append(s);\r\n        }\r\n        return ret.toString();\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841283761","body":"```\r\nvar MyQueue = function() {\r\n    this.inStack = [];\r\n    this.outStack = [];\r\n};\r\n\r\nMyQueue.prototype.push = function(x) {\r\n    this.inStack.push(x);\r\n};\r\n\r\nMyQueue.prototype.pop = function() {\r\n    if (!this.outStack.length) {\r\n        this.in2out();\r\n    }\r\n    return this.outStack.pop();\r\n};\r\n\r\nMyQueue.prototype.peek = function() {\r\n    if (!this.outStack.length) {\r\n        this.in2out();\r\n    }\r\n    return this.outStack[this.outStack.length - 1];\r\n};\r\n\r\nMyQueue.prototype.empty = function() {\r\n    return this.outStack.length === 0 && this.inStack.length === 0;\r\n};\r\n\r\nMyQueue.prototype.in2out = function() {\r\n    while (this.inStack.length) {\r\n        this.outStack.push(this.inStack.pop());\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LASIWan":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836748306","body":"### 思路\r\n采用每一位分别相加，并判断是否进位的方法：\r\n1、声明一个空数组\r\n2、从末位开始循环数组的每一位，并与加数k按位相加\r\n3、判断是否需要进位，当和大于10时，将结果存入下一位\r\n4、通过数组方法将存入顺序颠倒即可\r\n\r\n\r\n\r\n### JavaScript\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838531788","body":"### 思路\r\n\r\n判断目标字符与数组每一位的最小距离，那么则有几种情况\r\n目标在左侧，直接用当前位置减去目标index；\r\n目标在右侧，直接用目标index减去当前位置；\r\n两侧都有目标，则比较两侧之前的距离取最小值。\r\n\r\n\r\n### 代码\r\n\r\n```js\r\nvar shortestToChar = function(s,c){\r\n    let res = Array(s.length).fill(0);\r\n    \r\n\r\n    for(let i=0; i<s.length; i++){\r\n        if (s[i] === c) continue;\r\n\r\n        let l = i;\r\n        let r = i;\r\n        let shortest = Infinity;\r\n\r\n        while(l>=0){\r\n            if(s[l]===c){\r\n                shortest = Math.min(shortest, i-l); \r\n                break;\r\n            }\r\n            l--;\r\n        }\r\n        while(r<s.length){\r\n            if(s[r]===c){\r\n                shortest = Math.min(shortest,r-i);\r\n                break;\r\n            }\r\n            r++;\r\n        }\r\n        res[i]=shortest;\r\n    }\r\n    return res;\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N方)，两层循环。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839846195","body":"### 思路\r\n通过数组来模拟栈，使用push（）和pop（）方法实现入栈和出栈的操作。\r\n\r\n### 代码\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  this.list = []\r\n  this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.list.length < this.maxSize) {\r\n    this.list.push(x)\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  const item = this.list.pop()\r\n  return item === void 0 ? -1 : item\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (let i = 0; i < k && i < this.list.length; i++) {\r\n    this.list[i] += val\r\n  }\r\n};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fakerbaby":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836751618","body":"## [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\r\n\r\n难度:**简单**\r\n\r\n对于非负整数 `X` 而言，*`X`* 的*数组形式*是每位数字按从左到右的顺序形成的数组。例如，如果 `X = 1231`，那么其数组形式为 `[1,2,3,1]`。\r\n\r\n给定非负整数 `X` 的数组形式 `A`，返回整数 `X+K` 的数组形式。\r\n\r\n---\r\n\r\n**思路1**\r\n\r\n首先将原属组转化成字符串，然后转换成整型相加然后在切分成数组。最后返回数组为所求。\r\n\r\n**代码**\r\n\r\n~~~python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        tmp = ''\r\n        for index in num:\r\n            tmp += str(index)\r\n        res_int = int(tmp) + k\r\n        res = [int(x) for x in str(res_int)]\r\n        return res\r\n\r\n\r\n~~~\r\n\r\n\r\n\r\n**复杂度**\r\n\r\n时间：O(n)\r\n\r\n空间：O(1)\r\n\r\n---\r\n\r\n**思路2**\r\n\r\n```\r\n<加法模板>    \r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n\r\n**代码**\r\n\r\n~~~python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        i = len(A) - 1\r\n        while K:\r\n            A[i] += K\r\n            K, A[i] = A[i] // 10, A[i] % 10\r\n            i -= 1\r\n            if i < 0 and K:\r\n                A.insert(0,0)\r\n                i = 0\r\n        return A\r\n\r\n\r\n~~~\r\n\r\n\r\n\r\n**复杂度**\r\n\r\n时间：O(n)\r\n\r\n空间：O(n)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838706823","body":"# [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n#### 难度简单\r\n\r\n给你一个字符串 `s` 和一个字符 `c` ，且 `c` 是 `s` 中出现过的字符。\r\n\r\n返回一个整数数组 `answer` ，其中 `answer.length == s.length` 且 `answer[i]` 是 `s` 中从下标 `i` 到离它 **最近** 的字符 `c` 的 **距离** 。\r\n\r\n两个下标 `i` 和 `j` 之间的 **距离** 为 `abs(i - j)` ，其中 `abs` 是绝对值函数。\r\n\r\n---\r\n\r\n### 思路baseline:\r\n\r\n朴素算法，首先把c字符位置用数组记录，然后依次比较所有来得到最近的距离。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        pos,i = [],0 #pos记录位置\r\n        for e in s:\r\n            if e == c:\r\n                pos.append(i)\r\n            i += 1\r\n        Len = len(s)\r\n        ans = [0]*(Len)\r\n        min = Len\r\n        for b in range(Len):\r\n            min = Len\r\n            for c in pos:\r\n                min = min if min <= abs(b-c) else abs(b-c)\r\n                print(b)\r\n            ans[b] = min\r\n        return ans\r\n        \r\n```\r\n\r\n### 复杂度\r\n\r\n时间：$O(n^2)\r\n\r\n空间：$O(n)\r\n\r\n---\r\n\r\n### 思路strongline:\r\n\r\n从左向右和从右向左分别遍历一边，然后取最小的距离\r\n\r\n### 代码：\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        pre = -10000\r\n        ans = []\r\n        for i in range(len(S)):\r\n            if S[i] == C: pre = i\r\n            ans.append(i - pre)\r\n        pre = 20000\r\n        for i in range(len(S) - 1, -1, -1):\r\n            if S[i] == C: pre = i\r\n            ans[i] = min(ans[i], pre - i)\r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：$O(n)\r\n\r\n空间：$O(n)\r\n\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839838332","body":"# [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\r\n\r\n难度中等\r\n\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 `CustomStack` ：\r\n\r\n- `CustomStack(int maxSize)`：用 `maxSize` 初始化对象，`maxSize` 是栈中最多能容纳的元素数量，栈在增长到 `maxSize` 之后则不支持 `push` 操作。\r\n- `void push(int x)`：如果栈还未增长到 `maxSize` ，就将 `x`添加到栈顶。\r\n- `int pop()`：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 **-1** 。\r\n- `void inc(int k, int val)`：栈底的 `k` 个元素的值都增加 `val` 。如果栈中元素总数小于 `k` ，则栈中的所有元素都增加 `val` 。\r\n\r\n\r\n\r\n---\r\n\r\n### 思路1\r\n\r\n直接模拟法\r\n\r\n### 代码\r\n\r\n```python\r\nclass CustomStack:\r\n    def __init__(self, maxSize: int):\r\n        self.top = -1\r\n        self.stk = [0] * maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1: return -1\r\n        x = self.stk[self.top]\r\n        self.top -= 1\r\n        return x\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0,min(self.top+1, k)):\r\n            self.stk[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n\r\n\r\n\r\n### 算法复杂度\r\n\r\n时间:$O(1)\r\n\r\n空间:$O(1)\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n### 思路2（前缀和）\r\n\r\n见力扣++\r\n\r\n### 代码\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, size: int):\r\n        self.st = []\r\n        self.cnt = 0\r\n        self.size = size\r\n        self.incrementals = [0] * size\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.size:\r\n            self.st.append(x)\r\n            self.cnt += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt == 0: return -1\r\n        if self.cnt >= 2:\r\n            self.incrementals[self.cnt - 2] += self.incrementals[self.cnt - 1]\r\n        ans = self.st.pop() + self.incrementals[self.cnt - 1]\r\n        self.incrementals[self.cnt - 1] = 0\r\n        self.cnt -= 1\r\n        return ans\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n            if self.cnt:\r\n                self.incrementals[min(self.cnt, k) - 1] += val\r\n```\r\n\r\n### 复杂度：\r\n\r\n都是O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840644881","body":"\r\n\r\n# [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\r\n\r\n难度中等\r\n\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 *encoded_string* 正好重复 *k* 次。注意 *k* 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 *k*，例如不会出现像 `3a` 或 `2[4]` 的输入。 \r\n\r\n**示例 1：**\r\n\r\n```\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n```\r\n\r\n**示例 2：**\r\n\r\n```\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n```\r\n\r\n**示例 3：**\r\n\r\n```\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n```\r\n\r\n**示例 4：**\r\n\r\n```\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n```\r\n\r\n---\r\n\r\n### 思路(迭代)\r\n\r\n主要还是利用栈的思想，然后使用迭代的方法。吧“】”前的内容入栈，当遇到“】”需要出栈，结合【】的内容和数字进行不断迭代直到字符串s结尾。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for cha in s:\r\n            if cha == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr\r\n                #pop '['\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount  \r\n                stack.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stack.append(cha)\r\n        return \"\".join(stack)\r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\n时间:$O(n)$\r\n\r\n空间:$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841172315","body":"# [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\r\n\r\n难度简单\r\n\r\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：\r\n\r\n实现 `MyQueue` 类：\r\n\r\n- `void push(int x)` 将元素 x 推到队列的末尾\r\n- `int pop()` 从队列的开头移除并返回元素\r\n- `int peek()` 返回队列开头的元素\r\n- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\r\n\r\n \r\n\r\n**说明：**\r\n\r\n- 你只能使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\r\n- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n\r\n \r\n\r\n**进阶：**\r\n\r\n- 你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。\r\n\r\n \r\n\r\n**示例：**\r\n\r\n```\r\n输入：\r\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\r\n[[], [1], [2], [], [], []]\r\n输出：\r\n[null, null, null, 1, 1, false]\r\n\r\n解释：\r\nMyQueue myQueue = new MyQueue();\r\nmyQueue.push(1); // queue is: [1]\r\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\nmyQueue.peek(); // return 1\r\nmyQueue.pop(); // return 1, queue is [2]\r\nmyQueue.empty(); // return false\r\n```\r\n\r\n\r\n\r\n \r\n\r\n**提示：**\r\n\r\n- `1 <= x <= 9`\r\n- 最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`\r\n- 假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）\r\n\r\n---\r\n\r\n思路：\r\n\r\n无非是用两个栈来模拟队列，经典题目，一个为主栈，另一个是辅助栈保证queue的先进后出涉及到两个栈的互相“倾倒”\r\n\r\n代码：\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stk1 = []\r\n        self.stk2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stk1:\r\n            self.stk2.append(self.stk1.pop())\r\n        self.stk2.append(x)\r\n        while self.stk2:\r\n            self.stk1.append(self.stk2.pop())\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.stk1.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stk1[-1]\r\n        \r\n        \r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.stk1)\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n时间复杂度：$O(n)$\r\n\r\n空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841648560","body":"# [768. 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\r\n\r\n难度困难\r\n\r\n*这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为`2000`，其中的元素最大为`10**8`。*\r\n\r\n`arr`是一个可能包含**重复元素**的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\r\n\r\n我们最多能将数组分成多少块？\r\n\r\n**示例 1:**\r\n\r\n```\r\n输入: arr = [5,4,3,2,1]\r\n输出: 1\r\n解释:\r\n将数组分成2块或者更多块，都无法得到所需的结果。\r\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \r\n```\r\n\r\n**示例 2:**\r\n\r\n```\r\n输入: arr = [2,1,3,4,4]\r\n输出: 4\r\n解释:\r\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\r\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 \r\n```\r\n\r\n**注意:**\r\n\r\n- `arr`的长度在`[1, 2000]`之间。\r\n- `arr[i]`的大小在`[0, 10**8]`之间。\r\n\r\n---\r\n\r\n思路：\r\n\r\n类似于“融合区块”的思维，在遍历的时候找到比栈自己大或相等的入栈，如果小的话则融合。\r\n\r\n代码：\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for a in arr:\r\n            if stack and stack[-1] > a:\r\n                cur = stack[-1]\r\n                while stack and stack[-1] > a:\r\n                    stack.pop()\r\n                stack.append(cur)\r\n            else: stack.append(a)\r\n        return len(stack)\r\n```\r\n\r\n\r\n\r\n时间复杂度：$O(n)$\r\n\r\n空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841761582","body":"# [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\r\n\r\n难度中等\r\n\r\n给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。\r\n\r\n**示例 1：**\r\n\r\n![img](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)\r\n\r\n```\r\n输入：head = [1,2,3,4,5], k = 2\r\n输出：[4,5,1,2,3]\r\n```\r\n\r\n**示例 2：**\r\n\r\n![img](https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg)\r\n\r\n```\r\n输入：head = [0,1,2], k = 4\r\n输出：[2,0,1]\r\n```\r\n\r\n**提示：**\r\n\r\n- 链表中节点的数目在范围 `[0, 500]` 内\r\n- `-100 <= Node.val <= 100`\r\n- `0 <= k <= 2 * 109`\r\n\r\n---\r\n\r\n思路：\r\n\r\n​\t单链表成环，然后确定新链表的头节点，然后断开即可。\r\n\r\n代码：\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    # 融合成环找到头节点再断开\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n\r\n        n = 1\r\n        cur = head\r\n        while cur.next:\r\n            cur = cur.next\r\n            n += 1\r\n        print(n)\r\n        start = n - k % n\r\n        \r\n        #连接成环\r\n        cur.next = head\r\n        while start > 0:\r\n            cur = cur.next\r\n            start -= 1\r\n        newhead = cur.next\r\n        cur.next = None\r\n        return newhead      \r\n```\r\n\r\n复杂度：\r\n\r\n时间：$O(n)$\r\n\r\n空间：$O(1)$\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuris304":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836751629","body":"## 思路\r\n从末尾开始依次往前模拟加法运算\r\n\r\n## 关键点\r\n\r\n-  结束条件 num到首位& k加完 & 进位为0\r\n-  每次循环中要判断数组索引是否越界\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res=new LinkedList<Integer>();\r\n        int n=num.length-1;int flag=0;\r\n        while(n>-1||k!=0||flag!=0){\r\n            int tep;\r\n            if(n<0) tep=k%10+flag;\r\n            else tep=k%10+num[n]+flag;\r\n            k/=10;\r\n            flag=tep/10;\r\n            tep=tep%10;\r\n            res.add(0,tep);\r\n            n--;\r\n        }\r\n        return res;      \r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(max(log(k),n))$\r\n- 空间复杂度：$O(1)$"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838315989","body":"## 思路\r\n正反各一次遍历，第一次正向记录每一个字符与上一个目标字符的距离，第二次反向保留距离最小值\r\n\r\n## 关键点\r\n\r\n-  初始化用MAX_VALUE/2的形式，避免越界\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] S=s.toCharArray();\r\n        int[] res=new int[S.length];\r\n        int dis=Integer.MAX_VALUE/2;\r\n        for(int i=0;i<S.length;i++){\r\n            if(S[i]==c) dis=0;\r\n            res[i]=dis++;\r\n        }\r\n        for(int i=S.length-1;i>-1;i--){\r\n            if(S[i]==c) dis=0;\r\n            res[i]=Math.min(dis++,res[i]);\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n```\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838315989","body":"## 思路\r\n正反各一次遍历，第一次正向记录每一个字符与上一个目标字符的距离，第二次反向保留距离最小值\r\n\r\n## 关键点\r\n\r\n-  初始化用MAX_VALUE/2的形式，避免越界\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] S=s.toCharArray();\r\n        int[] res=new int[S.length];\r\n        int dis=Integer.MAX_VALUE/2;\r\n        for(int i=0;i<S.length;i++){\r\n            if(S[i]==c) dis=0;\r\n            res[i]=dis++;\r\n        }\r\n        for(int i=S.length-1;i>-1;i--){\r\n            if(S[i]==c) dis=0;\r\n            res[i]=Math.min(dis++,res[i]);\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n```\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840242460","body":"\r\n```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res=new StringBuilder();\r\n        int times=0;\r\n        Stack<Integer> timesStack=new Stack<Integer>();\r\n        Stack<String> strStack=new Stack<String>();\r\n        for(char c:s.toCharArray()){\r\n            if(c>='0'&&c<='9'){\r\n                times=times*10+c-'0';\r\n            }\r\n            else if(c=='['){\r\n                timesStack.push(times);\r\n                times=0;\r\n                strStack.push(res.toString());\r\n                res=new StringBuilder();\r\n            }\r\n            else if(c==']'){\r\n                int multi=timesStack.pop();\r\n                StringBuilder tem=new StringBuilder();\r\n                for(int i=0;i<multi;i++){\r\n                    tem.append(res);\r\n                }\r\n                res=new StringBuilder(strStack.pop()+tem);\r\n            }\r\n            else{\r\n                res.append(c);\r\n            }\r\n        }\r\n\r\n        return res.toString();\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841070258","body":"class MyQueue {\r\n    private Stack<Integer> stack1;\r\n    private Stack<Integer> stack2;\r\n    private int front;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stack1=new Stack<>();\r\n        stack2=new Stack<>();\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        if(stack1.empty()){front=x;}\r\n        stack1.push(x);\r\n\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(stack2.empty()){\r\n            while(!stack1.empty()){\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.pop();\r\n\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(!stack2.empty()){\r\n            return stack2.peek();\r\n        }\r\n        return front;\r\n\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return(stack1.empty()&&stack2.empty());\r\n\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841622622","body":"\r\n```java\r\n\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> s=new Stack<>();\r\n        for(int i:arr){\r\n            if(!s.empty()&&s.peek()>i){\r\n                int max=s.peek();\r\n                while(!s.empty()&&s.peek()>i){\r\n                s.pop();\r\n                }\r\n                s.push(max);\r\n            }else{\r\n                s.push(i);\r\n            }      \r\n        }\r\n        return(s.size());\r\n    }\r\n}\r\n\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Hazelnuttt":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836754397","body":"### 思路\r\n把 num 和 k 都转成数组，进行大数相加\r\n\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  k = k.toString().split(\"\").map(item => Number(item));\r\n\r\n  let carry = 0;\r\n  let result = []\r\n  while(num.length || k.length) {\r\n    carry += ~~num.pop() + ~~k.pop();\r\n    if(carry < 10){\r\n      result.unshift(carry);\r\n      carry = 0;\r\n    }else{\r\n      result.unshift(carry - 10);\r\n      carry = 1;\r\n    }\r\n  }\r\n\r\n  if(carry){\r\n    result.unshift(carry);\r\n    return result;\r\n  }else{\r\n    return result;\r\n  }\r\n\r\n\r\n};\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838578435","body":"### 解题思路\r\n贪心算法\r\n左边遍历，最小距离是多少，右边遍历，最小距离是多少，最后遍历取最小值\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar shortestToChar = function (s, c) {\r\n  let n = s.length;\r\n  let dp = new Array(n).fill(0);\r\n  let leftDp = new Array(n).fill(0);\r\n  let rightDp = new Array(n).fill(0);\r\n\r\n  let prev = -Infinity;\r\n  for(let i = 0; i < n; i++) {\r\n    if(s[i] === c) prev = i;\r\n    leftDp[i] = i - prev;\r\n  }\r\n\r\n  prev = Infinity;\r\n  for(let i = n - 1; i >= 0; i--) {\r\n    if(s[i] === c) prev = i;\r\n    rightDp[i] = prev - i;\r\n  }\r\n\r\n  for(let i = 0; i < n; i++){\r\n    dp[i] = Math.min(rightDp[i], leftDp[i])\r\n  };\r\n\r\n  return dp;\r\n\r\n};\r\n\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839808257","body":"### 解题思路\r\n考察数组实现栈的一些基本操作，入栈 => 数组push，出栈 => 数组pop，inc => 数组遍历\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if(this.stack.length === this.maxSize) return;\r\n  this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  if(this.stack.length === 0) return -1;\r\n  return this.stack.pop();\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  if(k > this.stack.length) k = this.stack.length;\r\n  for(let i = 0; i < k; i++) {\r\n    this.stack[i] += val\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840618300","body":"### 解题思路\r\n没有完成栈，暂时实现的没有嵌套的\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  let num = 0;\r\n  let str ;\r\n  let result = \"\";\r\n  for(let i = 0; i < s.length; i++) {\r\n    if(s[i] >= \"0\" && s[i] <= \"9\") {\r\n      num = num * 10 + Number(s[i]);\r\n    }\r\n    if(s[i] === \"[\") {\r\n      str = \"\";\r\n    }\r\n    if(s[i] === \"]\") {\r\n      for(let j = 0; j < num; j++) {\r\n        result += str;\r\n      }\r\n      str = \"\";\r\n      num = 0\r\n    }\r\n    if(s[i] >= \"a\" && s[i] <= \"z\") {\r\n      str += s[i];\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"WIN0624":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836759785","body":"## 思路\r\n\r\n* 把K加入A中，降低空间复杂度\r\n    * 从A的最后一位开始遍历，先将K（carry初始化为K）与最后一位相加，保留余数，整除10之后进位，直至carry为0\r\n    * 时间复杂度：O(N+max(0, K-N))\r\n    * 空间复杂度：O(max(1, K-N))\r\n* 难点：两者长度不等的情况，如何处理\r\n    * 若两者相等，最后多出的carry，新建B，把往A头部补位，变成B和A相加\r\n    * 若A长于B，则carry为0，不影响A继续补位\r\n    * 若B长于A， 则等同于有多出carry，B的补位可以直接通过数组相加，把当前位当做一个数组\r\n\r\n## 代码 | Python\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        carry = k\r\n        for i in range(len(num) - 1, -1, -1):\r\n            num[i], carry = (num[i] + carry) % 10, (num[i] + carry) // 10\r\n\t# deal with remain\r\n        B = []\r\n        while carry > 0:\r\n            B = [carry % 10] + B\r\n            carry //= 10\r\n        \r\n        return B + num\r\n```\r\n\r\n## 复杂度分析\r\n\r\n  * 时间复杂度：O(N+max(0, K-N))\r\n  * 空间复杂度：O(max(1, K-N))"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838717744","body":"## 思路\r\n\r\n  * 从左往右遍历一次，只记录到上一个C元素的距离（即在其右边的C），为`i-prev`\r\n  * 从右往左遍历一次，只记录到上一个C元素的距离(即在其左边的C）, 为`prev-i`\r\n  * 两个数组对应位数取最小值\r\n  * 要点\r\n      * 记住上一个，而非下一个，使得可以一边往后遍历，一边往ans加元素\r\n      * 不必分开两个数组存储，就存到一个，只不过第二次遍历的时候增加一个min的比较\r\n\r\n## 代码 | Python\r\n\r\n```python\r\nClass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        ans = []\r\n        # left to right iteration\r\n        prev = float('-inf')\r\n        for num, val in enumerate(S):\r\n            if val == C:\tprev = num\r\n            ans.append(num - prev)\r\n\t\t\r\n        # right to left iteration\r\n        prev = float('inf')\r\n        for num in range(len(S) - 1, -1, -1):\r\n            if S[num] == C:\tprev = num\r\n            ans[num] = min(ans[num], prev - num)\r\n        \r\n        return ans\r\n```\r\n\r\n## 复杂度分析\r\n\r\n  * 时间复杂度：$O(N)$\r\n  * 空间复杂度：$O(N)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839874545","body":"## 思路\r\n\r\n* 用数组`incremental`存储当前栈中每个元素的增加信息，之后pop的时候直接加上\r\n\r\n* **数据结构**\r\n\r\n    * 数组的第i位，存储第0-i个元素的增加信息\r\n    * 栈顶元素的增加信息 = incremental[-1]\r\n    * 其余元素的增加信息 = sum(incremental[i:-1]) => 所以在pop栈顶的时候，需要把栈顶元素的数值保留到倒数第二位元素以作穿成\r\n\r\n* **算法**\r\n\r\n    * 当push一个元素，incremental也push一个0；\r\n\r\n    * 当pop一个元素，incremental也pop作为当前元素的增加\r\n\r\n    * 但是当前pop的元素也是剩余元素需要的增加信息，这个时候，将这个信息加到incremental[-2] \r\n\r\n        > 每次只有栈顶元素能找到准确的增加信息incremental[-1]，其余元素都需要等叠加\r\n\r\n## 代码 | Python\r\n\r\n```\r\nclass CustomStack(object):\r\n    \"\"\"A class of stack with increment method.\"\"\"\r\n    \r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack, self.size, self.memo = [], 0, []\r\n    \r\n    def push(self, x: int) -> None:\r\n        if self.size < self.maxSize:\r\n            self.stack.append(x)\r\n            self.size += 1\r\n            self.memo.append(0)\r\n    \r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            self.size -= 1\r\n            add_num = self.memo.pop()\r\n            if self.memo:\r\n                self.memo[-1] += add_num \r\n            return self.stack.pop() + add_num\r\n        else:\r\n            return -1\r\n        \r\n    def increment(self, k: int, val: int) -> None:\r\n        if k < len(self.memo):\r\n            self.memo[k - 1] += val\r\n        elif self.memo:\r\n            self.memo[-1] += val\r\n```\r\n\r\n\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度: O(1)\r\n* 平均空间复杂度：O(cnt/N)，N为操作数，cnt为操作过程中栈的最大长度（<=maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840655220","body":"## 思路\r\n\r\n* 四种可能字符\r\n    * 遇到数字，开始累加\r\n    * 遇到左括号，累加数字放入栈，获取括号内部字符串，清空数字\r\n    * 遇到右括号，在当前字符串 * 累加数字（从栈中pop出）\r\n    * 普通字母，直接加到当前函数的解码字符串中\r\n* def：记得更新索引\r\n\r\n## 代码 | Python\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        def get_inner_str(s, i, stack):\r\n            decode_str = ''      # init decode_str\r\n            accum_num = []\r\n            while i < len(s):\r\n                if s[i] >= '0' and s[i] <= '9':\r\n                    accum_num.append(s[i])\r\n                elif s[i] == '[':\r\n                    stack.append(int(''.join(accum_num)))\r\n                    inner_str, i = get_inner_str(s, i+1, stack)\r\n                    decode_str += inner_str\r\n                    accum_num = []\r\n                elif s[i] == ']':\r\n                    return stack.pop() * decode_str, i\r\n                else:\r\n                    decode_str += s[i]\r\n                i += 1\r\n            return decode_str\r\n                    \r\n        return get_inner_str(s, 0, [])\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：O(N)，N为当前字符串长度\r\n* 空间复杂度：O(M)，M为解码后字符串长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841023385","body":"## 思路\r\n\r\n* 难点：时间复杂度如何实现 => 要认识到这是平均时间复杂度\r\n\r\n* 在需要pop/peek的时候，若输出栈空，则将输入栈的元素依次pop到输出栈\r\n\r\n    > 转移操作的时间复杂度为$O(N)$，N为当前已压入元素，但可以保证此后N次PEEK/POP的操作为$O(1)$时间复杂度，总用时也是$O(N)$\r\n    >\r\n    > 题目中的提示：In other words, performing `n` operations will take overall `O(n)` time even if one of those operations may take longer.\r\n\r\n## 代码 | Python\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.input_stack = []\r\n        self.output_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.input_stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.output_stack:\r\n            self._transfer()\r\n        if not self.empty():\r\n            return self.output_stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.output_stack:\r\n            self._transfer()\r\n        if not self.empty():\r\n            return self.output_stack[-1]\r\n        else:\r\n            return -1\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not (self.input_stack or self.output_stack)\r\n    \r\n    def _transfer(self):\t# 注意封装复用的代码\r\n        while self.input_stack:\r\n            self.output_stack.append(self.input_stack.pop())\r\n\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 平均时间复杂度\t\r\n    * push: $O(1)$\r\n    * pop：$O(N)$\r\n* 空间复杂度：$O(N)$，N是压入的元素总数"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ShunzWu012":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836761592","body":"### 思路\r\n按位相加，注意k的长度可能比num大\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList<>();\r\n        int n = num.length;\r\n        for(int i = n - 1; i >= 0; i--){\r\n            int sums = num[i] + k % 10;\r\n            k /= 10;\r\n            if(sums >= 10){\r\n                k++;\r\n            }\r\n            ans.add(sums%10);\r\n        }\r\n        while(k != 0){\r\n            ans.add(k%10);\r\n            k /= 10;\r\n        }\r\n        n = ans.size();\r\n        for(int i = 0; i < n/2; i++){\r\n            int temp = ans.get(i);\r\n            ans.set(i, ans.get(n-i-1));\r\n            ans.set(n-i-1, temp);\r\n        }\r\n        return  ans;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n- T:O(max(n, log(10, k)))\r\n- S:O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837715789","body":"### 思路\r\n对于每个字符而言，只需要比较当前字符到两边c的最短距离即可。\r\n\r\n注;为了不讨论左端点和右端点，对索引数组进行预处理，两端加上一个大值。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        List<Integer> idx = new ArrayList<>();\r\n        int n = s.length();\r\n        idx.add(n);\r\n        for(int i = 0; i < n; i++){\r\n            if(s.charAt(i) == c){\r\n                idx.add(i);\r\n            }\r\n        }\r\n        idx.add(n*2);\r\n        int[] ans = new int[n];\r\n        int j = 0;\r\n        for(int i = 0; i < n; i++){\r\n            if(s.charAt(i) == c){\r\n                ans[i] = 0;\r\n                j++;\r\n            }\r\n            else{\r\n                ans[i] = Math.min(Math.abs(i - idx.get(j)), Math.abs(idx.get(j+1) - i));\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n- T:O(n)\r\n- S:O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839779296","body":"### 思路\r\n要保持栈底的Inc运算，如果真的使用一个栈，那么在每次操作时候，都会全部入栈出栈一次，花销增加。\r\n使用一个数组代替这个固定栈，用索引位置记录栈顶位置。\r\n### 代码\r\n```java\r\nclass CustomStack {\r\n    private int curPos;\r\n    private int[] stack;\r\n    private int stackSize;\r\n    public CustomStack(int maxSize) {\r\n        curPos = -1;\r\n        stackSize = maxSize;\r\n        stack = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(curPos + 1 < stackSize){\r\n            curPos++;\r\n            stack[curPos] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        return curPos == -1 ? -1: stack[curPos--];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i = 0; i < Math.min(k, curPos+1); i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n### 复杂度分析\r\n&bnsp; | Time | Space\r\n--- | --- | ---\r\npush | O(1) | O(maxSize)\r\npop| O(1) | O(maxSize)\r\ninc| O(min(k, maxSize)) | O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840430499","body":"### 思路\r\n一个字符栈，一个数字栈。\r\n题目规定了，一定为k[encoding]的形式，\r\n那么，把每一个括号对中的内容提取出来后，和前一个数字做一个乘法运算就搞定啦。\r\n\r\n1. 遇到数字，继续遍历，直到非数字，入数字栈；\r\n2. 遇到 \"]\"，字符栈出栈，直到“[”，重新入栈；\r\n3. 其他情况，入字符栈\r\n\r\n### 代码(Java/Cpp/python3)\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<Character> charStack = new Stack<>();\r\n        Stack<Integer> cnts = new Stack<>();\r\n        int i = 0;\r\n        int n = s.length();\r\n        while(i < n){\r\n            if(Character.isDigit(s.charAt(i))){\r\n                int k = i;\r\n                while(i < n && Character.isDigit(s.charAt(i))){\r\n                    i++;\r\n                }\r\n                int cnt = Integer.parseInt(s.substring(k, i));\r\n                cnts.push(cnt);\r\n            }\r\n            else if(s.charAt(i) == ']'){\r\n                String str = \"\";\r\n                while(!charStack.isEmpty()){\r\n                    if(charStack.peek() == '['){\r\n                        charStack.pop();\r\n                        break;\r\n                    }\r\n                    else{\r\n                        str = charStack.peek() + str;\r\n                        charStack.pop();\r\n                    }\r\n                }\r\n                for(int j = 0; j < cnts.peek(); j++){\r\n                    for(char ch:str.toString().toCharArray()){\r\n                        charStack.push(ch);\r\n                    }\r\n                }\r\n                cnts.pop();\r\n                i++;\r\n\r\n            }\r\n            else {\r\n                charStack.push(s.charAt(i));\r\n                i++;\r\n            }\r\n        }\r\n        String ans  = \"\";\r\n        while(!charStack.isEmpty()){\r\n            ans = charStack.peek() + ans;\r\n            charStack.pop();\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    string decodeString(string decodestrs) {\r\n        stack<string> strs;\r\n        stack<int> nums;\r\n        string res=\"\";\r\n        int times=0;\r\n        for(auto s: decodestrs){\r\n            if('0' <= s && s <= '9'){\r\n                times = times*10 + int(s-'0');\r\n            }\r\n            else if('[' == s){\r\n                nums.push(times);\r\n                times = 0;\r\n                strs.push(res);\r\n                res = \"\";\r\n            }\r\n            else if(('a' <= s && s <= 'z') || ('A' <= s && s <= 'Z') ){\r\n                res += s;\r\n            }\r\n            else{\r\n                int n = nums.top();\r\n                nums.pop();\r\n                for(int i=0;i<n;i++){\r\n                    strs.top() += res;\r\n                }\r\n                res = strs.top();\r\n                strs.pop();\r\n                \r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n};\r\n```\r\n```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        if s:\r\n            stack = [s[0]]\r\n            i = 0\r\n            res = ''\r\n            while stack and i < len(s)-1:\r\n                i += 1\r\n                if s[i] != ']':\r\n                    stack.append(s[i])\r\n                else:\r\n                    tmp = ''\r\n                    # 取字符后缀\r\n                    while stack[-1] != '[':\r\n                        tmp = stack.pop() + tmp\r\n                    stack.pop()\r\n                    n = stack.pop()\r\n                    num = ''\r\n                    # 取数字前缀\r\n                    while '0' <= n and n <= '9' and stack:\r\n                        num = n + num\r\n                        n = stack.pop()\r\n                    if not ('0' <= n and n <= '9'):\r\n                        stack.append(n)\r\n                    else:\r\n                        num = n + num\r\n                    num = int(num)\r\n                    tmp = num*tmp\r\n                    stack.append(tmp)\r\n            res = ''\r\n            for s in stack:\r\n                res += s\r\n            return res\r\n        return s\r\n```\r\n### 复杂度分析\r\n- T:O(n)\r\n- S:O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840940272","body":"### 思路\r\n入栈，再全部出栈都另一站栈。\r\n### 代码\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> stk1;\r\n    Stack<Integer> stk2;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stk1 = new Stack<>();\r\n        stk2 = new Stack<>();\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        while(!stk2.isEmpty()){\r\n            stk1.push(stk2.peek());\r\n            stk2.pop();\r\n        }\r\n        stk1.push(x);\r\n        while(!stk1.isEmpty()){\r\n            stk2.push(stk1.peek());\r\n            stk1.pop();\r\n        }\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        int res = stk2.peek();\r\n        stk2.pop();\r\n        return res;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        return stk2.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return stk2.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n### 复杂度分析\r\n- T:O(n)\r\n- S:O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841601105","body":"### 思路\r\n按快排序后的结果和直接排序的结果相同,这是何意?\r\n\r\n假设排序后的结果为$[x_1, x_2, x_3, x_4, x_5, x_6, x_7]$\r\n\r\n如何确定能否分块，在这里，我们继续假设$[x_1, x_2, x_3]$为一块\r\n\r\n那么这个三个数的顺序就能随便排，比如$[x_1, x_3, x_2]$，$[x_3, x_2, x_1]$...\r\n\r\n如何确定$[x_1, x_2, x_3]$为一块，而不是$[x_1, x_2]$或者$[x_1, x_2, x_3, x_4]$呢？\r\n\r\n根据有序这一性质，我们可以得到这样一个结论，**如果$x_4 >= max (x_1, x_2, x_3)$，那么$[x_1, x_2, x_3]$可以分成一块**\r\n\r\n#### 思路1:单调栈\r\n很容易会想到**单调栈**这以数据结构\r\n维持一个单调递增栈，存储每个块中的最大值，最终单调栈的长度就是可分块的大小。\r\n\r\n\r\n#### 思路2：前缀和\r\n观察有序序列$[x_1, x_2, x_3]$与无序序列$[x_1, x_3, x_2]$之间的关系，会发现无论怎样改变，这两个序列的和一样，也就是说对有序序列和无序序列从前到后遍历相加，只要和相同，那么就可以分成块。\r\n\r\n#### 思路3：峰值检测\r\n对于块的右临界值，一定满足小于等于右边的所有值，大于等于左边左右值。\r\n首先找出每个值，前面的最大值，然后倒序遍历，对于最大值小于后序最小值的，可作为分快点。\r\n### 代码\r\n#### 代码1\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        int ans = 0;\r\n        for(int num:arr){\r\n            if(!stack.isEmpty() && num < stack.peek()){\r\n                int tmp = stack.pop();\r\n                while(!stack.isEmpty() && num < stack.peek()){\r\n                    stack.pop();\r\n                }\r\n                stack.push(tmp);\r\n            }\r\n            else{\r\n                stack.push(num);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n#### 代码2\r\n```java\r\nclass Solution{\r\n    public int maxChunkToSorted(int[] arr){\r\n        int n = arr.length;\r\n        int[] presum = new int[n];\r\n        presum[0] = arr[0];\r\n        for(int i=1; i < n; i++){\r\n            presum[i] += presum[i-1] + arr[i];\r\n        }\r\n        Arrays.sort(arr);\r\n        int tmp = 0;\r\n        int ans = 0;\r\n        for(int i = 0; i < n; i++){\r\n            tmp += arr[i];\r\n            if(presum[i] == tmp){\r\n                ans += 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n#### 代码3\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int ans = 0;\r\n        int n = arr.length;\r\n        int[] curMax = new int[n];\r\n        curMax[0] = arr[0];\r\n        for(int i = 1; i < n; i++){\r\n            curMax[i] = Math.max(curMax[i-1], arr[i]);\r\n        }\r\n        int tmp = Integer.MAX_VALUE;\r\n        for(int  i = n -1; i >= 0; i--){\r\n            if(tmp >= curMax[i]){\r\n                ans++;\r\n            }\r\n            tmp = Math.min(tmp, arr[i]);\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\nMethod | Time | Space\r\n--- | --- | ---\r\n单调栈 | O(n) | O(n)\r\n前缀和 | O(nlogn) | O(n)\r\n峰值检测 | O(n) | O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangpengzhen":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836765721","body":"不会没思路"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837748302","body":"没思路"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839698904","body":"没有思路,只知道push是往栈里面添加数据,pop是删除数据"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840281496","body":"### 思路\r\n辅助栈\r\n### 代码\r\n\r\n` function CodeStr(s) {\r\n    let repeats = 0, res = ''; const strStack = [], numStack = [];\r\n    for (let str of s) {\r\n        if (!isNaN(str)) {//是数字\r\n            repeats = 10 * repeats + +str;\r\n        } else if (str === '[') {\r\n            //进入下一层\r\n            numStack.push(repeats);\r\n            repeats = 0;\r\n            strStack.push(res);\r\n            res = ''\r\n        } else if (str === ']') {\r\n            res = strStack.pop() + res.repeat(numStack.pop())\r\n        } else {\r\n            res += str\r\n        }\r\n    }\r\n        return res\r\n\r\n};`\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841141023","body":"```\r\nvar MyQueue = function () {\r\n    this.stack = []\r\n};\r\n\r\nMyQueue.prototype.push = function (x) {\r\n    this.stack.push(x)\r\n};\r\n\r\n\r\nMyQueue.prototype.pop = function () {\r\n    // 从队列头中弹出\r\n    const tempStack = []\r\n    while (this.stack.length) {\r\n        tempStack.push(this.stack.pop())\r\n    }\r\n    const result = tempStack.pop()\r\n    while (tempStack.length) {\r\n        this.stack.push(tempStack.pop())\r\n    }\r\n    return result\r\n};\r\n\r\n\r\nMyQueue.prototype.peek = function () {\r\n    return this.stack[0] // 这个直接返回即可，不同语言不一样，不行就按照 pop 方法倒水，一样可行\r\n};\r\n\r\n\r\nMyQueue.prototype.empty = function () {\r\n    return !this.stack.length\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841631439","body":"```\r\nvar maxChunksToSorted = function(arr) {\r\n  let queue = [];\r\n\r\n  for(let i = 0; i < arr.length; i++){\r\n\r\n    if(queue.length == 0 || (queue[queue.length - 1] <= arr[i])){\r\n      queue.push(arr[i])\r\n    }else{\r\n      //the size of the queue reprensets the size of partition\r\n\r\n      let temp = queue.pop()\r\n      while(queue[queue.length - 1] > arr[i]){\r\n        queue.pop()\r\n      }\r\n\r\n      queue.push(temp)\r\n    }\r\n\r\n  }\r\n  return queue.length\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yxq1997":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836766743","body":"## 前置知识\r\n\r\n- 数组的遍历，整数的运算\r\n\r\n## 思路\r\n- 从后往前遍历数组，得到的是X的从低到高的每一位\r\n- k%10得到最低位，k/10更新当前k的倒数第二位为最低位\r\n- 通过将k的最低位与X的最低位诸位相加得到新的结果value，并用count = value /10保存当前加法后的进位数值，用value/10保留当前加法后的最低位\r\n\r\n## 关键点\r\n\r\n-  可以吧k当做一个数组来看，本题类似于两个数组的加法运算，加法循环的终止条件是两个数组(k和nuns)都便利了一遍，且进位count为0\r\n- 在本题中直接得到的结果在list中是逆序排列的，因此需要反转\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int count = 0; // 表示进位符\r\n        List<Integer> list = new ArrayList<>();\r\n        int n = num.length;\r\n        int value = 0;\r\n        for(int i=n-1;i>=0;i--){\r\n            int kNum = k % 10;\r\n            value = num[i] + kNum + count;\r\n            count = value / 10;\r\n            list.add(value % 10);\r\n            if(k > 0)\r\n                k /= 10;\r\n        }\r\n        k += count;\r\n        while(k > 0){\r\n            list.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(list);\r\n        return list;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(max(n, log k)$\r\n- 空间复杂度：$O(1)$"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838216276","body":"## 前置知识\r\n\r\n- 数组的遍历\r\n\r\n## 思路\r\n- 由题意可知每个字符的最短距离，即是左边离该字符最近的c字符与右边离该字符最近的c字符的距离的较小值\r\n- 因此通过一次顺序遍历，得到左边离该字符最近的c字符到该字符的距离；然后一次逆序遍历，得到右边离该字符最近的c字符到该字符的距离，两者比较去较小值即可\r\n\r\n## 关键点\r\n\r\n-  怎样实现只取左边最近的c字符的距离与右边最近的c字符的距离 --> 分别通过顺序和逆序遍历得到\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java {15}\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c){\r\n        int n = s.length();\r\n        int[] ans = new int[n];\r\n        int prev = -n;\r\n        for(int i=0;i<n;i++){\r\n            if(s.charAt(i) == c)\r\n                prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = 2 * n;\r\n        for(int i=n-1;i>=0;i--){\r\n            if(s.charAt(i) == c)\r\n                prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n令 n 为数组长度。\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839393265","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 前置知识\r\n\r\n- 栈的实现\r\n\r\n## 思路\r\n- 使用数组来模拟栈\r\n## 关键点\r\n\r\n-  用数组下标为0的位置表示栈底\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass CustomStack {\r\n    int[] stack;\r\n    int size;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        size = 0;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if(size < stack.length)\r\n            stack[size++] = x;\r\n    }\r\n\r\n    public int pop() {\r\n        if(size == 0)\r\n            return -1;\r\n        return stack[--size];\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int m = Math.min(k, size);\r\n        for(int i=0;i<m;i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n令 nmaxSize为栈的容量。\r\n- 时间复杂度：$O(maxSize)$ --> inc操作的时间复杂度为O(maxSize)\r\n- 空间复杂度：$O(maxSize)$ --> 使用了一个数组来模拟栈"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840273846","body":"## 题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 前置知识\r\n- 字符串的判断：是不是数字\r\n- 用栈进行符号匹配\r\n## 思路\r\n- 将s的字符进栈，当碰到‘]’时将栈顶元素去除，直到碰到'['，即得到要重复的字符串，然后继续取出栈顶元素直到碰到‘]’或栈为空，此即为该字符串要重复的次数，然后将重复后的字符串重新入栈。\r\n- 栈的作用即为再不改变字符串相对顺序的情况下，消除s中的 '[' 和 ']' 字符\r\n## 关键点\r\n-  ‘[’ 字符只用作匹配 ']' 字符，一旦匹配成功，则将 '[' 字符出栈\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        int n = s.length();\r\n        Deque<Character> stack = new LinkedList<>();\r\n        StringBuilder res = new StringBuilder();\r\n        for(int i=0;i<n;i++){\r\n            char c = s.charAt(i);\r\n            if(c != ']'){\r\n                stack.push(c);\r\n            }\r\n            else{\r\n                StringBuilder str = new StringBuilder();\r\n                while(!stack.isEmpty() && stack.peek() != '['){\r\n                    str.append(stack.pop());\r\n                }\r\n                stack.pop();\r\n                StringBuilder digit = new StringBuilder();\r\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\r\n                    digit.insert(0, stack.pop());\r\n                }\r\n                int count = Integer.parseInt(digit.toString());\r\n                for(int j=0;j<count;j++){\r\n                    for(int k=str.length()-1;k>=0; k--){\r\n                        char ch = str.charAt(k);\r\n                        stack.push(ch);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        while (!stack.isEmpty()){\r\n            res.append(stack.pop());  //最后反转能降低所用时间 \r\n        }\r\n        return res.reverse().toString();\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n令 n 为数组长度。\r\n- 时间复杂度：$O(n^2)$ --> 每个元素至多进栈和出栈n/2次\r\n- 空间复杂度：$O(n)$  --> 使用了一个stack,容量至多为n；两个StringBuildere类型数据str和digit，长度之和不会超过n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841030717","body":"\r\n## 题目地址(232. 用栈实现队列)\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n## 前置知识\r\n\r\n- 栈的使用\r\n- 栈和队列的特点\r\n\r\n## 思路\r\n- 将元素先经过输入栈，然后再经过输出栈，就实现了队列的功能\r\n\r\n## 关键点\r\n\r\n-  每当输出栈为空时，需要将输入栈的所有元素都出栈到输出栈中\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass MyQueue {\r\n    Deque<Integer> stack1;\r\n    Deque<Integer> stack2;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stack1 = new LinkedList<>(); // 输入栈\r\n        stack2 = new LinkedList<>(); // 输出栈\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(stack2.isEmpty()){\r\n            while(!stack1.isEmpty()){\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(stack2.isEmpty()){\r\n            while(!stack1.isEmpty()){\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return stack2.isEmpty() && stack1.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n\r\n```\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(1)$ --> 每个元素至多在输入栈和输出栈里面分别入栈和出栈了一次\r\n- 空间复杂度：$O(n)$ --> 最多所有元素都进入输入栈或者输出栈"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841626107","body":"\r\n## 题目地址(768. 最多能完成排序的块 II)\r\n\r\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\r\n\r\n## 前置知识\r\n- 单调栈的应用\r\n\r\n## 思路\r\n- 将遍历到i为止的最大值存入栈中，表示一个合理的分块\r\n- 从左到右遍历数组，比较当前元素num与栈顶元素peek，若当前元素小于栈顶元素，则出栈。并进入循环：若num小于栈顶元素，则出栈知道栈为空或者当前元素大于栈顶元素\r\n## 关键点\r\n-  若后面遇到比栈顶元素小的元素num，则证明之前的分块需要调整，因此，需要将栈中大于num的元素都出栈(因为这些分块都不是合理的分块了)\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Deque<Integer> stack = new LinkedList<>();\r\n        for(int value: arr){\r\n            if(!stack.isEmpty() && value < stack.peek()){\r\n                int head = stack.pop();\r\n                while (!stack.isEmpty() && value < stack.peek())\r\n                    stack.pop();\r\n                stack.push(head);\r\n            }\r\n            else stack.push(value);\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n令 n 为数组长度。\r\n- 时间复杂度：$O(n)$ --> 一次遍历整个数组，且栈中至多有一个元素入站出栈n次，平均每个元素入栈和出栈各1次，因此为O(n)\r\n- 空间复杂度：$O(n)$ --> 使用了栈，最大容量为O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Forschers":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836774703","body":"\r\n## 思路\r\n将k中的数取出一个个加入到数组中\r\n\r\n\r\neg:将【2，3，4】+ k=32 计算 4+32 因为4+32  = 36将6留在当前位 将k/10 以进为的形式加入到下个位中\r\n重复过程计算 【2，3】+ 3\r\n\r\n## 关键点\r\n\r\n-  将k放入到数组后\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> arr = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        //将k以 k/10的形式进位\r\n        for(int i = n-1;i>=0 || k>0;--i,k/=10){\r\n            if(i >= 0){\r\n                k +=num[i];\r\n            }\r\n            //加上k取出来的最后一位\r\n            arr.add(k%10);\r\n        }\r\n        //反转\r\n        Collections.reverse(arr);\r\n        return arr;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(max(n,logk))\r\n- 空间复杂度：O(1)\r\n\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838618318","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n整形反转\r\n\r\n## 思路\r\n对每个字符串 找出左右中c的距离 比较左右的距离 选择最小值\r\n\r\n\r\n左向右：\r\n\r\n上个字符出现的位置prev  距离 : i - prev\r\n\r\n右向左：\r\n\r\n上个字符出现的位置prev 则距离: prev - i\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        //创建新的数组ans\r\n        int[] ans = new int[n];\r\n        int prev = Integer.MIN_VALUE/2;\r\n\r\n        for(int i = 0;i < n;++i){\r\n            //法返回指定索引处的char值\r\n            if(s.charAt(i) == c){\r\n                //当遍历的值和c相等 位置prev为当前i 的位置\r\n                prev = i;\r\n            }\r\n            //左 ==》 右 遍历\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n         prev = Integer.MAX_VALUE/2;\r\n\r\n        for(int i = n-1;i >= 0;--i){\r\n            //法返回指定索引处的char值\r\n            if(s.charAt(i) == c){\r\n                //当遍历的值和c相等 位置prev为当前i 的位置\r\n                prev = i;\r\n            }\r\n            //选择其中最小的\r\n            ans[i] = Math.min(ans[i],prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838618318","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n整形反转\r\n\r\n## 思路\r\n对每个字符串 找出左右中c的距离 比较左右的距离 选择最小值\r\n\r\n\r\n左向右：\r\n\r\n上个字符出现的位置prev  距离 : i - prev\r\n\r\n右向左：\r\n\r\n上个字符出现的位置prev 则距离: prev - i\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        //创建新的数组ans\r\n        int[] ans = new int[n];\r\n        int prev = Integer.MIN_VALUE/2;\r\n\r\n        for(int i = 0;i < n;++i){\r\n            //法返回指定索引处的char值\r\n            if(s.charAt(i) == c){\r\n                //当遍历的值和c相等 位置prev为当前i 的位置\r\n                prev = i;\r\n            }\r\n            //左 ==》 右 遍历\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n         prev = Integer.MAX_VALUE/2;\r\n\r\n        for(int i = n-1;i >= 0;--i){\r\n            //法返回指定索引处的char值\r\n            if(s.charAt(i) == c){\r\n                //当遍历的值和c相等 位置prev为当前i 的位置\r\n                prev = i;\r\n            }\r\n            //选择其中最小的\r\n            ans[i] = Math.min(ans[i],prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"XinlingQiu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836776627","body":"- 语言 python\r\n- 时间复杂度：O(max(n,log(k)))\r\n- 空间复杂度：O(1)\r\n- 无需反转\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n=len(num)\r\n        count=0#进位符\r\n        for i in range(n-1,-1,-1):\r\n            new_i=num[i]+k%10+count\r\n            count=new_i/10\r\n            num[i]=new_i%10\r\n            if k>0:\r\n                k=k/10\r\n        k+=count\r\n        while k>0:\r\n            num.insert(0,k%10)\r\n            k/=10\r\n        return num\r\n```"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840630323","body":"```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        symbol=[]\r\n        for i in s:\r\n            try:\r\n                num=int(i)\r\n                num=symbol.pop()*10+num if symbol and isinstance(symbol[-1],int) else num\r\n                symbol.append(num)\r\n            except ValueError:\r\n                if i==']':\r\n                    s1=''\r\n                    while symbol[-1]!='[':\r\n                        s1=symbol.pop()+s1\r\n                    symbol.pop()\r\n                    symbol.append(symbol.pop()*s1)\r\n                else:\r\n                    symbol.append(i)\r\n        return ''.join(symbol)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841259914","body":"# Runtime: 4 ms, faster than 100.00% of Python online submissions for Implement Queue using Stacks.\r\n# Memory Usage: 13.4 MB, less than 89.07% of Python online submissions for Implement Queue using Stacks.\r\n```python\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack=[]\r\n        self.stk_aid=[]\r\n        \r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.stack.append(x)\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        :rtype: int\r\n        \"\"\"\r\n        top=self.stack[0]\r\n        while self.stack:\r\n            self.stk_aid.append(self.stack.pop())\r\n        self.stk_aid.pop()\r\n        while self.stk_aid:\r\n            self.stack.append(self.stk_aid.pop())\r\n        return top\r\n        \r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        Get the front element.\r\n        :rtype: int\r\n        \"\"\"\r\n        return self.stack[0] if self.stack else self.stk_aid[-1]\r\n        \r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        :rtype: bool\r\n        \"\"\"\r\n        return len(self.stack)==0 and len(self.stk_aid)==0\r\n        \r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suffocatingly0":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836783424","body":"- 语言 java\r\n- 时间复杂度O（n）\r\n- 空间复杂度O（n）\r\n- n = Math.max(num.length, k.length)\r\n```\r\nclass Solution {\r\n   public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res =new ArrayList<>();\r\n        int count=0;\r\n        for(int i=num.length-1;i>=0;i--){\r\n            int sum=num[i]+k%10;\r\n            k=k/10;\r\n            res.add((sum+count)%10);\r\n            count=(sum+count)/10;\r\n        }\r\n        if(count>0) k++;\r\n        for(;k>0;k/=10){\r\n            res.add(k%10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837657821","body":"- 语言：Java\r\n- 时间复杂度：O（N*M）\r\n- 空间复杂度：O（N）\r\n- N是s的长度，M是c在s中重复的个数\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        List<Integer> list=new ArrayList<>();\r\n        for(int i=0;i<s.length();i++){\r\n            if(s.charAt(i)==c){\r\n                list.add(i);\r\n            }\r\n        }\r\n       int [] distance=new int[list.size()];\r\n        for(int i=0;i<list.size();i++){\r\n            distance[i]=list.get(i);\r\n        }\r\n        int [] res =new int[s.length()];\r\n        Arrays.fill(res,Integer.MAX_VALUE);\r\n        for(int i=0;i<s.length();i++){\r\n            for(int j=0;j<distance.length;j++){\r\n                int a=Math.abs(i-distance[j]);\r\n                if(a<res[i]) res[i]=a;\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839714684","body":"方法一：双栈\r\n\r\n- 时间复杂度：push O(1)；pop O(1); increment O(N)\r\n- 空间复杂度：O（N）\r\n```\r\n- class CustomStack {\r\n    Stack<Integer> stack =new Stack<>();\r\n    int len;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.len= maxSize;\r\n    }\r\n\r\n    public void push(int x) {\r\n        //如果栈长>len 返回null；\r\n        //否则，直接利用stack.push()\r\n       if(stack.size()<len){\r\n            stack.push(x);\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        //栈为空，->-1\r\n        //栈不是空，利用栈本身的函数pop（）\r\n        if(stack.size()==0||stack.isEmpty()){\r\n            return -1;\r\n        }\r\n        else{\r\n            return stack.pop();\r\n        }\r\n\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        Stack<Integer> temp =new Stack<>();\r\n        int size= stack.size();\r\n        while(!stack.isEmpty()){\r\n            temp.push(stack.pop());\r\n        }\r\n        if(k<size){\r\n           while(!temp.isEmpty()){\r\n             while(k>0){\r\n                stack.push(temp.pop()+val);\r\n                k--;\r\n                } \r\n            stack.push(temp.pop());\r\n            }\r\n        }\r\n        else{\r\n            while(!temp.isEmpty()) {\r\n                stack.push(temp.pop() + val);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n方法二：\r\n- 时间复杂度：push O(1)；pop O(1); increment O（k)\r\n- 空间复杂度：O（maxSize）\r\n```\r\nclass CustomStack {\r\n    \r\n     int [] stack ;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack =new int[maxSize];\r\n        top=0;\r\n    }\r\n\r\n    public void push(int x) {\r\n        //栈长<len,直接利用stack.push(),最后一次stack[2]=x;top=3\r\n        //stack[0] top=1 stack[1]  stack[2]  top=3\r\n       if(top< stack.length){\r\n           stack[top++]=x;\r\n       }\r\n    }\r\n\r\n    public int pop() {\r\n    \r\n        if(top==0){\r\n            return -1;\r\n        }\r\n        else{\r\n            //--top=2 --top=1 --top=0 \r\n            return stack[--top];\r\n        }\r\n\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n       k=Math.min(k,top);\r\n       for(int i=0;i<k;i++){\r\n           stack[i]+=val;\r\n       }\r\n    }\r\n\r\n}\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841033684","body":"语言：java\r\n时间复杂度：O（1）\r\n空间复杂度：O（N）\r\n```\r\nclass MyQueue {\r\n  public Stack<Integer> a;// 输入栈\r\n    public Stack<Integer> b;// 输出栈\r\n    \r\n    public MyQueue() {\r\n        a = new Stack<>();\r\n        b = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        a.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        // 如果b栈为空，则将a栈全部弹出并压入b栈中，然后b.pop()\r\n        if(b.isEmpty()){\r\n            while(!a.isEmpty()){\r\n                b.push(a.pop());\r\n            }\r\n        }\r\n        return b.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(b.isEmpty()){\r\n            while(!a.isEmpty()){\r\n                b.push(a.pop());\r\n            }\r\n        }\r\n        return b.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return a.isEmpty() && b.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"S-T-D":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836785905","body":"# 思路\r\n\r\n对数组 `A` 从后往前遍历，同时对 `K` 取 10 的余数，将遍历的数字和余数相加得到新值，并更新数组对应位置的值，同时注意是否进位。\r\n\r\n注意：`K` 的位数可能比 `A` 的长度要长。\r\n\r\n&nbsp;\r\n\r\n# 代码\r\n\r\n```javascript\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    const len = num.length;    \r\n    let i = len - 1;\r\n    let carry = 0;\r\n    while (i >= 0) {\r\n        let addNum = 0;\r\n        if (k !== 0) {\r\n            addNum = k % 10;\r\n            k = Math.floor(k / 10);\r\n        }\r\n        let sum = num[i] + carry + addNum;\r\n        carry = sum >= 10 ? 1 : 0;\r\n        num[i] = sum % 10;\r\n        i--;\r\n    }\r\n    k += carry;\r\n    while (k !== 0) {\r\n        num.unshift(k % 10);\r\n        k = Math.floor(k / 10);\r\n    }\r\n    return num;\r\n};\r\n```\r\n\r\n&nbsp;\r\n\r\n# 复杂度分析\r\n\r\n令 `n` 为数组长度，`m` 为 `k` 的位数，按最坏情况\r\n\r\n时间：O(n + (m - n)^2)，第一个循环为 O(n)，第二个循环内在数组头部插入元素涉及数组的移动操作\r\n\r\n空间：O(m - n)，如果 `m` 大于 `n`，数组需要增加 `m - n` 的长度"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837706722","body":"## 思路\r\n\r\n可以分两次遍历。\r\n\r\n第一次遍历，从左往右，计算每个字符离左边的最近的 `c` 的距离。\r\n\r\n第二次遍历，从右往左，计算每个字符离右边最近的 `c` 的距离，再取最小值。\r\n\r\n## 代码\r\n\r\n```javascript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    const ans = [];\r\n    const len = s.length;\r\n\r\n    let prev = -10000;\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) {\r\n            prev = i;\r\n        }\r\n        ans.push(i - prev);\r\n    }\r\n\r\n    prev = 20000;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] === c) {\r\n            prev = i;\r\n        }\r\n        ans[i] = Math.min(ans[i], prev - i);\r\n    }\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间：O(n)，`n` 为字符串的长度。  \r\n- 空间：O(1)，忽略返回的数组所占空间。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837706722","body":"## 思路\r\n\r\n可以分两次遍历。\r\n\r\n第一次遍历，从左往右，计算每个字符离左边的最近的 `c` 的距离。\r\n\r\n第二次遍历，从右往左，计算每个字符离右边最近的 `c` 的距离，再取最小值。\r\n\r\n## 代码\r\n\r\n```javascript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    const ans = [];\r\n    const len = s.length;\r\n\r\n    let prev = -10000;\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) {\r\n            prev = i;\r\n        }\r\n        ans.push(i - prev);\r\n    }\r\n\r\n    prev = 20000;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] === c) {\r\n            prev = i;\r\n        }\r\n        ans[i] = Math.min(ans[i], prev - i);\r\n    }\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间：O(n)，`n` 为字符串的长度。  \r\n- 空间：O(1)，忽略返回的数组所占空间。\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsgouwan":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836787849","body":"思路：\r\n    转化为数组， 从末位起，两两相加，\r\n\r\n代码：\r\n```\r\n var addToArrayForm = function(num, k) {\r\n        let result = []\r\n        k = k.toString().split('')\r\n        let carryBit = 0\r\n        let _temp = 0\r\n        while(num.length > 0 || k.length > 0) {\r\n            let num1 = num.pop() \r\n            let num2 = k.pop() \r\n            num1 = num1 ? num1 * 1 : 0\r\n            num2 = num2 ? num2 * 1 : 0\r\n            _temp = num1 + num2 + carryBit\r\n            if(_temp > 9) {\r\n                carryBit = 1\r\n                _temp = _temp - 10\r\n            }else {\r\n                carryBit = 0\r\n            }\r\n            result.unshift(_temp)\r\n        }\r\n\r\n        if(carryBit > 0) {\r\n            result.unshift(1)\r\n        }\r\n        return result;\r\n    };\r\n```\r\nn = Math.max(num.length, k.length)\r\n时间复杂度：O(n)\r\n空间复杂度O(n)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838184466","body":"思路: 字符串转化为数组，找出匹配字符串在数组中的下标存为数组2；遍历数组，找出数组中差值最小的下标并返回\r\n语言: javascript\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    s = s.split('')\r\n    // 先遍历出C在数组中的位置\r\n    let subscript = []\r\n    let result = []\r\n    s.forEach((item, index) => {\r\n        if(item === c) {\r\n            subscript.push(index)\r\n        }\r\n    })\r\n    // \r\n    s.forEach((item, index) => {\r\n        let _min = subscript.reduce((pre, next) => {\r\n            return Math.min(pre, Math.abs(next - index))\r\n        }, Math.abs(subscript[0] - index))\r\n        result.push(_min)\r\n    })\r\n    return result\r\n};\r\n```\r\n\r\n复杂度：\r\n    字符串的长度 为m  \r\n    字符在字符串的个数为n \r\n    时间复杂度：O(m*n)\r\n    空间复杂度：O(m)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839398896","body":"思路：\r\n    使用数组模拟栈， 处理好边界问题\r\n 代码：javascript\r\n```js\r\nvar CustomStack = function(maxSize) {\r\n    // 初始化一个数组\r\n    this.list = []\r\n    this.maxSize = maxSize\r\n    return this.stack\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.list.length < this.maxSize){\r\n        this.list.push(x);\r\n    }\r\n    return this.list\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(this.list.length > 0){\r\n        return this.list.pop();\r\n    }else {\r\n        return -1;\r\n    }\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\n/* 栈底的 k 个元素增加 val , 如果栈底的元素数量小于 k 个则所有的都增加 val\r\n 在这里注意 k 的值，其实栈是从下面向上面递增的，也就是说下面是从零开始的。即 i<k就好了。\r\n*/\r\nCustomStack.prototype.increment = function(k, val) {\r\n   let _index = 0\r\n    k =Math.min(k, this.list.length)\r\n    while(_index < k) {\r\n        let value = this.list[_index]\r\n        if(value != undefined) {\r\n            this.list[_index] = value *1 + val *1\r\n        }\r\n        _index ++\r\n    }\r\n    return this.list\r\n};\r\n```\r\n复杂度：push、pop  O(1)   increment O(k)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840321754","body":"思路： 递归 + 栈\r\n自己最开始没有想明白，参考其他同学思路，最终想明白且理解\r\n代码：\r\n```\r\nvar decodeString = function (s) {\r\n    let strStack = []  \r\n    let numStack = []\r\n    let result = ''\r\n    let num = 0\r\n    for(let value of s) {\r\n        if(!isNaN(value)) {\r\n            num =num * 10 + Number(value)\r\n        }else if(value === '[') {\r\n            strStack.push(result); \r\n            result = ''\r\n            numStack.push(num) \r\n            num = 0 \r\n        }else if(value === ']') {\r\n            result = strStack.pop() + result.repeat(numStack.pop())\r\n        }else {\r\n            result += value\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841304695","body":"思路：\r\n1. 用两个栈，stack1/stack2\r\n2. 入队时，push 到stack1\r\n3. 出队时：\r\n   如果stack2为空，将stack1中的所有元素逐一弹出，push到stack2中，stack2弹出栈顶元素\r\n   如果stack2不为空，stack2弹出栈顶元素\r\n\r\n代码：\r\n```\r\nvar MyQueue = function() {\r\n   this.stack1=[];//数据都保存在stack1\r\n   this.stack2=[];//数据从stack1出栈进入stack2\r\n   \r\n};\r\n\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack1.push(x);\r\n};\r\n\r\nMyQueue.prototype.pop = function() {\r\n    if(this.stack2.length){//如果stack2不为空，说明数据全都移入了stack2，直接pop操作移除stack2的最后一位即为stack1 的第一位\r\n        return this.stack2.pop();\r\n    }else{\r\n        if(this.stack1.length){//如果stack1不为空\r\n            var len = this.stack1.length;\r\n            for(var i=0;i<len;i++){\r\n                this.stack2.push(this.stack1.pop());//将元素全部移入到stack2\r\n            }\r\n            return this.stack2.pop()//pop操作移除stack2的最后一位即为stack1 的第一位\r\n        }else{\r\n             return null\r\n        }\r\n         \r\n    }\r\n};\r\n\r\nMyQueue.prototype.peek = function() {\r\n    if(this.stack1.length==0){\r\n        return this.stack2[this.stack2.length-1]\r\n    }else if(this.stack2.length==0)\r\n    return this.stack1[0];\r\n};\r\n\r\nMyQueue.prototype.empty = function() {\r\n    if(this.stack1.length==0&& this.stack2.length==0){//只有当两个stack均为空的时候才能证明队列为空\r\n        return true;\r\n    }else {\r\n        return false;\r\n    }\r\n};\r\n\r\n```\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ziwh":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836788224","body":"## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n当前位 = (A 的当前位 + B 的当前位 + 进位) % 10\r\n\r\n注意，AB两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在前面。\r\n\r\n```\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位\r\n    \r\n    // 循环条件调整\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n```\r\n\r\n## 代码\r\nJava\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int i = num.length - 1;\r\n        int sum = 0;\r\n        List<Integer> ans = new ArrayList<>();\r\n        while(i >= 0 || k != 0 || sum != 0) {\r\n            int x = i >= 0 ? num[i] : 0;\r\n            int y = k != 0 ? k % 10 : 0;\r\n            sum += x + y;\r\n            ans.add(sum % 10);\r\n            sum = sum / 10;\r\n            k = k / 10;\r\n            i--;\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(max(n, log(k))\r\n空间复杂度: O(1)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837651373","body":"## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n当前字符距离c最短距离 = Math.min(当前字符距离左边c字符最短距离, 当前字符距离右边边c字符最短距离)\r\n\r\n\r\n## 代码\r\nJava\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] prev = new int[s.length()];\r\n        int[] next = new int[s.length()];\r\n\r\n        int begin = -1;\r\n        int end = s.length();\r\n        for(int i = 0; i < s.length(); i++) {\r\n            int endLoc = s.length() - i - 1;\r\n            if(s.charAt(i) == c) {\r\n                begin = i;\r\n                prev[i] = 0;\r\n            } else {\r\n                if(begin < 0) prev[i] = Integer.MAX_VALUE;\r\n                else prev[i] = i - begin;\r\n            }\r\n            if(s.charAt(endLoc) == c) {\r\n                end = endLoc;\r\n                next[end] = 0;\r\n            } else {\r\n                if(end > s.length() - 1) next[endLoc] = Integer.MAX_VALUE;\r\n                else next[endLoc] = end - endLoc;\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < s.length(); i++) {\r\n            prev[i] = Math.min(prev[i], next[i]);\r\n        }\r\n        return prev;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度: O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839616610","body":"## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n用一个数组数组模拟栈的操作\r\n\r\n\r\n## 代码\r\nJava\r\n```\r\nclass CustomStack {\r\n\r\n    private int maxSize;\r\n    private List<Integer> list;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        list = new ArrayList<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(list.size() >= maxSize) return;\r\n        else {\r\n            list.add(x);\r\n        }\r\n\r\n    }\r\n    \r\n    public int pop() {\r\n        if(list.size() < 1) return -1;\r\n        else {\r\n            int res = list.get(list.size() - 1);\r\n            list.remove(list.size() - 1);\r\n            return res;\r\n        }\r\n\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(list.size() < k) {\r\n            for(int i = 0; i < list.size(); i++) {\r\n                list.set(i, list.get(i) + val);\r\n            }\r\n        } else {\r\n            for(int i = 0; i < k; i++) {\r\n                list.set(i, list.get(i) + val);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：push: O(1), pop: O(1), increment: O(k)\r\n\r\n空间复杂度: O(maxSize)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840929751","body":"## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n一个栈专门用作入栈，一个栈专门用作出栈，当出栈为空时，则把入栈中的元素全部转移到出栈中\r\n\r\n通过这种入栈出栈操作，保证了元素在入栈是先入，在出栈是先出的，达到了模拟队列的效果\r\n\r\n\r\n## 代码\r\nJava\r\n```\r\nclass MyQueue {\r\n\r\n    private Stack<Integer> inputStack;\r\n    private Stack<Integer> outputStack;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        inputStack = new Stack<>();\r\n        outputStack = new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        inputStack.push(x);\r\n\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        shift();\r\n        return outputStack.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        shift();\r\n        return outputStack.peek();\r\n\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return inputStack.isEmpty() && outputStack.isEmpty();\r\n    }\r\n\r\n    public void shift() {\r\n        if(outputStack.isEmpty() && !inputStack.isEmpty()) {\r\n            while(!inputStack.isEmpty()) {\r\n                outputStack.push(inputStack.pop());\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度: 均摊复杂度为O(1)\r\n\r\n空间复杂度: O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"CruiseYuGH":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836790900","body":"## 思路\r\n\r\nsum_temp = num[i]+k%10 +temp\r\n分别更新temp 和 num[i]\r\n最后判别下是否有剩余的K or temp\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        temp = 0\r\n        for i in range(len(num)-1,-1,-1):\r\n            if k > 0 or temp>0:\r\n                sum_temp = num[i]+k%10 +temp\r\n                num[i]=sum_temp%10\r\n                temp = sum_temp//10\r\n                k = k//10\r\n        k+=temp\r\n        if k >0 :\r\n            while K:\r\n                num.insert(0,k%10)\r\n                k = k//10\r\n        return num\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838684275","body":"## 思路\r\n找出左右两边距离最近的，再取其中最小的\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        left  = [999 for i in range(len(s))]\r\n        right = [999 for i in range(len(s))]\r\n        for i in range(len(s)):\r\n            #print(i,len(s))\r\n            if s[i]==c:\r\n                left[i]=0\r\n            elif i!=0 and left[i-1]!=999 :\r\n                left[i] = left[i-1]+1\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i]==c:\r\n                right[i]=0\r\n            elif i!=len(s)-1 and right[i+1]!=999 :\r\n                right[i] = right[i+1]+1\r\n        res = [min(right[i],left[i]) for i in range(len(s))]\r\n        return res\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839885468","body":"思路\r\n用列表实现栈\r\n\r\n代码（Python3）\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack)<self.maxSize:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack)>0:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(len(self.stack),k)):\r\n            self.stack[i]+=val\r\n\r\n\r\n复杂度\r\n时间复杂度：push O(1) pop O(1) increment O(k)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840618054","body":"1. 用栈实现括号匹配\r\n给定的字符串可以存储到一个栈中\r\n出栈入栈条件为：\r\n如果非]，就入栈\r\n如果是]，那么就循环出栈，直到找到一个匹配的[\r\n注意数字如果是两位数，需要处理，所以为了方便，我们先把数字解析出来，变成一个元素存储在栈中，这样每次匹配左右括号时，可以直接取左括号的上一位元素进行复制操作即可\r\n代码\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        cur_num = 0\r\n        cur_str=\"\"\r\n        for c in s:\r\n            if c.isdigit():\r\n                cur_num = cur_num*10+int(c)\r\n            elif c is \"[\":\r\n                stack.append(cur_str)\r\n                stack.append(cur_num)\r\n                cur_str = ''\r\n                cur_num = 0\r\n            elif c is \"]\":\r\n                temp_num = stack.pop()\r\n                temp_str = stack.pop()\r\n                cur_str = temp_str + temp_num * cur_str\r\n            else:\r\n                cur_str+=c \r\n        return cur_str              \r\n复杂度分析\r\n令N为字符串长度\r\n\r\n时间复杂度：O(N) 只遍历了字符串一次，所以为线性复杂度\r\n\r\n空间复杂度：O(N) 使用了栈存储，所以为线性复杂度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841296621","body":"## 思路\r\n利用两个队列，来回倒腾\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack = []\r\n        self.help_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stack:\r\n            self.help_stack.append(self.stack.pop())\r\n        self.stack.append(x)\r\n        while self.help_stack:\r\n            self.stack.append(self.help_stack.pop())\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        #print(self.stack)\r\n        if len(self.stack)==0:\r\n            return\r\n        x = self.stack.pop()\r\n        #print(x)\r\n        return x\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        x = self.pop()\r\n        self.help_stack.append(x)\r\n        while self.stack:\r\n            self.help_stack.append(self.stack.pop())\r\n        while self.help_stack:\r\n            self.stack.append(self.help_stack.pop())\r\n        #print(self.stack,self.help_stack)\r\n        return x\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        if len(self.stack)==0:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841680705","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        count = collections.defaultdict(int)\r\n        ans = nonzero = 0\r\n        for x, y in zip(arr, sorted(arr)):\r\n            count[x] += 1\r\n            if count[x] == 0: nonzero -= 1\r\n            if count[x] == 1: nonzero += 1\r\n\r\n            count[y] -= 1\r\n            if count[y] == -1: nonzero += 1\r\n            if count[y] == 0: nonzero -= 1\r\n\r\n            if nonzero == 0: ans += 1\r\n\r\n        return ans\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(n)$\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johanazhu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836791845","body":"## 思路\r\n\r\n#### 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n当前位 = (A 的当前位 + B 的当前位 + 进位) % 10\r\n\r\n注意，AB两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在前面。\r\n\r\n```\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位\r\n    \r\n    // 循环条件调整\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n```\r\n\r\n## 代码\r\n\r\nJavascript\r\n\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    k = k.toString();\r\n    let aLen = num.length, kLen = k.length;\r\n    num.reverse();\r\n    if(aLen > kLen) {\r\n        k = '0'.repeat(aLen - kLen) + k;\r\n    } else if(aLen < kLen) {\r\n        for(let i = 0; i < kLen - aLen; i++) {\r\n            num.push(0);\r\n        }\r\n    }\r\n    k = k.split('').reverse();\r\n    let sum = 0, carry = 0, res = [];\r\n    num.forEach((item, i)=>{\r\n        sum = item + + k[i] + carry;\r\n        carry = parseInt(sum / 10);\r\n        res.push(sum % 10)\r\n    })\r\n    if(carry > 0) {\r\n        res.push(carry)\r\n    }\r\n    return res.reverse();\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(max(n, log(k))\r\n空间复杂度: O(1)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839255302","body":"## 思路\r\n\r\n#### 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/submissions/\r\n\r\n栈是由数组构成，原型中的push、pop是利用数组原有的方法push、pop做封装，而increment则通过传入的参数与栈的长度作对比，大于则给每个元素加上val；小于，则截至到k\r\n\r\n\r\n\r\n## 代码\r\n\r\nJavaScript\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize = maxSize;\r\n    this.stack = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length >= this.maxSize) {\r\n        return \r\n    }\r\n    this.stack.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (this.stack.length === 0) {\r\n        return -1\r\n    }\r\n    return this.stack.pop()\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    if (this.stack.length <= k) {\r\n        for (var i = 0; i < this.stack.length; i++) {\r\n            this.stack[i] += val\r\n        }\r\n    } else {\r\n        for(var i =0; i<k; i++) {\r\n            this.stack[i] += val\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：..\r\n空间复杂度: O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840621336","body":"## 思路\r\n\r\n#### 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n栈，\r\n\r\n如果是遇到的不是“]”，就往栈里压\r\n\r\n如果遇到“]”，就往栈里压“[]”前的数字*“[]”中的字母\r\n\r\n设置重复的数字为repeatCount，重复的字母为repeatStr，如何获取\r\n\r\n\r\n\r\n\r\n\r\n## 代码\r\n\r\nJavaScript\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n      let stack = []; // 保存需要 repeat 的字符串\r\n    let times = ''; // 乘以的倍数\r\n\r\n    for (let i = 0, len = s.length; i < len; i++) {\r\n        let item = s[i];\r\n\r\n        if (/[0-9]/.test(item)) {\r\n            if (i === 0 || /[0-9]/.test(s[i - 1])) {\r\n                times += item;\r\n            } else {\r\n                times = item\r\n            }\r\n        } else if (item === '[') {\r\n            times && stack.push(Number(times));\r\n            times = '';\r\n        } else if (item === ']') {\r\n            var curr = stack.pop();\r\n            var temp = '';\r\n            while (typeof curr !== 'number') {\r\n                temp = curr + temp;\r\n                curr = stack.pop();\r\n            }\r\n            temp = temp.repeat(curr);\r\n            stack.push(temp);\r\n        } else {\r\n            stack.push(item);\r\n        }\r\n    }\r\n    return stack.join('');\r\n\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度: O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840882273","body":"## 思路\r\n\r\n#### 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/submissions/\r\n\r\n注意分析：仅使用两个栈实现先入先出队列。而且使用的是pop和push，没说不能用shift，但估计是不希望我们用\r\n\r\n思考一下其实就是两个壶装水问题\r\n\r\n\r\n\r\n## 代码\r\n\r\nJavaScript\r\n\r\n```javascript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.stack = []\r\n    this.helperStack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    let cur = null;\r\n    // 关键是这步，如果 this.stack 有值，当它 this.stack.pop() 后得到的是出栈的值\r\n    // 当它无值时，cur = undefined，while 退出循环\r\n    while((cur = this.stack.pop())) {\r\n        this.helperStack.push(cur)\r\n    }\r\n    this.helperStack.push(x)\r\n    while((cur = this.helperStack.pop())) {\r\n        this.stack.push(cur)\r\n    }\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.stack.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[this.stack.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack.length === 0\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841569441","body":"## 思路\r\n\r\n#### 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\r\n\r\n不会，看刷题秘籍抄的\r\n\r\n我的理解是 压入的值不能比当前的值小，如果小的话，就循环弹出\r\n\r\n\r\n\r\n## 代码\r\n\r\nJavaScript\r\n\r\n```javascript\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n    var stack = []\r\n    for (var i = 0; i < arr.length; i++) {\r\n        var a = arr[i];\r\n        if (stack.length > 0 && stack[stack.length - 1] > a) {\r\n            const cur = stack[stack.length - 1]\r\n            while(stack && stack[stack.length - 1] > a) stack.pop()\r\n            stack.push(cur)\r\n        } else {\r\n            stack.push(a)\r\n        }\r\n    }\r\n    return stack.length\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841747740","body":"#### 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/rotate-list/\r\n\r\n\r\n\r\n## 思路\r\n\r\n不会，看刷题秘籍抄的\r\n\r\n对于零基础的我来说，算法里还有快慢指针之说，快指针比慢指针走的快一步\r\n\r\n刷了几天题，发现大多数算法里都用到了while\r\n\r\n满足条件时，就在{}执行，不满足时退出，\r\n\r\n牛逼牛逼\r\n\r\n\r\n\r\n## 代码\r\n\r\nJavaScript\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n    if (!head || !head.next) return head;\r\n    let count = 0,\r\n        now = head;\r\n    while(now) {\r\n        now = now.next;\r\n        count++\r\n    }\r\n    k = k % count;\r\n    let slow = (fast = head);\r\n\r\n    while (fast.next) {\r\n        if (k-- <= 0) {\r\n            slow = slow.next\r\n        }\r\n        fast = fast.next\r\n    }\r\n    fast.next = head;\r\n    let res = slow.next;\r\n    slow.next = null;\r\n    return res;\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zengwmFE":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836792060","body":"```\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let target = 0\r\n    let sum = 0\r\n    for(let i=num.length-1;i>=0;i--){\r\n        sum = num[i]+k%10+target \r\n        num[i] = sum%10\r\n        target = Math.floor(sum/10)   \r\n         k = Math.floor(k/10)\r\n\r\n    }\r\n    k = target + Number(k)\r\n    if(k){\r\n        let str = String(k)\r\n        for(let i=str.length-1;i>=0;i--){\r\n            num.unshift(str[i])\r\n        }\r\n    }\r\n    return num\r\n};\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838635265","body":"[题解同步到leetcode](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/liang-duan-xun-huan-que-ding-ju-chi-by-z-iryn/)\r\n自己写写思路，希望下次不要忘了，91奥利给\r\n## 思路\r\n令当前起始值为-1，如果第一个值\r\n这里采用，左右两端分别进行循环\r\n这里的关键在于如何处理匹配`c`之后的值：\r\n\r\n> 从右往左循环，可以拿到值离右边最近的`c`的距离\r\n> 如果当前这个值`s[i]`恰好等于`c`的时候，那么这个地方的pos[i] = 0，当然如果当前这个值之前还没有发现有`c`的存在的时候，这个时候，咱也不晓得（🤷‍♂️）这值是啥啊，那就可以先跳过这个位置：**即保留-1的状态值**，当找到了这个值的时候，就拿个东东（current）标识一哈：**current=i**，老铁开始出现了，那么就可以着手去更改位置的值了，那么这个位置是什么呢:?令i=2,current=1,距离是:高减低`current-i`.这样就得出了一个位置表达式\r\n\r\n> 从左往右循环，可以拿到值离左边最近的`c`的距离，一开始需要填填之前没有找到位置的地方，给他填好值吧，然后操作基本跟从右往左是一致的，但是距离表达式为**高减低`i-current`**，而且当遇到不为`-1`值的时候，我们需要判断两者的距离位置，最后肯定是要取一个小小的值！\r\n\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let len = s.length\r\n    let pos = new Array(len).fill(-1)\r\n    let current = -1\r\n    for(let i=len-1;i>=0;i--){\r\n        if(s[i] == c){\r\n            current = i\r\n            pos[i] = 0\r\n        }\r\n        if(current!==-1){\r\n            pos[i] = current-i\r\n        }\r\n\r\n    }\r\n    current = -1\r\n    for(let i=0;i<len;i++){\r\n        if(pos[i]===-1){\r\n            pos[i] = i-current\r\n        }\r\n        if(current!==-1){\r\n            pos[i] = Math.min(i-current,pos[i])\r\n        }\r\n        if(s[i]===c){\r\n            current = i\r\n        }\r\n    }\r\n    return pos\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838635265","body":"[题解同步到leetcode](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/liang-duan-xun-huan-que-ding-ju-chi-by-z-iryn/)\r\n自己写写思路，希望下次不要忘了，91奥利给\r\n## 思路\r\n令当前起始值为-1，如果第一个值\r\n这里采用，左右两端分别进行循环\r\n这里的关键在于如何处理匹配`c`之后的值：\r\n\r\n> 从右往左循环，可以拿到值离右边最近的`c`的距离\r\n> 如果当前这个值`s[i]`恰好等于`c`的时候，那么这个地方的pos[i] = 0，当然如果当前这个值之前还没有发现有`c`的存在的时候，这个时候，咱也不晓得（🤷‍♂️）这值是啥啊，那就可以先跳过这个位置：**即保留-1的状态值**，当找到了这个值的时候，就拿个东东（current）标识一哈：**current=i**，老铁开始出现了，那么就可以着手去更改位置的值了，那么这个位置是什么呢:?令i=2,current=1,距离是:高减低`current-i`.这样就得出了一个位置表达式\r\n\r\n> 从左往右循环，可以拿到值离左边最近的`c`的距离，一开始需要填填之前没有找到位置的地方，给他填好值吧，然后操作基本跟从右往左是一致的，但是距离表达式为**高减低`i-current`**，而且当遇到不为`-1`值的时候，我们需要判断两者的距离位置，最后肯定是要取一个小小的值！\r\n\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let len = s.length\r\n    let pos = new Array(len).fill(-1)\r\n    let current = -1\r\n    for(let i=len-1;i>=0;i--){\r\n        if(s[i] == c){\r\n            current = i\r\n            pos[i] = 0\r\n        }\r\n        if(current!==-1){\r\n            pos[i] = current-i\r\n        }\r\n\r\n    }\r\n    current = -1\r\n    for(let i=0;i<len;i++){\r\n        if(pos[i]===-1){\r\n            pos[i] = i-current\r\n        }\r\n        if(current!==-1){\r\n            pos[i] = Math.min(i-current,pos[i])\r\n        }\r\n        if(s[i]===c){\r\n            current = i\r\n        }\r\n    }\r\n    return pos\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840604606","body":"### 辅助栈法：\r\n思路：\r\n1. 数字首先需要单独取出来  要记住这个地方不是单独取一个，因为可能是10位也可能是百位\r\n2. 然后是`[`,先分析一下这个位置的，有什么内容，我们得到了一串数字，以及上一个集合留下的字符串res,以及`[`前的数字num\r\n     - 如果遇到了`[`，需要做的就是将字符串和数字入栈\r\n     - 同时清空这个字符串，可以避免和下次的重叠，同时将数字置为0\r\n3. 接着`]`，遇到这个内容，很明显就是已经把当前有效的字符都加完了，剩下的事就是按照这串文字前面的数字重复得到真正的明文res，那么这个值在哪？**栈顶**，因为很明显，`[`，肯定是立马有一个对应`]`，不管是`[[]]`还是`[]`，总有一个`[`对应着一个`]`,这个时候刚放进的，肯定是对应我们新的`]`，将栈顶出栈，res.repeat(pop[1])，这个就是我们这一次有效字符的真正解了，然后当然需要将我们之前一部分的有效集合接起来，即：`pop[0]+res.repeat(pop[1])`这样就是一个有效集合如：`a3[b]`的真正的解\r\n4. 最后处理正常的字符直接连接起来\r\n```\r\n let num = 0\r\n    let list = []\r\n    let res = ''\r\n    for(let i=0;i<s.length;i++){\r\n        if(/\\d/.test(s[i])){\r\n            // 数字\r\n            num = num*10+Number(s[i])\r\n            continue\r\n        }\r\n        if(s[i]==='['){\r\n            list.push([res,num])\r\n            res = '',num=0\r\n        }else if(s[i]===']'){\r\n            let top = list.pop()\r\n            res = top[0] + res.repeat(top[1])\r\n            \r\n        }else{\r\n            res += s[i]\r\n        }\r\n    }\r\n    return res\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n### 深度优先遍历\r\n思路：\r\n1. 首先对于数字的处理跟辅助栈是一样的\r\n2. 对`[`进行处理，这个时候标志了一个集合的开始，那么我们就可以从`i+1`的位置开始进行递归，而递归返回的就是这次有效集合的`res`和下次开始的位置，res+=temp.repeat(num)，同时从下一个位置继续循环\r\n3. 对`]`进行处理，这个标志了一个集合的结束，我们得到的`res`就是我们这一次所有的内容，记录结束位置，将[res,i]返回\r\n4.对普通字符处理同上\r\n```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let dfs = function(s,index){\r\n        let res = '',num=0\r\n           while(index<s.length){\r\n               if(/\\d/.test(s[index])){\r\n                   num = num*10+Number(s[index])\r\n               }else if(s[index]==='['){\r\n                   let [temp,i] = dfs(s,index+1)\r\n                   res+=temp.repeat(num)\r\n                   index = i\r\n                   num = 0\r\n               }else if(s[index]===']'){\r\n                   return [res,index]\r\n               }else{\r\n                   res+=s[index]\r\n               }\r\n               index++\r\n           }  \r\n        return res\r\n    }\r\n    return dfs(s,0)\r\n};\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841679248","body":"```\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n    let current = [...arr].sort((a,b)=>a-b)\r\n    let sum0=0,sum1=0;\r\n    let sum = 0\r\n    let len = current.length;\r\n    for(let i=0;i<len;i++){\r\n        sum0+=current[i]\r\n        sum1+=arr[i]\r\n        if(sum0===sum1){\r\n            sum++\r\n        }\r\n    }\r\n    return sum\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dorothyDing":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836793890","body":"javascript\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    let numStr = num.join('')\r\n    let maxLength = Math.max(numStr.length, k.toString().length)\r\n    numArr = numStr.padStart(maxLength, '0').split('').reverse()\r\n    kArr = k.toString().padStart(maxLength, '0').split('').reverse()\r\n    let flag = 0\r\n    for(let i = 0; i < maxLength; i++) {\r\n        let sum = Number(numArr[i]) + Number(kArr[i]) + flag\r\n        if (sum >= 10) {\r\n            flag = 1\r\n            sum -= 10\r\n        } else {\r\n            flag = 0\r\n        }\r\n        numArr[i] = sum\r\n    }\r\n    if (flag) {\r\n        numArr.push(flag)\r\n    }\r\n    return numArr.reverse().map(i => Number(i))\r\n};\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度:  O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838686757","body":"javascript\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let indexs = s.split('').map((item, index) => item === c ? index : null).filter(item => item != null)\r\n    return s.split('').map((_, index) => Math.min(...indexs.map(i => Math.abs(i - index))))\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839886372","body":"```js\r\nvar CustomStack = function(maxSize) {\r\n    s = []\r\n    t=0\r\n    n = maxSize\r\n};\r\nCustomStack.prototype.push = function(x) {\r\n    if(t<n) s[++t]=x\r\n    return s\r\n\r\n};\r\nCustomStack.prototype.pop = function() {\r\n    if(t)return s[t--]\r\n    return -1\r\n};\r\nCustomStack.prototype.increment = function(k, val) {\r\n    while(k) s[k--]+=val\r\n\r\n};\r\n```"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841682291","body":"javascript\r\n```js\r\n// 滑动窗口\r\nvar maxChunksToSorted = function(arr) {\r\n    let arrSorted = [...arr]\r\n    arrSorted.sort((a, b) => a - b)\r\n    let sum1 = 0\r\n    let sum2 = 0\r\n    let count = 0\r\n    for(let i = 0; i < arr.length; i++) {\r\n        sum1 += arr[i]\r\n        sum2 += arrSorted[i]\r\n        if (sum1 == sum2) {\r\n            count ++\r\n        }\r\n    }\r\n\r\n    return count\r\n};\r\n```\r\n\r\n复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841762669","body":"javascript\r\n```js\r\nvar rotateRight = function(head, k) {\r\n    if (k === 0 || !head || !head.next) {\r\n        return head;\r\n    }\r\n    let n = 1;\r\n    let cur = head;\r\n    while (cur.next) {\r\n        cur = cur.next;\r\n        n++;\r\n    }\r\n\r\n    let add = n - k % n;\r\n    if (add === n) {\r\n        return head;\r\n    }\r\n\r\n    cur.next = head;\r\n    while (add) {\r\n        cur = cur.next;\r\n        add--;\r\n    }\r\n\r\n    const ret = cur.next;\r\n    cur.next = null;\r\n    return ret;\r\n};\r\n```\r\n复杂度分析\r\n- 时间复杂度O(n)\r\n- 空间复杂度O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mittacy":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836795620","body":"### 思路\r\n\r\n从后往前遍历num，和k进行加法运算并进位，每次存入数组(该数组是从低位往高位存储的)，直到k=0，最后反转数组\r\n\r\n### 代码\r\n\r\n\r\n```go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n    ans := make([]int, 0)\r\n    for i := len(num) - 1; i >= 0 || k > 0; i-- {\r\n        if i >= 0 {\r\n            k += num[i]\r\n        }\r\n        ans = append(ans, k%10)\r\n        k /= 10\r\n    }\r\n\r\n    i, j := 0, len(ans)-1\r\n    for i < j {\r\n        ans[i], ans[j] = ans[j], ans[i]\r\n        i++\r\n        j--\r\n    }\r\n    return ans\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(max(N, logk))，其中 N 为数组长度。(k / 10^n = 1 => logk)\r\n- 空间复杂度：O(1)，除了返回值为数组外，其他都为常量\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838160036","body":"### 思路\r\n\r\n两端遍历\r\n1. 从前往后，res[curIndex] = curIndex - newTargetIndex\r\n2. 从后往前，res[curIndex] = min(res[curIndex], newTargetIndex-curIndex)\r\n其中，newTargetIndex为目标字符最新出现索引位置\r\n\r\n### 代码\r\n\r\n\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    res := make([]int, len(s))\r\n    // 1<=s.length<=10000, targetIndex-10000<0, 所以应该设置targetIndex为-10000\r\n    targetIndex := -10000\r\n    for i := 0; i < len(s); i++ {\r\n        if s[i] == c {\r\n            targetIndex = i\r\n        }\r\n        res[i] = i - targetIndex\r\n    }\r\n\r\n    // 1<=s.length<=10000, targetIndex-10000>10000, 所以应该设置targetIndex为20000\r\n    targetIndex = 20000 \r\n    for i := len(s)-1; i >= 0; i-- {\r\n        if s[i] == c {\r\n            targetIndex = i\r\n        }\r\n        res[i] = min(res[i], targetIndex - i)\r\n    }\r\n    return res\r\n}\r\n\r\nfunc min(i, j int) int {\r\n    if i < j {\r\n        return i\r\n    }\r\n    return j\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串s的长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839715318","body":"### 思路\r\n\r\n创建一个数组作为栈存储数据，使用i和size字段分别表示当前存储到的位置以及栈的容量\r\n\r\n```go\r\ntype CustomStack struct {\r\n    val []int\r\n    size int\r\n    i int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    return CustomStack{\r\n        val: make([]int, maxSize),\r\n        size: maxSize,\r\n        i: 0,\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if this.i >= this.size {\r\n        return\r\n    }\r\n    this.val[this.i] = x\r\n    this.i++\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Pop() (res int) {\r\n    if this.i == 0 {\r\n        return -1\r\n    }\r\n    this.i--\r\n    res = this.val[this.i]\r\n    return\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    if k > this.size {\r\n        k = this.size\r\n    }\r\n    for cur := 0; cur < k; cur++ {\r\n        this.val[cur] += val\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push、pop:O(1)，Increment: O(k)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840640798","body":"### 思路\r\n1. 建立栈，遍历字符串往栈内添加字符\r\n2. 如果字符为 ] , 出栈直到找到 [ ,再取数字, 处理字符放回栈中\r\n3. 最后栈即为结果字符串\r\n\r\n### 代码\r\n\r\n```go\r\nfunc decodeString(s string) string {\r\n\tres := Stack{}\r\n\tsByte := []byte(s)\r\n\r\n\tfor _, v := range sByte {\r\n\t\tif v != ']' {\r\n\t\t\tres.Push(v)\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\trepeatStr := \"\"\r\n\t\trepeatCount := \"\"\r\n\t\tfor !res.Empty() && res.Top() != '[' {\r\n\t\t\trepeatStr = string(res.Pop()) + repeatStr\r\n\t\t}\r\n\r\n\t\tres.Pop()\r\n\r\n\t\tfor !res.Empty() && res.Top() >= '0' && res.Top() <= '9' {\r\n\t\t\trepeatCount = string(res.Pop()) + repeatCount\r\n\t\t}\r\n\t\tcount, _ := strconv.Atoi(repeatCount)\r\n\t\ttmp := \"\"\r\n\t\tfor count > 0 {\r\n\t\t\ttmp += repeatStr\r\n\t\t\tcount--\r\n\t\t}\r\n\r\n\t\tres.PushSlice([]byte(tmp))\r\n\t}\r\n\treturn string(res.Val())\r\n}\r\n\r\ntype Stack struct {\r\n\tval []byte\r\n}\r\n\r\nfunc (s *Stack) Val() []byte {\r\n\treturn s.val\r\n}\r\n\r\nfunc (s *Stack) PushSlice(b []byte) {\r\n\ts.val = append(s.val, b...)\r\n}\r\n\r\nfunc (s *Stack) Push(b byte) {\r\n\ts.val = append(s.val, b)\r\n}\r\n\r\nfunc (s *Stack) Pop() byte {\r\n\tb := s.val[len(s.val)-1]\r\n\ts.val = s.val[:len(s.val)-1]\r\n\treturn b\r\n}\r\n\r\nfunc (s *Stack) Top() byte {\r\n\treturn s.val[len(s.val)-1]\r\n}\r\n\r\nfunc (s *Stack) Empty() bool {\r\n\treturn len(s.val) == 0\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 为解码后 s 的长度\r\n- 空间复杂度：O(N)，其中 N 为解码后 s 的长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841332718","body":"### 思路\r\n在结构体内有个栈，一个用来push入队，另一个用来实现 peek 和 pop 出队\r\n+ push：把元素直接插入val栈尾部\r\n+ pop / peek：检查 top 栈是否为空，为空则需要把 val 栈依次出栈、入栈到 top 栈，然后取栈顶元素返回\r\n+ empty：top 栈 和 val 栈 都为空返回 true，否则返回 false\r\n\r\n### 代码\r\n```go\r\ntype MyQueue struct {\r\n    val []int\r\n    top []int\r\n}\r\n\r\n\r\n/** Initialize your data structure here. */\r\nfunc Constructor() MyQueue {\r\n    return MyQueue{\r\n        val: make([]int, 0),\r\n        top: make([]int, 0),\r\n    }\r\n}\r\n\r\n\r\n/** Push element x to the back of queue. */\r\nfunc (this *MyQueue) Push(x int)  {\r\n    this.val = append(this.val, x)\r\n}\r\n\r\n\r\n/** Removes the element from in front of queue and returns that element. */\r\nfunc (this *MyQueue) Pop() int {\r\n    if len(this.top) == 0 {\r\n        for len(this.val) > 0 {\r\n            this.top = append(this.top, this.val[len(this.val)-1])\r\n            this.val = this.val[:len(this.val)-1]\r\n        }\r\n    }\r\n    val := this.top[len(this.top)-1]\r\n    this.top = this.top[:len(this.top)-1]\r\n    return val\r\n}\r\n\r\n\r\n/** Get the front element. */\r\nfunc (this *MyQueue) Peek() int {\r\n    if len(this.top) == 0 {\r\n        for len(this.val) > 0 {\r\n            this.top = append(this.top, this.val[len(this.val)-1])\r\n            this.val = this.val[:len(this.val)-1]\r\n        }\r\n    }\r\n    return this.top[len(this.top)-1]\r\n}\r\n\r\n\r\n/** Returns whether the queue is empty. */\r\nfunc (this *MyQueue) Empty() bool {\r\n    return len(this.val) == 0 && len(this.top) == 0\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push、empty都为O(1)，pop 和 peek 均摊 O(1)。\r\n- 空间复杂度：O(N)，N是操作总数"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841665969","body":"### 思路\r\n\r\n（此处撰写思路）\r\n\r\n### 代码\r\n\r\n```go\r\nfunc maxChunksToSorted(arr []int) int {\r\n    stack := make([]int, 0)\r\n\r\n    for _, v := range arr {\r\n        if len(stack) > 0 && v < stack[len(stack)-1] {\r\n            head := stack[len(stack)-1]\r\n            stack = stack[:len(stack)-1]\r\n            for len(stack) > 0 && v < stack[len(stack)-1] {\r\n                stack = stack[:len(stack)-1]\r\n            }\r\n            stack = append(stack, head)\r\n        } else {\r\n            stack = append(stack, v)\r\n        }\r\n    }\r\n    return len(stack)\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为 arr 长度\r\n- 空间复杂度：O(N)，使用了栈\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yourspeace":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836797246","body":"语言：Java\r\n\r\n思路：leetcode官方题解的思路：数组和数字最后一位从后往前，对应的位相加，如果产生进位，数字k加1，这样就会在下一位中运 算了，最后如果数字k的长度大于数组的长度，那么就把数字k剩下的进行取余取整操作，加到目标数组中，最后数组反转得到结果\r\n\r\n代码：\r\n\r\n`class Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        // 初始化参数\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = A.length;\r\n\r\n        // 1. 从后往前逐位相加\r\n        for(int i = n - 1;i >= 0;i--){\r\n            // 1.1 逐位相加\r\n            int sum = A[i] + K % 10;         // 每次重置sum\r\n            K /= 10;    \r\n            // 1.2 处理两位相加 进位的情况\r\n            if(sum >= 10){\r\n                K++;                        // 进位到K的末尾\r\n                sum -= 10;                  // 进位清掉\r\n            }\r\n            // 1.2 当前相加的结果 添加到结果集\r\n            res.add(sum);\r\n        }\r\n\r\n        // 2. K的数字长度大于数组的数字长度\r\n        for(;K > 0;K /= 10){                // 每次K左移一位\r\n            res.add(K % 10);                // 添加到结果集\r\n        }\r\n\r\n        // 3. 将结果集翻转即是所求答案\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}`\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838563251","body":"**语言：** Java\r\n\r\n**leetcode官方题解思想：**\r\n\r\n从前往后遍历一遍，记住各个位置离上一个C字符的距离，再从后往前遍历一遍，同样记住离上一个C字符的距离，最后比较两次遍历各个位置离C字符的距离，较小的那个被选用做为最终距离\r\n\r\n**复杂度：**\r\n\r\n时间：O(N)\r\n\r\n空间：O(N) \r\n\r\n**代码：**\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839798463","body":"**java**\r\n**leetcode官方题解：**用数组模拟，方便除了栈顶的其他值都可以看到，然后就可以实现底部k个值增加val\r\n```\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841215925","body":"**python**\r\n设置一个主栈 一个辅助栈\r\n**时间**O（n）每次push操作需要移动n个元素\r\n**空间**O（n）额外开辟了一个辅助栈空间\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack = []\r\n        self.help_stack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stack:\r\n            self.help_stack.append(self.stack.pop())\r\n        self.help_stack.append(x)\r\n        while self.help_stack:\r\n            self.stack.append(self.help_stack.pop())\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.stack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.stack)\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"paopaohua":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836797976","body":"思路：\n  1、从数组最后一位向前遍历，进行相加，考虑进位操作\n  2、考虑进位超出当前长度的操作\n  3、输出结果进行翻转 collections.reverse（res）\n代码：\n```\npublic List<Integer> addToArrayForm(int[] A, int K) {\n    List<Integer> res = new ArrayList<>();\n    int carry = 0;\n    int l1 = A.length - 1;\n    while (l1 >= 0 || K != 0) {\n        int x = l1 < 0 ? 0 : A[l1];\n        int y = K == 0 ? 0 : K % 10;\n\n        int sum = x + y + carry;\n        res.add(sum % 10);\n        carry = sum / 10;\n\n        l1--;\n        K = K / 10;\n    }\n    if (carry != 0) res.add(carry);\n    Collections.reverse(res);\n    return res;\n}\n\n```\n复杂度分析：（不懂）\n    时间复杂度：Ｏ（n）\n    空间复杂度：Ｏ（n）\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838694006","body":"思路：\n   从左向右遍历，记录字符c出现的位置p，距离为i-p\n   从右向左遍历，记录字符c出现的位置p，距离为p-i\n   得较小值\n代码：\n```\n\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;//防止越界\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);//判断最小值\n        }\n\n        return ans;\n    }\n}\n\n\n```\n复杂度分析：\n   时间复杂度：Ｏ（n）\n   空间复杂度：Ｏ（n）数组 ans 的大小"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839873718","body":"#\t思路\n\t（官方解法）用数组模拟栈 用变量top记录栈顶位置\n#\t代码\n```\n\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n\n\n```\n#\t复杂度分析\n*\t时间复杂度：Ｏ（1）  inc操作为Ｏ（K）\n*\t空间复杂度：Ｏ（maxSize）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840632691","body":"#\t思路（官方解法）\n\t1.将括号嵌套转化成 用栈维护 \n\t2.遍历栈 \n当前字符为数位，解析数字并进栈\n字母或者左括号，直接进\n右括号，开始出栈直到左括号出栈，反转拼接为字符串取栈顶数字\n#\t代码 \n```\n\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                // 获取一个数字并进栈\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                // 左括号出栈\n                stk.removeLast();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                // 构造字符串\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                // 将构造好的字符串入栈\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n\n\n```\n\n#\t复杂度分析\n*\t时间复杂度：Ｏ（s） 字符串长度为s\n*\t空间复杂度：Ｏ（s）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841324701","body":"#\t思路\n一个输入栈 push传入的数据\n一个栈做输出栈，用于pop和peek操作\n进行pop、peek时，若为空输出栈弹出全部数据并压入输出栈\n#\t代码\n```\n\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new LinkedList<Integer>();\n        outStack = new LinkedList<Integer>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}\n\n\n```\n#\t复杂度分析\n时间复杂度：Ｏ（1）\n空间复杂度：Ｏ（n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841678790","body":"#\t思路\n贪心算法找到最边开始最小的块\n#\t代码\n```\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0, nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i], y = expect[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) nonzero--;\n            if (count.get(x) == 1) nonzero++;\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) nonzero++;\n            if (count.get(y) == 0) nonzero--;\n\n            if (nonzero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n\n```\n#\t复杂度分析\n时间复杂度：Ｏ（NlogN）\n空间复杂度：Ｏ（N）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Auto-SK":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836800746","body":"## 方法一：逐位相加\r\n\r\n**当前位 = (A 的当前位 + B 的当前位 + 进位 carry) % 10**\r\n\r\n### 算法流程\r\n\r\n```\r\nwhile A 没完 or B 没完\r\n\tA 的当前位\r\n\tB 的当前位 (B % 10)\r\n\r\n\t和 = A 的当前位 + B 的当前位 + 进位 carry\r\n\t进位 = 和 // 10\r\n\r\n\t当前结果位 = 和 % 10\r\n判断还有进位吗\r\n反转数组\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(max(len(num), len(k)))\r\n* 空间复杂度：O(1)\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = len(num) - 1\r\n        sum = 0\r\n        carry = 0\r\n        res = []\r\n        while i >= 0 or k != 0:\r\n            x = num[i] if i >= 0 else 0\r\n            y = k % 10 if k != 0 else 0\r\n            sum = x + y + carry\r\n            carry = sum // 10\r\n\r\n            i -= 1\r\n            k //= 10\r\n\r\n            res.append(sum % 10)\r\n        \r\n        if carry != 0:\r\n            res.append(carry)\r\n        return res[::-1]\r\n```\r\n\r\n\r\n## 方法二：转换+逐位取出\r\n\r\n### 算法流程\r\n\r\n1. 逐位取 num，将其转为字符串\r\n2. 将 num 字符串转为整数\r\n3. 求出 num 和 k 之和 sum\r\n4. 逐位取 sum % 10，sum = sum // 10\r\n5. 反转，res[::-1]\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)\r\n* 空间复杂度：O(1)\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        x = ''\r\n        for i in num:\r\n            x += str(i)\r\n        x = int(x)\r\n        res = x + k\r\n        if res == 0:\r\n            return [0]\r\n        ans = []\r\n        while res != 0:\r\n            ans.append(res % 10)\r\n            res = res // 10\r\n        return ans[::-1]\r\n```\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838717787","body":"## 方法一：两次扫描\r\n\r\n### 算法流程\r\n\r\n从左向右遍历，记录上一个字符 `c` 出现的位置 `prev`，那么答案就是 `i - prev`。\r\n\r\n从右向左遍历，记录上一个字符 `c` 出现的位置 `prev`，那么答案就是 `prev - i`。\r\n\r\n这两个值取最小就是答案。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)，s 数组的长度。\r\n* 空间复杂度：O(n)，ans 数组的大小。\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        prev = float('-inf')\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans.append(i - prev)\r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839886268","body":"## 方法一：增量数组\r\n\r\n### 算法流程\r\n\r\n用数组模拟栈，`stack`用来存储栈的元素，`add`用来存储增量。当调用`pop`和`increment`方法时，改变`add`数组的元素。\r\n\r\n* 当`pop`时，若操作后，栈不为空，`add[-1]`加上上一个`add[-1]`；\r\n* 当`increment`时，如果栈为空，不操作；若 k > 栈长，add[-1] += val；若 k < 栈长，add[k - 1] += val。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(1)\r\n* 空间复杂度：O(maxSize)\r\n\r\n### 代码\r\n\r\n``` python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.length = 0\r\n        self.max_length = maxSize\r\n        self.stack = []\r\n        self.add = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.length < self.max_length:\r\n            self.stack.append(x)\r\n            self.add.append(0)\r\n            self.length += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.length == 0:\r\n            return -1\r\n        s = self.stack.pop()\r\n        a = self.add.pop()\r\n        self.length -= 1\r\n        if self.length > 0:\r\n            self.add[-1] += a\r\n        return s + a\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.length == 0:\r\n            return\r\n        elif self.length < k:\r\n            self.add[-1] += val\r\n        else:\r\n            self.add[k - 1] += val\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840627801","body":"## 方法一：辅助栈法\r\n\r\n本题难点在于括号内嵌套括号，需要**从内向外**生成与拼接字符串，这与栈的**先入后出**特性相应。\r\n\r\n### 算法流程\r\n\r\n1. 构建辅助栈`stack`，遍历字符串`s`中每个字符`c`；\r\n   * 当`c`为数字时，将数字字符转换为数字`multi`，用于后续倍数计算；\r\n   * 当`c`为字母时，在`res`尾部添加`c`；\r\n   * 当`c`为`[`时，将当前的`multi`和`res`入栈，并分别置空置0：\r\n     * 记录此`[`前的临时结果`res`至栈，用于发现对应`]`后的拼接操作；\r\n     * 记录此`[`前的倍数`multi`至栈，用于发现对应`]`后，获取`multi * [...]`字符串；\r\n     * 进入到新`[`后，`res`和`multi`重新记录。\r\n   * 当`c`为`]`时，`stack`出栈，拼接字符串`res=last_res + cur_multi * res`，其中：\r\n       * `last_res`是上个`[`到当前`]`的字符串，例如`3[a2[c]]`中的`a`；\r\n       * `cur_multi`是当前`[`到`]`内字符串的重复倍数，例如`3[a2[c]]`中的`2`；\r\n2. 返回字符串`res`。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(N)，一次遍历`s`；\r\n* 空间复杂度：辅助栈在极端情况下需要线性空间，例如`2[2[2[a]]]`。\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], '', 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = '', 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif c.isdigit():\r\n                multi = multi * 10 + int(c)\r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841315408","body":"## 方法一：用两个栈模拟队列\r\n\r\n### 算法流程\r\n\r\n栈是一种**后进先出** (last in - first out, LIFO) 的数据结构，元素从栈顶压入，也从栈顶弹出。\r\n\r\n队列是一种**先进先出** (first in - first out, FIFO) 的数据结构，元素从队尾入队，从队头出队。\r\n\r\n栈的**后进先出**特性相当于“逆转”了队列**先进先出**的效果，所以为了实现队列，我们需要使用两个栈，经过两次 “逆转” 满足队列的正常操作顺序。\r\n\r\n不妨设两个栈分别为 a, b，我们 使用 a 的栈顶模拟队尾，使用 b 的栈顶模拟队头 。为了保证结果的正确性，我们需要在每一次操作后都将所有元素保存在其中一个栈内（否则若分散在两个栈内，进行下一步操作后一定会改变元素顺序，就无法模拟队列的**先进先出**特性了）。\r\n\r\n我们不妨将所有元素都时刻保存在栈 b 中，也即任何操作过后，要保证全部元素保存在栈 b 中。需要模拟的操作如下：\r\n\r\n模拟元素“入队”时，要从队尾入队，也即要压入栈 a，但在此之前要先把栈 b 中的所有元素放入 a 中，压栈后再将 a 中元素再放回 b 中；\r\n\r\n模拟元素“出队”时，要从队头出队，也即从 b 的栈顶弹出元素。\r\n\r\n模拟 top/pop 操作时，类似元素“出队”操作，由于全部元素时刻保存在栈 b 中，所以只需对栈 b 进行取栈顶操作或弹出栈顶元素操作即可。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(1)\r\n* 空间复杂度：O(n)\r\n\r\n### 代码\r\n\r\n``` python\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.a = []\r\n        self.b = []\r\n\r\n    def push(self, x: int) -> None:\r\n        while self.b:\r\n            self.a.append(self.b.pop())\r\n        self.a.append(x)\r\n        while self.a:\r\n            self.b.append(self.a.pop())\r\n\r\n    def pop(self) -> int:\r\n        return self.b.pop()\r\n\r\n    def peek(self) -> int:\r\n        return self.b[-1] \r\n\r\n\r\n    def empty(self) -> bool:\r\n        return len(self.b) == 0\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841630954","body":"## 方法一：\r\n\r\n### 算法流程\r\n\r\n* **排序块定义**：\r\n    * **排序块** 充分条件： 设此块中最大数字为`headhead`, 若此块后面的所有数字都`>= head`，则此块为排序块。\r\n    * **排序块** 最短长度为 1，即单个元素可以独立看作一个排序块。\r\n\r\n* **贪心法则**（划分出尽可能多的排序块）：\r\n    * 思路一：\r\n        * 设定双指针指向数组头部，判断双指针内数字集合形成的块是否满足排序块条件，并尽量使窗口最小（贪心）。\r\n        * 每次形成排序块时计数，并越过此排序块重新指定双指针位置，重复以上步骤直到划分完整个数组。\r\n        * 此思路容易理解，但每次确定 1 个块都需要遍历整个数组，在某些极端情况（例如 [1,2,3,4,5]）时间复杂度达到 O(N^2) 。\r\n    * 思路二（本题解采用）：\r\n        * 判断是否是排序块只需要用到该块的 **元素最大值**`head`。我们联想到，是否可以遍历一遍数组`arr`，动态判断到目前数字`num`为止最多能分出多少排序块，并保存每个排序块的最大值`head`。每遍历到下个数字`num`，动态判断前面所有的排序块是否成立，并更新所有排序块：\r\n            * 当某排序块`num < head`：将此排序块`[A]`与`num`合并，形成新排序块`[A | num]`，最大值仍未`head`；\r\n            * 当某排序块`num >= head`：原排序块保留，并新加排序块`[num]`。\r\n        * 而对于整个数组的排序块，其`head`大小是从左到右递增的。例如：数组`[1, 2, 1, 3, 4, 7, 5, 6]`最多可划分为`[1|2, 1|3|4|7, 5, 6]`。因此，若给数组尾部加入一个随机正整数`n`，尾部的排序块更容易被合并（最先满足`num < head`）。当`n`值较小时（`< 前面多个排序块的 head`），则需按尾部到首部的顺序合并多个排序块。\r\n        * 这种先入（首部到尾部添加排序块）后出（尾部到首部判断并合并排序块）的特性，让我们联想到使用 **栈** 保存排序块最大值`head`。在遍历过程中，通过维护栈的`head`序列，实现排序块的动态更新。\r\n* 算法流程：\r\n    1. 遍历数组`arr`中的每个数字`num`；\r\n    2. 当栈 `stack`不为空且数字`num < 栈顶值`时：（代表此`num`会改变前面排序块分布）\r\n        * 栈顶`pop()`出栈，并保存栈顶值为`head`。（此情况下，新排序块最大值还为`head`，因此先暂存）\r\n        * 当`stack`不为空且数字`num < 栈顶值`时，循环栈顶`pop()`出栈。（判断加入`num`需要合并的所有排序块，每`pop()`一个`head`代表合并一个块）\r\n        * 将保存的栈顶值`head`重新`push()`入栈。（将`head`重新加入，作为新排序块的最大值）\r\n    3. 当栈`stack`为空或数字`num >= 栈顶值`时：（代表此`num`不影响前面排序块分布）\r\n        * 将`num`数字`push()`入栈。（加入单个元素的新排序块`[num]`）\r\n    4. 遍历完成后，栈中保存 **所有排序块的对应最大值`head`**，因此返回栈`stack`长度即可获得排序块数量。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(N)，遍历一遍`arr`为 O(N)，修正排序块最多遍历一遍`arr`为 O(N)；\r\n* 空间复杂度：O(N)，极端情况下排序块数量等于数组长度，此时`stack`占用线性大小额外空间。\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n```\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuanaxuan":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836802914","body":"### 思路\r\n\r\n#### 模板\r\n```\r\n当前位=0\r\nwhile ( A 没完 || B 没完)\r\n    //根据下标找到\r\n    A 的当前位\r\n    B 的当前位\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗,进位不为 0 ,加在目标值前面。\r\n```\r\n#### 注意点\r\n1. 循环结束条件\r\n2. 当前位的计算,注意防空\r\n3. 和的计算,carry初始值为0\r\n4. js中取整/后要转整数\r\n  \r\n### 代码\r\n\r\n```js\r\nvar addToArrayForm = function (num, k) {\r\n  let i = num.length - 1,\r\n    carry = 0,\r\n    arr = [];\r\n  while (i >= 0 || k > 0) {\r\n    let n = i>=0 ? num[i] : 0;\r\n    let m = k != 0 ? k % 10 : 0;\r\n    let sum = n + m + carry;\r\n    carry = parseInt(sum / 10);\r\n    arr.unshift(sum % 10);\r\n    i--;\r\n    k = parseInt(k / 10);\r\n  }\r\n  if (carry) arr.unshift(1);\r\n  return arr;\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度:`O(n)` \r\n空间复杂度:`O(n)`\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838288784","body":"### 思路\r\n用变量prevC记录c的下标,初始值为无穷大,当s[i]=c时更新preC=i\r\n遍历字符串,将非c的字符串存入临时栈中,当遇到c时,依次计算栈中字符串到当前c以及prevC的最小距离,注意针对C非S最后一个字符串的情况,需要再清空下临时栈\r\n### 复杂度\r\n时间复杂度：$O(N)$, N 为S数组长度。\r\n空间复杂度：$O(N)$, N 为S数组长度。\r\n### 代码\r\n```\r\nvar shortestToChar = function (S, C) {\r\n  let arr = [],\r\n    prevC = -Infinity,\r\n    map = [];\r\n  //清空暂存栈\r\n  function clear(prev, next = Infinity) {\r\n    for (const targetIndex of map) {\r\n      const Index = Math.min(Math.abs(targetIndex - prev), Math.abs(targetIndex - next));\r\n      arr.push(Index);\r\n    }\r\n    map = [];\r\n  }\r\n  for (let index = 0; index < S.length; index++) {\r\n    const ele = S[index];\r\n    if (ele === C) {\r\n      clear(prevC, index);\r\n      arr.push(0);\r\n      prevC = index;\r\n    } else {\r\n      map.push(index);\r\n    }\r\n  }\r\n  if (map.length > 0) {\r\n    clear(prevC);\r\n  }\r\n  return arr;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839486308","body":"#### 思路\r\n两种做法,一种常规遍历,一种运用辅助栈,空间换时间，用一个 O(M)的 hashtable 来记录所有 increment 的操作，\r\n在要 pop 的时候把操作对弹出栈的值进行运算,并且要更新辅助栈\r\n\r\n#### 复杂度\r\n\r\n1.  复杂度分析\r\n时间复杂度：O(N) \r\n空间复杂度：O(1)\r\n\r\n2. 辅助栈\r\n时间复杂度：O(1)\r\n空间复杂度：O(N)\r\n\r\n#### 代码\r\n```\r\nvar CustomStack = function (maxSize) {\r\n  this.list = [];\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n* @param {number} x\r\n* @return {void}\r\n*/\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.list.length < this.maxSize) {\r\n      this.list.push(x)\r\n  }\r\n};\r\n\r\n1.\r\n/**\r\n* @return {number}\r\n*/\r\nCustomStack.prototype.pop = function () {\r\n  return this.list.length ? this.list.pop() : -1\r\n};\r\n\r\n/** \r\n* @param {number} k \r\n* @param {number} val\r\n* @return {void}\r\n*/\r\nCustomStack.prototype.increment = function (k, val) {\r\n  let min = Math.min(k, this.list.length)\r\n  for (let index = 0; index < min; index++) {\r\n      this.list[index] += val\r\n  }\r\n};\r\n\r\n\r\n2.\r\nCustomStack.prototype.pop = function() {\r\n  if(this.stack.length < 1) return -1; //如果长度为0，返回-1\r\n  let curLastIndex = this.stack.length - 1; //现在即将要被pop出去的元素的index\r\n  let last = this.stack.pop(); //last = 被pop的\r\n  if(this.record.has(curLastIndex)){ //如果record有这个index的操作记录\r\n    let temp = this.record.get(curLastIndex) //让temp等于这个index的增加的总值\r\n    last += temp //加到last上去\r\n    //调整相关记录\r\n    this.record.set(curLastIndex - 1, (this.record.get(curLastIndex - 1) || 0 ) + temp )\r\n    //删除已经用过的记录\r\n    this.record.delete(curLastIndex)\r\n  }\r\n\r\n  return last;\r\n};\r\n\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let index = k > this.stack.length - 1 ? this.stack.length - 1 : k - 1;\r\n  this.record.set(index, (this.record.get(index) || 0) + val)\r\n};\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841042265","body":"#### 思路\r\n使用辅助栈,用空间换时间.\r\n注意:辅助栈的栈顶就是队列的队首,即原始栈当栈底\r\n#### 复杂度\r\n时间复杂度：时间复杂度均摊为 O(1) push 和 empty 都是 1， pop 和 peek 均摊是 1，对于每个元素之多入栈和出栈两次\r\n\r\n空间复杂度：O(N)\r\n#### 代码\r\n```\r\nvar MyQueue = function () {\r\n    this.stack1 = [];\r\n    this.stack2 = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n    this.stack1.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n    if (this.stack2.length === 0) {\r\n        while (this.stack1.length > 0) {\r\n            this.stack2.push(this.stack1.pop())\r\n        }\r\n        // return this.stack2.pop();\r\n    }\r\n    return this.stack2.pop();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n    if (this.stack2.length === 0) {\r\n        while (this.stack1.length > 0) {\r\n            this.stack2.push(this.stack1.pop())\r\n        }\r\n        // return this.stack2.pop();\r\n    }\r\n    return this.stack2[this.stack2.length-1];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\nreturn this.stack2.length===0 && this.stack1.length===0\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841627957","body":"#### 最多能完成排序的块 II\r\n\r\n#### 思路\r\n\r\n借助辅助栈,存储每一块的最大值,因而栈是正序排列的.\r\n遍历数组,当遇到比辅助栈栈顶元素大的元素或栈为空时直接压入栈,\r\n否则需要找到栈中所有比元素大的块,合为一块,最大值就是栈顶的值.so,递归遍历栈,若块的值比元素大,则出栈,块的值比元素小则停止循环,给栈加上值为栈顶的块\r\n#### 复杂度\r\n时间复杂度 O(N) ：遍历一遍 arr 为 O(N)，修正排序块最多遍历一遍 arrarr 为 O(N)；\r\n空间复杂度 O(N) ：极端情况下排序块数量等于数组长度，此时 stack 占用线性大小额外空间。\r\n#### 代码\r\n```\r\nvar maxChunksToSorted = function (arr) {\r\n  let stack = [];\r\n  for (const ele of arr) {\r\n      if (stack.length && ele < stack[stack.length - 1]) {\r\n        let max = stack.pop()\r\n        while (stack.length && ele < stack[stack.length - 1]) {\r\n         stack.pop()\r\n      }\r\n          stack.push(max);\r\n      }\r\n      else {\r\n          stack.push(ele);\r\n      }\r\n  }\r\n\r\n  return stack.length\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caoyuyuyu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836813414","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 思路\r\n\r\n-  最终结果由数组变成的数值和数值相加，再转化为数组\r\n-  所以解题过程完全按照结果的生成过程for循环实现\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```Python3\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        a=''\r\n        b=[]\r\n        for i in num:\r\n            a=a+str(i)\r\n        re=str(int(a)+k)\r\n        for j in re:\r\n            b.append(int(j))\r\n        return b\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 还不会分析复杂度,后面补上相关知识～\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838728328","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n\r\n-  题目是求每个字符串到最近到给定字符的距离，\r\n- 逆向思维，先求出给定字符到所有字符的距离，再求出其中的最小值\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        a=[]\r\n        b=[]\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                a.append(i)\r\n\r\n        for i in range(len(s)):\r\n            re=len(s)\r\n            for j in a:\r\n                re=min(re,abs(int(i)-int(j)))\r\n            b.append(re)\r\n        return b\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839886323","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n\r\n## 思路\r\n\r\n-  用python的list 和append、pop实现\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack=[]\r\n        self.maxsize=maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack)< self.maxsize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack)>0:\r\n            p=self.stack.pop()\r\n            return p\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.stack)<k:\r\n            for i in range(len(self.stack)):\r\n                self.stack[i]=self.stack[i]+val\r\n        else:\r\n            for i in range(k):\r\n                self.stack[i]=self.stack[i]+val\r\n        return self.stack\r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"keepchasing":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836818313","body":"### 思路\r\n+ 遍历数组与K的对应位相加，并记录进位carryNum，carryNum默认值为0\r\n+ 判断K的位数与A对应的数字的位数，如果K的位数更大 取出前边的数据依次加到A中\r\n### 语言：\r\n javascript\r\n\r\n### 复杂度分析\r\n+ 时间复杂度： O(N)\r\n+ 空间复杂度：O(1)\r\n```\r\n/**\r\n * @param {number[]} A\r\n * @param {number} K\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = (A, K) => {\r\n    let len = A.length // 数组A的长度\r\n    let carryNum = 0 // 进位\r\n    A.forEach((item, index) => {\r\n        let curNum = Math.floor(K % Math.pow(10, index + 1) / Math.pow(10, index))\r\n        let tmpCurNum = (curNum + A[len - index -1 ] + carryNum)\r\n        A[len - index - 1] = tmpCurNum % 10\r\n        carryNum = Math.floor(tmpCurNum / 10)\r\n    })\r\n    let kStrLen = (K + '').length\r\n    // 如果K的位数大于A对应的数字的位数\r\n    if (kStrLen >= len) {\r\n        let tmpK = Math.floor(K / Math.pow(10, len)) + carryNum\r\n        let tmpKStrLen = (tmpK + '').length\r\n        for (let i = 0; i < tmpKStrLen; i ++) {\r\n            let tmpNum = Math.floor(tmpK % Math.pow(10, i + 1) / Math.pow(10, i))\r\n            i === tmpKStrLen - 1 && tmpNum === 0 ? '' : A.unshift(tmpNum)\r\n        }\r\n    } else {\r\n        carryNum ? A.unshift(carryNum) : ''\r\n    }\r\n    return A\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838608422","body":"### 思路分析\r\n+ 从左到右遍历数组， res存储当前字符到左边数下标最大的目标C的距离\r\n+ 从右到左遍历，比较下标i对应的字符到从右边数下标最小的目标C的距离与res[i]的大小，取最小值\r\n\r\n### 语言\r\n+ javascript\r\n### 复杂度分析\r\n+ 时间复杂度：O(n)\r\n+ 空间复杂度：O(n)\r\n```\r\nlet S = \"loveleetcode\", C = 'e'\r\nconst shortestToChar = (S, C) => {\r\n    let res = []\r\n    let sLen = S.length\r\n    let leftMaxIndex = -10000\r\n    let rightMinIndex = 20000\r\n    for(let i = 0; i < sLen; i++) {\r\n        if(S[i] === C) {\r\n            leftMaxIndex = i\r\n        }\r\n        res[i] = i - leftMaxIndex\r\n    }\r\n    for(let i = sLen - 1; i >= 0; i--) {\r\n        if(S[i] === C) {\r\n            rightMinIndex = i\r\n        }\r\n        res[i] = Math.min(rightMinIndex - i, res[i])\r\n    }\r\n    return res\r\n}\r\nconsole.log(shortestToChar(S, C))\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839811027","body":"### 语言\r\n + javascript\r\n### 复杂度\r\n+ 空间 ：O(n)\r\n+ 时间 ：O(n)\r\n```\r\n\r\nclass CustomStack {\r\n    constructor(maxSize){\r\n        this.maxSize = maxSize\r\n        this.stack = []\r\n    }\r\n    push(val) {\r\n        if (this.stack.length < this.maxSize) {\r\n            this.stack.push(val)\r\n            return val\r\n        }\r\n        return null\r\n    }\r\n    pop() {\r\n        return this.stack.length === 0 ? -1 : this.stack.pop()\r\n    }\r\n    increment(k, val) {\r\n        let stackLen = this.stack.length\r\n        for (let i = 0; i < k && i < stackLen; i++) {\r\n            this.stack[i] += val\r\n        }\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840650185","body":"### 语言\r\n+ javascript\r\n### 思路分析\r\n+ 将字符串每个字符从前到后依次压入数组模拟的栈中\r\n+ 判断下一个字符串为’]‘时操作出栈 ，直到下一个’[‘，将这个中间出栈的元素存入一个变量\r\n+ 找到’[‘之后再找出它之前的数字times，然后重复步骤2中的变量times次，然后将它压入栈\r\n+ 最后返回这个栈中所有元素拼起来的字符串\r\n\r\n### 复杂度分析\r\n+ 空间复杂度： O(N)\r\n+ 时间复杂度：\r\n```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nconst decodeString = (s) => {\r\n    let stack = []\r\n    let sLen = s.length\r\n    for (let i = 0; i < sLen; i++) {\r\n        if (s[i] !== ']') {\r\n            stack.push(s[i])\r\n        } else {\r\n            let times = 0\r\n            let tmpItem = ''\r\n            for (let m = stack.length - 1; m >= 0; m--) {\r\n                if (stack[m] === '[') {\r\n                    stack.pop()\r\n                    // 取出数字\r\n                    let num = 0\r\n                    for (let j = m - 1; j >= 0; j--) {\r\n                        if (/\\d/.test(stack[j])) {\r\n                            times += Number(stack.pop())*Math.pow(10, num)\r\n                            num ++\r\n                        } else {\r\n                            break\r\n                        }\r\n                    }\r\n                    break\r\n                } else {\r\n                    tmpItem = `${stack.pop()}${tmpItem}`\r\n                }\r\n            }\r\n            if (i) {\r\n                stack.push(tmpItem.repeat(times))\r\n            }\r\n        }\r\n    }\r\n    return stack.join('')\r\n}\r\nconst s = \"3[a]2[bc]\"\r\nconsole.log(decodeString(s))\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"CurrrryChen":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836821360","body":"**思路**\r\n利用js的BigInt累加\r\n\r\n**代码**\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    return (BigInt(num.join(''))+BigInt(k)).toString().split('').map(Number);\r\n};\r\n```\r\n\r\n**复杂度**\r\n时间复杂度:O(n)\r\n空间复杂度:O(1)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839656205","body":"**思路**\r\n用数组模拟\r\n\r\n**代码**\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize = maxSize;\r\n    this.val = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.val.length<this.maxSize){\r\n        this.val.push(x);\r\n    }else{\r\n        return;\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(this.val.length){\r\n        return this.val.pop();\r\n    }else{\r\n        return -1;\r\n    }\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    this.val = this.val.map((item,index) => {\r\n        if(index<k){\r\n            return item+val;\r\n        }\r\n        return item;\r\n    })\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n**复杂度**\r\n时间复杂度：increO(n) push,pop O(1)\r\n空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"renziao":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836824996","body":"思路：leetcode官方题解的思路：数组和数字最后一位从后往前，对应的位相加，如果产生进位，数字k加1，这样就会在下一位中运 算了，最后如果数字k的长度大于数组的长度，那么就把数字k剩下的进行取余取整操作，加到目标数组中，最后数组反转得到结果\r\n\r\n代码：\r\n\r\npublic List addToArrayForm(int[] A, int K) {\r\n// 初始化参数\r\nList res = new ArrayList();\r\nint n = A.length;\r\n\r\n    // 1. 从后往前逐位相加\r\n    for(int i = n - 1;i >= 0;i--){\r\n        // 1.1 逐位相加\r\n        int sum = A[i] + K % 10;         // 每次重置sum\r\n        K /= 10;    \r\n        // 1.2 处理两位相加 进位的情况\r\n        if(sum >= 10){\r\n            K++;                        // 进位到K的末尾\r\n            sum -= 10;                  // 进位清掉\r\n        }\r\n        // 1.2 当前相加的结果 添加到结果集\r\n        res.add(sum);\r\n    }\r\n\r\n    // 2. K的数字长度大于数组的数字长度\r\n    for(;K > 0;K /= 10){                // 每次K左移一位\r\n        res.add(K % 10);                // 添加到结果集\r\n    }\r\n\r\n    // 3. 将结果集翻转即是所求答案\r\n    Collections.reverse(res);\r\n    return res;"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Nbambi":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836826525","body":"思路\r\n- 遍历数组num，用k乘当前位的10的幂次，累加结果\r\n\r\n代码\r\n```\r\nvar addToArrayForm = function (num, k) {\r\n    let len = num.length - 1;\r\n    let result = 0;\r\n    for(let i=0; i<num.length; i++) {\r\n        result = result +num[i] * (Math.pow(10, len - i))\r\n    }\r\n    return result + k;\r\n};\r\n```\r\n\r\n复杂度\r\n\r\n- 时间复杂度O(n) 空间复杂度O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837853699","body":"- 思路\r\n中心扩展法\r\n\r\n- 代码：JS\r\n```\r\n/**\r\n * 中心扩展法\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n\r\n    let n = s.length;\r\n    let answer = Array(n).fill(0);\r\n\r\n    for (let i = 0; i < n; i++) {\r\n        // 刚好匹配 不处理\r\n        if (s[i] === c) continue;\r\n        // 定义向左向右两个指针, 初始化 最短距离=Infinity(因为数组默认初始值是0)\r\n        let l = i, r = i, shortest = Infinity;\r\n        // 向左找\r\n        while (l >= 0) {\r\n            if (s[--l] === c) {\r\n                shortest = Math.min(i - l, shortest); //如果left找到了先赋值\r\n            }\r\n        }\r\n        // 向右找\r\n        while (r <= n) {\r\n            if (s[++r] === c) {\r\n                shortest = Math.min(r - i, shortest); //如果left找到了, 会与之比较, 更小就会替换掉\r\n            }\r\n        }\r\n        answer[i] = shortest;\r\n    }\r\n    return answer;\r\n};\r\n```\r\n\r\n- 复杂度\r\n时间复杂度O(n2) 空间复杂度O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837853699","body":"- 思路\r\n中心扩展法\r\n\r\n- 代码：JS\r\n```\r\n/**\r\n * 中心扩展法\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n\r\n    let n = s.length;\r\n    let answer = Array(n).fill(0);\r\n\r\n    for (let i = 0; i < n; i++) {\r\n        // 刚好匹配 不处理\r\n        if (s[i] === c) continue;\r\n        // 定义向左向右两个指针, 初始化 最短距离=Infinity(因为数组默认初始值是0)\r\n        let l = i, r = i, shortest = Infinity;\r\n        // 向左找\r\n        while (l >= 0) {\r\n            if (s[--l] === c) {\r\n                shortest = Math.min(i - l, shortest); //如果left找到了先赋值\r\n            }\r\n        }\r\n        // 向右找\r\n        while (r <= n) {\r\n            if (s[++r] === c) {\r\n                shortest = Math.min(r - i, shortest); //如果left找到了, 会与之比较, 更小就会替换掉\r\n            }\r\n        }\r\n        answer[i] = shortest;\r\n    }\r\n    return answer;\r\n};\r\n```\r\n\r\n- 复杂度\r\n时间复杂度O(n2) 空间复杂度O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AmuroPeng":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836832176","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n = num.length;\r\n        List<Integer> ans = new ArrayList<Integer>();\r\n        for (int i = n - 1; i >=0; i--) {\r\n            int digit = num[i] + k % 10; // for each digit\r\n            k /= 10;\r\n            if (digit >= 10) {\r\n                digit -= 10;\r\n                k++;\r\n            }\r\n            ans.add(digit);\r\n        }\r\n        // if the length of k is more than num\r\n        while (k >= 10){\r\n            ans.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        if (k != 0) {\r\n            ans.add(k);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839711082","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass CustomStack {\r\n    int[] ans;\r\n    int cursor;\r\n\r\n    public CustomStack(int maxSize) {\r\n        ans = new int[maxSize];\r\n        cursor = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (cursor == ans.length - 1) return;\r\n        cursor += 1;\r\n        ans[cursor] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if (cursor == -1) return -1;\r\n        cursor -= 1;\r\n        return ans[cursor + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int max_inc = Math.min(k, cursor + 1);\r\n        for (int i = 0; i < max_inc; i++) {\r\n            ans[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841206232","body":"\r\n## 题目地址(232. 用栈实现队列)\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\r\n\r\n实现 MyQueue 类：\r\n\r\nvoid push(int x) 将元素 x 推到队列的末尾\r\nint pop() 从队列的开头移除并返回元素\r\nint peek() 返回队列开头的元素\r\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\r\n\r\n \r\n\r\n说明：\r\n\r\n你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n\r\n \r\n\r\n进阶：\r\n\r\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\r\n[[], [1], [2], [], [], []]\r\n输出：\r\n[null, null, null, 1, 1, false]\r\n\r\n解释：\r\nMyQueue myQueue = new MyQueue();\r\nmyQueue.push(1); // queue is: [1]\r\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\nmyQueue.peek(); // return 1\r\nmyQueue.pop(); // return 1, queue is [2]\r\nmyQueue.empty(); // return false\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= x <= 9\r\n最多调用 100 次 push、pop、peek 和 empty\r\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass MyQueue {\r\n    Stack<Integer> in_stk, out_stk;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        in_stk = new Stack();\r\n        out_stk = new Stack();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        in_stk.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (out_stk.isEmpty()) move();\r\n        return out_stk.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (out_stk.isEmpty()) move();\r\n        return out_stk.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return out_stk.isEmpty() && in_stk.isEmpty()?true:false;\r\n    }\r\n\r\n    public void move() {\r\n        while (!in_stk.isEmpty()) {\r\n            out_stk.push(in_stk.pop());\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christ36":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836832193","body":"class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n复杂度分析\r\n\r\n时间复杂度：O(max(n,log k))，其中 n 为数组的长度。\r\n\r\n空间复杂度：O(1)。除了返回值以外，使用的空间为常数。\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838755307","body":"public class mindistant {\r\n    public int[] addToArrayForm(String S, char C) {\r\n        int N = S.length();\r\n        int[] res = new int[N];\r\n        for(int i = 0; i <N; i++) {\r\n            if (S.charAt(i) == C) continue;\r\n            int left = i;\r\n            int right = i;\r\n            int dist = 0;\r\n            while (left >= 0 || right <= S.length() - 1) {\r\n                if (S.charAt(left) == C) {\r\n                    dist = i - left;\r\n                    break;\r\n                }\r\n                if (S.charAt(right) == C) {\r\n                    dist = right - i;\r\n                    break;\r\n                }\r\n                if (left > 0) left--;\r\n                if (right < S.length() - 1) right++;\r\n            }\r\n            res[i] = dist;\r\n        }\r\n        return res;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838755307","body":"public class mindistant {\r\n    public int[] addToArrayForm(String S, char C) {\r\n        int N = S.length();\r\n        int[] res = new int[N];\r\n        for(int i = 0; i <N; i++) {\r\n            if (S.charAt(i) == C) continue;\r\n            int left = i;\r\n            int right = i;\r\n            int dist = 0;\r\n            while (left >= 0 || right <= S.length() - 1) {\r\n                if (S.charAt(left) == C) {\r\n                    dist = i - left;\r\n                    break;\r\n                }\r\n                if (S.charAt(right) == C) {\r\n                    dist = right - i;\r\n                    break;\r\n                }\r\n                if (left > 0) left--;\r\n                if (right < S.length() - 1) right++;\r\n            }\r\n            res[i] = dist;\r\n        }\r\n        return res;\r\n    }\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fangyinghua":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836833635","body":"思路:\r\n\r\n* 从右往左 依次遍历 [十进一]\r\n\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const len= num.length;\r\n\r\n   //需要处理 两者长度不一，可能数组的个数小于k的个数\r\n    for (let i = len - 1; (i >= 0 || k > 0); (--i, k = parseInt(k / 10))) {\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```\r\n\r\n复杂度\r\n\r\n* 时间复杂度O(Max(n,k)) \r\n* 空间复杂度O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838753017","body":"思路：\r\n从两个方向扫描，在相同位置进行比较。\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\n var shortestToChar = function (s, c) {\r\n        let N = s.length;\r\n        let ans = new Array(N);\r\n        let prev=Number.MIN_SAFE_INTEGER/2;\r\n        for (let i = 0; i < N; ++i) {\r\n            if (s.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev =Number.MAX_SAFE_INTEGER/2;\r\n        for (let i = N-1; i >= 0; --i) {\r\n            if (s.charAt(i) == c) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n   };\r\n```\r\n复杂度分析\r\n  * 时间复杂度:O(N);\r\n  * 空间复杂度:O(N);"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839814019","body":"* 方法一：\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize=maxSize;\r\n    this.customStack=[];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    const len=this.customStack.length;\r\n    if(len<this.maxSize){\r\n        this.customStack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    const result= this.customStack.pop();\r\n    return typeof result ==='undefined'?-1:result;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const len=this.customStack.length;  \r\n    for(let i=0;(i<Math.min(k,len));i++){\r\n        this.customStack[i]+=val;\r\n    }\r\n}\r\n```\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize=maxSize;\r\n    this.customStack=[];\r\n    this.top=-1;//栈顶指针\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if((this.top)!==(this.maxSize-1)){\r\n        this.top++;\r\n        this.customStack[this.top]=x;\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(this.top===-1){\r\n        return -1;\r\n    }\r\n    this.top--;\r\n    return this.customStack[this.top+1];\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const s=Math.min(k,this.top+1);\r\n    for(let i=0;i<s;i++){\r\n        this.customStack[i]+=val;\r\n    }\r\n}\r\n```\r\n* 复杂度：\r\n时间复杂度 increment O(min(k,n))，其他方法O(1);\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840594127","body":"\r\n```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let numStack = [];        \r\n    let strStack = [];        \r\n    let num = 0;              \r\n    let result = '';         \r\n    for (const char of s) {   \r\n        if (isInteger(char)) { \r\n            num =num * 10 + Number(char); \r\n        } else if (char == '[') { \r\n            strStack.push(result);\r\n            result = '';          \r\n            numStack.push(num);   \r\n            num = 0;              \r\n        } else if (char == ']') {  \r\n            let repeatTimes = numStack.pop();\r\n            result = strStack.pop() + result.repeat(repeatTimes); \r\n        } else {                   \r\n            result += char;       \r\n        }\r\n    }\r\n    return result;\r\n   \r\n};\r\n\r\nfunction isInteger(obj) {\r\n    return /^[0-9]$/.test(obj);\r\n}\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841309134","body":"```js\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n  this.inStack = []\r\n  this.outStack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n  this.inStack.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n  if (this.outStack.length === 0) {\r\n    this.in2out()\r\n  }\r\n  return this.outStack.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n  if (this.outStack.length === 0) {\r\n    this.in2out()\r\n  }\r\n  return this.outStack[this.outStack.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n  return this.inStack.length === 0 && this.outStack.length === 0\r\n};\r\n\r\n/**\r\n * move the all elements from inStack to outStack.\r\n * @return {void}\r\n */\r\nMyQueue.prototype.in2out = function() {\r\n  while (this.inStack.length) {\r\n    this.outStack.push(this.inStack.pop())\r\n  }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841667694","body":"\r\n```js\r\nvar maxChunksToSorted = function (arr) {\r\n    const sorted = [...arr];\r\n    sorted.sort((a, b) => a - b);\r\n    let count = 0,\r\n        sum1 = 0,\r\n        sum2 = 0;\r\n    for (let i = 0; i < arr.length; i++) {\r\n        sum1 += arr[i];\r\n        sum2 += sorted[i];\r\n        if (sum1 === sum2) {\r\n            count++;\r\n            sum1 = sum2 = 0; \r\n        }\r\n    }\r\n    return count;\r\n};\r\n```\r\n时间复杂度：\r\nO(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Gjts":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836834532","body":"算法流程\r\n\r\n    获取数组的长度\r\n    将 需要添加的targe赋值给sum\r\n    求出 num 和 k 之和 sum\r\n    逐位取 sum % 10，sum = sum // 10\r\n    反转，res[::-1]\r\n\r\n复杂度分析\r\n\r\n    时间复杂度：O(n)\r\n    空间复杂度：O(n)\r\n\r\n代码\r\n    \r\n    语言支持：c#\r\n    public IList<int> AddToArrayForm(int[] num, int k) {\r\n          int i = num.Length - 1;\r\n          int sum = k;\r\n          List<int> arr = new List<int>();\r\n          while(i >= 0 || sum > 0){\r\n              if(i >= 0){\r\n                  sum += num[i];\r\n              }\r\n              arr.Add(sum % 10);\r\n              sum /= 10;\r\n              i--;\r\n          }\r\n          int[] arr1 = arr.ToArray();\r\n          Array.Reverse(arr1);\r\n          return arr1;\r\n      }：\r\n  "},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838023165","body":"算法流程:\r\n\r\n    获取字符的长度\r\n    定义一个未知数int prev右移一位 int.MinValue>>1 int.MaxValue>>1 \r\n    左移、右移一位是为了定义一个边界值 0-最小值有问题 不会变成一个正整数\r\n    把字符串转换成数组char 判断和target相等 就取代那个未知数prev默认的位置\r\n    二分遍历查询数组，第一轮找到左边离target最近的数\r\n    ，第二轮找到右边离target最近的数，判断谁小把谁放到数组中\r\n\r\n复杂度分析\r\n\r\n    时间复杂度：O(n) 循环遍历数组的长度\r\n    空间复杂度：O(n) 创建了一个数组  复杂度分析不太懂 特别是空间复杂度\r\n\r\n语言支持：c#\r\n\r\n    public int[] ShortestToChar(string s, char c) {\r\n        int N = s.Length;\r\n        var isok = s.ToCharArray();\r\n        int[] ans = new int[N];\r\n        var prev = int.MinValue >> 1;\r\n        for (int i = 0; i < s.Length; i++)\r\n        {\r\n            if (isok[i] == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = int.MaxValue >> 1;\r\n        for (int i = N - 1; i >= 0; --i)\r\n        {\r\n            if (isok[i] == c) prev = i;\r\n            ans[i] = Math.Min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838023165","body":"算法流程:\r\n\r\n    获取字符的长度\r\n    定义一个未知数int prev右移一位 int.MinValue>>1 int.MaxValue>>1 \r\n    左移、右移一位是为了定义一个边界值 0-最小值有问题 不会变成一个正整数\r\n    把字符串转换成数组char 判断和target相等 就取代那个未知数prev默认的位置\r\n    二分遍历查询数组，第一轮找到左边离target最近的数\r\n    ，第二轮找到右边离target最近的数，判断谁小把谁放到数组中\r\n\r\n复杂度分析\r\n\r\n    时间复杂度：O(n) 循环遍历数组的长度\r\n    空间复杂度：O(n) 创建了一个数组  复杂度分析不太懂 特别是空间复杂度\r\n\r\n语言支持：c#\r\n\r\n    public int[] ShortestToChar(string s, char c) {\r\n        int N = s.Length;\r\n        var isok = s.ToCharArray();\r\n        int[] ans = new int[N];\r\n        var prev = int.MinValue >> 1;\r\n        for (int i = 0; i < s.Length; i++)\r\n        {\r\n            if (isok[i] == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = int.MaxValue >> 1;\r\n        for (int i = N - 1; i >= 0; --i)\r\n        {\r\n            if (isok[i] == c) prev = i;\r\n            ans[i] = Math.Min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"doubelejjyy":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836835885","body":"**思路:**\r\n1.从低位开始加\r\n2.可能k的长度大于数组的长度,所以可能for循环结束了但是k没加完,所以最后用while\r\n3.list.add的顺序是队列所以list一开始的顺序是答案从低位到高位的顺序 所以要逆序一下\r\n**代码**\r\n\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new ArrayList<>();\r\n        int length = num.length;\r\n        int value;\r\n        for (int i = length-1; i >=0; i--) {\r\n            value = num[i]+k%10;\r\n            k/=10;\r\n            if(value>9){\r\n                value -=10;\r\n                k++;//进位\r\n            }\r\n            list.add(value);\r\n\r\n        }\r\n\r\n        while(k!=0)\r\n            list.add(k%10);\r\n            k/=10;\r\n        }\r\n\r\n        Collections.reverse(list);\r\n        return list;\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\n**时间复杂度O(n)**\r\n**空间复杂度O(n)**"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837883042","body":"**思路:**\r\n1.从左到右遍历只考虑每个字符和它左边的c的距离\r\n2.从右到左遍历只考虑每个字符和它右边的c的距离\r\n3.然后比较大小\r\n\r\n**代码**\r\nJava Code:\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        \r\n        int length = s.length();\r\n        int pre = Integer.MIN_VALUE / 2;//除2是为了防止 i-pre超过int的最大值\r\n        int[] answer = new int[length];\r\n        //1.先从左边往右找 计算每个字符和上一个c的距离是多少\r\n        for (int i = 0; i < length; i++) {\r\n\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n            answer[i] = i-pre;\r\n        }\r\n\r\n        //从右边往左找 每次计算当前字符和上一个c的距离是多少\r\n        pre = Integer.MAX_VALUE / 2;// \r\n        for (int i = length-1; i >=0; i--) {\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n\r\n            if(answer[i]<pre - i){\r\n\r\n            }else{\r\n                answer[i] = pre - i;\r\n            }\r\n        }\r\n\r\n        return answer;\r\n\r\n    }\r\n}\r\n```\r\n\r\n**时间复杂度O(n)**\r\n**空间复杂度O(1)**"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839482809","body":"**思路：**实际上就是用数组模拟栈\r\n\r\nincrement方法可以优化，如果直接解就是对最后的k个元素都加上value\r\n\r\n优化就是再定义一个和栈同样长度的add数组\r\n\r\n```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int maxSize;\r\n    int realSize = 0;//栈中值的数量\r\n    int[] add;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n        add = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(realSize<maxSize){//栈还没满 还可以添加\r\n            stack[realSize++] = x;\r\n        }else{\r\n            return;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(realSize>0){//先判断stack中是否有元素\r\n            int temp = realSize-1;//需要pop出的元素的索引 \r\n            if(temp-1>=0 && add[temp]!=0){//不是最后一个往后移\r\n                add[temp-1] += add[temp];\r\n            }\r\n            int result = stack[--realSize]+add[temp];\r\n            add[temp] = 0;\r\n            return result;\r\n        }\r\n        return -1;\r\n\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n\r\n        int min = Math.min(k,realSize);\r\n        if(min>0){\r\n            add[min-1] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n**时间复杂度O(1)**\r\n\r\n**空间复杂度O(n)**"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840642199","body":"思路：栈  和计算器那种题目类似\r\n```\r\nclass Solution {\r\n    char[] ch;\r\n    public String decodeString(String s) {\r\n        ch = s.toCharArray();\r\n        return dfs(0)[0];\r\n    }\r\n\r\n    public String[] dfs(int i){\r\n        StringBuilder res = new StringBuilder();\r\n        int num = 0;\r\n        while(i < ch.length){\r\n            if(ch[i] <= '9' && ch[i] >= '0'){\r\n                num = num * 10 + Integer.parseInt(\"\" + ch[i]);\r\n            }else if(ch[i] == '['){\r\n                String[] tmp = dfs(i + 1);\r\n                i = Integer.parseInt(tmp[0]);\r\n                while(num > 0){\r\n                    res.append(tmp[1]);\r\n                    num--;\r\n                }\r\n            }else if(ch[i] == ']'){\r\n                return new String[]{\"\" + i, res.toString()};\r\n            }else{\r\n                res.append(\"\" + ch[i]);\r\n            }\r\n            i++;\r\n        }\r\n        return new String[]{res.toString()};\r\n    }\r\n}\r\n```\r\n时间复杂读O(n)\r\n空间复杂度O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841203075","body":"### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\r\n\r\n1.没有优化 \r\n\r\n```java\r\nclass MyQueue {\r\n    private Stack<Integer> inStack = new Stack<>();\r\n    private Stack<Integer> outStack = new Stack<>();\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(empty()){\r\n            return -1;\r\n        }\r\n\r\n        while(!inStack.isEmpty()){\r\n            outStack.push(inStack.pop());\r\n        }\r\n\r\n        int temp = outStack.pop();\r\n\r\n        while(!outStack.isEmpty()){\r\n            inStack.push(outStack.pop());\r\n        }\r\n\r\n        return temp;\r\n\r\n\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(empty()){\r\n            return -1;\r\n        }\r\n\r\n        while(!inStack.isEmpty()){\r\n            outStack.push(inStack.pop());\r\n        }\r\n\r\n        int temp = outStack.pop();\r\n        outStack.push(temp);\r\n\r\n        while(!outStack.isEmpty()){\r\n            inStack.push(outStack.pop());\r\n        }\r\n\r\n        return temp;\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return inStack.isEmpty();\r\n\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\n2.优化\r\n\r\n\r\n\r\n```java\r\nclass MyQueue {\r\n    private Stack<Integer> inputStack;\r\n    private Stack<Integer> outputStack;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        inputStack = new Stack<>();\r\n        outputStack = new Stack<>();\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        inputStack.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(outputStack.isEmpty()){\r\n            while(!inputStack.isEmpty()){\r\n                outputStack.push(inputStack.pop());\r\n            }\r\n        }\r\n\r\n        return outputStack.pop();\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n\r\n        if(outputStack.isEmpty()){\r\n            while(!inputStack.isEmpty()){\r\n                outputStack.push(inputStack.pop());\r\n            }\r\n        }\r\n\r\n        int temp = outputStack.pop();\r\n        outputStack.push(temp);\r\n        return temp;\r\n\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return inputStack.isEmpty()&&outputStack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n\r\n```\r\n\r\n**时间复杂度**  O(1)\r\n\r\n**空间复杂度** O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyyangrun":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836844742","body":"```\r\ndef addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n    res = []\r\n    i, carry = len(A) - 1, 0\r\n    while i >= 0 or K != 0:\r\n        x = A[i] if i >= 0 else 0\r\n        y = K % 10 if K != 0 else 0\r\n        sum = x + y + carry\r\n        res.append(sum % 10)\r\n        carry = sum // 10\r\n        i -= 1\r\n        K //= 10\r\n    if carry != 0: res.append(carry)\r\n    return res[::-1]\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839890841","body":"\r\n    class CustomStack:\r\n\r\n        def __init__(self, maxSize: int):\r\n            self.stack=[]\r\n            self.maxsize=maxSize\r\n\r\n\r\n        def push(self, x: int) -> None:\r\n            if len(self.stack)< self.maxsize:\r\n                self.stack.append(x)\r\n\r\n        def pop(self) -> int:\r\n            if len(self.stack)>0:\r\n               p=self.stack.pop()\r\n                return p\r\n            else:\r\n                return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.stack)<k:\r\n            for i in range(len(self.stack)):\r\n                self.stack[i]=self.stack[i]+val\r\n        else:\r\n            for i in range(k):\r\n                self.stack[i]=self.stack[i]+val\r\n        return self.stack\r\n\r\n\r\n\r\n\r\n\r\n"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841683087","body":"python3\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: [int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tipshal":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836845741","body":"我是码盲，刚开始学Python，先说一下思路吧：\r\n1.把一维数组转换成整数\r\n  s=0\r\n  for i in A\r\n    s=s*10+i\r\n2.整体进行加法运算\r\n  s=s+k\r\n3.将计算结果转成字符串，用列表推导式把每一位字符转换成整数\r\n  s=str(s)\r\n  return[int(x) for x in s]"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838738222","body":"囧迫的我还没搞好Python，先抄了一段Java，大概意思看明白了，就是通过两次遍历，找出c的位置，进行与当前每个字符的比对\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] dist = new int[length];\r\n        \r\n        // 从左向右遍历\r\n        int loc = 10000;\r\n        for(int i=0;i<length;i++){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.abs(i-loc);\r\n        }\r\n\r\n        // 从右向左遍历\r\n        for(int i=length-1;i>=0;i--){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.min(dist[i],Math.abs(i-loc));\r\n        }\r\n\r\n        return dist;\r\n\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838738222","body":"囧迫的我还没搞好Python，先抄了一段Java，大概意思看明白了，就是通过两次遍历，找出c的位置，进行与当前每个字符的比对\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] dist = new int[length];\r\n        \r\n        // 从左向右遍历\r\n        int loc = 10000;\r\n        for(int i=0;i<length;i++){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.abs(i-loc);\r\n        }\r\n\r\n        // 从右向左遍历\r\n        for(int i=length-1;i>=0;i--){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.min(dist[i],Math.abs(i-loc));\r\n        }\r\n\r\n        return dist;\r\n\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840576685","body":"\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack=[] #空栈\r\n        flag = False #设置一个布尔型变量，初始值为假\r\n        for c in s[::-1]+\"/\": #返向循环\r\n            if c.isdigit(): #判断c是否为数字\r\n                flag = True #如果c为数字，flag变为真\r\n            if not c.isdigit() and flag:   #如果c不为数字（即字符）且flag为真\r\n                flag = False #flag为假           \r\n                temp = [] #临时空列表\r\n                while True: \r\n                    t = stack.pop() #出栈字符逐个赋值\r\n                    if t!=\"]\": #如果未遇到]\r\n                        temp.append(t)#将临时列表中的数堆栈\r\n                    else:\r\n                        break\r\n                temp = \"\".join(temp).split(\"[\")#将临时列表里的字符转成字符串，再以\"[\"分割\r\n                stack.append(int(temp[0])*temp[1]) #前面是数值，后面是字符\r\n            stack.append(c) #将结果压栈\r\n        stack.pop()\r\n        return \"\".join(stack[::-1])\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841331022","body":"class Queue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.instack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.outstack:\r\n            while self.instack:\r\n                self.outstack.append(self.instack.pop())\r\n        return self.outstack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.outstack:\r\n            while self.instack:\r\n                self.outstack.append(self.instack.pop())\r\n        return self.outstack[-1]\r\n\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.outstack) + len(self.instack)==0"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zsjlovelike":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836846214","body":"Class Solution{\r\nList<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n}"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838335540","body":"class Solution { \r\n public  int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        //保证有prev参与的加减运算不会溢出。同时又能起到最小值的效果\r\n        //因为i>=0,不除以2会越界。防止从左向右遍历数组时i-pre越界。\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            if (s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = Math.min(res[i], prev - i);\r\n        }\r\n        return res;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839745214","body":"public class CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        StringBuilder sb=new StringBuilder(\"[\");\r\n        for (int i = 0; i < stack.length; i++) {\r\n            sb.append(stack[i]+\",\");\r\n        }\r\n        sb.append(\"]\");\r\n        String res = sb.toString();\r\n        return res;\r\n    }\r\n}\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840395899","body":"public class Solution {\r\n    private static int p;\r\n\r\n    public static void main(String[] args) {\r\n        String s = \"3[a2[c]]\";\r\n        System.out.println(decodeString(s));\r\n    }\r\n\r\n    public static String decodeString(String s) {\r\n        LinkedList<String> list = new LinkedList<>();\r\n        p = 0;\r\n\r\n        while (p < s.length()) {\r\n            char c = s.charAt(p);\r\n            if (Character.isDigit(c)) {\r\n                //获取一个数字进栈\r\n                String digits = getDigits(s);\r\n                list.addLast(digits);\r\n            } else if (Character.isLetter(c) || c == '[') {\r\n                //获取一个字母进栈\r\n                list.addLast(String.valueOf(s.charAt(p++)));\r\n            } else {\r\n                ++p;\r\n                LinkedList<String> sub = new LinkedList<>();\r\n                while (!\"[\".equals(list.peekLast())) {\r\n                    sub.addLast(list.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                //左括号出栈\r\n                list.removeLast();\r\n                //此时栈顶为当前sub对应的字符串应该出现的次数\r\n                int n = Integer.parseInt(list.removeLast());\r\n                StringBuffer sb = new StringBuffer();\r\n                String o = getString(sub);\r\n                while (n-- > 0) {\r\n                    sb.append(o);\r\n                }\r\n                list.addLast(sb.toString());\r\n            }\r\n        }\r\n        return getString(list);\r\n    }\r\n\r\n\r\n    public static String getDigits(String s) {\r\n        StringBuilder sb = new StringBuilder();\r\n        while (Character.isDigit(s.charAt(p))) {\r\n            sb.append(s.charAt(p++));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    public static String getString(LinkedList<String> list) {\r\n        StringBuffer sb = new StringBuffer();\r\n        for (String s : list) {\r\n            sb.append(s);\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841187642","body":"public class MyQueue {\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n\r\n    public MyQueue() {\r\n        inStack = new LinkedList<Integer>();\r\n        outStack = new LinkedList<Integer>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n\r\n    public int peek() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n\r\n    private void in2out() {\r\n        while (!inStack.isEmpty()) {\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841653835","body":"public class Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        LinkedList<Integer> stack = new LinkedList<Integer>();\r\n        for(int num : arr) {\r\n            if(!stack.isEmpty() && num < stack.getLast()) {\r\n                int head = stack.removeLast();\r\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\r\n                stack.addLast(head);\r\n            }\r\n            else stack.addLast(num);\r\n        }\r\n        return stack.size();\r\n    }\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"daidaidashixiong666":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836860926","body":"class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10) {\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838683020","body":"class Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        \r\n        int N =S.length();\r\n        int[] ans =new int[N];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        for(int i=0;i<N;i++){\r\n            if(S.charAt(i)==C) prev=i;\r\n            ans[i]=i-prev; \r\n        }\r\n        prev=Integer.MAX_VALUE/2;\r\n        for(int i=N-1;i>=0;--i){\r\n            if(S.charAt(i)==C) prev=i;\r\n            ans[i]=Math.min(ans[i],prev-i);\r\n        }\r\n        return ans;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838683020","body":"class Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        \r\n        int N =S.length();\r\n        int[] ans =new int[N];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        for(int i=0;i<N;i++){\r\n            if(S.charAt(i)==C) prev=i;\r\n            ans[i]=i-prev; \r\n        }\r\n        prev=Integer.MAX_VALUE/2;\r\n        for(int i=N-1;i>=0;--i){\r\n            if(S.charAt(i)==C) prev=i;\r\n            ans[i]=Math.min(ans[i],prev-i);\r\n        }\r\n        return ans;\r\n    }\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flagyk5":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836861924","body":"思路：\r\n1.list转换为int，计算加法，再把结果转化为list\r\n2.缺点运行速度太慢，空间一般\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        B = 0\r\n        for i in range(len(A) - 1, -1, -1):\r\n            B += A[i]*(10**(len(A) - i - 1))  \r\n        C = B + K\r\n        \r\n        if C == 0:\r\n            D = [0]\r\n        else:\r\n            D = []\r\n        \r\n        while C:\r\n            D.append(C%10)\r\n            C //=10\r\n        D.reverse()\r\n        return D"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838722787","body":"思路：\r\n两边分别寻找距离，然后对比。一开始不知道怎么处理没找到的情况，solution的方法很简洁，借鉴了一下\r\n\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        \r\n        for i in range(len(s)):\r\n            l = i   \r\n            while l >= 0:\r\n                if s[l] == c:\r\n                    break\r\n                else:\r\n                    l -= 1\r\n                 \r\n            r = i\r\n            while r < len(s):\r\n                if s[r] == c:\r\n                    break\r\n                else:\r\n                    r += 1\r\n                    \r\n            if l == -1: l = -10000\r\n            if r == len(s): r = 10000\r\n            num = min(i-l, r-i)\r\n            ans.append(num)\r\n        return ans\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839870744","body":"### 思路 \r\n基本的list栈，push(append), pop(pop)，题目要求的increment单独写一下就好\r\n### 代码 Python3\r\n\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.cs = []\r\n        self.sz = maxSize\r\n        \r\n    def push(self, x: int) -> None:\r\n        if len(self.cs) < self.sz: \r\n            self.cs.append(x)\r\n            \r\n    def pop(self) -> int:\r\n        if len(self.cs) == 0:\r\n            return -1\r\n        return self.cs.pop()\r\n        \r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.cs) <= k:\r\n            for i in range(len(self.cs)):\r\n                self.cs[i] += val\r\n        if len(self.cs) > k:\r\n            for i in range(k):\r\n                self.cs[i] += val\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840268397","body":"### 思路\r\n栈符号，读str然后写进stack里面，先找 ']' , 再回过来找 '[' \r\n有参考题解的思路\r\n\r\n### 代码 Python3\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for i in s:\r\n            if  i == ']':\r\n                les = ''\r\n                num = ''\r\n                while stack[-1].isalpha():\r\n                    les = stack.pop() + les\r\n                stack.pop()\r\n                while stack != [] and stack[-1].isnumeric():\r\n                    num = stack.pop() + num\r\n                stack.append(les * int(num))\r\n            else:\r\n                stack.append(i)\r\n        return \"\".join(stack)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841321427","body":"### 思路\r\n双栈模拟队列\r\nLeetCode有的case测试没通过，我去看看题解，在思考思考，先来打卡\r\n\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.s1 = []\r\n        self.s2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.s1.append(x)\r\n            \r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.s1 == []:\r\n            return None\r\n        while self.s1:\r\n            self.s2.append(self.s1.pop())\r\n        pop = self.s2.pop()\r\n        if self.s2 == []:\r\n            return None\r\n        self.s1.append(self.s2.pop())\r\n        return pop\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.s1 == []:\r\n            return None\r\n        while self.s1:\r\n            self.s2.append(self.s1.pop())\r\n        peek = self.s2[-1]\r\n        self.s1.append(self.s2.pop())\r\n        return peek\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.s1)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841678163","body":"### 思路\r\n栈，前一项大于后一项就进行融合，融合后的最大值写入栈中，最后计算栈长度\r\n一开始不会，参考了题解的思路\r\n\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, A: [int]) -> int:\r\n        s = []\r\n        for i in A:\r\n            if s and s[-1] > i:\r\n                num = s[-1]\r\n                while s and s[-1] > i:\r\n                    s.pop()\r\n                s.append(num)\r\n            else:\r\n                s.append(i)\r\n        return len(s)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jennny06":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836864849","body":"一开始用了一个一个加的方法，然后在用 divmod 做，但是发现这样的速度很慢。学习了一下评论里的码，发现python 其实一行code 就可以搞定：先把str 转成int， 然后加减，再转成str：\r\n`return map(int,str(int(''.join(map(str,num))) + k))`"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838731551","body":"### 思路\r\n先找到index，然后一个一个比较\r\n\r\n```\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        ind = [i for i,e in enumerate(s) if e == c ]\r\n        ans = []\r\n        \r\n        for i in range(len(s)):\r\n            minn = 'inf'\r\n            for j in ind:\r\n                dist = abs(i-j)\r\n                if minn > dist:\r\n                    minn = dist\r\n            ans.append(minn)\r\n                \r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：`O(n^2)`"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839872173","body":"## Code in Python\r\n\r\n`class CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.maxSize = maxSize\r\n        self.s = []\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.s) < self.maxSize:\r\n            self.s.append(x)\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.s) == 0:\r\n            return -1\r\n        else:\r\n            ele = self.s.pop()\r\n            return ele\r\n        \r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        \r\n        if len(self.s) <= k:\r\n            self.s = [i+val for i in self.s]\r\n        else:\r\n            self.s = [i+val for i in self.s[0:k]] + self.s[k:]`\r\n\r\n## 复杂度\r\n- 时间：`O(n)`\r\n- 空间：`O(n)`\r\n\r\n## 其他\r\n没有看懂python的最快解，不知道这个 `self.inc` 到底是干嘛用的。先来打卡，让我再来研究一下"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840587215","body":"## Code in Python\r\n\r\n\r\n`class Solution(object):\r\n    def decodeString(self, s):        \r\n        out = ''\r\n        stack = []\r\n        num = ''\r\n        \r\n        for c in range(len(s)):\r\n            if s[c].isdigit():\r\n                num += s[c]\r\n            elif s[c] == '[':\r\n                stack.append((out, int(num)));\r\n                out,num = \"\", \"\"\r\n            elif s[c] == ']':\r\n                top = stack.pop()\r\n                out = top[0] + out * top[1]\r\n            else: \r\n                out += s[c]\r\n          \r\n        return out`\r\n\r\n## 复杂度\r\n- 时间: `O (n)`\r\n- 空间: `O(n)`\r\n\r\n## 思路\r\n先从头往后，遇到数字先存成string，然后遇到`[` 之后，把现在存在的output 和 数字存起来。注意要把output reset 成null，这样可以遇到后面的括号内的内容，先把里面括号的内容写出来，再加上现在有的。遇到`]`后，把最上面的output 和 数字取出，然后用output + 数字*最新的括号内的内容。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841251826","body":"## Code in Python\r\n\r\n`class MyQueue(object):\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.s1 = []\r\n        self.s2 = []\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        \r\n        return self.s1.append(x);\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        :rtype: int\r\n        \"\"\"\r\n        \r\n        if not self.s2:\r\n            while len(self.s1) != 0:\r\n                self.s2.append(self.s1.pop())\r\n        \r\n        return  self.s2.pop()\r\n        \r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        Get the front element.\r\n        :rtype: int\r\n        \"\"\"\r\n        if not self.s2:\r\n            return self.s1[0]\r\n        \r\n        return self.s2[-1]\r\n        \r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        :rtype: bool\r\n        \"\"\"\r\n        if len(self.s1)+len(self.s2) == 0:\r\n            return True\r\n        else:\r\n            return False`\r\n\r\n## 复杂度\r\n- 时间：O(n)\r\n- 空间:  O(n)\r\n\r\n##思路\r\n用一个list就可以写出来。用一个stack做input，用另一个stack做output"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841683541","body":"##  Code in Python\r\n\r\n```python\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n     ans = 1\r\n        max_ = arr[0]\r\n        mins = [arr[-1]] * len(arr)\r\n        \r\n        for i in range(len(arr)-2,-1,-1):\r\n            mins[i] = min(mins[i+1],arr[i])\r\n            \r\n        for i in range(1,len(arr),1):\r\n            if max_ <= mins[i]:\r\n                ans+=1\r\n            max_ = max(max_, arr[i])\r\n\r\n```\r\n\r\n## 复杂度\r\n- 时间: O (n)\r\n- 空间: O (n)\r\n\r\n## 思路\r\n看了youtube上的解法。。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sun-unc":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836866524","body":"var addToArrayForm = function (num, k) {\r\n    return (BigInt(num.join('')) + BigInt(k)).toString().split('')\r\n};"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838373077","body":"    var shortestToChar = function(s, c) {\r\n      let arr = s.split('')\r\n      let answer = []\r\n      for(let i = 0; i < arr.length; i++) {\r\n        if(arr[i] == c) {\r\n          answer.push(0)\r\n          continue\r\n        }\r\n        let arr1 = arr.slice(0, i).reverse()\r\n        let arr2 = arr.slice(i+1, arr.length)\r\n        let leftIndex = arr1.indexOf(c)\r\n        let rightIndex = arr2.indexOf(c)\r\n        if (leftIndex === -1) {\r\n          answer.push(rightIndex + 1)\r\n        } else if(rightIndex === -1) {\r\n          answer.push(leftIndex + 1)\r\n        } else {\r\n          leftIndex <= rightIndex ? answer.push(leftIndex + 1) : answer.push(rightIndex + 1)\r\n        }\r\n      }\r\n      console.log(answer);\r\n      // return answer\r\n    };"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838373077","body":"    var shortestToChar = function(s, c) {\r\n      let arr = s.split('')\r\n      let answer = []\r\n      for(let i = 0; i < arr.length; i++) {\r\n        if(arr[i] == c) {\r\n          answer.push(0)\r\n          continue\r\n        }\r\n        let arr1 = arr.slice(0, i).reverse()\r\n        let arr2 = arr.slice(i+1, arr.length)\r\n        let leftIndex = arr1.indexOf(c)\r\n        let rightIndex = arr2.indexOf(c)\r\n        if (leftIndex === -1) {\r\n          answer.push(rightIndex + 1)\r\n        } else if(rightIndex === -1) {\r\n          answer.push(leftIndex + 1)\r\n        } else {\r\n          leftIndex <= rightIndex ? answer.push(leftIndex + 1) : answer.push(rightIndex + 1)\r\n        }\r\n      }\r\n      console.log(answer);\r\n      // return answer\r\n    };"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Rainjoy66":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836866671","body":"```\r\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        for nu in num:\r\n            res.append(str(nu))\r\n        string = \"\".join(res)\r\n        ans = int(string) + k\r\n        anss = list(str(ans))\r\n        dd = []\r\n        for ansss in anss:\r\n            dd.append(int(ansss))\r\n        return dd\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838734678","body":"### 思路：\r\n正反遍历，然后取最小值\r\n### 代码\r\n```\r\ndef function(self, s, c):\r\n        res = []\r\n        t = len(s)\r\n        for i in s:\r\n            t=0 if i==c else t+1\r\n            res.append(t)\r\n        for idx,i in enumerate(s[::-1]):\r\n            t = 0 if i==c else t+1\r\n            res[-(idx+1)] = min(t,res[-(idx+1)])\r\n        return res\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839883645","body":"### 代码\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n        self.delta = []\r\n        self.len = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.len < self.maxSize:\r\n            self.stack.append(x)\r\n            self.delta.append(0)\r\n            self.len += 1\r\n\r\n    def pop(self) -> int:\r\n        if not self.len:\r\n            return -1\r\n        self.len -= 1\r\n        a = self.stack.pop()\r\n        d = self.delta.pop()\r\n        if self.len:\r\n            self.delta[-1] += d\r\n        return a + d\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if not self.len:\r\n            return\r\n        if self.len < k:\r\n            self.delta[-1] += val\r\n        else:\r\n            self.delta[k - 1] += val\r\n```\r\n### 复杂度\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840619992","body":"### 代码\r\n```\r\ndef decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841313007","body":"```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        #stack1是输入栈\r\n        self.stack1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        #stack2是输出栈\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.stack1 and not self.stack2\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841677672","body":"### 思路\r\n维护一个单调栈，因为最后需要的是一个单调递增的数组，所以每一块的最大值应该是单调递增的。对于新进来一个数据，如果大于栈顶的最大值，直接放入栈中，作为新的块；如果小于栈顶的最大值，向之前的合并，但需要保留上一个块中的最大值。\r\n### 代码\r\n```\r\ndef maxChunksToSorted(self, arr: [int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n\r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuo0314":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836867704","body":"#Logic: convert list to str, then to int; add 2 int to get sum; convert int to str; convert str to list\r\n#Code: Python\r\n\r\n```\r\ndef addToArrayForm(self, num,k):\r\n    num_str = \"\"\r\n    for i in num:\r\n        num_str += str(i)\r\n    num_sum = int(num_str)+k\r\n    num_lst = [int(i) for i in str(num_sum)]\r\n    return num_lst\r\n```\r\n\r\n#Complexity: Time: O(n), Space: O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838701859","body":"\"\"\"Logic: iterate through the str, if the character is c, put its position in str in a new list1. After for loop, list1 will\r\n      have all position in str that's c;\r\n      iterate through the str, if the character is c, put 0 in the return list; if not, calculate the absolute value between\r\n      this index and each index in list 1, find the min and put it in the return list\r\n\"\"\"\r\n#Code: Python\r\n```\r\ndef shortestToChar(s, c):\r\n    lst = []\r\n    res_lst=[]\r\n    for i in range(len(s)):\r\n        if s[i] == c:\r\n            lst.append(i)\r\n    for j in range(len(s)):\r\n        if s[j]==c:\r\n            res_lst.append(0)\r\n        else:\r\n            min_dis = len(s)\r\n            for i in lst:\r\n                if abs(i-j) < min_dis:\r\n                    min_dis = abs(i-j)\r\n            res_lst.append(min_dis)\r\n    return res_lst\r\n```\r\n#Complexity: Time: O(n^2), Space: O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839421234","body":"#Logic: initialize an empty list and declare its max size.\r\n#Code: Python\r\n```\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.maxSize> len(self.stack):\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self)-> int:\r\n        if self.stack:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k:int, val:int) -> None:\r\n        for i in range(min(k,len(self.stack))):\r\n            self.stack[i] += val\r\n```\r\n#Complexity: Time: push() O(1), pop() O(1), increment() O(min(k,len(stack)))\r\n#space: O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840298450","body":"#第一次做不太会，参考了题解算法默写了一遍\r\n#Logic: Use of stack; Iterate through string, if character is \"]\" iterate backwards， add character to result string\r\n#until finding \"[\"; Then continue iterating backwards to find numeric char until non-numeric, \r\n#and update result string by repeating itself corresponding times. Join all char in stack to a string and return it\r\n#Code: Python\r\n```\r\ndef decodeString(self, s:str) -> str:\r\n    stack = []\r\n    #res_str = \"\"\r\n    for c in s:\r\n        if c ==\"]\":\r\n            res_str = \"\"\r\n            res_cnt = \"\"\r\n            while stack and stack[-1]!=\"[\":\r\n                res_str = stack.pop() + res_str\r\n            stack.pop()\r\n            while stack and stack[-1].isnumeric():\r\n                res_cnt = stack.pop() + res_cnt\r\n            res_str=res_str*int(res_cnt)\r\n            stack.append(res_str)        \r\n        else:\r\n            stack.append(c)\r\n    return \"\".join(stack)\r\n```\r\n\r\n#Complexity: Time: O(N), N is length of result string\r\n#space: O(N), N is length of result string"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841325358","body":"#Logic: Use two stack\r\n#Code:Python\r\n```\r\nclass MyQueue(object):\r\n```\r\n\r\n    def __init__(self):\r\n        self.stack=[]\r\n        self.helper_stack = []\r\n\r\n\r\n    def push(self, x:int) -> None:\r\n        return self.stack.append()\r\n\r\n\r\n    def pop(self) -> int :\r\n        if not self.helper_stack:\r\n            while self.stack:\r\n                self.helper_stack.append(self.stack.pop())\r\n        self.helper_stack.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.helper_stack:\r\n            return self.stack[0]\r\n        else:\r\n            self.helper_stack[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack and not self.helper_stack\r\n```\r\n```\r\n#Complexity: Time: O(1), pop() O(N)\r\n#space: O(N), N is length of result string"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841604407","body":"No clue. Checked solution and used monotonic stack.\r\n#Logic：max of previous block < min of next block.\r\n#Code: Python\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, A:[int]) -> int:\r\n        stack = []\r\n        for a in A:\r\n            if stack and stack[-1]>a:\r\n                curr_max = stack[-1]\r\n                while stack and stack[-1]>a: stack.pop()\r\n                stack.append(curr_max)\r\n            else:\r\n                stack.append(a)\r\n        return len(stack)\r\n```\r\n#Complexity: Time: O(N)\r\n#space: O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yangjiahao106":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836868252","body":"## 思路\r\n\r\n遍历数组num，用k乘当前位的10的幂次，累加结果\r\n代码\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num = list(reversed(num))\r\n        for i in range(0, len(num)):\r\n            k += num[i]\r\n            num[i] = k %10\r\n            k = k // 10\r\n        \r\n        while k > 0:\r\n            num.append(k%10)\r\n            k  = k // 10\r\n        return list(reversed(num))\r\n```\r\n## 复杂度\r\n\r\n时间复杂度O(n) 空间复杂度O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838740235","body":"```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = 0 \r\n        r = 0\r\n\r\n        res = [1<<31-1 for i in s] \r\n\r\n        while r < len(s):\r\n            if s[r] == c:\r\n               break\r\n            r += 1\r\n\r\n        for l in range(0, len(s)):\r\n            res[l] = r - l \r\n            if l ==r:\r\n                while r < len(s)-1:\r\n                    r += 1\r\n                    if s[r] == c:\r\n                        break\r\n                if s[r] != c:\r\n                    break\r\n        r = len(s) - 1\r\n        while r >=0:\r\n            if s[r] == c:\r\n               break\r\n            r -= 1\r\n    \r\n        for l in range(len(s)-1, -1, -1):\r\n            res[l] = min(res[l],  l-r) \r\n            if l <= r:\r\n                while r > 0:\r\n                    r -= 1\r\n                    if s[r] == c:\r\n                        break\r\n                if s[r] != c:\r\n                    return res \r\n        return res \r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839865783","body":"## 思路\r\n数组模拟栈\r\n## 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.vals = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.vals) < self.maxSize:\r\n            self.vals.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.vals) == 0:\r\n            return -1\r\n        return self.vals.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(k,len(self.vals))):\r\n            self.vals[i] += val\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840656306","body":"## 思路\r\n使用栈处理括号\r\n## 代码\r\n``` python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        int_stack = []\r\n        stack = []\r\n        i = 0\r\n        while i < len(s):\r\n            if '0' <= s[i] <= '9':\r\n                l = i\r\n                while '0' <=  s[i] <= '9':\r\n                    i += 1\r\n                int_stack.append(int(s[l:i]))\r\n            if s[i] == ']':\r\n                tmp = \"\"\r\n                while True:\r\n                    c = stack.pop()\r\n                    if c == '[':\r\n                        break\r\n                    tmp = c + tmp\r\n                stack.append(tmp * int_stack.pop())\r\n            else:\r\n                stack.append(s[i])\r\n\r\n            i += 1\r\n\r\n        return \"\".join(stack)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841319818","body":"# 思路\r\n 用两个栈 模拟一个队列\r\n\r\n## 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.a = []\r\n        self.b = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.a.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if len(self.b) > 0:\r\n            return self.b.pop()\r\n        while len(self.a) > 0:\r\n            self.b.append(self.a.pop())\r\n        return self.b.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if len(self.b) > 0:\r\n            return self.b[-1]\r\n        else:\r\n            return self.a[0]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.a) == 0 and len(self.b) == 0\r\n\r\n\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bmxbmx3":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836878093","body":"### 思路\r\n\r\n初步思路：\r\n1. 先排除异常情况\r\n2. 将数组变成对应数字，加上一个数后，将相加结果变回数组\r\n\r\n### 代码\r\n\r\n\r\n```python\r\n\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int] 待加数字的数组\r\n        :type k: int 所加的数字\r\n        :rtype: List[int] 加数字后的数组\r\n        \"\"\"\r\n\r\n        # 将num数组转换为对应的数字\r\n        sum = 0\r\n        length = len(num)\r\n        for i in range(len(num)):\r\n            sum += num[i]*10**(length-i-1)  # 逐位相加，比如[1,2]即1*10^1+2*10^0=12\r\n\r\n        sum += k  # 计算相加结果\r\n\r\n        # 将相加后的数字转换为对应的数组（从后往前逐位取数字）\r\n        result = []\r\n        while(sum):\r\n            result.append(sum % 10)\r\n            sum = sum//10  # 双斜杠（//）表示地板除，即先做除法（/），然后向下取整（floor）\r\n        result.reverse() # 结果数组倒序\r\n        return result\r\n\r\n\r\nnum = [9,9,9,9,9,9,9,9,9,9]\r\nk = 1\r\ns = Solution()\r\nresult = s.addToArrayForm(num, k)\r\nprint(result)\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838601737","body":"## 思路\r\n\r\n参考：\r\n- [821.字符的最短距离【4种解法、JS/Cpp/Py】](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/821zi-fu-de-zui-duan-ju-chi-4chong-jie-fa-javascri/)\r\n\r\n思路1（中心扩展法）：\r\n1. 排除异常情况\r\n2. 从原字符串s中每个字符（中心位置i）出发，向两边同时扩展寻找字符c。最先寻找到的字符c，一定距离位置i上的字符最近\r\n思路2（以空间换时间）？\r\n思路3（双向遍历贪心法）？（时间复杂度最优）\r\n## 关键点\r\n\r\n- python数组初始化？（参考：https://www.pythontab.com/html/2020/pythonjichu_0102/1470.html）\r\n- python判断字符串自否为大小写字母？（参考：https://blog.csdn.net/nanhuaibeian/article/details/99472393）\r\n- 双向遍历贪心法？\r\n\r\n## 代码\r\n\r\n- 语言支持：Python\r\n\r\nPython Code:\r\n\r\n```python\r\n\r\nclass Solution(object):\r\n    \"\"\"\r\n    思路1\r\n    \"\"\"\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        length = len(s)\r\n\r\n        \"\"\"\r\n        排除异常\r\n        \"\"\"\r\n        # 数组长度异常\r\n        if(length < 1 or length > 10000):\r\n            print(\"数组s的长度应在1-10000之间！\")\r\n            return\r\n        # 小写字母异常\r\n        if(not (s.islower() and s.isalpha())):\r\n            print(\"数组s必须都是小写字母！\")\r\n            return\r\n        if(c not in s):\r\n            print(\"字符c不在数组s中！\")\r\n            return\r\n\r\n        result = [0]*length  # 初始化结果数组，存放数组s中每个字符到字符c的最近距离\r\n\r\n        for i in range(length):\r\n            # 如果遍历到字符c，则跳过（最近距离为0）\r\n            if s[i] == c:\r\n                continue\r\n\r\n            \"\"\"  \r\n            以当前位置i的字符为中心，向两边扩展寻找最近的字符c\r\n            \"\"\"\r\n            left = i  # 向左寻找，下标不断减小\r\n            right = i  # 向右寻找，下表不断增加\r\n            min_distance = 0  # 记录最近距离（到中心字符s[i]）\r\n            while(left >= 0 or right <= length-1):\r\n                # 向两边同时寻找，一旦找到字符c就停止寻找\r\n                if(s[left] == c):\r\n                    min_distance = i-left\r\n                    break\r\n                if(s[right] == c):\r\n                    min_distance = right-i\r\n                    break\r\n\r\n                \"\"\" \r\n                left（向左标志）左移，同理right（向右标志）右移\r\n                note:\r\n                left若为0，left-1变为-1,到下层循环时不满足外层循环条件left>=0,\r\n                但right却可能依然满足right<length的外层循环条件，这样导致下层循环依然可以执行，\r\n                但此时下层循环中left=-1，使得s[left]即s[-1]因找不到值而发生错误,\r\n                故在这里设置left>0的判断。\r\n                同理，为了保险起见，这里right<length-1。\r\n                \"\"\"\r\n                if(left > 0):\r\n                    left -= 1\r\n                if(right < length-1):\r\n                    right += 1\r\n\r\n            result[i] = min_distance  # 记录字符串s中，当前位置i的字符距字符c的最近距离\r\n\r\n        return result\r\n\r\n\r\ns = Solution()\r\nstr_s = \"1baab\"\r\nc = \"a\"\r\nresult = s.shortestToChar(str_s, c)\r\nprint(result)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$，n为S的长度，两层循环。\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839887431","body":"## 思路\r\n\r\n参考：https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/solution/she-ji-yi-ge-zhi-chi-zeng-liang-cao-zuo-de-zhan-by/\r\n\r\n我们使用数组模拟栈，用一个变量 top 来记录当前栈顶的位置。\r\n\r\n对于 push 操作，首先判断当前元素的个数是否达到上限，如果没有达到，就把 top 后移一个位置并添加一个元素。\r\n\r\n对于 pop 操作，首先判断当前栈是否为空，非空返回栈顶元素并将 top 前移一位，否则返回 -1−1。\r\n\r\n对于 inc 操作，直接对栈底的最多 k 个元素加上 val。\r\n\r\n## 关键点\r\n\r\n-  对于栈前k个元素的增加操作\r\n\r\n## 代码\r\n\r\n- 语言支持：Python\r\n\r\nPython Code:\r\n\r\n```python\r\n\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int 栈的容量\r\n        \"\"\"\r\n\r\n        self.stack = [0]*maxSize  # 栈初始化\r\n        self.top = -1  # 栈顶指针\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n\r\n        # 防止溢出\r\n        length = len(self.stack)  # 获得栈的容量\r\n        if(self.top == length-1):\r\n            print(\"栈的容量已满，无法继续入栈元素！\")\r\n            return\r\n\r\n        # 入栈元素\r\n        self.top += 1\r\n        self.stack[self.top] = x\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n\r\n        # 栈空不能出栈\r\n        if(self.pop == -1):\r\n            print(\"栈空无法继续出栈！\")\r\n            return -1\r\n\r\n        # 出栈元素\r\n        x = self.stack[self.top]\r\n        self.top -= 1\r\n        return x\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int \r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n\r\n        \"\"\"\r\n        \r\n        \"\"\"\r\n        # 栈顶指针self.top从0开始计数，所以self.top+1\r\n        min_incre_size = min(k, self.top+1)\r\n        for i in range(min_incre_size):\r\n            self.stack[i] += val\r\n\r\n\r\ns = CustomStack(3)\r\ns.push(1)\r\ns.push(2)\r\ns.pop()\r\ns.push(2)\r\ns.push(3)\r\ns.increment(5,100)\r\na=s.pop()\r\na=s.pop()\r\na=s.pop()\r\nprint(a,s.top)\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n- 时间复杂度：初始化（构造函数）、push 操作和 pop 操作的渐进时间复杂度为O(1)，inc 操作的渐进时间复杂度为O(k)。\r\n- 空间复杂度：这里用到了一个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为O(maxSize)。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840644890","body":"## 思路\r\n\r\n参考：https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/\r\n1. 构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\r\n- 当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\r\n- 当 c 为字母时，在 res 尾部添加 c；\r\n- 当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 00：\r\n记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\r\n记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\r\n进入到新 [ 后，res 和 multi 重新记录。\r\n2. 当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\r\n- last_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\r\n- cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\r\n返回字符串 res。\r\n\r\n## 关键点\r\n\r\n-  括号匹配\r\n\r\n## 代码\r\n\r\n- 语言支持：Python\r\n\r\nPython Code:\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度 O(N)O(N)，一次遍历s；\r\n- 空间复杂度 O(N)O(N)，辅助栈在极端情况下需要线性空间，例如2[2[2[a]]]。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841330488","body":"## 思路\r\n\r\n将一个栈当作输入栈，用于压入 \\texttt{push}push 传入的数据；另一个栈当作输出栈，用于 \\texttt{pop}pop 和 \\texttt{peek}peek 操作。\r\n\r\n每次 \\texttt{pop}pop 或 \\texttt{peek}peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。\r\n\r\n## 关键点\r\n\r\n-  一个栈入队，另一个栈出队\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass MyQueue {\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n\r\n    public MyQueue() {\r\n        inStack = new LinkedList<Integer>();\r\n        outStack = new LinkedList<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n\r\n    private void in2out() {\r\n        while (!inStack.isEmpty()) {\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：push 和 empty 为 O(1)，pop 和 peek}为均摊 O(1)。对于每个元素，至多入栈和出栈各两次，故均摊复杂度为 O(1)。\r\n\r\n- 空间复杂度：O(n)。其中 n是操作总数。对于有 n次 push 操作的情况，队列中会有 n个元素，故空间复杂度为 O(n)。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841682726","body":"## 思路\r\n\r\n贪心法则\r\n\r\n参考：https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/zui-duo-neng-wan-cheng-pai-xu-de-kuai-ii-deng-jie-/\r\n\r\n## 关键点\r\n\r\n-  每个块的最小值要大于前一个块中的最大值\r\n\r\n## 代码\r\n\r\n- 语言支持：Python\r\n\r\nPython Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: [int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n复杂度分析：\r\n\r\n- 时间复杂度 O(N) ：遍历一遍 arrarr 为 O(N)，修正排序块最多遍历一遍 arr为 O(N)；\r\n- 空间复杂度 O(N)：极端情况下排序块数量等于数组长度，此时 stack占用线性大小额外空间。\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DADAHUI":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836882177","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n示例 1：\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n示例 2：\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n示例 3：\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n示例 4\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n提示：\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n`\r\n\r\n## 思路\r\nnum与k值逐位相加，大于9时进1，参与下一位运算\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) \r\n    {\r\n      vector <int> res;\r\n      for(int i=num.size()-1;i>=0;i--)\r\n      {\r\n          int sum=num[i]+k%10;\r\n          k/=10;\r\n          if(sum>9)\r\n          {\r\n              sum=sum%10;\r\n              k++;\r\n          }\r\n          res.push_back(sum);\r\n\r\n      }\r\n      for(;k>0;k/=10)\r\n      {\r\n          res.push_back(k%10);\r\n      }\r\n\r\n      reverse(res.begin(),res.end());\r\n      return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838588143","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n数组arr存储s中下标；s的每一个下标与每一个与和c相同的下标做差，取最小值 \r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n    vector <int> vec,answer;\r\n    \r\n    for(int i=0;i<s.size();i++)\r\n    {\r\n        if(s[i]==c) vec.push_back(i);\r\n    }\r\n    int arr[vec.size()];\r\n    \r\n    for(int i=0;i<s.size();i++)\r\n    {\r\n        for(int j=0;j<vec.size();j++)\r\n        {\r\n          arr[j]=abs(i-vec[j]);  \r\n        }\r\n        answer.push_back(*min_element(arr,arr+vec.size()));\r\n    }\r\n   return answer;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839870407","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 思路\r\nvector 实现栈。top记录栈顶；resize(n，elemen)分配内存空间（改变capacity），初始值element默认0，vector.size() 存储的元素（element）个数也变为n；\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass CustomStack {\r\npublic:\r\n    vector <int> s;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n    s.resize(maxSize);\r\n    top=-1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top!=s.size()-1)\r\n        { top++;\r\n          s[top]=x;\r\n          \r\n        }\r\n\r\n    }\r\n    \r\n    int pop() {\r\n        if(top==-1) return -1;\r\n        top--;\r\n        return s[top+1];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n         if(k>top+1) k=top+1;\r\n         for(int i=0;i<k;i++)\r\n         {\r\n             s[i]+=val;\r\n         }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(k)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841314180","body":"\r\n## 题目地址(232. 用栈实现队列)\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n\r\n## 思路\r\n栈1实现进入队列，栈1倒进栈2，栈顶为队列的开头\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass MyQueue {\r\nprivate:\r\n    stack <int>stack1;\r\n    stack <int>stack2;\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n    stack1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n     if(stack2.empty())\r\n     {\r\n         while(!stack1.empty())\r\n         {\r\n             stack2.push(stack1.top());\r\n             stack1.pop();\r\n         }\r\n     }\r\n     int ans=stack2.top();\r\n     stack2.pop();\r\n     return ans;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n     if(stack2.empty())\r\n     {\r\n         while(!stack1.empty())\r\n         {\r\n             stack2.push(stack1.top());\r\n             stack1.pop();\r\n         }\r\n     }\r\n     int ans=stack2.top();\r\n     \r\n     return ans;\r\n    \r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n     if(stack1.empty()&&stack2.empty()) return true;//进栈及出栈都为空，队列为空\r\n     else return false;\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841676832","body":"\r\n## 题目地址(768. 最多能完成排序的块 II)\r\n\r\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\r\n\r\n## 思路\r\n前一块的最大值要小于等于后一块的最小值，想到用单调栈解题\r\n当att[i]>=栈顶时，则将其压入栈；\r\narr[i]<栈顶时，先保存当前栈顶tmp作为块最大值，出栈，直到栈顶元素>=arr[i]，arr[i]与已出栈元素构成一个递增的块，其最小元素为arr[i]大于栈顶（上一块的最大值），最大值为tmp，再将tmp入栈；\r\n栈中保存的是区域最大值，元素个数即为可分的最多块。\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n    stack<int> nums;\r\n    nums.push(arr[0]);\r\n    \r\n    for(int i=1;i<arr.size();++i)\r\n    {   \r\n        if(arr[i]>nums.top())\r\n        {\r\n            nums.push(arr[i]);\r\n        }\r\n        else \r\n        {   \r\n            int tmp=nums.top();\r\n            while(!nums.empty()&&arr[i]<nums.top())\r\n            {\r\n              nums.pop();\r\n            }\r\n            nums.push(tmp);\r\n        }\r\n    }\r\n    return nums.size();\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$   for循环\r\n- 空间复杂度：$O(n)$   \r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qycoder":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836882253","body":"## 思路\r\n\r\n\r\n## 代码\r\nJavaScript\r\n\r\n```js\r\nvar addToArrayForm = function (num, k) {\r\n  let str = '';\r\n  for (let i = 0; i < num.length; i++) {\r\n    if (num[i] < 0 || num[i] > 9) {\r\n      str = '';\r\n      break;\r\n    } else {\r\n      str += num[i];\r\n    }\r\n  }\r\n  let sum = str / 1 + k;\r\n  const result = [];\r\n  let divisor;\r\n  for (let j = 0; j < (sum + '').length; j++) {\r\n    if (j == 0) {\r\n      divisor = 1;\r\n    } else {\r\n      divisor = 10 ** j;\r\n    }\r\n    result.unshift(parseInt((sum % 10 ** (j + 1)) / divisor));\r\n  }\r\n  return result;\r\n};\r\n\r\nconst arr = [1, 2, 0, 1];\r\nconst k = 220;\r\nconsole.log(addToArrayForm(arr, k));\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838736689","body":"## 思路\r\n\r\n## 代码\r\nvar shortestToChar = function (s, c) {\r\n  // 结果数组 res\r\n  var res = Array(s.length).fill(0);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    // 如果当前是目标字符，就什么都不用做\r\n    if (s[i] === c) continue;\r\n\r\n    let l = i,\r\n      r = i,\r\n      shortest = Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (s[l] === c) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r < s.length) {\r\n      if (s[r] === c) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n  return res;\r\n};\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839822900","body":"### 思路\r\n使用数组来模拟栈的push和pop\r\npop()返回堆顶元素\r\nincrement，当数组长度小于k时，所有元素+val, 当数组长度大于或等于k时，数组的前k个元素+val\r\n\r\n### 代码\r\nJavascript\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize = maxSize;\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length < this.maxSize) {\r\n        this.stack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    let stack = this.stack;\r\n    if ( stack.length > 0) {\r\n        return stack.pop();\r\n    }else {\r\n        return -1;\r\n    }\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const stackLen = this.stack.length;\r\n    let m = stackLen < k ? stackLen : k;\r\n    for(let i = 0; i < m; i++) {\r\n        this.stack[i] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n### 复杂度分析\r\n\r\n时间复杂度O(n)\r\n空间复杂度O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840657882","body":"```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  console.log(s, s.length);\r\n  let stack = s.split(']');\r\n  let arr = [];\r\n  stack = stack.map(item => {\r\n    item = item.split('[');\r\n    console.log('item', item);\r\n    let str = ''\r\n    for(let i = 0; i < item[0]; i ++) {\r\n      str += item[1];\r\n    }\r\n    console.log('str', str)\r\n    arr.push(str)\r\n  });\r\n  return arr.join('');\r\n};\r\n\r\nconst a1 = decodeString('3[a]2[bc]');\r\n\r\nconsole.log('a1', a1);\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841312790","body":"### 思路\r\n使用数组模拟队列\r\n### 代码\r\n\r\nJavaScript\r\n```js\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.stack.shift();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[0];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    if(this.stack.length == 0) {\r\n        return true\r\n    }else {\r\n        return false;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度O(n)\r\n空间复杂度O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lanceli424":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836931206","body":"## 代码\r\n```\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    let kArr: number[] = String(k).split('').map(v => parseInt(v, 10));\r\n    let kLength = kArr.length - 1;\r\n    let numLength = num.length - 1;\r\n    let flag: number = 0;\r\n    while(numLength >= 0 || kLength >= 0 || flag > 0) {\r\n        let kItem = kArr[kLength] || 0;\r\n        let numItem = num[numLength] || 0;\r\n        let sum = numItem + kItem + flag;\r\n        flag = 0;\r\n        if(sum >= 10) {\r\n            flag = 1;\r\n            sum -= 10;\r\n        }\r\n        if(numLength < 0) {\r\n            num.unshift(sum);\r\n        }else {            \r\n            num[numLength] = sum;\r\n        }\r\n        numLength--;\r\n        kLength--;\r\n    }\r\n    return num;\r\n};\r\n```\r\n\r\n## 思路\r\n1. 把数据转换成数组相加\r\n2. 两个数组长度可能不一样长，如果长度不够需要在头部插入\r\n\r\n## 复杂度分析\r\n1. 时间复杂度 O(m+n)，其中 m 是 num 数组长度，n 是 k的长度\r\n2. 空间复杂度 O(m+n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838374436","body":"## 思路\r\n找到匹配的字符，判断离上一个节点近还是下一个节点近。第一匹配到的位置之前和最后一个匹配到的位置之后需要单独处理。\r\n\r\n## 代码\r\n```\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    let result: number[] = [];\r\n    if (s.length === 0 || c.length === 0) {\r\n        return result;\r\n    }\r\n    let strArray = Array.from(s);\r\n    let indexs: number[] = [];\r\n    strArray.forEach((element, index) => {\r\n        if (element === c) {\r\n            indexs.push(index);\r\n        }\r\n    });\r\n    for (let i = 0; i <= indexs[0]; i++) {\r\n        result.push(indexs[0] - i);\r\n    }\r\n    for (let i = 0; i <= indexs.length - 2; i++) {\r\n        let start = indexs[i];\r\n        let end = indexs[i + 1];\r\n        for (let i = start + 1; i <= end; i++) {\r\n            let distance = Math.min(i - start, end - i);\r\n            result.push(distance);\r\n        }\r\n    }\r\n    for (let i = indexs[indexs.length - 1] + 1; i < strArray.length; i++) {\r\n        result.push(i - indexs[indexs.length - 1]);\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n1. 时间复杂度 O(N)\r\n2. 空间复杂度 O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839861269","body":"## 思路\r\n1. 用数组模拟\r\n2. 保留栈长度以及最大容量\r\n\r\n## 代码\r\n```\r\nclass CustomStack {\r\n    stack: number[];\r\n    maxSize: number;\r\n    size: number;\r\n    constructor(maxSize: number) {\r\n        this.stack = [];\r\n        this.maxSize = maxSize;\r\n        this.size = 0;\r\n    }\r\n\r\n    push(x: number): void {\r\n        if (this.size >= this.maxSize) {\r\n            return;\r\n        }\r\n        this.size += 1;\r\n        this.stack.push(x);\r\n    }\r\n\r\n    pop(): number {\r\n        if (this.size <= 0) {\r\n            return -1;\r\n        }\r\n        this.size -= 1;\r\n        return this.stack.pop();\r\n    }\r\n\r\n    increment(k: number, val: number): void {\r\n        let i = 0;\r\n        let size = this.size;\r\n        while (i < size && i < k) {\r\n            this.stack[i] += val;\r\n            i++;\r\n        }\r\n    }\r\n}\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841114910","body":"## 思路\r\n栈是先进后出，队列是先进先出，两个栈模拟队列的话，就是一个出栈一个入栈，当出栈空的时候，把入栈里面的元素拿出来在压入出栈，这样刚好实现先进先出\r\n\r\n## 代码\r\n```\r\nclass MyQueue {\r\n    outStack: number[]\r\n    inStack: number[]\r\n    constructor() {\r\n        this.outStack = [];\r\n        this.inStack = [];\r\n    }\r\n\r\n    push(x: number): void {\r\n        this.inStack.push(x);\r\n    }\r\n\r\n    pop(): number {\r\n        if (this.outStack.length === 0) {\r\n            this.in2out();\r\n        }\r\n        return this.outStack.pop();\r\n    }\r\n\r\n    peek(): number {\r\n        if (this.outStack.length === 0) {\r\n            this.in2out();\r\n        }\r\n        return this.outStack[this.outStack.length - 1];\r\n    }\r\n\r\n    empty(): boolean {\r\n        return this.inStack.length === 0 && this.outStack.length === 0;\r\n    }\r\n\r\n    in2out(): void {\r\n        while (this.inStack.length > 0) {\r\n            this.outStack.push(this.inStack.pop());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n1. 时间复杂度 O(1)\r\n2. 空间复杂度 O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841678744","body":"## 思路\r\n1. 最大逆序的子串必须分到一个块里面，其他块最大长度是剩余数组的长度\r\n2. 最大逆序子串和已排序的子串的和是相同的，如果和相同，长度加1\r\n\r\n## 代码\r\n```\r\nfunction maxChunksToSorted(arr: number[]): number {\r\n    let count: number = 0;\r\n    let sorted = [...arr];\r\n    sorted.sort((a, b) => {\r\n        return a - b;\r\n    });\r\n    const length = arr.length;\r\n    let sum1: number = 0;\r\n    let sum2: number = 0;\r\n    for (let i = 0; i < length; i++) {\r\n        sum1 += arr[i];\r\n        sum2 += sorted[i];\r\n        if (sum1 === sum2) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n};\r\n```\r\n## 复杂度分析\r\n1. 时间复杂度 O(NlogN)\r\n2. 空间复杂度 O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841762640","body":"## 思路\r\n1. 旋转其实是把倒数第 k 个以后的放到前面去\r\n2. 找到倒数第 k 个，然后把这部分节点放到前面去\r\n\r\n## 代码\r\n```\r\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\r\n    if (head === null || head.next === null) {\r\n        return head;\r\n    }\r\n    let count: number = 1;\r\n    let p1 = head;\r\n    while (count <= k && p1.next !== null) {\r\n        p1 = p1.next;\r\n        count++;\r\n    }\r\n    // 长度小于等于 k\r\n    if (count <= k && p1.next === null) {\r\n        let rotate: number = count - k % count;\r\n        let i: number = 1;\r\n        let p2 = head;\r\n        while (i < rotate) {\r\n            p2 = p2.next;\r\n            i++;\r\n        }\r\n        p1.next = head;\r\n        head = p2.next;\r\n        p2.next = null;\r\n        return head;\r\n    }\r\n    let p2 = head;\r\n    while (p2.next && p1.next) {\r\n        p2 = p2.next;\r\n        p1 = p1.next;\r\n    }\r\n    p1.next = head;\r\n    head = p2.next;\r\n    p2.next = null;\r\n    return head;\r\n};\r\n```\r\n## 复杂度分析\r\n1. 时间复杂度 O(N)\r\n2. 空间复杂度 O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lingquan02":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836966361","body":"### 思路\r\n- 位数相加，数组加完后，指针向前移动， 对于k加完后，去掉个位\r\n- 边界 数组len>=0 || k!=0\r\n复杂度：\r\nT= O(n)\r\nS =O(1)\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];// 存放结果\r\n    let len = num.length-1;\r\n    let carry = 0; // 存放进位\r\n\r\n    while(len>=0 || k!=0) {\r\n        const x = len >=0 ? num[len] : 0 // 取最后一位  （个位数）\r\n        const y = k!=0 ? k % 10 : 0; // 取个位数 取模\r\n\r\n        const sum = x+y+carry // 求和  \r\n        res.push(sum%10) // 将个位数放到结果集里\r\n        carry = Math.floor(sum/10) // 存放进位\r\n\r\n        len--;\r\n        k = Math.floor(k/10); // 每次运算完成去掉个位数\r\n    }\r\n\r\n    if(carry) res.push(carry)\r\n    return res.reverse()\r\n};\r\n\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838529295","body":"### 思路分析\r\n- T= O(n)\r\n- S = O(1)\r\n```javascript\r\n// 滑动窗口\r\nconst shortestToChar =(S,C) => {\r\n    let len =S.length;\r\n    let l = S[0] === C ? 0: len-1;\r\n    let r = S.indexOf(C,1); // 从index未1的位置开始找c\r\n    let res = Array(len);\r\n    for(let i=0;i<len;i++) {\r\n        res[i] =Math.min(Math.abs(i-r),Math.abs(l-i))\r\n        // 改变窗口\r\n        if(i===r) {\r\n            l =r; \r\n            r = S.indexOf(C,l+1);\r\n\r\n        }\r\n\r\n    }\r\n    return res\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839776411","body":"### 思路\r\n使用js数组 模拟栈\r\n```javascript\r\nclass CustomStack {\r\n    constructor(maxSize) {\r\n        this.stack = []\r\n        this.maxSize = maxSize\r\n    }\r\n\r\n    push(x) {\r\n        if(this.stack.length>= this.maxSize) return \r\n        this.stack.push(x)\r\n    }\r\n\r\n    pop() {\r\n        if(!this.stack.length) return -1\r\n        return this.stack.pop()\r\n    }\r\n\r\n    increment(k,val) {\r\n        let min = Math.min(k,this.stack.length)\r\n        for(let i=0;i<min;i++) {\r\n            this.stack[i]+=val\r\n        }\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"longlonglu":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837017943","body":"```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] answer = new int[length];\r\n        for (int i = 0; i < length; i++) {\r\n            if (s.charAt(i) == c) { answer[i] = 0; continue; }\r\n            int minDistance = Math.min(leftDistance(s, c, i), rightDistance(s, c, i));\r\n            answer[i] = minDistance;\r\n        }\r\n        return answer;\r\n    }\r\n    public int leftDistance(String s, char c, int index) {\r\n        int counter = 0;\r\n        for (int i = index; i >= 0; i--) {\r\n            if (s.charAt(i) == c) { return counter; }\r\n            counter++;\r\n        }\r\n        return s.length() + 1;\r\n    }\r\n    public int rightDistance(String s, char c, int index) {\r\n        int counter = 0;\r\n        for (int i = index; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) { return counter; }\r\n            counter++;\r\n        }\r\n        return s.length() + 1;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837017943","body":"```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] answer = new int[length];\r\n        for (int i = 0; i < length; i++) {\r\n            if (s.charAt(i) == c) { answer[i] = 0; continue; }\r\n            int minDistance = Math.min(leftDistance(s, c, i), rightDistance(s, c, i));\r\n            answer[i] = minDistance;\r\n        }\r\n        return answer;\r\n    }\r\n    public int leftDistance(String s, char c, int index) {\r\n        int counter = 0;\r\n        for (int i = index; i >= 0; i--) {\r\n            if (s.charAt(i) == c) { return counter; }\r\n            counter++;\r\n        }\r\n        return s.length() + 1;\r\n    }\r\n    public int rightDistance(String s, char c, int index) {\r\n        int counter = 0;\r\n        for (int i = index; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) { return counter; }\r\n            counter++;\r\n        }\r\n        return s.length() + 1;\r\n    }\r\n}\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840713732","body":"```java\r\nclass MyQueue {\r\n        /** Initialize your data structure here. */\r\n        Integer peek;\r\n        Stack<Integer> store;\r\n        public MyQueue() {\r\n            peek = null;\r\n            store = new Stack<>();\r\n        }\r\n        \r\n        /** Push element x to the back of queue. */\r\n        public void push(int x) {\r\n            if(store.isEmpty()) { peek = x; }\r\n            store.add(x);    \r\n        }\r\n        \r\n        /** Removes the element from in front of queue and returns that element. */\r\n       public int pop() {\r\n            if(store.isEmpty()) { return -1; }\r\n            Stack<Integer> temp = new Stack<>();\r\n            int size = store.size();\r\n            for(int i = 0; i < size; i++) {\r\n                temp.add(store.pop());\r\n            }\r\n            int returnValue = temp.pop();\r\n            if(!temp.isEmpty()) {\r\n                peek = temp.peek();\r\n            } else { return returnValue; }\r\n            size = temp.size();\r\n            for(int i = 0; i < size; i++) {\r\n                store.add(temp.pop());\r\n            }\r\n            return returnValue;\r\n        }\r\n        /** Get the front element. */\r\n        public int peek() {\r\n            if(peek == null) { return -1; }\r\n            return peek;     \r\n        }\r\n        \r\n        /** Returns whether the queue is empty. */\r\n        public boolean empty() {\r\n            return store.isEmpty();    \r\n        } \r\n    }   \r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841501072","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int len = arr.length;\r\n        int[] maxarr = new int[len+1];\r\n        int[] minarr = new int[len+1];\r\n        minarr[len] = Integer.MAX_VALUE;\r\n        for(int i=0; i<len; i++){\r\n            maxarr[i+1] = Math.max(arr[i], maxarr[i]);\r\n            minarr[len-i-1] = Math.min(arr[len-i-1], minarr[len-i]);\r\n        }\r\n        int cnt = 0;\r\n        for(int i=0; i<len; i++)\r\n            if(minarr[i+1]>=maxarr[i+1])\r\n                cnt++;\r\n        return cnt;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841738553","body":"```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) { return null; }\r\n        int length = 1;\r\n        ListNode temp = head;\r\n        while (temp.next != null) {  \r\n            length++;\r\n            temp = temp.next;\r\n        }\r\n        int moves = length - (k % length);\r\n        if (moves == length) { return head; }\r\n        temp.next = head;\r\n        temp = head;\r\n        for (int i = 1; i < moves; i++) {\r\n            temp = temp.next;\r\n        }\r\n        ListNode newHead = temp.next;\r\n        temp.next = null;\r\n        return newHead;\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"911gt5":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837256654","body":"TC: O(n)\r\nSC: O(n)\r\n\r\n``` python\r\ndef shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        left = [float('inf')]*n\r\n        right = [float('inf')]*n\r\n        stack = collections.deque()\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                while stack:\r\n                    pre_i= stack.popleft()\r\n                    left[pre_i] = i - pre_i\r\n                left[i] = 0\r\n            else:\r\n                stack.append(i)\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                while stack:\r\n                    post_i = stack.popleft()\r\n                    right[post_i] = post_i -i \r\n                right[i] = 0\r\n            else:\r\n                stack.append(i)\r\n        return [min(l,r) for l,r in zip(left, right)]\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839229965","body":"TC: O(n)  \r\nSC: O(n)\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max_size = maxSize\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1 \r\n        \r\n        res = self.stack[-1]\r\n        self.stack.pop()\r\n        return res\r\n        \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.stack) > k:\r\n            for i in range(k):\r\n                self.stack[i] += val \r\n        else:\r\n            self.stack = [j+val for j in self.stack]\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840115165","body":"TC: 指数级别\r\n```\r\ndef decodeString(self, s: str) -> str:\r\n        u = 0\r\n        def dfs(s):\r\n            nonlocal u\r\n            res = ''\r\n            while u < len(s) and s[u] != ']':\r\n\r\n                if s[u].isalpha():\r\n                    res += s[u]\r\n                    u += 1\r\n                elif s[u].isdigit():\r\n                    k = u\r\n                    while s[k].isdigit():\r\n                        k += 1\r\n\r\n                    x = int(s[u:k])\r\n                    u = k + 1\r\n                    y = dfs(s)\r\n                    u += 1 \r\n\r\n                    while x:\r\n                        res += y\r\n                        x -= 1\r\n            return res\r\n\r\n        return dfs(s)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840837027","body":"```python\r\ndef __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.s1, self.s2 = [], []\r\n        \r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.s1.append(x)\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        :rtype: int\r\n        \"\"\"\r\n        while self.s1:\r\n            self.s2.append(self.s1.pop())\r\n        res = self.s2.pop()\r\n        while self.s2:\r\n            self.s1.append(self.s2.pop())\r\n        return res\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        Get the front element.\r\n        :rtype: int\r\n        \"\"\"\r\n        return self.s1[0]\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        :rtype: bool\r\n        \"\"\"\r\n        return len(self.s1) == 0\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841568116","body":"TC: O(n)\r\n```python\r\ndef maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for a in arr:\r\n            if not stack or a >= stack[-1]:\r\n                stack += a,\r\n            while len(stack) >= 2 and a < stack[-2]:\r\n                j = stack.pop()\r\n                stack[-1] = j\r\n        return len(stack)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841733331","body":"TC = SC = O(n)\r\n```python\r\ndef rotateRight(self, head, k):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :type k: int\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head: return head \r\n        size = self.cal_length(head)\r\n        k = k % size\r\n        if k == 0:\r\n            return head\r\n\r\n        node_k_prev = self.get_kth_node(head, size - k)\r\n        node_k = node_k_prev.next\r\n        tail = self.get_kth_node(head, size)\r\n        tail.next = head\r\n        node_k_prev.next = None\r\n\r\n        return node_k\r\n        \r\n        \r\n        \r\n    def cal_length(self, head):\r\n        n = 0\r\n        curr = head\r\n        while curr:\r\n            n += 1 \r\n            curr = curr.next\r\n        return n \r\n    \r\n    def get_kth_node(self, head, k):\r\n        curr = head \r\n        for i in range(1, k):\r\n            curr = curr.next \r\n        return curr\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"prince805962788":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837860923","body":"### 思路\r\n双指针，从每个点出发，想左右搜寻，直到找到等于所给字符的点，然后分别算出距离，取其中最小的记录到数组中\r\n### 代码（js）\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    const res = []\r\n    for(let i=0;i<s.length;i++){\r\n        let left = i\r\n        let right = i\r\n        while(left>=0){\r\n            if(s[left] === c) break\r\n            left--\r\n        }\r\n        while(right<s.length){\r\n            if(s[right] === c) break\r\n            right++\r\n        }\r\n        if(left === -1) left = -Infinity\r\n        if(right === s.length) right = Infinity\r\n        res[i] = Math.min(i-left, right-i)\r\n    }\r\n    return res\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839366048","body":"### JS\r\n思路：数组模拟栈\r\n````\r\nvar CustomStack = function(maxSize) {\r\n    this.stack = []\r\n    this.maxSize = maxSize\r\n};\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.stack.length < this.maxSize) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\nCustomStack.prototype.pop = function() {\r\n    if(this.stack.length === 0) return -1\r\n    let item = this.stack.pop()\r\n    return item\r\n};\r\nCustomStack.prototype.increment = function(k, val) {\r\n    if(k>=this.stack.length){\r\n        for(let i=0;i<this.stack.length;i++){\r\n            this.stack[i] += val\r\n        }\r\n    }else {\r\n        for(let i=0;i<k;i++){\r\n            this.stack[i] += val\r\n        }\r\n    }\r\n};\r\n````"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840227944","body":"### 思路(JS)\r\n双指针，一个存数字，一个存当前字符串\r\n````\r\nvar decodeString = function(s) {\r\n    const numStack = []\r\n    const strStack = []\r\n    let num = 0\r\n    let res = ''\r\n    let index = 0\r\n    while(index<s.length){\r\n        if(s[index].match(/[0-9]/)){\r\n            num = num * 10 + Number(s[index])\r\n        }else if(s[index] === '['){\r\n            numStack.push(num)\r\n            strStack.push(res)\r\n            num = 0\r\n            res = ''\r\n        }else if(s[index] === ']'){\r\n            res = strStack.pop() + res.repeat(numStack.pop())\r\n        }else {\r\n            res = res + s[index]\r\n        }\r\n        index++\r\n    }\r\n    return res\r\n};\r\n````\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840942687","body":"### JS\r\n````\r\nclass MyQueue {\r\n    constructor () {\r\n        this.pushArr = [];\r\n        this.popArr = [];\r\n    }\r\n    push (element) {\r\n        this.pushArr.push(element);\r\n    }\r\n    pop () {\r\n        if (this.popArr.length === 0) {\r\n            while (this.pushArr.length > 0) {\r\n                this.popArr.push(this.pushArr.pop());\r\n            }\r\n        }\r\n        return this.popArr.pop();\r\n    }\r\n    peek () {\r\n        if (this.popArr.length === 0) {\r\n            while (this.pushArr.length > 0) {\r\n                this.popArr.push(this.pushArr.pop());\r\n            }\r\n        }\r\n        return this.popArr[this.popArr.length - 1];\r\n    }\r\n    empty () {\r\n        return !this.pushArr.length && !this.popArr.length;\r\n    }\r\n}\r\n````"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841581463","body":"### JS思路\r\n每一个分块和排序后的数组中对应的分块数字是一样的，只是排序不同，所以每个分块的合排序前后也是一样的\r\n````\r\nvar maxChunksToSorted = function (arr) {\r\n    const sorted = [...arr];\r\n    sorted.sort((a, b) => a - b);\r\n\r\n    let count = 0;\r\n    let sum1 = 0;\r\n    let sum2 = 0;\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        sum1 += arr[i];\r\n        sum2 += sorted[i];\r\n\r\n        if (sum1 === sum2) {\r\n            count++;\r\n            sum1 = 0;\r\n            sum2 = 0;\r\n        }\r\n    }\r\n\r\n    return count;\r\n};\r\n````"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyk1337":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837931988","body":"# Approach\r\n- Left-to-right: count the distance on the right\r\n- Right-to-left: count the distance on the left\r\n- Take the minimum at each position\r\n\r\n# Python Implementation\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        distance = 10001\r\n        n = len(s)\r\n        res = []\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                distance = 0\r\n            res.append(distance)\r\n            distance += 1\r\n        \r\n        distance = 10001\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                distance = 0\r\n            res[i] = min(distance, res[i])\r\n            distance += 1\r\n        return res\r\n```\r\n\r\n# Complexity analysis\r\n- Time: O(n)\r\n- Space: O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839606507","body":"# Approach\r\n- Stack\r\n\r\n# Python Implementation\r\n```python\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.stack:\r\n            x = self.stack.pop()\r\n        else:\r\n            x = -1\r\n        return x\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        for i in range(min(len(self.stack), k)):\r\n            self.stack[i] += val\r\n```\r\n\r\n# Complexity Analysis\r\n- Time O(1)\r\n- Space O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840661629","body":"# Approach\r\n- Handle continuous digits, `[`, `]`, and other chars.\r\n\r\n# Python Implementation\r\n```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        stack = []\r\n        n = 0\r\n        res = \"\"\r\n        for c in s:\r\n            if '0' <= c <= '9':\r\n                n = n * 10 + int(c)\r\n            elif c == '[':\r\n                stack.append([n, res])\r\n                n = 0\r\n                res = \"\"\r\n            elif c == ']':\r\n                cur_n, last_res = stack.pop()\r\n                res = last_res + cur_n * res\r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n\r\n# Time Complexity\r\n- Time O(n)\r\n- Space O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840677617","body":"# Approach\r\nUse two stacks to get a queue\r\n\r\n# Python Implementation\r\n```python\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.s1 = []\r\n        self.s2 = []\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.s1.append(x)\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        :rtype: int\r\n        \"\"\"\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop())\r\n        return self.s2.pop()\r\n\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        Get the front element.\r\n        :rtype: int\r\n        \"\"\"\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop())\r\n        return self.s2[-1]\r\n\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        :rtype: bool\r\n        \"\"\"\r\n        return not self.s1 and not self.s2\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n# Complexity Analysis\r\n- Time complexity: push O(1), peek/pop amortized O(1)\r\n- Space complexity O(n)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"YanFaFa":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838156207","body":"\r\nclass Solution {\r\n\r\n    /**\r\n     * @param String $s\r\n     * @param String $c\r\n     * @return Integer[]\r\n     */\r\n    function shortestToChar($s, $c) {\r\n        $target = [];\r\n        $len = strlen($s);\r\n        $targetLen = 0;\r\n        for ($i=0; $i<$len; $i++) {\r\n            if ($s[$i] == $c) {\r\n                array_push($target, $i);\r\n                $targetLen++;\r\n            }\r\n        }\r\n\r\n        for ($i = 0; $i<$len; $i++) {\r\n            if ($s[$i] == $c) {\r\n                $result[] = 0;\r\n            } else {\r\n                $num = $len;\r\n                for ($j = 0; $j<$targetLen;$j++) {\r\n                    $tmp = abs($target[$j] - $i);\r\n                    if ($tmp < $num) {\r\n                        $num = $tmp; \r\n                    } else {\r\n                        continue;\r\n                    }\r\n                }\r\n                $result[] = $num;\r\n            } \r\n        }\r\n        return $result;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839383268","body":"just translate it?\r\n\r\nclass CustomStack {\r\n    /**\r\n     * @param Integer $maxSize\r\n     */\r\n    public $maxSize;\r\n\r\n    function __construct($maxSize) {\r\n        $this->maxSize = $maxSize;\r\n    }\r\n\r\n    /**\r\n     * @param Integer $x\r\n     * @return NULL\r\n     */\r\n    function push($x) {\r\n        if($this->curSize === $this->maxSize)\r\n            return -1;\r\n        $this->stack[] = $x;\r\n        $this->curSize++;\r\n    }\r\n\r\n    /**\r\n     * @return Integer\r\n     */\r\n    function pop() {\r\n        if(!$this->curSize)\r\n            return -1;\r\n        $this->curSize--;\r\n        return array_pop($this->stack);\r\n    }\r\n\r\n    /**\r\n     * @param Integer $k\r\n     * @param Integer $val\r\n     * @return NULL\r\n     */\r\n    function increment($k, $val) {\r\n        if($this->curSize < $k)\r\n            // for($i=0; $i<$this->curSize; $i++)\r\n            //     $this->stack[$i]+=$val;\r\n            foreach($this->stack as &$num)\r\n                $num+=$val;\r\n        else\r\n            for($i=0; $i<$k; $i++)\r\n                $this->stack[$i]+=$val;\r\n    }\r\n}\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840539820","body":"the function 'str_repeat' should not be used.Waiting for optimization\r\n\r\nclass Solution {\r\n\r\n    /**\r\n     * @param String $s\r\n     * @return String\r\n     */\r\n    function decodeString($s) {\r\n        $len_s = strlen($s);\r\n        $stack = new SplStack();\r\n        for ($i = 0; $i < $len_s; $i++) {\r\n            if ($s[$i] != ']') {\r\n                $stack->push($s[$i]);\r\n                continue;\r\n            }\r\n            $repeat_str = \"\";\r\n            while (!$stack->isEmpty() && $stack->top() != '[') {\r\n                $repeat_str = $stack->pop(). $repeat_str;\r\n            }\r\n            $stack->pop();\r\n            $repeat_times = \"\";\r\n            while (!$stack->isEmpty() && is_numeric($stack->top())) {\r\n                $repeat_times = $stack->pop(). $repeat_times;\r\n            }\r\n            $temp = str_repeat($repeat_str, $repeat_times);\r\n            $stack->push($temp);\r\n        }\r\n\r\n        $res = \"\";\r\n        while (!$stack->isEmpty()) {\r\n            $res = $stack->pop(). $res;\r\n        }\r\n\r\n        return $res;\r\n    }\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"RealDuxy":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838328793","body":"#### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n#### 思路：\r\n\r\n暴力等等方法很简答，我们尝试双指针方法。\r\n构建result数组，由左向右遍历一遍，记录右边离你最近的c字符的距离，遍历 i 时可以利用已经完成的 i-1的结果。\r\n\r\n遍历完毕后，我们由右向左遍历，相当于比较左边和右边最近的c字符的距离哪个更小，取最小的来替代result[i]\r\n\r\n#### 代码 python\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [math.inf] * len(s)\r\n        # 从左至右遍历一遍\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n            elif i > 0:\r\n                result[i] = result[i-1] + 1\r\n       \r\n        # 从右至左\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n            elif i < len(s)-1:\r\n                result[i] = min(result[i+1]+1, result[i])\r\n        return result\r\n```\r\n\r\n\r\n\r\n#### 复杂度分析:\r\n\r\n时间复杂度：\r\n\r\n两次遍历都是N次迭代，每次迭代都是常数操作，显然是O(N)\r\n\r\n空间复杂度:\r\n\r\n除了result外，没有构建额外的数组，均在result原地操作，故O(1)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838328793","body":"#### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n#### 思路：\r\n\r\n暴力等等方法很简答，我们尝试双指针方法。\r\n构建result数组，由左向右遍历一遍，记录右边离你最近的c字符的距离，遍历 i 时可以利用已经完成的 i-1的结果。\r\n\r\n遍历完毕后，我们由右向左遍历，相当于比较左边和右边最近的c字符的距离哪个更小，取最小的来替代result[i]\r\n\r\n#### 代码 python\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [math.inf] * len(s)\r\n        # 从左至右遍历一遍\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n            elif i > 0:\r\n                result[i] = result[i-1] + 1\r\n       \r\n        # 从右至左\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n            elif i < len(s)-1:\r\n                result[i] = min(result[i+1]+1, result[i])\r\n        return result\r\n```\r\n\r\n\r\n\r\n#### 复杂度分析:\r\n\r\n时间复杂度：\r\n\r\n两次遍历都是N次迭代，每次迭代都是常数操作，显然是O(N)\r\n\r\n空间复杂度:\r\n\r\n除了result外，没有构建额外的数组，均在result原地操作，故O(1)\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841211519","body":"## Day 5 [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\r\n\r\n### 思路：\r\n\r\n利用两个栈和一个栈顶指针\r\n\r\n栈一用于存储队列元素，但是栈的存储顺序是与队列相反的，所以需要栈二来做一个逆序。\r\n\r\n输出和判断空时候直接按照栈一的正常操作即可。\r\n\r\n注意在pop的时候要注意更新栈顶\r\n\r\n### 代码\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.第一个栈 = []\r\n        self.第二个栈 = []\r\n        self.栈顶 = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        if not self.第一个栈:\r\n            self.第一个栈.append(x)\r\n            self.栈顶 = x\r\n        else:\r\n            while self.第一个栈:\r\n                self.第二个栈.append(self.第一个栈.pop())\r\n            self.第一个栈.append(x)\r\n            while self.第二个栈:\r\n                self.第一个栈.append(self.第二个栈.pop())\r\n        \r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        旧栈顶 = self.第一个栈.pop()\r\n        if self.第一个栈:\r\n            self.栈顶 = self.第一个栈[-1]\r\n        else:\r\n            self.栈顶 = -1\r\n        return 旧栈顶\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.栈顶\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.第一个栈\r\n\r\n```\r\n\r\n### 复杂度分析：\r\n\r\n时间：push操作，需要做两次栈之间的转移，复杂度为O（N），其余的操作明显为O（1）\r\n\r\n空间: 额外空间O（N）两个栈，一个指针"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841645360","body":"### [768. 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\r\n\r\n#### 思路：\r\n\r\n定义好排序快，根据排序块确定遍历规则\r\n\r\n#### 代码 python\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for x in arr:\r\n            if stack and x < stack[-1]: # stack[-1]为所有排序块的最大head\r\n                # 记录下当前最大的排序块head\r\n                # x < head说明这个x使得之前的head都不在有效，因此成为了新的排序块右边界\r\n                # 现在需要为其确定包含x的最大head，因此就在stack里面找到最大的小于等于x的head\r\n                # 找到后再将head放回stack里面 \r\n                head = stack.pop()\r\n                while stack and x < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(head)\r\n            else:\r\n                # x隶属于最大head的排序块\r\n                stack.append(x)\r\n        return len(stack)\r\n```\r\n\r\n\r\n\r\n#### 复杂度：\r\n\r\n遍历n次，极端情况下，一次遍历需要将stack内全部的head弹出，但是stack总共弹出的次数也不会超过N次，因此时间复杂度O（N）。\r\n\r\n借助了栈的额外空间，最多存储arr所有元素，O（N）。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaofaqian":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838329911","body":"## 思路\r\n双指针吧 从当前位置开始比对 然后往左偏移往比对往右偏移比对\r\n## 代码\r\n```\r\nSarr := []byte{}\r\n\tSP := []int{}\r\n\tfor _, v := range s {\r\n\t\tSarr = append(Sarr, byte(v))\r\n\t}\r\n\tfor i := 0; i < len(Sarr); i++ {\r\n\t\tstep := 0\r\n\r\n\t\tfor true {\r\n\t\t\tif i+step < len(Sarr) && Sarr[i+step] == c {\r\n\t\t\t\tSP = append(SP, step)\r\n\t\t\t\tstep = 1\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tif i-step >= 0 && Sarr[i-step] == c {\r\n\t\t\t\tSP = append(SP, step)\r\n\t\t\t\tstep = 1\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tstep++\r\n\t\t}\r\n\t}\r\n\treturn SP\r\n```\r\n## 复杂度\r\n- 时间复杂度 O(n2)\r\n- 空间复杂度 O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839512591","body":"## 思路\r\n## 代码\r\n```type CustomStack struct {\r\n\tmaxSize  int\r\n\tstackLen int\r\n\tstack    []int\r\n}\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n\treturn CustomStack{maxSize, 0, []int{}}\r\n}\r\n\r\nfunc (this *CustomStack) Push(x int) {\r\n\t//满了就不加了\r\n\tif this.maxSize == this.stackLen {\r\n\t\treturn\r\n\t}\r\n\t//添加一个元素并且栈长度加1\r\n\tthis.stack = append(this.stack, x)\r\n\tthis.stackLen++\r\n}\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n\tif this.stackLen == 0 {\r\n\t\treturn -1\r\n\t}\r\n\tpopValue := this.stack[this.stackLen-1]\r\n\tthis.stackLen--\r\n\tthis.stack = this.stack[:this.stackLen]\r\n\treturn popValue\r\n}\r\n\r\nfunc (this *CustomStack) Increment(k int, val int) {\r\n\tif k > this.stackLen {\r\n\t\tk = this.stackLen\r\n\t}\r\n\tfor i := 0; i < k; i++ {\r\n\t\tthis.stack[i] = this.stack[i] + val\r\n\t}\r\n}\r\n\r\n```\r\n## 复杂度\r\n- 时间复杂度 push/pop O(1) 元素加数 ）O(k)\r\n- 空间复杂度 O(maxSize)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841278444","body":"## 思路\r\n## 代码\r\n```\r\ntype MyQueue struct {\r\n\tqueueLen int\r\n\tqueue    []int\r\n}\r\n\r\n/** Initialize your data structure here. */\r\nfunc Constructor() MyQueue {\r\n\treturn MyQueue{0, []int{}}\r\n}\r\n\r\n/** Push element x to the back of queue. */\r\nfunc (this *MyQueue) Push(x int) {\r\n\tthis.queue = append(this.queue, x)\r\n\tthis.queueLen++\r\n}\r\n\r\n/** Removes the element from in front of queue and returns that element. */\r\nfunc (this *MyQueue) Pop() int {\r\n\tif this.queueLen == 0 {\r\n\t\treturn -1\r\n\t}\r\n\tval := this.queue[0]\r\n\tthis.queueLen--\r\n\tthis.queue = this.queue[1:]\r\n\treturn val\r\n}\r\n\r\n/** Get the front element. */\r\nfunc (this *MyQueue) Peek() int {\r\n\tif this.queueLen == 0 {\r\n\t\treturn -1\r\n\t}\r\n\treturn this.queue[0]\r\n}\r\n\r\n/** Returns whether the queue is empty. */\r\nfunc (this *MyQueue) Empty() bool {\r\n\tif this.queueLen == 0 {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n```\r\n## 复杂度\r\n- 时间复杂度 $O(1)$\r\n- 空间复杂度 $O(n)$"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838409646","body":"# 821.字符的最短距离\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n- [821.字符的最短距离](#821字符的最短距离)\r\n  - [题目描述](#题目描述)\r\n  - [解法 1：中心扩展法](#解法-1中心扩展法)\r\n    - [思路](#思路)\r\n    - [复杂度分析](#复杂度分析)\r\n    - [代码 (JS/C++)](#代码-jsc)\r\n  - [解法 2：空间换时间](#解法-2空间换时间)\r\n    - [思路](#思路-1)\r\n    - [复杂度分析](#复杂度分析-1)\r\n    - [代码 (JS/C++)](#代码-jsc-1)\r\n  - [解法 3：贪心](#解法-3贪心)\r\n    - [思路](#思路-2)\r\n    - [复杂度分析](#复杂度分析-2)\r\n    - [代码 (JS/C++/Python)](#代码-jscpython)\r\n  - [解法 4：窗口](#解法-4窗口)\r\n    - [思路](#思路-3)\r\n    - [复杂度分析](#复杂度分析-3)\r\n    - [代码 (JS/C++/Python)](#代码-jscpython-1)\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n字符串 S 的长度范围为 [1, 10000]。\r\nC 是一个单字符，且保证是字符串 S 里的字符。\r\nS 和 C 中的所有字母均为小写字母。\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n```\r\n\r\n## 解法 1：中心扩展法\r\n\r\n### 思路\r\n\r\n这是最符合直觉的思路，对每个字符分别进行如下处理：\r\n\r\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 `C`。\r\n- 只在一个方向找到的话，直接计算字符距离。\r\n- 两个方向都找到的话，取两个距离的最小值。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_0.png)\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 结果数组 res\r\n  var res = Array(S.length).fill(0);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 如果当前是目标字符，就什么都不用做\r\n    if (S[i] === C) continue;\r\n\r\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\r\n    let l = i,\r\n      r = i,\r\n      shortest = Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (S[l] === C) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r < S.length) {\r\n      if (S[r] === C) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        vector<int> res(S.length());\r\n\r\n        for (int i = 0; i < S.length(); i++) {\r\n            if (S[i] == C) continue;\r\n\r\n            int left = i;\r\n            int right = i;\r\n            int dist = 0;\r\n\r\n            while (left >= 0 || right <= S.length() - 1) {\r\n                if (S[left] == C) {\r\n                    dist = i - left;\r\n                    break;\r\n                }\r\n                if (S[right] == C) {\r\n                    dist = right - i;\r\n                    break;\r\n                }\r\n\r\n                if (left > 0) left--;\r\n                if (right < S.length() - 1) right++;\r\n            }\r\n\r\n            res[i] = dist;\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 解法 2：空间换时间\r\n\r\n### 思路\r\n\r\n空间换时间是编程中很常见的一种 trade-off (反过来，时间换空间也是)。\r\n\r\n因为目标字符 `C` 在 `S` 中的位置是不变的，所以我们可以提前将 `C` 的所有下标记录在一个数组 `cIndices` 中。\r\n\r\n然后遍历字符串 `S` 中的每个字符，到 `cIndices` 中找到距离当前位置最近的下标，计算距离。\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N*K)$，N 是 S 的长度，K 是字符 `C` 在字符串中出现的次数，$K <= N$。\r\n- 空间复杂度：$O(K)$，K 为字符 `C` 出现的次数，这是记录字符 `C` 出现下标的辅助数组消耗的空间。\r\n\r\n### 代码 (JS/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 记录 C 字符在 S 字符串中出现的所有下标\r\n  var cIndices = [];\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) cIndices.push(i);\r\n  }\r\n\r\n  // 结果数组 res\r\n  var res = Array(S.length).fill(Infinity);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 目标字符，距离是 0\r\n    if (S[i] === C) {\r\n      res[i] = 0;\r\n      continue;\r\n    }\r\n\r\n    // 非目标字符，到下标数组中找最近的下标\r\n    for (const cIndex of cIndices) {\r\n      const dist = Math.abs(cIndex - i);\r\n\r\n      // 小小剪枝一下\r\n      // 注：因为 cIndices 中的下标是递增的，后面的 dist 也会越来越大，可以排除\r\n      if (dist >= res[i]) break;\r\n\r\n      res[i] = dist;\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n        vector<int> c_indices;\r\n        // Initialize a vector of size n with default value n.\r\n        vector<int> res(n, n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) c_indices.push_back(i);\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) {\r\n                res[i] = 0;\r\n                continue;\r\n            }\r\n\r\n            for (int j = 0; j < c_indices.size(); j++) {\r\n                int dist = abs(c_indices[j] - i);\r\n                if (dist > res[i]) break;\r\n                res[i] = dist;\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 解法 3：贪心\r\n\r\n### 思路\r\n\r\n其实对于每个字符来说，它只关心离它最近的那个 `C` 字符，其他的它都不管。所以这里还可以用贪心的思路：\r\n\r\n1. 先 `从左往右` 遍历字符串 `S`，用一个数组 left 记录每个字符 `左侧` 出现的最后一个 `C` 字符的下标；\r\n2. 再 `从右往左` 遍历字符串 `S`，用一个数组 right 记录每个字符 `右侧` 出现的最后一个 `C` 字符的下标；\r\n3. 然后同时遍历这两个数组，计算距离最小值。\r\n\r\n**优化 1**\r\n\r\n再多想一步，其实第二个数组并不需要。因为对于左右两侧的 `C` 字符，我们也只关心其中距离更近的那一个，所以第二次遍历的时候可以看情况覆盖掉第一个数组的值：\r\n\r\n1. 字符左侧没有出现过 `C` 字符\r\n2. `i - left` > `right - i` (i 为当前字符下标，left 为字符左侧最近的 `C` 下标，right 为字符右侧最近的 `C` 下标)\r\n\r\n如果出现以上两种情况，就可以进行覆盖，最后再遍历一次数组计算距离。\r\n\r\n**优化 2**\r\n\r\n如果我们是直接记录 `C` 与当前字符的距离，而不是记录 `C` 的下标，还可以省掉最后一次遍历计算距离的过程。\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，N 是 S 的长度。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++/Python)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  var res = Array(S.length);\r\n\r\n  // 第一次遍历：从左往右\r\n  // 找到出现在左侧的 C 字符的最后下标\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) res[i] = i;\r\n    // 如果左侧没有出现 C 字符的话，用 Infinity 进行标记\r\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1];\r\n  }\r\n\r\n  // 第二次遍历：从右往左\r\n  // 找出现在右侧的 C 字符的最后下标\r\n  // 如果左侧没有出现过 C 字符，或者右侧出现的 C 字符距离更近，就更新 res[i]\r\n  for (let i = S.length - 1; i >= 0; i--) {\r\n    if (res[i] === Infinity || res[i + 1] - i < i - res[i]) res[i] = res[i + 1];\r\n  }\r\n\r\n  // 计算距离\r\n  for (let i = 0; i < res.length; i++) {\r\n    res[i] = Math.abs(res[i] - i);\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n**直接计算距离：**\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  var res = Array(S.length);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) res[i] = 0;\r\n    // 记录距离：res[i - 1] + 1\r\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1] + 1;\r\n  }\r\n\r\n  for (let i = S.length - 1; i >= 0; i--) {\r\n    // 更新距离：res[i + 1] + 1\r\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1;\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n        vector<int> dist(n, n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) dist[i] = 0;\r\n            else if (i > 0) dist[i] = dist[i - 1] + 1;\r\n        }\r\n\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (dist[i] == n\r\n                || (i < n - 1 && dist[i + 1] + 1 < dist[i]))\r\n                    dist[i] = dist[i + 1] + 1;\r\n        }\r\n\r\n        return dist;\r\n    }\r\n};\r\n```\r\n\r\nPython Code\r\n\r\n```py\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        res = [0 if s[i] == c else None for i in range(n)]\r\n\r\n        for i in range(1, n):\r\n            if res[i] != 0 and res[i - 1] is not None:\r\n                res[i] = res[i - 1] + 1\r\n\r\n        for i in range(n - 2, -1, -1):\r\n            if res[i] is None or res[i + 1] + 1 < res[i]:\r\n                res[i] = res[i + 1] + 1\r\n        return res\r\n```\r\n\r\n## 解法 4：窗口\r\n\r\n### 思路\r\n\r\n把 `C` 看成分界线，将 `S` 划分成一个个窗口。然后对每个窗口进行遍历，分别计算每个字符到窗口边界的距离最小值。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_1.png)\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，N 是 S 的长度。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++/Python)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 窗口左边界，如果没有就初始化为 Infinity，初始化为 S.length 也可以\r\n  let l = S[0] === C ? 0 : Infinity,\r\n    // 窗口右边界\r\n    r = S.indexOf(C, 1);\r\n\r\n  const res = Array(S.length);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 计算字符到当前窗口左右边界的最小距离\r\n    res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\r\n\r\n    // 遍历完了当前窗口的字符后，将整个窗口右移\r\n    if (i === r) {\r\n      l = r;\r\n      r = S.indexOf(C, l + 1);\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n\r\n        int l = S[0] == C ? 0 : n;\r\n        int r = S.find(C, 1);\r\n\r\n        vector<int> dist(n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            dist[i] = min(abs(i - l), abs(r - i));\r\n            if (i == r) {\r\n                l = r;\r\n                r = S.find(C, r + 1);\r\n            }\r\n        }\r\n\r\n        return dist;\r\n    }\r\n};\r\n```\r\n\r\nPython Code\r\n\r\n```py\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        res = [0 for _ in range(n)]\r\n\r\n        l = 0 if s[0] == c else n\r\n        r = s.find(c, 1)\r\n\r\n        for i in range(n):\r\n            res[i] = min(abs(i - l), abs(r - i))\r\n            if i == r:\r\n                l = r\r\n                r = s.find(c, l + 1)\r\n        return res\r\n```\r\n\r\n更多题解可以访问：[https://github.com/suukii/91-days-algorithm](https://github.com/suukii/91-days-algorithm)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838409646","body":"# 821.字符的最短距离\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n- [821.字符的最短距离](#821字符的最短距离)\r\n  - [题目描述](#题目描述)\r\n  - [解法 1：中心扩展法](#解法-1中心扩展法)\r\n    - [思路](#思路)\r\n    - [复杂度分析](#复杂度分析)\r\n    - [代码 (JS/C++)](#代码-jsc)\r\n  - [解法 2：空间换时间](#解法-2空间换时间)\r\n    - [思路](#思路-1)\r\n    - [复杂度分析](#复杂度分析-1)\r\n    - [代码 (JS/C++)](#代码-jsc-1)\r\n  - [解法 3：贪心](#解法-3贪心)\r\n    - [思路](#思路-2)\r\n    - [复杂度分析](#复杂度分析-2)\r\n    - [代码 (JS/C++/Python)](#代码-jscpython)\r\n  - [解法 4：窗口](#解法-4窗口)\r\n    - [思路](#思路-3)\r\n    - [复杂度分析](#复杂度分析-3)\r\n    - [代码 (JS/C++/Python)](#代码-jscpython-1)\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n字符串 S 的长度范围为 [1, 10000]。\r\nC 是一个单字符，且保证是字符串 S 里的字符。\r\nS 和 C 中的所有字母均为小写字母。\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n```\r\n\r\n## 解法 1：中心扩展法\r\n\r\n### 思路\r\n\r\n这是最符合直觉的思路，对每个字符分别进行如下处理：\r\n\r\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 `C`。\r\n- 只在一个方向找到的话，直接计算字符距离。\r\n- 两个方向都找到的话，取两个距离的最小值。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_0.png)\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 结果数组 res\r\n  var res = Array(S.length).fill(0);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 如果当前是目标字符，就什么都不用做\r\n    if (S[i] === C) continue;\r\n\r\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\r\n    let l = i,\r\n      r = i,\r\n      shortest = Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (S[l] === C) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r < S.length) {\r\n      if (S[r] === C) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        vector<int> res(S.length());\r\n\r\n        for (int i = 0; i < S.length(); i++) {\r\n            if (S[i] == C) continue;\r\n\r\n            int left = i;\r\n            int right = i;\r\n            int dist = 0;\r\n\r\n            while (left >= 0 || right <= S.length() - 1) {\r\n                if (S[left] == C) {\r\n                    dist = i - left;\r\n                    break;\r\n                }\r\n                if (S[right] == C) {\r\n                    dist = right - i;\r\n                    break;\r\n                }\r\n\r\n                if (left > 0) left--;\r\n                if (right < S.length() - 1) right++;\r\n            }\r\n\r\n            res[i] = dist;\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 解法 2：空间换时间\r\n\r\n### 思路\r\n\r\n空间换时间是编程中很常见的一种 trade-off (反过来，时间换空间也是)。\r\n\r\n因为目标字符 `C` 在 `S` 中的位置是不变的，所以我们可以提前将 `C` 的所有下标记录在一个数组 `cIndices` 中。\r\n\r\n然后遍历字符串 `S` 中的每个字符，到 `cIndices` 中找到距离当前位置最近的下标，计算距离。\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N*K)$，N 是 S 的长度，K 是字符 `C` 在字符串中出现的次数，$K <= N$。\r\n- 空间复杂度：$O(K)$，K 为字符 `C` 出现的次数，这是记录字符 `C` 出现下标的辅助数组消耗的空间。\r\n\r\n### 代码 (JS/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 记录 C 字符在 S 字符串中出现的所有下标\r\n  var cIndices = [];\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) cIndices.push(i);\r\n  }\r\n\r\n  // 结果数组 res\r\n  var res = Array(S.length).fill(Infinity);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 目标字符，距离是 0\r\n    if (S[i] === C) {\r\n      res[i] = 0;\r\n      continue;\r\n    }\r\n\r\n    // 非目标字符，到下标数组中找最近的下标\r\n    for (const cIndex of cIndices) {\r\n      const dist = Math.abs(cIndex - i);\r\n\r\n      // 小小剪枝一下\r\n      // 注：因为 cIndices 中的下标是递增的，后面的 dist 也会越来越大，可以排除\r\n      if (dist >= res[i]) break;\r\n\r\n      res[i] = dist;\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n        vector<int> c_indices;\r\n        // Initialize a vector of size n with default value n.\r\n        vector<int> res(n, n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) c_indices.push_back(i);\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) {\r\n                res[i] = 0;\r\n                continue;\r\n            }\r\n\r\n            for (int j = 0; j < c_indices.size(); j++) {\r\n                int dist = abs(c_indices[j] - i);\r\n                if (dist > res[i]) break;\r\n                res[i] = dist;\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 解法 3：贪心\r\n\r\n### 思路\r\n\r\n其实对于每个字符来说，它只关心离它最近的那个 `C` 字符，其他的它都不管。所以这里还可以用贪心的思路：\r\n\r\n1. 先 `从左往右` 遍历字符串 `S`，用一个数组 left 记录每个字符 `左侧` 出现的最后一个 `C` 字符的下标；\r\n2. 再 `从右往左` 遍历字符串 `S`，用一个数组 right 记录每个字符 `右侧` 出现的最后一个 `C` 字符的下标；\r\n3. 然后同时遍历这两个数组，计算距离最小值。\r\n\r\n**优化 1**\r\n\r\n再多想一步，其实第二个数组并不需要。因为对于左右两侧的 `C` 字符，我们也只关心其中距离更近的那一个，所以第二次遍历的时候可以看情况覆盖掉第一个数组的值：\r\n\r\n1. 字符左侧没有出现过 `C` 字符\r\n2. `i - left` > `right - i` (i 为当前字符下标，left 为字符左侧最近的 `C` 下标，right 为字符右侧最近的 `C` 下标)\r\n\r\n如果出现以上两种情况，就可以进行覆盖，最后再遍历一次数组计算距离。\r\n\r\n**优化 2**\r\n\r\n如果我们是直接记录 `C` 与当前字符的距离，而不是记录 `C` 的下标，还可以省掉最后一次遍历计算距离的过程。\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，N 是 S 的长度。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++/Python)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  var res = Array(S.length);\r\n\r\n  // 第一次遍历：从左往右\r\n  // 找到出现在左侧的 C 字符的最后下标\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) res[i] = i;\r\n    // 如果左侧没有出现 C 字符的话，用 Infinity 进行标记\r\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1];\r\n  }\r\n\r\n  // 第二次遍历：从右往左\r\n  // 找出现在右侧的 C 字符的最后下标\r\n  // 如果左侧没有出现过 C 字符，或者右侧出现的 C 字符距离更近，就更新 res[i]\r\n  for (let i = S.length - 1; i >= 0; i--) {\r\n    if (res[i] === Infinity || res[i + 1] - i < i - res[i]) res[i] = res[i + 1];\r\n  }\r\n\r\n  // 计算距离\r\n  for (let i = 0; i < res.length; i++) {\r\n    res[i] = Math.abs(res[i] - i);\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n**直接计算距离：**\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  var res = Array(S.length);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) res[i] = 0;\r\n    // 记录距离：res[i - 1] + 1\r\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1] + 1;\r\n  }\r\n\r\n  for (let i = S.length - 1; i >= 0; i--) {\r\n    // 更新距离：res[i + 1] + 1\r\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1;\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n        vector<int> dist(n, n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) dist[i] = 0;\r\n            else if (i > 0) dist[i] = dist[i - 1] + 1;\r\n        }\r\n\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (dist[i] == n\r\n                || (i < n - 1 && dist[i + 1] + 1 < dist[i]))\r\n                    dist[i] = dist[i + 1] + 1;\r\n        }\r\n\r\n        return dist;\r\n    }\r\n};\r\n```\r\n\r\nPython Code\r\n\r\n```py\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        res = [0 if s[i] == c else None for i in range(n)]\r\n\r\n        for i in range(1, n):\r\n            if res[i] != 0 and res[i - 1] is not None:\r\n                res[i] = res[i - 1] + 1\r\n\r\n        for i in range(n - 2, -1, -1):\r\n            if res[i] is None or res[i + 1] + 1 < res[i]:\r\n                res[i] = res[i + 1] + 1\r\n        return res\r\n```\r\n\r\n## 解法 4：窗口\r\n\r\n### 思路\r\n\r\n把 `C` 看成分界线，将 `S` 划分成一个个窗口。然后对每个窗口进行遍历，分别计算每个字符到窗口边界的距离最小值。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_1.png)\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，N 是 S 的长度。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++/Python)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 窗口左边界，如果没有就初始化为 Infinity，初始化为 S.length 也可以\r\n  let l = S[0] === C ? 0 : Infinity,\r\n    // 窗口右边界\r\n    r = S.indexOf(C, 1);\r\n\r\n  const res = Array(S.length);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 计算字符到当前窗口左右边界的最小距离\r\n    res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\r\n\r\n    // 遍历完了当前窗口的字符后，将整个窗口右移\r\n    if (i === r) {\r\n      l = r;\r\n      r = S.indexOf(C, l + 1);\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n\r\n        int l = S[0] == C ? 0 : n;\r\n        int r = S.find(C, 1);\r\n\r\n        vector<int> dist(n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            dist[i] = min(abs(i - l), abs(r - i));\r\n            if (i == r) {\r\n                l = r;\r\n                r = S.find(C, r + 1);\r\n            }\r\n        }\r\n\r\n        return dist;\r\n    }\r\n};\r\n```\r\n\r\nPython Code\r\n\r\n```py\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        res = [0 for _ in range(n)]\r\n\r\n        l = 0 if s[0] == c else n\r\n        r = s.find(c, 1)\r\n\r\n        for i in range(n):\r\n            res[i] = min(abs(i - l), abs(r - i))\r\n            if i == r:\r\n                l = r\r\n                r = s.find(c, l + 1)\r\n        return res\r\n```\r\n\r\n更多题解可以访问：[https://github.com/suukii/91-days-algorithm](https://github.com/suukii/91-days-algorithm)\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841011668","body":"# 232.用栈实现队列\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n- [232.用栈实现队列](#232用栈实现队列)\r\n  - [题目描述](#题目描述)\r\n  - [方法 1](#方法-1)\r\n    - [思路](#思路)\r\n    - [复杂度](#复杂度)\r\n    - [代码](#代码)\r\n  - [方法 2](#方法-2)\r\n    - [思路](#思路-1)\r\n    - [复杂度](#复杂度-1)\r\n    - [代码(JavaScript/C++)](#代码javascriptc)\r\n\r\n## 题目描述\r\n\r\n```\r\n使用栈实现队列的下列操作：\r\n\r\npush(x) -- 将一个元素放入队列的尾部。\r\npop() -- 从队列首部移除元素。\r\npeek() -- 返回队列首部的元素。\r\nempty() -- 返回队列是否为空。\r\n示例:\r\n\r\nMyQueue queue = new MyQueue();\r\n\r\nqueue.push(1);\r\nqueue.push(2);\r\nqueue.peek();  // 返回 1\r\nqueue.pop();   // 返回 1\r\nqueue.empty(); // 返回 false\r\n说明:\r\n\r\n你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。\r\n\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/implement-queue-using-stacks\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n```\r\n\r\n## 方法 1\r\n\r\n### 思路\r\n\r\n由于队列是 FIFI (先进先出)，而栈是 FILO (先进后出)。如果要用栈来模拟队列，则每次往模拟队列增加元素的时候，这个元素需要放在栈底，因为它是最后才会出列。\r\n\r\n方法之一是，每次需要往模拟队列尾端 `push` 一个新元素时：\r\n\r\n- 先把栈中的全部元素暂时取出\r\n- 将新元素入栈到栈底\r\n- 再将刚刚取出来元素重新入栈\r\n\r\n因此我们还需要一个辅助栈来存暂时取出来的元素。\r\n\r\n### 复杂度\r\n\r\n-   时间复杂度：入列操作是 $O(n)$，每次入列时，除新增元素外，每个元素都需要分别出栈入栈 2 次 (从模拟队列的栈中弹出，压入辅助栈，再从辅助栈弹出，压入队列模拟栈)。压入、弹出操作的时间复杂度都是 $O(1)$，所以总的时间复杂度差不多是 $O(4n)$，忽略掉常数，最后得到 $O(n)$。出列操作是 $O(1)$。\r\n-   空间复杂度：$O(n)$，n 是队列的大小，需要一个大小为 n 的栈来模拟队列，还需要一个大小为 n 的辅助空间，但总的空间复杂度还是 $O(n)$。\r\n\r\n### 代码\r\n\r\nJavaScript Code\r\n\r\n```js\r\nclass MyQueue {\r\n    constructor() {\r\n        this.stack = [];\r\n    }\r\n\r\n    push(x) {\r\n        const helper = [];\r\n        while (!this.empty()) {\r\n            helper.push(this.stack.pop());\r\n        }\r\n        this.stack.push(x);\r\n        while (helper.length) {\r\n            this.stack.push(helper.pop());\r\n        }\r\n    }\r\n\r\n    peek() {\r\n        return this.stack[this.stack.length - 1];\r\n    }\r\n\r\n    pop() {\r\n        return this.stack.pop();\r\n    }\r\n\r\n    empty() {\r\n        return this.stack.length === 0;\r\n    }\r\n}\r\n```\r\n\r\n## 方法 2\r\n\r\n### 思路\r\n\r\n方法 1 是在元素入列的时候，就考虑好了它出列的顺序，但我们还可以转换一下思路，在元素需要出列的时候再来考虑这个问题，这样的话：\r\n\r\n1. 入列时，直接 `push` 到栈中；\r\n2. 出列时，由于先入列的元素在栈底，需要先把其他元素弹出，依次压入辅助栈；\r\n3. 栈底元素弹出，出列；\r\n4. 刚才出栈的其他元素依次从辅助栈弹出，重新压入模拟栈。\r\n\r\n再仔细想想的话：\r\n\r\n-   第 2 步中，辅助栈中的元素出栈顺序刚好就是队列的出列顺序；\r\n-   所以到第 4 步的时候，我们根本没必要把元素再从辅助栈转移到模拟栈；\r\n-   下一次 `pop` 操作时，直接从辅助栈弹出元素就可以了；\r\n-   如果辅助栈中没有元素了，我们再重复第 2 步。\r\n\r\n这样的话，我们的队列元素其实是用了两个栈来储存，所以在判断队列是否为空的时候，两个栈都要考虑进去。\r\n\r\n### 复杂度\r\n\r\n-   时间复杂度：入列是 $O(1)$，出列最差的情况就是每个元素都要从模拟栈中弹出，压入辅助栈，再从辅助栈中弹出，所以是 $O(n)$。\r\n-   空间复杂度：$O(n)$，n 为队列大小。\r\n\r\n### 代码(JavaScript/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\nclass MyQueue {\r\n    constructor() {\r\n        this.stack = new MyStack();\r\n        this.helper = new MyStack();\r\n    }\r\n\r\n    push(x) {\r\n        this.stack.push(x);\r\n    }\r\n\r\n    peek() {\r\n        if (this.helper.empty()) {\r\n            while (!this.stack.empty()) {\r\n                this.helper.push(this.stack.pop());\r\n            }\r\n        }\r\n        return this.helper.peek();\r\n    }\r\n\r\n    pop() {\r\n        if (this.helper.empty()) {\r\n            while (!this.stack.empty()) {\r\n                this.helper.push(this.stack.pop());\r\n            }\r\n        }\r\n        return this.helper.pop();\r\n    }\r\n\r\n    empty() {\r\n        return this.stack.empty() && this.helper.empty();\r\n    }\r\n}\r\n\r\nclass MyStack {\r\n    constructor() {\r\n        this.stack = [];\r\n    }\r\n    push(x) {\r\n        this.stack.push(x);\r\n    }\r\n    pop() {\r\n        return this.stack.pop();\r\n    }\r\n    peek() {\r\n        return this.stack[this.stack.length - 1];\r\n    }\r\n    empty() {\r\n        return this.stack.length === 0;\r\n    }\r\n}\r\n```\r\n\r\nC++ Code\r\n```cpp\r\n#include <stack>\r\nusing namespace std;\r\n\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> stack_in_;\r\n    stack<int> stack_out_;\r\n    void pour_to_stack_out_() {\r\n        while (!stack_in_.empty()) {\r\n            int top = stack_in_.top();\r\n            stack_in_.pop();\r\n            stack_out_.push(top);\r\n        }\r\n    };\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        stack_in_.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if (stack_out_.empty()) { \r\n            pour_to_stack_out_();\r\n        }\r\n        int top = stack_out_.top();\r\n        stack_out_.pop();\r\n        return top;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if (stack_out_.empty()) { \r\n            pour_to_stack_out_();\r\n        }\r\n        return stack_out_.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return stack_in_.empty() && stack_out_.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```\r\n\r\n更多题解可以访问：[https://github.com/suukii/91-days-algorithm](https://github.com/suukii/91-days-algorithm)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SWUFEzyf":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838418829","body":"```\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        result = [0] * n\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n                continue\r\n            left = i-1\r\n            right = i + 1\r\n            while left >= 0 and s[left] != c:\r\n                left -= 1 \r\n            if left == -1:\r\n                left_distance = n\r\n            else:\r\n                left_distance = i - left\r\n            while right < n and s[right] != c:\r\n                right += 1\r\n            if right == n:\r\n                right_distance = n\r\n            else:\r\n                right_distance =  right - i\r\n            result[i] = min(left_distance, right_distance)\r\n        return result\r\n```\r\n复杂度分析\r\n时间复杂度：$O(N^2)$。\r\n空间复杂度：$O(N)$。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839596529","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.count = 0\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.count < self.maxSize:\r\n            self.count += 1\r\n            self.stack.append(x)\r\n        else:\r\n            return \r\n\r\n    def pop(self) -> int:\r\n        if self.count == 0:\r\n            return -1\r\n        else:\r\n            self.count -= 1\r\n            return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(self.count, k)):\r\n            self.stack[i] += val\r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shmilywh":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838419961","body":"\r\n## 题目分析\r\n\r\n- 字符串长度大于等于1\r\n- 均为小写字母\r\n- c至少出现一次\r\n\r\n## 思路\r\n\r\n 1. **【双指针】找c的位置，分情况讨论**\r\n\r\n    根据c出现的次数不同，计算相对位置的方式也略有出入，给定两个元素，一个是要计算相对位置的a，另一个是目标字符c，二者之间的位置我们可以分三种情况考虑\r\n\r\n    1) c只出现一次，且a在c的两侧\r\n\r\n    这时的相对距离，毋庸置疑应该等于 abs(index(a) - index(c))\r\n\r\n    2) c出现两次，且a在两个c的中间\r\n\r\n    这时的相对距离，应该计算a到两个c的距离然后取较小值\r\n\r\n    3) c出现三次或三次以上，我们可以拆分成上述两种情况来分别计算\r\n\r\n    代码：\r\n\r\n    定义两个指针，移动策略如下\r\n\r\n    - 一开始两指针均指向字符串头部\r\n    - 右指针向前移动，直到遇见一个c，这时满足情况1\r\n    - 更新左指针为右指针，右指针继续向右移动，直到再遇到c（满足情况2）或者走到字符串尾部（满足情况1）\r\n\r\n    几点注意：\r\n\r\n    1. 计算距离的时机应该在右指针更新的时候，右指针第二次之后，直到走到尾部，都按第2种情况计算，右指针第一次更新或者走到尾部，按照第1中情况判断\r\n    2. 要考虑右指针指向尾部以及尾部字符恰好是c的情况，所以条件判断应该有**优先级**\r\n\r\n    执行用时：**40 ms**, 在所有 Python3 提交中击败了**93.41%**的用户\r\n\r\n    内存消耗：**14.9 MB**, 在所有 Python3 提交中击败了**66.05%**的用户\r\n\r\n    ```python\r\n    class Solution:\r\n        def shortestToChar(self, s: str, c: str) -> List[int]:\r\n            # 定义变量 left记录上一个c的位置，如果存在的话\r\n            left = right_cnt = 0\r\n            answer = [0]*len(s)\r\n\r\n            # 循环，找c，计算距离\r\n            for right in range(len(s)):   # 右指针从0遍历到len(s)-1\r\n                if s[right] == c:   # 如果右指针指向的字符是c，那么计算一次距离\r\n                    if not right_cnt:   # 如果右指针第一次更新，说明在c的一侧\r\n                        answer[left:right+1] = [abs(right-i) for i in range(left, right+1)]\r\n                    else:   # 如果右指针不是第一次更新，说明在两个c中间\r\n                        answer[left:right+1] = [min(abs(right-i), abs(i-left)) for i in range(left, right+1)]\r\n                    # 更新左指针以及出现c的次数\r\n                    left = right\r\n                    right_cnt += 1\r\n                else:\r\n                    # 注意这个条件判断要在else里面，以排除最后一个元素是c的情况\r\n                    if right == len(s)-1:\r\n                        answer[left:right+1] = [abs(left-i) for i in range(left, right+1)]\r\n            return answer\r\n    ```\r\n\r\n    复杂度分析\r\n\r\n    令n为字符串长度：\r\n\r\n    时间复杂度：O(N)，这里外层循环，快指针遍历了n次，然后内层，每次遇到一个c，就处理一部分，总的遍历次数也是n，相当于是2n，所示时间复杂度是O(N)\r\n\r\n    空间复杂度：O(1)(不考虑返回占用的空间)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-838860047","body":"## 题目分析：\r\n\r\n- 入栈，有size限制\r\n- 出栈，空的话返回-1\r\n- inc，前k个元素都加上val\r\n\r\n## 思路\r\n\r\n辅助栈，空间换时间，额外定义一个栈，用来存储前k个元素的增量，只需要将第k个元素的值设为对应的增量即可，当出栈时再实时更新这个增量，起到增量向下传递的目的\r\n\r\n这样做的好处就是避免了对前k个元素进行的循环增量的操作，节省时间\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.size = maxSize\r\n        self.stk = []\r\n        self.inc = []   # 辅助栈，记录增量\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size > len(self.stk):\r\n            self.stk.append(x)\r\n            self.inc.append(0)   # 记得给辅助栈也压入元素，压0，不影响计算，还能避免判断长度\r\n\r\n    def pop(self) -> int:\r\n        if not self.stk: return -1\r\n        tmp = self.inc.pop()\r\n        res = self.stk.pop() + tmp\r\n        if self.inc: self.inc[-1] += tmp\r\n        return res\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        # 这里需要处理一下，如果给定的 k 大于当前栈的高度，那么应该 id 应该是最后一个元素\r\n        idx = k-1 if k < len(self.stk)+1 else len(self.stk)-1\r\n        # 处理之后， 如果self.inc原本就是空栈，那么idx会是负数，所以再加一个判断，防止索引越界\r\n        if idx >= 0:\r\n            self.inc[idx] += val \r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n```\r\n\r\n**复杂度分析：**\r\n\r\n假设操作次数为N\r\n\r\n时间复杂度：\r\n\r\n- 入栈：O(1)\r\n- 出栈：O(1)\r\n- 增量：O(1)，仅需计算对应位置增量\r\n\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-839928813","body":"[394\\. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\r\n\r\nDifficulty: **中等**\r\n\r\n### Solution\r\n\r\n### 题目分析\r\n\r\n- k一定是正整数\r\n- 字符串没有额外空格\r\n- 原始数据不包括数字\r\n\r\n### 思路：\r\n\r\n---\r\n\r\n### 1. 用栈实现括号匹配\r\n\r\n- 给定的字符串可以存储到一个栈中\r\n- 出栈入栈条件为：\r\n    - 如果非`]`，就入栈\r\n    - 如果是`]`，那么就循环出栈，直到找到一个匹配的`[`\r\n- 注意数字如果是两位数，需要处理，所以为了方便，我们先把数字解析出来，变成一个元素存储在栈中，这样每次匹配左右括号时，可以直接取左括号的上一位元素进行复制操作即可\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stk = []\r\n\r\n        for i in s:\r\n            try:    # 使用try，可以方便地对当前字符是否是数字进行判断\r\n                num = int(i)    # 这里的int(i)要单独占一行赋值语句\r\n                num = stk.pop()*10 + num if stk and isinstance(stk[-1], int) else num\r\n                stk.append(num)\r\n            except ValueError:\r\n                if i == ']':\r\n                    tmp = i\r\n                    while tmp[0] != '[':    # 循环pop，直到遇到了左括号\r\n                        tmp = stk.pop() + tmp\r\n                    stk.append(stk.pop()*tmp[1:-1])    # 解码后，重新压入栈\r\n                else:\r\n                    stk.append(i)\r\n        return ''.join(stk)\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令N为字符串长度\r\n\r\n时间复杂度：O(N) 只遍历了字符串一次，所以为线性复杂度\r\n\r\n空间复杂度：O(N) 使用了栈存储，所以为线性复杂度\r\n\r\n### 2. DFS\r\n\r\n递归写的不是很熟练，参考西法大佬的题解，将栈版本的代码改动成了递归\r\n\r\n详见代码注释\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        def dfs(i):   # 每次递归，传入的参数是索引， 表示在字符串的位置\r\n            num, ans = 0, ''    # 记得每次递归都将变量重新初始化一下\r\n            while i < len(s):\r\n                try:    # 使用try，不过这里直接加上 num*10，处理多位数字的情况\r\n                    num = num*10 + int(s[i])\r\n                except ValueError:   # 在抛出的异常中，处理字符串\r\n                    if s[i] == '[':   # 左括号的话，进入递归\r\n                        i, tmp = dfs(i+1)   # 更新索引 i\r\n                        ans += num*tmp   # 将当前递归层的ans加上内层的返回结果\r\n                        num = 0\r\n                    elif s[i] == ']':   # 右括号直接返回\r\n                        return i, ans\r\n                    else:\r\n                        ans += s[i]\r\n                i += 1\r\n            return ans\r\n        return dfs(0)\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令N为字符串长度\r\n\r\n时间复杂度：O(N) 递归其实更新了索引，所以还是只遍历了字符串一次，为线性复杂度\r\n\r\n空间复杂度：O(N) 极端情况下，递归调用栈的深度为N/2，比如`[[[[]]]]`，所以为线性复杂度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840668982","body":"### [232\\. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\r\n\r\nDifficulty: **简单**\r\n\r\n### Solution\r\n\r\n### 辅助栈\r\n\r\npush与peek的操作不说，但是pop的操作，如果只定义一个栈的话，想要实现队列的先入先出特性，在pop时，需要先将所有元素拿出来，然后pop掉栈底的元素，再放进去，这样的时间复杂度是线性的，所以我们可以使用空间换取时间\r\n\r\n定义一个辅助栈，然后每次pop时都执行以下操作\r\n\r\n- 辅助栈是否为空，是的话将主栈中所有元素添加到辅助栈中，注意这个添加的过程的倒序的，相当于辅助栈的栈顶就是队列的队首\r\n- 如果辅助栈不为空，或者已经执行完了第一步，那么直接返回辅助栈的栈顶元素即可\r\n\r\n```python\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.stk = []\r\n        self.aid = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stk.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.aid:\r\n            while self.stk:\r\n                self.aid.append(self.stk.pop())\r\n        return self.aid.pop()\r\n        \r\n    def peek(self) -> int:\r\n        if not self.aid: return self.stk[0]\r\n        else: return self.aid[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return True if not self.stk and not self.aid else False\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令队列元素为N个\r\n\r\n时间复杂度：均为O(1)\r\n\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841620049","body":"### [768\\. 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\r\n\r\nDifficulty: **困难**\r\n\r\n### Solution\r\n\r\n---\r\n\r\n### 题目分析\r\n\r\n- 题目大意是将，数组分块，分块排序后，连在一起可以组成所有元素的升序排列\r\n- 数组长度还好，不需要特殊处理\r\n- 言外之意就是，前一个块的所有元素，必须小于后一个块\r\n- 那么考虑两种极端情况，分别是数组完全升序和完全降序\r\n    - 完全升序时，数组中每个元素都小于后一个元素，所以每个元素都可以当成一个独立的块\r\n    - 完全降序时，数组中只能分成一个块\r\n\r\n### 思路：单调栈\r\n\r\n经过以上分析，可以通过单调栈来解决，设栈为`stk`，同时记录一下最大值`maxx`\r\n\r\n先向栈中存入第一个元素，避免不必要的判断\r\n\r\n遍历一次输入的数组：\r\n\r\n对每个元素依次做以下操作\r\n\r\n1. 判断是否入栈或出栈\r\n\r\n    入栈出栈的规则是：\r\n\r\n    - 如果当前元素大于或者等于`maxx`，入栈， 更新最大值`maxx`\r\n    - 如果当前元素小于栈顶元素，循环弹出栈顶元素，直到当前元素大于或等于栈顶元素，注意不用将当前元素入栈！！不过要再将`maxx`压入栈，因为刚刚pop时肯定把`maxx`弹出栈了\r\n\r\n最后返回栈的高度即可\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        maxx, stk = arr[0], [arr[0]]\r\n        for i in range(1, len(arr)):\r\n            if arr[i] >= maxx:\r\n                maxx = arr[i]\r\n                stk.append(arr[i])\r\n            else:\r\n                while stk and stk[-1] > arr[i]:\r\n                    stk.pop()\r\n                stk.append(maxx)\r\n        return len(stk)\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令数组长度为N\r\n\r\n时间复杂度：**O(N)** 因为只迭代了一次数组，所以为线性复杂度\r\n\r\n空间复杂度：**O(N)** 极端情况下，单调栈中会存N个数，所以为线性复杂度\r\n\r\n---\r\n\r\n### 思路：前缀和\r\n\r\n- 利用题中的先验条件：分块排序与直接排序，得到的结果一致\r\n- 因为对于每个块中的数据，我们可以不考虑他们的具体顺序以及大小，我们只需要关注他们的和就好，具体的方式就是\r\n\r\n    > 将前n个元素的和与直接排序后的前n个元素的和进行比较，如果相等，说明这n个元素可以被当成一个块\r\n\r\n- 为了进一步简化，我们可以通过前缀和的方式来比较，直接比较前缀和数组中相等元素的个数即可\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        cnt = 0\r\n        nums = sorted(arr, reverse=False)\r\n        for i in range(len(arr)):\r\n            nums[i] += nums[i-1] if i > 0 else 0\r\n            arr[i] += arr[i-1] if i > 0 else 0\r\n            cnt += 1 if arr[i] == nums[i] else 0\r\n        return cnt\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令数组长度为**N**\r\n\r\n时间复杂度：**O(N)** 排序为O(NlogN)，迭代为O(N)\r\n\r\n空间复杂度：**O(N)** 新建排序数组的空间占用为O(N)\r\n\r\n---\r\n\r\n### 思路：双指针/滑动窗口\r\n\r\n大概想法就是，定义两个指针，两个指针之间维护一个滑动窗口\r\n\r\n根据方法二的思路，我们可以判断每个窗口与排序后数组中元素的和是否相等\r\n\r\n定义两个指针 `left`， `right`，表示滑窗的左右边界，以及块数 `cnt`\r\n\r\n双指针移动策略：\r\n\r\n1. 初始值为 `left`指向0\r\n2. 使用`right`，遍历数组元素，右指针的范围是`1 - len(arr)+1`，注意python中**左闭右开**\r\n\r\n    如果当前两个指针之间的元素和与排序数组中的元素和相等，更新`left`为`right`，否则继续移动`right`，使滑窗变大\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        left = cnt = 0\r\n        nums = sorted(arr, reverse=False)\r\n        for right in range(1, len(arr)+1):\r\n            if sum(nums[left:right]) == sum(arr[left:right]):\r\n                cnt, left = cnt+1, right\r\n        return cnt\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令数组长度为**N**\r\n\r\n时间复杂度：**O(N)** 排序为O(NlogN)，迭代为O(N)\r\n\r\n空间复杂度：**O(N)** 新建排序数组的空间占用为O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841696578","body":"### [61\\. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\r\n\r\nDifficulty: **中等**\r\n\r\n### Solution\r\n\r\n### 题目分析\r\n\r\n- 没说链表中元素一定不同\r\n- 链表节点数量可能为0！！！\r\n\r\n---\r\n\r\n### 思路：三次反转链表\r\n\r\n这个题的思路有点像[旋转数组](https://leetcode-cn.com/problems/rotate-array/)，其步骤如下\r\n\r\n1. 将整个数组反转\r\n2. 将前k个元素反转\r\n3. 将后面所有元素反转\r\n\r\n这时的数组就是**旋转k个位置**后的\r\n\r\n同样本题也可以如此操作\r\n\r\n---\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        # 链表为空或者只有一个节点，直接返回即可\r\n        if not head or not head.next or not k: return head\r\n\r\n        # 根据steps的数量 反转链表\r\n        def reverseList(node: ListNode, steps: int) -> ListNode:\r\n            pre, cur = None, node\r\n            while steps > 0:\r\n                steps -= 1\r\n                nex = cur.next\r\n                cur.next = pre\r\n                pre = cur\r\n                cur = nex\r\n            return pre, cur\r\n\r\n        # 需要对K求余\r\n        tmp, length = head, 0\r\n        while tmp:\r\n            tmp = tmp.next\r\n            length += 1\r\n        k %= length\r\n\r\n        # k为0的话，说明不需要旋转\r\n        if not k: return head\r\n\r\n        # 先反转所有，再反转前k个，最后反转后面剩下的\r\n        rev, _ = reverseList(head, length)\r\n        preK, nex = reverseList(rev, k)\r\n        rev.next, _ = reverseList(nex, length-k)\r\n        return preK\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LeahLuo0903":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838427280","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        \r\n        int n = s.size();\r\n        vector<int> ans(s.size(), -n);\r\n            \r\n        int prev = -n;  \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) prev = i;\r\n            ans[i] = i - prev; \r\n        }\r\n        \r\n        // 不需要从最后开始遍历\r\n        // 从最后一次该字母出现处往前遍历\r\n        for (int i = prev - 1; i >= 0; i--) {\r\n            if (s[i] == c) prev = i;\r\n            ans[i] = min(ans[i], prev - i); \r\n        } \r\n        return ans; \r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838427280","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        \r\n        int n = s.size();\r\n        vector<int> ans(s.size(), -n);\r\n            \r\n        int prev = -n;  \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) prev = i;\r\n            ans[i] = i - prev; \r\n        }\r\n        \r\n        // 不需要从最后开始遍历\r\n        // 从最后一次该字母出现处往前遍历\r\n        for (int i = prev - 1; i >= 0; i--) {\r\n            if (s[i] == c) prev = i;\r\n            ans[i] = min(ans[i], prev - i); \r\n        } \r\n        return ans; \r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841668001","body":"### 思路\r\n1. 复制arr数组并对其排序\r\n2. 能成块的特点：和相同。比如[2，1，4，3，4]，排序后为[1，2，3，4，4]，2+1 = 1+2 -> 1，2能分出来\r\n3. 遍历数组，对比和即可\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        vector<int> sortArr = arr; \r\n        sort(sortArr.begin(), sortArr.end());\r\n        \r\n        int ans = 0;\r\n        long sum1 = 0; \r\n        long sum2 = 0; \r\n        \r\n        for (int i = 0; i < arr.size(); i++) {\r\n            sum1 += arr[i];\r\n            sum2 += sortArr[i];\r\n            if (sum1 == sum2) ans++;\r\n        }\r\n        return ans; \r\n    }\r\n};\r\n```\r\n时间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"p76":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838435741","body":"> ### 思路\r\n> 1.将字符串转成数组。\r\n2.遍历字符串数组，获取字符c在字符串数组中的坐标，生成坐标数组。\r\n3.再次遍历，获取字符串中其他字符与字符c的最近距离。\r\n \r\n> ### 代码\r\n``` \r\nvar shortestToChar = function (s, c) {\r\n    let sArr = s.split('');\r\n    let itemIndex = [];\r\n    let answerArr = [];\r\n    for (let i = 0; i < sArr.length; i++) {\r\n        if (sArr[i] === c) {\r\n            itemIndex.push(i);\r\n        }\r\n    }\r\n    for (let n = 0; n < sArr.length; n++) {\r\n        if (sArr[n] === c) {\r\n            answerArr.push(0);\r\n        } else {\r\n            let idx = sArr.length;\r\n            for (let j = 0; j < itemIndex.length; j++) {\r\n                let countNum = Math.abs(n - itemIndex[j]);\r\n                if (idx > countNum) {\r\n                    idx = countNum;\r\n                }\r\n            }\r\n            answerArr.push(idx);\r\n        }\r\n    }\r\n    return answerArr;\r\n};\r\n```\r\n> ### 复杂度\r\n时间复杂度O(n);\r\n空间复杂度O(1);"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839880360","body":">### 思路\r\n1.初始化top，将当前数值下标保存至top;\r\n2.初始化数组stack，长度为maxsize；\r\n3.执行push操作时，判断top是否大于maxsize-1,大于则不做操作，否则top++，然后将当前数据存入stack[top];\r\n4.执行pop操作时，判断top是否为-1，为-1时直接return -1，否则top--，return stack[top+1];\r\n5.执行increment操作时，直接遍历k,栈中下标小于k的数据加上val;\r\n\r\n>### 代码\r\n```\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n    stack = new Array(maxSize);\r\n    top = -1;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n    if (top < stack.length - 1) {\r\n        top++;\r\n        stack[top] = x;\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n    if (top != -1) {\r\n        top--;\r\n        return stack[top + 1];\r\n    }\r\n    return -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n    for (let i = 0; i < k; i++) {\r\n        if (stack[i]) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n    return stack;\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\nlet stack = [];\r\nlet top;\r\n```\r\n\r\n>### 复杂度\r\n时间复杂度：初始化、pop、push为O(1)，increment为O(k);\r\n空间复杂度:O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840655306","body":">### 思路\r\n遍历s字符串，遇到数字时，将字符串转成数字保存至num变量。遇到字符时，将字符进行拼接保存至res变量，遇到‘[’时，res和num分别存入strStack、mulStack栈中，并且将res和num变量分别重置为‘’和[]，遇到']'时，将strStack的栈顶元素出栈，并且进行重复操作。\r\n\r\n>### 代码 \r\n```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s) {\r\n   let mulStack = [], strStack = [], num = 0, res = ''\r\n    for (const c of s) {   \r\n        if (!isNaN(c)) {  \r\n            num = num * 10 + (c - '0')\r\n        } else if (c == '[') {  \r\n            strStack.push(res)\r\n            mulStack.push(num) \r\n            res = '' \r\n            num = 0\r\n        } else if (c == ']') {  \r\n            res = strStack.pop() + res.repeat(mulStack.pop())\r\n        } else {                   \r\n            res += c\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n>### 复杂度\r\n时间复杂度：\r\n空间复杂度：O(s.length)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Ben-Lee95":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838512853","body":"> # 821. 字符的最短距离\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历(正向遍历和反向遍历)\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n> \r\n> 示例 1:\r\n> \r\n> 输入: S = \"loveleetcode\", C = 'e'\r\n> 输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n> 说明:\r\n> \r\n> - 字符串 S 的长度范围为 [1, 10000]。\r\n> - C 是一个单字符，且保证是字符串 S 里的字符。\r\n> - S 和 C 中的所有字母均为小写字母。\r\n> ```\r\n## 思路\r\n- 对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\r\n## 关键点\r\n\r\n-  从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。\r\n从右向左遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。\r\n这两个值取最小就是答案。\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int N = s.length();\r\n        int[] ans = new int[N];\r\n        int prev = -10000;\r\n        \r\n        //从左往右遍历数组\r\n        for(int i = 0; i < N; ++i){\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = 20000;\r\n        //从右往左遍历数组\r\n        for(int i = N-1; i >= 0; --i){\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(1)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838512853","body":"> # 821. 字符的最短距离\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历(正向遍历和反向遍历)\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n> \r\n> 示例 1:\r\n> \r\n> 输入: S = \"loveleetcode\", C = 'e'\r\n> 输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n> 说明:\r\n> \r\n> - 字符串 S 的长度范围为 [1, 10000]。\r\n> - C 是一个单字符，且保证是字符串 S 里的字符。\r\n> - S 和 C 中的所有字母均为小写字母。\r\n> ```\r\n## 思路\r\n- 对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\r\n## 关键点\r\n\r\n-  从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。\r\n从右向左遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。\r\n这两个值取最小就是答案。\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int N = s.length();\r\n        int[] ans = new int[N];\r\n        int prev = -10000;\r\n        \r\n        //从左往右遍历数组\r\n        for(int i = 0; i < N; ++i){\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = 20000;\r\n        //从右往左遍历数组\r\n        for(int i = N-1; i >= 0; --i){\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(1)$\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"RMsboy":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838529779","body":"**思路**\r\n维护一个数组获取c在s中的下标\r\n使用reduce方法对计算最近距离\r\n\r\n**代码**\r\n语言支持：JavaScript\r\nJavaScript Code:\r\n\r\n```\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let resArr = new Array(s.length)\r\n    let temArr = []\r\n    // 包含c字符下标的数组\r\n    for(let i = 0; i < s.length; i++){\r\n        if(s[i] === c){\r\n            temArr.push(i)\r\n        }\r\n    }\r\n    // 使用reduce获取字符串与指定字符串的最短距离\r\n    for(let i = 0; i < s.length; i++){\r\n        resArr[i] = temArr.reduce((value, item) => {\r\n            return Math.min(value, Math.abs(item - i))\r\n        }, 10000)\r\n    }\r\n    return resArr\r\n}\r\n```\r\n\r\n**复杂度分析**\r\nn为s的长度，m为c在s中的重复次数\r\n\r\n时间复杂度：O(mn) \r\n空间复杂度：O(mn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839737782","body":"**代码**\r\n\r\n    **语言支持：JavaScript**\r\n\r\n``` \r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n    this.stack = []\r\n    this.max = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n    if (this.stack.length < this.max) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n    if (this.stack.length === 0) {\r\n        return -1\r\n    } else {\r\n        let a = this.stack.splice(this.stack.length - 1, 1)\r\n        return a\r\n    }\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n    if (this.stack.length < k) {\r\n        let i = 0\r\n        while (i < this.stack.length) {\r\n            this.stack[i] += val\r\n            i++\r\n        }\r\n    } else {\r\n        let i = 0\r\n        while (i < k) {\r\n            this.stack[i] += val\r\n            i++\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n复杂度分析\r\n\r\n    push\r\n        时间复杂度：O(1)\r\n        空间复杂度：O(1)\r\n\r\n    pop\r\n        时间复杂度：O(1)\r\n        空间复杂度：O(1)\r\n\r\n    increment\r\n        时间复杂度：O(n)\r\n        空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840646642","body":"// 时间不够，先抄一遍，再来仔细琢磨\r\n\r\n```/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  const stack = [];\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] != ']'){\r\n      stack.push(s[i])\r\n    }else if(s[i] == ']'){\r\n      let temp = ''\r\n      while(stack[stack.length - 1] != '['){\r\n        temp = stack.pop() + temp;\r\n      }\r\n      stack.pop() //这一步一定是'['\r\n\r\n      let num = ''\r\n      while(stack[stack.length - 1] >= '0' && stack[stack.length - 1] <= '9'){\r\n        num = stack.pop() + num\r\n      }\r\n\r\n      temp = temp.repeat(parseInt(num))\r\n      stack.push(temp)\r\n    }\r\n  }\r\n  return stack.join('');\r\n};```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841321279","body":"**语言：js**\r\n```/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function () {\r\n    this.queueLeft = []\r\n    this.queueRight = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n    this.queueLeft.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n    if (this.queueRight.length <= 0) {\r\n        while (this.queueLeft.length > 0) {\r\n            this.queueRight.push(this.queueLeft.pop())\r\n        }\r\n    }\r\n    return this.queueRight.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n    if (this.queueRight.length <= 0) {\r\n        while (this.queueLeft.length > 0) {\r\n            this.queueRight.push(this.queueLeft.pop())\r\n        }\r\n    }\r\n    return this.queueRight[this.queueRight.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n    return this.queueLeft.length === 0 && this.queueRight.length === 0\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841628856","body":"**语言：js**\r\n维护一个栈，存储每一块的最大值\r\n\r\n```\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n    // 定义一个栈\r\n    let res = []\r\n    let len = arr.length\r\n    for(let i = 0; i < len; i++){\r\n        // 当前项大于等于栈最后一个值 push\r\n        if(res.length <= 0 || arr[i] >= res[res.length - 1]){\r\n            res.push(arr[i])\r\n        } else {\r\n            // 当前值小于栈最后一个值，继续往栈前面找，找到小于当前值的数\r\n            let temp = res.pop()\r\n            while(arr[i] < res[res.length - 1]){\r\n                res.pop()\r\n            }\r\n            res.push(temp)\r\n        }\r\n    }\r\n    return res.length\r\n};\r\n```\r\n\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"XiaoY0324":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838586771","body":"```js\r\n// 每个元素往两边扫描 取最小值\r\nvar shortestToChar = function(s, c) {\r\n  let stringArr = s.split('');\r\n  let res = [];\r\n  let startIdx = 0; // 起始扫描下标\r\n  \r\n  // 递归开始\r\n  findMinIdx(startIdx, stringArr, c, res);\r\n\r\n  // 结果返回\r\n  return res;\r\n};\r\n\r\nconsole.log(\"baaa\", \"b\");\r\nvar findMinIdx = function(startIdx, stringArr, c, res) {\r\n  // 递归终止条件\r\n  if (res.length == stringArr.length) return;\r\n\r\n  let total;\r\n\r\n  for (let i = startIdx; i < stringArr.length; i++) { // 往右扫\r\n    console.warn(`正向扫startIdx: ${ startIdx }`, `i: ${ i }`);\r\n    if (stringArr[i] == c) {\r\n      let curIdx = Math.abs(i - startIdx);\r\n      total = curIdx; // 移动差值\r\n      break;\r\n    }\r\n  }\r\n\r\n  for (let j = startIdx; j >= 0 ; j--) { // 往左扫 注意 j 为 0 也要扫 扫的是 0 位置的元素 比如 'baaa' 和 'b'，0 位置相等。\r\n    console.error(`反向扫startIdx: ${ startIdx }`, `j: ${ j }`);\r\n    if (stringArr[j] == c) {\r\n      console.error(j, '------------');\r\n      let curIdx = Math.abs(j - startIdx);\r\n      \r\n      if (total) {\r\n        total = total > curIdx ? curIdx : total; // 最小移动差值\r\n      } else { // 如果上一个往右扫没有满足条件，这里 total 就为 undefined，做下兼容。\r\n        total = curIdx;\r\n      }\r\n      \r\n      break;\r\n    }\r\n  }\r\n\r\n  res.push(total);\r\n  return findMinIdx(startIdx + 1, stringArr, c, res);\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839448979","body":"```js\r\nvar CustomStack = function(maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = new Array();\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  this.stack.length < this.maxSize && (this.stack.push(x));\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  let resNum = -1;\r\n\r\n  this.stack.length && (resNum = this.stack.pop());\r\n  return resNum;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let endIdx = Math.min(this.stack.length, k);\r\n\r\n  for (let i = 0; i < endIdx; i++) {\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840540108","body":"```js\r\n/**\r\n * @desc 题解：https://algo91.herokuapp.com/solutionDetail?type=3&id=4&max_id=2 这道题没想出来\r\n * @param {string} s\r\n * @return {string}\r\n */\r\n\r\n// 最符合直觉的版本 利用栈\r\nvar decodeString = function(s) {\r\n  var stack = []; // 栈 字符串首部依次压入栈\r\n  \r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] == ']') {\r\n      let pop = stack.pop(); // 栈顶取出 并记录值 \r\n      let repeatStr = pop; // 要 repeat 的字符串                                \r\n      \r\n      // 栈顶不是 \"[\" 时，再出栈的说明是要 repeat 的字符串\r\n      while(pop !== '[') {\r\n        pop = stack.pop(); // 总会多一次 pop 也就是 pop 为 '['\r\n        pop !== '[' && (repeatStr = pop + repeatStr); // 要 repeat 的字符串 注意要 pop + repeatStr，不能 repeatStr + pop, 不然可能乱序\r\n      }\r\n                                          \r\n      // -------------  要 repeat 的字符串已经出栈, 开始处理要 repeat 的次数   ---------------\r\n      pop = stack.pop();\r\n      let repeatCount = pop; // 要 repeat 的次数\r\n      \r\n      // 栈顶是一个数字的时候\r\n      while(!isNaN(pop)) {\r\n        pop = stack.pop(); // 总会多 pop 一次, 后面要 push 回来\r\n        !isNaN(pop) && (repeatCount = pop + repeatCount); // 字符串形式的数字 直接拼接                                 \r\n      }\r\n      \r\n      pop && stack.push(pop); //  要 Push 回来\r\n      stack.push(repeatStr.repeat(repeatCount));\r\n    } else {\r\n       stack.push(s[i]);\r\n      console.log(stack);\r\n    }\r\n  }\r\n  \r\n  return stack.join('');\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841232428","body":"```js\r\n/**\r\n * Initialize your data structure here.\r\n */\r\n// 数组的pop 是从末尾删除一位  而队列的 pop，则是从开头删除一位，这道题主要处理这个差异。\r\nvar MyQueue = function() {\r\n  this.stack = []; \r\n  this.bkStack = []; // 辅助栈 用来倒序 pop\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n  this.stack.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {  \r\n  var result;\r\n  \r\n  // 倒序 取要 pop 的值\r\n  while (this.stack.length) {\r\n    this.bkStack.push(this.stack.pop());\r\n  }\r\n  \r\n  result =  this.bkStack.pop();\r\n  \r\n  // 再正序塞回 stack\r\n  while (this.bkStack.length) {\r\n    this.stack.push(this.bkStack.pop());\r\n  }\r\n  \r\n  return result;\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n  return this.stack[0];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n  return this.stack.length === 0;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841666714","body":"```js\r\n\r\nvar maxChunksToSorted = function(arr) {\r\n        let sortArr = [...arr].sort((a,b)=> a-b);\r\n        let sum1 = 0, sum2 = 0, count = 0;\r\n        for (let i = 0; i< arr.length; i++){\r\n            sum1+= arr[i];\r\n            sum2+= sortArr[i];\r\n            if (sum1==sum2){\r\n                count += 1;\r\n                sum1 = 0;\r\n                sum2 = 0;\r\n            }   \r\n        }       \r\n        return count   \r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"breadfruit":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838590094","body":"## 思路\r\n遍历当前数组，分别从两边开始寻找，知道两边分别找到指定字符，然后取最小值加入结果数组。\r\n## 代码\r\n语言支持：Python3\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        for i in range(len(s)):\r\n            l = r =i\r\n            while l > -1:\r\n                if s[l] == c: break\r\n                l -= 1\r\n            while r < len(s):\r\n                if s[r] == c: break\r\n                r += 1\r\n            if l == -1: l = -10000\r\n            if r == len(s): r = 20000\r\n            ans.append(min(r-i,i-l))\r\n        return ans\r\n```\r\n## 复杂度\r\n- 时间复杂度：O(N^2)\r\n- 空间复杂度：O(1)\r\n题目的数据范围是 10000，所以 [-10000,20000]"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839238762","body":"## 思路\r\n1. 需要两个判断变量，一个是记录当前栈顶元素位置p，另一个是记录最大栈空间的位置q。\r\n2. push的时候判断当前栈顶元素位置p是否会大于最大栈空间的位置q\r\n3. pop判断当前栈中是否有元素\r\n4. increment判断k和当前栈顶元素位置p的大小\r\n## 代码\r\n语言支持:Python3\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.top = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top > len(self.stack):\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack: \r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, len(self.stack))\r\n        for i in range(lim):\r\n            self.stack[i] += val\r\n```\r\n\r\n\r\n```\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stack)-1:\r\n            self.top += 1\r\n            self.stack[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top > -1: \r\n            temp = self.stack[self.top]\r\n            self.top -= 1\r\n            return temp\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stack[i] += val\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840554020","body":"# 辅助栈\r\n## 思路\r\n首先理清楚，我们要判断的值有哪一些，什么时候进栈，什么时候出栈，栈里面存的是什么\r\n1. 我们首先要判断的参数有四种，分别是'[', ']', 数字，字母。\r\n2. 我们的值是'['的时候进栈，']'的时候出栈\r\n3. 用res 记录括号[]里面的字符串res \r\n4. 栈里面存两个变量一个是两个[ [ 做括号之间的字符串用来与当前res进行拼接，一个是记录当前res需要重复的次数\r\n## 代码\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n# dfs\r\n## 思路\r\n我们要理清dfs的参数是什么，终止条件是什么，递归的工作是什么\r\n1. dfs的参数是当前字符串，开始循环的下标\r\n2. 终止条件是下标超标\r\n3. 递归的工作是从i+1往下继续搜索\r\n## 代码思想\r\n当 s[i] == ']' 时，返回当前括号内记录的 res 字符串与 ] 的索引 i （更新上层递归指针位置）；\r\n当 s[i] == '[' 时，开启新一层递归，记录此 [...] 内字符串 tmp 和递归后的最新索引 i，并执行 res + multi * tmp 拼接字符串。\r\n遍历完毕后返回 res。\r\n## 代码\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        def dfs(s, i):\r\n            res, multi = \"\", 0\r\n            while i < len(s):\r\n                if '0' <= s[i] <= '9':\r\n                    multi = multi * 10 + int(s[i])\r\n                elif s[i] == '[':\r\n                    i, tmp = dfs(s, i + 1)\r\n                    res += multi * tmp\r\n                    multi = 0\r\n                elif s[i] == ']':\r\n                    return i, res\r\n                else:\r\n                    res += s[i]\r\n                i += 1\r\n            return res\r\n        return dfs(s,0)\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840890634","body":"## 辅助栈\r\n### 思路\r\n1. 利用一个辅助栈实现队列，栈是先进后出，而队列是先进先出，也就是对于栈来说实现队列无疑就是将最靠近栈底的元素提前pop处理，从栈底push元素，从数据结构来看是无法实现的，那么我们可以换一个思路，用一个辅助栈把你暂存，\r\n2. 对于pop暂存除栈底意外的元素，然后再把栈底pop出去，然后再把暂存在辅助栈的那些元素依次从辅助栈pop出去append到原来的栈中\r\n3. 对于push，依次暂存原来栈中所有元素，然后在辅助栈顶push题目要求的元素，然后依照栈操作，依次又从辅助栈pop，append到原来栈中。\r\n### 代码\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack = []\r\n        self.help_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stack:\r\n            self.help_stack.append(self.stack.pop())\r\n        self.help_stack.append(x)\r\n        while self.help_stack:\r\n            self.stack.append(self.help_stack.pop())\r\n        \r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.stack.pop()\r\n        \r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stack[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.stack)\r\n```\r\n\r\n## 双栈\r\n### 思路\r\n用两个栈实现队列，一个栈用来进行读操作(push)，一个栈用来写操作(pop,empty,peek)\r\n1. 栈a进行push操作\r\n2. 在进行pop，peek操作的时候，如果栈b有元素，直接pop，没有的话，在栈a有元素的时候，栈a进行pop添加到栈b再进行pop\r\n3. 当栈a，b为空的时候才是空的\r\n### 延伸阅读\r\n-   其实使用两个栈来替代一个队列的实现是为了在多进程中分开对同一个队列对读写操作。一个栈是用来读的，另一个是用来写的。当且仅当读栈满时或者写栈为空时，读写操作才会发生冲突。\r\n-  当只有一个线程对栈进行读写操作的时候，总有一个栈是空的。在多线程应用中，如果我们只有一个队列，为了线程安全，我们在读或者写队列的时候都需要锁住整个队列。而在两个栈的实现中，只要写入栈不为空，那么push操作的锁就不会影响到pop。\r\n### 代码\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.a = []\r\n        self.b = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.a.append(x)\r\n        \r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.b:\r\n            while self.a:\r\n                self.b.append(self.a.pop())\r\n        return self.b.pop()\r\n             \r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.b:\r\n            while self.a:\r\n                self.b.append(self.a.pop())\r\n        return self.b[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        if not(self.a or self.b):\r\n            return True\r\n        return False\r\n```\r\n\r\n## 栈混洗\r\n### 思路\r\n栈混洗也是借助另外一个栈来完成\r\n- 将 pushed 队列中的每个数都 push 到栈中，同时检查这个数是不是 popped 序列中下一个要 pop 的值，如果是就把它 pop 出来。\r\n### 代码\r\n```\r\nclass Solution(object):\r\n    def validateStackSequences(self, pushed, popped):\r\n        j = 0\r\n        stack = []\r\n        for x in pushed:\r\n            stack.append(x)\r\n            while stack and j < len(popped) and stack[-1] == popped[j]:\r\n                stack.pop()\r\n                j += 1\r\n        return j == len(popped)\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841581858","body":"## 单调栈里面的分块融合\r\n也许你和我一样，一开始想着用单调栈\r\n  1. 比栈顶大的元素，分块\r\n  2. 和栈顶相等的元素，分块\r\n  3. 比栈顶小的元素，融合为块。\r\n\r\n\r\n但我在测试用例中[4,2,2,1,1]运用这个过不来，因为按照我上面那个思路，j结果是[4,2],[2,1],[1],但是结果是[4,2,2,1,1]\r\n这是为什么？其实因为我们只考虑到局部，就是只能判断当前栈顶的值比较，没错我们是在比较寻找最大值，但是这里是分块，你不能确保上一个分块的最大值和你当前块的比较，你比较的是当前块的最大值而已，好比[4,2]和[2,1]我们只能确保当前分块是递减的。\r\n那么就像力扣加加说的那样，我们来逆向思维，比较整体的每一块的最大值而不是当前块！遇到比当前栈顶小的就合并，被老大吃了，大家只能看到最大的那个。\r\n如何比较呢\r\n## 思路\r\n1. 遍历数组，遇到比当前小的元素直接添加到栈中等到遇到比当前栈顶元素大的元素时，保留当前栈顶元素(可以理解栈顶元素就是当前块的代表，也就是最大值)，把栈清空，再将当前块的代append上去(比他小的都和他融为一体了)，可以理解为块代表的比较，以此类推\r\n举个例子：\r\n[5,4,4,3,1,1]\r\n正确分区为[5,4,4,3,1,1],因为5作为一开始的栈顶，遍历完，5最为这块区域的老大，没有比他更大的了\r\n[2,1,3,4,4]\r\n正确分区为[2, 1], [3], [4], [4],其实栈中此时记录的是各区的老大,[2,3,4,4],因为[1,2]进行相融合并了\r\n## 代码\r\n语言：Python3\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, A: [int]) -> int:\r\n        stack = []\r\n        for i in A :\r\n            if stack and stack[-1] > i:\r\n                cur = stack[-1]\r\n                while stack and stack[-1] > i:\r\n                    stack.pop()\r\n                stack.append(cur)\r\n            else:\r\n                stack.append(i)\r\n        return len(stack)\r\n```\r\n## 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luoluomo":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838597001","body":"# 思路\r\n  正向和逆向分别遍历数组，计算和上一个目标字符的最短距离，保留两次遍历中较小的距离\r\n  实现时下面的边界条件，容易出现问题\r\n  let lastC = Number.MIN_SAFE_INTEGER;\r\n  lastC = Number.MAX_SAFE_INTEGER;\r\n# 代码\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const number = new Array(s.length).fill(Number.MAX_SAFE_INTEGER);\r\n    const strs = s.split(\"\");\r\n    let lastC = Number.MIN_SAFE_INTEGER;\r\n    strs.forEach((item, index) => {\r\n        if(item === c){\r\n            number[index] = 0;\r\n            lastC = index;\r\n        }else{\r\n            number[index] = index - lastC;\r\n        }\r\n    })\r\n    lastC = Number.MAX_SAFE_INTEGER;\r\n    for(let i = strs.length - 1; i >= 0; i--){\r\n        if(strs[i] === c){\r\n            number[i] = 0;\r\n            lastC = i;\r\n        }else{\r\n            number[i] = Math.min(number[i], lastC - i);\r\n        }\r\n    }\r\n\r\n    return number;\r\n};\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838597001","body":"# 思路\r\n  正向和逆向分别遍历数组，计算和上一个目标字符的最短距离，保留两次遍历中较小的距离\r\n  实现时下面的边界条件，容易出现问题\r\n  let lastC = Number.MIN_SAFE_INTEGER;\r\n  lastC = Number.MAX_SAFE_INTEGER;\r\n# 代码\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const number = new Array(s.length).fill(Number.MAX_SAFE_INTEGER);\r\n    const strs = s.split(\"\");\r\n    let lastC = Number.MIN_SAFE_INTEGER;\r\n    strs.forEach((item, index) => {\r\n        if(item === c){\r\n            number[index] = 0;\r\n            lastC = index;\r\n        }else{\r\n            number[index] = index - lastC;\r\n        }\r\n    })\r\n    lastC = Number.MAX_SAFE_INTEGER;\r\n    for(let i = strs.length - 1; i >= 0; i--){\r\n        if(strs[i] === c){\r\n            number[i] = 0;\r\n            lastC = i;\r\n        }else{\r\n            number[i] = Math.min(number[i], lastC - i);\r\n        }\r\n    }\r\n\r\n    return number;\r\n};\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"QiuhaoLi":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838597599","body":"## 思路\r\n\r\n使用双指针，分别指向匹配字符。从左向右扫描并更新距离，当发现新的匹配字符更新第二个指针时，进行回溯更新距离（与第一个指针间一半的字符需要更新）。\r\n\r\n要考虑到可能只有一个匹配字符（第二个指针为空）。\r\n\r\n## 代码\r\n\r\n```c\r\n/**\r\n * Note: The returned array must be malloced, assume caller calls free().\r\n */\r\nint* shortestToChar(char * s, char c, int* returnSize){\r\n    size_t string_size = strlen(s);\r\n    *returnSize = string_size;\r\n    if (string_size == 0)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    int *distance = malloc(string_size * sizeof(int));\r\n    //error handling\r\n\r\n    long index_c_first = -1;\r\n    long index_c_second = -1;\r\n\r\n    for (long i = 0; i < string_size; ++i)\r\n    {\r\n        if (s[i] == c)\r\n        {\r\n            if (index_c_first == -1)\r\n            {\r\n                index_c_first = i;\r\n                for (long j = index_c_first; j >=0; --j)\r\n                {\r\n                    distance[j] = index_c_first-j;\r\n                }\r\n            }\r\n            else if (index_c_second == -1)\r\n            {\r\n                index_c_second = i;\r\n                for (long j = index_c_second; j > (index_c_second+index_c_first)/2; --j)\r\n                {\r\n                    distance[j] = index_c_second-j;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                long tmp = index_c_second;\r\n                index_c_second = i;\r\n                index_c_first = tmp;\r\n                for (long j = index_c_second; j > (index_c_second+index_c_first)/2; --j)\r\n                {\r\n                    distance[j] = index_c_second-j;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            long index_c = index_c_second == -1 ? index_c_first : index_c_second;\r\n            if (index_c != -1)\r\n            {\r\n                distance[i] = i - index_c;\r\n            }\r\n        }\r\n    }\r\n\r\n    return distance;\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n时间：O(n)\r\n空间：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839409800","body":"## 思路\r\n\r\n用数组模拟栈，维护最大长度和栈顶。\r\n\r\n关键点在于`inc`操作，如果每次都对`min(k, obj->top)`进行逐个操作，复杂度将为`O(n)`。注意到栈的结构和`inc`操作的相似性，我们可以用另一个栈保存（或者每个栈元素中保存）当前元素及下方元素应该加的数，`pop`操作时将这个数加上，并传递至下方元素。\r\n\r\n## 代码\r\n\r\n```c\r\ntypedef struct {\r\n    size_t maxSize;\r\n    long top;\r\n    int *stack;\r\n    int *add;\r\n} CustomStack;\r\n\r\n\r\nCustomStack* customStackCreate(int maxSize) {\r\n    if (maxSize < 0)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    CustomStack * result = malloc(sizeof(CustomStack));\r\n    result->stack = malloc(maxSize * sizeof(result->stack[0]));\r\n    result->add = calloc(maxSize, sizeof(result->add[0]));\r\n    // error handing\r\n\r\n    result->top = 0;\r\n    result->maxSize = maxSize;\r\n\r\n    return result;\r\n}\r\n\r\nvoid customStackPush(CustomStack* obj, int x) {\r\n    long top = obj->top;\r\n    if (top >= obj->maxSize)\r\n    {\r\n        return;\r\n    }\r\n    obj->stack[top] = x;\r\n    ++obj->top;\r\n}\r\n\r\nint customStackPop(CustomStack* obj) {\r\n    long top = obj->top;\r\n    if (top <= 0)\r\n    {\r\n        return -1;\r\n    }\r\n\r\n    --obj->top;\r\n    int result = obj->stack[obj->top] + obj->add[obj->top];\r\n\r\n    if (obj->top > 0)\r\n    {\r\n        obj->add[obj->top - 1] += obj->add[obj->top];\r\n    }\r\n    obj->add[obj->top] = 0;\r\n\r\n    return result;\r\n}\r\n\r\nvoid customStackIncrement(CustomStack* obj, int k, int val) {\r\n    long inc_top = k < obj->top ? k : obj->top;\r\n    if (inc_top <= 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    obj->add[inc_top - 1] += val;\r\n}\r\n\r\nvoid customStackFree(CustomStack* obj) {\r\n    free(obj->stack);\r\n    free(obj->add);\r\n    free(obj);\r\n}\r\n\r\n/**\r\n * Your CustomStack struct will be instantiated and called as such:\r\n * CustomStack* obj = customStackCreate(maxSize);\r\n * customStackPush(obj, x);\r\n \r\n * int param_2 = customStackPop(obj);\r\n \r\n * customStackIncrement(obj, k, val);\r\n \r\n * customStackFree(obj);\r\n*/\r\n```\r\n\r\n## 复杂度\r\n\r\n时间：各项操作均为O(1)\r\n空间：O(maxSize)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zfaye":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838600080","body":"**思路**：[indexOf](int ch）[indexOf](int ch,  int fromIndex)获取前后两个指针，取小的绝对距离\r\n\r\n代码：\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        //int[] index=new int[s.length()];\r\n        int cur=s.indexOf(c);int pre=cur;\r\n       // Iterator<Integer> it=index.iterator();\r\n        int[] ans=new int[s.length()];\r\n        for(int i=0;i<s.length();i++){\r\n            if(s.charAt(i)== c) {\r\n               ans[i]=0;\r\n               pre=i;\r\n               cur=s.indexOf(c,i+1);\r\n            }else{\r\n                ans[i]=Math.min(Math.abs(i-pre),Math.abs(cur-i));\r\n             }\r\n\r\n\r\n        }\r\n\r\n\r\n    return ans;\r\n\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)?"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839632151","body":"思路：使用数组实现栈。成员变量top指向栈顶，在push()中判断溢出，pop()中分别判断栈是否为空。使用循环进行累加。\r\n\r\n```Java\r\npublic class CustomStack {\r\n    int[] stack;\r\n    int maxSize;\r\n    int top=-1;\r\n    public CustomStack(int maxSize) {\r\n        stack=new int[maxSize];\r\n        this.maxSize=maxSize;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if(top+1<maxSize){\r\n            top++;\r\n            stack[top]=x;\r\n\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if(top==-1){\r\n            return -1;\r\n        }else{\r\n            top--;\r\n            return  stack[top+1];\r\n\r\n        }\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int num=Math.min(k, top+1);\r\n        for (int i = 0; i < num; i++) stack[i]+=val;\r\n    }\r\n  \r\n  \r\n}\r\n```\r\n\r\n时间复杂度：O(min(k,cnt))\r\n\r\n空间复杂度：O(maxsize)\r\n\r\n思路二：将增量的循环操作舍弃，减少时间复杂度；增加一个数组只在pop（）时做加法，牺牲空间。\r\n\r\n```\r\npublic class CustomStack {\r\n    int[] stack;\r\n    int[] increment;\r\n    int maxSize;\r\n    int top = -1;\r\n    public CustomStack(int maxSize) {\r\n        stack=new int[maxSize];\r\n        increment=new int[maxSize+1];\r\n        this.maxSize=maxSize;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if(top+1<maxSize){\r\n            top++;\r\n            stack[top]=x;\r\n\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if(top==-1){\r\n            return -1;\r\n        }else{\r\n\r\n\r\n            //top--;\r\n             stack[top]+=increment[top+1];\r\n             increment[top]+=increment[top+1];\r\n             increment[top+1]=0;\r\n             top--;\r\n             return stack[top+1];\r\n\r\n        }\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        //int num=Math.min(k, top+1);\r\n         increment[Math.min(k, top+1)]+=val;\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度：O(1)\r\n\r\n空间复杂度：O(maxsize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840356324","body":"思路：使用一个栈实现。在遇到右括号时出栈，使用栈的peek()方法，一直出栈，直到遇到左括号。将字符串和次数相乘后入栈。\r\n\r\n```\r\nclass Solution {\r\n\r\n    public String decodeString(String s) {\r\n\r\n        Stack<String> st= new Stack<>();\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == ']') {\r\n                StringBuilder repeatStr = new StringBuilder();\r\n                while (!st.peek().equals(\"[\")) repeatStr.append(st.pop()) ;\r\n\r\n                st.pop();//删去“[”\r\n                StringBuilder scount = new StringBuilder();\r\n                while ((!st.isEmpty()) && (st.peek().charAt(0) >= '0' && st.peek().charAt(0) <= '9')) {\r\n                    scount.append(st.pop()) ;\r\n                }\r\n                scount=scount.reverse();\r\n                int count = Integer.parseInt(scount.toString());\r\n                StringBuilder res = new StringBuilder();;\r\n                for (int j = 0; j < count; j++) res.append(repeatStr) ;\r\n                st.push(res.toString());\r\n            } else {\r\n                String str = \"\" + s.charAt(i);\r\n                st.push(str);\r\n            }\r\n\r\n        }\r\n        StringBuilder ans=new StringBuilder();\r\n        while(!st.isEmpty()){\r\n            ans.append(st.pop());\r\n        }\r\n        ans.reverse();\r\n        return ans.toString();\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840978495","body":"思路：简单题，使用两个栈，在peek()和pop()的时候，把一个栈的内容倒到另一个栈。\r\n\r\n```\r\nclass MyQueue {\r\n\r\n  // int n;\r\n\r\n  Stack<Integer> tmp=new Stack<>();\r\n\r\n  Stack<Integer> st;\r\n\r\n  /** Initialize your data structure here. */\r\n\r\n  public MyQueue() {\r\n\r\n    st=new Stack<>();\r\n\r\n  }\r\n\r\n  \r\n\r\n  /** Push element x to the back of queue. */\r\n\r\n  public void push(int x) {\r\n\r\n   st.push(x);\r\n\r\n   //  n++;\r\n\r\n  }\r\n\r\n  \r\n\r\n  /** Removes the element from in front of queue and returns that element. */\r\n\r\n  public int pop() { \r\n\r\n     while(tmp.isEmpty()){\r\n\r\n       while(!st.isEmpty())\r\n\r\n      tmp.push(st.pop());\r\n     }\r\n\r\n   \r\n\r\n\r\n\r\n    return tmp.pop();\r\n\r\n\r\n\r\n  }\r\n\r\n  \r\n\r\n  /** Get the front element. */\r\n\r\n  public int peek() {\r\n\r\n    // Stack<Integer> tmp=new Stack<>()\r\n\r\n   while(tmp.isEmpty()){\r\n\r\n      while(!st.isEmpty())\r\n\r\n      tmp.push(st.pop());\r\n\r\n    }\r\n\r\n  \r\n\r\n    return tmp.peek();\r\n\r\n\r\n\r\n  }\r\n\r\n  \r\n\r\n  /** Returns whether the queue is empty. */\r\n\r\n  public boolean empty() {\r\n\r\n    return tmp.isEmpty()&&st.isEmpty();\r\n\r\n  }\r\n\r\n}\r\n```\r\n\r\n时间复杂度：pop()和peek()只需倒一次后，例如有n个元素，执行n次出栈和n次入栈。后面pop()和peek()都只有一次操作。将前者2n次的操作平均到后面，故均摊复杂度O(1).\r\n\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841632788","body":"一看到hard就放弃了，下次争取多想一会儿。\r\n\r\n思路：分块条件：左边最大值小于右边最小值。一看到这种左边右边的，好像都可以用两次遍历解决，分别从左到右，和从右到左。加上比较一共三次循环，效率不高，但是思路简单。\r\n\r\n```java\r\nclass Solution {\r\n\r\n  public int maxChunksToSorted(int[] arr) {\r\n\r\n​    int n=arr.length;\r\n\r\n​    int right_min[]=new int[n];\r\n\r\n​    int left_max[]=new int[n];\r\n\r\n\r\n\r\n​    for(int i=n-1;i>=0;i--){\r\n\r\n​      if(i==n-1) right_min[i]=arr[i];\r\n\r\n​      else\r\n\r\n​      right_min[i]=Math.min(right_min[i+1],arr[i]);\r\n\r\n​    }\r\n\r\n​    int chunks=1;\r\n\r\n​    for(int i=0;i<n-1;i++){\r\n\r\n​      if(i==0) left_max[i]=arr[i];\r\n\r\n​      else\r\n\r\n​      left_max[i]=Math.max(left_max[i-1],arr[i]);\r\n\r\n​      }\r\n\r\n\r\n\r\n​    \r\n\r\n​    for(int i=0;i<n-1;i++){\r\n\r\n​        if(left_max[i]<=right_min[i+1])\r\n\r\n​        chunks++;\r\n\r\n​    }\r\n\r\n​    return chunks;\r\n\r\n  }  \r\n\r\n}\r\n```\r\n\r\nTime：O(n)\r\n\r\nspace:O(n)\r\n\r\n单调栈：满足题意，遍历过程中比左边小的一定要融合；尽可能多分块，比较大的，入栈。需要注意的是块的融合过程（需要弹出已经入栈的元素），需要比较的，也就是说需要保存的是块的最大值，要重新入栈。栈在入栈过程是单调递增的，所以是栈顶值。\r\n\r\n```Java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> st=new Stack<Integer>();\r\n        int max;\r\n       // st.push(arr[0]);\r\n        for(int num:arr){\r\n            if(!st.isEmpty()&&num<st.peek()){\r\n                  max=st.peek();\r\n                while(!st.isEmpty()&&num<st.peek())\r\n                 st.pop();//需要融合所以弹出，融完了再入一个最大值（下一步）\r\n\r\n                st.push(max);//栈顶始终为块的最大值\r\n            }//块融合\r\n\r\n\r\n            else st.push(num);//大于等于则为新块，入栈\r\n\r\n           // max=Math.\r\n\r\n        }\r\n        return st.size(); \r\n\r\n    }  \r\n   \r\n}\r\n```\r\n\r\nTime:O(n)\r\n\r\nSpace:O(n)\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"winterdogdog":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838615479","body":"```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let array = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        array[i] = s.length;\r\n    }\r\n    for (let i = 0; i < s.length; i++){\r\n        if ( s.substring(i, i+1) === c){\r\n            for (let j = 0; j < s.length; j++){\r\n                array[j] = Math.min(Math.abs(i - j),array[j])\r\n            }\r\n        }\r\n    }\r\n    return array;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839868593","body":"```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.list = [];\r\n    this.maxSize = maxSize\r\n\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.list.length < this.maxSize) {\r\n        this.list.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    let res = this.list.pop()\r\n    return res === undefined ? -1 : res\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n   this.list.forEach((item, index) => {\r\n       if (index < k) {\r\n           this.list[index] += val\r\n       }\r\n   }) \r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840593759","body":"```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let numStack = [], stringStack = [], num = 0, result = '';\r\n    for(let cur of s) {\r\n        if (\"0\" <= cur && cur <= \"9\") {\r\n            num = num * 10 + Number(cur)\r\n        } else if (cur === '[') {\r\n            stringStack.push(result);\r\n            numStack.push(num);\r\n            result = '';\r\n            num = 0;\r\n        } else if (cur === ']') {\r\n            let newNum = numStack.pop();\r\n            result = stringStack.pop() + result.repeat(newNum);\r\n        } else {\r\n            result = result + cur\r\n        }\r\n    }\r\n    return result\r\n};\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841680951","body":"```js\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n    const sorted = arr.slice().sort((a, b) => a - b)\r\n    let sum = 0, count = 0, sumSorted = 0\r\n    arr.forEach((item, index) => {\r\n        sum = sum + item;\r\n        sumSorted = sumSorted + sorted[index];\r\n        if (sum === sumSorted) {\r\n            count ++\r\n            sum = sumSorted = 0\r\n        }\r\n    })\r\n    return count\r\n\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"NealChristmas":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838633616","body":"```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n\r\n    const stackRight = []\r\n    const stackLeft = []\r\n    for (let i = 0; i < s.length; i++) {\r\n        const char = s[i]\r\n        if (char === c) {\r\n            stackRight.unshift(i)\r\n        }\r\n    }\r\n    let i = 0\r\n    const res = []\r\n    while (i < s.length) {\r\n        let topRight = stackRight[stackRight.length - 1]\r\n        if (topRight !== undefined && i > topRight) {\r\n            stackLeft.push(stackRight.pop())\r\n        }\r\n        topRight = stackRight[stackRight.length - 1] === undefined ? Number.MAX_SAFE_INTEGER : stackRight[stackRight.length - 1]\r\n        let topLeft = stackLeft[stackLeft.length - 1] === undefined ? Number.MAX_SAFE_INTEGER : stackLeft[stackLeft.length - 1]\r\n        const minDis = Math.min(Math.abs(i - topLeft), Math.abs(i - topRight))\r\n        i++\r\n        res.push(minDis)\r\n    }\r\n    return res\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838633616","body":"```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n\r\n    const stackRight = []\r\n    const stackLeft = []\r\n    for (let i = 0; i < s.length; i++) {\r\n        const char = s[i]\r\n        if (char === c) {\r\n            stackRight.unshift(i)\r\n        }\r\n    }\r\n    let i = 0\r\n    const res = []\r\n    while (i < s.length) {\r\n        let topRight = stackRight[stackRight.length - 1]\r\n        if (topRight !== undefined && i > topRight) {\r\n            stackLeft.push(stackRight.pop())\r\n        }\r\n        topRight = stackRight[stackRight.length - 1] === undefined ? Number.MAX_SAFE_INTEGER : stackRight[stackRight.length - 1]\r\n        let topLeft = stackLeft[stackLeft.length - 1] === undefined ? Number.MAX_SAFE_INTEGER : stackLeft[stackLeft.length - 1]\r\n        const minDis = Math.min(Math.abs(i - topLeft), Math.abs(i - topRight))\r\n        i++\r\n        res.push(minDis)\r\n    }\r\n    return res\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raoshuang":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838653080","body":"- 暴力解法：遍历找出c字符的所有下标，然后找再次遍历找出最小值\r\n-class Solution {\r\npublic:\r\n    vector<int> s1;\r\n    vector<int> s2;\r\n   \r\n    vector<int> shortestToChar(string s, char c) {\r\n    for(int i=0;i<s.length();++i){\r\n        if(s[i] == c){\r\n            s1.push_back(i);\r\n        }\r\n    } \r\n    \r\n    for(int i=0;i<s.length();++i){\r\n        int len=s.length(),minlen=s.length();\r\n        for(int j=0;j<s1.size();++j){\r\n            len = abs(s1[j]-i);\r\n            minlen = min(len,minlen);\r\n        }\r\n        s2.push_back(minlen);\r\n\r\n    }\r\n    return s2;\r\n    }\r\n};"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838653080","body":"- 暴力解法：遍历找出c字符的所有下标，然后找再次遍历找出最小值\r\n-class Solution {\r\npublic:\r\n    vector<int> s1;\r\n    vector<int> s2;\r\n   \r\n    vector<int> shortestToChar(string s, char c) {\r\n    for(int i=0;i<s.length();++i){\r\n        if(s[i] == c){\r\n            s1.push_back(i);\r\n        }\r\n    } \r\n    \r\n    for(int i=0;i<s.length();++i){\r\n        int len=s.length(),minlen=s.length();\r\n        for(int j=0;j<s1.size();++j){\r\n            len = abs(s1[j]-i);\r\n            minlen = min(len,minlen);\r\n        }\r\n        s2.push_back(minlen);\r\n\r\n    }\r\n    return s2;\r\n    }\r\n};"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840653187","body":"思路：用两个栈来解决\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<string> let;\r\n        stack<int> num;\r\n\r\n        string ans = \"\";\r\n        int cur = 0;\r\n\r\n        for(const char& c : s)\r\n        {\r\n            if(isdigit(c))\r\n                cur = cur*10 + c - '0';\r\n            else if(c == '[')\r\n            {\r\n                let.push(ans);\r\n                num.push(cur);\r\n                cur = 0;\r\n                ans = \"\";\r\n            }\r\n            else if(c == ']')\r\n            {\r\n                string str = ans;\r\n                for(int i = 0; i < num.top()-1; ++i)\r\n                    ans += str;\r\n                ans = let.top() + ans;\r\n                num.pop();\r\n                let.pop();\r\n            }\r\n            else\r\n                ans += c;\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841127783","body":"- 思路：用两个栈来实现队列，一个输入一个输出（先进后出+先进后出 = 先进先出）\r\n- 改进：pop（）和top（）操作都需要判断输出栈是否为空，如果输出栈为空，就把输入栈的数据转到输出栈。由于这样的操作需要两次，可以写成一个类的成员函数in2out，这样代码就只需要写一遍。\r\n- 代码：\r\n`class MyQueue {\r\n    stack<int> s_in;\r\n    stack<int> s_out;\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        s_in.push(x);\r\n\r\n    }\r\n    \r\n    void in2out(){\r\n        while(!s_in.empty()){\r\n              s_out.push(s_in.top());\r\n              s_in.pop();\r\n          }\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n      if(s_out.empty()){\r\n          in2out();\r\n      }\r\n      int num_pop = s_out.top();\r\n      s_out.pop();\r\n      return num_pop;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n    if(s_out.empty()){\r\n          in2out();\r\n      }\r\n      int num_top = s_out.top();\r\n      return num_top;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return s_in.empty()&&s_out.empty();\r\n     \r\n    }\r\n};`\r\n\r\n- 复杂度分析：\r\n- 时间复杂度：push（）和empty（）都是O（1），pop（）和top（）是O（n）\r\n- 空间复杂度：O（n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841466401","body":"思路：用栈来存每个模块的最大值。栈有几个最大值，就说明有几个模块。\r\n\r\n代码：\r\n\r\nclass Solution {\r\nint max_num;\r\nstack stack1;\r\n\r\npublic:\r\nint maxChunksToSorted(vector& arr) {\r\nstack1.push(arr[0]); //把第一个元素在循环前插入栈中\r\nfor(int i=1;i<arr.size(); i++){\r\n\r\n   if(stack1.top()<=arr[i]){\r\n      stack1.push(arr[i]);\r\n      \r\n   }\r\n   if(stack1.top()>arr[i]){\r\n       max_num = stack1.top();\r\n       while(!stack1.empty()&&stack1.top()>arr[i]){//这个句子最开始写错了，没加上!stack.empty()&&，会stack已经空了却还在调用stack1.top()的情况出现\r\n           stack1.pop();\r\n       }\r\n       stack1.push(max_num);\r\n       \r\n   }\r\n}\r\nreturn stack1.size();\r\n}\r\n};\r\n\r\nTime: O(n)\r\nSpace: O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaoyuhai":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838666444","body":"/**\r\n* 找出左右两边距离最近的，再取其中最小的\r\n*/ \r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] result = new int[s.length()];\r\n        int pre = -2000;\r\n        for(int i =0; i < s.length(); i++){\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n            result[i] = i - pre;\r\n        }\r\n        pre = 2000;\r\n        for(int i = s.length() -1 ; i >=0; i--){\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n            result[i] = Math.min(result[i],pre-i);\r\n        }\r\n        return result;\r\n    }"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839772089","body":"数组模拟栈,top记录栈顶元素位置\r\n\r\n    class CustomStack {\r\n        int top;\r\n        int[] stack;\r\n        public CustomStack(int maxSize) {\r\n           //初始化数组\r\n           stack = new int[maxSize];\r\n           top = -1;     \r\n        }\r\n        \r\n        public void push(int x) {\r\n            //如果数组中还没满，将数组下边向后移动一位并赋值\r\n            if(top!= stack.length-1){\r\n                ++top;\r\n                stack[top] = x;\r\n            }\r\n         \r\n        }\r\n        \r\n        public int pop() {\r\n            //如果数组元素不为空，返回顶部元素，top向前移动一位\r\n            if(top==-1){\r\n                return -1;\r\n            }\r\n            top--;\r\n            return stack[top+1];\r\n        }\r\n        \r\n        public void increment(int k, int val) {\r\n            //需要加的下标 为 k 和 top+1 长度中短的那个\r\n            int index = Math.min(k,top+1);\r\n            for(int i=0; i < index; i++){\r\n                stack[i] += val;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840648761","body":"算法流程：\r\n\r\n构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\r\n\r\n当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\r\n\r\n当 c 为字母时，在 res 尾部添加 c；\r\n\r\n当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 00：\r\n\r\n记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\r\n\r\n记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\r\n\r\n进入到新 [ 后，res 和 multi 重新记录。\r\n\r\n当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\r\n\r\nlast_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\r\n\r\ncur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\r\n\r\n返回字符串 res。\r\n\r\n复杂度分析：\r\n\r\n时间复杂度 O(N)O(N)，一次遍历 s；\r\n\r\n空间复杂度 O(N)O(N)，辅助栈在极端情况下需要线性空间，例如 2[2[2[a]]]\r\n\r\n代码\r\n\r\n    public String decodeString(String s) {\r\n            StringBuilder res = new StringBuilder();\r\n            int multi = 0;\r\n            LinkedList<Integer> stack_multi = new LinkedList<>();\r\n            LinkedList<String> stack_res = new LinkedList<>();\r\n            for (Character c : s.toCharArray()) {\r\n                if (c == '[') {\r\n                    stack_multi.addLast(multi);\r\n                    stack_res.addLast(res.toString());\r\n                    multi = 0;\r\n                    res = new StringBuilder();\r\n                    continue;\r\n                }\r\n                if (c == ']') {\r\n                    StringBuilder tmp = new StringBuilder();\r\n                    int cur_multi = stack_multi.removeLast();\r\n                    for (int i = 0; i < cur_multi; i++) tmp.append(res);\r\n                    res = new StringBuilder(stack_res.removeLast() + tmp);\r\n                    continue;\r\n                }\r\n                if (Character.isDigit(c)) {\r\n                    multi = multi * 10 + Integer.parseInt(c + \"\");\r\n                    continue;\r\n                }\r\n                res.append(c);\r\n            }\r\n            return res.toString();\r\n    \r\n        }\r\n\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841298669","body":"思路\r\n\r\n将一个栈当作输入栈，用于压入传入的数据；另一个栈当作输出栈；若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。\r\n\r\n代码\r\n\r\n    class MyQueue {\r\n    \r\n        /** Initialize your data structure here. */\r\n        Deque<Integer> inStack;\r\n        Deque<Integer> outStack;\r\n        public MyQueue() {\r\n            inStack = new LinkedList<Integer>();\r\n            outStack = new LinkedList<Integer>();\r\n        }\r\n        \r\n        /** Push element x to the back of queue. */\r\n        public void push(int x) {\r\n           inStack.push(x);\r\n        }\r\n        \r\n        /** Removes the element from in front of queue and returns that element. */\r\n        public int pop() {\r\n            if(outStack.isEmpty()){\r\n                initOutStack();\r\n            }\r\n            return outStack.pop();\r\n        }\r\n        \r\n        /** Get the front element. */\r\n        public int peek() {\r\n            if(outStack.isEmpty()){\r\n                initOutStack();\r\n            }\r\n            return outStack.peek();\r\n        }\r\n        \r\n        /** Returns whether the queue is empty. */\r\n        public boolean empty() {\r\n            return inStack.isEmpty() && outStack.isEmpty();\r\n        }\r\n        public void initOutStack(){\r\n            while(!inStack.isEmpty()){\r\n                outStack.push(inStack.pop());\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841677381","body":"\r\n\r\n遍历数组 arrarr 中的每个数字 numnum ；\r\n\r\n当栈 stackstack 不为空且数字 num<num<栈顶值 时： （代表此 numnum 会改变前面排序块分布）\r\n\r\n栈顶 pop() 出栈，并保存栈顶值为 headhead 。 （此情况下，新排序块最大值还为 headhead ，因此先暂存）\r\n\r\n当 stackstack 不为空且数字 num<num<栈顶值 时，循环栈顶 pop() 出栈。 （判断加入 numnum 需要合并的所有排序块，每 pop() 一个 headhead 代表合并一个块）\r\n\r\n将保存的栈顶值 headhead 重新 push() 入栈。 （将 headhead 重新加入，作为新排序块的最大值）\r\n\r\n当栈 stackstack 为空或数字 num>=num>=栈顶值 时： （代表此 numnum 不影响前面排序块分布）\r\n\r\n将 numnum 数字 push() 入栈。 （加入单个元素的新排序块 [num]）\r\n\r\n遍历完成后，栈中保存 所有排序块的对应最大值 headhead ，因此返回栈 stackstack 长度即可获得排序块数量。\r\n\r\n复杂度分析：\r\n\r\n时间复杂度 O(N)O(N) ：遍历一遍 arrarr 为 O(N)O(N)，修正排序块最多遍历一遍 arrarr 为 O(N)O(N)；\r\n\r\n空间复杂度 O(N)O(N) ：极端情况下排序块数量等于数组长度，此时 stackstack 占用线性大小额外空间。\r\n\r\n    class Solution {\r\n       public int maxChunksToSorted(int[] arr) {\r\n            LinkedList<Integer> stack = new LinkedList<Integer>();\r\n            for(int num : arr) {\r\n                if(!stack.isEmpty() && num < stack.getLast()) {\r\n                    int head = stack.removeLast();\r\n                    while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\r\n                    stack.addLast(head);\r\n                }\r\n                else stack.addLast(num);\r\n            }\r\n            return stack.size();\r\n        }\r\n    \r\n    }\r\n\r\n\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mayu0007":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838671847","body":"### 思路\r\n\r\n参考了参考答案的动态规划。\r\n双次遍历数组 \r\n- dp数组状态量：与上一个c的距离\r\n\r\n  左遍历\r\n    - 状态转移方程：```dp[i] = dp[i-1] + 1 ```\r\n    - 边界条件：```if s[i] == c: dp[i] = 0 ```\r\n\r\n  右遍历\r\n    - 状态转移方程：```dp[i] = min(dp[i+1] + 1, dp[i]) ```\r\n    - 边界条件：```if s[i] == c: dp[i] = 0 ```\r\n\r\n### caveat\r\n不要忘记check index的范围\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        # traverse 2 times \r\n        # left to right: each element store distance to the nearest C met before (on the LEFT).\r\n        # right to left: each element store the distance to the nearest C on the RIGHT. \r\n        # compare the value of both. \r\n        # initialize array with inf\r\n        \"\"\"\r\n        # 参考答案的prev initialization有点难理解\r\n        result = []\r\n        prev = -float('inf')\r\n        for i, elem in enumerate(s):\r\n            if elem == c:\r\n                prev = i \r\n            result[i] = i - prev \r\n\r\n        prev = float('inf')\r\n        for i in range(len(s)-1,0,-1):\r\n            if s[i] == c:\r\n                prev = i \r\n            result[i] = min(prev-i, result[i])\r\n        return result\r\n        \"\"\"\r\n        dp = [float('inf')]*len(s) # float('inf') is a number bigger than all others \r\n        \"\"\"\r\n        num = float('inf')\r\n        print(num > 1000) #True\r\n        print(num + 1 == num) #True \r\n        print(num-1) #inf\r\n        \"\"\"\r\n        for i, elem in enumerate(s):\r\n            if elem == c:\r\n                dp[i] = 0 \r\n            elif i > 0: #index range checking\r\n                dp[i] = dp[i-1] + 1\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                dp[i] = 0 \r\n            elif i < len(s)-1: #index range checking\r\n                dp[i] = min(dp[i+1] + 1, dp[i])\r\n                \r\n        return dp\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，N 为数组`s`的长度，两次遍历\r\n- 空间复杂度：O(N), N 为数组`s`的长度，也是返回值\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839563314","body":"## 解题思路1\r\n\r\n用python的list实现stack，注意push/increment 确认没有满栈\r\n\r\n### Code\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n        \r\n    def pop(self) -> int:\r\n        return self.stack.pop() if len(self.stack) else -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i] += val \r\n```\r\n\r\n### Complexity\r\n**Time Complexity**: increment - `O(k)` \\\r\n**Space Complexity**: a dynamic array of size `O(maxSize)` \r\n\r\n## 解题思路2 \r\n\r\n优化increment的时间复杂度\r\ncreate auxiliary list to store increment val for bottom k elements at position closest to top. \r\n\r\n### Code \r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0] * maxSize\r\n        self.add = [0] * maxSize\r\n        self.top = -1 #record index of top element\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top < len(self.stack) - 1:\r\n            self.top += 1\r\n            self.stack[self.top] = x\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        last_index_to_add = min(k-1, self.top)\r\n        if last_index_to_add >= 0:\r\n            self.add[last_index_to_add] += val\r\n        \r\n    def pop(self) -> int:\r\n        if self.top == -1: return -1\r\n        \r\n        result = self.add[self.top] + self.stack[self.top]\r\n        \r\n        if self.top > 0:\r\n            self.add[self.top-1] += self.add[self.top]\r\n        self.add[self.top] = 0 \r\n        self.top -= 1\r\n\r\n        return result \r\n```\r\n### Complexity\r\n**Time Complexity**: init/push/pop/increment - `O(1)` \\\r\n**Space Complexity**: 2 dynamic array of size `O(maxSize)` "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840607195","body":"## 解题思路1\r\n\r\nNested square brackets need to be processed inside out to generate substrings, which aligns with stack's FILO character\r\n\r\n### Code\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        # 1. stack: push all characters and pop when encounter \"]\" to compute the augmented substring, then push the concatenated substring back onto stack \r\n        stack = []\r\n        for c in s:\r\n            if c == \"]\":\r\n                repeatStr = ''\r\n                repeatMul = ''\r\n                while stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr # Caveat: need to concatenate character in reverse order \r\n                # pop off \"[\" \r\n                stack.pop()\r\n\r\n                while stack and stack[-1].isdigit(): # Caveat: stack is popped every iteration, need to terminate loop when stack is empty to ensure indexing is valid \r\n                    repeatMul = stack.pop() + repeatMul # Caveat: need to concatenate character in reverse order \r\n                stack.append(int(repeatMul)*repeatStr) \r\n            else: \r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n\r\n\r\n\r\n\r\n```\r\n\r\n### Complexity\r\n**Time Complexity**: `O(N)` to traverse the string `s` \\\r\n**Space Complexity**: `O(N)` if keeps pushing all elements into stack before enclosing bracket \r\n\r\n## 解题思路2 \r\n\r\nrecursion. (to-do)\r\n\r\n### Code \r\n```python\r\n\r\n```\r\n### Complexity\r\n**Time Complexity**: `O(N)` to traverse the string `s` \\\r\n**Space Complexity**: `O(N)` for max recursion depth "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841267005","body":"## 解题思路\r\nsince queue is FIFO, in reversing order as stack (FILO), we can use an auxiliary stack to reverse the sequence of element. \r\n- push is `O(N)`:  the main stack keep elements in queue's manner: the pushed element at the bottom\r\n- pop: `O(1)`\r\n- peek: `O(1)`\r\n- is.empty(): same as checking if s1 is empty\r\n\r\n### push and pop O(1)的思路\r\nseparate enque and deque. \r\n- push is `O(1)`. Since order is reversed, \r\n- for pop/peak, data need to be moved to s2. s2 is the queue's order, pop/peek is `O(1)`. Migrating elements only when output stack s2 is empty. \r\n- isempty: elements can be in either input stack or output stack if previous batch all dequed. so need to check whether both stacks are empty\r\n\r\n\r\n### Code\r\n\r\n```python\r\n\r\nclass MyQueue:\r\n# O(1) amortized cost\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.input_stk = [] \r\n        self.output_stk = []  \r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.input_stk.append(x) \r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.output_stk: \r\n            while self.input_stk: \r\n                self.output_stk.append(self.input_stk.pop()) \r\n        return(self.output_stk.pop())\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.output_stk: \r\n            while self.input_stk: \r\n                self.output_stk.append(self.input_stk.pop()) \r\n        return(self.output_stk[-1]) \r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.input_stk) == 0 and len(self.output_stk) == 0 \r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()              \r\n```\r\n\r\n### Complexity\r\n**Time Complexity**: `O(1)` for push, isempty, amortised `O(1)` for peek/pop to account for 1 time element pop/push onto output stack \\\r\n**Space Complexity**: `O(N)` for additional output stack\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841645157","body":"## 解题思路\r\n每个chunk的最大元素要小于后面任何元素。\r\n构造辅助stack，存储每个chunk的最大元素，遇到新元素比之前chunk的最大元素小，需要将新元素并入最后的chunk，之前所有chunk最大元素大于新元素也需要并入最末chunk\r\n\r\n\r\n### Code\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        # keep valid chunks on stack, each element record largest elem of chunk. \r\n        # if new elem a encountered smaller than top elem, merge the new elem to the last chunk, \r\n        # but all previous chunks whose largest elem smaller than a must also merge with the last chunk.  \r\n        chunks = []\r\n        for elem in arr:\r\n            if not chunks or chunks[-1] < elem: \r\n                chunks.append(elem)\r\n            else:\r\n                last = chunks[-1]\r\n                while chunks and chunks[-1] > elem:\r\n                    chunks.pop()\r\n                chunks.append(last)\r\n        \r\n        return len(chunks)         \r\n```\r\n\r\n### Complexity\r\n**Time Complexity**: `O(N)` loop through the arr once \\\r\n**Space Complexity**: `O(N)` for auxiliary stack to store the max elem of each chunk\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838700474","body":"### 思路分析\r\n1. 遍历两次字符串， 一次从左到右遍历，一次从右到左遍历\r\n2. 两次遍历分别记录s[i]对 c 的距离\r\n3. 两者比较, 保留较小值\r\n\r\n\r\n### 代码实现 JavaScript\r\n\r\n```\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const res = new Array(s.length).fill(Infinity)\r\n\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] === c) res[i] = 0;\r\n    else res[i] = i == 0 ? Infinity : res[i - 1] + 1\r\n  }\r\n\r\n  for(let i = s.length - 1; i >= 0; i--){\r\n    if(res[i] == Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：$O(N)$, N为字符串长度\r\n- 空间复杂度：$O(1)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839846755","body":"### 思路\r\n  用数组模拟栈，用数组原生方法pop、push方法实现\r\n  \r\n### 代码\r\n\r\n```\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.stack.length >= this.maxSize) {\r\n    return;\r\n  }\r\n  this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  return this.stack.length ? this.stack.pop() : -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  const length = Math.min(k, this.stack.length);\r\n  for (let i = 0; i < length; i++) {\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n```\r\n### 复杂度\r\n- 时间复杂度 \r\n\r\n  push: O(1)\r\n\r\n  pop：O(1)\r\n  \r\n  increment：O(K) \r\n \r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840630345","body":"### 思路\r\n1. 将字符串从末尾开始遍历\r\n2. 遇到“]”入栈\r\n3. 拼接要出栈的字符串，遇到\"[\"出栈\r\n4. \"[\"后紧跟数据，累计最终的数字\r\n5. 将遍历后入栈的字符串出栈，进行反转拼接，得到最终结果\r\n\r\n### 代码\r\n\r\n```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\n var decodeString = function(s) {\r\n    let stack = []; // 定义存储字符串的栈\r\n    let str = \"\"; // 定义最终返回的字符串\r\n    let num = \"\"; // 定义字符串重复的次数\r\n    const length = s.length;\r\n    for (let i = length - 1; i >= 0; i--) {\r\n      console.log(\"s[i]\", stack, i);\r\n      if (s[i] >= \"0\" && s[i] <= \"9\") {\r\n        // 解析出连续的数字\r\n        while (s[i] >= \"0\" && s[i] <= \"9\") {\r\n          num += s[i];\r\n          i--;\r\n          console.log(\"num\", num);\r\n        }\r\n        stack.push(\r\n          str.repeat(\r\n            Number(\r\n              num\r\n                .split(\"\")\r\n                .reverse()\r\n                .join(\"\")\r\n            )\r\n          )\r\n        ); // 拼接字符\r\n        str = \"\";\r\n        num = \"\"; //清空计数\r\n        i++;\r\n      } else if (s[i] === \"[\") {\r\n        // 遇到\"[\"时，将后续字符出栈\r\n        let curStr = stack.pop();\r\n        while (curStr !== \"]\") {\r\n          str += curStr;\r\n          curStr = stack.pop(); // 拼接出栈的字符串 \"[\"后跟着的一定是数字\r\n        }\r\n      } else {\r\n        // 将字符 或 \"]\"入栈\r\n        stack.push(s[i]);\r\n      }\r\n    }\r\n    return stack.reverse().join(\"\");\r\n  };\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：$O(N)$\r\n- 空间复杂度：$O(N)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841296958","body":"\r\n### 思路\r\n    定义两个栈，\r\n-   一个是pushStack, 执行push操作时，将元素入pushStack栈\r\n-   另一个是popStack,执行pop操作时，在popStack取元素；当popStack栈为空时，依次将pushStack元素pop取出，push进pushStack栈\r\n\r\n\r\n### 代码实现\r\njavaScript\r\n```\r\nvar MyQueue = function() {\r\n    this.pushStack = [];\r\n    this.popStack = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.pushStack.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if(this.popStack.length === 0) {\r\n        while(this.pushStack.length > 0) {\r\n            this.popStack.push(this.pushStack.pop())\r\n        }\r\n    }\r\n    return this.popStack.pop();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if(this.popStack.length === 0) {\r\n        while(this.pushStack.length > 0) {\r\n            this.popStack.push(this.pushStack.pop())\r\n        }\r\n    }\r\n    return this.popStack[this.popStack.length - 1];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.popStack.length === 0 && this.pushStack.length === 0;\r\n};\r\n\r\n```\r\n### 复杂度分析\r\n- 时间复杂度 $O(1)$\r\n- 空间复杂度 $O(N)$, N为队列元素个数\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841681803","body":"### 单调栈\r\n\r\n### 代码实现\r\njavaScript\r\n\r\n```\r\nvar maxChunksToSorted = function(arr) {\r\n    let queue = [];\r\n    for (let i = 0; i < arr.length; i++){\r\n        if (queue.length === 0 || (queue[queue.length - 1] <= arr[i])){\r\n            queue.push(arr[i])\r\n        } else {\r\n            const value = queue.pop()\r\n            while (queue[queue.length - 1] > arr[i]){\r\n                queue.pop()\r\n            }\r\n            queue.push(value)\r\n        }\r\n    }\r\n    return queue.length\r\n};\r\n```\r\n### 复杂度分析\r\n- 时间复杂度 $O(N)$\r\n- 空间复杂度 $O(N)$\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AutumnDeSea":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838712904","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 数组和字符串的内存管理\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 数组的正向、反向遍历，是一道简单的左右指针的题目\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    // 字符串转数组的逻辑\r\n    // 数组的正向、反向遍历\r\n    sArr = s.split('')\r\n    const sLen = sArr.length\r\n    let arr = []\r\n    \r\n    for(var i = 0; i< sArr.length ; i++) {\r\n        var s = sArr[i]\r\n        var l = r = i\r\n          // 向左遍历\r\n        while(l > -1) {\r\n            if(sArr[l] == c) {\r\n                break\r\n            }\r\n            l--\r\n        }\r\n        // 像右遍历\r\n        while(r <  sLen) {\r\n            if(sArr[r] == c) {\r\n                break\r\n            }\r\n            r++\r\n        }\r\n        if(l === -1) {\r\n            l = -10000\r\n        }\r\n        if(r === sLen) {\r\n            r = 20000\r\n        }\r\n        var result = Math.min(r-i, i-l)\r\n        arr.push(result)\r\n    }\r\n    return arr\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838712904","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 数组和字符串的内存管理\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 数组的正向、反向遍历，是一道简单的左右指针的题目\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    // 字符串转数组的逻辑\r\n    // 数组的正向、反向遍历\r\n    sArr = s.split('')\r\n    const sLen = sArr.length\r\n    let arr = []\r\n    \r\n    for(var i = 0; i< sArr.length ; i++) {\r\n        var s = sArr[i]\r\n        var l = r = i\r\n          // 向左遍历\r\n        while(l > -1) {\r\n            if(sArr[l] == c) {\r\n                break\r\n            }\r\n            l--\r\n        }\r\n        // 像右遍历\r\n        while(r <  sLen) {\r\n            if(sArr[r] == c) {\r\n                break\r\n            }\r\n            r++\r\n        }\r\n        if(l === -1) {\r\n            l = -10000\r\n        }\r\n        if(r === sLen) {\r\n            r = 20000\r\n        }\r\n        var result = Math.min(r-i, i-l)\r\n        arr.push(result)\r\n    }\r\n    return arr\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841327427","body":"\r\n## 题目地址(232. 用栈实现队列)\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\r\n\r\n实现 MyQueue 类：\r\n\r\nvoid push(int x) 将元素 x 推到队列的末尾\r\nint pop() 从队列的开头移除并返回元素\r\nint peek() 返回队列开头的元素\r\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\r\n\r\n \r\n\r\n说明：\r\n\r\n你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n\r\n \r\n\r\n进阶：\r\n\r\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\r\n[[], [1], [2], [], [], []]\r\n输出：\r\n[null, null, null, 1, 1, false]\r\n\r\n解释：\r\nMyQueue myQueue = new MyQueue();\r\nmyQueue.push(1); // queue is: [1]\r\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\nmyQueue.peek(); // return 1\r\nmyQueue.pop(); // return 1, queue is [2]\r\nmyQueue.empty(); // return false\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= x <= 9\r\n最多调用 100 次 push、pop、peek 和 empty\r\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  栈的结构是先进后出，和数组的push pop相似\r\n-  用栈模拟队列，就要实现先进先出，此时需要一个辅助的栈，每次push的时候进行数据移位\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Initialize your data structure here.\r\n */\r\n// \r\nvar MyQueue = function() {\r\n    this.stack = []\r\n    this.helpstack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    let cur = null\r\n    while(cur = this.stack.pop()) {\r\n        this.helpstack.push(cur)\r\n    }\r\n    this.stack.push(x)\r\n    while(cur = this.helpstack.pop()) {\r\n        this.stack.push(cur)\r\n    }\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.stack.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[this.stack.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack.length === 0\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$，其中的n为栈中的元素，每次都需要循环一次\r\n- 空间复杂度：$O(n)$  使用了辅助栈，和原栈大小一致，所以为n\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyaoyao":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838716666","body":"### 思路分析\r\n中心扩展，每遍历一个元素时候，便向两边扩展，取最小值即可\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> res(n);\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c)\r\n                continue;\r\n            int l = i;\r\n            int r = i;\r\n            int len = 0;\r\n            \r\n            while (l >= 0 || r < n) {\r\n                if (s[l] == c) {\r\n                    len = i - l;\r\n                    break;\r\n                }\r\n                if (s[r] == c) {\r\n                    len = r - i;\r\n                    break;\r\n                }\r\n\r\n                if (l > 0) l--;\r\n                if (r < n) r++;\r\n            }\r\n            res[i] = len;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n## 复杂度\r\n+ 时间复杂度$O(N^2)$\r\n+ 空间复杂度$O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838716666","body":"### 思路分析\r\n中心扩展，每遍历一个元素时候，便向两边扩展，取最小值即可\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> res(n);\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c)\r\n                continue;\r\n            int l = i;\r\n            int r = i;\r\n            int len = 0;\r\n            \r\n            while (l >= 0 || r < n) {\r\n                if (s[l] == c) {\r\n                    len = i - l;\r\n                    break;\r\n                }\r\n                if (s[r] == c) {\r\n                    len = r - i;\r\n                    break;\r\n                }\r\n\r\n                if (l > 0) l--;\r\n                if (r < n) r++;\r\n            }\r\n            res[i] = len;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n## 复杂度\r\n+ 时间复杂度$O(N^2)$\r\n+ 空间复杂度$O(1)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mm12344":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838739105","body":"### 思路\r\n\r\n1. 第一遍正序遍历，遇非e保留序号，遇e存储索引进pre变量，再遇e则更新其索引。返回当前非e数到左边e的距离\r\n2. 第二遍倒序遍历，同上，返回当前非e数到右边e的距离\r\n3. 两者比大小，返回最小值\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        pre = -10000\r\n        ans = []\r\n\r\n        for i in range(len(S)):\r\n            if S[i] == C: pre = i\r\n            ans.append(i - pre)\r\n        pre = 20000\r\n        for i in range(len(S) - 1, -1, -1):\r\n            if S[i] == C: pre = i\r\n            ans[i] = min(ans[i], pre - i)\r\n        return ans\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839716817","body":"### 思路\r\n\r\n给定一个变量来记录栈顶的位置，更新数据来模拟栈的操作，但因为实质是函数内的数组，所以可以实现对除了栈顶元素外的改动。（后续再优化）\r\n\r\n### 代码\r\n\r\n\r\n```py3\r\nclass CustomStack:\r\n# use array in function makes the each elenments in stack \"visable\"\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0]*maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        # if stack size is smaller than maxSize, push in\r\n        # maxSize is not defined in this function, so use len of stack instead\r\n        if self.top < len(self.stk)-1:\r\n            self.stk[self.top+1] = x\r\n            self.top += 1\r\n\r\n    def pop(self) -> int:\r\n        # if stack is empty, return -1\r\n        # if stack is not empty, return the top value and delete it in the stack (no need)\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        # use the minimum value between k and self.stk length, then traverse\r\n        if k>-1:\r\n            for i in range(min(self.top+1,k)):\r\n                self.stk[i]+=val\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(min(k, maxSize)),\r\n- 空间复杂度：O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840631703","body":"### 思路\r\n\r\n1. 本题每层只包含三个信息：左括号前的字符串，左括号前的数字，左括号后的字符串\r\n2. 如果出现嵌套，则暂时存储前两个信息，以同样的方式对左括号后的内容嵌套进行分析\r\n3. 以右括号为标志进行嵌套层信息的弹出分解\r\n\r\n### 代码\r\n```py3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = [] # 暂存嵌套层外的前置信息\r\n        res = \"\" # 当前层的字符串\r\n        num = 0  \r\n        if len(s)>0:\r\n            for c in s:\r\n                if c.isdigit():\r\n                    num = 10*num + int(c)\r\n                elif c.isalpha():\r\n                    res += c\r\n                elif c == \"[\": # 遇到左括号就往栈里存入包含两个信息的元组（[前的字符串，[前的数字）\r\n                    stack.append((res,num))\r\n                    res, num = \"\", 0\r\n                else:\r\n                    # if c == \"]\"， 遇到右括号就开始弹出栈顶元组信息，组成当前层解码后的字符串\r\n                    top = stack.pop()\r\n                    res = top[0] + top[1]*res\r\n        return res\r\n\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(S)\r\n- 空间复杂度：O(S)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841683734","body":"### 思路\r\n利用计数排序前后不变原理\r\n\r\n### 代码\r\n\r\n``` py3\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        count_a = collections.defaultdict(int)\r\n        count_b = collections.defaultdict(int)\r\n        ans = 0\r\n\r\n        for a, b in zip(arr, sorted(arr)):\r\n            count_a[a] += 1\r\n            count_b[b] += 1\r\n            if count_a == count_b: ans += 1\r\n\r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n时间复杂度： O(N^2)\r\n空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Yueqi-19":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839848486","body":"时间复杂度：O(1)\r\n空间复杂度：O(N)\r\n```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int size;\r\n    int[] increment;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        increment = new int[maxSize + 1];\r\n        size = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(size == stack.length){\r\n            return;\r\n        }\r\n        stack[size++] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(size == 0){\r\n            return -1;\r\n        }\r\n        int res = stack[size - 1];\r\n        if(increment[size] != 0){\r\n            res += increment[size];\r\n            increment[size - 1] += increment[size];\r\n            increment[size] = 0;\r\n        }\r\n        size--;\r\n        return res;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        increment[Math.min(k, size)] += val;\r\n    }\r\n}\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841310834","body":"```java\r\nclass MyQueue {\r\n    private Stack<Integer> s1;\r\n    private Stack<Integer> s2;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (s2.empty()) {\r\n            while (!s1.empty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (s2.empty()) {\r\n            while (!s1.empty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.peek();\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s1.empty() && s2.empty();\r\n    }\r\n}\r\n```\r\n1）入队时-s1.push(x)；出队用 s1 s2\r\n2）出队时，如果s2为empty，把s1的数据全部倒入s2"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841680004","body":"java\r\n单调栈\r\n```java\r\npublic int maxChunksToSorted(int[] arr) {\r\n    int top = 0;\r\n    for(int a: arr) {\r\n        int max = a;\r\n        while(top > 0 && arr[top - 1] > a) {\r\n            max = Math.max(max, arr[--top]);\r\n        }\r\n        arr[top++] = max;\r\n    }\r\n    return top;\r\n}\r\n```\r\nTime complexity: O(n)\r\nSpace complexity: O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841754932","body":"双指针法\r\n我们需要从末端开始找到第n个节点之前的节点。 此节点将是新列表的最后一个节点，而从末尾开始的第n个节点将是新列表中的新头。\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        int listSize = 0;\r\n        while(fast != null){\r\n            fast = fast.next;\r\n            listSize++;\r\n        }\r\n        fast = head;\r\n        int realRotation = k % listSize;\r\n        for (int i = 0; i < realRotation; i++){\r\n            fast = fast.next;\r\n        }\r\n        while(fast.next != null){\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        fast.next = head;\r\n        head = slow.next;\r\n        slow.next = null;\r\n        return head;\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yinfenglin":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839166298","body":"Python\r\n\r\nclass Solution:\r\n\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        char_indices = [i for i, ltr in enumerate(s) if ltr == c]\r\n        \r\n        distances = []\r\n        for i in range(len(s)):\r\n            d_i = [abs(ci - i) for ci in char_indices]\r\n            distances.append(min(d_i))\r\n            \r\n        return distances"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841446671","body":"思路：\r\n如果max(arr[:j]) <= min(arr[j:]), 则在j位置之后分割。先遍历一遍生成min_arr, 第二次遍历生成分割。\r\n\r\nPython\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        def create_min_array(arr):\r\n            c_min = arr[-1]\r\n            min_arr = [c_min]\r\n            for i in range(2, len(arr)+1):\r\n                if arr[-i] < c_min:\r\n                    c_min = arr[-i]\r\n                min_arr.append(c_min)\r\n            return list(reversed(min_arr))\r\n        min_arr = create_min_array(arr)\r\n        \r\n        split_count = 0\r\n        e = 0\r\n        c_max = arr[0]\r\n        while e < len(arr):\r\n            if e+1 == len(arr):\r\n                split_count += 1\r\n            else:\r\n                if c_max < arr[e]:\r\n                    c_max = arr[e]\r\n                if c_max <= min_arr[(e+1)]:\r\n                    split_count += 1\r\n                    c_max = arr[e+1]\r\n            e += 1\r\n        return split_count\r\n```\r\nTime: O(n)\r\nSpace: O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MangoJuicy":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839433927","body":"## 思路\r\n因为是 fixed size stack，可以直接使用数组模拟。index 为指向 top 的指针。\r\n\r\n底部 k 个元素增量 val，可以 iterate bottom K items 来实现，复杂度为 O(n)。可以使用额外的存储inc，来记录要增加的位置。\r\npop 操作，stack top 元素 + 对应的 inc 增量。index - 1处的 增量变为 inc[index - 1] += inc[index]. pop 后，index 对应的增量归零。\r\n\r\n### 注意点\r\n\r\n- 边界，push 时 index 是否越界。\r\n- 边界，pop 时 是否存在 item。\r\n- 增量添加是否合理，空栈或者 k 非正数，无需添加操作。\r\n- 增量添加对应的index 计算，k 超过 stack 元素个数时，按 stack 实际数量操作。\r\n\r\n## 代码\r\n```java\r\n// push: regular push\r\n// pop: res = top + add[index]. If add[index] != 0, add[index - 1] += add[index]。 add[index] = 0\r\n// increment: add[min(k - 1, index)] = val \r\n\r\nclass CustomStack {\r\n    \r\n    private final int[] stack;\r\n    private final int[] add;\r\n    private int index;\r\n    private final int len;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        add = new int[maxSize];\r\n        index = -1; // point to top\r\n        len = maxSize;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (index < len - 1) {\r\n            index++;\r\n            stack[index] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (index < 0) {\r\n            return -1;\r\n        }\r\n        \r\n        int res = stack[index] + add[index];\r\n        if (index > 0) {\r\n            add[index - 1] += add[index];\r\n        }\r\n        add[index] = 0;\r\n        index--;\r\n        return res;\r\n        \r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if (k <= 0 || index < 0) {\r\n            return;\r\n        }\r\n        \r\n        add[Math.min(k - 1, index)] += val;\r\n    }\r\n}\r\n```\r\n空间复杂度：O(n)\r\n时间复杂度：O(1) for all operations."},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ningali":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839475296","body":"Time Complexity: O(N) \r\nSpace Complexity: O(N)\r\n\r\nJava\r\n\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        char[] chars = s.toCharArray();\r\n        int[] res = new int[length];\r\n        \r\n        int left = -length;\r\n        for (int i = 0; i < length; i++) {\r\n            if (chars[i] == c) {\r\n                left = i;\r\n                res[i] = 0;\r\n            } else {\r\n                res[i] = i - left;\r\n            }\r\n        }\r\n        int right = 2 * length;\r\n        for (int i = length - 1; i >= 0; i--) {\r\n            if (chars[i] == c) {\r\n                right = i;\r\n            } else {\r\n                res[i] = Math.min(right - i, res[i]);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chelseachen007":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839548839","body":"```javaScript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n    this.stack = []\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n    if (this.stack.length < this.maxSize) this.stack.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n    return this.stack.pop() || -1\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n    const min = Math.min(this.stack.length, k)\r\n    for (let i = 0; i < min; i++) {\r\n        this.stack[i] += val\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840232089","body":"### 解法一\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度: O(n)\r\n\r\n突出一个写的丑\r\n\r\n```JavaScript\r\nvar decodeString = function (s) {\r\n    let stack = []\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === \"]\") {\r\n            let pop = stack.pop()\r\n            let newStr = pop\r\n            while (pop !== '[') {\r\n                pop = stack.pop()\r\n                pop !== '[' && (newStr = pop + newStr)\r\n            }\r\n\r\n            pop = stack.pop()\r\n            let num = pop\r\n            while (!isNaN(pop)) {\r\n                pop = stack.pop()\r\n                !isNaN(pop) && (num = pop + num)\r\n            }\r\n            pop && stack.push(pop)\r\n            stack.push(newStr.repeat(num))\r\n        } else {\r\n            stack.push(s[i])\r\n        }\r\n    }\r\n    return stack.join('')\r\n};\r\n```\r\n\r\n## "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840931430","body":"### 解法一\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(1)\r\n\r\n空间复杂度: O(n)\r\n\r\n```JavaScript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function () {\r\n    this.pushStack = []\r\n    this.popStack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n    this.pushStack.push(x)\r\n};\r\nMyQueue.prototype._push2Pop = function (x) {\r\n    if (!this.popStack.length) {\r\n        while (this.pushStack.length) {\r\n            this.popStack.push(this.pushStack.pop())\r\n        }\r\n    }\r\n};\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n    this._push2Pop()\r\n    return this.popStack.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n    this._push2Pop()\r\n    return this.popStack[this.popStack.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n    return !(this.popStack.length || this.pushStack.length)\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n\r\n## "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841605789","body":"### 解法一\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度: O(n)\r\n\r\n单调栈解法：因为要找到做多的快，所以每一个递减区域都可以分成一个块，那么就可以转化成问题：找到第一个比他大的值，也就是单调栈解法。\r\n\r\n当每次找到第一个最大值，将前面的块只需要保存一个极值，这样只需要返回栈的长度即可\r\n\r\n```JavaScript\r\nvar maxChunksToSorted = function (arr) {\r\n    const stack = [];\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        let curr = arr[i];\r\n        if (stack.length > 0 && stack[stack.length - 1] > curr) {\r\n            const peek = stack.pop()\r\n            while (stack && stack[stack.length - 1] > curr) stack.pop();\r\n            stack.push(peek);\r\n        } else {\r\n            stack.push(curr);\r\n        }\r\n    }\r\n    return stack.length;\r\n};\r\n```\r\n\r\n### 解法二\r\n\r\n时间复杂度：O(nlogn) 排序的复杂度\r\n\r\n空间复杂度: O(n)\r\n\r\n滑动窗口解法：根据题意中 每个可排序块的总和应该是恒等的 所以将和相加，每一个和相等的实际就是一次切分块的点\r\n\r\n```JavaScript\r\nvar maxChunksToSorted = function (arr) {\r\n    const newArr = [...arr]\r\n    const sortArr = newArr.sort((a, b) => a - b)\r\n    let count = 0, sum1 = 0, sum2 = 0\r\n    for (let i = 0; i < arr.length; i++) {\r\n        sum1 += arr[i]\r\n        sum2 += sortArr[i]\r\n        if (sum1 == sum2) {\r\n            count++\r\n        }\r\n    }\r\n    return count\r\n};\r\n```\r\n\r\n## "},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"falconruo":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-840161675","body":"**思路:**\r\n\r\n查找string S里的每个字符离给定字符C的index的最短距离，对于每个字符有以下三种情况：\r\n\r\n。如果等于C则距离=0\r\n。最近的C在其左边\r\n。最近的C在其右边\r\n\r\n。从左到右依次遍历字符串S，比较每个字符与字符C的最短距离并存放到返回数组res中\r\n。从右到左依次遍历字符串S，比较每个字符与字符C的最短距离并与之前存放在数组res中的距离取小值\r\n\r\n**复杂度分析:**\r\n\r\n时间复杂度: O(n), n为string S长度\r\n空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> res(n, INT_MAX);\r\n\r\n        int l;\r\n        // scan string S from left to right to get the distance of each character\r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c)\r\n                l = i;\r\n            res[i] = min(res[i], abs(i - l));\r\n        }\r\n\r\n        // scan string S from right to lef to get the distance of each character, then choose the shortest one via comparing the distance values\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s[i] == c)\r\n                l = i;\r\n            res[i] = min(res[i], abs(i - l));\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"peacejoylove86":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-840252978","body":"import java.util.ArrayList;\r\n\r\npublic class Leetcode821 {\r\n    public int[] shortestToChar(String s, char c) {\r\n        if (s == null)\r\n        {\r\n            return null;\r\n        }\r\n        char[] chars = s.toCharArray();\r\n        int[] output = new int[s.length()];\r\n        if (!s.contains(String.valueOf(c)))\r\n        {\r\n            return output;\r\n        }\r\n        ArrayList indexs = new ArrayList();\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (c == chars[i])\r\n                indexs.add(i);\r\n        }\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (c == chars[i])\r\n                output[i] = 0;\r\n            else\r\n            {\r\n                int temp = Math.abs(i-((Integer) indexs.get(0)).intValue());\r\n                for (int j = 0; j < indexs.size(); j++) {\r\n                    int val = Math.abs(i-((Integer) indexs.get(j)).intValue());\r\n                    if (val < temp)\r\n                        temp = val;\r\n                }\r\n                output[i]=temp;\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Leetcode821 lc = new Leetcode821();\r\n        String s = \"loveleetcode\";\r\n        char c = 'e';\r\n        //输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n        int[] output = lc.shortestToChar(s,c);\r\n        for (int item:output\r\n             ) {\r\n            System.out.println(item);\r\n        }\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840255070","body":"import java.util.ArrayList;\r\nimport java.util.Stack;\r\n\r\nclass Leetcode394 {\r\n    public static String decodeString(String s) {\r\n        Stack sk = new Stack();\r\n        char[] input = s.toCharArray();\r\n        StringBuffer output = new StringBuffer();\r\n        StringBuffer subStr = new StringBuffer();\r\n        StringBuffer number = new StringBuffer();\r\n        for (int i = 0; i <= input.length - 1; i++) {\r\n            String temp = String.valueOf(input[i]);\r\n            if (isNumeric(temp)) {\r\n                number.append(input[i]);\r\n                continue;\r\n            }\r\n            if ('[' == input[i]) {\r\n                sk.push(number.toString());\r\n                number.delete(0, number.length());\r\n                subStr.delete(0, subStr.length());\r\n                for (int j = 1; j <= input.length - i - 1; j++) {\r\n                    if (']' == input[i + j]) {\r\n                        i = i + j;\r\n                        break;\r\n                    } else if (isChar(String.valueOf(input[i + j]))) {\r\n                        subStr.append(input[i + j]);\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            if (!sk.isEmpty()) {\r\n                int repeat = Integer.valueOf((String) sk.pop());\r\n                for (int j = 0; j <= repeat - 1; j++) {\r\n                    output.append(subStr);\r\n                }\r\n            }\r\n        }\r\n        return output.toString();\r\n    }\r\n\r\n    public final static boolean isNumeric(String s) {\r\n        if (s != null && !\"\".equals(s.trim()))\r\n            return s.matches(\"^[0-9]*\");\r\n        else\r\n            return false;\r\n    }\r\n\r\n    public final static boolean isChar(String s) {\r\n        char c = s.charAt(0);\r\n        if (((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(decodeString(\"10[a]2[bc]\"));\r\n    }\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yolo-jane":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840236906","body":"使用正则：执行用时：88 ms (去刷刷讲义后，再来)\r\n```\r\n输入\r\n\"3[z]2[2[y]pq4[2[jk]e1[f]]]ef\"\r\n输出\r\n\"zzzyypqjkjkefjkjkefjkjkefjkjkefyypqjkjkefjkjkefjkjkefjkjkefef\"\r\n预期结果\r\n\"zzzyypqjkjkefjkjkefjkjkefjkjkefyypqjkjkefjkjkefjkjkefjkjkefef\"\r\n\r\n```\r\n\r\n``` javascript\r\n/**\r\n * @param {string} str  \"3[a]2[bc]\"\r\n * @return {string} \"aaabcbc\"\r\n */\r\nvar decodeString = function (str) {\r\n  let result = ''\r\n  function replaceString(str) {\r\n    let res = str.replace(/(\\d+)(\\[(\\w+)\\])/g, (rs, $1, $2) => {\r\n      //  console.log(`rs=`+rs,`$1=`+$1,`$2=`+$2); rs=3[a] $1=3 $2=[a] rs=2[bc] $1=2 $2=[bc]\r\n      let res1 = []; for (let i = 0; i < $1; i++) {\r\n        let notNumber = $2.match(/\\w+/)[0];\r\n        if (notNumber) {\r\n          res1.push($2.match(/\\w+/))\r\n        }\r\n\r\n      }\r\n      return res1.join(\"\");\r\n\r\n    })\r\n\r\n\r\n    return res;\r\n  }\r\n\r\n  result = replaceString(str);\r\n  if (result.match(/(\\d+)(\\[(\\w+)\\])/g)) {\r\n    return decodeString(result);\r\n  } else {\r\n    return result;\r\n  }\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZiyangZ":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839400425","body":"- A simple implementation using array\r\n- Time complexity: O(1) for push and pop. O(n) for increment and initialization. \r\n- Space complexity: O(1) for push, pop and increment. O(n) for initialization.\r\n``` Java\r\nclass CustomStack {\r\n    \r\n    private int[] array;\r\n    private int index = -1;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.array = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (index < array.length - 1) {\r\n            array[++index] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (index < 0) return index;\r\n        return array[index--];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < Math.min(k, index+1); i++) {\r\n            array[i] += val;\r\n        }\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840245423","body":"- Using the code from YouTuber AndroidBabies. \r\n- Her code is not perfect. Feels a little clumsy.\r\n- Definitely needs more review.\r\n``` Java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Integer num = 0;\r\n        Stack<Object> stack = new Stack<>();\r\n        \r\n        for (char c: s.toCharArray()) {\r\n            if (Character.isDigit(c)) {\r\n                num = num * 10 + c - '0';\r\n            } else if (c == '[') {\r\n                stack.push(num);\r\n                num = 0;\r\n            } else if (c == ']') {\r\n                String newstr = helper(stack);\r\n                Integer cnt = (Integer) stack.pop();\r\n                for (int i = 0; i < cnt; i++) {\r\n                    stack.push(newstr);\r\n                }\r\n            } else {\r\n                stack.push(String.valueOf(c));\r\n            }\r\n        }\r\n        return helper(stack);\r\n    }\r\n    \r\n    private String helper(Stack<Object> stack) {\r\n        Stack<String> tmp = new Stack<>();\r\n        while (!stack.isEmpty() && stack.peek() instanceof String) {\r\n            tmp.push((String) stack.pop());\r\n        }\r\n        StringBuilder sb = new StringBuilder();\r\n        while (!tmp.isEmpty()) {\r\n            sb.append(tmp.pop());\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840923632","body":"``` Java\r\nclass MyQueue {\r\n    Stack<Integer> queue = new Stack<>();\r\n    Stack<Integer> help = new Stack<>();\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        queue.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        while(!queue.empty()) {\r\n            help.push(queue.pop());\r\n        }\r\n        int temp = help.pop();\r\n        while(!help.empty()) {\r\n            queue.push(help.pop());\r\n        }\r\n        return temp;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        while(!queue.empty()) {\r\n            help.push(queue.pop());\r\n        }\r\n        int temp = help.peek();\r\n        while(!help.empty()) {\r\n            queue.push(help.pop());\r\n        }\r\n        return temp;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return queue.empty();\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841664965","body":"- From Lee215...\r\n``` Java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] sorted = arr.clone();\r\n        Arrays.sort(sorted);\r\n        int res = 0, sum1 = 0, sum2 = 0;\r\n        for (int i = 0; i < arr.length; i++) {\r\n            sum1 += arr[i];\r\n            sum2 += sorted[i];\r\n            if (sum1 == sum2) res += 1;\r\n        }\r\n    return res;\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Endeavor-Gcl":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839854346","body":"学习大佬思路，暂时还写不出来😭"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840245976","body":"学习ing~"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841642806","body":"学习ing~"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"QiYang03101994":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840253072","body":" 思路：参考最佳答案，用heap来控制迭代过程，遇到[，push，遇到], pop，通过使用heap来控制递归的开始和终止\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        multi = 0\r\n        res = ''\r\n        last_res= ''\r\n        final_res =''\r\n        stack = []\r\n\r\n        for i in range(len(s)):\r\n            c = s[i]\r\n            if ('0' <= c and c <= '9'):\r\n                multi = multi * 10 + int(c)\r\n            \r\n            elif (c == '['):\r\n                stack.append([res,multi])\r\n                # print(stack)\r\n                multi = 0\r\n                res =''\r\n            \r\n            elif (c == ']'):\r\n                [last_res,cur_multi] = stack.pop()\r\n                res = last_res + cur_multi * res\r\n                \r\n            else:\r\n                res += c\r\n\r\n\r\n        return res\r\n时空复杂度均为：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841280306","body":"## 思路\r\n* 参考官方题解，用两个stack来替代一个deque\r\n## 代码\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.pop_stack = []\r\n        self.push_stack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while(self.pop_stack):\r\n            self.push_stack.append(self.pop_stack.pop())\r\n        \r\n        self.push_stack.append(x)\r\n\r\n        while(self.push_stack):\r\n            self.pop_stack.append(self.push_stack.pop())\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n\r\n        return self.pop_stack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.pop_stack[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.pop_stack) == 0"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlesugarman":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840281532","body":"**思路：**\r\n利用栈的后进先出特性展开折叠的字符\r\n\r\n**代码：**\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        s = list(s)\r\n        stack = []\r\n        for k in s:\r\n            if k == ']':\r\n                cnt = ''\r\n                nr = ''\r\n                l = stack.pop()\r\n                while l != '[':\r\n                    nr = l + nr\r\n                    l = stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    cnt = stack.pop() + cnt\r\n                stack.append(nr * int(cnt)) \r\n            else:\r\n                stack.append(k)\r\n        return reduce(lambda x, y: x + y, stack)`\r\n```\r\n\r\n**复杂度分析：**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841307408","body":"今天的题简单鸭！但我写的还是麻烦了点~~冲\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.l1 = []\r\n        self.l2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.l1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.l2:\r\n            while self.l1:\r\n                self.l2.append(self.l1.pop())\r\n        return self.l2.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.l2:\r\n            while self.l1:\r\n                self.l2.append(self.l1.pop())\r\n        return self.l2[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return self.l1 == [] and self.l2 == []\r\n```\r\n\r\n时间复杂度：O(1)\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841614833","body":"```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        l = len(arr)\r\n        cnt = 0\r\n        for i in range(l-1):\r\n            if max(arr[:i+1]) <= min(arr[i+1:]):\r\n                cnt += 1\r\n        return cnt + 1\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841757362","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if (not head) or (not head.next):\r\n            return head\r\n        cnt = 0\r\n        p = head\r\n        while p:\r\n            cnt += 1\r\n            p = p.next\r\n        k = k % cnt\r\n        if k == 0:\r\n            return head\r\n        p = head\r\n        for i in range(cnt-k-1):\r\n            p = p.next\r\n        mark_tail = p\r\n        p = p.next\r\n        mark_tail.next = None\r\n        new_head = p\r\n        while p.next != None:\r\n            p = p.next\r\n        p.next = head\r\n        return new_head\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"baoqin87":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-840343221","body":"## 821.字符的最短距离\r\n\r\n### 思路\r\n向左或者向右距离目标字符最近的距离，取最小值\r\n\r\n### 代码 JavaScript\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  let len = s.length\r\n  let res = []\r\n  let prev = -10000\r\n  for (let i = 0; i < len; ++i) {\r\n    if (s.charAt(i) == c) prev = i\r\n    res[i] = i - prev\r\n  }\r\n  prev = 20000\r\n  for (let i = len - 1; i >= 0; --i) {\r\n    if (s.charAt(i) == c) prev = i\r\n    res[i] = Math.min(res[i], prev - i)\r\n  }\r\n  return res\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n^2)，其中 n 为数组的长度。\r\n* 空间复杂度：O(n)。\r\n* "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840526051","body":"## 394.字符串解码\r\n\r\n### 思路\r\n使用入栈出栈操作，将原字符串解码\r\n\r\n### 代码 JavaScript\r\n\r\n```javascript\r\nvar decodeString = function(s) {\r\n  let res = '';\r\n  let multi = 0;\r\n  let stack_multi = [];\r\n  let stack_res = [];\r\n  for (let i = 0, len = s.length; i < len; i++) {\r\n    c = s.charAt(i)\r\n    if(c == '[') {\r\n      // 把数字和拼接的字母分别压入栈\r\n      stack_multi.push(multi)\r\n      stack_res.push(res)\r\n      multi = 0\r\n      res = ''\r\n    } else if(c == ']') {\r\n      let tmp = ''\r\n      // 数字出栈\r\n      let cur_multi = stack_multi.pop()\r\n      // 数字作为循环次数\r\n      for (let i = 0; i < cur_multi; i++) {\r\n        tmp += res\r\n      }\r\n      res = stack_res.pop() + tmp\r\n    } else if (c >= '0' && c <= '9') {\r\n      multi = multi * 10 + parseInt(c)\r\n    } else {\r\n      res += c\r\n    }\r\n  }\r\n  return res;\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(N)。\r\n* 空间复杂度：O(N)。\r\n* "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841195744","body":"## 232.用栈实现队列\r\n\r\n### 思路\r\n* 将一个栈当作输入栈，用于压入push传入的数据；\r\n* 另一个栈当作输出栈，用于pop 和 peek 操作。\r\n* 每次 pop 或 peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，\r\n* 这样输出栈，从栈顶往栈底的顺序，就是队列从队首往队尾的顺序。\r\n\r\n### 代码 JavaScript\r\n\r\n```javascript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n  // 输入栈\r\n  this.in_stack = []\r\n  // 输出栈\r\n  this.out_stack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n  this.in_stack.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n  if (this.out_stack.length == 0) {\r\n    this.in2out()\r\n  }\r\n  return this.out_stack.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n  if (this.out_stack.length == 0) {\r\n    this.in2out()\r\n  }\r\n  return this.out_stack[this.out_stack.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n  return this.in_stack.length == 0 && this.out_stack.length == 0\r\n};\r\n\r\nMyQueue.prototype.in2out = function() {\r\n  while (this.in_stack.length > 0) {\r\n    this.out_stack.push(this.in_stack.pop())\r\n  }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)。\r\n* 空间复杂度：O(n)。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841678915","body":"## 768.最多能完成排序的块II\r\n\r\n### 思路\r\n判断是否是排序块，只需要用到该块的元素最大值 head。可以遍历一遍数组 arr ，动态判断到目前数字 num 为止，最多能分出多少排序块，并保存每个排序块的最大值 head 。每遍历到下个数字 num ，动态判断前面所有的排序块是否成立，并更新所有排序块。\r\n\r\n### 代码 JavaScript\r\n\r\n```javascript\r\nvar maxChunksToSorted = function(arr) {\r\n  let stack = []\r\n  let num\r\n  for (let i = 0, len = arr.length; i < len; i++) {\r\n    num = arr[i]\r\n    if (stack.length > 0 && num < stack[stack.length - 1]) {\r\n      let head = stack.pop()\r\n      while(stack.length > 0 && num < stack[stack.length - 1]) {\r\n        stack.pop()\r\n      }\r\n      stack.push(head)\r\n    } else {\r\n      stack.push(num)\r\n    }\r\n  }\r\n  return stack.length\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)。\r\n* 空间复杂度：O(n)。\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JadeQi":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839516173","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n## 前置知识\r\n\r\n-  栈\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass CustomStack {\r\n    int maxSize;\r\n    int[] stack;\r\n    int index;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n        index = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(index == maxSize){\r\n            return;\r\n        }\r\n        stack[index++] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(index == 0){\r\n            return -1;\r\n        }\r\n        return stack[--index];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        k = Math.min(k,index);\r\n        for(int i = 0; i<k; i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n\r\n- 时间复杂度：push、pop：O(1)， increment：O(k)\r\n- 空间复杂度：O(maxSize)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840315430","body":"## 思路\r\n- 获取字符/获取倍数.\r\n- 括号内嵌套括号，需要从内向外生成与拼接字符.\r\n\r\n```java\r\nclass Solution394 {\r\n    public String decodeString(String s) {\r\n        Stack<Character> stack = new Stack<>();\r\n\r\n        // toCharArray: 字符串转换为字符数组\r\n        for (char c : s.toCharArray()) {\r\n            if (c != ']')\r\n                // 把所有的字母push到栈中，除了]\r\n                stack.push(c);\r\n            else {\r\n                // 取出[] 内的字符串\r\n                StringBuilder sb = new StringBuilder();\r\n                // isLetter: 用于判断指定字符是否为字母; 判断取出的顶部对象是否为字母\r\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\r\n                    // 在第0位插入出栈的对象\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n\r\n                //[ ]内的字符串\r\n                String sub = sb.toString();\r\n                // 去除[\r\n                stack.pop();\r\n\r\n                // 获取倍数数字\r\n                sb = new StringBuilder();\r\n                // isDigit: 判断指定字符是否为数字;  判断取出的顶部对象是否为数字\r\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n                // 倍数\r\n                int count = Integer.valueOf(sb.toString());\r\n\r\n                // 根据倍数把字母再push回去\r\n                while (count > 0) {\r\n                    for (char ch : sub.toCharArray()) {\r\n                        stack.push(ch);\r\n                    }\r\n                    count--;\r\n                }\r\n            }\r\n        }\r\n\r\n        // 把栈里面所有的字母取出来\r\n        StringBuilder retv = new StringBuilder();\r\n        while (!stack.isEmpty()) {\r\n            retv.insert(0, stack.pop());\r\n        }\r\n\r\n        return retv.toString();\r\n    }\r\n}\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841156694","body":"- 今天走神严重，耐不下心来，看着官方答案写了一波\r\n```java\r\nclass MyQueue {\r\n\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        inStack = new LinkedList<Integer>();\r\n        outStack = new LinkedList<Integer>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(outStack.isEmpty()){\r\n            in2out();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(outStack.isEmpty()){\r\n            in2out();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n\r\n    public void in2out(){\r\n        while(!inStack.isEmpty()){\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841663033","body":"- hard还是hard，看着官方题写了下，有些还是不理解\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) nonzero--;\r\n            if (count.get(x) == 1) nonzero++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) nonzero++;\r\n            if (count.get(y) == 0) nonzero--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Bochengwan":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840353737","body":"### 思路\r\n\r\n利用两个stack，一个stack存数字，一个stack存字母，遇到左括号时，把当前的数字入数字栈，当前的字母入字母栈，遇到右括号时，则出栈左括号前的数字，也就是数字栈的栈顶，此数字是当前字符的重复次数，并且与字母栈的栈顶拼接作为当前字符\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        bracket_stack = []\r\n        number_stack = []\r\n        c = ''\r\n        n = ''\r\n        for e in s:\r\n            \r\n            if e.isdigit():\r\n                n+=e\r\n            elif e == '[':\r\n                bracket_stack.append(c)\r\n                number_stack.append(n)\r\n                n = ''\r\n                c = ''\r\n            elif e == ']':\r\n                \r\n                c = (bracket_stack.pop() + c*int(number_stack.pop()))\r\n            else:\r\n                c += e\r\n        return c\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suikataro":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840354871","body":"### 代码\r\n```java\r\n    public String decodeString(String s) {\r\n        if (s == null || s.length() == 0) return s;\r\n        String res = \"\";\r\n        Stack<Integer> countStack = new Stack<>();\r\n        Stack<String> resStack = new Stack<>();\r\n        int idx = 0;\r\n        while (idx < s.length()) {\r\n            if (Character.isDigit(s.charAt(idx))) {\r\n                //处理>10的整数\r\n                int count = 0;\r\n                while (Character.isDigit(s.charAt(idx))) {\r\n                    count = count * 10 + (s.charAt(idx) - '0');\r\n                    idx++;\r\n                }\r\n                countStack.push(count);\r\n            } else if (s.charAt(idx) == '[') {\r\n                resStack.push(res);\r\n                res = \"\";\r\n                idx++;\r\n            } else if (s.charAt(idx) == ']') {\r\n                StringBuilder temp = new StringBuilder(resStack.pop());\r\n                int time = countStack.pop();\r\n                for (int i = 0; i < time; i++) {\r\n                    temp.append(res);\r\n                }\r\n                res = temp.toString();\r\n                idx++;\r\n            } else {\r\n                //字母\r\n                res += s.charAt(idx++);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"YuetongYu":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840365976","body":"思路： 正则判断解决。\r\n\r\n```js\r\nlet reg = /(\\d+)\\[([a-zA-Z]+)\\]/g;\r\n    while(s.indexOf('[')>0){\r\n        s = s.replace(reg,(_,...[num,str])=>{\r\n            let result = \"\";\r\n            for(let i=0;i<num-0;i++){\r\n                result += str;\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    return s;\r\n```\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840941830","body":"太简单了。。。不多解释\r\n\r\n```js\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.stack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.stack.shift()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[0]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return !Boolean(this.stack.length)\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"CelesteXiong":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839827285","body":"```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            return self.stack.pop()\r\n        else: return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        least = min(len(self.stack), k)\r\n        for i in range(least):\r\n            self.stack[i] += val\r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840503799","body":"#### 思路\r\n需要由内而外读取括号，因此使用栈先进后出的特性\r\n#### 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        # 看题解做的\r\n        stack = []\r\n        multi = 0\r\n        ans = \"\"\r\n        res = \"\"\r\n        for c in s:\r\n            if '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)\r\n            elif c == '[':\r\n                stack.append([multi, ans])\r\n                multi = 0\r\n                ans = \"\"\r\n            elif c == ']':\r\n                last = stack.pop()\r\n                last_multi = last[0]\r\n                last_ans = last[1]\r\n                ans = last_ans + last_multi * ans \r\n            else:\r\n                ans += c\r\n        return ans\r\n\r\n```\r\n#### 复杂度\r\n时间复杂度O(N)：需要遍历一遍`s`\r\n空间复杂度O(N)：最坏的情况下需要线性空间"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841330775","body":"### 思路\r\n1. 使用数组模拟栈，可以使用数组的push和pop操作实现栈的先进后出的特性。\r\n2. 使用两个数组模拟一个队列，一个栈用于存储push的内容，每次pop时，讲该栈的数据pop到第二个栈，再pop第二个栈的内容。\r\n\r\n### 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.s1, self.s2 = [], []\r\n        \r\n\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.s1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop())\r\n        return self.s2.pop()\r\n\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop())\r\n        return self.s2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        if len(self.s1) or len(self.s2): \r\n            print (self.s1, self.s2)\r\n            return False\r\n        else: \r\n            print (self.s1, self.s2)\r\n            return True\r\n        \r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n### 复杂度分析\r\n假设数组长度为n。\r\n时间复杂度：push() 时间复杂度是 O(1)；peek()/pop() 均摊时间复杂度是 O(1)，单步操作的最坏时间复杂度是 O(N)O(N)。\r\n空间复杂度：空间复杂度是O(N)，因为两个栈和数组长度相同。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841658286","body":"## 思路\r\n借用栈先进后出的特性，按照自小而大的顺序，保留能排序的所有块中的最大值。如果当前数字超过栈顶，则存储栈顶，一直pop到当前比当前数字小的栈顶，再将保留的栈顶入栈，以栈中的个数作为能排序的块的个数。\r\n\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        head = None\r\n        for num in arr:\r\n            if stack and num < stack[-1]:\r\n                head = stack.pop()\r\n                while stack and num < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n\r\n```\r\n## 复杂度\r\n时间复杂度：O(n), 遍历一边数组\r\n空间复杂度：O(n), 线性增长的空间"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flashyy":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840507326","body":"- 思路：\r\n   需要由子问题组合得到原问题，把每一层需要叠加的字母(res)和叠加的次数(multi)记录下来，加到原字符串上，迭代字符串：\r\n1. 遇到数字的时候，将其转化为整数（multi）记录下来，用于后序计算\r\n2. 遇到字母的时候，将该字符串加入当前字符串后面\r\n3. 遇到左括号时候，将需要叠加的字母(res)和叠加的次数(multi)记录下来并放入栈中\r\n4.遇到右括号时候弹出字符串，将字符串组合起来  \r\n```\r\nvar decodeString = function(s) {\r\n     let res=\"\",multi=0,stack=[];\r\n     for(let char of s){\r\n         if(!isNaN(char)){\r\n             multi = multi*10+parseInt(char);\r\n         }\r\n         else if(char === \"[\"){\r\n             stack.push([multi,res]);\r\n             res = \"\";\r\n             multi = 0;\r\n         }\r\n         else if(char === \"]\"){\r\n             let [multi,str] = stack.pop();\r\n             res = str+res.repeat(multi);\r\n         }  \r\n         else{\r\n            res +=char;\r\n         }\r\n     }\r\n     return res;\r\n};\r\n```\r\n- 复杂度：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsj":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840571999","body":" var decodeString = function (s) {\r\n        const isNum = n=>n>='1'&&n<='9'\r\n        const size = s.length \r\n        let stack = []\r\n        for(let i=0;i<size;i++){\r\n            const item = s.charAt(i)\r\n            if(item === '['){\r\n                stack.push('')\r\n                continue\r\n            }\r\n            if(item === ']'){\r\n                let popItem = stack[stack.length - 1]\r\n                const numVal = stack[stack.length - 2]\r\n                const popNum = parseInt(numVal)\r\n                let str = ''\r\n                if(popItem.length){\r\n                    for(let n = 0;n<popNum;n++){\r\n                        str+=popItem\r\n                    }\r\n                }\r\n                if(stack.length){\r\n                    stack.pop()\r\n                    stack.pop()\r\n                    if(stack.length){\r\n                        stack[stack.length - 1] += str\r\n                    }else{\r\n                        stack.push(str)\r\n                    }\r\n                }\r\n                continue\r\n            }\r\n            if(isNum(item)){\r\n                if(isNum(stack[stack.length - 1])){\r\n                    stack[stack.length - 1] += item\r\n                    continue\r\n                }\r\n                stack.push(item)\r\n                continue\r\n            }\r\n            if(!stack.length){\r\n                stack.push(item)\r\n                continue\r\n            }\r\n            stack[stack.length - 1] +=item\r\n        }\r\n        return stack.join('')\r\n    }\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jueran":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840575047","body":"思路：\r\n使用两个栈，一个栈存储数字，一个栈存字母；\r\n代码\r\n\r\n```\r\nclass Solution:\r\n    def decodeString(s:str)->str:\r\n        bracket_stack=[]\r\n        number_stack=[]\r\n        c=''\r\n        n=''\r\n        for e in s:\r\n            if e.isdigit():\r\n                n+=e\r\n            elif e=='[':\r\n                bracket_stack.append(c)\r\n                number_stack.append(n)\r\n                n=''\r\n                c=''\r\n            elif e==']':\r\n                c=(bracket_stack.pop()+c*int(number_stack.pop()))\r\n            else:\r\n                c+=e\r\n        return c\r\n```\r\n\r\n复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841258649","body":"思路\r\n使用两个数组模拟栈操作。\r\n1.在pop时候，需要先将所有元素拿出来放到辅助栈，然后pop栈顶的元素\r\n2.如果辅助栈不为空，直接返回pop辅助栈的栈顶元素即可。\r\n```\r\nclass MQueue:\r\n    def __init__(self) :\r\n        self.stack=[]\r\n        self.assit=[]\r\n\r\n    def push(self,x:int)->None:\r\n        self.stack.append(x)\r\n\r\n    def pop(self)->int:\r\n        if not self.assit:\r\n            while self.stack:\r\n                self.assit.append(self.stack.pop())\r\n        return self.assit.pop()\r\n\r\n    def peek(self)->int:\r\n        if not self.assit:return self.stack[0]\r\n        else: return self.assit[-1]\r\n\r\n    def empty(self)->bool:\r\n        return True if not self.stack and not self.assit else False\r\n```\r\n时间复杂度（pop/push/peek）：均为O(1)\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841666803","body":"思路\r\n使用一个辅助数组\r\n1.使用循环依次取值。\r\n2.只要左边的最大值小于值就可以多分一个模块，就把该值入数组，窗口往右滑动，继续对比\r\n3.如果左边的最大值大于值，则出栈辅助数组元素，直到找到比值大的。窗口往右滑动，继续对比\r\n4循环结束，返回辅助数组的大小。\r\n\r\npython：\r\n```\r\nclass ClassName:\r\n    def maxChunksToSorted(s:str)->str:\r\n        queue=[]\r\n        for i in range(len(s)):\r\n            if len(queue)==0 or queue[len(queue)-1]<=str[i]:\r\n                queue.push(str[i])\r\n            else:\r\n                temp=queue.pop()\r\n                while queue[len[queue]-1]>str[i]:\r\n                    queue.pop()\r\n                queue.push(temp)\r\n        return len(queue)\r\n```\r\n时间复杂度 O(n)\r\n控件复杂度 O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Dark-volute":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840590769","body":"### 思路\r\n我们可以利用 stack 来实现这个操作，遍历这个字符串 s，判断每一个字符的类型：\r\n\r\n如果是字母 --> 添加到 stack 当中\r\n如果是数字 --> 先不着急添加到 stack 中 --> 因为有可能有多位\r\n如果是 [ --> 说明重复字符串开始 --> 将数字入栈 --> 并且将数字清零\r\n如果是 ] --> 说明重复字符串结束 --> 将重复字符串重复前一步储存的数字遍\r\n\r\n### 代码\r\n```js\r\nvar decodeString = function(s) {\r\n    let strStack = []\r\n    let numStack = []\r\n    let num = 0\r\n    let str = ''\r\n    for (let i = 0; i< s.length; i++) {\r\n        // 如果是次数\r\n        if (!isNaN(s[i])) {\r\n            // 处理二位及以上次数\r\n            num = num * 10 + +s[i]\r\n        } else if (s[i] === '[') {\r\n            numStack.push(num)\r\n            strStack.push(str)\r\n            num = 0\r\n            str = ''\r\n        } else if (s[i] === ']'){\r\n            let repeatTimes = numStack.pop() // 获取拷贝次数\r\n            str = strStack.pop() + str.repeat(repeatTimes) \r\n        } else {\r\n            str += s[i]\r\n        }\r\n    }\r\n    return str\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：$O(N)$，其中 N 为解码后的 s 的长度。 空间复杂度：$O(N)$，其中 N 为解码后的 s 的长度。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Peg-008":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840594683","body":"字符内所有类型分别为:[  ]  数字   字母四种   数字和字母分别用一个栈存储  用 [ ] 作为入栈 出栈的条件 \r\n\r\n``` java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        if (s == null || \"\".equals(s)){\r\n            return null;\r\n        }\r\n        //数字栈\r\n        Stack<Integer> numStack = new Stack<>();\r\n        //字母栈\r\n        Stack<String> strStack = new Stack<>();\r\n        char[] chars = s.toCharArray();\r\n        int num = 0;\r\n        for(char c : chars){\r\n            if(isNum(c + \"\")){\r\n                num = num * 10 + c - '0';\r\n            } else if(c == '['){\r\n                strStack.push(c + \"\");\r\n                numStack.push(num);\r\n                num = 0;\r\n            } else if(c == ']'){ \r\n                int number = numStack.pop(); \r\n               String str = \"\";\r\n                while(!strStack.peek().equals(\"[\")){\r\n                    str = strStack.pop() + str;\r\n                }\r\n                strStack.pop();\r\n                strStack.push(getMultiWord(str, number));\r\n            } else {\r\n                strStack.push(c + \"\");\r\n            }\r\n        }\r\n        String res = \"\";\r\n        while(! strStack.isEmpty()){\r\n            res = strStack.pop() + res;\r\n        }\r\n        return res;\r\n    }\r\n    public static boolean isNum(String str) {\r\n        String regex = \"^[0-9]+$\";\r\n        return str.matches(regex);\r\n    }\r\n\r\n    private static String getMultiWord(String s, int num){\r\n        StringBuilder sb = new StringBuilder();\r\n        for (int i = 0 ;i < num; i ++){\r\n            sb.append(s);\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zibinanhai":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840626495","body":"\r\n## 题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n\r\n\r\n示例 3：\r\n\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n\r\n\r\n示例 4：\r\n\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n用一个栈来解决\r\n\r\n## 关键点\r\nwhile循环把[]里面的字符串读出来\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        int len = s.length();\r\n        if(len <= 0) {\r\n            return \"\";\r\n        }\r\n        Stack<String> stack = new Stack<>();\r\n        for(int i=0; i<len; i++){\r\n            char mid=s.charAt(i);\r\n            if(mid==']'){\r\n                StringBuilder tmp = new StringBuilder();\r\n                while(!stack.peek().equals(\"[\")){\r\n                    tmp.insert(0,stack.pop());\r\n                }\r\n                stack.pop();\r\n                StringBuilder num=new StringBuilder();\r\n                while(!stack.isEmpty() && (stack.peek().charAt(0) >= '0' \r\n                && stack.peek().charAt(0)<='9')){\r\n                    num.insert(0,stack.pop());\r\n                }\r\n                int number=Integer.parseInt(num.toString());\r\n                StringBuilder sb = new StringBuilder();\r\n                for(int j = 0; j < number; j++){\r\n                    sb.append(tmp);\r\n                }\r\n                stack.push(sb.toString());\r\n            }else{\r\n                StringBuilder sb = new StringBuilder();\r\n                sb.insert(0,mid);\r\n                stack.push(sb.toString());\r\n            }\r\n        }\r\n        StringBuilder res = new StringBuilder();\r\n        while(!stack.isEmpty()){\r\n            res.insert(0,stack.pop());\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wu529778790":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840627651","body":"```\r\nvar decodeString = function(s) {\r\n    let mulStack = [], strStack = [], num = 0, res = ''\r\n    for (const c of s) {   \r\n        if (!isNaN(c)) {  \r\n            num = num * 10 + (c - '0')\r\n        } else if (c == '[') {  \r\n            strStack.push(res)\r\n            mulStack.push(num) \r\n            res = '' \r\n            num = 0\r\n        } else if (c == ']') {  \r\n            res = strStack.pop() + res.repeat(mulStack.pop())\r\n        } else {                   \r\n            res += c\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841291124","body":"```\r\nvar MyQueue = function() {\r\n    this.inStack = [];\r\n    this.outStack = [];\r\n};\r\n\r\nMyQueue.prototype.push = function(x) {\r\n    this.inStack.push(x);\r\n};\r\n\r\nMyQueue.prototype.pop = function() {\r\n    if (!this.outStack.length) {\r\n        this.in2out();\r\n    }\r\n    return this.outStack.pop();\r\n};\r\n\r\nMyQueue.prototype.peek = function() {\r\n    if (!this.outStack.length) {\r\n        this.in2out();\r\n    }\r\n    return this.outStack[this.outStack.length - 1];\r\n};\r\n\r\nMyQueue.prototype.empty = function() {\r\n    return this.outStack.length === 0 && this.inStack.length === 0;\r\n};\r\n\r\nMyQueue.prototype.in2out = function() {\r\n    while (this.inStack.length) {\r\n        this.outStack.push(this.inStack.pop());\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841660038","body":"想了30分钟总结不出规律，看楼上的评论……\r\n\r\n在数组任意位置i,如果[0...i]的最大值，比[i+1..len-1]的最小值要小，那么就可以算作一个“块”。否则的话，排序的时候从右侧必须要换到左侧来，根据题目要求就不能算作一个块。\r\n根据上述规律，对于数组的任意位置i，先计算[0...i]的最大值max，再计算[i+1...len-1]的最小值min，如果max[i] <= min[i+1]，就可以分出一个“块”。\r\n边界条件是任何数组至少会有一个块。\r\n```\r\nvar maxChunksToSorted = function (arr) {\r\n    const sorted = [...arr];\r\n    sorted.sort((a, b) => a - b);\r\n\r\n    let count = 0,\r\n        sum1 = 0,\r\n        sum2 = 0;\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        sum1 += arr[i];\r\n        sum2 += sorted[i];\r\n\r\n        if (sum1 === sum2) {\r\n            count++;\r\n        }\r\n    }\r\n\r\n    return count;\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"scarydemon2":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840634618","body":"## 递归\r\n```\r\n\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        res=\"\"\r\n        s=list(s)\r\n        index=0\r\n        stack=[]\r\n        current_num=0\r\n        while index<len(s):\r\n            if ord(s[index])<=ord('9') and ord(s[index])>=ord('0'):\r\n                num_start=index\r\n                index+=1\r\n                while ord(s[index])<=ord('9') and ord(s[index])>=ord('0'):\r\n                    index+=1\r\n                current_num=int(\"\".join(s[num_start:index]))\r\n                continue\r\n            elif s[index]=='[':\r\n                stack.append('[')\r\n                left=index+1\r\n                while stack!=[]:\r\n                    index += 1\r\n                    if s[index]=='[':\r\n                        stack.append('[')\r\n                        continue\r\n                    if s[index]==']':\r\n                        stack.pop(-1)\r\n                        right=index\r\n                        continue\r\n                tmp=self.decodeString(\"\".join(s[left:right]))\r\n                if current_num!=0:\r\n                    for i in range(current_num):\r\n                        res+=tmp\r\n                    current_num=0\r\n            elif s[index]==']':\r\n                index+=1\r\n                continue\r\n            else:\r\n                res+=s[index]\r\n                index+=1\r\n        return res\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841280030","body":"’‘’\r\n\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.s1=[]\r\n        self.s2=[]\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.s1.append(x)\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.s2)!=0:\r\n            return self.s2.pop()\r\n        else:\r\n            while self.s1!=[]:\r\n                self.s2.append(self.s1.pop())\r\n            return self.s2.pop()\r\n    def peek(self):\r\n        \"\"\"\r\n        Get the front element.\r\n        :rtype: int\r\n        \"\"\"\r\n\r\n        if len(self.s2) != 0:\r\n            return self.s2[-1]\r\n        else:\r\n            while self.s1 != []:\r\n                self.s2.append(self.s1.pop())\r\n            return self.s2[-1]\r\n\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        :rtype: bool\r\n        \"\"\"\r\n        return self.s1==[] and self.s2==[]\r\n\r\n‘’‘"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841618612","body":"从右到左先遍历得到从右边到当前位置的最小值。记为r2l\r\n然后从左到右遍历，对于当前块，维护一个当前块的最大值，如果这个最大值比下个位置的r2l值小（或者等于），那么可以在该位置分块，时间空间都是On\r\n\r\n’‘’\r\n\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n\r\n        res=0\r\n        if len(arr)==0:\r\n            return 0\r\n        r2l=[arr[-1]]\r\n        last_min=arr[-1]\r\n        for i in range(len(arr)-2,-1,-1):\r\n            if arr[i]<last_min:\r\n                r2l=[arr[i]]+r2l\r\n                last_min=arr[i]\r\n            else:\r\n                r2l=[last_min]+r2l\r\n        current_max=-float('inf')\r\n        for i in range(len(arr)-1):\r\n            if arr[i]>current_max:\r\n                current_max=arr[i]\r\n            if current_max <= r2l[i + 1]:\r\n                res += 1\r\n        return res+1\r\n\r\n‘’‘"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841757487","body":"先找到倒数底k个节点，然后摘下来，放到链表头部\r\n\r\n’‘’\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        if head==None or head.next==None:\r\n            return head\r\n        tmp_head=head\r\n        p=head\r\n        length=0\r\n        while p is not None:\r\n            length+=1\r\n            p=p.next\r\n        k=k%length\r\n        if k==0:\r\n            return head\r\n        for i in range(k):\r\n            tmp_head=tmp_head.next\r\n        p=head\r\n        while tmp_head.next!=None:\r\n            tmp_head=tmp_head.next\r\n            p=p.next\r\n        next_head=p.next\r\n        p.next=None\r\n        return_head=next_head\r\n        while next_head.next!=None:\r\n            next_head=next_head.next\r\n        next_head.next=head\r\n        return return_head\r\n‘’‘"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kendj-staff":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840643716","body":"### 思路\r\n自己写的只能通过部分用例，盖着复现官方题解，看到其他人解答觉得自己写的太屎了\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    int ptr;\r\n    public String decodeString(String s) {\r\n        LinkedList<String> letterStack = new LinkedList<String>();\r\n        LinkedList<Integer> numStack = new LinkedList<Integer>();\r\n        ptr = 0;\r\n        \r\n        while (ptr < s.length()) {\r\n            if (Character.isDigit(s.charAt(ptr))) {\r\n                numStack.addLast(Integer.parseInt(getNumber(s)));\r\n            } else if (Character.isLetter(s.charAt(ptr)) || '[' == s.charAt(ptr)) {\r\n                letterStack.addLast(String.valueOf(s.charAt(ptr++)));\r\n            } else {\r\n                ptr++;\r\n                int count = numStack.removeLast();\r\n                LinkedList<String> subStrList = new LinkedList<String>();\r\n\r\n                while (!\"[\".equals(letterStack.peekLast())) {\r\n                    subStrList.addFirst(letterStack.removeLast());\r\n                    \r\n                }  \r\n\r\n                letterStack.removeLast();\r\n                String subStr = getString(subStrList);\r\n                StringBuffer sb = new StringBuffer();\r\n                while (count > 0) {\r\n                    sb.append(subStr);\r\n                    count --;\r\n                }\r\n\r\n                letterStack.addLast(sb.toString());\r\n            }\r\n        }\r\n        return getString(letterStack);\r\n    }\r\n    public String getNumber(String s) {\r\n        StringBuffer sb = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            sb.append(s.charAt(ptr++));\r\n        }\r\n        return sb.toString();\r\n    }\r\n    public String getString(List<String> s) {\r\n        StringBuffer sb = new StringBuffer();\r\n        for (String str: s) {\r\n            sb.append(str);\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841004299","body":"### 思路\r\n双栈蠢方法准备看一下O（1）\r\n\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass MyQueue {\r\n    private Deque<Integer> inStack;\r\n    private Deque<Integer> outStack;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        inStack = new LinkedList<Integer>();\r\n        outStack = new LinkedList<Integer>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        inStack.push(x);\r\n        outStack.clear();\r\n        for(int i : inStack) {\r\n            outStack.push(i);\r\n        }\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        int res = outStack.pop();\r\n        inStack.clear();\r\n        for(int i : outStack) {\r\n            inStack.push(i);\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        return outStack.peek(); \r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        if (outStack.isEmpty()) {\r\n            return true;\r\n        } \r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841624961","body":"### 思路\r\n\r\n学习官方题解，使用辅助栈，真是妙啊，自己太傻了\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Deque<Integer> stack = new LinkedList<Integer>();\r\n        for (int i = 0; i < arr.length; i++) {\r\n            if (stack.size() == 0 || arr[i] >= stack.peek()) {\r\n                stack.push(arr[i]);\r\n            } else if (arr[i] < stack.peek()) {\r\n                int head = stack.pop();\r\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(head);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZZWHU":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840646477","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, multi, res = [], 0, ''\r\n        for c in s:\r\n            if c.isdigit():\r\n                multi = multi*10 + int(c)\r\n            elif c == '[':\r\n                stack.append([multi, res])\r\n                multi, res = 0, ''\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi*res\r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n看了下大佬的代码\r\n\r\n- 时间复杂度O(N)\r\n- 空间复杂度O(N)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841655229","body":"```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]:\r\n                head = stack.pop()\r\n                while stack and num < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(head)\r\n            else:\r\n                stack.append(num)\r\n        return len(stack)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zbqnb":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840648679","body":"## **91学算法DAY1**\r\n\r\n#### 思路：\r\n\r\n计算器问题，入栈出栈的时机从符号转为“[ ]”\r\n\r\n#### 复杂度分析：\r\n\r\n- 时间：单次for O(n)\r\n- 空间：O(n)\r\n\r\n```c++\r\n#include \"LeetCodeBasic.h\"\r\n#include \"LeetCodeStl.h\"\r\nusing namespace std;\r\n/*\r\n* \r\n*/\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<string> strs;\r\n        stack<int> Muti_operator;\r\n        string res = \"\";\r\n        \r\n        for (size_t i = 0; i < s.size(); i++)\r\n        {   \r\n            int num;\r\n            if (s[i] >= '0' && s[i] <= '9')\r\n            {   \r\n                {\r\n                    num = num * 10 + s[i] - '0';\r\n                }\r\n                //第一次做想到了连续数字问题，但是其实没必要特殊考虑\r\n                /*for (size_t j = 1; j + i < s.size(); j++)\r\n                {\r\n                    if (s[i + j] >= '0' && s[i + j] <= '9')\r\n                    {\r\n                        num = s[i] * 10 + s[i + j];\r\n                    }\r\n                    else {\r\n                        continue;\r\n                    }\r\n                }*/\r\n            }\r\n            else if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z'))\r\n            {\r\n                res = res + s[i];\r\n            }\r\n            else if (s[i] == '[')\r\n            {   \r\n                Muti_operator.push(num);\r\n                num = 0;\r\n                strs.push(res);\r\n                res = \"\";\r\n            }\r\n            else if (s[i] == ']') {\r\n                int times = Muti_operator.top();\r\n                Muti_operator.pop();\r\n                for (size_t i = 0; i < times; i++)\r\n                {\r\n                    strs.top() += res;\r\n                }\r\n                res = strs.top();\r\n                strs.pop();\r\n            }  \r\n        }\r\n    }\r\n};\r\n```\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841085056","body":"## **91学算法DAY2**\r\n\r\n#### 思路：\r\n两个栈模拟输入和输入\r\n\r\n对比小白时期的优化：\r\n\r\npush可以一直push到输入栈，不需要倒腾。\r\n\r\npop的时候其实只要是output的栈栈顶有元素其实就是需要pop的num。\r\n\r\n**只有out栈是空的时候，才需要左边倒腾到右边。**\r\n\r\n#### 复杂度分析：\r\n\r\n- 时间：O(1)\r\n- 空间：O(n)\r\n\r\n```c++\r\n\r\nusing namespace std;\r\nclass MyQueue {\r\npublic:\r\n    stack<int> output;\r\n    stack<int> input;\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n    }\r\n    /** Push element x to the back of queue. */\r\n   void push(int x) { \r\n            input.push(x);\r\n  \r\n    }\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop()\r\n    {\r\n        int num = 0;\r\n        if (output.empty())\r\n        {\r\n            while (!input.empty())\r\n            {\r\n                output.push(input.top());\r\n                input.pop();\r\n            }\r\n        }\r\n        if (!output.empty())\r\n        {\r\n            num = output.top();\r\n            output.pop();\r\n        }\r\n        return num;\r\n    }\r\n\r\n    /** Get the front element. */\r\n    int peek() {\r\n        int res;\r\n        if (output.empty())\r\n        {\r\n            while (!input.empty())\r\n            {\r\n                output.push(input.top());\r\n                input.pop();\r\n            }\r\n        }\r\n\r\n        if (!output.empty())\r\n        {\r\n            res = output.top();\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return (output.empty() && input.empty()) ? true : false;\r\n    }\r\n};\r\n\r\n```\r\n\r\n``"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841683445","body":"## **91学算法DAY3**\r\n\r\n#### 思路：\r\n\r\n​        维护一个递增的单调栈，其中栈内的元素是每个块的最大值，这样最后栈的长度就是块的长度\r\n​        维护时的过程\r\n​         如果arr[i]比栈顶元素大，根据取最大值的题意，他就要被分到单调的一块\r\n​         如果arr[i]比栈顶元素小，那么就要依次弹出栈顶，直到找到可以找到他可以添加的块的位置，将前面弹出的这些块合并。\r\n​        /如果相等，说明当前块需要容纳arr[i]\r\n\r\n#### 复杂度分析：\r\n\r\n- 时间：O(1)\r\n- 空间：O(n)\r\n\r\n```c++\r\n\r\n#include <algorithm> \r\nusing namespace std;\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n\r\n        stack<int> res;\r\n        int len = arr.size();\r\n        int stackSize = res.size();\r\n        int max = arr[0];\r\n        res.push(max);\r\n        for (size_t i = 0; i < len; i++)\r\n        {\r\n            if (!res.empty())\r\n            {\r\n                if (arr[i] > res.top())\r\n                {\r\n                    res.push(arr[i]);\r\n                }\r\n                else\r\n                {   \r\n                    max = res.top();\r\n                    res.pop();\r\n                    while (!res.empty()) {\r\n                        if (arr[i] >= res.top()) { \r\n                            res.push(max);\r\n                            break;\r\n                        }\r\n                        res.pop();\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                res.push(arr[i]);\r\n            }\r\n        }\r\n        return stackSize;\r\n    }\r\n};\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841751580","body":"## **91学算法DAY3*4\r\n\r\n#### 思路：\r\n\r\n 先秒一个迭代。晚上回来写双指针和环\r\n\r\n****\r\n\r\n#### 复杂度分析：\r\n\r\n\r\n\r\n\r\n\r\n```c++\r\n\r\n\r\nclass Solution {\r\n    //思路\r\n    // 遍历k    \r\n    // 3 -> \r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (head == nullptr || head->next\r\n             == nullptr || k == 0) { return head; }\r\n        \r\n        ListNode* temp = head;\r\n        int len = 0;\r\n        \r\n        while (temp->next != nullptr)\r\n        {\r\n            temp = temp->next; //尾节点\r\n            len++;\r\n        }\r\n\r\n        k = k % len;\r\n        ListNode* newhead;\r\n        ListNode* newTail;\r\n        newhead = head;\r\n        newTail = head;\r\n        for (size_t i = 0; i < len - k; i++)\r\n        {\r\n            newhead = newhead->next;\r\n        }\r\n        for (size_t i = 0; i < len - k; i++)\r\n        {\r\n            newTail = newTail->next;\r\n        }\r\n        temp->next = head;\r\n        newTail->next = nullptr;\r\n        return newhead;\r\n    }\r\n};\r\n\r\n```\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Jolins":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839884479","body":"### 思路\r\n通过vector进行栈的模拟，设计一个指针始终指向栈顶的位置，记录栈中存的元素\r\n### 代码\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stack;\r\n    int m_max_;\r\n    int m_top_ = 0;\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize);\r\n        m_max_ = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (m_top_ >= m_max_) return;\r\n        stack[m_top_++] = x;\r\n    }\r\n    \r\n    int pop() {\r\n        if (m_top_ >= 1) {\r\n            return stack[--m_top_];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int min_val = min(k, m_top_);\r\n        for (int i = 0; i < min_val; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```\r\n\r\n### 注意事项\r\n需注意top++, ++top，及--top和top--可能造成的数组越界问题\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(max(maxSize, k)) (increment函数)\r\n- 空间复杂度：O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840656961","body":"### 解题思路\r\n\r\n* 遇到数字保存数字到临时变量\r\n* 遇到字母保存字母到临时变量\r\n* 遇到左括号把数字和字母推到栈中\r\n* 遇到右括号对栈中的数字和字母出栈进行解析\r\n\r\n### 代码\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<int> nums;\r\n        stack<string> strs;\r\n        string res = \"\";\r\n        int num = 0;\r\n\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] >= '0' && s[i] <= '9') {\r\n                num = num * 10 + s[i] - '0';  //字符串转整数\r\n            } else if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z')) {\r\n                res = res + s[i];\r\n            } else if('[' == s[i]) {\r\n                nums.push(num);\r\n                strs.push(res);\r\n                \r\n                //清空num和res\r\n                num = 0;\r\n                res = \"\";\r\n            } else if(']' == s[i]) {\r\n                for (int j = 0; j < nums.top(); j++) {\r\n                   //res += strs.top();\r\n                   strs.top() += res;\r\n                }\r\n\r\n                res = strs.top();\r\n\r\n                nums.pop();\r\n                strs.pop();\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 时间复杂度\r\n\r\n\r\n\r\n### 空间复杂度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841290432","body":"### Leetcode-232. 用栈实现队列\r\n### 思路\r\n使用两个栈，一个栈保存数据，另外一个栈当需要pop的时候保存第一个栈的数据，实现数据的翻转；\r\n### 代码\r\n\r\n- 语言：C++\r\n```c++\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        if (stack_in.empty()) front = x; //记录stack_in最下面的元素，且只记录一次\r\n        stack_in.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    //队列的头就是最开始的元素，因此如果out里面有元素，从out里面直接pop即可；\r\n    int pop() {\r\n        int result;\r\n        if (stack_out.empty()) {\r\n            while (!stack_in.empty()) {\r\n                stack_out.push(stack_in.top());\r\n                stack_in.pop();\r\n            }\r\n        }\r\n        result = stack_out.top();\r\n        stack_out.pop();\r\n        return result;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if (stack_out.empty()) return front;\r\n        return stack_out.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return stack_in.empty() && stack_out.empty();\r\n    }\r\n\r\nprivate:\r\n    int front;\r\n    stack<int> stack_in;\r\n    stack<int> stack_out;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```\r\n\r\n### 时间复杂度\r\nO(1)\r\n### 空间复杂度\r\nO(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841667623","body":"### 思路\r\n按照题意，将数据进行放到栈中，因为最后需要的是一个单调递增的数组，所以每一块的最大值应该是单调递增的。\r\n所以新进来一个数据\r\n\r\n- 如果大于栈顶的最大值，直接放入栈中，作为新的块\r\n- 如果小于栈顶的最大值，向之前的合并，但需要保留上一个块中的最大值\r\n\r\n### 代码实现 C++\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        for (int i = 0; i < arr.size(); i++) {\r\n            if (max_stack.empty()) {\r\n                max_stack.push(arr[i]);\r\n            } else {\r\n                if (arr[i] >= max_stack.top()) {\r\n                    max_stack.push(arr[i]);\r\n                } else {\r\n                    int temp = max_stack.top();\r\n                    while (!max_stack.empty() && arr[i] < max_stack.top()) {\r\n                        max_stack.pop();\r\n                    }\r\n                    max_stack.push(temp);\r\n                }\r\n            }\r\n        }\r\n        return max_stack.size();\r\n    }\r\n\r\nprivate:\r\n    std::stack<int> max_stack;\r\n};\r\n```\r\n\r\n### 时间复杂度\r\nO(N)\r\n### 空间复杂度\r\nO(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okbug":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839266522","body":"# 思路\r\n用数组和一个全局变量idx来模拟\r\nidx即当前栈顶元素的下标\r\npop就返回最后一个元素，并且idx--\r\npush就判断idx是否在定义的大小范围之内然后idx加1后再赋值\r\nincrement直接模拟一下过程即可\r\n\r\n# 代码：\r\nC++\r\n\r\n```cpp\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stack;\r\n    int idx;\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize); // 定义栈的大小\r\n        idx = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(idx != stack.size() - 1) {\r\n            stack[++idx] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        return idx == -1 ? idx : stack[idx--];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int limit = min(k, idx + 1);\r\n        for (int i = 0; i < limit; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n};\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840923592","body":"# 思路\r\n用一个栈为主要栈，另外一个栈为辅助栈\r\n其中push操作直接放入主要栈中，然后需要取出top元素时，需要去将主要栈的元素全部放入辅助栈中，然后再依次返回，类似做了一个反转的操作，这样pop出来的就是队列顶的元素的。\r\n# 代码\r\nc++\r\n```cpp\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    stack<int> s1, s2;\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        while(s1.size() > 1) {\r\n            s2.push(s1.top());\r\n            s1.pop();\r\n        }\r\n        int t = s1.top();\r\n        s1.pop();\r\n        while (s2.size()) {\r\n            s1.push(s2.top());\r\n             s2.pop();\r\n        }\r\n        return t;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        while(s1.size() > 1) {\r\n            s2.push(s1.top());\r\n            s1.pop();\r\n        }\r\n        int t = s1.top();\r\n        while (s2.size()) {\r\n            s1.push(s2.top());\r\n             s2.pop();\r\n        }\r\n        return t;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return s1.empty();\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841645559","body":"\r\n# 代码\r\nc++\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        auto b = arr;\r\n        sort(b.begin(), b.end());\r\n        unordered_map<int, int> map;\r\n        int res = 0;\r\n        for (int i = 0, s = 0; i < arr.size(); i ++) {\r\n            if (map[arr[i]] == 1) s --;\r\n            else if (map[arr[i]] == 0) s ++;\r\n            map[arr[i]] --;\r\n            if (map[b[i]] == -1) s --;\r\n            else if (map[b[i]] == 0) s ++;\r\n            map[b[i]] ++;\r\n            if (!s) res ++;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maqianxiong":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839686367","body":"\r\n### 思路\r\n\r\n暴力法\r\n\r\n### 代码\r\n\r\n\r\nPython\r\n\r\n\r\n```\r\n Class CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max = maxSize\r\n        self.ina = [] \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.ina)<self.max:\r\n            self.ina.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.ina:\r\n            return self.ina.pop()\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k,len(self.ina))):\r\n            self.ina[i]+=val\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841099531","body":"### 思路\r\n\r\n使用list表示两个栈stak_1,list_1，只能使用栈的相关方法，如append()，pop()，s[-1]，分别是栈顶追加元素,删除栈顶元素,取出栈顶元素.\r\n\r\n入队操作即追加元素，都在栈stak_1中操作；\r\n出队操作首先判断缓存栈,list_1是否有元素，有的话直接取出,list_1栈顶元素；若,list_1为空并且stak_1中有元素，将stak_1中元素全部转移到,list_1中，再取出,list_1栈顶元素，即可模拟队列出队操作；\r\n\r\n### 代码\r\n\r\n\r\n```\r\npython\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack_1 = []\r\n        self.list_1 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stack_1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.list_1:\r\n            return self.list_1.pop()\r\n        else:\r\n            if self.stack_1:\r\n                while self.stack_1:\r\n                    self.list_1.append(self.stack_1.pop())\r\n                return self.list_1.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.list_1:\r\n            return self.list_1[-1]\r\n        else:\r\n            if self.stack_1:\r\n                while self.stack_1:\r\n                    self.list_1.append(self.stack_1.pop())\r\n                return self.list_1[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        if self.stack_1 or self.list_1:\r\n            return False\r\n        else:\r\n            return True\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n#### push\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(1)\r\n#### pop\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n#### peek\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n#### empty\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(1)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-enll":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839755413","body":"### 思路\r\n数组模拟\r\n\r\n### 代码\r\nC++\r\n\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stack;\r\n    int idx;\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize); // 定义栈的大小\r\n        idx = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(idx != stack.size() - 1) {\r\n            stack[++idx] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        return idx == -1 ? idx : stack[idx--];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int limit = min(k, idx + 1);\r\n        for (int i = 0; i < limit; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n};"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841745832","body":"**复杂度分析**\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(1)\r\n\r\n**思路** **递归**\r\n\r\n`class Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n        \r\n        length = 1\r\n        lastNode = head\r\n        \r\n        while lastNode.next:\r\n            lastNode = lastNode.next\r\n            length += 1\r\n        \r\n        if k>=length: k=k%length\r\n\r\n        if k==0: return head\r\n\r\n        numBreak = length-k\r\n\r\n        breakNode = head\r\n        for i in range(numBreak-1):\r\n            breakNode = breakNode.next\r\n        nextListNode = breakNode.next\r\n        \r\n        lastNode.next = head\r\n        breakNode.next = None\r\n\r\n        return nextListNode`"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyyxw":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841302467","body":"JavaScript Code:\r\n```\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n  this.pushStack = []\r\n  this.popStack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n  this.pushStack.push(x)\r\n};\r\n\r\n/**\r\n * 移栈\r\n */\r\nMyQueue.prototype.transfer = function() {\r\n  if(!this.popStack.length){\r\n    while(this.pushStack.length){\r\n      this.popStack.push(this.pushStack.pop())\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n  this.transfer()\r\n  return this.popStack.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n  this.transfer()\r\n  return this.popStack[this.popStack.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n  return !this.pushStack.length && !this.popStack.length\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\nTime Complexity：O(1)\r\nSpace Complexity：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dpgirl":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841076289","body":"## 思路\r\n用辅助栈来存储元素，当辅助栈不为空时，往主栈添加辅助栈的栈顶；当主栈不为空时，往辅助栈添加主栈的栈顶\r\n\r\n- 语言支持：JavaScript\r\n\r\n\r\n```javascript\r\n\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.stack = [] // 主栈\r\n    this.helpStack = [] // 辅助栈\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    let cur = null\r\n    while(cur = this.stack.pop()) { // 主栈不为空的时候\r\n        console.log('help',this.helpStack, cur)\r\n        this.helpStack.push(cur)\r\n    }\r\n    this.helpStack.push(x) // push的时候，先往辅助栈添加元素\r\n    while(cur = this.helpStack.pop()) { // 辅助栈不为空时，往主栈添加辅助栈的栈顶\r\n        console.log('stack',this.stack, cur)\r\n        this.stack.push(cur)\r\n    }\r\n    console.log('结果', this.stack, this.helpStack)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.stack.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[this.stack.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack.length === 0\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n第二种：用数组的push和shift来模拟队列操作\r\n```javascript\r\n\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n   this.queue = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n   this.queue.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.queue.shift()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.queue[0]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.queue.length === 0\r\n};\r\n\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"physicshi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JianXinyu":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840980179","body":"## 思路\r\nqueue是FIFO, stack是LIFO. 用两个栈stack1, stack2。 queue push时就把新元素放入stack1。queue pop或者top的时候就把stack1全部的元素转移到stack2中，因为stack.pop是取出last-in, i.e., top元素，所以stack2会把last-in元素放入栈底，first-in元素放入栈顶，那么对stack2执行pop或top就能得到first-in的元素了。[参考](https://zxi.mytechroad.com/blog/stack/leetcode-232-implement-queue-using-stacks/)\r\n## 代码(C++)\r\n```cpp\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() { }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        stk1_.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if(stk2_.empty()) move();\r\n        int top = stk2_.top();\r\n        stk2_.pop();\r\n        return top;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if(stk2_.empty()) move();\r\n        return stk2_.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return (stk1_.empty() && stk2_.empty());\r\n    }\r\nprivate:\r\n    stack<int> stk1_, stk2_;\r\n    void move(){\r\n        while(!stk1_.empty()){\r\n            stk2_.push(stk1_.top());\r\n            stk1_.pop();\r\n        }\r\n    }\r\n};\r\n```\r\n**复杂度分析**\r\n- Time complexity: \r\n    - worst case: push n个元素进queue，那么第一次调用pop或peek时，复杂度是O(n)\r\n    - best case: 之后再调用pop或peek，复杂度是O(1)\r\n    - average case: 执行>=n次的pop或peek，平均复杂度是O(1)\r\n - Space complexity: 两个stack加起来是n个元素，所以是O(n)  "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841594876","body":"## 思路\r\n题解。\r\n该方法借鉴了Counting Sort, Bucket Sort。\r\n计数数组count: 数组的索引表示值，数组的值表示其对应的出现次数。\r\n为了节省空间，虽然count的index是从0开始，但我们可以加上一个偏移量(arr中的最小值min)，\r\n这样count[0] = 1就表示1在arr中出现了1次。count的长度为max-min+1\r\n\r\n如果一个块能单独排序，那么它在arr中位置和排序后在sorted_arr的位置一样。\r\n\r\n所以对于arr中任意一个块B，其在sorted_arr中对应位置的块是B'，比较B和B'中元素在count中的值。\r\n\r\n- 如果都相等，说明它们其实是同一个块。B可以单独排序。比如B1和B1'\r\n- 如果不相等，那继续扩大块B的范围。比如B0和B0'\r\n\r\n> Crux:  如果两个数组的计数信息是一致的，那么两个数组排序后的结果也是一致的\r\n\r\n那么如何比较两个块对应的count内容呢？\r\n能单独排序的blocks必然是连续的，且它们在arr和sorted_arr中的位置相同，它们对应的count相同。\r\n故而可以先声明两个计数数组，从第一个元素开始遍历arr和sorted_arr，并更新两个计数数组。\r\n\r\n- 一旦两个计数数组相等了，说明我们又遇到了一个新的可排序块\r\n- 不相等就继续\r\n\r\n因此步骤如下：\r\n\r\n1. sort arr -> sorted_arr\r\n2. traverse arr\r\n3. if arr[:i+1]‘s corresponding count array == sorted_arr[:i+1]'s corresponding count array， \r\n   说明我们得到了一个新的可排序的块，ans++ \r\n\r\narr[:i+1] 指的是 arr 的切片，从索引 0 到 索引 i 的一个切片。\r\n\r\n但其实不需要两个计数数组，只需要一个计数数组count，arr增加count元素的值，sorted_arr则减少count元素的值。\r\n记录count中不为0的元素个数。如果是0，说明遇到了一个新的可排序块。\r\n## 代码\r\n```cpp\r\nint maxChunksToSorted(vector<int>& arr) {\r\n     vector<int> sorted_arr = arr;\r\n     sort(sorted_arr.begin(), sorted_arr.end());\r\n     int n = arr.size();\r\n     int min = sorted_arr[0], max = sorted_arr[n-1];\r\n     vector<int> count(max - min + 1, 0);\r\n     int non_zero_cnt = 0;\r\n     int ans = 0;\r\n     for(int i = 0; i < n; ++i){\r\n         int a = arr[i]-min, b = sorted_arr[i]-min;\r\n         \r\n         count[a]++;\r\n         if(count[a] == 0) \r\n             non_zero_cnt--;\r\n         else if(count[a] == 1) //注意一旦一个元素不为零，我们只用cnt++一次\r\n             non_zero_cnt++;\r\n         \r\n         count[b]--;\r\n         if(count[b] == 0)\r\n             non_zero_cnt--;\r\n         else if(count[b] == -1) //同上\r\n             non_zero_cnt++;\r\n         \r\n         if(non_zero_cnt == 0)\r\n             ans++;\r\n         \r\n     }\r\n     return ans;\r\n }   \r\n```\r\n## 复杂度分析\r\nT: 排序是决定因素 O(NlogN)，faster than 5.27%\r\nS: 减少了，但仍然是O(max-min+1)，less than 5.27%\r\n\r\n评价：\r\n这个方法还是很低效的。应该使用单调栈。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841745367","body":"## 思路\r\n首先观察规律：rotate就是把old tail and old head连起来，设置new tail, 再返回new head。题目Constraints中给的k可能远大于链表长度，不妨先遍历一遍链表，找出长度，再取模，避免无意义的遍历列表。\r\n注意链表为0，或者不旋转的corner case。\r\n## Code\r\n```cpp\r\nListNode* rotateRight(ListNode* head, int k) {\r\n\tif(!head || !k) return head;\r\n\tint len = 0;\r\n\tListNode *cur = head, *tail;\r\n\r\n\twhile(cur){\r\n\t\tlen++;\r\n\t\tif(!cur->next) tail = cur;\r\n\t\tcur = cur->next;\r\n\t}\r\n\r\n\tint rotate = k % len;\r\n\tif(!rotate) return head;\r\n\tcur = head;\r\n\tfor(int i = 1; i < len - rotate; ++i){\r\n\t\tcur = cur->next;\r\n\t}\r\n\r\n\ttail->next = head;\r\n\tListNode* newhead = cur->next;\r\n\tcur->next = nullptr;\r\n\r\n\treturn newhead;\r\n}\r\n```\r\n\r\n**复杂度分析**\r\nN为链表长度\r\nT: 遍历了两遍链表，O(N)\r\nS: O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"PeopleWhoListenToStories":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840997718","body":"> cv第二天\r\n```js\r\n  var MyQueue = /** @class */ (function () {\r\n      function MyQueue() {\r\n          this.stack = [];\r\n      }\r\n      MyQueue.prototype.push = function (value) {\r\n          this.stack.push(1);\r\n      };\r\n      MyQueue.prototype.peek = function () {\r\n          return this.stack[0];\r\n      };\r\n      MyQueue.prototype.pop = function () {\r\n          this.stack.pop();\r\n      };\r\n      MyQueue.prototype.empty = function () {\r\n          return !this.stack.length;\r\n      };\r\n      return MyQueue;\r\n  }());\r\n  var obj = new MyQueue();\r\n  obj.push(0);\r\n  obj.push(1);\r\n  obj.pop();\r\n  console.log(obj.peek());\r\n  console.log(obj);\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zeningc":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841089348","body":"### 思路\r\n\r\n栈是一个后进先出的结构，队列是一个先进先出的结构。因此，出队操作时需要倒栈，将所有元素倒序加入另一个栈即可解决先进先出的问题\r\n\r\n### 代码\r\n\r\n\r\n```py\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack1=[]\r\n        self.stack2=[]\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stack1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.stack2:\r\n            return self.stack2.pop()\r\n        else:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.stack2:\r\n            return self.stack2[-1]\r\n        else:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.stack2)+len(self.stack1)==0\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(2N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"x-joey":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841135443","body":"## 思路\r\n第二次刷这题，顺利完成。利用两个栈操作。\r\n## 关键点\r\n从题解中看到这段，有丝丝明白为什么要用两个栈来实现一个队列，因为多线程可以分开同一个队列的读写操作。\r\n\r\n实际上现实中也有使用两个栈来实现队列的情况，那么为什么我们要用两个 stack 来实现一个 queue？\r\n\r\n其实使用两个栈来替代一个队列的实现是为了在多进程中分开对同一个队列对读写操作。一个栈是用来读的，另一个是用来写的。当且仅当读栈满时或者写栈为空时，读写操作才会发生冲突。\r\n\r\n当只有一个线程对栈进行读写操作的时候，总有一个栈是空的。在多线程应用中，如果我们只有一个队列，为了线程安全，我们在读或者写队列的时候都需要锁住整个队列。而在两个栈的实现中，只要写入栈不为空，那么push操作的锁就不会影响到pop。\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass MyQueue {\r\n        Stack<Integer> stack1 ;\r\n        Stack<Integer> stack2 ;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stack1 = new Stack();\r\n        stack2 = new Stack();\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        while(!stack1.isEmpty()){\r\n            stack2.push(stack1.pop());\r\n        }\r\n        stack2.push(x);\r\n        while(!stack2.isEmpty()){\r\n            stack1.push(stack2.pop());\r\n        }\r\n\r\n\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(stack1.isEmpty()){\r\n            return 0;\r\n        }\r\n        return stack1.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(stack1.isEmpty()){\r\n            return 0;\r\n        }\r\n        return stack1.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return stack1.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$//入队时间复杂度为O（n）,出队O（1），判断空O（1），队首O（1）；看题解均摊时间复杂度是O（1），后面有时间再看一下。\r\n- 空间复杂度：$O(n)$\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DANG-PingBo":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841185354","body":"#50 \r\n\r\n\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1, self.stack2 = [], []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n    def pop(self):\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2.pop()\r\n\r\n    def peek(self):\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack1 and not self.stack2\r\n\r\n\r\n时间复杂度: O(n)\r\n空间复杂度: O(n)\r\n\r\n字节原题......"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841663916","body":"## 我只能说这个解法真是nb，叹为观止\r\n\r\n\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        count_a = collections.defaultdict(int)\r\n        count_b = collections.defaultdict(int)\r\n        ans = 0\r\n\r\n        for a, b in zip(arr, sorted(arr)):\r\n            count_a[a] += 1\r\n            count_b[b] += 1\r\n            if count_a == count_b: \r\n                ans += 1\r\n\r\n        return ans\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度: O(n^2)\r\n- 空间复杂度: O(n)\r\n- (懒得优化了)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangyifan2018":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841202056","body":"### 代码\r\n\r\n- 支持语言：python\r\n\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stk = []\r\n        self.help_stk = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stk:\r\n            self.help_stk.append(self.stk.pop())\r\n        self.help_stk.append(x)\r\n        while self.help_stk:\r\n            self.stk.append(self.help_stk.pop())\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.stk.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stk[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.stk)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ninghuang456":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841225456","body":"/** use two stack to implement queue: outStack and inStack. Time complexity: o(1) for all methods. amortized for pop and peek method.\r\n*/\r\nclass MyQueue {\r\n\r\n    /** Initialize your data structure here. */\r\n    Stack<Integer> inStack;\r\n    Stack<Integer> outStack;\r\n    public MyQueue() {\r\n        inStack = new Stack<>();\r\n        outStack = new Stack<>();   \r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n      inStack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(!outStack.isEmpty()) return outStack.pop();\r\n        while(!inStack.isEmpty()){\r\n            outStack.push(inStack.pop());\r\n        }\r\n        return outStack.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(!outStack.isEmpty()) return outStack.peek();\r\n        while(!inStack.isEmpty()){\r\n            outStack.push(inStack.pop());\r\n        }\r\n        return outStack.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"He1xin":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841236637","body":"__思路__\r\n用两个栈 tem，deque；push()只往deque里加；pop()和peek()借助tem得到deque底部元素，之后再将元素填往deque；empty()只判断deque是否为空就好。\r\n**代码（Java）**\r\n```java\r\nclass MyQueue {\r\n    private ArrayDeque<Integer> deque;\r\n    private ArrayDeque<Integer> tem;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        deque=new ArrayDeque<>();\r\n        tem=new ArrayDeque<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {        \r\n        deque.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        int size=deque.size();\r\n        for(int i=1;i<size;i++){\r\n            tem.push(deque.pop());\r\n        }\r\n        int ans=deque.pop();\r\n        for(int i=1;i<size;i++){\r\n            deque.push(tem.pop());\r\n        }\r\n        return ans;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        int size=deque.size();\r\n        for(int i=0;i<size;i++){\r\n            tem.push(deque.pop());\r\n        }\r\n        int ans=tem.peek();\r\n        for(int i=0;i<size;i++){\r\n            deque.push(tem.pop());\r\n        }\r\n        return ans;\r\n\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return deque.isEmpty();\r\n    }\r\n}\r\n```\r\n**时间复杂度**\r\npop()和peek()为O(n)。push()和empty()为O(1)。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Moin-Jer":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841297330","body":"#### 思路：\r\n栈有先进后出的特点，队列有先进现出的特点，此题目主要考察如何让一个被压在底下的元素先取出来。\r\n因为需要取到的元素是被压在最底下的，那么想要取出最底下的元素就必须把它上面的元素想弹出，由于最先弹出的是最后进栈的，同时它也应该是最后出队列的元素，即相当与把现有的最前的元素放到最后，所以需要做的是把首尾的元素位置进行互换，如果是数组使用双指针即可简单解决位置互换问题，但是栈的这个数据结构限制了只能从一端进行读写操作，此时想要把元素进行互换，可以把原来的元素都拉出来，在重新圧入到一个新的栈中。\r\n#### 代码\r\n```\r\nclass MyQueue {\r\n\r\n    Deque<Integer> in, out;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        in = new LinkedList<>();\r\n        out = new LinkedList<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        in.add(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (out.isEmpty()) {\r\n            while (!in.isEmpty()) {\r\n                out.add(in.poll());\r\n            }\r\n        }\r\n        return out.poll();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (out.isEmpty()) {\r\n            while (!in.isEmpty()) {\r\n                out.add(in.poll());\r\n            }\r\n        }\r\n        return out.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return in.isEmpty() && out.isEmpty();\r\n    }\r\n}\r\n```\r\n#### 复杂度：\r\n时间复杂度：　Ｏ（１）\r\n空间复杂度：　Ｏ（Ｎ）　"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LambertCao":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841307971","body":"以前做过这题\r\n```\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        //先把B中的元素倒回到A中去\r\n        while(!B.empty()){\r\n            A.push(B.top());\r\n            B.pop();\r\n        }\r\n        A.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        //将A中的内容移到B上去\r\n        while(!A.empty()){\r\n            B.push(A.top());\r\n            A.pop();\r\n        }\r\n        if(B.empty()){\r\n            return -1;\r\n        }\r\n        else{\r\n            int A = B.top();\r\n            B.pop();\r\n            return A;\r\n        }\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        //将A中的内容移到B上去\r\n        while(!A.empty()){\r\n            B.push(A.top());\r\n            A.pop();\r\n        }\r\n        if(B.empty()){\r\n            return -1;\r\n        }\r\n        else{\r\n            return B.top();\r\n        }\r\n    }\r\n    \r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        while(!A.empty()){\r\n            B.push(A.top());\r\n            A.pop();\r\n        }\r\n        return B.empty();\r\n    }\r\npublic:\r\n    stack<int> A;\r\n    stack<int> B;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841617021","body":"今天这题，一直在想着如何用分治的思想去做，比如用到归并再统计逆序对，但是忽略了逆序对算分组数需要回溯，这样就太麻烦了，裂开，下次不能再看到困难题就往复杂的地方想了。\r\n此题解法用单调栈，计数优化值得借鉴\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> S;\r\n        for(int i = 0;i<arr.size();++i){\r\n            if(S.empty()){\r\n                S.push(arr[i]);\r\n            }\r\n            else{\r\n                if(arr[i]<S.top()){\r\n                    int maxvalue = INT16_MIN;\r\n                    while(!S.empty()&&S.top()>arr[i]){\r\n                        maxvalue = max(S.top(),maxvalue);\r\n                        S.pop();\r\n                    }\r\n                    S.push(maxvalue);\r\n                }\r\n                else{\r\n                    S.push(arr[i]);\r\n                }\r\n            }\r\n        }\r\n        return S.size();\r\n    }\r\n};\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841760135","body":"这题应该用快慢指针做的，这样就只需要遍历一遍\r\n但我的步骤为：\r\n1.先封装成环，且统计size\r\n2.由于k可能比size大很多，取余\r\n3.那么遍历到size-k就是新头节点\r\n分析：我的理解是各有好处，用快慢指针的话，只需遍历一遍，但是k值不好再次取余统计\r\nT:O(N)\r\nS:O(1)\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(head==NULL){\r\n            return NULL;\r\n        }\r\n        //先把链表封装成环\r\n        ListNode* tail = head;\r\n        int size = 0;\r\n        while(tail->next!=NULL){\r\n            tail = tail->next;\r\n            ++size;\r\n        }\r\n        size++;\r\n        tail->next = head;\r\n\r\n        k = k%size;\r\n        \r\n        if(k==0){\r\n            tail->next = NULL;\r\n            return head;\r\n        }\r\n\r\n        ListNode* curr = head;\r\n        ListNode* pre = NULL; \r\n        for(int i =0 ;i<size-k;++i){\r\n            pre = curr;\r\n            curr = curr->next;\r\n        }\r\n        if(pre!=NULL){\r\n            pre->next = NULL;\r\n        }\r\n\r\n        return curr;\r\n    }\r\n};\r\n```\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MellonGuan":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841332013","body":" ## 题目地址(232. 用栈实现队列)\r\n * https://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n \r\n ## 解题思路\r\n * 辅助栈设计 stack2\r\n * push(int x) 将元素 x 推到队列的末尾： stack1 保存队列首在栈底，队列尾部在栈顶；\r\n * pop() -- 从队列首部移除元素： stack2 保存队列首在栈顶，队列尾部在栈底；\r\n * int peek() 返回队列开头的元素：stack2 保存队列首在栈顶，队列尾部在栈底；\r\n * boolean empty() 如果队列为空，返回 true ；否则，返回 false：stack1、stack2都为空时才为true；\r\n \r\n```cpp\r\n/*\r\n * 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\r\n * 实现 MyQueue 类：\r\n * void push(int x) 将元素 x 推到队列的末尾\r\n * int pop() 从队列的开头移除并返回元素\r\n * int peek() 返回队列开头的元素\r\n * boolean empty() 如果队列为空，返回 true ；否则，返回 false\r\n * 说明：\r\n * 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size,\r\n * 和 is empty 操作是合法的。\r\n * 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n    来源：力扣（LeetCode）\r\n    链接：https://leetcode-cn.com/problems/implement-queue-using-stacks\r\n    著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n * 使用栈实现队列的下列操作：\r\n * push(x) -- 将一个元素放入队列的尾部。\r\n * pop() -- 从队列首部移除元素。\r\n * peek() -- 返回队列首部的元素。\r\n * empty() -- 返回队列是否为空。\r\n */\r\n\r\n#include <iostream>\r\n#include <stack>\r\n\r\nusing namespace std;\r\n\r\nclass MyQueue {\r\npublic:\r\n    stack<int> st1;\r\n    stack<int> st2;\r\n    int temp = 0;\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n\r\n    /** Push element x to the back of queue.\r\n     * @param x void push(int x)\r\n     * 将元素 x 推到队列的末尾 */\r\n    void push(int x) {\r\n        while (!st2.empty()){\r\n            temp = st2.top();\r\n            st2.pop();\r\n            st1.push(temp);\r\n        }\r\n        st1.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element.\r\n     *\r\n     * @return int pop()\r\n     * 从队列的开头移除并返回元素\r\n     */\r\n    int pop() {\r\n        int popnum = 0;\r\n        while (!st1.empty()){\r\n            temp = st1.top();\r\n            st1.pop();\r\n            st2.push(temp);\r\n        }\r\n        popnum = st2.top();\r\n        st2.pop();\r\n        return popnum;\r\n    }\r\n\r\n    /** Get the front element.\r\n     *\r\n     * @return int peek()\r\n     * 返回队列开头的元素\r\n     */\r\n    int peek() {\r\n        int peeknum = 0;\r\n        while (!st1.empty()){\r\n            temp = st1.top();\r\n            st1.pop();\r\n            st2.push(temp);\r\n        }\r\n        peeknum = st2.top();\r\n        return peeknum;\r\n    }\r\n\r\n    /** Returns whether the queue is empty. \r\n     * \r\n     * @return boolean empty() \r\n     * 如果队列为空，返回 true ；\r\n     * 否则，返回 false\r\n     * */\r\n    bool empty() {\r\n        if (st1.empty() && st2.empty())\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n};\r\n\r\n```\r\n ## 时间复杂度\r\n * O(n)\r\n ## 空间复杂度\r\n * O(n)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SeventeenCui":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841577415","body":"### 思路\r\n两次遍历\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        int N = arr.size();\r\n        vector<int> lmax(N, INT_MIN);\r\n        vector<int> rmin(N, INT_MAX);\r\n        lmax[0] = arr[0];\r\n        rmin[N - 1] = arr[N - 1];\r\n        for (int i = 1; i < N; ++i) {\r\n            lmax[i] = max(lmax[i - 1], arr[i]);\r\n            rmin[N - 1 - i] = min(rmin[N - i], arr[N - 1 - i]);\r\n        }\r\n        int res = 1;\r\n        for (int i = 0; i < N - 1; ++i) {\r\n            res += lmax[i] <= rmin[i + 1];\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BUBBLEbubbleBUBBLEbubble":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841602759","body":"**思路**\r\n最主要的是当：1.用栈表示块。2.前块的最小值要永远要大于等于前一块的最大值。若不符合则要和前面一块合并。\r\n**步骤**\r\n一开始从左向右以单个数据作为一个块，向右移动，若不符合上面的思路就向左合并块。\r\n**代码**\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: [int]) -> int:\r\n        stack = []  # 栈的长度即块数\r\n        for num in arr:\r\n            if stack and stack[-1] > num:\r\n                head = stack.pop()\r\n                while stack and num < stack[-1]:\r\n                    stack.pop()\r\n                pass\r\n                stack.append(head)\r\n            else:\r\n                stack.append(num)\r\n                pass\r\n            pass\r\n        pass \r\n        return len(stack)\r\n```\r\n**复杂度分析**\r\n时间：O(N)\r\n空间：O(N)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Tomtao626":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841604711","body":"# 思路：\r\n> + 记录每个块中的最大值，最大值的个数就是分块数\r\n\r\n```python\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: \r\n                    stack.pop()\r\n                stack.append(head)\r\n            else: \r\n                stack.append(num)\r\n        return len(stack)\r\n```\r\n\r\n# 复杂度分析：\r\n> + 时间复杂度：O(n)\r\n> + 空间复杂度：O(n）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JasonQiu":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841632622","body":"A stack will hold the largest element in each chunk.\r\nScan from the beginning of the array:\r\n\r\n- If an element is equal to or greater than the largest element so far _i.e._ the last element of the stack (if applicable), it will be an individual chunk as well as the largest element of that chunk. Append it to the stack.\r\n- Otherwise, to make the element no smaller than (any element in) any other chunk, it should form a new chunk along with all the elements that fail to meet the requirement. During this process, the largest/representative element(s) will be popped from the stack. The chunks represented by the popped elements will no longer be individual chunks. The current element in the array or the (former) last element of the stack will be the smallest or the largest element of the new chunk. Append the last element back to the stack so that it represents the new chunk.\r\n\r\nThe length of the stack is the answer.\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        chunks = []\r\n        for a in arr:\r\n            if chunks and chunks[-1] > a:\r\n                last = chunks[-1]\r\n                while chunks and chunks[-1] > a:\r\n                    chunks.pop()\r\n                chunks.append(last)\r\n            else:\r\n                chunks.append(a)\r\n        return len(chunks)\r\n```\r\nRuntime: 68 ms, faster than 93.72% of Python3 online submissions for Max Chunks To Make Sorted II.\r\nMemory Usage: 14.7 MB, less than 44.35% of Python3 online submissions for Max Chunks To Make Sorted II."},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dopufol":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841640842","body":"```\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        n = len(arr)\r\n        stack = list()\r\n        stack.append(arr[0])\r\n        curMax = arr[0]\r\n        for i in range(1, n):\r\n            if arr[i] >= stack[-1]:\r\n                stack.append(arr[i])\r\n            else:\r\n                curMax = stack[-1]\r\n                while stack and arr[i] < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(curMax)\r\n        return len(stack)\r\n```\r\n时间复杂度是O(N)，空间复杂度是O(1)。其中N是所有数组的长度。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ysy0707":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841648081","body":"**思路：单调栈**\r\n维持一个单调递增栈，存储每个块中的最大值，最终单调栈的长度就是可分块的大小。\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        // new一个栈对象\r\n        int ans = 0;\r\n        for(int num:arr){\r\n            if(!stack.isEmpty() && num < stack.peek()){\r\n                int tmp = stack.pop();\r\n                while(!stack.isEmpty() && num < stack.peek()){\r\n                    stack.pop();\r\n                }\r\n                stack.push(tmp);\r\n                // 遍历整个数组，当栈不空且栈顶元素大于当前比较元素则出栈，且更新成新的最大值，不增加栈的长度\r\n            }\r\n            else{\r\n                stack.push(num);\r\n                // 如果栈空或栈顶元素小于当前比较元素，则栈顶元素入栈，栈的长度加一\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n时间复杂度:O(N)\r\n空间复杂度:O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunshineliu6":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841656231","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        LinkedList<Integer> stack = new LinkedList<Integer>();\r\n        for(int num : arr) {\r\n            if(!stack.isEmpty() && num < stack.getLast()) {\r\n                int head = stack.removeLast();\r\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\r\n                stack.addLast(head);\r\n            }\r\n            else stack.addLast(num);\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n时间复杂度：O（N）\r\n空间复杂度O（N）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jimengchao":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841664989","body":"没有思路，对照题解，所理解的 遍历arr， 如果 下一项比前一项数值大则分块， 将每一块的最大值保留，最后返回长度\r\n```js\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n    let stack = [];\r\n    let head = 0;\r\n\r\n    for ( let i = 0; i < arr.length; i++ ){\r\n        if( stack.length && stack[stack.length - 1] > arr[i] ){\r\n            head = stack.pop();\r\n            while(stack.length && stack[stack.length - 1] > arr[i]){\r\n                stack.pop()\r\n            }\r\n            stack.push(head)\r\n        }else{\r\n            stack.push(arr[i])\r\n        }\r\n    }   \r\n    return stack.length\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AnnabellHyx":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841678608","body":"### 方法：单调递增栈\r\n### 代码\r\n```\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n    let stack = []\r\n    for (let i = 0; i < arr.length; i ++) {\r\n        if (!stack.length || stack[stack.length - 1] <= arr[i]) {\r\n            stack.push(arr[i])\r\n        } else {\r\n            const temp = stack.pop()\r\n            while (stack[stack.length - 1] > arr[i]) {\r\n                stack.pop()\r\n            }\r\n            stack.push(temp)\r\n        }\r\n    }\r\n    return stack.length\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Lizhao-Liu":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841683542","body":"**思路**\r\n\r\n遍历数组，划分当前数字前的排序快，栈中保存每排序块的最大值，确保head大小从左往右递增 （如果当前数字很小需要添加循环合并前面的排序块），返回栈的大小为排序块个数\r\n\r\n**代码**\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        for(int curr: arr){\r\n            if(!stack.empty() && curr<stack.peek()){\r\n                int max = stack.pop();\r\n                while(!stack.empty() && curr<stack.peek()){\r\n                    stack.pop();\r\n                }\r\n                stack.push(max);\r\n            }else{\r\n                stack.push(curr);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n\r\n**复杂度**\r\n\r\n时间复杂度 O(N)\r\n\r\n空间复杂度 O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kelh93":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841684182","body":"思路：\r\n用栈保存分割片段中的最大值，只要后序的数字比栈顶的数字大，则是有效的分块，否则，栈顶的分块需要与较小的数进行合并分块。\r\n[参考题解](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/zui-duo-neng-wan-cheng-pai-xu-de-kuai-ii-deng-jie-/)\r\n代码：\r\n```javascript\r\nfunction maxChunksSorted(arr){\r\n  let stack = [];\r\n  let length = arr.length;\r\n  let head = null;\r\n  for(let i = 0; i < length; i++){\r\n    const item = arr[i];\r\n    if(stack.length == 0 || stack[stack.length - 1] <= item){\r\n      stack.push(item);\r\n    }else{\r\n      head = stack.pop();\r\n      //弹出所有大于item的值\r\n      while(stack.length >  0 && stack[stack.length - 1] > item){\r\n        stack.pop();\r\n      }\r\n      stack.push(head); // 合并分块\r\n    }\r\n  }\r\n  return stack.length;\r\n}\r\n```\r\n时间复杂度 O(N);\r\n空间复杂度O(N);"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"klaus0323":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841755209","body":"\r\nThis question is straightforward, but the details are hard to comply. \r\nDetail 1, it's possible that the length of the linked list is SMALLER than k given in the question. If length is too small and k is too big, there could be multiple rotations over and over.\r\nDetail 2, how to count through the Linked List?\r\n\r\nMethodology: ( TWO-Pass solution )\r\n1. Use a pointer for counting, traverse through the entire linkedlist, then when the pointer reach the position that pointer.next is None, record the length of the linked list\r\n2. Use two pointers, first/second. At the beginning, these two are initialized at head. then use k as the counter, move the second pointer k steps forward, record the second pointer (here, the ending location of the second pointer is the **END** of the reversed linked list)\r\n3. adjust the linked list, be careful about where is the end and where is the new start. the new head of the result should be the next position of the second pointer.\r\n4. Overall the thinking process of the questions is not very hard, but details are not that easy to comply.\r\n\r\n\r\nHere is the code in python 3\r\n\r\n\r\n`\r\n\r\n  class Solution:\r\n      def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n          \r\n          # base case: empty list just return is OK\r\n          if not head: return None\r\n          \r\n          # first, calculate the length of the linked list\r\n          pointer = head\r\n          count = 1\r\n          while pointer.next:\r\n              pointer = pointer.next\r\n              count += 1\r\n              \r\n          # here, the k could be longer than the length of the linkedlist\r\n          k = k % count \r\n          if k == 0: return head\r\n          \r\n          # move the second until there are distance of k\r\n          first, second = head, head\r\n          while k > 0:\r\n              second = second.next\r\n              k -= 1\r\n          \r\n          # simultaneously move the first and second to the end while maintaining the k distance\r\n          while second.next:\r\n              first = first.next\r\n              second = second.next\r\n          \r\n          # now first is the end, re-adjust the entire linkedlist\r\n          begin = first.next\r\n          first.next = None\r\n          second.next = head\r\n          return begin\r\n            `"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"15209356689":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841762702","body":"**1思路**\r\n1链表空，返回空，确定链表长度count ；2向右移动K 等于向右移动K%count ，那么返回的节点等于，head向右移动count-K%count；3原始链表后面链接到起始节点，返回节点前一位断开。\r\n**2代码PYTHON**\r\n```python\r\nDefinition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head:return\r\n        bangnode=ListNode()\r\n        bangnode.next=head\r\n        temp=head\r\n        a=bangnode\r\n        count=0\r\n        while temp:\r\n            count+=1\r\n            temp=temp.next\r\n            a=a.next\r\n        a.next=head\r\n        k=count-k%count\r\n        if k==0:\r\n            return head\r\n        index=1\r\n        key=head\r\n        while index<k:\r\n            key=key.next\r\n            index+=1\r\n        res=key.next\r\n        key.next=None\r\n        return res\r\n ```\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)  N是链表的长度\r\n- 空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}