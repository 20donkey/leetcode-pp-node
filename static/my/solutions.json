{"1":[],"2":[],"3":[],"4":[],"5":[],"6":[],"7":[],"8":[],"9":[],"10":[],"11":[],"12":[],"13":[],"14":[],"15":[],"16":[],"17":[],"18":[],"19":[],"20":[],"21":[],"22":[],"23":[],"24":[],"25":[],"26":[],"27":[],"28":[],"29":[],"30":[],"31":[],"32":[],"33":[],"34":[],"35":[],"36":[],"37":[],"38":[],"39":[],"40":[],"41":[],"42":[],"43":[],"44":[],"45":[],"46":[],"47":[],"48":[],"49":[],"50":[],"51":[],"52":[],"53":[],"54":[],"55":[],"56":[],"57":[],"58":[],"59":[],"60":[],"61":[],"62":[],"63":[],"64":[],"65":[],"66":[],"67":[],"68":[],"69":[],"70":[],"71":[],"72":[],"73":[],"74":[],"75":[],"76":[],"77":[],"78":[],"79":[],"80":[],"81":[],"82":[],"83":[],"84":[],"85":[],"86":[],"87":[],"88":[],"89":[],"90":[],"91":[],"839781960":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429561861","body":" 思路；返回数组转换为字符串相加的结果，转换回数组\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new ArrayList<>(); // 创建一个空的结果列表\r\n        int i = num.length - 1; // 从最高位开始处理\r\n        while (i >= 0 || k > 0) { // 如果num数组没有处理完或者k不为0\r\n            if (i >= 0) { // 如果num数组还有数\r\n                k += num[i]; // 将num[i]加到k中\r\n                i--; // 指向下一个num的下标\r\n            }\r\n            list.add(0, k % 10); // 将k的最低位添加到结果列表的最前面\r\n            k /= 10; // 去掉k的最低位\r\n        }\r\n        return list; // 返回结果列表\r\n    }\r\n}\r\n//时间空间复杂度O(N)\r\n\r\nclass Solution2 {\r\n    public static List<Integer> addToArrayForm(int[] num, int k) {\r\n        StringBuffer sb = new StringBuffer(); // 创建一个可变的字符串缓冲区\r\n        for (int i=0;i<num.length;i++) { // 遍历num数组\r\n            sb.append(num[i]); // 将num数组中的数添加到字符串缓冲区中\r\n        }\r\n        BigDecimal bg = new BigDecimal(sb.toString()).add(new BigDecimal(k)); // 将字符串缓冲区中的数和k相加\r\n        String countStr = bg.toString(); // 将相加的结果转换为字符串\r\n        List<Integer> list = new ArrayList<>(); // 创建一个空的结果列表\r\n        for (int i=0;i<countStr.length();i++) { // 遍历相加后的结果字符串\r\n            list.add(Integer.parseInt(String.valueOf(countStr.charAt(i)))); // 将结果字符串中的数添加到结果列表中\r\n        }\r\n        return list; // 返回结果列表\r\n    }\r\n}\r\n时间空间复杂度O(N)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431409004","body":"思路，但是错了\r\n//输出距离每个字母最近的e的下标->输入字串s,字符e。\r\n```java\r\nclass Solution{\r\n    public int[] shortestToChar(String s, char c) {\r\n        ArrayList<Integer> lst = new ArrayList<>();\r\n        int[] rt = new int[s.length()];\r\n        //得到arr\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) {\r\n                lst.add(i);\r\n            }\r\n        }\r\n        //遍历一遍\r\n        //遍历每个'e'字符3,5,611\r\n        for (int i = 0; i < lst.size(); i++) {\r\n            int e = lst.get(i); // 当前遍历到的'e'字符的下标\r\n            int j = e; // 初始化j为当前'e'字符的下标\r\n            while (j >= 0) {\r\n                int dist = e - j; // 计算当前字符到当前'e'字符的距离\r\n                // 如果rt[j]为0，说明当前位置之前没有出现过'e'字符，需要直接记录距离\r\n                // 或者当前位置到当前'e'字符的距离小于rt[j]，说明当前位置到当前'e'字符更近，需要更新rt[j]\r\n                if (rt[j] == 0 || dist < rt[j]) {\r\n                    rt[j] = dist; // 更新rt[j]为当前位置到当前'e'字符的距离\r\n                } else {\r\n                    break; // 如果当前位置到当前'e'字符的距离已经不再递减，说明已经找到最近的'e'字符，可以跳出循环\r\n                }\r\n                j--; // 继续向左遍历字符\r\n            }\r\n            j = e + 1; // 将j重置为当前'e'字符下标的下一个位置\r\n            while (j < s.length()) {\r\n                int dist = j - e; // 计算当前字符到当前'e'字符的距离\r\n                // 如果rt[j]为0，说明当前位置之前没有出现过'e'字符，需要直接记录距离\r\n                // 或者当前位置到当前'e'字符的距离小于rt[j]，说明当前位置到当前'e'字符更近，需要更新rt[j]\r\n                if (rt[j] == 0 || dist < rt[j]) {\r\n                    rt[j] = dist; // 更新rt[j]为当前位置到当前'e'字符的距离\r\n                } else if (dist == rt[j] && j < e) {\r\n                    // 当距离相等时，选择左边的字符\r\n                    rt[j] = dist;\r\n                    break;\r\n                } else {\r\n                    break; // 如果当前位置到当前'e'字符的距离已经不再递增，说明已经找到最近的'e'字符，可以跳出循环\r\n                }\r\n                j++; // 继续向右遍历字符\r\n            }\r\n        }\r\n        return rt;\r\n    }\r\n    \r\n} \r\n优化\r\n\r\n//给定一个字符串S和一个字符C，返回一个整数数组，其中每个元素表示字符C在字符串S中的距离。\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        // 创建int型数组rt，用于存放最终的距离结果\r\n        int[] rt = new int[s.length()];\r\n        // 遍历字符串S\r\n        for (int i = 0; i < s.length(); i++) {\r\n            // 如果字符S中当前字符等于目标字符C，距离为0\r\n            if (s.charAt(i) == c) {\r\n                rt[i] = 0;\r\n            }\r\n            // 否则以当前字符为中心，从左右向外扩散查找，直到找到目标字符C\r\n            else {\r\n                int j = i - 1; // 左边字符的位置\r\n                int k = i + 1; // 右边字符的位置\r\n                while (j >= 0 || k < s.length()) {\r\n                    // 如果左边字符的位置不越界且字符等于目标字符C，距离为当前字符和目标字符之间的距离\r\n                    if (j >= 0 && s.charAt(j) == c) {\r\n                        rt[i] = i - j;\r\n                        break;\r\n                    }\r\n                    // 如果右边字符的位置不越界且字符等于目标字符C，距离为当前字符和目标字符之间的距离\r\n                    else if (k < s.length() && s.charAt(k) == c) {\r\n                        rt[i] = k - i;\r\n                        break;\r\n                    }\r\n                    // 否则继续向外扩散查找\r\n                    j--;\r\n                    k++;\r\n                }\r\n            }\r\n        }\r\n        // 返回查找结果\r\n        return rt;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433295829","body":"//思路inc栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val\n```java\nclass Solution{\n    class CustomStack {\n        int maxSize;\n        int [] stk;\n        int top;\n\n        public CustomStack(int maxSize) {\n            this.maxSize = maxSize;\n            stk = new int[maxSize];\n            top = -1;\n        }\n        \n        public void push(int x) {\n            if(top<maxSize-1){\n                stk[++top]=x;\n            }\n        }\n        \n        public int pop() {\n            if(top<=0){\n                return -1;\n            }else{\n                int res = stack[top];\n                top--;\n                return res;\n            }\n        }\n        \n        public void increment(int k, int val) {\n            int l = Math.min(k,top+1);//1 <= maxSize, x, k <= 1000 \n            for(int i =0;i<l;i++){\n                stk[i] = stk[i]+val;\n            }\n        }\n    }\n} \n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434842640","body":"```java\n//思路 首先定义2个指针来解开括号\n//left找到左括号【\n//right找到对应的右】  需要用到栈,否则搞不开\n//找到前面的系数 numleft numright\n//递归\n\nimport java.util.Stack;\n\npublic class _394字符串解码 {\n    public String decodeString(String s) {\n        int left = 0 , right = 0;\n        char[] arr = s.toCharArray();\n        //left找到左括号【\n        for (int i = 0; i < s.length(); i++) {\n            if(arr[i]=='['){\n                left=i;\n            }\n        }\n        //right找1对应的】\n        Stack<Character> stk = new Stack<>();\n        for (int i = left+1; i < arr.length; i++) {\n            if(arr[i]=='['){//找到第2..个【 入栈\n                stk.push(arr[i]);\n            }else if(arr[i]==']'&&stk.isEmpty()){\n                right=i;//找到1对应的右】\n                break;\n            }\n            else if(arr[i]==']'&&!stk.isEmpty()){\n                stk.pop();\n            }\n        }\n        int numLeft = left -1,numRight = left -1;\n        while (numLeft>=0&&arr[numLeft]>='0'&&arr[numLeft]<='9'){//不越界且数字\n            numLeft--;//-1\n        }\n        //取出系数\n        int times = Integer.parseInt(s.substring(numLeft+1,numRight+1));//-1+1,右开\n        String sub = s.substring(left + 1, right);//被乘串\n        StringBuffer sb = new StringBuffer();//用来拼串\n        sb.append(s.substring(0,numLeft+1));\n        while (times>0){\n            sb.append(sub);\n            times--;\n        }\n        sb.append(s.substring(right+1));\n        return decodeString(sb.toString());\n    }\n\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435675661","body":"```java\n//思路2个栈 模拟队列\npublic class _232用栈实现队列 {\n        private Stack<Integer> inStack;\n        private Stack<Integer> outStack;\n        public _232用栈实现队列() {\n                inStack = new Stack<>();\n                outStack= new Stack<>();\n        }\n\n        public void push(int x) {\n                inStack.push(x);\n        }\n\n        public int pop() {\n                if(outStack.isEmpty()){\n                        while (!inStack.isEmpty()){\n                                outStack.push(inStack.pop());\n                        }\n                }\n                return  outStack.pop();\n        }\n\n        public int peek() {\n                int rt = this.pop();\n                outStack.push(rt);\n                return rt;\n        }\n\n        public boolean empty() {\n                return inStack.isEmpty()&& outStack.isEmpty();\n        }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436024133","body":"```java\n//思路子数组中的最大值小于后面未排序部分的最小值\npublic class _768最多能完成排序的块II {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        int last_pop = -1;\n        for (int i = 0; i < arr.length; i++) {\n            int num = arr[i];\n            if (stack.empty() || num >= stack.peek()) {\n                // 可以将栈中所有小于num的元素弹出\n                while (!stack.empty() && num < stack.peek()) {\n                    stack.pop();\n                }\n                last_pop = i;\n            }\n            stack.push(num);\n        }\n        // 如果栈中还有元素，它们组成的子数组也可以被单独排序\n        return arr.length - (last_pop + 1);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1438595335","body":"```java\r\n//思路：1.头部 head【0】和尾部head【head.length-1】相连拼成环形链表\r\n//     2.定义一个指针p1,p2指向head【head.length-1】，head[0]链表右移就是指针左移k个位置\r\n// if(k<head.length-1)  位置为head.length-1-k\r\n//if(k>head.length-1)   位置为head.length-1-k%(head.length-1)\r\npublic class _61旋转链表 {\r\n    public ListNode rotateRight(ListNode head,int k) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n\r\n        int n = 1;\r\n\r\n        ListNode tail = head;\r\n\r\n        while (tail.next != null) {\r\n            n++;\r\n            tail = tail.next;\r\n        }\r\n\r\n        tail.next = head;//首位相连\r\n        k=k%n;\r\n\r\n        ListNode new_tail = head;\r\n        for (int i = 0; i < n - 1 - k; i++) {//新尾点\r\n            new_tail = new_tail.next;\r\n        }\r\n        ListNode new_head = new_tail.next;//新头\r\n        new_tail.next=null;\r\n        return new_head;\r\n\r\n\r\n    }\r\n\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437259096","body":"明天看\npublic ListNode rotateRight(ListNode head, int k) {\n    if (head == null) {\n        return null;\n    }\n    int n = 1; // n表示链表的长度，初始值为1，因为head不为空\n    ListNode tail = head; // tail表示链表的尾节点，初始值为head\n    while (tail.next != null) { // 遍历链表，找到尾节点和链表长度\n        n++;\n        tail = tail.next;\n    }\n    tail.next = head; // 首尾相连，形成环形链表\n    k %= n; // 将k对n取余，简化处理k>=n的情况\n    if (k > 0) {\n        ListNode new_tail = head; // 找到新链表的尾节点\n        for (int i = 0; i < n-k-1; i++) { // 双指针寻找新链表的尾节点\n            new_tail = new_tail.next;\n        }\n        ListNode new_head = new_tail.next; // 找到新链表的头节点\n        new_tail.next = null; // 断开环形链表，使新链表成为单向链表\n        return new_head;\n    } else { // 如果k等于0，链表不需要旋转，直接返回原链表\n        return head;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440305218","body":"```java\npublic class _109有序链表转换二叉搜索树 {\n\n    public TreeNode sortedListToBST(ListNode head) {\n        //链表为空\n        if (head == null) {\n            return null;\n        }\n        //只有一个节点\n        if (head.next == null) {\n            return new TreeNode(head.val);\n        }\n        ListNode slow = head, fast = head, prev = null;\n\n        // 快慢指针找到链表的中间节点\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        // 以中间节点作为根节点构建二叉搜索树\n        TreeNode root = new TreeNode(slow.val);\n        prev.next = null; // 断开链表\n        root.left = sortedListToBST(head); // 递归构建左子树\n        root.right = sortedListToBST(slow.next); // 递归构建右子树\n        return root;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"954545647":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428935968","body":"### 思路\n\n逐位相加，从最后一位开始加起来，需要额外考虑剩余 1 的情况\n\n### 代码\n\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  let i = num.length - 1;\n  let res = [];\n  let carry = 0;\n  while (i >= 0 || k !== 0) {\n    const a = i >= 0 ? num[i] : 0;\n    const b = k !== 0 ? k % 10 : 0;\n    const sum = a + b + carry;\n    carry = sum >= 10 ? 1 : 0;\n    res.push(sum % 10);\n    // 更新边界条件\n    k = Math.floor(k / 10);\n    i--;\n  }\n  if (carry) res.push(carry);\n  return res.reverse();\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430709353","body":"### 思路\n\n先记录 S 中存在字符 C 的位置，然后二次 for 循环去遍历\n\n### 代码\n\n```javascript\nvar shortestToChar = function (S, C) {\n  // 记录 C 字符在 S 字符串中出现的所有下标\n  var hasCArr = [];\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) hasCArr.push(i);\n  }\n\n  // 结果数组 res\n  var res = Array(S.length).fill(Infinity);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) {\n      res[i] = 0;\n      continue;\n    }\n\n    // 非目标字符，到下标数组中找最近的下标\n    for (const cIndex of hasCArr) {\n      const dist = Math.abs(cIndex - i);\n      if (dist >= res[i]) break;\n      res[i] = dist;\n    }\n  }\n  return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432293551","body":"### 思路\r\n\r\n根据要求写代码\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.list = [];\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  const len = this.list.length;\r\n  if (len >= this.maxSize) return;\r\n  this.list.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  const len = this.list.length;\r\n  if (len === 0) return -1;\r\n  return this.list.pop();\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  const maxVal = Math.min(k, this.list.length);\r\n  for (let i = 0; i < maxVal; i++) {\r\n    this.list[i] += val;\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：push、pop：O(1) increment:O(N)。\r\n- 空间复杂度：O(maxSize)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1433935706","body":"### 思路\n\n利用辅助栈的思路，遇到【 入栈，遇到 】出栈\n\n### 代码\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\n\n// 输入：s = \"3[a]2[bc]\"\n// 输出：\"aaabcbc\"\n// 输入：s = \"3[a2[c]]\"\n// 输出：\"accaccacc\"\n// 输入：s = \"abc3[cd]xyz\"\n// 输出：\"abccdcdcdxyz\"\nvar decodeString = function (s) {\n  const temp = [];\n  let res = '';\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    const cur = s[i];\n    // 数字类型\n    if (Number.isInteger(Number(cur))) {\n      count = Number(count + cur);\n      continue;\n      // 分界线\n    } else if (cur === '[') {\n      temp.push([res, count]);\n      res = '';\n      count = 0;\n      continue;\n    } else if (cur === ']') {\n      const [str, count] = temp.pop();\n      const val = res.repeat(count);\n      res = str + val;\n      continue;\n    } else {\n      res += cur;\n    }\n  }\n  return res;\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435690072","body":"\n### 代码\n\n```js\nvar MyQueue = function() {\n  this.list = [];\n  this.help = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.list.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n   // 这里要多加一层判断的原因是辅助栈的元素需要先处理\n  if(!this.help.length)  { \n    while(this.list.length){\n      this.help.push(this.list.pop());\n    }\n  }\n  return this.help.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  if(!this.help.length)  {\n    while(this.list.length){\n      this.help.push(this.list.pop());\n    }\n  }\n  return this.help[this.help.length-1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return !this.list.length && !this.help.length;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435809463","body":"### 思路\n计数思维，排序后的数组和乱序的合是一样的\n\n### 代码\n\n```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n  const newArr = [...arr].sort((a, b) => a - b);\n  // 滑动窗口\n  let res = 0;\n  let sum1 = 0;\n  let sum2 = 0;\n  for (let i = 0; i < newArr.length; i++) {\n    let cur = arr[i];\n    let newCur = newArr[i];\n    sum1 += cur;\n    sum2 += newCur;\n    if (sum1 === sum2) {\n      res++;\n    }\n  }\n  return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(NlogN) 排序时间\n- 空间复杂度：O(N) 数组长度\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436157087","body":"### 思路\n\n暴力解法：先计算链表长度\n\n### 代码\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n  if (!head || !head.next) return head;\n  let length = 0;\n  let temp = head;\n  // 计算链表长度\n  while (temp) {\n    temp = temp.next;\n    ++length;\n  }\n  // 优化旋转个数\n  k = k % length;\n  if (k === 0) return head;\n  let slow = (fast = head);\n  // 快慢指针，找到倒数第K个元素\n  while (fast.next) {\n    if (k-- <= 0) {\n      slow = slow.next;\n    }\n    fast = fast.next;\n  }\n  fast.next = head;\n  // 第K+1个元素先暂存\n  let res = slow.next;\n  slow.next = null;\n  return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437707373","body":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function (head) {\n  if (!head || !head.next) return head;\n  let dummy = new ListNode(0);\n  dummy.next = head; // preHead\n  let help = head;\n  let res = head.next; // 返回的结果\n  while (help && help.next) {\n    let nextNode = help.next;\n    let nnNode = nextNode.next;\n    help.next = nnNode;\n    nextNode.next = help;\n    dummy.next = nextNode;\n    dummy = help;\n    help = nnNode;\n  }\n  return res;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439279835","body":"### 思路\n用快慢指针\n\n### 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function (head) {\n  if (!head) return head;\n  return dfs(head, null);\n};\n\nfunction dfs(head, tail) {\n  if (head == tail) return null;\n  let fast = head;\n  let slow = head;\n  while (fast !== tail && fast.next !== tail) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  let root = new TreeNode(slow.val);\n  root.left = dfs(head, slow);\n  root.right = dfs(slow.next, tail);\n  return root;\n}\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：nLogN\n- 空间复杂度：logN","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441077340","body":"### 思路\n\n哈希法：\n因为两个链表会有交点，所以可以先让第一个链表做一个标记，然后再去遍历第二个链表\n\n### 代码\n\n```javascript\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function (headA, headB) {\n  while (headA) {\n    headA.flag = true;\n    headA = headA.next;\n  }\n  while (headB) {\n    if (headB.flag) return headB;\n    headB = headB.next;\n  }\n  return null;\n};\n\n// 或者可以使用数组\nvar getIntersectionNode = function (headA, headB) {\n  let data = new Set();\n  while (headA) {\n    data.push(headA);\n    headA = headA.next;\n  }\n  while (headB) {\n    if (data.has(headB)) return headB;\n    headB = headB.next;\n  }\n  return null;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1541732340":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"michaelxi3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darknightwriter":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"findlayzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuwf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lbc546":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zch-bit":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frankelzeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhaodev":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joeymoso":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hackbl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiyishuoshuo":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429017592","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        //用LinkedList不断从头将位数和加入index 0\n        List<Integer> res = new LinkedList<>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; i--) {\n            //从末尾往前扫，加和取余的值\n            res.add(0, (num[i] + k) % 10);\n            //更新k存进位carry\n            k = (num[i] + k) / 10;\n        }\n\n        // post-possing: 处理k位数大于num的情况剩下的部分\n        // Time = O(log(k))\n        while (k > 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aouos":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wengzhouyunfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whisht":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzzkains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenmengyu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uancen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuomituxedo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongranherz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gr52":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hydelovegood":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nikojxie":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429253540","body":"### 思路：\r\n逐位相加 进位+1\r\n\r\n### 代码：\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n  const result = []\r\n  let index = num.length - 1, overTen = false, current = 0\r\n  while(index >=0 || k > 0 || overTen) {\r\n    current = (num[index] || 0) + (k % 10 || 0) + overTen\r\n    result.unshift(current % 10)\r\n    index--\r\n    k = Math.floor(k / 10)\r\n    overTen = current >= 10\r\n  }\r\n  return result\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430684438","body":"### 思路\n遍历每一个字符，再用两个指针同时遍历其左右的字符，找到就退出循环\n\n### 代码\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n  const answer = new Array(s.length)\n  for(let index = 0; index < s.length; index ++) {\n    const str = s[index]\n    let left = index, right = index + 1\n    while(left >= 0 || right < s.length) {\n      if(s[left] === c) {\n        answer[index] = index - left\n        break\n      }\n      if(s[right] === c) {\n        answer[index] = right - index\n        break\n      }\n      left --\n      right ++\n    }\n  }\n  return answer\n};\n```\n\n### 复杂度\n- 时间复杂度： O(n^2)\n- 空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432557533","body":"### 思路\n定义一个数组和一个maxSize，push和pop时判断边界，increament时遍历加value\n\n### 代码\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.stack = []\n  this.size = maxSize\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if(this.stack.length < this.size) {\n    this.stack.push(x)\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if(this.stack.length) {\n    return this.stack.pop()\n  }\n  return -1\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  k = Math.min(k, this.stack.length)\n  for(let i = 0; i < k; i++) {\n    this.stack[i] += val\n  }\n};\n\n```\n\n### 复杂度\n- 时间复杂度：O(min(k, size))\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441168830","body":"### 思路\r\na链表.length + b链表.length === b链表.length + a链表.length，如果有相交，在中间一定会相遇\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let a = headA, b = headB\r\n    while(a != b) {\r\n      a = a ? a.next : headB\r\n      b = b ? b.next : headA\r\n    }\r\n    return a\r\n};\r\n```\r\n\r\n### 复杂度\r\n- 时间复杂度 O(m+n) m,n分别为两个链表的长度\r\n- 空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fangxianshen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jokertzw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyang258":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kernelsue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erikahuang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuang-mou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iloveqier":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429027822","body":"# 思路\n\t原地计算 数组num倒序加上k的和的余数作为num的每一位 循环中k/10参与下一次计算 将num放到list中 对于k的长度大于num长度的 继续将k剩余的长度一次添加到list头的位置上  \n# 算法复杂度\n\t时间复杂度 O(max(n,log k)) 空间复杂度O(max(n,log k)) n为数组长度 k为参数k\n# 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new ArrayList<>();\n        int carry = k;\n        for (int i = num.length - 1; i >= 0&&carry != 0; i--) {\n            int sum = num[i] + carry;\n            carry = sum / 10;\n            num[i]=sum%10;\n        }\n        for(int i:num){\n            ans.add(i);\n        }\n        while (carry > 0) {\n            ans.add(0, carry % 10);\n            carry = carry / 10;\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430646933","body":"# 思路\n\t一次遍历 回头赋值\n# 复杂度\n\t时间复杂度 O(n) 空间复杂度 O(1)\n# 代码\n```java\nclass Solution {\n    public static int[] shortestToChar(String s, char c) {\n        int index = s.length(), i = -1;\n        int[] ans = new int[s.length()];\n        for (char a : s.toCharArray()) {\n            i++;\n            if (a == c) {\n                //当前下标的字母为标记字母\n                ans[i] = 0;\n                int k = i;\n                index = i;\n                //向前遍历 直到数组中某位的值＜当前位置和该值下标的差\n                while (k >= 1 && ans[--k] > i - k) {\n                    ans[k] = i - k;\n                }\n            }\n            ans[i] = Math.abs(i - index);\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432667078","body":"# 思路\n\t使用额外的数组存储increment需要增加的值和下标，在输出的时候增加这个值\n# 复杂度\n\t时间复杂度O(1) 空间复杂度O(maxSize)\n# 代码\n```java\nclass CustomStack {\n        int[] ans;\n        int index = 0;\n        int[] incres;\n\n        public CustomStack(int maxSize) {\n            ans = new int[maxSize];\n            incres = new int[maxSize];\n        }\n\n        public void push(int x) {\n            if (index < ans.length) {\n                ans[index++] = x;\n            }\n\n        }\n\n        public int pop() {\n            if (index <= 0) {\n                return -1;\n            }\n            int k = ans[--index] + incres[index];\n            if (index > 0) {\n                incres[index - 1] += incres[index];\n            }\n            incres[index] = 0;\n            return k;\n        }\n\n        public void increment(int k, int val) {\n            int temp = Math.min(k-1 , index - 1);\n            if(temp<0){\n                return;\n            }\n            incres[temp] += val;\n        }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434227801","body":"# 思路\n\t双栈 数字栈存储每一层的数字 字符串栈存储每一层外层的字符串 左括号储存 右括号取数并拼接\n# 复杂度\n\t时间复杂度 O(n) 空间复杂度O(n)\n# 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<Integer> numberDeque = new LinkedList<>();\n        Deque<String> stringDeque = new LinkedList<>();\n        StringBuilder stringBuilder = new StringBuilder();\n\n        int number = 0;\n        for (char c : s.toCharArray()) {\n            if (c == ']') {\n                StringBuilder temp = new StringBuilder();\n                temp.append(String.valueOf(stringBuilder).repeat(numberDeque.pop()));\n                stringBuilder = temp.insert(0, stringDeque.pop());\n            } else if (c == '[') {\n                numberDeque.push(number);\n                stringDeque.push(stringBuilder.toString());\n                number = 0;\n                stringBuilder = new StringBuilder();\n            } else if (c >= '0' && c <= '9') {\n                number = number * 10 + (c - '0');\n            } else {\n                stringBuilder.append(c);\n            }\n        }\n        return stringBuilder.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435645468","body":"\n# 思路\n\t双栈 head存栈 tail出栈 当tail为空的时候 将head依次出栈 tail入栈 \n\t每个元素最多只会执行两次入栈 两次出栈的操作 \n# 复杂度\n\t时间复杂度 平均O(1) 空间复杂度O(n)\n# 代码\n ```java\n class MyQueue {\n        Deque<Integer> head;\n        Deque<Integer> tail;\n        \n        public MyQueue() {\n            head = new LinkedList<>();\n            tail = new LinkedList<>();\n        }\n\n        public void push(int x) {\n            tail.push(x);\n        }\n\n        public int pop() {\n            if (tail.isEmpty()) {\n                switchStack();\n            }\n            return tail.pop();\n        }\n\n        public int peek() {\n            if (tail.isEmpty()) {\n                switchStack();\n            }\n            return tail.peek();\n        }\n\n        private void switchStack() {\n            while (!head.isEmpty()) {\n                tail.push(head.pop());\n            }\n        }\n\n        public boolean empty() {\n            return tail.isEmpty() && head.isEmpty();\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435866814","body":"# 思路\r\n\t单调栈 大于栈顶的值入栈 小于栈顶的值 出栈 直到栈顶的值大于当前值或栈空 \r\n# 复杂度\r\n\t时间复杂度O(n) 空间复杂度O(n)\r\n# 代码\r\n```java\r\npublic static int maxChunksToSorted(int[] arr) {\r\n        int[] stack = new int[arr.length];\r\n        int index = 0;\r\n        stack[index] = arr[0];\r\n        for (int i = 1; i < arr.length; i++) {\r\n            if (stack[index] > arr[i]) {\r\n                int k = stack[index];\r\n                while (index >= 0 && stack[index] > arr[i]) {\r\n                    k = Math.max(stack[index--], k);\r\n                }\r\n                stack[++index] = k;\r\n            } else {\r\n                stack[++index] = arr[i];\r\n            }\r\n        }\r\n        return index + 1;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436195573","body":"# 思路\n\t成环再拆环\n# 复杂度\n\t时间复杂度O(n) 空间复杂度O(1)\n# 代码\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null||k==0){\n            return head;\n        }\n        ListNode tail  = head,temp = head;\n        int length = 1;\n        while(tail.next!=null){\n            tail = tail.next;\n            length++;\n        }\n        tail.next = head;\n        tail = tail.next;\n        k = length - k % length;\n        for(int i=0;i<k;i++){\n            temp = tail;\n            tail = tail.next;\n        }\n        temp.next=null;\n        return tail;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437773221","body":"# 思路\n  迭代 每次向后遍历两位 交换他们的位置\n# 复杂度\n  时间复杂度 O(n) 空间复杂度O(1)\n\n\n# 代码\n```java\nclass Solution {\n    public static ListNode swapPairs(ListNode head) {\n        ListNode temp = new ListNode(0,head);\n        ListNode ans = temp;\n        while(head!=null&&head.next!=null){\n            temp.next = temp.next.next;\n            head.next = head.next.next;\n            temp.next.next = head;\n            head = head.next;\n            temp = temp.next.next;\n        }\n        return ans.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440218853","body":"# 思路\n\t查找中间节点作为树的根节点，再对左右两边的链表分别建树\n\n# 复杂度\n\t时间复杂度O(n) 空间复杂度O(n)\n# 代码\n```java\nclass Solution {\n      public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441284097","body":"# 思路\n\t先计算两个链表的长度 再将长链表长的头截去 再依次判断后续节点是否相同\n# 复杂度\n\t时间复杂度O(m+n) 空间复杂度 O(1)\n# 代码\n```java\n\tpublic class Solution {\n        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n            ListNode planA = headA, planB = headB;\n            int lengthA = 0, lengthB = 0;\n            while (planA != null) {\n                lengthA++;\n                planA = planA.next;\n            }\n            while (planB != null) {\n                lengthB++;\n                planB = planB.next;\n            }\n            planA = headA;\n            planB = headB;\n            if (lengthA > lengthB) {\n                for (int i = 0; i < lengthA - lengthB; i++) {\n                    planA = planA.next;\n                }\n            } else {\n                for (int i = 0; i < lengthB - lengthA; i++) {\n                    planB = planB.next;\n                }\n            }\n            while (planA != null) {\n                if (planA == planB) {\n                    return planA;\n                } else {\n                    planA = planA.next;\n                    planB = planB.next;\n                }\n            }\n            return null;\n        }\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ashleyyma6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuki-yzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpc7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yujian920":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kiirii4":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ucashurui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heng518":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tlntin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richypang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fenchuiyun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry-lllman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nickyk319":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"herbertpan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsmmxmm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fan-svg":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzejia":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunnyyujf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"phoenixflyingsky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nehchsuy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzyxts":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elainekuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ll491119940":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"2learnsomething":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ataraxyadong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzasd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miluowzt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maylinglin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weijie-he":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brodxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y525":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429156559","body":"- Time: $O(N)$ N is the length of the input array\r\n- Space: $O(1)$ No extra space is used except the returned array.\r\n\r\n```typescript\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    const res = Array(num.length);\r\n\r\n    for (let read = num.length - 1, write = 0; read >= 0; read--, write++) {\r\n        res[write] = (num[read] + k) % 10;\r\n        k = ((num[read] + k) / 10) >> 0;\r\n    }\r\n\r\n    while (k > 0) {\r\n        res.push(k % 10);\r\n        k = (k / 10) >> 0;\r\n    }\r\n\r\n    res.reverse();\r\n    return res;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1432547572","body":"- Time: $O(N)$\r\n- Space: $O(N)$\r\n```tsx\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    const dist = Array(s.length).fill(0);\r\n\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) dist[i] = 0;\r\n        else dist[i] = (dist[i - 1] ?? Infinity) + 1;\r\n    }\r\n\r\n    for (let i = s.length - 2; i >= 0; i--) {\r\n        dist[i] = Math.min(dist[i], dist[i + 1] + 1);\r\n    }\r\n\r\n    return dist;\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432600245","body":"|operation|Time|Space|\r\n|-|-|-|\r\n|`push`|$O(1)$|$O(1)$|\r\n|`pop`|$O(1)$|$O(1)$|\r\n|`increment`|$O(1)$|$O(1)$|\r\n\r\n```tsx\r\nclass CustomStack {\r\n  private maxSize_: number;\r\n  private top_: number = -1;\r\n  private nums_: number[];\r\n  private inc_: number[];\r\n  constructor(maxSize: number) {\r\n    this.maxSize_ = maxSize;\r\n    this.nums_ = Array(maxSize);\r\n    this.inc_ = Array(maxSize).fill(0);\r\n  }\r\n\r\n  push(x: number): void {\r\n    if (this.top_ === this.maxSize_ - 1) return;\r\n    this.nums_[++this.top_] = x;\r\n  }\r\n\r\n  pop(): number {\r\n    if (this.top_ < 0) return -1;\r\n\r\n    const num = this.nums_[this.top_];\r\n    const inc = this.inc_[this.top_];\r\n    this.inc_[this.top_ - 1] += inc;\r\n    this.inc_[this.top_] = 0;\r\n    this.top_--;\r\n\r\n    return num + inc;\r\n  }\r\n\r\n  increment(k: number, val: number): void {\r\n    k = Math.min(k - 1, this.top_);\r\n    if (k < 0) return;\r\n    this.inc_[k] += val;\r\n  }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434252684","body":"- Time: $O(N)$, where N is the length of the input string.\r\n- Space: $O(S)$, where S is the length of the decoded string.\r\n\r\n```tsx\r\nfunction top<T>(stk: T[]): T {\r\n    return stk[stk.length - 1];\r\n}\r\n  \r\nfunction decodeString(s: string): string {\r\n    const stack: string[] = [];\r\n  \r\n    for (let i = 0; i < s.length; i++) {\r\n      if (s[i] !== ']') {\r\n        stack.push(s[i]);\r\n        continue;\r\n      }\r\n  \r\n      let pattern = '';\r\n      let times = '';\r\n      while (stack.length && top(stack) !== '[') {\r\n        pattern = stack.pop() + pattern;\r\n      }\r\n  \r\n      if (top(stack) === '[') {\r\n        stack.pop();\r\n  \r\n        while (stack.length && /[0-9]/.test(top(stack))) {\r\n          times = stack.pop() + times;\r\n        }\r\n      }\r\n  \r\n      stack.push(pattern.repeat(parseInt(times)));\r\n    }\r\n  \r\n    return stack.join('');\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1436318491","body":"- Time: push $O(1)$, pop, peek $O(1)$ on average\r\n- Space: $O(N)$\r\n\r\n```tsx\r\nclass MyQueue {\r\n    private _readStack: number[] = [];\r\n    private _writeStack: number[] = [];\r\n\r\n    constructor() {}\r\n\r\n    push(x: number): void {\r\n        this._writeStack.push(x);\r\n    }\r\n\r\n    pop(): number {\r\n        if (this.empty()) return -1;\r\n        if (!this._readStack.length) this._pour();\r\n        return this._readStack.pop()!;\r\n    }\r\n\r\n    peek(): number {\r\n        if (!this._readStack.length) this._pour();\r\n        return this._readStack[this._readStack.length - 1];\r\n    }\r\n\r\n    empty(): boolean {\r\n        return this._writeStack.length === 0 && this._readStack.length === 0;\r\n    }\r\n\r\n    _pour(): void {\r\n        while (this._writeStack.length)\r\n            this._readStack.push(this._writeStack.pop()!);\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436331511","body":"- Time: $O(N)$\r\n- Space: $O(N)$\r\n```tsx\r\nfunction peek<T>(arr: T[]): T {\r\n  return arr[arr.length - 1];\r\n}\r\n\r\nfunction maxChunksToSorted(arr: number[]): number {\r\n  const stk: number[] = [];\r\n\r\n  for (let num of arr) {\r\n    const maxInChunk = Math.max(peek(stk) ?? num, num);\r\n\r\n    while (stk.length > 0 && peek(stk) > num) {\r\n      stk.pop();\r\n    }\r\n\r\n    stk.push(maxInChunk);\r\n  }\r\n\r\n  return stk.length;\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436336096","body":"- Time: $O(N)$\r\n- Space: $O(1)$\r\n```tsx\r\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\r\n    if (!head) return null;\r\n\r\n    let len = 1;\r\n    let p = head;\r\n\r\n    while (p.next) {\r\n        p = p.next;\r\n        len++;\r\n    }\r\n\r\n    p.next = head;\r\n    k %= len;\r\n    k = len - k;\r\n\r\n    while (k--) {\r\n        p = p.next;\r\n    }\r\n\r\n    const rotatedHead = p.next;\r\n    p.next = null;\r\n    return rotatedHead;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437811498","body":"- Time: $O(N)$\r\n- Space: $O(N)$\r\n```tsx\r\nfunction swapPairs(head: ListNode | null): ListNode | null {\r\n    if (!head || !head.next) return head;\r\n    const rest = swapPairs(head.next.next);\r\n    const [first, second] = [head, head.next];\r\n    first.next = rest;\r\n    second.next = first;\r\n    return second;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439378192","body":"- Time: $O(N)$\r\n- Space: $O(h)$\r\n```tsx\r\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\r\n  if (!head) return null;\r\n\r\n  let p: ListNode | null = head;\r\n  let len = 0;\r\n  while (p !== null) {\r\n    p = p.next;\r\n    len++;\r\n  }\r\n\r\n  function inorder(start: number, end: number): TreeNode | null {\r\n    if (start > end || !head) return null;\r\n    const mid = (((end - start + 1) / 2) >> 0) + start;\r\n\r\n    const root = new TreeNode();\r\n    root.left = inorder(start, mid - 1);\r\n    root.val = head.val;\r\n    head = head.next;\r\n    root.right = inorder(mid + 1, end);\r\n    return root;\r\n  }\r\n\r\n  return inorder(0, len - 1);\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mirrors-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jakkiabc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyoneday":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429672378","body":"## 代码\r\n\r\n```js\r\nvar addToArrayForm = function (num, K) {\r\n    const len = num.length || 0;\r\n    let numK = K;\r\n    const result = [];\r\n\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        const a = num[i];\r\n        const b = numK % 10;\r\n       \r\n        let total = a + b;\r\n        numK = total >= 10 ? parseInt(numK / 10) + 1 : parseInt(numK / 10);\r\n        result[i] = total % 10;\r\n    }\r\n    while (numK > 0) {\r\n        result.unshift(numK % 10);\r\n        numK = parseInt(numK / 10);\r\n    }\r\n\r\n    return result;\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431427337","body":"## 代码\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n  const tempArr = [];\r\n  const len = s.length;\r\n  let idx = -1;\r\n  for (let i = 0; i < len; i++) {\r\n    if (s[i] === c) {\r\n      idx = i;\r\n      tempArr[i] = 0;\r\n    } else if (idx === -1) {\r\n      tempArr[i] = Infinity;\r\n    } else {\r\n      tempArr[i] = i - idx;\r\n    }\r\n  }\r\n\r\n  idx = Infinity;\r\n  for (let i = len - 1; i > -1; i--) {\r\n    const val = tempArr[i];\r\n\r\n    if (s[i] === c) {\r\n      idx = i;\r\n    } else if (val > idx - i) {\r\n      tempArr[i] = idx - i ;\r\n    }\r\n  }\r\n\r\n  return tempArr;\r\n};\r\n```\r\n\r\n## 时间复杂度\r\n\r\n- 空间复杂度O(n)\r\n- 时间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433027322","body":"## 代码\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function(maxSize) {\r\n  this.stack = [];\r\n  this.size = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.stack.length < this.size) {\r\n    this.stack.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  if (this.stack.length === 0) {\r\n    return -1;\r\n  } else {    \r\n    return this.stack.pop();\r\n  }\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  const len = k > this.stack.length ? this.stack.length : k;\r\n  for (let i = 0; i < len; i++) {\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434662917","body":"## 代码\r\n\r\n```js\r\nvar decodeString = function(s) {\r\n    const stack = [];\r\n\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] !== ']') {\r\n            stack.push(s[i]);\r\n        } else {\r\n            let result = \"\";\r\n            let tempStr = \"\";\r\n            let num = \"\";\r\n            while (stack[stack.length - 1] !== '[') {\r\n                const c = stack.pop();\r\n                tempStr = c + tempStr;\r\n            }\r\n            stack.pop();\r\n            while (/\\d/.test(stack[stack.length - 1]) && stack.length >= 0) {\r\n                const n = stack.pop();\r\n                num = n + num;\r\n            }\r\n            \r\n            for (let i = 0; i < +num; i++) {\r\n                result += tempStr;\r\n            }\r\n\r\n            for (let j = 0; j < result.length; j++) {\r\n                stack.push(result[j]);\r\n            }\r\n        }\r\n    }\r\n    \r\n    return stack.join(\"\");\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435657520","body":"## 代码\r\n\r\n```js\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    const temStack = [];\r\n    const len = this.stack.length;\r\n    for (let i = 0; i < len; i++) {\r\n        temStack.push(this.stack.pop());\r\n    }\r\n    const res = temStack.pop();\r\n    const len2 = temStack.length;\r\n    for (let j = 0; j < len2; j++) {\r\n        this.stack.push(temStack.pop());\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    const temStack = [];\r\n    const len = this.stack.length;\r\n    for (let i = 0; i < len; i++) {\r\n        temStack.push(this.stack.pop());\r\n    }\r\n    const res = temStack[len - 1];\r\n    for (let j = 0; j < len; j++) {\r\n        this.stack.push(temStack.pop());\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack.length === 0;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435977644","body":"## 代码\r\n\r\n```js\r\nvar maxChunksToSorted = function (arr) {\r\n  const stack = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const lastMax = stack[stack.length - 1];\r\n    if (i === 0) {\r\n      stack.push(arr[i]);\r\n    } else if (arr[i] >= stack[stack.length - 1]) {\r\n      stack.push(arr[i]);\r\n    } else {\r\n      while (arr[i] < stack[stack.length - 1] && stack.length) {\r\n        stack.pop()\r\n      }\r\n      stack.push(lastMax)\r\n    }\r\n  }\r\n  return stack.length;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437030058","body":"## 代码\r\n\r\n```js\r\nvar rotateRight = function (head, k) {\r\n  if (!(head && head.next)) return head;\r\n  if (k === 0) return head;\r\n  let node = head;\r\n  const node4 = head;\r\n  let len = 1;\r\n  while (node.next) {\r\n    len++;\r\n    node = node.next\r\n  }\r\n\r\n    let newLen = k % len === 0 ? 0 : Math.abs(len - k % len);\r\n  if (newLen === 0) return node4;\r\n  while (newLen > 1) {\r\n    newLen--;\r\n    head = head.next;\r\n  }\r\n\r\n  let node3 = head.next;\r\n  head.next = null;\r\n  const node5 = node3;\r\n\r\n  while (node3 && node3.next) {\r\n    node3 = node3.next;\r\n  }\r\n  if (node3) {\r\n    node3.next = node4;\r\n  }\r\n \r\n  return node5;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438554299","body":"## 代码\r\n\r\n```js\r\nvar swapPairs = function(head) {\r\n    if (!head || !head.next) {\r\n        return head\r\n    }\r\n    let pre = head.next\r\n    let next = head\r\n    let tmp = pre.next\r\n    head = head.next\r\n    while (next.next) {\r\n        pre.next = next\r\n        next.next = tmp ? (tmp.next || tmp) : null\r\n        if (tmp) {\r\n            pre = tmp.next\r\n            next = tmp\r\n            tmp = pre ? pre.next : null\r\n        }\r\n    }\r\n    return head\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439984188","body":"## 代码\r\n\r\n```js\r\nvar sortedListToBST = function (head) {\r\n  if (!head) return null;\r\n  if (head && !head.next) {\r\n    return new TreeNode(head.val);\r\n  }\r\n\r\n\r\n  function buildTree(head, tail) {\r\n    if (head === tail) return null;\r\n    const mid = findMid(head, tail);\r\n   \r\n    const topNode = new TreeNode(mid.val);\r\n    topNode.left = buildTree(head, mid);;\r\n    topNode.right = buildTree(mid.next, tail);;\r\n    return topNode;\r\n  }\r\n\r\n  function findMid(head, tail) {\r\n    let slow = head;\r\n    let fast = head;\r\n  \r\n    while (fast !== tail && fast.next !== tail) {\r\n      slow = slow.next;\r\n      fast = fast.next.next;\r\n    }\r\n\r\n    return slow;\r\n  }\r\n\r\n  return buildTree(head, null);\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441144408","body":"## 代码\r\n\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let node1 = headA, node2 = headB;\r\n    while (node1 != node2) {\r\n        node1 = node1 ? node1.next : headB;\r\n        node2 = node2 ? node2.next : headA;\r\n    }\r\n    return node1;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chouqin99":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaogeg111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ye2222":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uyplayer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guixian001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junzmer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hx-code":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"admu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxiaomm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pgquestions":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eldinzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangwenzhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnwu6688":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomtao626":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aiweng1981":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richard-lime":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acoada":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duanyaqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429633422","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& nums, int k)\r\n    {\r\n        stack<int> data;\r\n        int tmp;\r\n        int flag = 0;\r\n        for(int i = nums.size() - 1; i > -1; i--)\r\n        {\r\n            tmp = nums[i];\r\n            if(k > 0)\r\n            {\r\n                tmp += k % 10;\r\n                k = k / 10;\r\n            }\r\n            tmp += flag;\r\n            data.push(tmp % 10);\r\n            flag = tmp / 10;\r\n        }\r\n        while(k > 0)\r\n        {\r\n            tmp = flag + k % 10;\r\n            k = k / 10;\r\n            data.push(tmp % 10);\r\n            flag = tmp / 10;\r\n        }\r\n        if(flag)\r\n            data.push(flag);\r\n        vector<int> res;\r\n        while(data.size())\r\n        {\r\n            res.push_back(data.top());\r\n            data.pop();\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431591552","body":"```\r\n###思路\r\n\r\n看解题思路，左右个遍历一次，分别记录距离，然后对比大小\r\n\r\n###代码\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int count = s.length();\r\n        int[] ans = new int[n];\r\n        Arrays.fill(ans, count + 1);\r\n        for (int i = 0, j = -1; i < count; i++) {\r\n            if (s.charAt(i) == c) j = i;\r\n            if (j != -1) ans[i] = i - j;\r\n        }\r\n        for (int i = count - 1, j = -1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) j = i;\r\n            if (j != -1) ans[i] = Math.min(ans[i], j - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n###复杂度分析\r\n\r\n时间复杂度 ：O(n)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433285487","body":"```\r\nclass CustomStack {\r\n\r\n    int[] arr;\r\n    int tail = -1;\r\n\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(tail == arr.length - 1) {\r\n            return;\r\n        }\r\n        arr[++tail] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(tail == -1) {\r\n            return -1;\r\n        }\r\n        return arr[tail--];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i = 0; i < Math.min(k, arr.length); i++) {\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434397904","body":"```\r\nfunction decodeString(s: string): string {\r\n  let numStack = [];\r\n  let strStack: string[] = [];\r\n  let num = 0;\r\n  let result = \"\";\r\n\r\n  for (const str of s) {\r\n    // 是数字\r\n    if (!isNaN(+str)) {\r\n      num = +(num + str);\r\n    } else if (str === \"[\") {\r\n      // 是[，就是字符重复的开始，所以将之前的记录存档\r\n      numStack.push(num);\r\n      num = 0;\r\n      strStack.push(result);\r\n      result = \"\";\r\n    } else if (str === \"]\") {\r\n      // 是]，就准备收口，返回重复后的字符\r\n      let report = numStack.pop();\r\n      result = strStack.pop() + result.repeat(report as number);\r\n    } else {\r\n      // 是字符串，就要拼接起来\r\n      result += str;\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435676973","body":"```\r\nclass MyQueue {\r\npublic:\r\n    stack<int> s1,s2;\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n       s1.push(x); \r\n    }\r\n    \r\n    int pop() {\r\n       while(!s1.empty()){\r\n       s2.push(s1.top());\r\n       s1.pop();\r\n       }\r\n       return(s2.top());\r\n       s2.pop();\r\n    }\r\n    \r\n    int peek() {\r\n        int p=s2.top();\r\n        return p;\r\n    }\r\n    \r\n    bool empty() {\r\n        if(!s1.empty()||!s2.empty())\r\n        return false;\r\n        else return true;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437232291","body":"```\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(head==NULL)\r\n            return NULL;\r\n        ListNode* temp = head;\r\n        int len = 1;\r\n        while(temp->next!=NULL)\r\n        {    \r\n            temp = temp->next;\r\n            ++len;\r\n        }\r\n        temp->next = head;\r\n        int step = len - k%len;\r\n        while(--step)\r\n            head = head->next;\r\n        temp = head->next;\r\n        head->next = NULL;\r\n        return temp;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438704053","body":"```\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        if head is None or head.next is None: return head\r\n        start, end, len = head, None, 0\r\n        while head:\r\n            end = head\r\n            head = head.next\r\n            len += 1\r\n        end.next = start\r\n        pos = len - k % len\r\n        while pos > 1:\r\n            start = start.next\r\n            pos -= 1\r\n        ret = start.next\r\n        start.next = None\r\n        return ret\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440251594","body":"```\r\nclass Solution:\r\n    def divideConquer(self, segment: Optional[ListNode], length: int) -> Optional[TreeNode]:\r\n        if not segment: return\r\n        if not segment.next: return TreeNode(segment.val)\r\n        # find the middle node to divide and conquer\r\n        prev, middle = segment, segment.next\r\n        for _ in range(length//2-1):\r\n            prev, middle =  prev.next, middle.next \r\n        # divide and conquer\r\n        prev.next = None\r\n        leftTree = self.divideConquer(segment, length//2)\r\n        rightTree = self.divideConquer(middle.next, length-length//2-1)\r\n        middle.next = None\r\n        return TreeNode(middle.val, leftTree, rightTree) \r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head: return\r\n        if not head.next: return TreeNode(head.val)\r\n        # Get the length of the linked list\r\n        length = 0\r\n        cur = head\r\n        while cur:\r\n            length += 1\r\n            cur = cur.next\r\n        return self.divideConquer(head, length)\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaiykk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cachezhou0617":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangtuo1999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cytrue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyryan-web":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429623057","body":"#### 解题思路\n  1. 低位到高位逐位将数字加在一起\n  2. 若加法的结果大于等于 1010，把进位的 11 加入到下一位的计算中\n\n\n#### 代码实现\n\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度: O(max(n,logk), 其中 nn 为数组的长度\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431493869","body":"#### 解题思路\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 C。\n- 如果只在一个方向找到，直接计算字符距离。\n- 如果两个方向都找到，取两个距离的最小值\n\n#### 代码实现\n\n```\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  const res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433182188","body":"### 思路\n  用数组模拟栈，用数组原生方法pop、push方法实现\n  \n### 代码\n\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length >= this.maxSize) {\n    return;\n  }\n  this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  return this.stack.length ? this.stack.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const length = Math.min(k, this.stack.length);\n  for (let i = 0; i < length; i++) {\n    this.stack[i] += val;\n  }\n};\n```\n### 复杂度\n- 时间复杂度 \n\n  push: O(1)\n\n  pop：O(1)\n  \n  increment：O(K) \n \n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434718608","body":"### 思路\n1. 将字符串从末尾开始遍历\n2. 遇到“]”入栈\n3. 拼接要出栈的字符串，遇到\"[\"出栈\n4. \"[\"后紧跟数据，累计最终的数字\n5. 将遍历后入栈的字符串出栈，进行反转拼接，得到最终结果\n\n### 代码\n\n```\n/**\n * @param {string} s\n * @return {string}\n */\n var decodeString = function(s) {\n    let stack = []; // 定义存储字符串的栈\n    let str = \"\"; // 定义最终返回的字符串\n    let num = \"\"; // 定义字符串重复的次数\n    const length = s.length;\n    for (let i = length - 1; i >= 0; i--) {\n      console.log(\"s[i]\", stack, i);\n      if (s[i] >= \"0\" && s[i] <= \"9\") {\n        // 解析出连续的数字\n        while (s[i] >= \"0\" && s[i] <= \"9\") {\n          num += s[i];\n          i--;\n          console.log(\"num\", num);\n        }\n        stack.push(\n          str.repeat(\n            Number(\n              num\n                .split(\"\")\n                .reverse()\n                .join(\"\")\n            )\n          )\n        ); // 拼接字符\n        str = \"\";\n        num = \"\"; //清空计数\n        i++;\n      } else if (s[i] === \"[\") {\n        // 遇到\"[\"时，将后续字符出栈\n        let curStr = stack.pop();\n        while (curStr !== \"]\") {\n          str += curStr;\n          curStr = stack.pop(); // 拼接出栈的字符串 \"[\"后跟着的一定是数字\n        }\n      } else {\n        // 将字符 或 \"]\"入栈\n        stack.push(s[i]);\n      }\n    }\n    return stack.reverse().join(\"\");\n  };\n```\n\n### 复杂度分析\n- 时间复杂度：O(n),循环遍历一遍\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435673074","body":"### 解题思路\n    定义两个栈，\n-   一个是pushStack, 执行push操作时，将元素入pushStack栈\n-   另一个是popStack,执行pop操作时，在popStack取元素；当popStack栈为空时，依次将pushStack元素pop取出，push进pushStack栈\n\n\n### 代码实现\n```\nvar MyQueue = function() {\n    this.pushStack = [];\n    this.popStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack[this.popStack.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.popStack.length === 0 && this.pushStack.length === 0;\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(1)$\n- 空间复杂度 $O(N)$, N为队列元素个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436018080","body":"#### 解题思路\n> 单调栈\n\n#### 代码实现\n\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    //定义最大数据栈\n    let res=[]\n    for(let i = 0; i < arr.length; i++) {\n        if(res.length==0){\n            res.push(arr[i])\n        }else{\n            if(arr[i]>=res[res.length-1]){\n                res.push(arr[i])\n            }else{\n                let max=res[res.length-1]\n                while(arr[i]<res[res.length-1]){\n                    res.pop()\n                }\n                res.push(max)\n            }\n        }\n    }\n    return res.length\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N)$，N为数组长度\n- 空间复杂度：$O(N)$，N为数组长度","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438685049","body":"\n### 解题思路\n1. 设置虚拟节点，定义pre指针，指向当前虚拟节点\n2. 当pre.next以及pre.next.next指针均不为空时，开始交换\n3. 令cur指针指向pre.next；next指针指向pre.next.next\n4. 交换过程如下：\n- pre.next = next\n- cur.next = next.next\n- next.next = cur\n- pre = cur\n\n### 代码实现\njavaScript\n\n```\nvar swapPairs = function(head) {\n    let dummyNode = new ListNode(0);\n    dummyNode.next = head;\n    let pre = dummyNode;\n    while(pre.next && pre.next.next) {\n        const cur = pre.next;\n        const next = pre.next.next;\n        pre.next = next;\n        cur.next = next.next;\n        next.next = cur;\n        pre = cur;\n    }\n    return dummyNode.next;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$, N为链表中节点数目\n- 空间复杂度 $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439928204","body":"### 解题思路\n    分治 \n### 代码实现\njavaScript\n\n```\nvar sortedListToBST = function(head) {\n  if(!head) return null;\n  let length = 0;\n  let current = head;\n  while(current){\n    current = current.next\n    length++\n  }\n\n  var buildBST = function(start, end){\n    if(start > end) return null;\n\n    const mid = start + ((end - start)>> 1)\n    const leftSide = buildBST(start, mid - 1);\n\n    const root = new TreeNode(head.val)\n    head = head.next;\n    root.left = leftSide\n\n    root.right = buildBST(mid+1, end)\n    return root;\n  }\n\n  return buildBST(0, length - 1)\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(logN)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnxizhao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"incipe-win":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"revisegoal":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckysq999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dereklisdr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"perfqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mryao1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"likeyousmile":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhg1992":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liquanluo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aq666888":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samlu-ecnu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongxiangxiang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hatorimain":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429112268","body":"# 解法思路1:\r\n\r\n这题本质上就像做加法一样。我们先用linkedlist来存结果，因为往链表头加一个数的操作是O(1)\r\n\r\n`num = [1,2,0,0], k = 34`\r\n\r\n可以当作 num的最后一位加了34。然后我们保留它的最后一位，也就是往我们的结果数组里面add一个(nums[i] + k) % 10。\r\n\r\n然后num[i - 1]的前面一位要进位。这个要进的位就是 34/10的结果。这里是3。\r\n\r\n然后我们一直进行这个操作直到遍历完整个数组。这里有个问题就是k本身的长度可能比num的数组长度大。所以如果k>0（说明k没加完）。我们继续把k % 10，结果加到res数组里。然后再k/10进位。\r\n\r\n## 注意要点：\r\n注意k可能本身的长度比num长。\r\n\r\n这道题空间复杂度是O(1)因为只有返回的数组占了空间复杂度。算法本身没有用任何辅助的数据结构。\r\n\r\n## 复杂度：\r\n\r\n时间：$O(n)$\r\n\r\n（O(k)，K是k的位数))\r\n\r\n空间：$O(1)$\r\n\r\n## 第一次自己写的代码：\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> tmp = new LinkedList<>();\r\n        for(int i = num.length - 1; i >= 0; i--) {\r\n            num[i] += k;\r\n            tmp.addFirst(num[i] % 10);\r\n            k = num[i] / 10;\r\n        }\r\n        while(k > 0) {\r\n            tmp.addFirst(k % 10);\r\n            k = k / 10;\r\n        } \r\n        List<Integer> res = new ArrayList<>(tmp);\r\n        return res;\r\n    \r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430140762","body":"# 解法思路1:\n\n## 注意要点：\n\n这题先指针从左扫到右，再从右扫到左，把初始index设成一个很大的负值（这里设了20000是因为长度最大值是10000）。这里不能设Integer.MIN_VALUE因为之后会overflow。  \n\n计算从左往右时每个字符到字符c的距离。遇到第一个之前距离都是非常大。\n\n扫完以后再从右往左扫，比较这个新的距离跟原来的距离哪个更小，这里注意index要设成一个正的很大的数，因为这样遇到第一个c之前右边的结果产生的数都会非常大，通过和原来的res[i]比较能得到正确的值。\n\n## 复杂度：\n\n时间：$O(n)$\n\n空间：$O(1)$\n\n两个for循环所以是O(n),开的数组只用来返回结果所以是O(1)\n\n## 第一次自己写的代码：\n\n```jsx\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        int index = -20000;\n        for(int i = 0; i < s.length(); i++) {\n            if(s.charAt(i) == c) index = i;\n            res[i] = i - index;\n        }\n        index = 20000;\n        for(int i = s.length() - 1; i >= 0; i--) {\n            if(s.charAt(i) == c) index = i;\n            res[i] = Math.min(index - i, res[i]);\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1431936045","body":"# 题目名\r\n\r\n链接：[https://leetcode.com/problems/design-a-stack-with-increment-operation/description/](https://leetcode.com/problems/design-a-stack-with-increment-operation/description/)\r\n\r\n# 解法思路1:\r\n\r\n一开始global声明一个stack和一个increment数组。\r\n\r\n用stack的好处是不用多加一个变量来记录栈现在的size，不容易出错。\r\n\r\nincrement数组用来记录增加前几个index范围的值。\r\n\r\n比如increment[2]用来增加index [0, 2]范围的值\r\n\r\n实现push操作很简单。就是栈当前的size只要小于maxSize，就push。\r\n\r\nincrement数组用来增加数组[0, k - 1]范围的值。\r\n\r\n如果increment(k, val)了。那么我们就让i = Math.min(k, stack.size()) - 1。\r\n\r\nincrement[i] += val\r\n\r\n如果这时i < 0，说明没有区间的值让我们增加，不操作。\r\n\r\npop的时候同理。我们弹出栈顶的值，此时i = stack.size() - 1。\r\n\r\n此时增量操作过的栈顶实际的值应该是 increment[i] + stack.pop()\r\n\r\n因为我们已经加上了increment[i]的值。所以increment[i]清零。\r\n\r\nincrement[i - 1] += increment[i];\r\n\r\n然后返回increment[i] + stack.pop()\r\n\r\n优化的话可以把increment用一个linkedlist来维护，这样remove和add的操作都是1.空间复杂度最多是当前stack的size。\r\n\r\n## 注意要点：\r\n\r\n感觉这题的思路挺简单的就是前缀和实现O(1)操作，但是实际写的时候各种边界出了很多bug还de不出来。\r\n\r\n## 复杂度：\r\n\r\n时间：$O(1)$\r\n\r\n空间：$O(stackSize/N)$\r\n\r\npop, push, increment本身时间复杂度是1，但是因为我们额外要维护一个increment链表，所以平均下来空间复杂度是O(cnt/N)\r\n\r\n## 第一次自己写的代码：\r\n\r\n```java\r\nclass CustomStack {\r\n\r\n    Stack<Integer> stack;\r\n    LinkedList<Integer> increment;\r\n    int maxSize;\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        stack = new Stack<Integer>();\r\n        increment = new LinkedList<Integer>();\r\n        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(stack.size() < this.maxSize) {\r\n            increment.add(0);\r\n            stack.push(x);\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        int i = stack.size() - 1;\r\n        if(i < 0) return -1;\r\n        if(i > 0)\r\n            increment.set(i - 1, increment.get(i) + increment.get(i - 1));\r\n        int res = increment.get(i) + stack.pop();\r\n        increment.remove(i);\r\n        return res; \r\n        \r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int i = Math.min(stack.size(), k) - 1;\r\n        if(i >= 0)\r\n            increment.set(i, increment.get(i) + val);\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434777533","body":"```jsx\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n\n        StringBuilder sb = new StringBuilder();\n\n        for(char c : s.toCharArray()) {\n            if(c == ']') {\n                StringBuilder repeatStr = new StringBuilder();\n                while(!stack.isEmpty() && stack.peek() != '[') {\n                    repeatStr.append(stack.pop());\n                }\n                stack.pop();\n                repeatStr = repeatStr.reverse();\n                int repeatCnt = 0;\n                int k = 1;\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                \n                    int n = stack.pop() - '0';\n                    repeatCnt = k * n + repeatCnt;\n        \n                    k = k * 10;\n                }\n                \n                for(int i = 0; i < repeatCnt; i++){\n                    for(int j = 0; j < repeatStr.length(); j++) {\n                        stack.push(repeatStr.charAt(j));\n                    }\n                }\n            }\n            else {\n                stack.push(c);\n            }\n        }\n        while(!stack.isEmpty()) {\n            sb.append(stack.pop());\n        }\n        return sb.reverse().toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435712719","body":"class MyQueue {\n\n    Stack<Integer> s1, s2;\n    public MyQueue() {\n        s1 = new Stack<>();\n        s2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        s1.push(x);\n    }\n    \n    public int pop() {\n        peek();\n        return s2.pop();\n    }\n    \n    public int peek() {\n        if(s2.isEmpty()){\n            while(!s1.isEmpty()){\n                s2.push(s1.pop());\n            }\n        }\n        return s2.peek();\n    }\n    \n    public boolean empty() {\n        return s2.isEmpty() && s1.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435712652","body":"class MyQueue {\n\n    Stack<Integer> s1, s2;\n    public MyQueue() {\n        s1 = new Stack<>();\n        s2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        s1.push(x);\n    }\n    \n    public int pop() {\n        peek();\n        return s2.pop();\n    }\n    \n    public int peek() {\n        if(s2.isEmpty()){\n            while(!s1.isEmpty()){\n                s2.push(s1.pop());\n            }\n        }\n        return s2.peek();\n    }\n    \n    public boolean empty() {\n        return s2.isEmpty() && s1.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436291783","body":"# 题目名\n\n链接：[https://leetcode.com/problems/rotate-list/description/](https://leetcode.com/problems/rotate-list/description/)\n\n# 解法思路1:\n\n先遍历链表一遍，此时记录链表本身的长度。并且让链表成环。\n\n让k = k % len。此时让指针再走len - k 格。就可以走到旋转链表的链表的tail节点。记录这个节点的next节点。让他把tail的next节点变为null断尾。\n\n## 注意要点：\n\n## 复杂度：\n\n时间：$O(n)$\n\n空间：$O(1)$\n\n## 第一次自己写的代码：\n\n```jsx\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null) return null;\n        ListNode p = head;\n        int len = 1;\n        \n        while(p.next != null){\n            p = p.next;\n            len++;\n        }\n        p.next = head;\n        k = k % len;\n        k = len - k;\n        for(int i = 0; i < k; i++) {\n            p = p.next;\n        }\n        ListNode res = p.next;\n        p.next =null;\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437413335","body":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(5);\n        dummy.next = head;\n        ListNode preNode = dummy;\n        ListNode firstNode = head;\n        ListNode secondNode;\n        ListNode postNode;\n        while(firstNode != null && firstNode.next != null) {\n            secondNode = firstNode.next;\n            postNode = secondNode.next;\n         \n            preNode.next = secondNode;\n            \n            firstNode.next = postNode;\n            secondNode.next = firstNode;\n            preNode = firstNode;\n            firstNode = postNode;\n            \n        }\n        return dummy.next;\n\n        \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440304819","body":"class Solution {\n  public TreeNode sortedListToBST(ListNode head) {\n      if(head == null) return null;\n      return dfs(head,null);\n  }\n  private TreeNode dfs(ListNode head, ListNode tail){\n      if(head == tail) return null;\n      ListNode fast = head, slow = head;\n      while(fast != tail && fast.next != tail){\n          fast = fast.next.next;\n          slow = slow.next;\n      }\n      TreeNode root = new TreeNode(slow.val);\n      root.left = dfs(head, slow);\n      root.right = dfs(slow.next, tail);\n      return root;\n  }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1440388463","body":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n\n        while(p1 != p2) {\n            if(p1 == null) \n                p1 = headB;\n            else \n                p1 = p1.next;\n            \n\n            if(p2  == null)\n                p2 = headA;\n            else \n                p2 = p2.next;\n            \n        }\n        return p1;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"neado":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaojunjun1110":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wxleah":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunl1ght":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kerrhl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c1f2h3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dlm001128":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxy94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyqqq22":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elon-lau":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436019315","body":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for (int num : arr) {\n            if (!stack.isEmpty() && num < stack.getLast()) {\n                int cur = stack.removeLast();\n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(cur);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        return stack.size();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437016576","body":"public ListNode rotateRight(ListNode head, int k) {\nif (k == 0 || head == null || head.next == null) {\nreturn head;\n}\nint n = 1;\nListNode iter = head;\nwhile (iter.next != null) {\niter = iter.next;\nn++;\n}\nint add = n - k % n;\nif (add == n) {\nreturn head;\n}\niter.next = head;\nwhile (add-- > 0) {\niter = iter.next;\n}\nListNode ret = iter.next;\niter.next = null;\nreturn ret;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437733294","body":"TC: O(n)\nSC: O(n)\n\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        var next = head.next;\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n    }","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nowkizzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsgtgyb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"irenia111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suiyi8760":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saltychess":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rabbit2010520":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yopming":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckytwj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzz607":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoulufeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxoojs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okkband":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wyz999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hacker90":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ricjli":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luhaoling":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gelxgx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lsunxh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lanceli424":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qycoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qilin88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengheng-yun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smz1995":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"size-of":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428989759","body":"var addToArrayForm = function(num, k) {\n  let i = num.length - 1, list = []\n\n  n = 0\n  while (i >= 0 || k > 0 || n) {\n    let a = num[i] || 0, b = k % 10\n\n    let res = a + b + n\n    n = res / 10 | 0\n    k = k / 10 | 0\n    i--\n\n    list.push(res % 10)\n  }\n\n  return list.reverse()\n};\n时间复杂度：O(n), 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430628438","body":"/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n  const res = new Array(s.length).fill(Infinity)\n  for (let i = 0; i < s.length; i++) {\n    res[i] = s.substr(i, 1) === c ? 0 : (res[i - 1] != undefined ? res[i - 1] : Infinity) + 1\n  }\n\n  for (let i = s.length - 1; i >= 0; i--) {\n    let prev = res[i + 1] !== undefined ? res[i + 1] : Infinity\n    res[i] = prev + 1 < res[i] ? prev + 1 : res[i]\n  }\n\n  return res\n};\n时间复杂度O(n),空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432299251","body":"/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.stack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length >= this.maxSize) return\n    this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (!this.stack.length) return -1\n    return this.stack.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let n = this.stack.length < k ? this.stack.length : k\n\n    for (let i = n - 1; i >= 0; i--) {\n        this.stack[i] += val\n    }\n};\n时间复杂度：push: O(1), pop: O(1), increment: O(n). 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1435472474","body":"/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let stack = []\r\n    let num = 0, char = '', cur = '', top \r\n\r\n    for (let i = 0; i < s.length; i++) {\r\n        cur = s.charAt(i)\r\n\r\n        if (typeof +cur === 'number' && !isNaN(+cur)) {\r\n            num = num * 10 + +cur\r\n        } else if (cur === '[') {\r\n            stack.push([num, char])\r\n            num = 0\r\n            char = ''\r\n        } else if (cur === ']') {\r\n            top = stack.pop()\r\n            char = top[1] + new Array(top[0]).fill(char).join('')\r\n        } else {\r\n            char += cur\r\n        }\r\n    }\r\n\r\n    return char\r\n};\r\n时间复杂度O(N),空间复杂度O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435474672","body":"var MyQueue = function() {\n    this.a = []\n    this.b = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.a.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (this.b.length) return this.b.pop()\n    while (this.a.length) {\n        this.b.push(this.a.pop())\n    }\n    return this.b.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (this.b.length) return this.b[this.b.length - 1]\n    while (this.a.length) {\n        this.b.push(this.a.pop())\n    }\n\n    return this.b[this.b.length - 1]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.a.length && !this.b.length\n};\n时间复杂度push，empty O(1),peek pop 均摊O(1), 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435942220","body":"/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n  const stack = []\n\n  for (let i = 0; i < arr.length; i++) {\n    if (!stack.length || stack[stack.length - 1] <= arr[i]) {\n      stack.push(arr[i])\n    } else {\n      const cur = stack.pop()\n      while(stack[stack.length - 1] > arr[i]) {\n        stack.pop()\n      }\n      stack.push(cur)\n    }\n  }\n  return stack.length\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438106808","body":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    const pre = new ListNode(-1)\n    pre.next = head\n    let now = pre\n\n    while (now.next !== null && now.next.next !== null) {\n        let start = now.next\n        let end = now.next.next\n\n        now.next = end\n        start.next = end.next\n        end.next = start\n        now = start\n    }\n\n    return pre.next\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441273699","body":"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let a = headA, b = headB\n\n    while (a !== b) {\n      a = a ? a.next : headB\n      b = b ? b.next : headA\n    }\n    return a\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moyuanhua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"9vivian88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guxuehua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kirosola":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maoting":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youzhaing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hanwangxxx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dujt-x":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436196030","body":"# 题目\r\nhttps://leetcode-cn.com/problems/rotate-list/\r\n\r\n将链表旋转k次，其中k是非负整数，即将链表的最后k个节点移动到链表的头部。\r\n# 思路分析\r\n---\r\n需要找到链表中的倒数第k个节点，并将链表从这个节点处分成两个部分，然后将第二部分连接到链表的头部。\r\n\r\n1. 首先遍历一次链表，以确定链表的长度。\r\n\r\n2. 如果k大于链表的长度，将k对链表的长度取模，以确保它不大于链表的长度。\r\n\r\n3. 定义两个指针：快指针和慢指针，都指向链表的头部。快指针向前移动k步，然后慢指针和快指针同时向前移动，直到快指针到达链表的尾部。\r\n\r\n4. 将第二部分链表的尾部与第一部分链表的头部相连接。\r\n\r\n5. 将第二部分链表的头部作为新的头节点返回。\r\n# 代码实现\r\n---\r\nGolang\r\n```Go\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n    // 特殊情况：链表为空或只有一个节点\r\n    if head == nil || head.Next == nil {\r\n        return head\r\n    }\r\n    \r\n    // 计算链表的长度\r\n    n := 1\r\n    curr := head\r\n    for curr.Next != nil {\r\n        n++\r\n        curr = curr.Next\r\n    }\r\n    \r\n    // 如果k大于链表的长度，将k对链表的长度取模\r\n    k = k % n\r\n    \r\n    // 特殊情况：k等于0，即不需要旋转\r\n    if k == 0 {\r\n        return head\r\n    }\r\n    \r\n    // 定义快指针和慢指针\r\n    fast := head\r\n    slow := head\r\n    \r\n    // 快指针向前移动k步\r\n    for i := 0; i < k; i++ {\r\n        fast = fast.Next\r\n    }\r\n    \r\n    // 移动慢指针和快指针，直到快指针到达链表的尾部\r\n    for fast.Next != nil {\r\n        slow = slow.Next\r\n        fast = fast.Next\r\n    }\r\n    \r\n    // 将第二部分链表的尾部与第一部分链表的头部相连接\r\n    new_head := slow.Next\r\n    slow\r\n```\r\n# 复杂度分析\r\n- 时间复杂度：O(n)，其中n是链表的长度。需要遍历一次链表来计算链表的长度，遍历一次链表来找到倒数第k个节点，所以时间复杂度是O(n)。\r\n\r\n- 空间复杂度：O(1)，只使用了常数级别的额外空间。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"degndaixingqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gzgzgzgzgzgz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gentleman-goodman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyi-arch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zenwangzy":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429936974","body":"## 思路\n模拟计算加法的逻辑。从个位开始遍历num计算的时候，用k作为carry 的数字。最后如果还有剩余的carry数字，加到res前中。\n\n## 代码\n```python\nclass Solution: \n\tdef addToArrayForm(self, num: List[int], k: int) -> List[int]: \n\t\tn = len(num) \n\t\tcarry = total = 0 \n\t\tres = [] \n\t\ti = len(num)-1 # track digits in num \n\t\twhile i >= 0 or k != 0: \n\t\t\tx = num[i] if i >= 0 else 0 # last digit in num \n\t\t\ty = k % 10 if k != 0 else 0 # last digit in k \n\t\t\ttotal = x + y + carry \n\t\t\tcarry = total // 10 \n\t\t\tk = k // 10 # remove last digit from k \n\t\t\ti -= 1 \n\t\t\tres.append(total % 10) \n\t\t\t\n\t\tif carry != 0: \n\t\t\tres.append(carry) \n\t\treturn res[::-1]\n```\n## 复杂度分析\n\n时间: O(N), n is max (len(num), k )\n\n空间: O(N), n is number of digits we processed in the while loop and the space in the res array","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437079617","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head:\n            slow , fast = head ,head\n            tmp = head\n            leng = 0\n            while tmp:\n                tmp = tmp.next\n                leng +=1\n            k = k%leng\n            while k:\n                fast = fast.next\n                k -=1\n            while fast.next:\n                slow = slow.next\n                fast = fast.next\n            if slow.next:\n                tmp = slow.next\n            else:\n                return head\n            slow.next = None\n            fast.next = head\n            return tmp\n```\n## 复杂度分析\n\n n 为数组长度。\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyyxw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fourierhai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yangz001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mannnn6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"haoyangxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chjillout":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenjialu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mhcn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coconutice":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackgaoyuan":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428999601","body":"```\r\nfunc addToArrayForm(num []int, k int) []int {\r\n\tkstr := strconv.Itoa(k)\r\n\tvar kArr []int\r\n\tvar res []int\r\n\tvar sum, reminder, carry int\r\n\tfor i := 0; i < len(kstr); i++ {\r\n\t\tv, _ := strconv.Atoi(string(kstr[i]))\r\n\t\tkArr = append(kArr, v)\r\n\t}\r\n\treverseSlice(kArr)\r\n\treverseSlice(num)\r\n\tfor i, j := 0, 0; i < len(num) || j < len(kArr); {\r\n\t\tif i >= len(num) { // num out of index\r\n\t\t\tsum = carry + kArr[j]\r\n\t\t\tj++\r\n\t\t} else if j >= len(kArr) { // kArr out of index\r\n\t\t\tsum = carry + num[i]\r\n\t\t\ti++\r\n\t\t} else { // num and kArr are both in range\r\n\t\t\tsum = carry + num[i] + kArr[j]\r\n\t\t\ti++\r\n\t\t\tj++\r\n\t\t}\r\n\t\tcarry = sum / 10\r\n\t\treminder = sum % 10\r\n\t\tres = append(res, reminder)\r\n\t}\r\n\tif carry > 0 {\r\n\t\tres = append(res, carry)\r\n\t}\r\n\treverseSlice(res)\r\n\treturn res\r\n}\r\n\r\nfunc reverseSlice(num []int) {\r\n\tfor i, j := 0, len(num)-1; i < j; i, j = i+1, j-1 {\r\n\t\tnum[i], num[j] = num[j], num[i]\r\n\t}\r\n}\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436165664","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * type ListNode struct {\r\n *     Val int\r\n *     Next *ListNode\r\n * }\r\n */\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n\t// 边界守护\r\n\tif head == nil {\r\n\t\treturn head\r\n\t}\r\n\t// 存储节点头，节点头的Next都是nil，避免处理环\r\n\theadList := []*ListNode{}\r\n\t// 节点list的长度\r\n\tn := 0\r\n\t// 节点的指针\r\n\tp := head\r\n\t// 计数器，计算处理结束\r\n\tcount := 1\r\n\t// 应该处理的长度，因为当处理的次数与总长度相等时，会出现周期性的循环，所以应处理次数为 k%n，只求余数即可\r\n\ttotalCount := 0\r\n\r\n\t// 将节点放入list\r\n\tfor p != nil {\r\n\t\theadList = append(headList, p)\r\n\t\tpNext := p.Next\r\n\t\tp.Next = nil\r\n\t\tp = pNext\r\n\t\tn++\r\n\t}\r\n\r\n\ttotalCount = k % n\r\n\tp = head\r\n\r\n\t// 先将数组进行选装，不处理节点\r\n\tfor count <= totalCount {\r\n\t\theadList = append(headList[n-1:], headList[0:n-1]...)\r\n\t\tcount++\r\n\t}\r\n\r\n\t// 连接处理的节点\r\n\tfor i := 0; i < n; i++ {\r\n\t\tif i == n-1 {\r\n\t\t\theadList[i].Next = nil\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\theadList[i].Next = headList[i+1]\r\n\t}\r\n\r\n\thead = headList[0]\r\n\r\n\treturn head\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufeng727":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fontendart":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingchehu":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435837452","body":"# 思路\r\n將 sub array 與 sub sorted array 比對數字出現的次數\r\n次數都相同就代表 sub array 可以排序成 sub sorted array，也就代表可以分成一個 chunk\r\n\r\n# Code\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        arr_counter = collections.defaultdict(int)\r\n        sorted_arr_counter = collections.defaultdict(int)\r\n        ans = 0\r\n        \r\n        sorted_arr = sorted(arr)\r\n        \r\n        for i in range(len(arr)):\r\n            arr_counter[arr[i]] += 1\r\n            sorted_arr_counter[sorted_arr[i]] += 1\r\n            if arr_counter == sorted_arr_counter:\r\n                ans += 1\r\n        return ans\r\n```\r\n\r\n# 複雜度\r\nTime: O(N^2) 迴圈裡加上 dict 比對\r\nSpace: O(N) 開了兩個 dict ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436583561","body":"# 思路\r\n要 rotate linked list，就先找到對的位置，拆掉重新接起來\r\n用快慢指針相隔 k，接著快指針走到最後一個 node 的時候慢指針便為在新的 linked list 的最後一個 node\r\n最後就尾接到頭，新的 head 在慢指針的下個節點，再把慢指針指到的 node 斷開\r\n\r\n# Code\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        if k == 0:\r\n            return head\r\n\t\t\t\t\r\n        p = head\r\n        length = 1\r\n        while p.next:\r\n            length += 1\r\n            p = p.next\r\n            \r\n        k = k % length\r\n        fast = slow = head\r\n        while fast.next:\r\n            fast = fast.next\r\n            if k > 0:\r\n                k -= 1\r\n            else:\r\n                slow = slow.next\r\n\r\n        fast.next = head\r\n        head = slow.next\r\n        slow.next = None\r\n        return head\r\n```\r\n\r\n# 複雜度\r\nTime: O(N)\r\nSpace: 未使用額外空間 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438298437","body":"# Code\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        \n        ret = self.swapPairs(head.next.next)\n        tmp = head.next\n        head.next = ret\n        tmp.next = head\n        \n        return tmp\n```\n# 複雜度\nTime: O(N)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439745777","body":"# 思路\r\n使用遞迴，每次都用快慢指針找出 Linked List 中間的節點當作數的根節點，前半 Linked List 遞迴呼叫做出左子樹，後半 Linked List 遞迴呼叫做出右子樹\r\n\r\n# Code\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n        \r\n        slow = ListNode()\r\n        slow.next = head\r\n        fast = head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n\r\n        node = TreeNode()\r\n        node.val = slow.next.val\r\n        node.right = self.sortedListToBST(slow.next.next)\r\n        slow.next = None\r\n        node.left = self.sortedListToBST(head)\r\n        return node\r\n```\r\n# 複雜度\r\nTime:  O(NlogN) 數的高度 logN * 每層執行 N\r\nSpace: O(logN)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cobayaz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomato-tomato":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xfliudx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"djd28176":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xilutian":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"itsjacob":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shunanch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yppah-eb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raychenlei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"woshichuanqilz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"willuuu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christina-soda":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jia98shanliang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user-vannnn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tobepellucid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnvsd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yueza":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawyuan97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"victorhuang99":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cusanity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jay-xzj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiradaone":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyue-ma":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joyce94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"steven72574":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tian-pengfei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asuka1h":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaowangcoding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james0608":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaneyang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"azl397985856":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whgsh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chengfengfengwang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bulingbulingbuling":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c2tr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eden-ye":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingtrains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"starorbiting":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo-xiaoxiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"passengersa":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shellylcooper":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"testplm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tom-zhouch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skylarxu214":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taihui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huaxueguakele":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yang-chenyu104":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mlking15":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"-3":[],"cyonline":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rzhao010":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jetery":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429910267","body":"### [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n### 思路\n模拟竖式的加法, 得到每个数组的最低位, 从最低位开始加\\\n注意 _循环结束后_ 对进位 `t` 的判断\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> a, b;\n        for (int i = num.size() - 1; i >= 0; i--) a.push_back(num[i]);\n        while (k != 0) {\n            b.push_back(k % 10);\n            k /= 10;\n        }\n        vector<int> temp;\n        int t = 0;\n        for (int i = 0; i < a.size() || i < b.size(); i++) {\n            if (i < a.size()) t += a[i];\n            if (i < b.size()) t += b[i];\n            temp.push_back(t % 10);\n            t /= 10;\n        }\n        if (t) temp.push_back(1);\n        vector<int> ans;\n        for (int i = temp.size() - 1; i >= 0; i--) ans.push_back(temp[i]);\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431533429","body":"```\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> ans(s.size(), INT_MAX);\n        int l = s.size(), r = -1, n = s.size();\n        for (int i = 0; i < s.size(); i++) {\n            int j = n - 1 - i;\n            if (s[i] == c) l = i;\n            if (s[j] == c) r = j;\n            if (i >= l) ans[i] = min(ans[i], i - l);\n            if (j <= r) ans[j] = min(ans[j], r - j);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433192790","body":"```cpp\nclass CustomStack {\n\npublic:\n    int size = 0, max = 0;\n    vector<int> stack;\n\n    CustomStack(int maxSize) {\n        max = maxSize;\n    }\n    \n    void push(int x) {\n        if (size < max) {\n            stack.push_back(x);\n            size++;\n        }\n    }\n    \n    int pop() {\n        if (size == 0) return -1;\n        size = size - 1;\n        int ret = stack[size];\n        stack.pop_back();\n        return ret;\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i < size && i < k; i++) {\n            stack[i] += val;\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434832063","body":"```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<int> num;\n        int n = 0;\n        stack<string> str;\n        string ans = \"\";\n        for (char c : s) {\n            if (c >= '0' && c <= '9') {\n                n = n * 10 + c - '0';\n            } else if (c == '[') {\n                num.push(n);\n                n = 0;\n                str.push(ans);\n                ans = \"\";\n            } else if (c == ']') {\n                int t = num.top();\n                num.pop();\n                for (int i = 0; i < t; i++) {\n                    str.top() += ans;\n                }\n                ans = str.top();\n                str.pop();\n            } else {\n                ans += c;\n            }\n        }\n        return ans;\n    }\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435650699","body":"```cpp\nclass MyQueue {\npublic:\n    stack<int> input;\n    stack<int> output;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        input.push(x);\n    }\n    \n    int pop() {\n        int ret = 0;\n        if (output.size() > 0) {\n            ret = output.top();\n            output.pop();\n        } else {\n            while (!input.empty()) {\n                output.push(input.top());\n                input.pop();\n            }\n            ret = output.top();\n            output.pop();\n        }\n        return ret;\n    }\n    \n    int peek() {\n        int ret = 0;\n        if (output.size() > 0) {\n            ret = output.top();\n        } else {\n            while (!input.empty()) {\n                output.push(input.top());\n                input.pop();\n            }\n            ret = output.top();\n        }\n        return ret;\n    }\n    \n    bool empty() {\n        return input.empty() && output.empty();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436017435","body":"```cpp\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        // å·²ç»æåºçæ°ç»\n        vector<int> clone = arr;\n        sort(clone.begin(), clone.end());\n        \n        int ans = 0, window = 0;\n        // ä½¿ç¨åå¸è¡¨è¿è¡è®¡æ°\n        unordered_map<int, int> map;\n\n        for (int i = 0; i < arr.size(); i++) {\n            map[arr[i]]++;\n            if (map[arr[i]] == 0) window--;\n            else if (map[arr[i]] == 1) window++;\n\n            map[clone[i]]--;\n            if (map[clone[i]] == 0) window--;\n            else if (map[clone[i]] == -1) window++;\n\n            if (window == 0) ans++;\n        }\n\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437184094","body":"```cpp\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (k == 0 || head == NULL || head->next == NULL) {\n            return head;\n        }\n        \n        int size = 1;\n        ListNode* cur = head;\n        while (cur->next != NULL) {\n            cur = cur->next;\n            size++;\n        }\n        cur->next = head;\n\n        k %= size;\n        for (int i = size - k - 1; i > 0; i--) {\n            head = head->next;\n        }\n\n        cur = head->next;\n        head->next = NULL;\n\n        return cur;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438684634","body":"```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* dummy = new ListNode(-1);\n        dummy->next = head;\n        ListNode *a = dummy, *b = head;\n        while (b != nullptr && b->next != nullptr) {\n            ListNode* c = b->next;\n            ListNode* d = c->next;\n            a->next = c;\n            c->next = b;\n            b->next = d;\n            a = b;\n            b = a->next;\n        }\n\n        return dummy->next;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440285037","body":"```cpp\n\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        TreeNode *root;\n        if (head == nullptr) return nullptr;\n        else if (head->next == nullptr) {\n            root = new TreeNode(head->val);\n            return root;\n        }\n\n        ListNode *fast = head, *slow = head, *pre = head;\n        // è®© slow æåä¸­é´èç¹\n        while (fast != nullptr && fast->next != nullptr) {\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        while (pre->next != slow) pre = pre->next;\n        root = new TreeNode(slow->val);\n        pre->next = nullptr; // ä»ä¸­é´æ­å¼é¾è¡¨, é²æ­¢éå½æ¶é¾è¡¨é¿åº¦ä¸å\n        // éå½å¤ç\n        root->left = sortedListToBST(head);\n        root->right = sortedListToBST(slow->next);\n\n        return root;\n\n    }\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"klspta":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bookyue":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429838033","body":"现写的还没以前写的简洁，泪目\n\nOC: O(max(n, logk))  \nSC: O(1)\n\n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new LinkedList<>();\n        int i = num.length - 1;\n        int d = 0;\n        while (i >= 0 || k > 0 || d > 0) {\n            d += (i >= 0 ? num[i] : 0) + k % 10;\n            ans.add(0, d % 10);\n            d /= 10;\n            k /= 10;\n            i--;\n        }\n\n        return ans;\n    }\n```\n\n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new LinkedList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0) {\n            if (i >= 0) k += num[i];\n\n            ans.add(0, k % 10);\n            k /= 10;\n            i--;\n        }\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430652958","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        Arrays.fill(ans, n);\n        for (int i = 0, j = -1; i < n; i++) {\n            if (s.charAt(i) == c) j = i;\n            if (j != -1) ans[i] = i - j;\n        }\n\n        for (int i = n - 1, j = -1; i >= 0; i--) {\n            if (s.charAt(i) == c) j = i;\n            if (j != -1) ans[i] = Math.min(ans[i], j - i);\n        }\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432451072","body":"TC: O(1) for all operations  \nOC: O(n)\n\n```java\nclass CustomStack {\n    private final int[] stack;\n    private final int[] add;\n    private int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        add = new int[maxSize];\n        top = -1;\n    }\n\n    public void push(int x) {\n        if (top == stack.length - 1) return;\n\n        stack[++top] = x;\n    }\n\n    public int pop() {\n        if (top == -1) return -1;\n\n        int ans = stack[top] + add[top];\n        if (top > 0) add[top - 1] += add[top];\n        add[top] = 0;\n        top--;\n\n        return ans;\n    }\n\n    public void increment(int k, int val) {\n        int limit = Math.min(k - 1, top);\n        if (limit >= 0)\n            add[limit] += val;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1433955807","body":"TC: O(n)  \nSC: O(n)\n\n```java\n    public String decodeString(String s) {\n        Queue<Character> queue = new ArrayDeque<>();\n        for (char c : s.toCharArray())\n            queue.offer(c);\n\n        return helper(queue);\n    }\n\n    private String helper(Queue<Character> queue) {\n        StringBuilder sb = new StringBuilder();\n        int num = 0;\n        while (!queue.isEmpty()) {\n            char c = queue.poll();\n            if (Character.isDigit(c)) {\n                num = 10 * num + c - '0';\n            } else if (c == '[') {\n                String sub = helper(queue);\n                sb.append(sub.repeat(num));\n                num = 0;\n            } else if (c == ']') {\n                break;\n            } else {\n                sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435471668","body":"TC: push O(1), pop O(n), peek O(n)  \nOC: O(n)\n\n```java\nclass MyQueue {\n    private final Deque<Integer> in;\n    private final Deque<Integer> out;\n\n    public MyQueue() {\n        in = new ArrayDeque<>();\n        out = new ArrayDeque<>();\n    }\n\n    public void push(int x) {\n        in.push(x);\n    }\n\n    public int pop() {\n        transfer();\n        return out.pop();\n    }\n\n    public int peek() {\n        transfer();\n        return out.peek();\n    }\n\n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n    }\n    \n    private void transfer() {\n        if (!out.isEmpty()) return;\n        \n        while (!in.isEmpty())\n            out.push(in.pop());\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435945243","body":"https://leetcode.com/problems/max-chunks-to-make-sorted-ii/solutions/595713/monotonic-stack-solution-with-detailed-explanation/\n\nTC: O(n)  \nSC: O(n)\n\n```java\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int num : arr) {\n            while (!stack.isEmpty() && stack.peek() > num)\n                stack.pop();\n\n            stack.push(num);\n        }\n\n        return stack.size();\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436175369","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || k == 0) return head;\n\n        int n = 1;\n        var cur = head;\n        while (cur.next != null) {\n            cur = cur.next;\n            n++;\n        }\n\n        k %= n;\n        if (k == 0) return head;\n\n        cur.next = head;\n        k = n - k - 1;\n\n        while (k > 0) {\n            head = head.next;\n            k--;\n        }\n\n        var newHead = head.next;\n        head.next = null;\n        return newHead;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437716929","body":"TC: O(n)  \nSC: O(n)\n\n```java\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        var next = head.next;\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439314255","body":"TC: O(n)  \nSC: O(lgn)\n\n```java\n    private ListNode cur;\n\n    public TreeNode sortedListToBST(ListNode head) {\n        int len = 0;\n        for (var p = head; p != null; p = p.next) len++;\n\n        cur = head;\n        return buildTree(0, len - 1);\n    }\n\n    private TreeNode buildTree(int left, int right) {\n        if (left > right) return null;\n\n        int mid = (left + right) >>> 1;\n\n        TreeNode leftTree = buildTree(left, mid - 1);\n\n        TreeNode root = new TreeNode(cur.val);\n        cur = cur.next;\n\n        TreeNode rightTree = buildTree(mid + 1, right);\n        root.left = leftTree;\n        root.right = rightTree;\n\n        return root;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1440331400","body":"TC: O(n)  \nSC: O(1)\n\n```java\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode nodeA = headA;\n        ListNode nodeB = headB;\n        while (nodeA != nodeB) {\n            nodeA = nodeA == null ? headB : nodeA.next;\n            nodeB = nodeB == null ? headA : nodeB.next;\n        }\n\n        return nodeA;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jancerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"buer1121":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ceramickitten":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gg925407590":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alyenor":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenming-cao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggohem":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dark-volute":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ronething":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jmastella":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429296672","body":"思路\r\n用一个addson记录需要进位的数字, 从个位开始加，每一次把 %10 存进list里面，直到addson为零\r\n\r\n代码\r\n`\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> li = new ArrayList();\r\n\r\n        int addson = k;\r\n        int index = num.length-1;\r\n\r\n        while(index>=0 || addson >0){\r\n            if(index>=0){\r\n                addson += num[index];\r\n                index--;\r\n            }\r\n            li.add(0, addson%10);\r\n            addson/=10;\r\n            \r\n        }\r\n\r\n        return li;\r\n    }\r\n}\r\n`\r\n复杂度分析\r\n\r\n时间: O(max(N, log k)), N is the length of num\r\n空间: O(max(N, log k)), N is the length of num\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430971036","body":"思路\r\n从左到右loop一遍，记录左边离他最近的character。再从右到左loop一遍记录右边离他最近的character，两者取min。\r\n\r\n代码\r\n```\r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] answer = new int[s.length()];\r\n        int index = -1;\r\n        for(int i=0; i<s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                index = i;\r\n            }\r\n            if(index == -1){\r\n                answer[i] = s.length();\r\n            }else{\r\n                answer[i] = i - index;\r\n            }\r\n            //System.out.println(s.charAt(i) + \" \" + answer[i]);\r\n        }\r\n        //System.out.println(\"==================\");\r\n        for(int i=s.length()-1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                index = i;\r\n            }\r\n            if(index >= i){\r\n                answer[i] = Math.min(answer[i], index - i);\r\n            }\r\n            //System.out.println(s.charAt(i) + \" \" + answer[i]);\r\n        }\r\n        return answer;\r\n}\r\n```\r\n复杂度\r\n时间：O(N) N=s.length()\r\n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432576668","body":"思路\r\n用int array来代表stack，new variable index来mark top of list\r\npush的时候，check有没有超过array.length\r\npop的时候，check index>=0\r\nincrement的时候，取Math.min(k, arr.length)\r\n\r\n代码\r\n```\r\nclass CustomStack {\r\n    int[] arr;\r\n    int index;\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        index = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(index < arr.length-1){\r\n            index++;\r\n            arr[index] = x;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    public int pop() {\r\n        if(index >=0){\r\n            return arr[index--];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        System.out.println(k + \" \" + index);\r\n        for(int i=0; i< Math.min(k, arr.length); i++){\r\n            arr[i]+=val;\r\n        }\r\n    }\r\n}\r\n```\r\n复杂度分析\r\n\r\n时间复杂度：push、pop：O(1) increment:O(N)。\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434224506","body":"思路\r\n利用stack\r\n1.遇到数字变成int 数字\r\n2.遇到'[' 把数字push to stack\r\n3.遇到’]‘ 把所有的character pop出来组成一个string，在用数字去repeat\r\n4.遇到字母push to stack\r\n\r\n代码\r\n```\r\n    public String decodeString(String s) {\r\n        \r\n        Stack<String> stack = new Stack<>();\r\n        int i=0;\r\n        int repeat =0;\r\n        while(i<s.length()){\r\n            char curr = s.charAt(i);\r\n            if(Character.isDigit(curr)){\r\n                repeat = repeat*10 + Character.getNumericValue(curr);\r\n            }else if(curr == '['){\r\n                stack.push(Integer.toString(repeat));\r\n                stack.push(\"*\");\r\n                repeat = 0;\r\n            }else if(curr == ']'){\r\n                String str = \"\";\r\n                while(!stack.peek().equals(\"*\")){\r\n                    str = stack.pop() + str;\r\n                }\r\n                stack.pop();\r\n                int count = Integer.parseInt(stack.pop());\r\n                stack.push(str.repeat(count));\r\n            }else{\r\n                stack.push(Character.toString(curr));\r\n            }\r\n            i++;\r\n        }\r\n        String result = \"\";\r\n        while(!stack.isEmpty()){\r\n            result = stack.pop() + result;\r\n        }\r\n        return result;\r\n    }\r\n```\r\n复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435638176","body":"思路\r\n两个stack，一个是部分reverse queue的顺序，一个是正序\r\npush：直接push到reverse_stack\r\npop: 如果正序stack不为空，pop from 正序stack。otherwise，先把reverse stack所有element放进正序stack里，再pop from 正序stack。\r\npeek：和pop思路一样\r\nempty：两个stack都为空\r\n代码\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> s1;\r\n    Stack<Integer> s2;\r\n    public MyQueue() {\r\n        s1 = new Stack<>(); // reverse\r\n        s2 = new Stack<>(); /// front\r\n    }\r\n    \r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(!s2.isEmpty()){\r\n            return s2.pop();\r\n        }\r\n        while(!s1.isEmpty()){\r\n            s2.push(s1.pop());\r\n        }\r\n        return s2.pop();\r\n    }\r\n\r\n    \r\n    public int peek() {\r\n        if(!s2.isEmpty()){\r\n            return s2.peek();\r\n        }\r\n        while(!s1.isEmpty()){\r\n            s2.push(s1.pop());\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```\r\n复杂度分析\r\n\r\n时间复杂度：push()和empty()：O(1)，pop()，peek()：O(N)。\r\n空间复杂度：O(N)，其中 N number of element push in stack。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435925844","body":"### 思路\r\n用stack来存每一个chunck里面最大的数字，monotonic stack\r\n如果stack.peek() > arr[i], 找到所有比arr[i]大的数字，pop()出来，然后再把本chunk最大的数字再加回去\r\n### 代码\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int count =1;\r\n        Stack<Integer> stack = new Stack<>();\r\n        for(int i=0; i<arr.length; i++){\r\n            if(stack.size() == 0 || stack.peek()<= arr[i]){\r\n                stack.push(arr[i]);\r\n                continue;\r\n            }\r\n            int temp = stack.peek();\r\n            while(!stack.empty() && stack.peek() > arr[i] ){\r\n                stack.pop();\r\n            }\r\n            stack.push(temp);\r\n\r\n            \r\n        }\r\n        return stack.size();\r\n    }\r\n```\r\n### 复杂度\r\n时间：O(N)\r\n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436517682","body":"### 思路\r\nfast 和slow两个pointer。先找到整个list长度N。fast走 k%N步，找到新的head，修改\r\nedge case：empty list，k=0 or k%N=0\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null){\r\n            return null;\r\n        }\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n\r\n        int len = 0;\r\n        while(fast != null){\r\n            fast = fast.next;\r\n            len++;\r\n        }\r\n        fast = head;\r\n        if(k==0 || k%len == 0){\r\n            return head;\r\n        }\r\n        for(int i=0; i<k%len; i++){\r\n            fast = fast.next;\r\n        }\r\n        while(fast.next != null){\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n\r\n        ListNode temp = slow.next;\r\n        slow.next = null;\r\n        fast.next = head;\r\n\r\n        return temp; \r\n\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n时间：O(N)\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437990918","body":"### 思路\r\n1. 借助了一些hint，提示用recursion。\r\n2. new listNode fakehead 帮助返回new head。\r\n3. Base Case： curr==null || curr.next ==null\r\n4. Recursion: \r\nparent -> swap1 -> swap2 -> temp\r\n变为\r\nparent -> swap2 -> swap1 -> temp\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n\r\n        ListNode fakeHead = new ListNode();\r\n        fakeHead.next = head;\r\n        helper(fakeHead, head);\r\n        return fakeHead.next;\r\n    }\r\n    public void helper(ListNode parent, ListNode swap1){\r\n        \r\n        if(swap1 == null || swap1.next == null){\r\n            return;\r\n        }\r\n        ListNode swap2 = swap1.next;\r\n        ListNode temp = swap2.next;\r\n        swap2.next = swap1;\r\n        swap1.next = temp;\r\n        parent.next = swap2;\r\n\r\n        helper(swap1, swap1.next);\r\n    }\r\n\r\n}\r\n```\r\n### 复杂度\r\n时间：O(N)\r\n空间： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439654691","body":"## 思路\r\nroot, left, right  preorder traversal\r\n\r\n## 代码\r\n```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return helper(head, null);\r\n    }\r\n    public TreeNode helper(ListNode head, ListNode tail){\r\n        if(head == tail){\r\n            return null;\r\n        }\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while(fast !=tail && fast.next!=tail){\r\n            slow = slow.next;\r\n            if(fast.next==tail){\r\n                break;\r\n            }\r\n            fast =fast.next.next;\r\n        }\r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = helper(head, slow);\r\n        root.right = helper(slow.next, tail);\r\n\r\n        return root;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n时间：O(N)\r\n空间：O(log(N))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441094599","body":"### 思路\r\nAAAAAAAACCCCC\r\nBBCCCCC\r\n\r\nA+C+B = B + C + A\r\n\r\n当Aloop完继续loopB， 同理B loop完继续loop A，当他俩交汇时就是intersection\r\n\r\n### 代码\r\n```\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode lA = headA;\r\n        ListNode lB = headB;\r\n\r\n        while(lA != null || lB !=null){\r\n            if(lA == lB){\r\n                return lA;\r\n            }\r\n            \r\n            if(lA == null){\r\n                lA = headB;\r\n            }else{\r\n                lA = lA.next;\r\n            }\r\n            if(lB == null){\r\n                lB = headA;\r\n            }else{\r\n                lB = lB.next;\r\n            }\r\n            \r\n            \r\n            \r\n        }\r\n        return null;\r\n    }\r\n```\r\n### 复杂度\r\n时间 O(m+n)\r\n空间 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"paopaohua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dd2001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mayloveless":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuexi001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nineis7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"abby-xu":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429186782","body":"合并list -> 加上k -> 拆分为list\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        return [int(a) for a in str(int(''.join(map(str,num)))+k)]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430833276","body":"```\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size(), pos = -n;\n        vector<int> res(n,n);\n        for (int i = 0; i < n; i++) {\n            if (s[i] == c) pos = i;\n            res[i] = i - pos;\n        }\n        for (int i = pos - 1; i >= 0; i--) {\n            if (s[i] == c) pos = i;\n            res[i] = min(res[i], pos - i);\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432418838","body":"```\nclass CustomStack {\n    vector<int> stack;\n    int n;\npublic:\n    CustomStack(int maxSize) {\n        n = maxSize;\n    }\n    \n    void push(int x) {\n        if (stack.size() == n) return;\n        if (stack.size() < n) stack.push_back(x);\n    }\n    \n    int pop() {\n        if(stack.size()==0)\n            return -1;\n        int x=stack.back();\n        stack.pop_back();\n        return x;\n    }\n    \n    void increment(int k, int val) {\n        int x=k;\n        if(stack.size()<k)\n            x=stack.size();\n        for(int i=0;i<x;i++) {\n            stack[i]+=val;\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434174727","body":"```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        current_string = \"\"\n        k = 0\n\n        for char in s:\n            if char == \"[\":\n                # Just finished parsing this k, save current string and k for when we pop\n                stack.append((current_string, k))\n                # Reset current_string and k for this new frame\n                current_string = \"\"\n                k = 0\n            elif char == \"]\":\n                # We have completed this frame, get the last current_string and k from when the frame \n                # opened, which is the k we need to duplicate the current current_string by\n                last_string, last_k = stack.pop(-1)\n                current_string = last_string + last_k * current_string\n            elif char.isdigit():\n                k = k * 10 + int(char)\n            else:\n                current_string += char\n\n        return current_string\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435491976","body":"```\nclass MyQueue:\n\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n\n    def push(self, x):\n        self.s1.append(x)\n\n    def pop(self):\n        self.peek()\n        return self.s2.pop()\n\n    def peek(self):\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n        return self.s2[-1]        \n\n    def empty(self):\n        return not self.s1 and not self.s2 \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435903870","body":"```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        s = []\n        for i,a in enumerate(arr):\n            maxi = a\n            while s and s[-1] > a:\n                maxi = max(maxi,s.pop())\n            s.append(maxi)\n        return len(s)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436365541","body":"```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return None\n      \n      #check the length\n        lastNode, length = head, 1\n        while lastNode.next:\n            lastNode = lastNode.next\n            length += 1\n\n        # check the number of rotation\n        k = k % length\n\n      # setlast node point to the first node\n        lastNode.next = head\n\n      #traverse until (length - k) node\n        temp = head\n        for i in range(length - k - 1): temp = temp.next\n\n      #disconnect the first and last node\n        out = temp.next\n        temp.next = None\n\n        return out\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439434999","body":"```\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head: return None\n        if not head.next: return TreeNode(head.val)\n\n        pre, slow, fast = None, head, head\n\n        # find the middle node of the linked list\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        if pre: pre.next = None\n\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n\n        return root\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441182993","body":"```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        p, q = headA, headB\n        while p != q:\n            p = p.next if p else headB\n            q = q.next if q else headA\n        return p\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsw9818":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaomingshixiaotang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"snmyj":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429688195","body":"```c\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> kvet,res;\n        while(k>=1){\n            kvet.push_back(k%10);\n            k/=10;\n        }\n        reverse(kvet.begin(),kvet.end());\n        int n=num.size(),m=kvet.size(),cnt;\n        if(n>=m){\n            cnt=0;\n            for(int i=m-1,j=n-1;i>=0;i--,j--){\n                int a=num[j]+kvet[i]+cnt;\n                if(a>=10) {\n                    res.push_back(a-10);\n                    cnt=1;\n                }\n                else {\n                    res.push_back(a);\n                    cnt=0;\n                }\n            }\n            for(int i=n-m-1;i>=0;i--){\n                int a=num[i]+cnt;\n                if(a>=10) {\n                    res.push_back(a-10);\n                    cnt=1;\n                }\n                else {\n                    res.push_back(a);\n                    cnt=0;\n                }\n            }\n        }\n        else if(n<m){\n            cnt=0;\n            for(int i=n-1,j=m-1;i>=0;i--,j--){\n                int a=num[i]+kvet[j]+cnt;\n                if(a>=10) {\n                    res.push_back(a-10);\n                    cnt=1;\n                }\n                else {\n                    res.push_back(a);\n                    cnt=0;\n                }\n            }\n            for(int i=m-n-1;i>=0;i--){\n                int a=kvet[i]+cnt;\n                if(a>=10) {\n                    res.push_back(a-10);\n                    cnt=1;\n                }\n                else {\n                    res.push_back(a);\n                    cnt=0;\n                }\n            }\n        }\n        if(cnt!=0) res.push_back(cnt);\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```\nT:max(m,n)+n\nS:o(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431233047","body":"```c\n class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n=s.length();\n        \n        vector<int> res;\n        for(int i=0;i<n;i++){\n           \n            if(s[i]==c) res.push_back(0);\n            else{\n                 for(int p=1;;p++){\n                     if(i+p<n){\n                     if((s[i+p]==c)&&(i+p)<n) {\n                         res.push_back(p);\n                         break;\n                     }\n                     }\n                     if(i-p>=0){\n                    if((s[i-p]==c)&&(i-p)>=0){\n                        res.push_back(p);\n                        break;\n                    }\n                     }\n                 }\n                \n                \n            }\n            \n        }\n        return res;\n    }\n};\n```\nT:O(NlogN);\nS:O(N);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433244386","body":"```c\r\nclass CustomStack {\r\npublic:\r\n    vector<int> s;\r\n    int len=0,maxlen;\r\n    CustomStack(int maxSize) {\r\n            maxlen=maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(len<maxlen){\r\n        s.push_back(x);\r\n        len++;\r\n        }\r\n       \r\n    }\r\n    \r\n    int pop() {\r\n        if(len>0) {\r\n          int temp=s[len-1];\r\n          s.pop_back();\r\n        \r\n        len--;\r\n        return temp;\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n            if(k<=len) {\r\n                for(int i=0;i<k;i++) s[i]+=val;\r\n            }\r\n            else {\r\n                for(int i=0;i<s.size();i++) s[i]+=val;\r\n            }\r\n    }\r\n};\r\n```\r\nT：push() pop() == O(1) ; increment: O(k);\r\nS: O(N);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434512405","body":"```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<char> ss;\r\n        string ans=\"\",re=\"\",rereverse=\"\";\r\n        int sign=0,cnt=0;\r\n        for(int i=0;i<s.size();i++){\r\n            ss.push(s[i]);\r\n        }\r\n        for(int t=s.size()-1;t>=0;t--){\r\n            if(sign==0&&ss.top()>='a'&&ss.top()<='z') {\r\n                ans+=ss.top();\r\n                ss.pop(); \r\n                continue;         \r\n              }\r\n            if(ss.top()==']'){\r\n                sign++;\r\n                ss.pop(); \r\n                continue;    \r\n            }\r\n            if(ss.top()=='[') {\r\n                sign--;\r\n                ss.pop();\r\n                continue;\r\n            }\r\n            if(sign!=0&&ss.top()>='a'&&ss.top()<='z') {\r\n                    re+=ss.top();\r\n                    ss.pop();\r\n                    continue;\r\n            }\r\n            if(ss.top()>='0'&&ss.top()<='9') {\r\n                cnt=ss.top()-'0';\r\n                ss.pop();\r\n                continue;\r\n            }\r\n            if(cnt!=0) {\r\n                for(int i=re.size()-1;i>=0;i--) rereverse+=re[i];\r\n                     if(sign==0){\r\n                            for(int j=cnt;j>0;cnt--){\r\n                                ans+=rereverse;\r\n                            }\r\n                     }      \r\n                     if(sign!=0){\r\n                            for(int j=cnt;j>0;cnt--){\r\n                                re+=rereverse;\r\n                            }\r\n                     }    \r\n                 \r\n            }\r\n            re=\"\";\r\n            rereverse=\"\";\r\n            cnt=0;\r\n            \r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\n```\r\nT:O(N);\r\nS:O(N);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435126511","body":"```c\nclass MyQueue {\npublic:\n    stack<int> s1,s2;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n       s1.push(x); \n    }\n    \n    int pop() {\n       while(!s1.empty()){\n       s2.push(s1.top());\n       s1.pop();\n       }\n       return(s2.top());\n       s2.pop();\n    }\n    \n    int peek() {\n        int p=s2.top();\n        return p;\n    }\n    \n    bool empty() {\n        if(!s1.empty()||!s2.empty())\n        return false;\n        else return true;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435772317","body":"```c\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int n=arr.size(),max=0;;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>=i;j--){\n                if(arr[j]<=arr[i]) {\n                    max++;\n                    for(int k=j-1;k>=i;k--){\n                        if(arr[k]==arr[j])\n                        max++;\n                        else if(arr[i]==arr[j]) {\n                            \n                            if(arr[k]==arr[j]){\n                                max++;\n                                j=k;\n                            }\n                            \n                        }\n                    }\n                    if(j!=n-1){\n                    i=j;\n                    break;\n                    }\n                    \n                    return max;\n                   \n                }\n            }\n        }\n        return max;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436057624","body":"```c\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        ListNode* p=head,newhead;\n        int length=0,cnt=0;\n        while(p!=nullptr){\n            length++;\n            p=p->next;\n        }\n        p=head;\n        while(p!=nullptr){\n            cnt++;\n            p=p->next;\n            if(cnt==length-k){\n                newhead=p->next;\n                p->next=nullptr;\n               \n            }\n            if(cnt==length) {\n                p->next=head;\n                break;\n            }\n        }\n        return newhead;\n    }\n};\n```\nT:O(n);\nS:O(1);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438651683","body":"```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy=new ListNode(-1,head);\n        ListNode cur=dummy;\n        ListNode temp=null;\n        ListNode temp1=null;\n        while(cur.next!=null&&cur.next.next!=null){\n            temp=cur.next;\n            temp1=cur.next.next.next;\n            cur.next=cur.next.next;\n            cur.next.next=temp;\n            cur.next.next.next=temp1;\n            cur=cur.next.next;\n        }\n        return dummy.next;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440094184","body":"```c++\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head==nullptr) return nullptr;\n        if(head->next==nullptr) return new TreeNode(head->val);\n        ListNode* p=head,*q=head,*dummy=nullptr;\n        while(q!=nullptr&&q->next!=nullptr){\n            dummy=p;\n            p=p->next;\n            q=q->next->next;\n        }\n        dummy->next=nullptr;\n        TreeNode *root=new TreeNode(p->val);\n        root->left=sortedListToBST(head);\n        root->right=sortedListToBST(p->next);\n        return root;\n\n    }\n};\n```\nTC:O(n);\nSC:O(n);","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flipn9":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429974446","body":"```java\n/**\n    TC: O(max(N,logk)), N为数组的长度\n    SC: O(max(N,logk))\n*/\n\n// Method 2: 将 加数 k 整个 加入数组表示的数的最低位\n//           3 + 912 = 915, 5 留在当前这一位，将 910 / 10 = 91 以进位的形式加入下一位\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int N = num.length;\n        for (int i = N - 1; i >= 0; i--){\n            int sum = num[i] + k;\n            res.add(0, sum % 10);\n            k = sum / 10;   // 更新 k 存进位 carry\n        }\n        while (k > 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n        return res;\n    }\n}\n\n// Method 1: 两个数拆解后 同时 从后往前逐位相加\nclass Solution1 {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int N = num.length;\n        \n        int i = N - 1;\n        int sum = 0, carry = 0;\n        while (i >= 0 || k > 0) {\n            int x = i >= 0 ? num[i] : 0;\n            int y = k > 0 ? k % 10 : 0;\n            sum = x + y + carry;\n            carry = sum / 10;\n            k /= 10;\n            i--;\n            res.add(0, sum % 10);\n        }\n        \n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430842233","body":"```java\n/**\n    思路:     对每一个 i 从中心扩散找最近的 C     O(n^2)\n        ==>  空间换时间, 存储所有 c 的位置       O(nk), 出现 k 次\n        ==>  Greedy, 只关心最近的 C ==> 正向遍历+反向遍历\n    ------------------------------------------------------------------\n    实现:\n        两个数组 left 和 right 分别记录每个字符左/右侧出现的最后一个 C 字符的下标\n        同时比遍历这两个数组, 计算距离最小值\n\n    优化:    \n        1. 只需要最近的 C, 所以看情况可以覆盖掉第一个数组的值\n            case 1. 字符的左侧没有出现过 C 字符\n            case 2. i - left > right - i\n        2. 直接记录 C 与当前字符的距离, 而不是 C 的下标, 还可以省去最后遍历计算距离的过程\n                \n    TC: O(N), SC: O(1)      1ms\n*/\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int N = s.length();\n        int[] dist = new int[N];\n        dist[0] = s.charAt(0) == c ? 0 : N;\n        for (int i = 1; i < N; i++) {\n            dist[i] = s.charAt(i) == c ? 0 : dist[i - 1] + 1;\n        }\n        for (int i = N - 2; i >= 0; i--) {\n            dist[i] = Math.min(dist[i], dist[i + 1] + 1);  // 左侧距离 > 右侧距离, 未遇到 C 默认距离为 N\n        }\n        return dist;\n    }\n}\n\n/**\n    sliding window: 把 c 看成 s 的分割线\n    XXXX | XXXX | XXXXXX\n    \n    TC: O(N), SC: O(1)\n*/\nclass Solution1 {\n    public int[] shortestToChar(String s, char c) {\n        int N = s.length();\n        int[] dist = new int[N];\n        \n        int l = s.charAt(0) == c ? 0 : N;\n        int r = s.indexOf(c);\n        for (int i = 0; i < N; i++) {\n            dist[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\n            if (i == r) {\n                l = r;\n                r = s.indexOf(c, l + 1);\n            }\n        }\n        return dist;\n    }\n}\n```\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434131488","body":"```java\n/**\n    Method 2: recursive\n         先解析数字 x, 解析到了左括号 [，递归向下解析后面的内容，遇到对应的右括号就返回 ]\n         [] 解析结束后, 再继续 解析] 右边的内容\n*/\nclass Solution1 {\n    int i = 0;\n    public String decodeString(String s) {\n        int count = 0;\n        StringBuilder sb = new StringBuilder();\n        while (i < s.length()) {\n            char c = s.charAt(i);\n            i++;\n            if (Character.isLetter(c)) {\n                sb.append(c);\n            } else if (Character.isDigit(c)) {\n                count = count * 10 + (c - '0');\n            } else if (c == ']') {      \n                break;\n            } else if (c == '[') {\n                String repeat = decodeString(s);\n                while (count > 0) {\n                    sb.append(repeat);\n                    count--;\n                }\n            }\n        }\n        return sb.toString();\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435745090","body":"```java\n/**\n    思路: 和 769 类似\n    块的最大值呈升序排列, 维护一个单调递增栈 保存每个块的最大值\n        如果当前栈为空 || 栈顶 比当前小, 将当前元素 push 进去\n        如果当前栈非空 && 栈顶比当前大, 栈顶应该是目前块的最大值, pop 出来, \n                                    把所有比当前大的元素也 pop 出来\n                                    再把真正的最大值 pop 回去\n    TC: O(N), SC: O(N)\n*/\nclass Solution1 {\n    public int maxChunksToSorted(int[] arr) {\n        int[] stack = new int[arr.length];\n        int top = -1;\n        for (int i : arr) {\n            if (top != -1 && stack[top] > i) {\n                int max = stack[top--];\n                while (top != -1 && stack[top] > i)\n                    top--;\n                stack[++top] =  max;\n            } else {\n                stack[++top] = i;\n            }\n        }\n        return top + 1;\n    }\n}\n\n// method 2: TC: O(nlogn), O(M)\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] copy = arr.clone();\n        Arrays.sort(copy);\n        int count = 0;\n        int sum1 = 0, sum2 = 0;\n        for(int i = 0; i < arr.length; i++) {\n            sum1 += arr[i];\n            sum2 += copy[i];\n            if(sum1 == sum2) {\n                count++;\n                sum1 = 0;\n                sum2 = 0;\n            }\n        }\n        return count;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437235654","body":"```java\n/**\n    思路: 走 k 步, 由于 k 可能很大, 希望 k = k % N\n        1. 遍历, 找到N, 和尾结点 tail\n        2. 断开两种方式\n            - 找到新的头结点, 连接旧头尾, 断开得到新的 head, 新的 tail 指向 null\n            - 先连成环, 再找到新的头尾, 断开\n*/\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode fast = dummy, slow = dummy;\n\n        int N = 0;\n        for (; fast.next != null; N++)\n            fast = fast.next;\n        for (int i = N - k % N; i > 0; i--) \n            slow = slow.next;\n\n        fast.next = dummy.next; \n        dummy.next = slow.next;\n        slow.next = null;\n    \n        return dummy.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438694383","body":"```java\n\n// 思路: 两两翻转 TC: O(n) SC: O(1)\n// 像这种多次对链表进行相同操作, iterative 的写法用 dummy 节点会很方便\n\n// recursive\nclass Solution1 {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) \n            return head;\n        \n        ListNode first = head;\n        ListNode second = head.next;\n        ListNode others = head.next.next;\n        \n        second.next = first;\n        first.next = swapPairs(others);\n        return second;\n    }\n}\n\n// iterative\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode tmp = dummy;\n        while (tmp.next != null && tmp.next.next != null) {\n            ListNode first = tmp.next;\n            ListNode second = tmp.next.next;\n            tmp.next = second;\n            first.next = second.next;\n            second.next = first;\n            tmp = first;\n        }\n        return dummy.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440299863","body":"\n```java\n// Approach 2: 中序遍历结果是链表本身:     TC: O(n), SC: O(logn)\n//             不直接找到中点的值, 而是构造完左子树, 指针自然指向中间结点, 再构造右子树\nclass Solution {\n    ListNode cur;\n    \n    public TreeNode sortedListToBST(ListNode head) {\n        cur = head;\n        int len = 0;\n        for (ListNode p = head; p != null; p = p.next)\n            len++;\n        return inOrderBuildTree(0, len - 1);\n    }\n    \n    private TreeNode inOrderBuildTree(int left, int right) {\n        if (left > right) return null;\n        int mid = left + (right - left) / 2;\n        \n        TreeNode leftTree = inOrderBuildTree(left, mid - 1);    // 构造左子树\n        TreeNode root = new TreeNode(cur.val);                  // 构造根节点\n        cur = cur.next;\n        TreeNode rightTree = inOrderBuildTree(mid + 1, right);  // 构造右子树\n        \n        root.left = leftTree;\n        root.right = rightTree;\n        return root;\n    }\n}\n\n// Approach 1: 快慢指针找链表中点    TC: O(nlogn), SC: O(logn)\nclass Solution1 {\n    public TreeNode sortedListToBST(ListNode head) {\n        return build(head, null);\n    }\n    \n    // 把链表左闭右开区间 [begin, end) 的节点构造成 BST\n    private TreeNode build(ListNode begin, ListNode end) {\n        if (begin == end) \n            return null; // 左闭右开 -> 空集\n        ListNode mid = getMid(begin, end);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = build(begin, mid);\n        root.right = build(mid.next, end);\n        return root;\n    }\n    \n    private ListNode getMid(ListNode begin, ListNode end) {\n        ListNode slow = begin, fast = begin;\n        while (fast != end && fast.next != end) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wabw1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqmmy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-pricity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sclihuiming":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"amazeding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"astrking":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429161664","body":"### 思路\n\n~~~bash\n1、题目可以简略理解为是2个数的相加，主要就是考虑生成结果的方式\n2、我们遍历num数组，考虑倒叙遍历，依次和k相加，结果对10取模，余数留下，模继续和下一位相加\n3、利用linkedlist的特性，每次加入的时候都是往头部加，这样我们得到的值就是正序的\n4、同时考虑到K值特别大的情况，最后对K值再进行判断一下，这样就是完整的流程\n~~~\n\n### 代码\n\n~~~java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> res = new LinkedList<>();\n    int n = num.length;\n    \n    for (int i = n - 1; i >= 0; i--) {\n        res.add(0, (num[i] + k) % 10);\n        k = (num[i] + k) / 10;\n    }\n    \n    while (k > 0) {\n        res.add(0, k % 10);\n        k /= 10;\n    }\n    \n    return res;\n}\n~~~\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430897544","body":"### 思路\n\n~~~bash\n1.无脑两次遍历，正着一次，反着一次，然后再比较两次遍历后相同下标处的最小值即可\n2.遍历的时候只考虑当前顺序，考虑不到的情况由下次反序遍历时来弥补\n~~~\n\n### 代码\n\n~~~java\npublic int[] shortestToChar(String s, char c) {\n    int n = s.length();\n    int[] ans = new int[n];\n\n    for (int i = 0, idx = -n; i < n; ++i) {\n        if (s.charAt(i) == c) {\n            idx = i;\n        }\n        ans[i] = i - idx;\n    }\n\n    for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n        if (s.charAt(i) == c) {\n            idx = i;\n        }\n        ans[i] = Math.min(ans[i], idx - i);\n    }\n    return ans;\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432869219","body":"### 思路\n\n~~~bash\n1、看题目描述+栈的本身特性，做到后进先出\n2、同时考虑题目中的increment函数，循环加那肯定是数组来的最快，无脑for循环加即可\n3、我们把数组想象成横向的一组数字，左边是开头，右边是结尾，每次新增数据都是在结尾处添加当前数据，符合题目中的push要求，同时可以对前n个元素进行for循环遍历相加，也符合题目中的increment要求，只是我们不符合题目中的pop要求\n4、我们把步骤3中的数组进行逆时针旋转，同时记录最后一位值的下标，每次pop的时候，就移出数组中的最后一位元素，这样就满足了我们题目的要求\n\n整体而言就是数组+一个辅助标志位\n~~~\n\n### 代码\n\n~~~java\npublic class CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top =-1;\n    }\n    public void Push(int x) {\n        if(top!=stack.Length-1)\n        {\n            top++;\n            stack[top]=x;\n        }\n    }\n    public int Pop() {\n        if(top==-1)\n        {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    public void Increment(int k, int val) {\n        int limit = Math.Min(k, top + 1);\n        for (int i = 0; i < limit; ++i)\n        {\n            stack[i] += val;\n        }\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：push和pop为O(1)，increment为O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434284105","body":"### 思路\n\n~~~bash\n默认题解是与辅助栈相结合，我们遍历字符串，一次压入栈，等遇到']'再出栈，一致出栈至'['，根据重复次数进行相关操作，再依次入栈，依次类推，得到最终结果即可\n\n本次我们换另一种思路：递归\n1、依次取出每个字符，再对剩下的字符串进行递归，在方法中对不同类型的情况进行分类处理\n2、利用队列的特性(先进先出)，可以简化遍历以及对方法的调用\n~~~\n\n### 代码\n\n~~~java\nstatic class Solution {\n    public String decodeString(String s) {\n        Queue<Character> q = new LinkedList<>();\n        // 借助队列(先进者先出)，简化递归函数，看起来更加清晰明了\n        for (char c : s.toCharArray()) {\n            q.offer(c);\n        }\n        return decodeString(q);\n    }\n\n    public String decodeString(Queue<Character> q) {\n        StringBuilder res = new StringBuilder();\n        int num = 0;\n        // 什么时候q为空则结束\n        while (!q.isEmpty()) {\n            // 我们就针对一个一个字符进行判断\n            char c = q.poll();\n            // 当字符是阿拉伯数字时，计算重复次数\n            if (c >= '0' && c <= '9') {\n                num = 10 * num + (c - '0');\n            } else if (c == '[') {  // 字符是左括号，可以理解为一条新开始的字符串，我们直接对剩余的q操作即可\n                String tmp = decodeString(q);\n                // 操作完成且获取到返回的字符串后，判断字符串是否需要重复\n                while (num > 0) {\n                    res.append(tmp);\n                    num--;\n                }\n            } else if (c == ']') { // 判断是否要结束返回\n                return res.toString();\n            } else { // 这种情况就是遇到了字符，无脑接在res后面即可\n                res.append(c);\n            }\n\n        }\n        // 最后返回我们的res即可\n        return res.toString();\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435665008","body":"### 思路\n\n~~~bash\n1、栈的特性是先进后出，队列的特性是先进先出，我们根据这些特性来做此道题目\n2、知道两者特性之后，我们需要用两个栈来模拟队列的特性，一个栈为入队栈，一个栈为出对栈。当出队栈存在内容时，出队栈的栈顶，即为第一个出队的元素。若出队栈无元素，我们的需求又是出队的话，我们就需要将入队栈的内容反序导入出队栈，然后弹出栈顶即可。\n~~~\n\n### 代码\n\n~~~java\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new LinkedList<Integer>();\n        outStack = new LinkedList<Integer>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}\n~~~\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435946779","body":"### 思路\n\n~~~bash\n采用单调栈的思想，将一个减序列压缩合并成最该序列的最大的值，保证其它栈里面是单调递增即可\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for (int num : arr) {\n            // 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\n            // 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\n            if (!stack.isEmpty() && num < stack.getLast()) {\n                // 我们需要将融合后的区块的最大值重新放回栈\n                // 而 stack 是递增的，因此 stack[-1] 是最大的\n                int cur = stack.removeLast();\n                // 维持栈的单调递增\n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(cur);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        // 栈存的是块信息，因此栈的大小就是块的数量\n        return stack.size();\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436532795","body":"### 思路\n\n~~~bash\n1、首先我们先确认一个概念，当整体向右边移动1个位置，相当于把链表的最后1位移动到head前面，移动2个位置，就是把链表的最后两位移动到head前面\n2、如果说链表的整体长度为k，你移动k，相当于没有移动(把链表当成一个环来处理)\n3、所以我们的移动，只需要考虑K对链表长度的求余即可\n4、那么后续问题，就可以转化为查询链表上面倒数第几个元素了，这样就十分方便了\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        int count = 0;\n        ListNode now = head;\n        while(now != null){\n            now = now.next;\n            count++;\n        }\n        k = k % count;\n        ListNode slow = head, fast = head;\n        while(fast.next != null){\n            if(k-- <= 0){\n                slow = slow.next;\n            }\n            fast = fast.next;\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438140941","body":"### 思路\n\n~~~bash\n采用递归的思想，两个两个一组，先对前面两个进行翻转，再把剩下的依次进行翻转\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    // 定义：输入以 head 开头的单链表，将这个单链表中的每两个元素翻转，\n    // 返回翻转后的链表头结点\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode first = head;\n        ListNode second = head.next;\n        ListNode others = head.next.next;\n        // 先把前两个元素翻转\n        second.next = first;\n        // 利用递归定义，将剩下的链表节点两两翻转，接到后面\n        first.next = swapPairs(others);\n        // 现在整个链表都成功翻转了，返回新的头结点\n        return second;\n\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439827715","body":"### 思路\n\n~~~bash\ndfs+双指针：\n1、获取当前链表的中点\n2、以链表中点为根\n3、中点左边的值都小于它,可以构造左子树\n4、同理构造右子树\n5、循环第一步\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n  public TreeNode sortedListToBST(ListNode head) {\n      if(head == null) return null;\n      return dfs(head,null);\n  }\n  private TreeNode dfs(ListNode head, ListNode tail){\n      if(head == tail) return null;\n      ListNode fast = head, slow = head;\n      while(fast != tail && fast.next != tail){\n          fast = fast.next.next;\n          slow = slow.next;\n      }\n      TreeNode root = new TreeNode(slow.val);\n      root.left = dfs(head, slow);\n      root.right = dfs(slow.next, tail);\n      return root;\n  }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(nlogn)\n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441663474","body":"### 思路\n\n~~~bash\n1、使用两个指针如指针 a, b 分别指向 A, B 这两条链表的头节点, 两个指针以相同的速度向后移动。\n2、若在此过程中 a, b 指针相遇，则相遇节点为两链表相交的起始节点，否则说明两个链表不存在相交点。\n~~~\n\n### 代码\n\n~~~java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        // p1 指向 A 链表头结点，p2 指向 B 链表头结点\n        ListNode p1 = headA, p2 = headB;\n        while (p1 != p2) {\n            // p1 走一步，如果走到 A 链表末尾，转到 B 链表\n            if (p1 == null) p1 = headB;\n            else            p1 = p1.next;\n            // p2 走一步，如果走到 B 链表末尾，转到 A 链表\n            if (p2 == null) p2 = headA;\n            else            p2 = p2.next;\n        }\n        return p1;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tzuikuo":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429891420","body":"### 思路\n待补充\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        map<int,int> nummap;\n        vector<int> revec;\n        int n=num.size(),flag=0;\n        reverse(num.begin(),num.end());\n        for(int i=0;i<n;i++){\n            nummap[i]=num[i];\n        }\n        int i=0;\n        while(k!=0){\n            nummap[i]+=k%10;\n            k=k/10;\n            i++;\n        }\n        for(auto it=nummap.begin();it!=nummap.end();it++){\n            if(it->second>=10&&it->first<nummap.size()-1){\n                it->second-=10;\n                it++;\n                it->second+=1;\n                it--;\n            }\n            if(it->second>=10&&it->first==nummap.size()-1){\n                it->second-=10;\n                flag++;\n            }\n            revec.push_back(it->second);\n        }\n        if(flag) revec.push_back(1);\n        reverse(revec.begin(),revec.end());\n        return revec;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431487447","body":"### 思路\n待补充\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n=s.size();\n        vector<int> re;\n        for(int i=0;i<n;i++){\n            int left=i,right=i;\n            if(s[i]==c){\n                re.push_back(0);\n                continue;\n            }\n            left--;\n            right++;\n            while(true){\n                if(left<0&&right>n-1) break;\n                if(left>=0){\n                    if(s[left]==c){\n                        re.push_back(i-left);\n                        break;\n                    }\n                    left--;\n                } \n                if(right<=n-1){\n                    if(s[right]==c){\n                        re.push_back(right-i);\n                        break;\n                    }\n                    right++;\n                }\n            }\n        }\n        return re;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433245555","body":"### 思路\n用数组\n\n### 代码\n\n\n```C++\nclass CustomStack {\npublic:\n    int max_=0;\n    vector<int> vec;\n    CustomStack(int maxSize) {\n        max_=maxSize;\n    }\n    \n    void push(int x) {\n        if(vec.size()<max_) vec.push_back(x);\n    }\n    \n    int pop() {\n        int re=-1;\n        if(!vec.empty()){\n            re=vec[vec.size()-1];\n            vec.pop_back();\n        }\n        return re;\n    }\n    \n    void increment(int k, int val) {\n        if(vec.size()>0){\n            if(vec.size()<k){\n                for(int i=0;i<vec.size();i++) vec[i]+=val;\n            }\n            else{\n                for(int i=0;i<k;i++){\n                    vec[i]+=val;\n                }\n            }\n        }\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434724515","body":"### 思路\r\n栈\r\n\r\n### 代码\r\n\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        int n=s.size();\r\n        stack<string> stackstr;\r\n        stack<int> stacknum;\r\n        string curstr=\"\";\r\n        int curnum=0;\r\n        for(int i=0;i<n;i++){\r\n            if(s[i]>='0'&&s[i]<='9') curnum=curnum*10+(s[i]-'0');\r\n            if(s[i]>='a'&&s[i]<='z') curstr+=s[i];\r\n            if(s[i]=='['){\r\n                stackstr.push(curstr);\r\n                stacknum.push(curnum);\r\n                curstr=\"\";\r\n                curnum=0;\r\n            }\r\n            if(s[i]==']'){\r\n                string temp=curstr;\r\n                for(int i=0;i<stacknum.top()-1;i++) curstr+=temp;\r\n                curstr=stackstr.top()+curstr;\r\n                stackstr.pop();\r\n                stacknum.pop();\r\n            }\r\n        }\r\n        return curstr;\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435703493","body":"### 思路\n两个栈\n\n### 代码\n\n\n```C++\nclass MyQueue {\npublic:\n    stack<int> mainstack,tempstack;\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        mainstack.push(x);\n    }\n    \n    int pop(){\n        int temp;\n        if(!tempstack.empty()){\n            temp=tempstack.top();\n            tempstack.pop();\n        }\n        else{\n            while(!mainstack.empty()){\n                temp=mainstack.top();\n                mainstack.pop();\n                tempstack.push(temp);\n            }\n            temp=tempstack.top();\n            tempstack.pop(); \n        }  \n        return temp;\n    }\n    \n    int peek() {\n        if(!tempstack.empty()) return tempstack.top();\n        else{\n            while(!mainstack.empty()){\n                int temp=mainstack.top();\n                mainstack.pop();\n                tempstack.push(temp);\n            }   \n            return tempstack.top();\n        }\n    }\n    \n    bool empty() {\n        if(mainstack.empty()&&tempstack.empty()) return true;\n        return false;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436005055","body":"### 思路\r\n分块排序前后和一样，妙啊\r\n\r\n### 代码\r\n\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        long long sum1 = 0, sum2 = 0, ans = 0;\r\n        vector<int> t = arr;\r\n        sort(t.begin(), t.end());\r\n        for(int i = 0; i < arr.size(); i++) {\r\n            sum1 += t[i];\r\n            sum2 += arr[i];\r\n            if(sum1 == sum2) ans++;\r\n        }\r\n\treturn ans;\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437156067","body":"### 思路\n快慢指针\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        ListNode* slow=head,*fast=head,*newhead;\n        ListNode* cur=head;\n        int c=0;\n        if(!head||!head->next) return head;\n        while(cur){\n            cur=cur->next;\n            c++;\n        }\n        if(k>=c) k%=c;\n        while(k){\n            fast=fast->next;\n            k--;\n        }\n        while(fast->next){\n            fast=fast->next;\n            slow=slow->next;\n        }\n        fast->next=head;\n        newhead=slow->next;\n        slow->next=NULL;\n        return newhead;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438590472","body":"### 思路\n两个指针，虚拟头节点；\n讨论里有用递归的\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* pre,*left,*right,*last;\n        pre=new ListNode(0);\n        pre->next=head;\n        left=head;\n        if(head) right=head->next;\n        last=pre;\n        while(left&&left->next){\n            last->next=right;\n            left->next=right->next;\n            right->next=left;\n            last=left;\n            if(left&&left->next){\n               left=left->next;\n               right=left->next; \n            }\n        }\n        return pre->next;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440291205","body":"### 思路\n递归\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    TreeNode* buildBST(ListNode* head) {\n        if(!head) return nullptr;\n\n        ListNode *slow = head, *fast = head, *prev = nullptr;\n \n        while(fast && fast->next) {\n            prev = slow;\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        if(prev) prev -> next = nullptr;\n        if(slow == head) head = nullptr;\n\n        TreeNode* node = new TreeNode(slow->val);\n\n        node -> left = buildBST(head);\n        node -> right = buildBST(slow->next);\n\n        return node;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        return buildBST(head);\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441081771","body":"### 思路\n从剩下相同的长度处往后比较\n\n### 代码\n```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        int nA=0,nB=0;\n        ListNode* curA,*curB;\n        curA=headA;\n        curB=headB;\n        while(curA){\n            nA++;\n            curA=curA->next;\n        }\n        while(curB){\n            nB++;\n            curB=curB->next;\n        }\n        int diff=abs(nA-nB);\n        if(nA>nB){\n            while(diff)\n            {\n                headA=headA->next;\n                diff--;\n            }\n        }\n        else if(nB>nA){\n            while(diff)\n            {\n                headB=headB->next;\n                diff--;\n            }\n        }\n        while(headA&&headB){\n            if(headA==headB) return headA;\n            headA=headA->next;\n            headB=headB->next;\n        }\n\n        return nullptr;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(m+n)。m,n分别为两个链表的长度。\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ringo1597":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brucezhang-utf-8":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luanxing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moin-jer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lihua1997":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cuizezhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuanaxuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tiandao043":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"restlessbreeze":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429917860","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int n = num.size();\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10) {\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            res.push_back(sum);\r\n        }\r\n        for (; k > 0; k /= 10) {\r\n            res.push_back(k % 10);\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431476973","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> ans(n);\r\n\r\n        for (int i = 0, idx = -n; i < n; ++i) {\r\n            if (s[i] == c) {\r\n                idx = i;\r\n            }\r\n            ans[i] = i - idx;\r\n        }\r\n\r\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\r\n            if (s[i] == c) {\r\n                idx = i;\r\n            }\r\n            ans[i] = min(ans[i], idx - i);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433162602","body":"### code\r\n```\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stk;\r\n    int top;\r\n\r\n    CustomStack(int maxSize) {\r\n        stk.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top != stk.size() - 1) {\r\n            ++top;\r\n            stk[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stk[top + 1];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int lim = min(k, top + 1);\r\n        for (int i = 0; i < lim; ++i) {\r\n            stk[i] += val;\r\n        }\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434687773","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    string getDigits(string &s, size_t &ptr) {\r\n        string ret = \"\";\r\n        while (isdigit(s[ptr])) {\r\n            ret.push_back(s[ptr++]);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string getString(vector <string> &v) {\r\n        string ret;\r\n        for (const auto &s: v) {\r\n            ret += s;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string decodeString(string s) {\r\n        vector <string> stk;\r\n        size_t ptr = 0;\r\n\r\n        while (ptr < s.size()) {\r\n            char cur = s[ptr];\r\n            if (isdigit(cur)) {\r\n                string digits = getDigits(s, ptr);\r\n                stk.push_back(digits);\r\n            } else if (isalpha(cur) || cur == '[') {\r\n                stk.push_back(string(1, s[ptr++])); \r\n            } else {\r\n                ++ptr;\r\n                vector <string> sub;\r\n                while (stk.back() != \"[\") {\r\n                    sub.push_back(stk.back());\r\n                    stk.pop_back();\r\n                }\r\n                reverse(sub.begin(), sub.end());\r\n                stk.pop_back();\r\n                int repTime = stoi(stk.back()); \r\n                stk.pop_back();\r\n                string t, o = getString(sub);\r\n                while (repTime--) t += o; \r\n                stk.push_back(t);\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435665075","body":"### code\r\n```\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n\r\n    void in2out() {\r\n        while (!inStack.empty()) {\r\n            outStack.push(inStack.top());\r\n            inStack.pop();\r\n        }\r\n    }\r\n\r\npublic:\r\n    MyQueue() {}\r\n\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    int pop() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n\r\n    int peek() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n\r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435990423","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        unordered_map<int, int> cnt;\r\n        int res = 0;\r\n        vector<int> sortedArr = arr;\r\n        sort(sortedArr.begin(), sortedArr.end());\r\n        for (int i = 0; i < sortedArr.size(); i++) {\r\n            int x = arr[i], y = sortedArr[i];\r\n            cnt[x]++;\r\n            if (cnt[x] == 0) {\r\n                cnt.erase(x);\r\n            }\r\n            cnt[y]--;\r\n            if (cnt[y] == 0) {\r\n                cnt.erase(y);\r\n            }\r\n            if (cnt.size() == 0) {\r\n                res++;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437043032","body":"### code\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (!head) return nullptr;\r\n        int length = 1;\r\n        ListNode* H = head;\r\n        while (H -> next)\r\n        {\r\n            H = H -> next;\r\n            length++;\r\n        }  \r\n        H -> next = head;\r\n        k = length - k % length;\r\n        while (k > 1)\r\n        {\r\n            head = head -> next;\r\n            k--;\r\n        }\r\n        H = head;\r\n        head = H -> next;\r\n        H -> next = nullptr;\r\n        return head;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437769132","body":"### code\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (!head || !head -> next)\r\n            return head;\r\n        ListNode* newHead = swapPairs(head -> next -> next);\r\n        ListNode* p = head -> next;\r\n        head -> next = newHead;\r\n        p -> next = head;\r\n        return p;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439377466","body":"### code\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* getMedium(ListNode* left, ListNode* right)\r\n    {\r\n        ListNode* S = left;\r\n        ListNode* F = left;\r\n        while (F != right && F -> next != right)\r\n        {\r\n            S = S -> next;\r\n            F = F -> next -> next;\r\n        }\r\n        return S;\r\n    }\r\n\r\n    TreeNode* BST(ListNode* l, ListNode* r)\r\n    {\r\n        if (l == r) return nullptr;\r\n        ListNode* me = getMedium(l, r);\r\n        TreeNode* med = new TreeNode(me -> val);\r\n        med -> left = BST(l, me);\r\n        med -> right = BST(me -> next, r);\r\n        return med;\r\n    }\r\n\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        return BST(head, nullptr);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441274715","body":"### code\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if (!headA || !headB) return nullptr;\r\n        ListNode *pa = headA;\r\n        ListNode *pb = headB;\r\n        while (pa != pb)\r\n        {\r\n            pa = pa == nullptr ? headB : pa -> next;\r\n            pb = pb == nullptr ? headA : pb -> next;\r\n        }\r\n        return pa;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ruikiwi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huiminren":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saitochen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wtdcai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"albert556":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wuxiaoshawn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zrtch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuzhu096":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whoam-challenge":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weisday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"syh-coder":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436022622","body":"func maxChunksToSorted(arr []int) (ans int) {\r\n    cnt := map[int]int{}\r\n    b := append([]int{}, arr...)\r\n    sort.Ints(b)\r\n    for i, x := range arr {\r\n        cnt[x]++\r\n        if cnt[x] == 0 {\r\n            delete(cnt, x)\r\n        }\r\n        y := b[i]\r\n        cnt[y]--\r\n        if cnt[y] == 0 {\r\n            delete(cnt, y)\r\n        }\r\n        if len(cnt) == 0 {\r\n            ans++\r\n        }\r\n    }\r\n    return\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaaller":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kyrie96521":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cavecrypto":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cxgbro":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erjian96":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-polarbear":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alexno1no2":[null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431598470","body":"```\n暴力破解\nclass Solution:\n     def shortestToChar(self, s: str, c: str) -> List[int]:\n         c_idx = [ i for i in range(len(s)) if s[i] == c ]\n         return [ min(abs( i - j )  for j in c_idx) for i in range(len(s)) ]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433313429","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yetfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhiyuanpeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bwspsu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"arinzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mdge":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng666":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yin02":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elsa-zhang":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429069573","body":"```bash\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        sum = 0\n        for i in range(n):\n            sum=10*sum+num[i]\n        sum = sum+k\n\n        ans = []\n        while sum:\n            sum, remian = sum//10, sum%10\n            ans.append(remian)\n        \n        return ans[::-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430692126","body":"```bash\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pos = []\n        for i, w in enumerate(s):\n            if w==c:\n                pos.append(int(i))\n        \n        ans = []\n        for i, w in enumerate(s):\n            dis = [abs(p-i) for p in pos]\n            ans.append(min(dis))\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432520891","body":"```bash\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxsize = maxSize\n        self.list = []\n\n    def push(self, x: int) -> None:\n        if len(self.list) < self.maxsize:\n            self.list.append(x)\n\n    def pop(self) -> int:\n        if len(self.list) == 0:\n            return -1\n        return self.list.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        length = min(k, len(self.list))\n        for i in range(length):\n            self.list[i] = self.list[i]+val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434068281","body":"```bash\nclass Solution:\n    def decodeString(self, str: str) -> str:\n        stack, num, res = [], 0, ''\n        for s in str:\n            if '0'<=s<='9':\n                num = int(num)*10 + int(s)\n            elif s == '[':\n                stack.append([num, res])\n                num, res = 0, ''\n            elif s == ']':\n                last_num, last_res = stack.pop()\n                res = last_res + last_num*res\n            else:\n                res += s\n        \n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435500329","body":"```bash\nclass MyQueue:\n\n    def __init__(self):\n        self.quene = []\n\n    def push(self, x: int) -> None:\n        self.quene.append(x)\n\n    def pop(self) -> int:\n        return self.quene.pop(0)\n\n    def peek(self) -> int:\n        return self.quene[0]\n\n    def empty(self) -> bool:\n        return False if self.quene else True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435981637","body":"```bash\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        n = len(arr)\n        temp = []\n        ans = []\n        for i in range(n):\n            temp.append(arr[i])\n            if i<n-1 and max(temp)<=min(arr[i+1:]):\n                ans.append(temp)\n                temp = []\n            elif i==n-1:\n                ans.append(temp)\n        return len(ans) if ans else 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436283928","body":"```bash\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n\n        if not head:\n            return \n            \n        cur = head\n        length = 0\n        while cur:\n            cur = cur.next\n            length+=1\n        rotate_length = k%length\n        l = length - rotate_length\n\n        if l==length:\n            return head\n\n        node1 = head\n        temp1 = node1\n        while l-1:\n            node1 = node1.next\n            l-=1\n        node2 = node1.next\n        node1.next = None\n\n        temp2 = node2\n        while node2.next:\n            node2=node2.next\n        node2.next = temp1\n\n        return temp2\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437833179","body":"```bash\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return head\n        dummyhead = ListNode()\n        dummyhead.next = head\n        temp = dummyhead\n\n        while temp.next and temp.next.next:\n            node1 = temp.next\n            node2 = temp.next.next\n\n            temp.next = node2\n            node1.next = node2.next\n            node2.next = node1\n\n            temp = node1\n        \n        return dummyhead.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439368408","body":"```bash\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return head\n\n        def getMedian(l:ListNode, r:ListNode)-> ListNode:\n            fast = slow = l \n            while fast!=r and fast.next!=r:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n\n        def buildTree(l:ListNode, r:ListNode)-> TreeNode:\n            if l == r:\n                return None\n            mid = getMedian(l, r)\n            root = TreeNode(mid.val)\n            root.left = buildTree(l, mid)\n            root.right = buildTree(mid.next, r)\n            return root\n        \n        return buildTree(head, None)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441162055","body":"```bash\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        node1,node2 = headA, headB\n        while node1!=node2:\n            if node1:\n                node1 = node1.next\n            else:\n                node1 = headB\n            \n            if node2:\n                node2 = node2.next\n            else:\n                node2 = headA\n\n        return node2\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asur4s":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlesugarman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhihaowan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"apockira":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guowei0223":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuqianyang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sj941127":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yongxi-zhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darwintk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"h-steven":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mischaqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wurongronga":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miduoliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyshenzhengkang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y4h2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yoco323":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forschers":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shanshuiqiankun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"annabellhyx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hwfrankfung":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435826710","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        rec = [None] * (len(arr)+1)\n        rec[0] = 0\n        cur, p = arr[0], 0\n        for i in arr:\n            while i < rec[p]:\n                p -= 1\n            p += 1\n            if i > cur:\n                cur = i;\n            rec[p] = cur\n        return p\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438638398","body":"```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frederickfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huibinny":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggmybro":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"myleetcodejourney":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"want2333":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"staringwhere":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng8":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ryanbaiyansong":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428966385","body":"```\nclass Solution:\n    def addToArrayForm(self, nums: List[int], k: int) -> List[int]:\n        nums.reverse()\n        i = t = 0\n        n = len(nums)\n        res = []\n        while i < n or t or k:\n            if k:\n                t += k % 10\n                k //= 10\n            \n            if i < n:\n                t += nums[i]\n                i += 1\n            \n            digit = t % 10\n            res.append(digit)\n            t //= 10\n        \n        res.reverse()\n        return res\n```\n高精度板子题","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430158405","body":"# 双指针 + 前后缀分解\n···\nclass Solution:\n    def shortestToChar(self, s: str, t: str) -> List[int]:\n        n = len(s)\n        ans = [0] * n\n        idx = -n \n        for i, c in enumerate(s):\n            if c == t:\n                idx = i \n            ans[i] = i - idx \n        \n        idx = 2 * n\n        for i in range(n - 1, -1, -1):\n            c = s[i]\n            if c == t:\n                idx = i \n            ans[i] = min(ans[i], idx - i)\n        \n        return ans\n        \n        l = 0 if s[0] == t else n \n        r = s.find(t, start=1)\n        for i in range(n):\n            ans[i] = min(i - l, r - i)\n            if i == r:\n                l = r \n                r = s.find(t, start = l + 1)\n        \n        return ans\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1431886534","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = []\n        self.maxSize = maxSize\n\n\n    def push(self, x: int) -> None:\n        if len(self.stk) < self.maxSize:\n            self.stk.append(x)\n\n\n    def pop(self) -> int:\n        if not self.stk: return -1\n        return self.stk.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i < len(self.stk):\n                self.stk[i] += val\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n# maxSize\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436006067","body":"···\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        # split arr into number of chunks\n        n = len(arr)\n        #动态比较两个集合是否相同 两个哈希表\n        tmp = sorted(arr)\n        count = Counter()\n        res = 0\n        for x, y in zip(arr, sorted(arr)):\n            count[x] += 1\n            count[y] -= 1\n            if all(x == 0 for x in count.values()):\n                res += 1\n        \n        return res\n            \n\n\n\n\n        #单调栈 O(N) 维护所有集合的最大值\n        # 存储每一个区间的最大值\n        stk = []\n        for x in arr:\n            # 新的最大值\n            t = x\n            while stk and stk[-1] > x:\n                t = max(t, stk[-1])\n                stk.pop()\n            stk.append(t)\n        return len(stk)\n···","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437367599","body":"···\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head \n        dummy = ListNode(-1)\n        dummy.next = head \n        pre = dummy \n        cur = head \n        \n        while cur and cur.next:\n            sec = cur.next\n            tmp = cur.next.next\n            cur.next.next = cur \n            cur.next = tmp \n            pre.next = sec \n            pre = cur \n            cur = cur.next \n        \n        return dummy.next\n···\nO(N) O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439216912","body":"···\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return \n        \n        len = 0\n        p = head \n        while p:\n            p = p.next \n            len += 1\n        def build(L: int, R: int) -> Optional[TreeNode]:\n            if L > R:\n                return \n            \n            mid = (L + R + 1) // 2\n            root = TreeNode()\n            root.left = build(L, mid - 1)\n            nonlocal head\n            root.val = head.val\n            head = head.next\n            root.right = build(mid + 1, R)\n            return root\n\n        \n        return build(0, len - 1\n\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1440656556","body":"···\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        a, b = headA, headB\n        while a != b:\n            if a:\n                a = a.next \n            else:\n                a = headB\n            \n            if b:\n                b = b.next\n            else:\n                b = headA\n        \n        return a\n···","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dou-yu-xuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyxupup":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cs12300":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chiehw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aesir-idun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaldsk12":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hxj2001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"for123s":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428245121","body":"```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res = {num.rbegin(), num.rend()};\n        int len = 0;\n        while (k!=0) {\n            int temp = k % 10;\n            k /= 10;\n            if (len < res.size()) {\n                if (temp + res[len] >= 10) {\n                    k += 1;\n                }\n                res[len] = (res[len] + temp) % 10;\n            }\n            else {\n                res.emplace_back(temp);\n            }\n            ++len;\n        }\n        return {res.rbegin(), res.rend()};\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430050786","body":"```\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> res(s.size(), -1);\n        int idx = -1;\n        for (int i=0;i<s.size();i++) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            if (idx != -1) {\n                res[i] = i - idx;\n            }\n        }\n        idx = -1;\n        for (int i=s.size()-1;i>=0;i--) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            if (res[i] == -1) {\n                res[i] = idx - i;\n            }\n            else if (idx != -1) {\n                res[i] = min(res[i], idx - i);\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1431673255","body":"```\nclass CustomStack {\npublic:\n    vector<int> nums;\n    int top = -1;\n    CustomStack(int maxSize) {\n        nums.resize(maxSize);\n    }\n    \n    void push(int x) {\n        if (top == nums.size()-1) {\n            return;\n        }\n        nums[++top] = x;\n    }\n    \n    int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        return nums[top--];\n    }\n    \n    void increment(int k, int val) {\n        for (int i=0;i<=top&&i<k;i++) {\n            nums[i] += val;\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434813115","body":"```\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<char> st_c;\n        stack<int> st_num;\n        for(int i=0;i<s.size();++i)\n        {\n            if(s[i]>='0'&&s[i]<='9')\n            {\n                int temp = s[i]-'0';\n                while(s[i+1]>='0'&&s[i+1]<='9')\n                {\n                    ++i;\n                    temp = temp * 10 + s[i]-'0';\n                }\n                st_num.push(temp);\n            }\n            else if(s[i]==']')\n            {\n                string temp = \"\";\n                while(st_c.top()!='[')\n                {\n                    temp = st_c.top() + temp;\n                    st_c.pop(); \n                }\n                st_c.pop();\n                for(int j=0;j<st_num.top();++j)\n                {\n                    for(int k=0;k<temp.size();++k)\n                    {\n                        st_c.push(temp[k]);\n                    }\n                }\n                st_num.pop();\n            }\n            else\n            {\n                st_c.push(s[i]);\n            }\n        }\n        string res=\"\";\n        while(!st_c.empty())\n        {    \n            res = st_c.top() + res;\n            st_c.pop();\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435702529","body":"```\nclass MyQueue {\n    stack<int> in;\n    stack<int> out;\npublic:\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        in.push(x);\n    }\n    \n    int pop() {\n        int temp;\n        if(out.empty())\n        {\n            while(!in.empty())\n            {\n                temp = in.top();\n                in.pop();\n                out.push(temp);\n            }\n        }\n        temp = out.top();\n        out.pop();\n        return temp;\n    }\n    \n    int peek() {\n        int temp;\n        if(out.empty())\n        {\n            while(!in.empty())\n            {\n                temp = in.top();\n                in.pop();\n                out.push(temp);\n            }\n        }\n        temp = out.top();\n        return temp;\n    }\n    \n    bool empty() {\n        return in.empty()&&out.empty();\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436034279","body":"```\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head==NULL)\n            return NULL;\n        ListNode* temp = head;\n        int len = 1;\n        while(temp->next!=NULL)\n        {    \n            temp = temp->next;\n            ++len;\n        }\n        temp->next = head;\n        int step = len - k%len;\n        while(--step)\n            head = head->next;\n        temp = head->next;\n        head->next = NULL;\n        return temp;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438592570","body":"```\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* pre = new ListNode(0,head);\n        ListNode* first = pre;\n        ListNode* second = pre->next;\n        while(second&&second->next)\n        {\n            ListNode* temp = second->next->next; \n            first->next = second->next;\n            first->next->next = second;\n            second->next = temp;\n            first = second;\n            second = temp;\n        }\n        return pre->next;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzhilin":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428529645","body":"### 思路\r\n类似计算加法的逻辑。从个位开始遍历num计算的时候，用k作为carry over的数字。最后如果还有剩余的carry数字，加到res中。\r\n\r\n### 代码\r\n```python\r\nclass Solution: \r\n\tdef addToArrayForm(self, num: List[int], k: int) -> List[int]: \r\n\t\tn = len(num) \r\n\t\tcarry = total = 0 \r\n\t\tres = [] \r\n\t\ti = len(num)-1 # track digits in num \r\n\t\twhile i >= 0 or k != 0: \r\n\t\t\tx = num[i] if i >= 0 else 0 # last digit in num \r\n\t\t\ty = k % 10 if k != 0 else 0 # last digit in k \r\n\t\t\ttotal = x + y + carry \r\n\t\t\tcarry = total // 10 \r\n\t\t\tk = k // 10 # remove last digit from k \r\n\t\t\ti -= 1 \r\n\t\t\tres.append(total % 10) \r\n\t\t\t\r\n\t\tif carry != 0: \r\n\t\t\tres.append(carry) \r\n\t\treturn res[::-1]\r\n```\r\n\r\n**复杂度分析**\r\n- 时间: O(N), n is max number of digits in num or k\r\n- 空间: O(N), n is number of digits we processed in the while loop and the space in the res array","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430710786","body":"### 思路\nfirst pass left to right to calculate distance between last index of c (prev) and current index of element i, save answer to arr.\nsecond pass right to left to calculate distance between current i and last index of c.\ncompare with saved answers to find minimum\n\n### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n        prev = float('-inf')\n        ans = []\n        for i, ele in enumerate(s):\n            if ele == c:\n                prev = i\n            ans.append(i - prev)\n\n        prev = float('inf')\n        for i in range(len(s)-1, -1, -1):\n            if s[i] == c:\n                prev = i\n            ans[i] = min(prev - i, ans[i])\n\n        return ans\n```\n\n**复杂度分析**\n时间: O(n) all elements in s\n空间: O(n) ans array","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1434027418","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxsize = maxSize\n        \n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxsize:\n            self.stack.append(x)\n\n        \n\n    def pop(self) -> int:\n        if self.stack:\n            pop = self.stack.pop()\n            return pop\n        else:\n            return -1\n        \n\n    def increment(self, k: int, val: int) -> None:\n        if k < len(self.stack):\n            for i in range(k):\n                print(self.stack)\n                self.stack[i] = self.stack[i]+val\n        else:\n            for i in range(len(self.stack)):\n                self.stack[i] = self.stack[i]+val\n        \n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1433571424","body":"### 思路\r\n类似basic calculator系列，创建空stack st和空string cur_str，从左到右遍历s。如果当前遍历的是数字，用一个temporary variable num存下来。如果是左括号，把当前repeat num和cur str加进stack，reset num和cur str。遇到右括号pop stack，根据存下来的数字复制cur str并存进cur str里。如果是普通character，直接存进cur str。\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        st = []\r\n        cur_str = \"\"\r\n        num = 0\r\n        for c in s:\r\n            if c.isdigit():\r\n                num = 10*num\r\n                num += int(c)\r\n            elif c == '[':\r\n                st.append((cur_str, num))\r\n                cur_str = ''\r\n                num = 0\r\n            elif c ==']':\r\n                s, val = st.pop()\r\n                cur_str = s + val * cur_str\r\n            else:\r\n                cur_str += c\r\n        return cur_str\r\n```\r\n\r\n**复杂度分析**\r\n时间：O(n),itereated over s\r\n空间：O(max depth) aka O(n), stack","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437535008","body":"### 思路\r\nFirst we need to get the length of linkedlist to calculate actual amount to rotate.\r\nThen if list length is less than k, we modulate k by length to have the actual rotation amount.\r\nwe will make the list in cycle to make rotation easier.\r\nThen we need to find new head, which means we need to get the node at length-k-1's position (new tail) through iteration and get new head (length - k). Afterwards we set tail.next to None.\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return None\r\n        length = 1\r\n        last = head\r\n        \r\n        while (last.next):\r\n            last = last.next\r\n            length += 1\r\n\r\n        last.next = head\r\n        k = k % length\r\n        first = head\r\n        for i in range(length-k-1):\r\n            first = first.next\r\n        newhead = first.next\r\n        first.next = None\r\n\r\n        return newhead\r\n```\r\n\r\n**复杂度分析**\r\ntime: O(n) iterate through list\r\nspace: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437500021","body":"### 思路\nuse a dummy head and prev to save the node before swapping, then swap the two nodes on the go iteratively.\n\n1. setup dummy head\n2. swap first node and second node\n3. move the pointers by updating head node and prev\n\n### 代码\n\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dh = ListNode(-1)\n        dh.next = head\n        prev = dh\n\n        while head != None and head.next != None:\n            first = head\n            second = head.next\n\n            prev.next = second\n            first.next = second.next\n            second.next = first\n\n            prev = first\n            head = first.next\n\n        return dh.next\n```\n\n**复杂度分析**\ntime: O(n), iterate over the linkedlist with n nodes\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439008937","body":"### 思路\nWe first need to find the middle node in the linkedlist (root node). Initiate slow and fast pointers to find the mid point. Because it's a sorted linkedlist, we want the mid point as well as the two halves. So also initiate a prev ptr that points to one node before slow in order to help us break the linkedlist into half later. After we have the mid node, construct root tree node and check if the mid node is the same as head, which means that mid is the only node in the linkedlist thus we can return the tree node. If mid is not the only node, we recursively construct the left and right subtrees by passing them into the function.\n\n### 代码\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        # use 2 pointers to get middle node in ll\n        fast = slow = head\n        # save a reference to break list later\n        prev = None\n        \n        # find middle element in ll (rootnode)\n        while fast and fast.next:\n            fast = fast.next.next\n            prev = slow\n            slow = slow.next\n\n        # separate linkedlist into half\n        if prev:\n            prev.next = None\n\n        # construct root node\n        root = TreeNode(slow.val)\n\n        # check if there's only one element in ll (base case)\n        if slow == head:\n            return root\n\n        # recursively construct left and right subtrees\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n\n        return root\n```\n\n**复杂度分析**\nTime: O(NlogN) we find middle of the linkedlist in every recursive step, which means n/2 number of nodes every time and get mid takes O(N) time.\nSpace: O(logN) because the heightbalanced binary search tree has logN height and adding one node in each recursive call takes O(1) space, it ends up as O(LogN) overall","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yfu6":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428552417","body":"1. My main purpose is to divide this problem into a simple adding and spliting problem. We can start with the smallest one, for example: [1, 0, 0] and 123. We use the last '0' to add the 123, and then divide it by 10 and leave the remainer. The last element of the list will be changed from 0 to 3, meanwhile, we will add the '0' with 120. We do the divide part again and again. In the end, we have walk through all the elements of the num list. If there is still k value, we will do the other iterate to add the new list element to num.\n2. class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        for i in range(len(num) - 1, -1, -1):\n            if not k: break\n            k, num[i] = divmod(num[i] + k, 10)\n            # returns the quotient and remainder of （num[i] + k） / 10\n        while k:\n            k, a = divmod(k, 10)\n            num = [a] + num\n        return num\n3. The time and space complexity is O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430471180","body":"``\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        a,n=[],len(s)\n        for i in range(n):\n            if s[i]==c:\n                a.append(i)\n        answer=[]\n        j=0\n        for i in range(n):\n            if s[i]==c:\n                answer.append(0)\n                j+=1\n            elif i<a[0]:\n                answer.append(a[0]-i)\n            elif i>a[-1]:\n                answer.append(i-a[-1])\n            else:\n                answer.append(min((a[j]-i),(i-a[j-1])))\n        return answer\n``","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432089783","body":"```python\n# 1.  Use simple python push and pop function to solve the Problem\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = []\n        self.maxSize = maxSize\n\n\n    def push(self, x: int) -> None:\n        if len(self.stk) < self.maxSize:\n            self.stk.append(x)\n\n\n    def pop(self) -> int:\n        if not self.stk: return -1\n        return self.stk.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i < len(self.stk):\n                self.stk[i] += val\n```\n3. The Time: O(k)\nSpace: O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1433601834","body":"1. The probem can be solved by creating a stack to store the repeat string and the number to repeat. We will loop each character in the string to store the information and compute the final result.\n2.\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        cur_num = cur_str = ''\n        for c in s:\n            if c == '[':\n                stack.append(cur_str)\n                stack.append(int(cur_num))\n                cur_num = cur_str = ''\n            elif c == ']':\n                num = stack.pop()\n                prev_str = stack.pop()\n                cur_str = prev_str + cur_str * num\n            elif c.isdigit():\n                cur_num += c\n            else:\n                cur_str += c\n        return cur_str\n```\n3. Both O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435079362","body":"1. We can use python's append and pop function to build a stack and implement these functions.\n2 Code:\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.arr=[]\n    \n    def push(self, x: int) -> None:\n        self.arr.append(x)\n\n    def pop(self) -> int:\n        return self.arr.pop(0)\n\n    def peek(self) -> int:\n        return self.arr[0]\n        \n\n    def empty(self) -> bool:\n        return not self.arr\n```\n3. Time and Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435917825","body":"1. Use stack to store the number and compare the max value to return the result\n2. Code:\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            largest = num\n            while stack and stack[-1] > num:\n                largest = max(largest, stack.pop())\n            stack.append(largest)\n        return len(stack)\n```\n3.  O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436059651","body":"1. Use the n - k % n - 1 to calculate the new ring tail with the old ring head\n2. \n```python\nclass Solution:\n    def rotateRight(self, head: 'ListNode', k: 'int') -> 'ListNode':\n        if not head:\n            return None\n        if not head.next:\n            return head\n\n        old_tail = head\n        n = 1\n        while old_tail.next:\n            old_tail = old_tail.next\n            n += 1\n        old_tail.next = head\n        \n        new_tail = head\n        for i in range(n - k % n - 1):\n            new_tail = new_tail.next\n        new_head = new_tail.next\n        \n        new_tail.next = None\n        \n        return new_head\n```\n3.O(n)\nO(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1440511224","body":"```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        B = set()\n\n        while headB is not None:\n            B.add(headB)\n            headB = headB.next\n\n        while headA is not None:\n            if headA in B:\n                return headA\n            headA = headA.next\n\n        return None\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mengsixing":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428927200","body":"var addToArrayForm = function(num, k) {\n    let result = []\n    for(let i=num.length-1;i>=0;i--){\n        let sum = num[i] + k % 10;\n        k = Math.floor(k/10);\n        if(sum >=10){\n            sum-=10;\n            k++;\n        }\n        result.push(sum)\n    }\n    while(k > 0){\n        result.push(k % 10);\n        k = Math.floor(k/10);\n    }\n    return result.reverse();\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431464685","body":"```js\nvar shortestToChar = function(s, c) {\nlet result = Array.from(s).fill(0);\nlet idx = -s.length;\nfor(let i=0;i<s.length;i++){\n    if(s[i]=== c){\n        idx = i;\n    }\n    result[i] = i-idx;\n}\n\nidx =s.length * 2;\nfor(let i=s.length-1;i>=0;--i){\n    if(s[i]=== c){\n        idx = i;\n    }\n    result[i] = Math.min(idx-i,result[i]);\n}\n\nreturn result\n\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438503295","body":"```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode pre = new ListNode(0);\n        pre.next = head;\n        ListNode temp = pre;\n        while(temp.next != null && temp.next.next != null) {\n            ListNode start = temp.next;\n            ListNode end = temp.next.next;\n            temp.next = end;\n            start.next = end.next;\n            end.next = start;\n            temp = start;\n        }\n        return pre.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439277735","body":"```js\nvar sortedListToBST = function(head) {\n    let arr = [];\n    let child = head;\n    while(child){\n        arr.push(child.val);\n        child = child.next;\n    }\n\n    function buildTree(arr,start,end){\n        if(start>end){\n            return null;\n        }\n        if(end  === start){\n            return new TreeNode(arr[start],null,null);\n        }\n        if(end-start===1){\n            const root = new TreeNode(arr[end],null,null);\n            root.left = new TreeNode(arr[start],null,null);\n        }\n\n        const mid = Math.floor((start+end)/2);\n        const root = new TreeNode(arr[mid],null,null);\n        root.left = buildTree(arr,start,mid-1);\n        root.right = buildTree(arr,mid+1,end);\n        return root;\n    }\n\n    return buildTree(arr,0,arr.length-1);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441086287","body":"```js\nvar getIntersectionNode = function(headA, headB) {\n    var h1 = headA;\n    var h2 = headB;\n    while(h1 != h2){\n        h1 = h1 == null ? headB : h1.next;\n        h2 = h2 == null ? headA : h2.next;\n    }\n    return h1\n   \n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"import-ant":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428956544","body":"\n\n## 思路\n将k转化为数组，然后数组k和数组num遍历，按位相加。\n- 加数1：k[j]\n- 加数3：num[i]\n- 进位：c\n- **结果result**:(k[j]+num[i]+c) % 10\n-  **下一个进位** ：Math.floor(result / 10)\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    //利用数组 字符串api (大数超出的风险)\n    // return (+num.join('')+k + '').split('');\n\n    //将k转化成数组，遍历num做加法运算。\n    k = (k+'').split('');\n    const length1 = num.length;\n    const length2 = k.length;\n    let i = length1-1,j=length2-1,c=0,result = [];\n    while(i >= 0 || j >= 0){\n        const add1 = i >= 0 ? num[i] : 0;\n        const add2 = j >= 0 ? +k[j] : 0;\n        const sum = add1 + add2 + c;\n        c = Math.floor(sum / 10);\n        result.unshift(sum % 10);\n        i --;\n        j --;\n    }\n    if(c != 0){\n        result.unshift(c);\n    }\n    return result\n};\n\n```\n\n\n**复杂度分析**\n令 n 为Math.max(k.length,num.length)。\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431234199","body":"\n\n## 思路\n- 将数组s中字符c出现的索引放到一个临时数组中。\n- 遍历数组s，对于s中的每个元素，遍历存放索引的临时数组，去找abs(temp(j)-i)最小的那个值。\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    const length = s.length;\n    const answer = new Array(length).fill(0);\n    const temp = [];\n    for(let i = 0;i < length;i ++){\n        if(s[i] == c){\n            temp.push(i);\n        }\n    }\n    for(let i = 0;i < length;i ++){\n        let t = Infinity\n        for(let j = 0;j < temp.length;j ++){\n            t = Math.min(Math.abs(temp[j]-i),t);\n        }\n        answer[i] = t;\n    }\n    return answer;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。k为数组中字符c的数量\n\n- 时间复杂度：$O(n*k)$\n- 空间复杂度：$O(k)$ ，忽略结果数组\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432342758","body":"\n## 思路\n- 增量数组，前缀和思想\n- 先记录增加的值，在pop的时候加上该增加的值。\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = [];\n    this.maxSize = maxSize;\n    //记录增量\n    this.add = new Array(maxSize).fill(0);\n    this.size = 0;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.size < this.maxSize){\n        this.stack[this.size] = x;\n        this.size ++;\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.size == 0){\n        return -1;\n    }\n    if(this.size >= 2){\n        this.add[this.size-2] += this.add[this.size-1];\n    }\n    const num = this.stack[this.size-1] + this.add[this.size-1];\n    this.add[this.size-1] = 0;\n    this.size --;\n    return num;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const num = Math.min(k,this.size);\n    this.add[num-1] += val;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n**复杂度分析**\n\n令 maxSize 为栈最大长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(maxSize)$ 增量数组\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joriscai":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1428969365","body":"# 思路\n先将k转成数组，再利用双指针分别从k和num的最后一位开始按位计算。注：需要考虑最后一次进位的情况。\n\n# 代码\njavascript\n\n```javascript\n/*\n * @lc app=leetcode.cn id=989 lang=javascript\n *\n * [989] 数组形式的整数加法\n */\n\n// @lc code=start\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n  const kArr = (k + '').split('')\n  let temp = 0\n  const ret = []\n  let i = num.length - 1\n  let j = kArr.length - 1\n  while(i >= 0 || j >= 0) {\n    const sum = (num[i] || 0) + parseInt(kArr[j] || 0) + temp\n    ret.unshift(sum % 10)\n    temp = parseInt(sum / 10)\n    i--\n    j--\n  }\n  if (temp) {\n    ret.unshift(temp)\n  }\n\n  return ret\n};\n// @lc code=end\n\n```\n\n# 复杂度分析\n时间复杂度：O(max(n, log k))，其中 n 为数组的长度。log k为k的位，即log 10(k)，10为底k的对数。\n空间复杂度：O(max(n, log k))。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1433309147","body":"# 思路\n- 先正序遍历数组，找目标字符跟右边元素的距离\n- 再反序遍历数组，找目标字符与左边元素的距离，同时取两次距离的最小值\n\n# 代码\njavascript\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n  let dis = Infinity\n  const ret = []\n  for (let i = 0; i < s.length; i++) {\n    const cur = s[i]\n    if (cur === c) {\n      dis = 0\n    } else {\n      dis++\n    }\n    ret.push(dis)\n  }\n\n  for (let i = s.length - 1; i >= 0; i--) {\n    const cur = s[i]\n    if (cur === c) {\n      dis = 0\n    } else {\n      dis++\n    }\n    ret[i] = Math.min(dis, ret[i])\n  }\n\n  return ret\n};\n\n```\n\n# 复杂度分析\n- 时间复杂度：O(n)，需要遍历两次数组，正序和反序\n- 空间复杂度：O(n)，返回结果的大小","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433304413","body":"# 思路\n- push方法要限制超过长度时不入栈\n- pop方法为了让所有操作都为O(1)的话，在出栈时再进行增加操作\n  - 出栈时要取出对应的增加值，并与栈顶值相加\n  - 由于数据出栈了，对应位置的加值无用，故对应位置的加值设为0，即默认值\n  - 由于inc方法的k是指栈底的 k 个元素，故此时下一位的加值要加上此次取出的加值，inc方法是栈底k个元素都增加val。\n- increment方法在对应的位置累加上加值即可 O(1)\n\n# 代码\njavascript\n\n```javascript\n/*\n * @lc app=leetcode.cn id=1381 lang=javascript\n *\n * [1381] 设计一个支持增量操作的栈\n */\n\n// @lc code=start\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.size = maxSize\n  this.stack = []\n  this.add = []\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length < this.size) {\n    this.stack.push(x)\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  // 方法一\n  // return this.stack.pop() || -1\n\n  // 方法二\n  const len = this.stack.length\n  if (len === 0) {\n    return -1\n  }\n\n  const add = this.add[len] || 0\n  // 由于只记录当前栈顶的增加值\n  // 故要更新下一个栈顶\n  this.add[len - 1] = this.add[len - 1] || 0\n  this.add[len - 1] += add\n  // 出栈后，对应位置的增加值无用，重置为0\n  this.add[len] = 0\n\n  const curr = this.stack.pop()\n\n  return curr + add\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  // 方法一\n  // const len = Math.min(this.stack.length, k)\n  // for (let i = 0; i < len; i++) {\n  //   this.stack[i] += val\n  // }\n\n  // 方法二\n  const index = Math.min(this.stack.length, k)\n  this.add[index] = this.add[index] || 0\n  this.add[index] += val\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n// @lc code=end\n\n```\n\n# 复杂度分析\n- 时间复杂度：O(1)，三个方法都是O(1)\n- 空间复杂度：O(n)，一个栈空间和一个加值存放空间，两个都是n的长度","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436016562","body":"# 思路\n- 哈希表\n- 一段区间内，若原数组的总和与排序后的数组的总和相等，则说明该区间排序后所在的位置与全部排序后相对应\n- 判断可以分块后，故要将重新保持一致，找下一个分块\n\n# 代码\njavascript\n\n```javascript\n/*\n * @lc app=leetcode.cn id=768 lang=javascript\n *\n * [768] 最多能完成排序的块 II\n */\n\n// @lc code=start\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n  const sortArr = [...arr].sort((a, b) => a - b)\n  let sum1 = 0\n  let sum2 = 0\n  let count = 0\n  for (let i = 0; i < arr.length; i++) {\n    // 判断原数组与排序后的数组的总和是否一样\n    sum1 += arr[i]\n    sum2 += sortArr[i]\n    // 若一样，则说明当前区间可以排序最终的结果，可以分块\n    if (sum1 === sum2) {\n      count += 1\n      // 由于已经分块，故要将重新保持一致，找下一个分块\n      // 其实两个结果都相等才能成立分块，已经保持一致了，下面的可不用置零\n      // 考虑到可以溢出的问题，建议设置为零\n      sum1 = 0\n      sum2 = 0\n    }\n  }\n  return count\n};\n// @lc code=end\n\n```\n\n# 复杂度分析\n- 时间复杂度：O(NlogN)，只遍历一次数组，但是数组的排序更加耗时，数组排序大概是O(NlogN)\n- 空间复杂度：O(N)，用了三个变量，还有存放排序后的数组，故为O(N)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441117243","body":"# 思路\n- 当不相交部分的长度一样时，故两个指针同时前进，最终相遇\n- 当不相交部分的长度不一致时，可使用双指针消除不相交部分的长度差\n  - 两指针分别从a,b链表头节点开始，同时前进\n  - 当有一个指针走到尾节点时，改成指向另一个链表\n  - 当两个指针都进行了交换时，此时链表的长度差消除\n  - 即可以当成不相交部分长度一致了，同时前进最终会相遇\n# 代码\njavascript\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    if (!headA || !headB) return null\n    let curA = headA\n    let curB = headB\n    while (curA !== curB) {\n        curA = curA ? curA.next : headB\n        curB = curB ? curB.next : headA\n    }\n\n    return curA\n};\n```\n\n# 复杂度分析\n- 时间复杂度：O(n)，每个链表最多被遍历两次，即2*n次，n = lenA + lenB\n- 空间复杂度：O(1)，只用了常数空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangqianqian202301":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429058772","body":"##### 思路\n可理解为三个数相加， 记为first, second, third, 只要有任何一个数不为0， 则需要循环\n##### 代码\n```py\nfrom typing import List\ndef addNumber(arr: List, num: int):\n    third = 0\n    index = len(arr) - 1\n    while num != 0 or index >= 0 or third > 0:\n        if index < 0:\n            arr.insert(0, 0)\n            index = 0\n        second = num % 10\n        first = arr[index]\n        arr[index] = (first + second + third) % 10\n        third = (first + second + third) // 10\n        index = index - 1\n        num = num // 10\n\n    return arr\n\nprint(addNumber([1, 2, 1], 89))\nprint(addNumber([1, 2, 1], 890))\n            \n```\n##### 算法复杂度\n- 时间复杂度O(n)\n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430808614","body":"##### 思路\n使用两个变量存储要查找的字符的位置，取距离两个字符的最小者\n##### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        length = len(s)\n        lIndex = -length\n        rIndex = s.index(c)\n        rtnArr = [0 for i in range(length)]\n        for i in range(len(s)):\n            if s[i] == c:\n                lIndex, rIndex = rIndex, i\n                for j in range(lIndex + 1, rIndex):\n                    rtnArr[j] = min(abs(j - lIndex), abs(j - rIndex))\n\n            else:\n                rtnArr[i] = min(abs(i - lIndex), abs(i - rIndex))\n        return rtnArr\n```\n##### 复杂度\nO(mn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432761016","body":"##### 思路\n使用一个数组，一个index, index指向最新数据\n##### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.data = [None] * maxSize\n        self.index = -1\n\n    def push(self, x: int) -> None:\n        if (self.index + 1) < self.maxSize:\n            self.index = self.index + 1\n            self.data[self.index] = x\n\n    def pop(self) -> int:\n        if self.index >= 0:\n            self.index = self.index - 1\n            return self.data[self.index + 1]\n        else:\n            return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        to = min(k - 1, self.index)\n        for i in range(0, to + 1):\n            self.data[i] = self.data[i] + val\n\n```\n##### 复杂度\nO(1)\nO(1)\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434235254","body":"##### 思路\n使用两个stack, 一个存原始数据， 一个存局部数据\n##### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        res = \"\"\n        seg = \"\"\n        stack = []\n        segStack = []\n        index = 0\n        while (index + 1) <= len(s):\n            c = s[index]\n            if c != ']':\n                stack.append(c)\n            else:\n                repeatStr = \"\"\n                while stack[-1] != '[':\n                    if stack[-1] == '#':\n                        stack.pop()\n                        repeatStr = segStack.pop() + repeatStr\n                    else:\n                        repeatStr = stack.pop() + repeatStr\n                stack.pop()\n                times = \"\"\n                while len(stack) > 0 and stack[-1].isdigit():\n                    times = stack.pop() + times\n                seg = \"\"\n                for i in range(int(times)):\n                    seg = repeatStr + seg\n                if len(stack) == 0:\n                    res = res + seg\n                else:\n                    stack.append('#')\n                    segStack.append(seg)\n                seg = \"\"\n\n            index = index + 1\n        temp = \"\"\n        while len(stack) > 0:\n            if stack[-1] == '#':\n                stack.pop()\n                temp = segStack.pop() + temp\n            else:\n                temp = stack.pop() + temp\n\n        return res + temp\n\n```\n##### 时间复杂度\nO(nm)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435457615","body":"##### 思路\nstack1用于push, stack2用于pop\n如果stack2没有元素pop, stack1中的全部元素弹出到stack2中\n##### 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if len(self.stack2) == 0:\n            length = len(self.stack1)\n            for i in range(length):\n                self.stack2.append(self.stack1.pop())\n        if len(self.stack2) == 0:\n            return None\n        else:\n            return self.stack2.pop()\n        \n\n    def peek(self) -> int:\n        peekEle = self.pop()\n        if peekEle is not None:\n            self.stack2.append(peekEle)\n        return peekEle\n\n    def empty(self) -> bool:\n        return len(self.stack1) == 0 and len(self.stack2) == 0\n```\n\n##### 复杂度\npush O(1)\npop O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435996892","body":"##### 思路\n如果可以分成多块，那么前一块中的最大指小于下一块的最小值\n遍历这个列表，碰到比当前值小，则与前面各块最大值比较，确定是否合并\n碰到比当前值大或者相等，记作一块\n##### 代码\n```python\nfrom typing import List\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        leftMaxArr = []\n        leftMaxEle = (0, arr[0])\n        for i in range(1, len(arr)):\n            if leftMaxEle[1] <= arr[i]:\n                leftMaxArr.append(leftMaxEle)\n                leftMaxEle = (i, arr[i])\n            else:\n                while leftMaxArr and leftMaxArr[-1][1] > arr[i]:\n                    leftMaxArr.pop()\n                if leftMaxArr:\n                    leftMaxEle = (i, leftMaxEle[1])\n        leftMaxArr.append(leftMaxEle)\n        return len(leftMaxArr)\n\n```\n##### 复杂度分析\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436441566","body":"##### 思路\n把列表做成一个环，走length - k步， 就是新的头结点\n##### 代码\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0:\n            return head\n        if not head:\n            return None\n        temp = head\n        length = 1\n        while temp.next :\n            length = length + 1\n            temp = temp.next\n        k = k % length\n        if k == 0:\n            return head\n        temp.next = head\n\n        step = length - k\n        temp = head\n        while step > 1:\n            temp = temp.next\n            step = step - 1\n        head = temp.next\n        temp.next = None\n\n        return head\n```\n##### 复杂度\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437810938","body":"##### 思路\n使用两个变量， 一个pre, 一个left结点实现两两逆转\n##### 代码\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None or head.next is None:\n            return head\n\n        pre = ListNode()\n        pre.next = head\n        left = head\n        head = pre\n        while left is not None and left.next is not None:\n            pre.next = left.next\n            left.next = left.next.next\n            pre.next.next = left\n            pre = left\n            left = left.next\n        pre = None\n\n        return head.next\n```\n##### 复杂度\nO(n)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439519838","body":"##### 思路\n1. 选中中间结点\n2. 递归设置左结点和右结点\n##### 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if head is None or head.next is None:\n            return head\n\n        length = 0\n        temp = head\n        while temp is not None:\n            length = length + 1\n            temp = temp.next\n        return self.list2Tree(head, length)\n\n    def list2Tree(self, head: Optional[ListNode], length: int) -> Optional[TreeNode]:\n        if length <= 1:\n            return TreeNode(head.val, None, None)\n        middle = (length - 1) // 2\n        temp = head\n        tempMiddle = middle\n        while tempMiddle > 0:\n            temp = temp.next\n            tempMiddle = tempMiddle - 1\n\n        root = TreeNode(temp.val, None, None)\n        if middle > 0:\n            root.left = self.list2Tree(head, middle) \n\n        root.right = self.list2Tree(temp.next, length - middle - 1) \n\n        return root\n\n```\n\n##### 复杂度\n?","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441186594","body":"##### 思路\n先找出长度差异 ， 再循环比较 \n##### 代码\n```python\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if headA == headB:\n            return headA\n        if headA is None or headB is None:\n            return None\n        tempA = headA\n        tempB = headB\n        while True:\n            tempA = tempA.next;\n            tempB = tempB.next;\n            if tempA == tempB:\n                return tempA\n            if tempA is None:\n                tempA = headA\n                break\n            if tempB is None:\n                tempB = headB\n                break\n        if tempA == headA:\n            while tempB:\n                tempB = tempB.next\n                headB = headB.next\n            tempB = headB\n        else:\n            while tempA:\n                tempA = tempA.next\n                headA = headA.next\n            tempA = headA\n\n        while tempA:\n            if tempA == tempB:\n                return tempA\n            tempA = tempA.next\n            tempB = tempB.next\n\n        return None\n\n\n```\n##### 复杂度\nO(m + n)\nO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"airwalkers":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429071130","body":"```java\n// 思路，类似与归并排序，num数组末尾与k末尾数字相加，记录进位carray，插入到列表头\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> sum = new LinkedList<>();\n        int i = num.length - 1;\n        int carry = 0;\n        while (i >= 0 || k > 0) {\n            if (i >= 0) {\n                carry += num[i--];\n            }\n            if (k > 0) {\n                carry += k%10;\n                k /= 10;\n            }\n            sum.addFirst(carry % 10 );\n            carry /= 10;\n        }\n        if (carry > 0) {\n            sum.addFirst(carry);\n        }\n        return sum;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431007168","body":"```java\n// 思路，从左向右扫描记录左侧最近下标入left数组，\n// 从右向左扫描右侧最近下标入right数组\n// 根据left，right数组以及i计算最近结果\n\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] chars = s.toCharArray();\n        int[] left = new int[chars.length];\n        int[] right = new int[chars.length];\n\n        for (int i = 0, pre = -1; i < chars.length; i++) {\n            if (chars[i] == c) {\n                pre = i;\n            }\n            left[i] = pre;\n        }\n\n        for (int i = chars.length - 1, pre = -1; i >= 0; i--) {\n            if (chars[i] == c) {\n                pre = i;\n            }\n            right[i] = pre;\n        }\n\n        int[] res = new int[chars.length];\n        for (int i = 0; i < chars.length; i++) {\n            if (left[i] == -1) {\n                res[i] = right[i] - i;\n            } else if (right[i] == -1) {\n                res[i] = i - left[i];\n            } else {\n                res[i] = Math.min(i - left[i], right[i] - i);\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432451659","body":"```java\n// 思路，数组模拟栈，增加一个差分数组记录栈底k个数字需要累加的值\n// 复杂度，push O(1)，pop O(1)，increment O(1)\n\nclass CustomStack {\n    int[] stack;\n    int[] acc;\n    int maxSize;\n    int i;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.acc = new int[maxSize];\n        this.maxSize = maxSize;\n        this.i = 0;\n    }\n    \n    public void push(int x) {\n        if (i < maxSize) {\n            stack[i++] = x;\n        }\n    }\n    \n    public int pop() {\n        if (i == 0) {\n            return -1;\n        }\n        --i;\n        if (i - 1 >= 0) {\n            acc[i - 1] += acc[i];\n        }\n        stack[i] += acc[i];\n        acc[i] = 0;\n        return stack[i];\n    }\n    \n    public void increment(int k, int val) {\n        if (i > 0) {\n            acc[Math.min(k - 1, i - 1)] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1437795687","body":"```java\r\n // [ push\r\n // ] pop\r\n // num or letter, append peek\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        char[] str = s.toCharArray();\r\n        Deque<StringBuilder> stack = new LinkedList<>();\r\n        stack.push(new StringBuilder());\r\n\r\n        for (char c : str) {\r\n            if (c == '[') {\r\n                stack.push(new StringBuilder());\r\n            } else if (c >= 'a' && c <= 'z') {\r\n                stack.peek().append(c);\r\n            } else if (c >= '0' && c <= '9') {\r\n                stack.peek().append(c);\r\n            } else if (c == ']') {\r\n                StringBuilder letters = stack.pop();\r\n                StringBuilder peek = stack.peek();\r\n                int k = getK(peek);\r\n                while (k > 0) {\r\n                    peek.append(letters);\r\n                    --k;\r\n                }\r\n            }\r\n        }\r\n\r\n        return stack.peek().toString();\r\n    }\r\n\r\n    private int getK(StringBuilder s) {\r\n        if (s.length() == 0) {\r\n            return 1;\r\n        }\r\n        int k = 0;\r\n        for (int i = s.length() - 1, b = 1; i >= 0 && s.charAt(i) >= '0' && s.charAt(i) <= '9'; i--) {\r\n            char c = s.charAt(i);\r\n            s.deleteCharAt(i);\r\n            k += b * (c - '0');\r\n            b *= 10;\r\n        }\r\n        return k == 0 ? 1 : k;\r\n    }\r\n}\r\n```","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437982956","body":"```java\npublic ListNode swapPairs(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        \n        ListNode pre = new ListNode();\n        pre.next = head;\n        ListNode p = pre, q = p.next;\n        while (q != null && q.next != null) {\n            ListNode r = q.next;\n            ListNode next = r.next;\n            r.next = q;\n            q.next = next;\n            p.next = r;\n            p = q;\n            q = next;\n        }\n        return pre.next;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439729876","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\n// 1 ->  2 -> null\n// p     s     f\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        // 0 结点\n        if (head == null) {\n            return null;\n        }\n        // 1 结点\n        if (head.next == null) {\n            return new TreeNode(head.val);\n        }\n        // ≥2 结点\n        ListNode prev = head;\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        // dfs\n        TreeNode root = new TreeNode(slow.val);\n        prev.next = null;\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(slow.next);\n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441168021","body":"```java\n// 思路，找到两条链路的长度差，从长的那一条先走，走到补齐的位置时两条链路同时遍历，直到找到第一个相同的节点\n\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int lenA = 0;\n        ListNode p = headA;\n        while (p != null) {\n            lenA++;\n            p = p.next;\n        }\n\n        int lenB = 0;\n        p = headB;\n        while (p != null) {\n            lenB++;\n            p = p.next;\n        }\n\n        p = headA;\n        ListNode q = headB;\n        while (lenA > lenB) {\n            p = p.next;\n            lenA--;\n        }\n        while (lenB > lenA) {\n            q = q.next;\n            lenB--;\n        }\n        while (p != null && p != q) {\n            p = p.next;\n            q = q.next;\n        }\n        return p;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhumengcheng":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429106157","body":"```javascript\r\n思路,末位数相加,超10进1,直接添加到数组的首位,如果是10则添加0,如果大于10取余数,\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  let i = num.length - 1;\r\n  let ys = 0;\r\n  let res = [];\r\n  while (i >= 0 || k > 0) {\r\n    let x = i >= 0 ? num[i] : 0;\r\n    let y = k % 10;\r\n    k = Math.floor(k / 10);\r\n    ys = x + y;\r\n    if (ys >= 10) {\r\n      if (ys == 10) {\r\n        ys = 0;\r\n      } else {\r\n        ys = ys % 10;\r\n      }\r\n      k++;\r\n    }\r\n    i--;\r\n    res.unshift(ys);\r\n  }\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n- 复杂度\r\n\r\n1. 时间复杂度：O(max⁡(n,log⁡k))，其中 nnn 为数组的长度。\r\n2. 空间复杂度：O(1)\r\n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431409149","body":"```javascript\r\n解题思路: 第一层循环判断出c字符串的位置,第二层循环判断当前字符距离目标字符的距离Math.abs(i - j)判断距离\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n  let len = s.length;\r\n  const res = new Array(len).fill(len);\r\n  for (let i = 0; i < len; i++) {\r\n    if (s.substring(i, i + 1) === c) {\r\n      for (let j = 0; j < len; j++) {\r\n        res[j] = Math.min(Math.abs(i - j), res[j]);\r\n      }\r\n    }\r\n  }\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n- 复杂度\r\n\r\n时间复杂度 O(n^2)\r\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433063870","body":"```javascript\r\n实现思路: 使用数组完成\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = new Array();\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.stack.length < this.maxSize) {\r\n    this.stack.push(x);\r\n  } else {\r\n    return;\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  return this.stack.length > 0 ? this.stack.pop() : -1;\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  let len = this.stack.length < k ? this.stack.length : k;\r\n  for (let i = 0; i < len; i++) {\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n\r\n```\r\n复杂度分析\r\n时间复杂度：O(1)\r\n空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434406149","body":"```javascript\r\n思路: 记录数字表示重复次数,记录括号内的字符为重复自负,次数和字符都单独存起来,如果没有数字和字符直接累加\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    // 重复次数\r\n    let repetStack=[];\r\n    // 重复字符串\r\n    let resStack=[];\r\n    // 拼接的字符串\r\n    let resStr = \"\";\r\n    // 当前字符的重复次数\r\n    let repet = 0;\r\n\r\n    for(let i=0;i<s.length;i++){\r\n        let cur = s.charAt(i);\r\n        if(cur == '['){\r\n            repetStack.push(repet);\r\n            resStack.push(resStr);\r\n            // 重置\r\n            repet = 0;\r\n            resStr = \"\";\r\n        }else if(cur == ']'){\r\n            let count = repetStack.pop();\r\n            // 根据重复次数生成重复字符串，给temp赋值，并和累积的字符串resStr拼接\r\n            let temp = \"\";\r\n            for(let i = 0;i<count;i++){\r\n                temp += resStr;\r\n            }\r\n            // 字符串拼接\r\n            resStr = resStack.pop() + temp;\r\n        }else if(cur>='0' && cur<='9'){\r\n            repet = repet*10 + (cur-'0');\r\n        }else{\r\n            resStr += cur;\r\n        }\r\n    }\r\n    return resStr;\r\n \r\n};\r\n```\r\n\r\n复杂度\r\n时间复杂度：O(s)\r\n空间复杂度：O(s)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kofzhang":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429132721","body":"### 思路\r\n1.将列表转成数值\r\n2.加上K\r\n3.转成列表\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        n = 0\r\n        for i in num:\r\n            n=n*10+i\r\n        s = n+k\r\n        res = []\r\n        for i in str(s):\r\n            res.append(int(i))\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430562184","body":"### 思路\r\n1.先找到所有字符位置，添加到一个列表里\r\n2.双指针，一个指向字符位置列表，一个指向原列表\r\n3.如果位置列表存在下一个位置，并且下一个位置到当前字符位置的绝对值小于当前位置到当前字符位置的绝对值，字符位置列表索引+1，并计算位置。否则以当前字符位置直接计算距离。\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        positions = [index for index,i in enumerate(s) if i==c]\r\n        res = []\r\n        p = 0\r\n        for index,i in enumerate(s):\r\n            if p<len(positions)-1 and abs(positions[p+1]-index)<abs(positions[p]-index):\r\n                p += 1                \r\n            res.append(abs(positions[p]-index))\r\n        return res\r\n                \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432719597","body":"### 思路\r\n两个列表分别记录数据和增量。\r\n当increment的时候，只记录位置和增量，pop时增量向下累加\r\n### 复杂度\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.data = [0]*maxSize\r\n        self.add = [0]*maxSize\r\n        self.cursor = -1\r\n\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cursor<self.maxSize-1:\r\n            self.cursor+=1\r\n            self.data[self.cursor]=x\r\n            self.add[self.cursor]=0\r\n            \r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.cursor==-1:\r\n            return -1\r\n        r = self.data[self.cursor]+self.add[self.cursor]\r\n        \r\n        if self.cursor>=1:\r\n            self.add[self.cursor-1]+=self.add[self.cursor]        \r\n        self.cursor-=1\r\n        return r\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.cursor<k:\r\n            k = self.cursor+1\r\n        self.add[k-1]+=val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434176805","body":"### 思路\r\n从右向左，有点烦\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        l = len(s) - 1\r\n        stack = []\r\n        while l >= 0:\r\n            t = s[l]\r\n            if t.isdigit():\r\n                numstack = []\r\n                while l >= 0 and s[l].isdigit():\r\n                    numstack.append(s[l])\r\n                    l -= 1\r\n\r\n                temp = []\r\n                stack.pop()\r\n                while (p := stack.pop()) != ']':\r\n                    temp.append(p)\r\n                c = ''.join(temp) * int(\"\".join(numstack[::-1]))\r\n                stack.append(c)\r\n            else:\r\n                stack.append(t)\r\n                l -= 1\r\n        return ''.join(stack[::-1])\r\n```\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435469313","body":"### 思路\r\n两个栈，instack和outstack\r\n每次入队列的时候放入instack。\r\n出队列的时候从outstack出。如果outstack没有数据了就把所有的instack的数据倒到outstack里。\r\n### 复杂度\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)\r\n### 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.instack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.outstack:\r\n            self.in2out()\r\n        return self.outstack.pop()\r\n\r\n    def in2out(self) -> None:        \r\n            while self.instack:\r\n                self.outstack.append(self.instack.pop())\r\n\r\n    def peek(self) -> int:\r\n        if not self.outstack:\r\n            self.in2out()\r\n        return self.outstack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        if self.instack or self.outstack:\r\n            return False\r\n        return True\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435939146","body":"### 思路\r\n单调栈，记录当前块的最大值。\r\n如果栈空，或者当前值大于最大值，就把它作为单独一块，放入栈。\r\n否则，合块。记录最大值，把栈中比当前值大的值全弹出。放入记录的最大值。\r\n结果是栈的长度。\r\n### 复杂度\r\nO(n)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for i in arr:\r\n            if not stack or stack[-1]<=i:\r\n                stack.append(i)\r\n            else:\r\n                m = stack[-1]\r\n                while stack and i<stack[-1]:\r\n                    stack.pop()\r\n                stack.append(m)\r\n        return len(stack)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436194556","body":"### 思路\r\n找出链表长度\r\n取一下模，然后向后走\r\n最后记得断开链表\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        dummy = head\r\n        l = 1\r\n        while head.next:\r\n            head = head.next\r\n            l += 1\r\n        \r\n        k = (l - k % l)%l\r\n        if k == 0 :\r\n            return dummy\r\n        head.next = dummy\r\n        head = dummy\r\n        while k > 1:   \r\n            head = head.next\r\n            k -= 1\r\n        res = head.next\r\n        head.next = None\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438008324","body":"### 思路\r\n模拟\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        \r\n        dummy = ListNode(-1,head)\r\n        left = dummy\r\n        cur = head\r\n        right = head.next\r\n        while cur and cur.next:\r\n            left.next = right\r\n            cur.next = right.next\r\n            right.next = cur\r\n            \r\n            left = cur\r\n            cur = cur.next\r\n            if cur and cur.next:\r\n                right = cur.next\r\n        return dummy.next\r\n            \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439278722","body":"### 思路\r\n快慢指针\r\n### 复杂度\r\n时间复杂度：O(nlogn)  //分治思想\r\n空间复杂度：O(1)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return head\r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n        slow = head\r\n        fast = head\r\n        slow_left = head\r\n        while fast and fast.next:\r\n            slow_left = slow\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n\r\n        right = slow.next\r\n        slow.next = None\r\n        slow_left.next=None\r\n        left = head\r\n        root = TreeNode(slow.val)\r\n        root.left = self.sortedListToBST(left)\r\n        root.right = self.sortedListToBST(right)\r\n        return root\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441305049","body":"### 思路\r\n这个题做过，印象很深刻，双指针，一个走A，一个走B\r\nA走完，走B。B走完，走A。\r\n两个指针同时走完了AB，那么没有交点。\r\n如果没走完相等了，就有交点。\r\n### 复杂度：\r\n时间复杂度：O(m+n)\r\n空间复杂度：O(1)\r\n### 代码：\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        curA,curB = headA,headB        \r\n        while curA != curB:\r\n            curA = curA.next if curA else headB\r\n            curB = curB.next if curB else headA\r\n        return curA\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leonalhq":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429140638","body":"class Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # treat the num as a stack\n        res = []\n        carry = k\n        while num:\n            val = num.pop() + carry\n            carry = val/10\n            res.insert(0, val%10)\n\n        while carry:\n            res.insert(0, carry%10)\n            carry = carry/10\n        return res\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431559494","body":"class Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        left=[]\n        lens = len(s)\n        right=[0]*lens\n        \n        t = sys.maxsize\n        for i in range(0,lens):\n            if s[i]== c:\n                t = i\n            left.append(t)\n            \n        t = sys.maxsize\n        for i in range(lens-1,-1,-1):\n            if s[i]== c:\n                t = i\n            right[i] = t\n\n        ans = []\n        for i in range(0,lens):\n            ans.append(min(abs(left[i]-i),abs(right[i]-i)))\n            \n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433193022","body":"class CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.stacks=[]\r\n        self.cnt=0\r\n        self.size = maxSize\r\n        self.incre = [0]*maxSize\r\n        \r\n        \r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if self.cnt<self.size:\r\n            self.stacks.append(x)\r\n            self.cnt+=1\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.cnt<=0:\r\n            return -1\r\n        inc = self.incre[self.cnt-1]\r\n        self.incre[self.cnt-1] = 0\r\n        if self.cnt>1:\r\n            self.incre[self.cnt-2] +=inc\r\n        \r\n        self.cnt-=1\r\n        return self.stacks.pop() + inc\r\n        \r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if(self.cnt):\r\n            if k <= self.cnt:\r\n                self.incre[k-1] += val\r\n            if k > self.cnt:","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434053932","body":"### 思路  \n  \n这种计算器类【】相关的第一反应就是栈，\n特别想用recurrsion，写了半天发现没考虑两位数这种case，int_stack发现似乎也不必要\n  \n### 代码  \n  \n```python\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        int_stack= []\n        def subDecode(s, i, temp):\n            int_temp = \"\"\n            while i < len(s):\n                if s[i] == ']':\n                    return i, temp\n                elif s[i] == '[':\n                    int_stack.append(int(int_temp))\n                    int_temp = \"\"\n                    i, cur_str = subDecode(s, i+1, \"\")\n                    temp = temp + int_stack.pop() * cur_str\n                elif s[i].isnumeric():\n                    int_temp+=s[i]\n                else:\n                    temp += s[i]\n                i=i+1\n            return temp\n        t = subDecode(s, 0, \"\")\n\n        return t\n```\n  \n**复杂度分析**  \n- 时间复杂度：O(N)，其中 N 为数组长度。  \n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435438598","body":"class MyQueue(object):\n\n    def __init__(self):\n        self.s = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.s.insert(0,x)\n        \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.s.pop()\n        \n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.s[-1]\n        \n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return not self.s\n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435907313","body":"### 思路  \n  \n单项栈的Stack的做法实在是太巧妙\n  \n### 代码  \n  \n  \n```py（此处换成你的语言，比如js，py 等）  \nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        for a in arr:\n            if not stack:\n                stack.append(a)\n            else:\n                if stack[-1] < a:\n                    stack.append(a)\n                else:\n                    top = stack[-1]\n                    while stack and stack[-1] > a:\n                        stack.pop()\n                    stack.append(top)\n                    \n        return len(stack)\n```  \n  \n  \n```  \n  \n**复杂度分析**  \n- 时间复杂度：O(kN)，其中 N 为数组长度。  \n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436305996","body":"```\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :type k: int\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head or k == 0:\r\n            return head\r\n\r\n        act = head\r\n        l = 1\r\n        while act.next:\r\n            act = act.next\r\n            l +=1\r\n        act.next = head\r\n        \r\n        a_k = k%l\r\n        a_l = l - a_k - 1\r\n    \r\n        # Find the new head\r\n        new_tail = head\r\n        for i in range(a_l):\r\n            new_tail = new_tail.next\r\n\r\n        new_head = new_tail.next\r\n        # print(a_l, new_head)\r\n        # cut from previous end\r\n        new_tail.next = None\r\n\r\n        return new_head\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438631353","body":"class Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next: \n            return head\n\n        nextNode = head.next\n        head.next = self.swapPairs(nextNode.next)\n        nextNode.next = head\n\n        return nextNode","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439507693","body":"### 思路  \n  \n有点难，所以最好 重新看一下\n1.快慢指针的写法\n  \n### 代码  \n  \n  \n```python\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n        \n        #获取当前链表的中点\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        #以链表中点为根\n        mid = TreeNode(slow.val)\n        # 没有就 maximum recursion depth exceeded\n        if slow == fast:\n            return mid\n        #中点左边的值都小于它,可以构造左子树\n        mid.left = self.sortedListToBST(head)\n        #同理构造右子树\n        mid.right = self.sortedListToBST(slow.next)\n\n        return mid\n```\n  \n**复杂度分析**  \n- 时间复杂度：O(NlogN)，其中 N 为数组长度。  \n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441204487","body":"class Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummyA = headA\n        dummyB = headB\n        # inter = set()\n        # interA = None\n        # while dummyA:\n        #     inter.add(dummyA)\n        #     dummyA = dummyA.next\n        \n        # while dummyB:\n        #     if dummyB in inter:\n        #         return dummyB\n        #     else:\n        #         dummyB = dummyB.next\n\n        while dummyA != dummyB:\n            if not dummyA and not dummyB:\n                return None\n            if not dummyA:\n                dummyA = headB\n            else:\n                dummyA = dummyA.next\n            if not dummyB:\n                dummyB = headA\n            else:\n                dummyB = dummyB.next\n\n        return dummyA","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hjy-u":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429146539","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carryon = 0\n        i = len(num) - 1\n        res = []\n        while (i >= 0 or k != 0):\n            current_num = num[i] if i >= 0 else 0\n            current_k = k%10 if k!=0 else 0\n            value = current_num + current_k + carryon\n            carryon = value // 10\n            k //= 10\n            i -= 1\n            res.insert(0, value % 10)\n        if carryon != 0:\n            res.insert(0, carryon)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430735051","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        res = [0] * n\n        idx = -n\n        for i in range(n):\n            if s[i] == c:\n                idx = i\n            res[i] = i - idx\n        idx = 2 * n\n        for i in range(n - 1, -1, -1):\n            if s[i] == c:\n                idx = i\n            res[i] = min(res[i], idx - i)\n        return res\n```\nTC: O(n)\nSC: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1437915096","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if len(self.stack) == 0:\n            return -1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) < k:\n            self.stack = [i+val for i in self.stack]\n        else:\n            for i in range(k):\n                self.stack[i] += val\n        return self.stack\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"csthaha":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429151521","body":"#### 思路：\n   1.将 K 也转换成对应的数组。\n   2. 遍历最长的一个数组。从末尾进行相加。\n   3. 获取res后 对数组进行替换。\n   4. 遍历完之后判断是否仍有进位。\n#### 复杂度：\n  时间复杂度：O(n)\n  空间复杂度：O(n)\n#### 代码：\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(arr, k) {\n    // k 数组形式\n    const strK = String(k)\n    const arrK = []\n    for(let i = 0; i < strK.length; i++) {\n        arrK.push(+strK[i])\n    }\n    let pos = 0 // 进位\n    const longArr = arrK.length > arr.length ? arrK : arr\n    for(let j = 0; j < longArr.length; j++) {\n        const A = arrK[arrK.length - 1 - j];\n        const B = arr[arr.length - 1 - j];\n        const sum = (A || 0) + (B || 0) + pos;\n        const res = sum % 10;\n        pos = Math.floor(sum / 10)\n        longArr[longArr.length - 1 - j] = res;\n    }\n    if(pos) {\n        longArr.unshift(pos)\n    }\n    return longArr\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430803730","body":"#### 思路：\n  - 获取字符**c**在**s**中的所有索引列表\n  - `getDistance` 获取字符在索引列表中的最小值。\n#### 复杂度：\n  - 时间复杂度: O(n^2)\n  - 空间复杂度: O(n)\n#### 代码：\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    const res = []\n    const indexList = []\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] === c) {\n            indexList.push(i)\n        }\n    }\n    const getDistance = (list, index) => {\n        let min = Number.MAX_VALUE;\n        for(let i = 0; i < list.length; i++) {\n            min = Math.min(Math.abs(list[i] - index), min)\n        }\n        return min\n    }\n    for(let i = 0; i < s.length; i++) {\n        res.push(getDistance(indexList, i))\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432615804","body":"#### 复杂度：\n时间复杂度：O(min(k, maxSize))\n空间复杂度：O(1)\n#### 代码：\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.list = [];\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.size() >= this.maxSize) {\n        return;\n    };\n    this.list.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.size() === 0) return -1;\n    return this.list.pop();\n};\n\nCustomStack.prototype.size = function() {\n    return this.list.length;\n}\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0; i < Math.min(this.size(), k); i++) {\n        this.list[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434160030","body":"\n\n #### 思路：\n - 遍历字符串\n - 若遇到数字计算倍数\n - 若遇到 *[* 进行 倍数、之前结果进行入栈 *[num, res]* ，并将 *num*、*res* 重置\n - 若遇到 *]* 则进行出栈操作。当前拼接的 res 为需要重复的字符串，而出栈的 res 则为之前的结果字符串。二者进行拼接。\n - 若遇到其他字符则进行结果拼接。\n\n #### 复杂度：\n - 时间复杂度： O(n)\n - 空间复杂度：O(l) l为嵌套层数。\n #### 代码：\n ```javascript\n /**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let res = '';\n    const stack = [];\n    let num = 0;\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] >= 0) {\n            num = +s[i] + num * 10;\n            continue;\n        }\n        if(s[i] === '[') {\n            stack.push([num, res]);\n            num = 0;\n            res = '';\n            continue\n        }\n        if(s[i] === ']') {\n            const [num, stackRes] = stack.pop();\n            res = stackRes + res.repeat(num)\n            continue;\n        }\n        res += (s[i] > 0 ? '' : s[i])\n    }\n    return res\n};\n ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435476966","body":"\n#### 复杂度：\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)\n\n#### 代码：\n```javascript\nclass MyQueue {\n    constructor() {\n        this.list = [];\n    }\n\n    push(x) {\n        this.list.push(x);\n    }\n\n    pop() {\n        if(!this.size()) return;\n        return this.list.shift();\n    }\n\n    size() {\n        return this.list.length;\n    }\n\n    peek() {\n        if(!this.size()) return;\n        return this.list[0];\n    }\n\n    empty() {\n        return this.size() === 0;\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435828337","body":"#### 复杂度：\n时间复杂度：O(n)\n空间复杂度：O(n) while循环次数 最大为 n\n#### 代码：\n```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    // 单调栈， 维护块的最大元素。\n    const stack = [];\n    for(let item of arr) {\n        // 小于 或者 等于的都可以当做一个块\n        if(stack.length === 0 || stack[stack.length - 1] <= item) {\n            stack.push(item)\n        } else {\n            const max = stack.pop();  // 弹出栈顶元素 重新分配块。\n            // 如果 最大元素大于当前元素。 则继续弹出栈顶元素。\n            while(stack.length && stack[stack.length - 1] > item) {\n                stack.pop()\n            }\n            stack.push(max)\n        }\n    }\n    return stack.length;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436227015","body":"\n#### 复杂度：\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n#### 代码：\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let cur = head;\n    let count = 0;\n    while(cur) {\n        count++;\n        if(!cur.next) {\n            // 成环\n            cur.next = head;\n            break;\n        } else {\n            cur = cur.next;\n        }\n    }\n    let remain = k % count; //求余数\n\n    // head 需要移动 remain 下， 成环后（cur.next = head） ， cur 需要移动 add 下。\n    // cur.next 为 头节点。然后断开环。\n    let add = count - remain;\n\n    if(add === count) {\n        cur.next = null;\n        return head;\n    }\n\n    let res = null;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    res = cur.next;\n    cur.next = null;\n    \n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437789687","body":"\n#### 思路：\n - 递归进行两两交换即可。 \n#### 复杂度：\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n#### 代码：\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    var cb = head => {\n        if(!head || !head.next) return head;\n        let cur;\n        cur =  head.next;\n        next = cur.next;\n        cur.next = head;\n        head.next = null;\n        head = cur;\n        if(next) {\n            head.next.next = cb(next)\n        }\n        return head;\n    }\n    return  cb(head);\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441168494","body":"#### 复杂度：\n- 时间复杂度：O(n + m) headA length + m 相交前 B 的节点。\n- 空间复杂度：O(n) headA length\n#### 代码：\n```javascript\n/**  160\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    const visited = new Set();\n    let temp = headA;\n    while (temp) {\n        visited.add(temp);\n        temp = temp.next;\n    }\n    temp = headB;\n    while (temp) {\n        if (visited.has(temp)) {\n            return temp;\n        }\n        temp = temp.next;\n    }\n    return null;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zepherust":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429177324","body":"\n- 最简单的思路\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        A = 0\n        for i in num:\n            A = A*10 + i\n        k = k+A\n        result = []\n        while k!= 0:\n            result = [k%10] + result\n            k = k//10\n        return result if result != [] else [0]\n```\n结果： 2388ms/ 14.3MB\n原因分析: 两次O(n)循环，创建了一个数组\n\n- 尝试改进一次O(n)\n\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        n = len(num)\n        addition = 0\n        result = []\n        for i in range(0,n):\n            t = num[n-i-1] + k%10 + addition\n            addition = 1 if t >=10 else 0\n            t = t %10\n            result = [t] + result\n            k = k // 10\n        while k>0:\n            t = k%10 + addition\n            addition = 1 if t >=10 else 0\n            t = t %10\n            result = [t] + result\n            k = k//10\n        if addition > 0:\n            result = [1] + result\n        return result \n```\n结果 : 1336ms/13.6MB\n分析：比上次几乎节省一半时间，合理\n\n- 尝试更优解法\n\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        n = len(num) - 1\n        addition = 0\n        while n >= 0:\n            num[n] = num[n] + k%10 + addition\n            addition = 1 if num[n] >=10 else 0\n            num[n] = num[n] %10\n            k = k // 10\n            n -= 1\n        while k>0:\n            t = k%10 + addition\n            addition = 1 if t >=10 else 0\n            t = t %10\n            num = [t] + num\n            k = k//10\n        if addition > 0:\n            num = [1] + num\n        return num\n```\n结果:  56ms/13.4MB\n分析：直接使用原来的数组，省去创造数组的时间\n\n- 群友的最优解法\n\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        i= len(num) - 1\n        while k>0 and i>=0:\n            num[i] += k\n            k = num[i] // 10\n            num[i] %= 10\n            i -= 1\n        while k>0:\n            num = [k%10] + num\n            k //= 10\n        return num\n```\n结果： 36/13.7\n分析：直接省去进位（把进位体现到k上），进一步节省时间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431456932","body":"class Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        # forward \n        n = len(s)\n        result = [n for i in range(n)]\n        k = 0\n        for i in range(n):\n            if s[i] != c:\n                result[i] = abs(n-k-1)\n                k += 1\n            else:\n                result[i] = 0\n                k = n\n        print(result)\n        #backward\n        k = n-1\n        for i in range(n-1,-1,-1):\n            if s[i] != c:\n                result[i] = min(result[i],abs(k))\n                k -= 1\n            else:\n                result[i] = 0\n                k = -1\n        return result","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432932626","body":"- 使用Python自带的数组\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.capability = maxSize\r\n        self.size = 0\r\n        self.values = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.capability:\r\n            self.values.append(x)\r\n            self.size+=1\r\n\r\n    def pop(self) -> int:\r\n        if self.size > 0:\r\n            v = self.values.pop()\r\n            self.size -=1\r\n            return v\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k > self.size:\r\n            l = self.size\r\n        else:\r\n            l = k\r\n        for i in range(l):\r\n            self.values[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n- 空间换时间\r\n```\r\n class CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.capability = maxSize\r\n        self.size = 0\r\n        self.values = [0 for i in range(maxSize)]\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.capability:\r\n            self.size+=1\r\n            self.values[self.size -1] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.size > 0:\r\n            v = self.values[self.size-1]\r\n            self.size -=1\r\n            return v\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k > self.size:\r\n            l = self.size\r\n        else:\r\n            l = k\r\n        for i in range(l):\r\n            self.values[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feefeefee":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429180682","body":"```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n const len = num.length\n let i = len - 1 \n let carry = 0\n let res = []\n  while(i>=0 || k!==0){\n      let x = i>=0 ? num[i] : 0\n      let y = k !== 0 ? k % 10 :0\n      const sum = x + y +carry\n      carry = sum >= 10 ? 1 : 0\n      res.push(sum % 10);\n      k = Math.floor(k / 10)\n      i-- \n  \n  }\n  if(carry){\n     res.push(carry)\n  }\nreturn res.reverse()\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430664602","body":"```javaScript \n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let len = s.length\n    const arr = Array(s.length)\n    let l_current = null\n    let r_current = null\n\n    for(let i = 0; i < len ; i++){\n        l_current = s[i] === c ? i :l_current\n        arr[i] = l_current !== null ? Math.abs(i - l_current) : Infinity\n    }\n\n     for(let i = len-1; i >=0 ; i--){\n        r_current = s[i] === c ? i : r_current\n        if(r_current !== null){\n            const abs = Math.abs(i -r_current)\n            arr[i] = arr[i] < abs ? arr[i]:abs\n        }\n    }\n    return arr\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432628609","body":"```javaScript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  const len = this.stack.length;\n  if (len < this.maxSize) {\n    this.stack.push(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  const len = this.stack.length;\n  return len === 0 ? -1 : this.stack.pop();\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  const len = this.stack.length;\n\n  const y = len < k ? len :k\n   for (let i = 0; i < y; i++) {\n      this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hughlin07":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429183075","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        \n        List<Integer> res= new ArrayList();\n        int index = num.length - 1;\n        \n        while( index >= 0 || k > 0){\n            if(index >= 0 ){\n                k = k + num[index];\n            }\n            res.add(k%10);\n            k = k/10;\n            index -- ;\n        }\n\n        Collections.reverse(res);\n        \n        return res;\n    }\n}\n\n\nComplexity Analysis:\nTime: O(n), n is the length of array\nSpace: O(n),","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432861018","body":"class CustomStack {\n    \n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top != stack.length-1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n\n        if(top != -1){\n            --top;\n            return stack[top+1 ];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < Math.min(k, top+1); i++){\n            stack[i] += val;\n        }\n    }\n}\n\nTime Complexity: \nPush, Pop: O(1)\nIncrement: O(k)\n\nSpace Complexity: O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434403006","body":"class Solution {\n    public String decodeString(String s) {\n        \n        Stack<Integer> times = new Stack<>();\n        Stack<String> temp_String = new Stack<>();\n        StringBuilder result = new StringBuilder();\n        int count = 0;\n        \n        for(char c : s.toCharArray()){\n            if( c == '['){\n                times.push(count);\n                temp_String.push(result.toString());\n                count = 0;\n                result = new StringBuilder();\n            }\n            else if(c == ']'){\n                StringBuilder temp = new StringBuilder();\n                int temp_times = times.pop();\n                \n                for(int i = 0; i < temp_times; i++){\n                    temp.append(result);\n                }\n                result = new StringBuilder(temp_String.pop() + temp.toString());\n            }\n            else if(c >= '0' && c <= '9'){\n                count = count * 10 + c - '0';\n            }\n            else{\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n}\n\nSpace Complexity:\nO(m+n), m and n are the size of stack\nTime Complexity:\nO(n*count), iterate count times for total.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435524905","body":"class MyQueue {\n\n    Stack<Integer> s1 = new Stack<>();\n    Stack<Integer> s2 = new Stack<>();\n\n    public MyQueue() {\n        \n    }\n    \n    public void push(int x) {\n        while(!s1.isEmpty()){\n            s2.push(s1.pop());\n        }\n\n        s2.push(x);\n\n        while(!s2.isEmpty()){\n            s1.push(s2.pop());\n        }\n    }\n    \n    public int pop() {\n        return s1.pop();\n    }\n    \n    public int peek() {\n        return s1.peek();\n    }\n    \n    public boolean empty() {\n        return s1.isEmpty();\n    }\n}\n\nTime Complexity: O(n)\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435951030","body":"class Solution {\r\n    \r\n    public int maxChunksToSorted(int[] arr) {\r\n\r\n        Stack<Integer> result = new Stack<Integer>();\r\n\r\n        for(int num : arr){\r\n            int tmp = num;\r\n            while(result.size() > 0 && result.peek() > num){\r\n                tmp = Math.max(tmp, result.peek());\r\n                result.pop();\r\n            }\r\n            result.push(tmp);\r\n        }\r\n        return result.size();\r\n    }\r\n}\r\n\r\nTime Complexity: O(n)\r\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436651376","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null){\n            return head;\n        }\n\n        ListNode curNode = head;\n        int length = 1;\n        while(curNode.next != null){    \n            curNode = curNode.next;\n            length ++;\n        }\n\n        ListNode tailNode = curNode;\n        curNode.next = head;\n        curNode = head;\n\n        int loopCount = length - (k%length);\n        for(int i = 0; i < loopCount; i++){\n            curNode = curNode.next;\n            tailNode = tailNode.next;\n        }\n        tailNode.next = null;\n        return curNode;\n    }\n}\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438051979","body":"class Solution {\r\n\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n\r\n        ListNode temp = head.next;\r\n        head.next = swapPairs(temp.next);\r\n        temp.next = head;\r\n        return temp;\r\n    }\r\n}\r\n\r\nTime Complexity: O(N)\r\nSpace Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439700654","body":"class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        \n       if(head == null){\n            return null;\n        }\n        return dfs(head, null);\n    }\n\n    public TreeNode dfs(ListNode head, ListNode tail){\n        if(head == tail) return null;\n        ListNode fast = head, slow = head;\n        while(fast != tail && fast.next != tail){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = dfs(head, slow);\n        root.right = dfs(slow.next, tail);\n        return root;\n    }\n}\n\nTime Complexity: O(nlogn)\n\nSpace Complexity: O(logn)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huizsh":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429183316","body":"### 解题思路\n逐位相加\n\n### 代码\n\n```golang\nfunc addToArrayForm(A []int, K int) []int {\n    carry := 0\n    for i := len(A) - 1; i >= 0; i-- {\n        A[i], carry = (carry + A[i] + K % 10) % 10, (carry + A[i] + K % 10) / 10\n        K /= 10\n    }\n    B := make([]int, 0)\n    carry = carry + K\n    for carry > 0 {\n        B = append([]int{carry % 10}, B...)\n        carry /= 10\n    }\n    return append(B, A...)\n}\n```\n\n### 复杂度分析\n时间复杂度：O(max(n, log k))\n空间复杂度：O(max(n, log k))","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434713052","body":"```\nfunc decodeString(s string) string {\n    var stack []string\n    for i := 0; i < len(s); i++ {\n        c := string(s[i])\n        if c == \"]\" {\n            var repeatStr string\n            var repeatCount string\n            for len(stack) > 0 && stack[len(stack)-1] != \"[\" {\n                repeatStr = stack[len(stack)-1] + repeatStr\n                stack = stack[:len(stack)-1]\n            }\n    \n            stack = stack[:len(stack)-1]\n            for len(stack) > 0 && isNumeric(stack[len(stack)-1]) {\n                repeatCount = stack[len(stack)-1] + repeatCount\n                stack = stack[:len(stack)-1]\n            }\n            repeatCountInt, _ := strconv.Atoi(repeatCount)\n            stack = append(stack, strings.Repeat(repeatStr, repeatCountInt))\n        } else {\n            stack = append(stack, c)\n        }\n    }\n    return strings.Join(stack, \"\")\n}\n\nfunc isNumeric(s string) bool {\n    _, err := strconv.Atoi(s)\n    return err == nil\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435978918","body":"```\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc maxChunksToSorted(arr []int) int {\n    count_a := make(map[int]int)\n    count_b := make(map[int]int)\n    ans := 0\n\n    sortedArr := make([]int, len(arr))\n    copy(sortedArr, arr)\n    sort.Ints(sortedArr)\n\n    for i, val := range arr {\n        count_a[val]++\n        count_b[sortedArr[i]]++\n        if reflect.DeepEqual(count_a, count_b) {\n            ans++\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    arr := []int{4, 3, 2, 1, 0}\n    fmt.Println(maxChunksToSorted(arr))\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437036780","body":"```\nfunc rotateRight(head *ListNode, k int) *ListNode {\n    if head == nil || k == 0 {\n        return head\n    }\n\n    p1, p2 := head, head\n    count := 1\n    i := 0\n    for i < k {\n        if p2.Next != nil {\n            count++\n            p2 = p2.Next\n        } else {\n            k = k % count\n            i = -1\n            p2 = head\n        }\n        i++\n    }\n\n    for p2.Next != nil {\n        p1 = p1.Next\n        p2 = p2.Next\n    }\n\n    tmp := p1.Next\n    if tmp != nil {\n        p1.Next = nil\n        p2.Next = head\n        return tmp\n    }\n    return head\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441538956","body":"```\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    if headA == nil || headB == nil {\n        return nil\n    }\n\n    pA := headA\n    pB := headB\n    for pA != pB {\n        if pA == nil {\n            pA = headB\n        } else {\n            pA = pA.Next\n        }\n        if pB == nil {\n            pB = headA\n        } else {\n            pB = pB.Next\n        }\n    }\n\n    return pA\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chanceyliu":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429188828","body":"### 思路\r\n\r\n逐位相加，注意处理进位，将进位直接用 K 接收\r\n\r\n### 代码\r\n\r\n```typescript\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n  let res: number[] = [];\r\n  for (let i = num.length - 1; i >= 0; i--) {\r\n    let sum = num[i] + (k % 10);\r\n    // 给k消位\r\n    k = Math.floor(k / 10);\r\n    // 有进位\r\n    if (sum >= 10) {\r\n      k++;\r\n      sum -= 10;\r\n    }\r\n    console.log(sum);\r\n    res.push(sum);\r\n  }\r\n  for (; k > 0; k = Math.floor(k / 10)) {\r\n    res.push(k % 10);\r\n  }\r\n  return res.reverse();\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(max(n,log k)) 其中 N 为数组长度\r\n- 空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430857093","body":"### 思路\n\n两次遍历，从前往后，在从后往前取最小距离\n\n### 代码\n\n```typescript\nfunction shortestToChar(s: string, c: string): number[] {\n  const n = s.length;\n  const res = new Array(n).fill(0);\n\n  for (let i = 0, idx = -n; i < n; i++) {\n    if (s[i] === c) {\n      idx = i;\n    }\n    res[i] = i - idx;\n  }\n\n  for (let i = n - 1, idx = 2 * n; i >= 0; i--) {\n    if (s[i] === c) {\n      idx = i;\n    }\n    res[i] = Math.min(res[i], idx - i);\n  }\n\n  return res;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N) 其中 N 为数组长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432657977","body":"\n### 代码\n\n```typescript\n\nexport class CustomStack {\n  private data: any[];\n  private maxSize: number;\n\n  constructor(maxSize: number) {\n    this.data = [];\n    this.maxSize = maxSize;\n  }\n\n  push(x: number): void {\n    if (this.data.length < this.maxSize) {\n      this.data.push(x);\n    }\n  }\n\n  pop(): number {\n    console.log(this.data);\n    if (this.data.length === 0) {\n      return -1;\n    }\n    return this.data.pop();\n  }\n\n  increment(k: number, val: number): void {\n    for (let i = 0; i < Math.min(k, this.data.length); i++) {\n      this.data[i] += val;\n    }\n  }\n}\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：push、pop O(1) ; increment O(n)\n- 空间复杂度：O(maxSize)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434272307","body":"### 思路\n\n使用两个栈，分别存放重复次数和累加后的字符，针对特定的四种情况分别做处理，做好之前字符的记录工作，最后完成拼接\n\n### 代码\n\n```typescript\nfunction decodeString(s: string): string {\n  let numStack = [];\n  let strStack: string[] = [];\n  let num = 0;\n  let result = \"\";\n\n  for (const str of s) {\n    // 是数字\n    if (!isNaN(+str)) {\n      num = +(num + str);\n    } else if (str === \"[\") {\n      // 是[，就是字符重复的开始，所以将之前的记录存档\n      numStack.push(num);\n      num = 0;\n      strStack.push(result);\n      result = \"\";\n    } else if (str === \"]\") {\n      // 是]，就准备收口，返回重复后的字符\n      let report = numStack.pop();\n      result = strStack.pop() + result.repeat(report as number);\n    } else {\n      // 是字符串，就要拼接起来\n      result += str;\n    }\n  }\n\n  return result;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n) n为s字符长度\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1436474768","body":"\n### 思路\n\n使用两个栈，一个用来放主栈中颠倒过后的数据，这样只用 POP 方法，我们就能移出栈底部的元素\n\n### 代码\n\n```typescript\nclass MyQueue {\n  private intStack: any[];\n  private outStack: any[];\n\n  constructor() {\n    this.intStack = [];\n    this.outStack = [];\n  }\n\n  push(x: number): void {\n    this.intStack.push(x);\n  }\n\n  pop(): number {\n    if (!this.outStack.length) {\n      while (this.intStack.length) {\n        this.outStack.push(this.intStack.pop());\n      }\n    }\n    return this.outStack.pop();\n  }\n\n  peek(): number {\n    if (!this.outStack.length) {\n      while (this.intStack.length) {\n        this.outStack.push(this.intStack.pop());\n      }\n    }\n    return this.outStack[this.outStack.length - 1];\n  }\n\n  empty(): boolean {\n    return !this.intStack.length && !this.outStack.length;\n  }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：push 和 empty 为 O(1)，pop 和 peek 为 O(n)\n- 空间复杂度：O(n)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436667533","body":"### 代码\n\n```typescript\nclass ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}\n\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n  if (k === 0 || !head || !head.next) {\n    return head;\n  }\n  let n = 1;\n  let cur = head;\n  while (cur.next) {\n    cur = cur.next;\n    n++;\n  }\n\n  let add = n - (k % n);\n  if (add === n) {\n    return head;\n  }\n\n  cur.next = head;\n  while (add) {\n    cur = cur.next as ListNode;\n    add--;\n  }\n\n  const ret = cur.next;\n  cur.next = null;\n  return ret;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439547196","body":"### 代码\n\n```typescript\nclass ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}\n\nclass TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n  const arr: number[] = [];\n  while (head) {\n    arr.push(head.val);\n    head = head.next;\n  }\n\n  const buildBST = (start, end) => {\n    if (start > end) return null;\n    const mid = (start + end) >>> 1;\n    const root = new TreeNode(arr[mid]);\n    root.left = buildBST(start, mid - 1);\n    root.right = buildBST(mid + 1, end);\n    return root; // 返回当前子树\n  };\n\n  return buildBST(0, arr.length - 1);\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441279581","body":"### 代码\n\n```typescript\nexport class ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}\n\nfunction getIntersectionNode(\n  headA: ListNode | null,\n  headB: ListNode | null\n): ListNode | null {\n  const visited = new Set();\n  let temp = headA;\n  while (temp !== null) {\n    visited.add(temp);\n    temp = temp.next;\n  }\n  temp = headB;\n  while (temp !== null) {\n    if (visited.has(temp)) {\n      return temp;\n    }\n    temp = temp.next;\n  }\n  return null;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(m + n) m 和 n 分别为 headA 和 deadB 的长度\n- 空间复杂度：O(m)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hshen11":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429194671","body":"#思路\n1. 把A数给转成数字aNum\n2. 数字aNum和K相加得到数字sum\n3. sum再转成数组\n```\n public int[] getInt(int[] A, int K) {\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < A.length; i++) {\n            builder.append(A[i]);\n        }\n        String aString = builder.toString();\n        int aNum = Integer.valueOf(aString);\n        int sum = K + aNum;\n\n        String[] split = String.valueOf(sum).split(\"\");\n        int[] result = new int[split.length];\n        for (int i = 0; i < split.length; i++) {\n            result[i] = Integer.valueOf(split[i]);\n        }\n        return result;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431305704","body":"```java\n public int[] shortestToChar(String s, char c) {\n        char[] chars = s.toCharArray();\n        int n = chars.length;\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (chars[i] == c) {\n                list.add(i);\n            }\n              \n        }\n        int[] result = new int[n];\n        for (int i = 0; i < n; i++) {\n            int k = n;\n            for (int j = 0; j < list.size(); j++) {\n                int b = Math.abs(i - list.get(j));\n                k = k - b <= 0 ? k: b;\n            }\n            result[i] = k;\n        }\n\n        return result;\n\n    }\n```\n### 复杂度\n- 时间O(n)\n- 空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433035535","body":"## 思路\n数组模拟栈\n```java\npublic class CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n\n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n\n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n\n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n```\n## 复杂度分析\n- 参见官方题解\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434145289","body":"\n## 题目地址(394. 字符串解码)\n\nhttps://leetcode.cn/problems/decode-string/\n\n## 题目描述\n\n```\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n \n\n示例 1：\n\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n\n\n示例 2：\n\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n\n\n示例 3：\n\n输入：s = \"2[abc]3[cd]ef\"\n输出：\"abcabccdcdcdef\"\n\n\n示例 4：\n\n输入：s = \"abc3[cd]xyz\"\n输出：\"abccdcdcdxyz\"\n\n\n \n\n提示：\n\n1 <= s.length <= 30\ns 由小写英文字母、数字和方括号 '[]' 组成\ns 保证是一个 有效 的输入。\ns 中所有整数的取值范围为 [1, 300] \n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public String decodeString(String s) {\n        int k = 0;\n        Stack<Integer> kStack = new Stack<>();\n        Stack<StringBuilder> letterStack = new Stack<>();\n        StringBuilder res = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (c == '[') {\n                kStack.push(k);\n                k = 0;\n                letterStack.push(res);\n                res = new StringBuilder();\n            } else if (c == ']') {\n                int curr=  kStack.pop();\n                StringBuilder temp = new StringBuilder();\n                for (int i = 0; i < curr; i++) {\n                    temp.append(res);\n                }\n                res = letterStack.pop().append(temp);\n            } else if (Character.isDigit(c)) {\n                k = c - '0' + k * 10;\n            } else {\n                res.append(c);\n            }\n\n        }\n\n        return res.toString();\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436575647","body":"\n## 题目地址(61. 旋转链表)\n\nhttps://leetcode.cn/problems/rotate-list/\n\n## 题目描述\n\n```\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n\n \n\n示例 1：\n\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n\n\n示例 2：\n\n输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n\n\n \n\n提示：\n\n链表中节点的数目在范围 [0, 500] 内\n-100 <= Node.val <= 100\n0 <= k <= 2 * 109\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437730060","body":"\n## 题目地址(24. 两两交换链表中的节点)\n\nhttps://leetcode.cn/problems/swap-nodes-in-pairs/\n\n## 题目描述\n\n```\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n\n \n\n示例 1：\n\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n\n\n示例 2：\n\n输入：head = []\n输出：[]\n\n\n示例 3：\n\n输入：head = [1]\n输出：[1]\n\n\n \n\n提示：\n\n链表中节点的数目在范围 [0, 100] 内\n0 <= Node.val <= 100\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n\npublic ListNode swapPairs(ListNode head) {\n\t\t//递归的终止条件\n\t\tif(head==null || head.next==null) {\n\t\t\treturn head;\n\t\t}\n\t\t//假设链表是 1->2->3->4\n\t\t//这句就先保存节点2\n\t\tListNode tmp = head.next;\n\t\t//继续递归，处理节点3->4\n\t\t//当递归结束返回后，就变成了4->3\n\t\t//于是head节点就指向了4，变成1->4->3\n\t\thead.next = swapPairs(tmp.next);\n\t\t//将2节点指向1\n\t\ttmp.next = head;\n\t\treturn tmp;\n\t}\n\n\n    \n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为链表长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439644615","body":"## 参考官方\n```java\npublic TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    private TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left,mid);\n        root.right = buildTree(mid.next,right);\n        return root;\n    }\n\n    private ListNode getMedian(ListNode left, ListNode right) {\n        ListNode slow = left;\n        ListNode fast = left;\n        while (fast != right && fast.next != right) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441513004","body":"\n## 题目地址(160. 相交链表)\n\nhttps://leetcode.cn/problems/intersection-of-two-linked-lists/\n\n## 题目描述\n\n```\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n自定义评测：\n\n评测系统 的输入如下（你设计的程序 不适用 此输入）：\n\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\nlistA - 第一个链表\nlistB - 第二个链表\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\n\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\n\n \n\n示例 1：\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。\n\n\n \n\n示例 2：\n\n输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n示例 3：\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\n\n \n\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n1 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <= m\n0 <= skipB <= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]\n\n \n\n进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n先对两条链表扫描一遍，取两者长度，然后让长链表先走「两者长度的差值」，然后再同时走，遇到第一个节点就是答案\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA , ListNode headB ) {\n        int c1 = 0, c2 = 0;\n        ListNode t1 = headA, t2 = headB;\n        while (t1 != null && ++c1 > 0) t1 = t1.next;\n        while (t2 != null && ++c2 > 0) t2 = t2.next;\n        int sub = Math.abs(c1 - c2);\n        while (sub-- > 0) {\n            if (c1 > c2) headA = headA.next;\n            else headB = headB.next;\n        }\n       \n        while (headA != null&&headB!=null) {\n            if (headA.equals(headB)) return headA;\n            else {\n                headA = headA.next;\n                headB = headB.next;\n            }\n        }\n\n        return null;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(m+n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"horace7":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429210148","body":"### 思路\n从右往左依次相加，如果大于10则处理进位\n\n### 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n    // 把k转换为数组\n    k = (k+'').split('');\n    // 从右往左依次相加\n    let l1 = num.length - 1;\n    let l2 = k.length - 1;\n    // c作为进位\n    let c = 0, result = [];\n    while (l1 >= 0 || l2 >=0) {\n        const num1 = l1 >= 0 ? +num[l1] : 0;\n        const num2 = l2 >= 0 ? +k[l2] : 0;\n        const sum = num1 + num2 + c;\n        // c取十位，数组push个位\n        c = Math.floor(sum / 10);\n        result.unshift(sum % 10);\n        l1--;\n        l2--;\n    }\n    // 退出循环时如果c大于0\n    if (c > 0) result.unshift(c);\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431022168","body":"```javascript\nvar shortestToChar = function(s, c) {\n    let res = Array(s.length).fill(0);\n\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] !== c) {\n            res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1] + 1;\n        }\n    }\n\n    for (let i = s.length - 1; i >= 0; i--) {\n         if (res[i] === Infinity || res[i + 1] + 1 < res[i]) {\n             res[i] = res[i + 1] + 1;\n         }\n    }\n\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432706661","body":"### 思路\n可以直接用js中的方法实现\n\n### 复杂度\n`时间复杂度：push pop：O(1); inc: O(k)`\n\n`空间复杂度：O(maxSize)`\n\n### 代码\n\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.arr = [];\n    this.len = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.arr.length < this.len) this.arr.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n     return this.arr.pop() || -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    this.arr = this.arr.map((item, index) => index < k ? item + val : item)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434396620","body":"```javascript\nvar decodeString = function(s) {\n    // define num stock & str stock\n    let numStock = [];\n    let strStock = [];\n    let num = 0, res = '';\n\n    for (let item of s) {\n        if (!isNaN(item)) {\n            num = num * 10 + parseInt(item);\n        } else if (item === '[') { // 开始入栈\n            numStock.push(num);\n            strStock.push(res);\n            num = 0;\n            res = ''\n        } else if (item === ']') { // 开始出栈\n            // 拿到次数\n            const times = numStock.pop()\n            res = strStock.pop() + res.repeat(times)\n        } else {\n            res += item\n        }\n    }\n\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435476440","body":"```javascript\nvar MyQueue = function() {\n    this.os = []; // 出队栈\n    this.is = []; // 入队栈\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.is.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (!this.os.length) {\n        while(this.is.length) {\n            this.os.push(this.is.pop())\n        }\n    }\n    return this.os.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (!this.os.length) {\n        while(this.is.length) {\n            this.os.push(this.is.pop())\n        }\n    }\n    return this.os[this.os.length - 1]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.os.length && !this.is.length\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435996327","body":"```javascript\nvar maxChunksToSorted = function(arr) {\n    const stack = [];\n    for (const num of arr) {\n        if (stack.length === 0 || num >= stack[stack.length - 1]) {\n            stack.push(num);\n        } else {\n            const mx = stack.pop();\n            while (stack.length && stack[stack.length - 1] > num) {\n                stack.pop();\n            }\n            stack.push(mx);\n        }\n    }\n    return stack.length;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436687590","body":"```javascript\nvar rotateRight = function(head, k) {\n    if (!head || !head.next || k === 0) return head;\n    let point = head, len = 1;\n    while (point.next) {\n        len++;\n        point = point.next;\n    }\n    if (k % len === 0) return head;\n\n    let n = len - (k % len);\n    point.next = head;\n    while (n > 0) {\n        point = point.next;\n        n--;\n    }\n    let res = point.next;\n    point.next = null;\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438603949","body":"```javascript\nvar swapPairs = function(head) {\n    if (!head || !head.next) return head\n    let pre = head.next\n    let next = head\n    let tmp = pre.next\n    head = head.next\n    while (next.next) {\n        pre.next = next\n        next.next = tmp ? (tmp.next || tmp) : null\n        if (tmp) {\n            pre = tmp.next\n            next = tmp\n            tmp = pre ? pre.next : null\n        }\n    }\n    return head\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439794180","body":"```javascript\nvar sortedListToBST = function(head) {\n    const buildTree = function(head, tail) {\n        if (head === tail) return null\n        // 快慢指针\n        var p1 = head, p2 = head;\n        while(p2 !== tail) {\n            p2 = p2.next;\n            if (p2 !== tail) {\n                p1 = p1.next;\n                p2 = p2.next\n            }\n        }\n        var tree = new TreeNode(p1.val);\n        tree.left = buildTree(head, p1);\n        tree.right = buildTree(p1.next, tail);\n        return tree\n    }\n    return buildTree(head, null)\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzh0114":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429234314","body":"### 思路：  \n· 从低位到高位计算；  \n· 对k取整，将个位数与num[i]相加得到sum，k除10。  \n· 判断sum是否大于等于0，若true，除过10的k+1；将sum-10 push_back进列表；  \n· 若k比num长，经过上述循环后的k仍大于0，对k取整push_back后除10；  \n· reverse列表。    \n\n### 代码：  \n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for(int i = n - 1; i >= 0; --i){\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if(sum >= 10){\n                ++k;\n                sum -= 10;\n            }\n            res.push_back(sum);\n        }\n        while(k > 0){\n            res.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n\n### 复杂度分析：\n· 时间复杂度O(n)，n为列表长度；   \n· 空间复杂度O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431551686","body":"### 思路\n---\n### 代码      \n```cpp    \nclass Solution {\npublic:\n   vector<int> shortestToChar(string S, char C) {\n       vector<int> ans(S.size(), 0);\n       int prev = -10000;\n       for(int i = 0; i < S.size(); i ++){\n           if(S[i] == C) prev = i;\n           ans[i] = i - prev;\n       }\n       prev = 20000;\n       for(int i = S.size() - 1; i >= 0; i --){\n           if(S[i] == C) prev = i;\n           ans[i] = min(ans[i], prev - i);\n       }\n       return ans;\n   }\n};\n```   \n---      \n### 复杂度分析       \ntc:O(n)     \nsc:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433223214","body":"### 思路\n- 用vector实现      \n---\n### 代码    \n```cpp\nclass CustomStack {\nprivate:\n    vector<int> stack;\n    int maxSize_;\npublic:\n    CustomStack(int maxSize) {\n        maxSize_ = maxSize;\n        stack.reserve(maxSize);\n    }\n    \n    void push(int x) { \n        if (stack.size() >= maxSize_) {\n            return;\n        }\n        stack.push_back(x);\n    }\n    \n    int pop() {\n        if(!stack.empty()){\n            int top = stack.back();\n            stack.pop_back();\n            return top;\n        }\n        else return -1;\n    }\n    \n    void increment(int k, int val) {\n        if(stack.size() <= k){\n            for(int i = 0; i < stack.size(); i++){\n                stack[i] = stack[i] + val;\n            }\n        }\n        else{\n            for(int i = 0; i < k; i++){\n                stack[i] = stack[i] + val;\n            }\n        }\n    }\n};\n```\n---\n### 复杂度分析    \n- TC：O(N)，N为k    \n- SC：O(N)，N为maxSize\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434451645","body":"### 思路   \n- 题解\n---\n### 代码   \n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n    stack<int> numStack;\n    stack<string> resStack;\n    int num = 0;\n    string res;\n    for (int i = 0; i < s.size(); i++) {\n        if (isalpha(s[i])) {\n            res.push_back(s[i]);\n        } else if (isdigit(s[i])) {\n            num = num * 10 + s[i] - '0';\n        } else if (s[i] == '[') {\n            resStack.push(res);\n            res = \"\";\n            numStack.push(num);\n            num = 0;\n        } else {\n            for (int j = 0; j < numStack.top(); j++) {\n                resStack.top() += res;\n            }\n            numStack.pop();\n            res = resStack.top();\n            resStack.pop();\n        }\n    }\n    return res;\n}\n};\n```\n### 复杂度分析   \n- TC:O(N)\n- SC:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435639094","body":"### 思路\n- 构造正反两个方向的栈，在需要pop或peek队列时，访问反向栈的栈顶\n---\n### 代码\n```cpp\nclass MyQueue {\nprivate:\n    stack<int> pos;\n    stack<int> neg;\n\n    void pos2neg(){\n        while(!pos.empty()){\n            neg.push(pos.top());\n            pos.pop();\n        }    \n    }\npublic:\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        pos.push(x);\n    }\n    \n    int pop() {\n        if(neg.empty()) pos2neg();\n        int res = 0;\n        res = neg.top();\n        neg.pop();\n        return res;\n    }\n    \n    int peek() {\n        if(neg.empty()) pos2neg();\n        return neg.top();\n    }\n    \n    bool empty() {\n        return pos.empty() && neg.empty();\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(1)\n- SC:O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435958026","body":"### 思路\n- （题解）单调栈\n---\n### 代码\n```cpp\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> stack;\n        for(int i = 0; i < arr.size(); i++){\n            if(!stack.empty() && stack.top() > arr[i]){\n                int cur = stack.top();\n                while(!stack.empty() && stack.top() > arr[i]){\n                    stack.pop();\n                }\n                stack.push(cur);\n            }\n            else stack.push(arr[i]);\n        }\n        return stack.size();\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(N)\n- SC:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437201057","body":"### 思路\n- 闭合为环\n---\n### 代码\n```cpp\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (k == 0 || head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        int n = 1;\n        ListNode* iter = head;\n        while (iter->next != nullptr) {\n            iter = iter->next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter->next = head;\n        while (add--) {\n            iter = iter->next;\n        }\n        ListNode* ret = iter->next;\n        iter->next = nullptr;\n        return ret;\n    }\n};\n```\n---\n### 复杂度分析\n- TC:O(N)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438668716","body":"### 思路\n- 迭代\n---\n### 代码\n```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* dummyHead = new ListNode(0);\n        dummyHead->next = head;\n        ListNode* tmp = dummyHead;\n        while(tmp->next != nullptr && tmp->next->next != nullptr){\n            ListNode* n1 = tmp->next;\n            ListNode* n2 = tmp->next->next;\n            tmp->next = n2;\n            n1->next = n2->next;\n            n2->next = n1;\n            tmp = n1;\n        }\n        return dummyHead->next;\n        \n    }\n};\n```\n----\n### 复杂度分析\n- TC:O(N)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439885770","body":"### 思路\n- 题解\n----\n### 代码\n```cpp\nclass Solution {\npublic:\n    int getLength(ListNode* head) {\n        int ret = 0;\n        for (; head != nullptr; ++ret, head = head->next);\n        return ret;\n    }\n\n    TreeNode* buildTree(ListNode*& head, int left, int right) {\n        if (left > right) {\n            return nullptr;\n        }\n        int mid = (left + right + 1) / 2;\n        TreeNode* root = new TreeNode();\n        root->left = buildTree(head, left, mid - 1);\n        root->val = head->val;\n        head = head->next;\n        root->right = buildTree(head, mid + 1, right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        int length = getLength(head);\n        return buildTree(head, 0, length - 1);\n    }\n};\n```\n-----\n### 复杂度分析\n- TC:O(N)\n- SC:O(log n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441325526","body":"### 思路\n- 双指针\n----\n### 代码\n```cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *A = headA, *B = headB;\n        while (A != B) {\n            A = A != nullptr ? A->next : headB;\n            B = B != nullptr ? B->next : headA;\n        }\n        return A;\n    }\n};\n```\n----\n### 复杂度分析\n- TC:O(m+n)\n- SC:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dragonfcl":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429257693","body":"### 思路\n\n两个数组，从右往左处理数据，和大于0，则处理进位（注意空值默认0处理）\n\n### 代码\n\n\n```javascript\n     const addToArrayForm = function (aSource, plusNum) {\n        let aRes = []\n        let aTarget = Array.from(plusNum.toString());\n        while (aTarget.length > 0) {\n          let sum = (+aSource.pop() || 0) + (+aTarget.pop() || 0)\n          if (sum >= 10) {\n            aTarget.push((+aTarget.pop() || 0) + 1)\n            aRes.unshift(sum % 10)\n          } else {\n            aRes.unshift(sum)\n          }\n        }\n        aRes = [...aSource, ...aRes];\n        return aRes;\n      };\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431534561","body":"### 思路\n\n先记录c的Index，遍历字符串，记录距离的绝对值，取最小值\n\n### 代码\n\n\n```JavaScript\nvar shortestToChar = function(s, c) {\n    const aS = s.split('');\n    const aCIndex = [];\n    const aRes = new Array(aS.length).fill(aS.length);\n    for(let i = 0; i < aS.length; i++){\n        if(aS[i] == c) {\n            aCIndex.push(i)\n        }\n    }\n    for(let i = 0; i < aS.length; i++){\n        for(let j = 0; j < aCIndex.length; j++){\n            aRes[i] = Math.min(aRes[i],Math.abs(i-aCIndex[j]))\n        }\n    }\n    return aRes;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433317498","body":"\r\nvar CustomStack = function(maxSize) {\r\n  this.stack = [];\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  let stack = this.stack;\r\n  if (stack.length < this.maxSize) {\r\n    stack.push( x );\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  let stackTemp = this.stack;\r\n  if (stackTemp.length > 0){\r\nreturn stackTemp.pop();\r\n} \r\n  return -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let stack = this.stack;\r\n  for (let i = 0; i < Math.min(stack.length, k); i++) {\r\n    stack[i] += val;\r\n  }\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434836053","body":"```javascript\r\nvar decodeString = function(s) {\r\n    let repetStack=[],resStack=[];\r\n    let resStr = \"\";\r\n    let repet = 0;\r\n    for(let i=0;i<s.length;i++){\r\n        let cur = s.charAt(i);\r\n        if(cur == '['){\r\n            repetStack.push(repet);\r\n            resStack.push(resStr);\r\n            repet = 0;\r\n            resStr = \"\";\r\n        }else if(cur == ']'){\r\n            let count = repetStack.pop();\r\n            let temp = \"\";\r\n            for(let i = 0;i<count;i++){\r\n                temp += resStr;\r\n            }\r\n            resStr = resStack.pop() + temp;\r\n        }else if(cur>='0' && cur<='9'){\r\n            repet = repet*10 + (cur-'0');\r\n        }else{\r\n            resStr += cur;\r\n        }\r\n    }\r\n    return resStr;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huifeng248":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429283375","body":"###### thoughts\r\n        # convert the array form interger into int\r\n        # add them and turn the sum into array form\r\n\r\n```py\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]: \r\n        sub_total = 0 \r\n        i = len(num)-1\r\n        j = 0\r\n        while j < len(num):\r\n            digit = num[j] * (10**i)\r\n            sub_total += digit\r\n            j+= 1\r\n            i -= 1 \r\n        \r\n        \r\n        sub_total += k \r\n\r\n        res = list(str(sub_total))\r\n        return [int(i) for i in res]\r\n```\r\n######    Complexity \r\n        # time complexity is O(n), n is the max(len(num), len(sum))\r\n        # space complexity is O(n), n is the max(len(num), len(sum))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430562334","body":"###### 思路： 左右指针算距离上一个的距离。然后比对两个array 的最小值\n```py\n\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # Algorithm\n\n        # When going left to right, we'll remember the index prev of the last character C we've seen. Then the answer is i - prev.\n        # When going right to left, we'll remember the index prev of the last character C we've seen. Then the answer is prev - i.\n        # We take the minimum of these two answers to create our final answer.\n\n        left_res = [None]*len(s)\n        right_res = [None]*len(s)\n        res = []\n        \n        prev = float('-inf')\n        # check from left\n        for i, char in enumerate(s):    \n            if char == c:\n                prev = i\n            left_res[i] = i - prev\n        \n        # check from right\n        right_prev = float('inf')\n        for j in range(len(s)-1, -1, -1):\n            right_res[j] = float('inf')\n            if s[j] == c:\n                right_prev = j\n            right_res[j] = right_prev - j\n   \n        for i in range(len(s)):\n            ele = min(left_res[i], right_res[i])\n            res.append(ele)\n        return res\n```\n\n\n    # time complexity O(n)\n    # space complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1431833638","body":"```python \nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.arr = []\n        \n\n    def push(self, x: int) -> None:\n        if len(self.arr) < self.maxSize:\n            self.arr.append(x)\n        \n    def pop(self) -> int:\n        if len(self.arr) >= 1:\n            res = self.arr.pop()\n            return res\n        else:\n            return -1\n        \n\n    def increment(self, k: int, val: int) -> None:\n        # print(\"stack\", self.arr, \"k\", k, val)\n        if len(self.arr) <= k:\n            self.arr = [i+val for i in self.arr]\n            # print([k, val], self.arr, )\n        else:\n            for i in range(k):\n                self.arr[i] += val\n            # print([k, val], self.arr, )\n        \n\n```\n\n##### time complexity: push, pop is O(1); increment is O(n) and n is equal to the min(len(stack), k)\n##### space complexity is O(n) n is the length of stack","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1435527470","body":"``` python\nclass Solution:\n\n    def decodeString(self, s:str) -> str:\n        stack = []\n        cur_str = \"\"\n        cur_num = 0\n        for char in s:\n            if char.isalpha():\n                cur_str += char\n                print(\"letter\", char)\n            elif char.isdigit():\n                cur_num = cur_num * 10 + int(char)\n                print(\"digit\", char)\n            elif char == \"[\":\n                stack.append(cur_str)\n                stack.append(cur_num)\n                cur_num = 0\n                cur_str = \"\"\n                print(\"stack after [\", stack)\n            elif char == \"]\":\n                print(\"stack ]\", stack)\n                num_multi = stack.pop()\n                pre_str = stack.pop()\n                print(\"cur_str\", cur_str, \"prev_str\", pre_str, \"num_multi\", num_multi, \"stack\", stack)\n                cur_str = pre_str + num_multi * cur_str\n        return cur_str\n            \ns = \"2[ee]2[3[a2[c]]]\"\n# s = \"2[abc]3[cd]ef\"\n# s = \"3[a]2[bc]\"           \n    \nsample = Solution()\nprint(sample.decodeString(s))\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435170344","body":"###### use only one stack. python pop(0) and append can do the work\n``` python \nclass MyQueue:\n\n    def __init__(self):\n        self.stack_one = []\n        # self.stack_two = []\n\n    def push(self, x: int) -> None:\n        self.stack_one.append(x)\n        # self.stack_two.insert(0, x)\n\n    def pop(self) -> int:\n        res = self.stack_one.pop(0)\n        # res = self.stack_two.pop(0)\n        return res\n\n    def peek(self) -> int:\n        return self.stack_one[0]\n        \n    def empty(self) -> bool:\n        return len(self.stack_one) == 0\n\n```\npop(0) is O(n). others are O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436458587","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        # count the number of max in the chunk. the previous chunk's max must be smaller than the next chunk's smallest\n        max_num = arr[0]\n        stack = []\n        for i in arr:\n            if  i >= max_num:\n                stack.append(i)\n                max_num = i\n            else: \n                top = stack[-1]\n                while len(stack) > 0 and stack[-1]> i:\n                    stack.pop()\n                \n                stack.append(top)\n        return len(stack)\n\n# time comeplexity: O(n)\n# space comeplexity: O(n)\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436635875","body":"``` python \n# make a circle and move along in k step, return the elements after the k.\n# there is still edge cases for this one, I will update it tmr to close the cases. \n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        # need to walk through the total linked list and get the total number of node\n        # total - k is the one that need to point to none, and the second half till end need to point to head \n        # return the second half head.\n        if k == 0:\n            return head\n        if head is None:\n            return None\n        if head.next is None:\n            return head\n        arr = [head.val]\n        current = head \n        while current.next:\n            arr.append(current.next.val)\n            current = current.next\n        current.next = head\n        total_len = len(arr)\n        \n        move_step = k % total_len\n        print(\"move_step\", move_step)\n        if move_step == 0:\n            return head\n        \n        new_tail = head\n        count = 0\n        while count< move_step:\n            count += 1\n            new_tail = new_tail.next\n        print(\"new_tail\", new_tail, \"new_tail.next\",new_tail.next)\n        \n        new_head = new_tail.next\n        new_tail.next = None\n        return new_head\n        \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438695028","body":"``` python\n#use recursion to swap the first two node, and pass the remainding and attached to the back of the first node\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None or head.next is None:\n            return head\n\n        first_Node = head\n        second_node = head.next\n\n        # assuming the remaining is working, the temp is the next nodes need to attached to the first_Node\n\n        temp = self.swapPairs(second_node.next)\n        first_Node.next = temp\n        second_node.next = first_Node\n        return second_node\n\n# Time Complexity: O(N), the size of the linked list.\n# Space Complexity: O(N), stack space utilized for recursion.\n\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sarah11qing":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429288563","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num) - 1\n        num[n] += k\n        carry = 0\n\n        # first, process the num arr\n        for i in range(n, -1, -1):\n            temp = num[i] + carry\n            num[i] = temp % 10\n            carry = temp // 10\n\n        # second, check carry\n        # if no carry, return num dirrectly\n        # else, create an addtional carry arr\n        if carry:\n            carry_arr = []\n            while carry:\n                carry_arr.append(carry % 10)\n                carry //= 10\n\n            # note that carry_arr need to be reversed\n            num = carry_arr[::-1] + num\n        \n        return num\n\n        # time: O(max(len(num), logk))\n        # space: O(max(len(num), logk))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430988519","body":"```py\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n        # Find all index of c\n        c_index = []\n        for i, ch in enumerate(s):\n            if ch == c:\n                c_index.append(i)\n\n        # Initialize the res arr and a pointer     \n        res = [0] * len(s)\n        p = 0\n        \n        # Deal with three situations:\n        # when i < the first c's index\n        for i in range(0, c_index[0]):\n            res[i] = c_index[0] - i\n\n        # when i >= the last c's index\n        for i in range(c_index[-1], len(s)):\n            res[i] = i - c_index[-1]\n\n        # when first <= i < last\n        for i in range(c_index[0], c_index[-1]):\n            if i >= c_index[p + 1]:\n                p += 1\n            res[i] = min(i - c_index[p], c_index[p + 1] - i)\n\n        return res\n\n        # time: O(len(s)), traverse twice\n        # space: len(c_index), max = len(s)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432686892","body":"```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.increments = []\n        self.size = 0\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.stack.append(x)\n            self.increments.append(0)\n            self.size += 1\n        \n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n\n        # the value to pop = sum of two stacks' tops\n        top_ele = self.stack.pop()\n        top_inc = self.increments.pop()\n        self.size -= 1\n\n        # if stack is not empty, calculate the increments's top\n        if self.size:\n            self.increments[self.size - 1] += top_inc\n\n        return top_ele + top_inc\n\n\n    def increment(self, k: int, val: int) -> None:\n        if self.size == 0:\n            return\n        \n        # Add the val only to the index where the inc will be the first one to pop\n        self.increments[min(k, self.size) - 1] += val\n\n\n    # Delayed calcutation\n    # time: O(1) for push, pop, increment operations\n    # space: O(maxSize), two stacks\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434158232","body":"```py\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n\n        for ch in s:\n            # kepp pushing\n            if ch != \"]\":\n                stack.append(ch)\n\n            else:\n                ele = \"\"\n                count = \"\"\n\n                while stack[-1].isalpha():\n                    ele = stack.pop() + ele\n                # pop \"]\"\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    count = stack.pop() + count\n\n                stack.append(int(count) * ele)\n        \n        return \"\".join(stack)\n\n        # time: O(N)\n        # space: O(N)\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435648159","body":"```py\nclass MyQueue:\n    def __init__(self):\n        self.in_stack = []\n        self.out_stack = []\n        \n    def push(self, x: int) -> None:\n        self.in_stack.append(x)\n        \n    def pop(self) -> int:\n        self.supplementOutStack()\n        return self.out_stack.pop()\n\n    def peek(self) -> int:\n        self.supplementOutStack()\n        return self.out_stack[-1]\n    \n    def supplementOutStack(self) -> None:\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n           \n    def empty(self) -> bool:\n        return not self.in_stack and not self.out_stack\n    \n    # Two stacks, one for enqueueing and another for dequeueing\n    # time: \n    # - push, empty: O(1)\n    # - pop, peek  amortized O(1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435906419","body":"```py\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n\n        for num in arr:\n            largest = num\n            while stack and stack[-1] > num:\n                largest = max(largest, stack.pop())\n            stack.append(largest)\n        \n        return len(stack)\n\n        # mono stack\n        # time: O(n)\n        # space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436962757","body":"```py\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next: \n            return head\n\n        # in order to make it a circular linked list and count the length,\n        # iterate to find the tail node and link the tail.next to head\n        length = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            length += 1\n        cur.next = head\n\n        newTail = head\n        for i in range(length - k % length - 1):\n            newTail = newTail.next\n        newHead = newTail.next\n        newTail.next = None\n\n        return newHead\n        \n        # time: O(N)\n        # space: O(1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438101482","body":"```py\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(-1)\n        dummy.next = head\n        \n        pre = dummy\n        first = head\n\n        while first and first.next:\n            second = first.next \n            suc = second.next\n\n            # Swap the two nodes\n            pre.next = second\n            second.next = first\n            first.next = suc\n            \n            # Move prev pointer to first node in swapped pair\n            pre = first\n            first = suc\n        \n        return dummy.next\n\n        # iteration \n        # time: O(n)\n        # space: O(1)\n```\n\n```py\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        \n        first = head\n        second = head.next\n\n        first.next = self.swapPairs(second.next)\n        second.next = first\n\n        return second\n\n        # recursion\n        # time: O(n)\n        # space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439669532","body":"```py\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n\n        def get_length(node):\n            length = 0\n            cur = node\n            while cur:\n                cur = cur.next\n                length += 1\n            return length\n        \n        def build_bst(left, right):\n            nonlocal head\n            # Base case: \n            # when the start index exceeds the end index, return None\n            if left > right:\n                return None\n\n            mid = (left + right) // 2\n\n            # Recursively construct the left and right subtrees of the current root node\n            left = build_bst(left, mid - 1)\n            # Create the root node using the middle element\n            root = TreeNode(head.val)\n            root.left = left\n\n            head = head.next\n\n            right = build_bst(mid + 1, right)\n            root.right = right\n\n            return root\n\n        length = get_length(head)\n        return build_bst(0, length - 1)\n\n    # time: O(nlogn)\n    # space: O(logn)\n```\n\n```py\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        # The pointer used to disconnect the left half from the mid node.\n        def getMiddle(node):\n            pre = None\n            slow = node\n            fast = node\n            \n            # Iterate until fast pointer doesn't reach the end of the linked list.\n            while fast and fast.next:\n                pre = slow\n                slow = slow.next\n                fast = fast.next.next\n            \n            # Handling the case when slow pointer was equal to head.\n            if pre:\n                pre.next = None\n            \n            return slow\n        \n        if not head:\n            return None\n        \n        # The mid becomes the root of the BST.\n        mid = getMiddle(head)\n        root = TreeNode(mid.val)\n\n         # Base case: \n         # when there is just one element in the linked list\n        if head == mid:\n            return root\n        \n        # Recursively form balanced BSTs using the left and right halves of the original list.\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n\n        return root\n\n    # time: O(nlogn)\n   # space: O(logn)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441283015","body":"```py\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        pa = headA\n        pb = headB\n\n        while pa != pb:\n            pa = pa.next if pa else headB\n            pb = pb.next if pb else headA\n        \n        return pa\n       \n        # two pointers\n        # time: O(len(A) + len(B))\n        # space: O(1)\n\n        # In the case lists do not intersect, the pointers for A and B  will still line up in the 2nd iteration, \n        # just that here won't be a common node down the list and both will reach their respective ends at the same time. \n        # So pA will be NULL in that case.\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"el1as7":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429303877","body":"思路：两个数组，从最后位开始依次计算。遇到结果大于10的留位。\n\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        length=len(num)\n        res=[]\n        n=length-1\n        summary,carry=0,0\n        while n >=0 or k !=0: \n            upper_end=num[n] if n>=0 else 0\n            low_end=k%10 if k !=0 else 0\n            summary=upper_end+low_end+carry\n            carry = summary // 10\n            k//=10\n            n-=1\n            res.append(summary%10)\n        if carry !=0: \n            res.append(carry)\n        return res[::-1]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431302350","body":"\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        l = r = 0\n        n = len(s)\n        res = [n] * n\n        flag = False  \n        while r <= n - 1:\n            if s[r] == c:\n                res[r] = 0\n                while l <= r:\n                    res[l] = min(res[l], r - l)\n                    l += 1\n                r += 1\n                flag = True\n            else:\n                if flag:\n                    res[r] = res[r-1] + 1\n                r += 1\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432934190","body":"class CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top < self.maxSize - 1:\n            self.top += 1\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        value = self.stack[self.top]\n        self.top -= 1\n        return value\n\n    def inc(self, k: int, val: int) -> None:\n        length = min(k, self.top + 1)\n        for i in range(length):\n            self.stack[i] += val\n首先检查栈是否为空，如果为空，则返回 -1。否则的话弹出栈顶元素并将其返回","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434703109","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zcytm3000":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429313172","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        a=0\n        for i in num:\n            a = i + a*10\n        s = a + k\n        ar=[]\n        for i in str(s):\n            ar.append(int(i))\n        return ar","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430688419","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        a=[]\n        b=[]\n        for i,ch in enumerate(s):\n            if ch==c:\n                b.append(int(i))\n        return([min(abs(x-i) for i in b) for x in range(len(s))])","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432919837","body":"class CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.stack:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i]+=val","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434390170","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n       num_stack = [] \n       char_stack = []\n       res = ''\n       num_str = ''\n       for i in s:\n           if i.isdigit():\n               num_str+=i\n           elif i == '[':\n               char_stack.append(res)\n               num_stack.append(num_str)\n               res = ''\n               num_str = ''\n           elif i == ']':\n               res = char_stack.pop() + int(num_stack.pop()) * res \n           else:\n               res += i\n       return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435690424","body":"class MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack_in = []\r\n        self.stack_out = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_in.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n        \r\n        if self.stack_out:\r\n            return self.stack_out.pop()\r\n        else:\r\n            for i in range(len(self.stack_in)):\r\n                self.stack_out.append(self.stack_in.pop())\r\n            return self.stack_out.pop()\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack_out.append(ans)\r\n        return ans\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not (self.stack_in or self.stack_out)\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435995168","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        cnt = Counter()\n        res = 0\n        for x, y in zip(arr, sorted(arr)):\n            cnt[x] += 1\n            if cnt[x] == 0:\n                del cnt[x]\n            cnt[y] -= 1\n            if cnt[y] == 0:\n                del cnt[y]\n            if len(cnt) == 0:\n                res += 1\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436633696","body":"class Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n        \r\n        n = 1\r\n        cur = head\r\n        while cur.next:\r\n            cur = cur.next\r\n            n += 1\r\n        \r\n        if (add := n - k % n) == n:\r\n            return head\r\n        \r\n        cur.next = head\r\n        while add:\r\n            cur = cur.next\r\n            add -= 1\r\n        \r\n        ret = cur.next\r\n        cur.next = None\r\n        return ret","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439834914","body":"class Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        \n        return buildTree(head, None)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441397067","body":"class Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        unordered_set<ListNode *> visited;\n        ListNode *temp = headA;\n        while (temp != nullptr) {\n            visited.insert(temp);\n            temp = temp->next;\n        }\n        temp = headB;\n        while (temp != nullptr) {\n            if (visited.count(temp)) {\n                return temp;\n            }\n            temp = temp->next;\n        }\n        return nullptr;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pangjiadai":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429328694","body":"## Python3\n```python\nimport math \nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num_value = 0\n        num_length = len(num)\n\n        for i in num:\n            if i != 0:\n                num_value += i * pow(10, num_length-1)\n            num_length -= 1\n\n        total = num_value + k\n        return [int(x) for x in str(total)]\n```\n\n## Complexity:\n- time: O(n)\n- space: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432506382","body":"```Python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        # stack: FILO, append, pop\n        self.stack = []\n        self.size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        pointer = 0\n        for i in range(min(k, len(self.stack))):\n            self.stack[pointer] += val \n            pointer += 1\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439490333","body":"```python3\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head: return None\n        if not head.next: return TreeNode(head.val)\n\n        fast = slow = head\n        prev = None\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        root = TreeNode(slow.val)\n        prev.next = None\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xb798298436":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429336757","body":"addToArrayForm(array,k){\n    let str = \"\";\n    for(let i in array){\n      str += array[i];\n    }\n    let res = (parseInt(str)+k).toString().split('');\n    return res;\n  }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430913022","body":"getDistance(s, c) {\n    let n = s.length;\n    let res = [];\n    let pos = -n;\n    for (let i = 0; i < n; i++) {\n      if (s[i] === c) {\n        pos = i;\n      }\n      res[i] = i - pos;\n    }\n\n    for (let i = n - 1; i >= 0; i--) {\n      if (s[i] === c) {\n        pos = i;\n      }\n      res[i] = Math.min(res[i], pos - i);\n    }\n\n    return res;\n  }","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436422001","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        int len = 1;\n        ListNode p = head;\n        while(p.next != null){\n            p = p.next;\n            len++;\n        }\n        p.next = head;\n        k = k % len;\n        k = len - k;\n        for(int i = 0; i < k; i++) {\n            p = p.next;\n        }\n        ListNode res = p.next;\n        p.next =null;\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ywang525":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429339866","body":"class Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        add = 0\r\n        res = [0]*len(num)\r\n        for i in range(len(num)-1, -1, -1):\r\n            if num[i] + k%10 + add < 10:\r\n                res[i] = num[i] + k%10 + add\r\n                add = 0  \r\n            else:\r\n                res[i] = num[i] + k%10 + add - 10\r\n                add = 1\r\n            k = k // 10\r\n        if add == 0 and k == 0:\r\n            return res\r\n        else:\r\n            n = add + k\r\n            while (n % 10 != 0) or (n // 10 != 0):\r\n                res = [n%10] + res\r\n                n = n//10\r\n            return res\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1432642389","body":"class Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        output = [0]*len(s)\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                res.append(i)\r\n        for i in range(len(s)):\r\n            minV = inf\r\n            for j in range(len(res)):\r\n                minV = min(minV, abs(res[j]-i))\r\n            output[i] = minV\r\n        return output","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"limbo42":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429352458","body":"```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> vec;\n        while(k) {\n            vec.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(vec.begin(), vec.end());\n        int add = 0;\n        vector<int> ans;\n        int i = vec.size()-1;\n        int j = num.size()-1;\n        while(i >= 0 && j >= 0) {\n            int sum = vec[i] + num[j] + add;\n            if(sum >= 10) {\n                sum -= 10;\n                add = 1;\n            } else {\n                add = 0;\n            }\n            ans.push_back(sum);\n            i--;\n            j--;\n        }\n        // cout << 1;\n        while(i >= 0) {\n            int sum = vec[i] + add;\n            if(sum >= 10) {\n                sum -= 10;\n                add = 1;\n            } else {\n                add = 0;\n            }\n            ans.push_back(sum);\n            i--;\n        }\n        // cout << 2;\n        while(j >= 0) {\n            int sum = num[j] + add;\n            if(sum >= 10) {\n                sum -= 10;\n                add = 1;\n            } else {\n                add = 0;\n            }\n            ans.push_back(sum);\n            j--;\n        }\n        // cout << 3;\n        if(add) {\n            ans.push_back(1);\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430607361","body":"```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> ans(s.length(), s.length());\n        int pre = 2 * s.length();\n        for(int i = 0; i < s.length(); ++i) {\n            // 先记录离左边最近的\n            if(s[i] == c) {\n                pre = i;\n            }\n            ans[i] = min(abs(i - pre), ans[i]);\n        }\n        pre = 2 * s.length();\n        for(int i = s.length()-1; i >=0; --i) {\n            // 先记录离左边最近的\n            if(s[i] == c) {\n                pre = i;\n            }\n            ans[i] = min(abs(i - pre), ans[i]);\n        }\n        return ans;\n    }\n}c++;\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432323315","body":"```C++\nclass CustomStack {\npublic:\n    // 差分数组\n    vector<int> vec;\n    vector<int> add;\n    int size_;\n    CustomStack(int maxSize) {\n        size_ = maxSize;\n    }\n    \n    void push(int x) {\n        if(vec.size() < size_) {\n            vec.push_back(x);\n            add.push_back(0);\n        }\n    }\n    \n    int pop() {\n        if(vec.size() == 0) return -1;\n        int num = vec.back();\n        vec.pop_back();\n        int diff = add.back();\n        num += diff;\n        add.pop_back();\n        if(add.size() >= 1)\n            add[add.size()-1] += diff;\n        return num;\n    }\n    \n    void increment(int k, int val) {\n        // 支持范围+val\n        if(vec.size() == 0) return;\n        if(vec.size() < k) {\n            add[vec.size()-1] += val;\n        } else {\n            add[k-1] += val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434009949","body":"```C++\nclass Solution {\npublic:\n    \n    string decodeString(string s) {\n        int num = 0;\n        string ans = \"\";\n        int pre = 0;\n        int i = 0;\n        while(i < s.length()) {\n            if(s[i] >= 'a' && s[i] <= 'z') {\n                ans += s[i++];\n            } else if(isdigit(s[i])) {\n                int num = 0;\n                int j = i;\n                for(; j < s.length(); ++j) {\n                    if(isdigit(s[j])) {\n                        num *= 10;\n                        num += s[j] - '0';\n                    } else {\n                        break;\n                    }\n                }\n                // cout << num << \" \";\n                int count = 0;\n                int k = j;\n                for(; k < s.length(); ++k) {\n                    if(s[k] == '[') count++;\n                    else if(s[k] == ']') count--;\n                    if(count == 0) break;\n                }\n                // k指向] , j 为[\n                string str = s.substr(j+1, k-j-1);\n                // cout << str << \" \";\n                for(int p = 0; p < num; ++p) {\n                    ans += decodeString(str);\n                }\n                i = k + 1;\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435433089","body":"```C++\nclass MyQueue {\nprivate:\n    stack<int> st1;\n    stack<int> st2;\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        st1.push(x);\n    }\n    \n    int pop() {\n        if(!st2.empty()) {\n            int res = st2.top();\n            st2.pop();\n            return res;\n        }\n        while(!st1.empty()) {\n            int num = st1.top();\n            st1.pop();\n            st2.push(num);\n        }\n        int res = st2.top();\n            st2.pop();\n            return res;\n    }\n    \n    int peek() {\n        if(!st2.empty()) {\n            int res = st2.top();\n            return res;\n        }\n        while(!st1.empty()) {\n            int num = st1.top();\n            st1.pop();\n            st2.push(num);\n        }\n        return st2.top();\n    }\n    \n    bool empty() {\n        return st1.empty() && st2.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435992621","body":"```C++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        // 右边的最小值，需要大于左边的最大值\n        vector<int> rightMIN(arr.size(), 0);\n        int min_num = arr[arr.size()-1];\n        for(int i = arr.size()-1; i >= 0; --i) {\n            min_num = min(min_num, arr[i]);\n            rightMIN[i] = min_num;\n        }\n        int count = 0;\n        int cur_max = arr[0];\n        for(int i = 0; i + 1 < arr.size(); ++i) {\n            if(cur_max <= rightMIN[i+1]) {\n                count++;\n                cur_max = arr[i+1];\n            } else {\n                cur_max = max(cur_max, arr[i]);\n            }\n        }\n        return count + 1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436154766","body":"```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head == nullptr) return head;\n        int size = 0;\n        ListNode* cur = head;\n        while(cur) {\n            cur = cur->next;\n            size++;\n        }\n        if(size == 0) return head;\n        int num = k % size;\n        if(num == 0) return head;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(num) {\n            num--;\n            fast = fast->next;\n        }\n        while(fast->next) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        ListNode* ans = slow->next;\n        slow->next = nullptr;\n        fast->next = head;\n        return ans;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438220031","body":"```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr) return head;\n        if(head->next == nullptr) return head;\n        ListNode* cur = head;\n        ListNode* pre = nullptr;\n        ListNode* ans = nullptr;\n        while(cur) {\n            ListNode* next = cur->next;\n            if(ans == nullptr) ans = next;\n            if(next == nullptr) break;\n            ListNode* node = next->next;\n            if(pre != nullptr) {\n                pre->next = next;\n            }\n            pre = cur;\n            cur->next = node;\n            next->next = cur;\n            cur = node;\n        }\n        return ans;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439305515","body":"```C++\nclass Solution {\npublic:\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        // 递归\n        // 找到中间节点作为根节点\n        if(head == nullptr) return nullptr;\n        if(head->next == nullptr) return new TreeNode(head->val);\n        // cout << head->val<< \" \" ;\n        ListNode* pre = nullptr;\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while(fast != nullptr && fast->next) {\n            pre = slow;\n            slow = slow->next;\n            if(fast->next == nullptr) break;\n            fast = fast->next->next;\n        }\n        if(pre != nullptr) {\n            pre->next = nullptr;\n        }\n\n        TreeNode* root = new TreeNode(slow->val);\n        root->left = sortedListToBST(head);\n        root->right = sortedListToBST(slow->next);\n        return root;\n\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dorapocket":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429417644","body":"```c++\r\nclass Solution {\r\n\r\npublic:\r\n    vector<int> num2arr(int num){\r\n        vector<int> v;\r\n        while(num!=0){\r\n            int last = num%10;\r\n            num = num/10;\r\n            v.push_back(last);\r\n        }\r\n        return v;\r\n    }\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> kv = num2arr(k);\r\n        vector<int> res;\r\n        reverse(num.begin(),num.end());\r\n        int i=0;\r\n        int over = 0;\r\n        while(i<num.size()&&i<kv.size()){\r\n            int n = num[i]+kv[i]+over;\r\n            over = n/10;\r\n            res.push_back(n%10);\r\n            i++;\r\n        }\r\n        while(i<num.size()||i<kv.size()){\r\n            int n = ((i<num.size())?num[i]:kv[i])+over;\r\n            over = n/10;\r\n            res.push_back(n%10);\r\n            i++;\r\n        }\r\n        if(over) res.push_back(over);\r\n        reverse(res.begin(),res.end());\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431470683","body":"```c++\nclass Solution {\npublic:\n    int getMinDis(string s,int idx,char c){\n        int i=idx;\n        int tmp = s.size()+1;\n        while(i>=0){\n            if(s[i]==c) {tmp = min(tmp,idx-i);break;}\n            i--;\n        }\n        i=idx;\n        while(i<s.size()&&i-idx<tmp){\n            if(s[i]==c) {tmp = min(tmp,i-idx);break;}\n            i++;\n        }\n        return tmp;\n    }\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> v;\n        for(auto i=0;i<s.size();i++){\n            v.emplace_back(getMinDis(s,i,c));\n        }\n        return v;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432999782","body":"```c++\r\nclass CustomStack {\r\npublic:\r\n    int maxSize=0;\r\n    vector<int> v;\r\n    CustomStack(int m) {\r\n        maxSize=m;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(v.size()<maxSize) v.emplace_back(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if(v.size()>0){\r\n            int i = v.back();\r\n            v.pop_back();\r\n            return i;\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for(int i=0;i<k&&i<v.size();i++){\r\n            v[i]+=val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434734823","body":"```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res;\n        for (int i = 0; i < s.size(); ++i) {\n            if (s[i] == '[') {\n                int k, l=i-1, r=i, n=1;\n                while (l >= 0 && isdigit(s[l])) --l;\n                ++l;\n                k = stoi(s.substr(l, i - l));\n                while (n != 0) {\n                    ++i;\n                    if (s[i] == '[') ++n;\n                    if (s[i] == ']') --n;\n                }\n                string str = decodeString(s.substr(r + 1, i - r - 1));\n                for (int i = 0; i < k; ++i) res += str; \n            }\n            if (isalpha(s[i])) res += s[i];\n        }\n        return res == \"\" ? s : res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435642202","body":"```c++\nclass MyQueue {\npublic:\n        stack<int> rev;\n        stack<int> q;\n        bool isRev=true;\n    MyQueue() {\n\n    }\n    void _q2rev(){\n        while(!q.empty()){\n            rev.push(q.top());\n            q.pop();\n        }\n        isRev=true;\n    }\n    void _rev2q(){\n        while(!rev.empty()){\n            q.push(rev.top());\n            rev.pop();\n        }\n        isRev=false;\n    }\n\n    void push(int x) {\n        if(!isRev) _q2rev();\n        rev.push(x);\n    }\n    \n    int pop() {\n        if(isRev) _rev2q();\n        int i=q.top();\n        q.pop();\n        return i; \n    }\n    \n    int peek() {\n        if(isRev) _rev2q();\n        return q.top(); \n    }\n    \n    bool empty() {\n        return rev.empty()&&q.empty();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436182301","body":"```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        vector<int> maxV(arr.size());\n        vector<int> minV(arr.size());\n        int maxi = INT_MIN;\n        for (int i = 0; i < arr.size(); ++i)\n            maxV[i] = maxi = max(maxi, arr[i]);\n        int mini = INT_MAX;\n        for (int i = arr.size() - 1; i >= 0; --i)\n            minV[i] = mini = min(mini, arr[i]);\n        int result = 0;\n        for (int i = 0; i < arr.size(); ++i)\n            if (i == arr.size() - 1 || maxV[i] <= minV[i + 1])\n            ++result;\n        return result;\n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436201012","body":"```c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head==nullptr) return head;\n        vector<ListNode*> l;\n        ListNode* p=head;\n        while(p!=nullptr) { l.emplace_back(p); p=p->next;}\n        k=k%l.size();\n        if(k==0) return head;\n        l[l.size()-1]->next = l[0];\n        l[l.size()-k-1]->next = nullptr;\n        return l[l.size()-k];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438516556","body":"```c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head==nullptr) return head;\n        ListNode top(-1,head);\n        ListNode* p0=&top,*p1=head,*p2=head->next,*p3;\n        p2=p1==nullptr?nullptr:p1->next;\n        while(p1!=nullptr&&p2!=nullptr){\n            p3=p2->next;\n            p0->next=p2;\n            p0=p2->next=p1;\n            p1=p1->next=p3;\n            p2=p3==nullptr?p3:p3->next;\n            p3=p2==nullptr?p3:p2->next;\n        }\n        return top.next;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440162927","body":"```c++\nclass Solution {\npublic:\n    ListNode* mid(ListNode* l,ListNode* r){\n        ListNode* p1=l,*p2=l;\n        while(p2!=r&&p2->next!=r){\n            p1=p1->next;\n            p2=p2->next->next;\n        }\n        return p1;\n    }\n    TreeNode* build(ListNode* l,ListNode* r){\n        if(l==r) return nullptr;\n        TreeNode* t = new TreeNode();\n        ListNode* m = mid(l,r);\n        t->val = m->val;\n        t->left = build(l,m);\n        t->right = build(m->next,r);\n        return t;\n    }\n    TreeNode* sortedListToBST(ListNode* head) {\n        return build(head,nullptr);\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoeyzyzyzy":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429421064","body":"``` java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        List<Integer> res = new ArrayList<>();\n        int i = n - 1, sum = 0, carry = 0;\n        while (i >= 0 || k != 0) {\n            int x = i >= 0 ? num[i] : 0;\n            int y = k != 0 ? k % 10 : 0;\n\n            sum = x + y + carry;\n            carry = sum / 10;\n            k = k / 10;\n\n            i--;\n            res.add(0, sum % 10);\n        }\n        if (carry != 0)\n            res.add(0, carry);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430987728","body":"### Thought\n- thinking of how to get distance between c and s.charAt(i);\n- go through the string twice 1 order and 1 reverse order;\n- in order is to traverse c in left situation, for first part(left has no c): make idx to -n;\n- reverse order is to traverse c in right situation, for last part(right has no c): make idx to 2*n;\n- find minium.\n### Code\n``` java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] res = new int[n];\n\n        for (int i = 0, idx = -n; i < n; i++) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            res[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            res[i] = Math.min(res[i], idx - i);\n        }\n        return res;\n    }\n}\n```\n### Complexity\nTime complexity : O(n), traverse twice\n\nSpace complexity : O(n) array with size n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432758412","body":"``` java\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1433583760","body":"### Thought\nSince this problem we need to process the string in a nested manner, that is we need to process substring inside brackets before processing the outer substrings. A stack is a natural choice for this kind of problem because it allows us keep track of the order in which we encounter brackets.  Step by step:\n\n1. Initialize a string \"res\" to store the final decoded string, an integer \"curNumber\" to store the current number being processed, and two empty stacks: one to store the previous results and another to store the previous numbers.\n\n2. Loop through each character in the input string \"s\":\n\n    -  If the current character \"ch\" is a digit, update the current number \"curNumber\" by appending the digit to the end of the current number.\n\n    -  If the current character \"ch\" is an opening bracket '[', push the current number \"curNumber\" and the current result \"res\" onto their respective stacks, and reset \"curNumber\" and \"res\" to empty strings to start processing the substring inside the brackets.\n\n    -  If the current character \"ch\" is a closing bracket ']', pop the top element \"prevRes\" from the result stack and the top element \"prevNum\" from the number stack. Repeat the substring \"res\" \"prevNum\" times and append the resulting string to \"prevRes\". Set \"res\" to the new \"prevRes\" and continue processing the rest of the string.\n\n    -  If the current character \"ch\" is a letter, append it to the current result \"res\".\n\n3. Once the loop is complete, return the final decoded string \"res\".\n\n### Code\n``` java\nclass Solution {\n    public String decodeString(String s) {\n        LinkedList<String> stringStack = new LinkedList<>();\n        LinkedList<Integer> numStack = new LinkedList<>();\n        StringBuilder sb = new StringBuilder();\n        int curNum = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            char cur = s.charAt(i);\n            if (cur >= '0' && cur <= '9') {\n                curNum = curNum * 10 + (cur - '0');\n            } else if (cur == '[') {\n                stringStack.push(sb.toString());\n                numStack.push(curNum);\n                curNum = 0;\n                sb = new StringBuilder();\n            } else if (cur == ']') {\n                StringBuilder tem = new StringBuilder();\n                int cur_num = numStack.pop();\n                for (int j = 0; j < cur_num; j++) {\n                    tem.append(sb);\n                }\n                sb = new StringBuilder(stringStack.pop() + tem);\n            } else {\n                sb.append(cur);\n            }\n        }\n        return sb.toString();\n    }\n}\n```\n\n### Complexity:\nTime: O(n), loop through the input string 1 once.\n\nSpace: O(n), in the worst case, where the input string is fully nested, the maximum size of the stacks would be O(n/2). ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435129875","body":"``` java\n/* \n * imlpement a FIFO queue using only 2 stacks, stack is FILO, \n * so we can think of use one stack to store In and other for Out.\n * We can also have a variable to store front value to decrease time complexity.\n */\n\nclass MyQueue {\n    LinkedList<Integer> stackIn;\n    LinkedList<Integer> stackOut;\n\n    public MyQueue() {\n        stackIn = new LinkedList<>();\n        stackOut = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        stackIn.push(x);\n    }\n\n    public int pop() {\n        if (stackOut.isEmpty()) {\n            while (!stackIn.isEmpty()) {\n                stackOut.push(stackIn.pop());\n            }\n        }\n        return stackOut.pop();\n    }\n\n    public int peek() {\n        if (stackOut.isEmpty()) {\n            while (!stackIn.isEmpty()) {\n                stackOut.push(stackIn.pop());\n            }\n        }\n        return stackOut.peek();\n    }\n\n    public boolean empty() {\n        return stackIn.isEmpty() && stackOut.isEmpty();\n    }\n}\n\n//Time Complexity: push(), empty(): O(1), pop() and peek() amortized time complexity(best situation) : O(1)\n//Space Complexity: O(n)\n\nclass MyQueue1 {\n    LinkedList<Integer> stack1;\n    LinkedList<Integer> stack2;\n    int front;\n\n    public MyQueue1() {\n        stack1 = new LinkedList<>();\n        stack2 = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        if (stack1.isEmpty())\n            front = x;\n        stack1.push(x);\n    }\n\n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n\n    }\n\n    public int peek() {\n        if (!stack2.isEmpty())\n            return stack2.peek();\n        return front;\n    }\n\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n\n//Time Complexity: push(), empty(), peek(): O(1), pop(): amortized time complexity(best situation) : O(1)\n//Space Complexity: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435938082","body":"``` java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436655593","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438202403","body":"```java\nclass Solution {\n   public ListNode swapPairs(ListNode head) {\n      ListNode node = new ListNode(0);\n        node.next = head;\n        ListNode ptr = head;\n        while (ptr!= null && ptr.next != null) {\n            ListNode newNode = ptr.next;\n            ptr.next = newNode.next;\n            newNode.next = ptr;\n            ptr = ptr.next;\n        }\n        return node.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1438987722","body":"```java\nclass Solution {\n    // Initial thought: put each node's val in to map and recursively access this\n    // map build tree.\n    // optimization: can use array istead of map to save space\n    // howerver did not use property of LinkedList\n    // time complexity: O(n), space complexity: O(n + logN)\n    HashMap<Integer, Integer> map = new HashMap<>();\n\n    public TreeNode sortedListToBST1(ListNode head) {\n        int index = 0;\n        ListNode l1 = head;\n        while (l1 != null) {\n            map.put(index, l1.val);\n            l1 = l1.next;\n            index++;\n        }\n        // System.out.println(index);\n        return helper(0, index - 1);\n    }\n\n    private TreeNode helper(int start, int end) {\n        TreeNode root = new TreeNode();\n        if (start > end)\n            return null;\n        int mid = (start + end) >>> 1;\n        root.val = map.get(mid);\n        root.left = helper(start, mid - 1);\n        root.right = helper(mid + 1, end);\n        return root;\n    }\n\n    // Another thought: use fast and slow pointer to find the midian node;\n    // important note : we need a pointer - pre to make the left part of linkedList's length change, otherwise we can not know the end of left part.\n    // time complexity : O(N),  space complexity: O(logN)\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null)\n            return null;\n        if (head.next == null)\n            return new TreeNode(head.val);\n\n        ListNode p = head, q = head, pre = null;\n        while (q != null && q.next != null) {\n            pre = p;\n            p = p.next;\n            q = q.next.next;\n        }\n        pre.next = null;\n\n        TreeNode root = new TreeNode(p.val);\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(p.next);\n        return root;\n    }\n\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1440765717","body":"```java\r\npublic class Solution {\r\n    // A : a + c B: b + c  if A & B intersect, if will have a+b+c; else a+b => null\r\n   // TC:O(m+n) SC:O(1)\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode p1 = headA, p2 = headB;\r\n        while (p1 != p2) {\r\n            p1 = p1 == null ? headB : p1.next;\r\n            p2 = p2 == null ? headA : p2.next;\r\n        }\r\n        return p1;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jasonqiu":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429514656","body":"- Convert `k` to string\r\n- Pointers `pn` `pk` against `num` `k` respectively\r\n- Start from the ends and continue until both go beyond the first element. One may finish earlier than the other - always set the value to `0` afterwards\r\n- Append the carried bit (if any) and reverse\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        pn = len(num) - 1\r\n        k = str(k)\r\n        pk = len(k) - 1\r\n        carry = 0\r\n        result = []\r\n        while pn >= 0 or pk >= 0:\r\n            a = num[pn] if pn >= 0 else 0\r\n            b = k[pk] if pk >= 0 else 0\r\n            s = int(a) + int(b) + carry\r\n            result.append(s % 10)\r\n            carry = 1 if s >= 10 else 0\r\n            pn -= 1\r\n            pk -= 1\r\n        if carry > 0:\r\n            result.append(1)\r\n        return result[::-1]\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431064325","body":"- Set `last` (last position of the character) to a large negative number\r\n-  Scan from the beginning. Distances to the nearest `c` in the left direction are calculated in this process. `last` will be updated at the position where `c` is found\r\n- Set `last` to a large positive number\r\n- Scan from the end of `s`. When distance to the nearest `c` in the right direction is shorter, update the answer with that distance. Again, `last` will be updated at the position where `c` is found\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        answer = []\r\n        last = -16383\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                last = i\r\n            answer.append(i - last)\r\n        last = 16384\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                last = i\r\n            answer[i] = min(last - i, answer[i])\r\n        return answer\r\n```\r\nTime: O(n)\r\nSpace: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432860740","body":"- Use List\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i] += val\r\n```\r\nTime: `push()` O(1), `pop()` O(1), `increment()` O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434634231","body":"- Create a string `k` and a stack where each element is [current_k, string_to_be_repeated] and initialise with [1, '']\r\n- Start from the beginning. If the character is\r\n        - a letter: append to the last string_to_be_repeated\r\n        - a digit: append to k\r\n        - `[`: append to `k` and append a new element [k, ''] to the stack\r\n        - `]`: pop the last element from the stack, generate the decoded string and append it to string_to_be_repeated of the last element of the stack\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = [[1, '']]\r\n        k = ''\r\n        for i in range(len(s)):\r\n            if s[i].isalpha():\r\n                queue[-1][1] += s[i]\r\n            elif s[i].isdigit():\r\n                k += s[i]\r\n            elif s[i] == '[':\r\n                stack.append([int(k), ''])\r\n                k = ''\r\n            elif s[i] == ']':\r\n                seg = stack.pop()\r\n                stack[-1][1] += seg[1] * seg[0]\r\n        return stack[0][1]\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435613618","body":"- Use the second stack as a reversed stack\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack = []\r\n        self.stackR = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stackR) == 0:\r\n            for i in range(len(self.stack)):\r\n                self.stackR.append(self.stack.pop(-1))\r\n        return self.stackR.pop(-1)\r\n\r\n    def peek(self) -> int:\r\n        if len(self.stackR) == 0:\r\n            for i in range(len(self.stack)):\r\n                self.stackR.append(self.stack.pop(-1))\r\n        return self.stackR[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return len(self.stack) == 0 and len(self.stackR) == 0\r\n```\r\nTime: `push()` `empty()` O(1), `pop()` `peek()` amortised O(1)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435995936","body":"- The presence of a smaller integer in the rear of the sequence will lead to the number of chunks being less, as that integer must be equal to or greater than any element in previous chunks\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = [arr[0]]\r\n        curMax = 0\r\n        for i in range(1, len(arr)):\r\n            if arr[i] >= stack[-1]:\r\n                stack.append(arr[i])\r\n            else:\r\n                curMax = stack[-1]\r\n                while stack and arr[i] < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(curMax)\r\n        return len(stack)\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437132602","body":"- Iterate along till the end and get the length of the linked list\r\n- Link the tail with the head to make it a ring\r\n- Move `length - (k % length)` steps to reach the last element of the new linked list\r\n- Make it the tail\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if head is None:\r\n            return None\r\n        p = head\r\n        length = 1\r\n        new_head = None\r\n        while p.next:\r\n            p = p.next\r\n            length += 1\r\n        p.next = head\r\n        for i in range(length - (k % length)):\r\n            p = p.next\r\n        new_head = p.next\r\n        p.next = None\r\n        return new_head\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438254173","body":"- Create dummy head `prev` and save the new `head`\r\n- Swap when there are at least two nodes remaining\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        prev = ListNode(0, head)\r\n        if head and head.next:\r\n            head = head.next\r\n        while prev.next and prev.next.next:\r\n            left = prev.next\r\n            right = left.next\r\n            prev.next = right\r\n            left.next = right.next\r\n            right.next = left\r\n            prev = left\r\n        return head\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439991415","body":"- Find the mid point and divide\r\n- Recurse on the left and right part\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n        if not head.next.next:\r\n            return TreeNode(head.next.val, TreeNode(head.val))\r\n        node_before_mid = self.findNodeBeforeMid(head)\r\n        root = TreeNode(node_before_mid.next.val, None, self.sortedListToBST(node_before_mid.next.next))\r\n        node_before_mid.next = None\r\n        root.left = self.sortedListToBST(head)\r\n        return root\r\n\r\n    def findNodeBeforeMid(self, head):\r\n        if not head:\r\n            return head\r\n        slow = head\r\n        fast = head.next\r\n        while fast.next and fast.next.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        return slow\r\n```\r\nTime: O(nlogn)\r\nSpace: O(h)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lp1506947671":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429552710","body":"\n\n```python\n# 思路:从低位到高位依次相加(数组倒叙遍历,数值除10取余),对数值位数大于数组的长度的部分进行边界处理\n\nfrom typing import List\n\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in num[::-1]:\n            sum_item = i + k % 10\n            k //= 10\n            if sum_item >= 10:\n                k += 1\n                sum_item -= 10\n            res.insert(0, sum_item)\n        while k > 0:\n            res.insert(0, k % 10)\n            k //= 10\n        return res\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print(solution.addToArrayForm([1, 2, 0, 0], 34))\n    \n# 时间复杂度:O(max(n,n-k))\n# 空间复杂度:O(n)\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431458904","body":"### 思路\r\n\r\n先获取c字符在s字符中的标记记录在数组c_indices中\r\n\r\n然后遍历字符s中的每个字符,与c_indics中的值也就是c字符所在的索引逐一比较获取最小值\r\n\r\n\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        c_indices = []\r\n        for index, value in enumerate(s):\r\n            if value == c:\r\n                c_indices.append(index)\r\n        result = [None] * len(s)\r\n        for index, value in enumerate(s):\r\n            if value == c:\r\n                result[index] = 0\r\n                continue\r\n            for c_index in c_indices:\r\n                dist = abs(c_index - index)\r\n                if result[index] and dist >= result[index]:\r\n                    break\r\n                result[index] = dist\r\n\r\n        return result\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度: O(N∗K)，N 是 S 的长度，K 是字符 `C` 在字符串中出现的次数，K <= N。 \r\n\r\n空间复杂度 O(K)，K 为字符 `C` 出现的次数，这是记录字符 `C` 出现下标的辅助数组消耗的空间 \r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433144775","body":"### 思路\n\n通过列表的pop和append分别作为栈的出栈入栈操作,需要注意入栈的最大长度和出站的空临界情况\n\n### 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack: return -1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        end = k\n        if len(self.stack) <= k:\n            end = len(self.stack)\n        for index in range(0, end):\n            self.stack[index] += val\n```\n\n### 复杂度\n\n时间复杂度：push 和 pop 操作时间复杂度为O(1),而 increment 操作的时间复杂度为O(min(k,cnt))\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434788852","body":"### 思路\n\n- 构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\n  -  当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\n  - ​\t当 c 为字母时，在 res 尾部添加 c；\n  - ​\t当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 00：\n    - 记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\n    - 记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\n    - 进入到新 [ 后，res 和 multi 重新记录。\n  - 当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\n    - last_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\n    - cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\n- 返回字符串 res\n\n### 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        res = ''\n        stack = []\n        multi = 0\n        for c in s:\n            if c == \"[\":\n                stack.append((res, multi))\n                res = \"\"\n                multi = 0\n            elif c == \"]\":\n                last_res, cur_multi = stack.pop()\n                res = last_res + cur_multi * res\n            elif c.isnumeric():\n                multi = multi * 10 + int(c)\n            else:\n                res += c\n        return res\n```\n\n### 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435500538","body":"\n\n### 思路\n\n构建两个栈一个作为输入栈,一个作为输出栈,输入栈逐个弹出放到输出栈,再从输出栈逐个弹出元素,则可以负负的正\n\n实现先进先出\n\n\n\n### 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.in_stack = []\n        self.out_stack = []\n\n    def push(self, x: int) -> None:\n        self.in_stack.append(x)\n\n    def pop(self) -> int:\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n        return self.out_stack.pop()\n\n    def peek(self) -> int:\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n        return self.out_stack[-1]\n\n    def empty(self) -> bool:\n        if not self.in_stack and not self.out_stack:\n            return True\n        else:\n            return False\n\n```\n\n\n\n\n\n### 复杂度\n\n时间复杂度:push和empty的时间复杂度O(1),pop和peek时间复杂度为O(n)\n\n空间复杂度:O(n)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436010265","body":"### 思路\n\n对于已经分好块的数组，若块数大于 1，则可以得到以下结论：右边的块的所有数字均大于或等于左边的块的所有数字。考虑这个问题：对于已经分好块的数组，若在其末尾添加一个数字，如何求得新数组的分块方式？\n\n新添加的数字可能会改变原数组的分块方式。如果新添加的数字大于或等于原数组最后一个块的最大值，则这个新添加的数字可以自己形成一个块。如果新添加的数字小于原数组最后一个块的最大值，则它必须融入最后一个块。如果它大于或等于原数组倒数第二个块（如果有）的最大值，那么这个过程可以停止，新数组的分块方式已经求得。否则，它将继续融合原数组倒数第二个块，直到遇到一个块，使得该块的最大值小于或等于这个新添加的数，或者这个数字已经融合了所有块。\n\n上述分析过程中，我们只用到了块的最大值来进行比较，比较过程又是从右到左，符合栈的思想，因此可以用类似单调栈的数据结构来存储块的最大值。\n\n\n\n### 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for a in arr:\n            if not stack or a >= stack[-1]:\n                stack.append(a)\n            else:\n                mx = stack.pop()\n                while stack and stack[-1] > a:\n                    stack.pop()\n                stack.append(mx)\n        return len(stack)\n\n```\n\n\n\n### 复杂度\n\n时间复杂度:O(n),其中 n是输入数组 arr 的长度.需要遍历一遍数组,入栈的操作最多为 n次。\n\n空间复杂度:O(n).栈的长度最多为 n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437176312","body":"### 思路\n\n1.创建快慢指针，遍历链表找到快指针位置（倒数第k+1个节点的）；\n2.同时移动快慢指针直到快指针的next没有数据为止,此时慢指针指向新链表的尾节点(这里还要一个指针来记录快指针的前驱节点，这个要看移动情况来定用不用)\n3.对原链表进行拆分并返回新链表头节点即可\n\n\n\n### 代码\n\n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        # 双指针\n        if head:\n            p1 = head\n            p2 = head\n            count = 1\n            i = 0\n            while i < k:\n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                else:\n                    k = k % count\n                    i = -1\n                    p2 = head\n                i += 1\n\n            while p2.next:\n                p1 = p1.next\n                p2 = p2.next\n\n            if p1.next:\n                tmp = p1.next\n            else:\n                return head\n            p1.next = None\n            p2.next = head\n            return tmp\n\n```\n\n\n\n### 复杂度\n\n- 时间复杂度：节点最多只遍历两遍，时间复杂度为O(n)\n- 空间复杂度：未使用**额外**的空间，空间复杂度O(1)\n\n\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438699150","body":"### 思路\n\n1.创建一个空节点pre,让其next指向A,避免判断边界条件\n\n2.然后相邻的节点之间执行如下逆转步骤,直至整个链表被逆转\n\n```python\nA.next=B.next\nB.next=A\npre.next=B\n```\n\n\n\n### 代码\n\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        pre = ListNode(0)\n        pre.next = head\n        temp = pre\n        while temp.next and temp.next.next:\n            node1 = temp.next\n            node2 = temp.next.next\n\n            node1.next = node2.next\n            temp.next = node2\n            node2.next = node1\n\n            temp = node2\n        return pre.next\n```\n\n\n\n### 复杂度\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n\n\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440268193","body":"### 思路\n\n使用快慢双指针可定位中间元素,具体可参考双指针的讲义.这里我简单描述一下算法流程：\n\n1. 获取当前链表的中点\n2. 以链表中点为根\n3. 中点左边的值都小于它,可以构造左子树\n4. 同理构造右子树\n5. 循环第一步\n\n具体算法：\n\n1. 定义一个快指针每步前进两个节点，一个慢指针每步前进一个节点\n2. 当快指针到达尾部的时候，正好慢指针所到的点为中点\n\n\n\n\n\n### 代码\n\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n\n\n\n### 复杂度\n\n- 时间复杂度：递归树的深度为 logn,每一层的基本操作数为 n,因此总的时间复杂度为O(nlogn)\n- 空间复杂度：空间复杂度为O(logn)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"texamc2":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429605508","body":"class Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = 0\r\n        for j, n  in enumerate(num) :\r\n            i = 10 * i + n\r\n        res = i + k\r\n        l = []\r\n        for s in str(res):\r\n            l.append(int(s))\r\n        return l","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431330007","body":"``` \r\nfunc shortestToChar(s string, c byte) []int {\r\n    res := make([]int, len(s))\r\n    for i := 0; i < len(s); i++ {\r\n    l, r := i, i\r\n    for ; l >= 0 && s[i] != c; l = l - 1;{\r\n    }\r\n    for ; r < len(s) && s[i] != c; r = r+1; {\r\n    }\r\n    if l < 0 {\r\n        res[i] = r - i;\r\n     } else if r > len(s) {\r\n        res[i] = i - l;\r\n     } else {\r\n         res[i] = min(i-l, r-i)\r\n     }\r\n     }\r\n     return res\r\n  }\r\n  func min(a, b int) int {\r\n      if a > b {\r\n          return b\r\n         }\r\n       return a\r\n   }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433125628","body":"```\r\ntype CustomStack struct {\r\n\tstack   []int\r\n\tmaxSize int\r\n\tmap_1   map[int]int\r\n}\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n\treturn CustomStack{\r\n\t\tstack:   make([]int, 0),\r\n\t\tmaxSize: maxSize,\r\n\t\tmap_1:   make(map[int]int),\r\n\t}\r\n}\r\n\r\nfunc (this *CustomStack) Push(x int) {\r\n\tif len(this.stack) == this.maxSize {\r\n\t\treturn\r\n\t}\r\n\tthis.stack = append(this.stack, x)\r\n}\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n\tif len(this.stack) == 0 {\r\n\t\treturn -1\r\n\t}\r\n\tv := this.stack[len(this.stack)-1]\r\n\tif inc, has := this.map_1[len(this.stack)]; has {\r\n\t\tv += inc\r\n\t\tdelete(this.map_1, len(this.stack))\r\n\t\tthis.map[len(this.stack)-1]+=inc\r\n\t}\r\n\tthis.stack = this.stack[:len(this.stack)-1]\r\n\treturn v\r\n}\r\n\r\nfunc (this *CustomStack) Increment(k int, val int) {\r\n\tif k > len(this.stack) {\r\n\t\tk = len(this.stack)\r\n\t}\r\n\tthis.map_1[k] += val\r\n\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434611223","body":"```\r\nfunc decodeString(s string) string {\r\n\tstk := []string{}\r\n\tptr:=0\r\n\tfor ptr<len(s){\r\n\t\tcur:=s[ptr]\r\n\t\tif cur>='0' && cur <='9'{\r\n\t\t\tdigits:=getDigits(s,&ptr)\r\n\t\t\tstk = append(stk, digits)\r\n\t\t} else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <= 'Z') || cur=='[' {\r\n\t\t\tstk=append(stk,string(cur))\r\n\t\t\tptr++\r\n\t\t}else{\r\n\t\t\tptr++\r\n            sub:=[]string{}\r\n\t\t\tfor stk[len(stk)-1]!=\"[\"{\r\n\t\t\t\tsub=append(sub,stk[len(stk)-1])\r\n\t\t\t\tstk = stk[:len(stk)-1]\r\n\t\t\t}\r\n\t\t\tfor i:=0;i<len(sub)/2;i++{\r\n\t\t\t\tsub[i],sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i]\r\n\t\t\t}\r\n\t\t\tstk = stk[:len(stk)-1]\r\n\t\t\trepTime,_:=strconv.Atoi(stk[len(stk)-1])\r\n\t\t\tstk = stk[:len(stk)-1]\r\n\t\t\tt:= strings.Repeat(getString(sub), repTime)\r\n\t\t\tstk =append(stk,t)\r\n\t\t}\r\n\r\n\r\n\t\t}\r\n\t\treturn getString(stk)\r\n\t}\r\n\r\n\r\nfunc getDigits(s string, ptr *int) string{\r\n\tret := \"\"\r\n\tfor ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++{\r\n\t\tret += string(s[*ptr])\r\n\t}\r\n\treturn ret\r\n}\r\nfunc getString(v []string)string{\r\n\tret :=\"\"\r\n\tfor _,s :=range v{ //for循环只读value\r\n\t\tret+=s\r\n\t}\r\n\treturn ret\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435676069","body":"```\r\ntype MyQueue struct {\r\n    inStack, outStack []int\r\n}\r\n\r\nfunc Constructor() MyQueue {\r\n    return MyQueue{}\r\n}\r\n\r\nfunc (q *MyQueue) Push(x int) {\r\n    q.inStack = append(q.inStack, x)\r\n}\r\n\r\nfunc (q *MyQueue) in2out() {\r\n    for len(q.inStack) > 0 {\r\n        q.outStack = append(q.outStack, q.inStack[len(q.inStack)-1])\r\n        q.inStack = q.inStack[:len(q.inStack)-1]\r\n    }\r\n}\r\n\r\nfunc (q *MyQueue) Pop() int {\r\n    if len(q.outStack) == 0 {\r\n        q.in2out()\r\n    }\r\n    x := q.outStack[len(q.outStack)-1]\r\n    q.outStack = q.outStack[:len(q.outStack)-1]\r\n    return x\r\n}\r\n\r\nfunc (q *MyQueue) Peek() int {\r\n    if len(q.outStack) == 0 {\r\n        q.in2out()\r\n    }\r\n    return q.outStack[len(q.outStack)-1]\r\n}\r\n\r\nfunc (q *MyQueue) Empty() bool {\r\n    return len(q.inStack) == 0 && len(q.outStack) == 0\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436009700","body":"```\r\nfunc maxChunksToSorted(arr []int) (ans int) {\r\n    cnt := map[int]int{}\r\n    b := append([]int{}, arr...)\r\n    sort.Ints(b)\r\n    for i, x := range arr {\r\n        cnt[x]++\r\n        if cnt[x] == 0 {\r\n            delete(cnt, x)\r\n        }\r\n        y := b[i]\r\n        cnt[y]--\r\n        if cnt[y] == 0 {\r\n            delete(cnt, y)\r\n        }\r\n        if len(cnt) == 0 {\r\n            ans++\r\n        }\r\n    }\r\n    return\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436998707","body":"```\r\n// 旋转链表函数\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n    // 如果链表为空或只有一个结点或k为0，直接返回head\r\n    if head == nil || head.Next == nil || k == 0 {\r\n        return head\r\n    }\r\n    // 定义变量n表示链表长度，tail表示尾结点\r\n    n := 1\r\n    tail := head\r\n    // 遍历链表，更新n和tail\r\n    for tail.Next != nil {\r\n        n++\r\n        tail = tail.Next\r\n    }\r\n    // 计算k对n取模，得到实际需要移动的步数m\r\n    m := k % n\r\n    // 如果m为0，说明不需要旋转，直接返回head\r\n    if m == 0 {\r\n        return head\r\n    }\r\n    // 定义变量cur表示当前结点，初始化为head\r\n    cur := head\r\n    // 从head开始向后走n-m-1步，找到新的尾结点newTail和新的头结点newHead \r\n    for i := 0; i < n - m - 1; i++ {\r\n        cur = cur.Next \r\n\t}\r\n\tnewTail := cur \r\n\tnewHead := cur.Next \r\n\t// 将newTail的next指针置空，将tail的next指针指向head，完成旋转 \r\n\tnewTail.Next = nil \r\n\ttail.Next = head \r\n\t// 返回newHead作为结果 \r\n\treturn newHead \r\n}\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438489135","body":"```\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n    if head == nil || head.Next == nil {\r\n        return head\r\n    }\r\n    newHead := head.Next\r\n    head.Next = swapPairs(newHead.Next)\r\n    newHead.Next = head\r\n    return newHead\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440264256","body":"```\r\n\r\nfunc sortedListToBST(head *ListNode) *TreeNode {\r\n    return buildTree(head, nil)\r\n}\r\n\r\nfunc getMedian(left, right *ListNode) *ListNode {\r\n    fast, slow := left, left\r\n    for fast != right && fast.Next != right {\r\n        fast = fast.Next.Next\r\n        slow = slow.Next\r\n    }\r\n    return slow\r\n}\r\n\r\nfunc buildTree(left, right *ListNode) *TreeNode{\r\n    if left == right {\r\n        return nil\r\n    }\r\n    mid := getMedian(left, right)\r\n    root := &TreeNode{mid.Val, nil, nil}\r\n    root.Left = buildTree(left, mid)\r\n    root.Right = buildTree(mid.Next, right)\r\n    return root\r\n}\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joemonkeylee":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429643042","body":"### 思路\n\n- k值转为 int数组 \n- 两数组高位向左相加 注意处理进位 \n- 若索引0为0 数组长度整体右移一位 \n\n 常规想法 不用复杂类型类型 要牺牲时间\n\n### 代码\n\n\n```c#\n\n    public List<int> Main(int[] num, int k)\n    {\n        int kCopy;\n\n        //1.获取k位数 \n        int kLength = 1;\n        kCopy = k;\n        while (kCopy / 10 > 0)\n        {\n            kLength++;\n            kCopy = kCopy / 10;\n        }\n\n        //2.将k转成数组\n        int[] num2 = new int[kLength];\n        int currentIndex = 0;\n        kCopy = k;\n        while (currentIndex < kLength)\n        {\n            num2[kLength - currentIndex - 1] = kCopy % 10;\n            kCopy = (kCopy - kCopy % 10) / 10;\n            currentIndex++;\n        }\n\n        //3.开辟一个数组 长度是两数组长度较大值+1 右对齐求和\n        int maxLength = Math.Max(num.Length, num2.Length);\n        int[] res = new int[maxLength + 1];\n        int carry = 0;\n        int a;\n        int b;\n        for (int index = 0; index < maxLength; index++)\n        {\n            if (num.Length - index > 0)\n            {\n                a = num[num.Length - index - 1];\n            }\n            else\n            {\n                a = 0;\n            }\n\n            if (num2.Length - index > 0)\n            {\n                b = num2[num2.Length - index - 1];\n            }\n            else\n            {\n                b = 0;\n            }\n\n            if (a + b + carry >= 10)\n            {\n                res[maxLength - index] = a + b + carry - 10;\n                carry = 1;\n            }\n            else\n            {\n                res[maxLength - index] = a + b + carry;\n                carry = 0;\n            }\n        }\n\n        if (carry == 1)\n        {\n            res[0] = carry;\n        }\n\n        //4.如果最低位是0 数组长度-1右移\n        int[] result = new int[maxLength];\n        if (res[0] == 0)\n        {\n            for (int i = 0; i < result.Count(); i++)\n            {\n                result[i] = res[i + 1];\n            }\n            return result;\n        }\n        else\n        {\n            return res;\n        }\n    }\n```\n\n**复杂度分析**\n- 时间复杂度：O(max(n,logk))\n- 空间复杂度：O(1)\n- 不太确定对不对","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431214887","body":"### 思路\n\n- 先找char的位置\n- 第二遍算较小长度\n\n### 代码\n\n\n```c#\n\n    public int[] ShortestToChar(string s, char c)\n    {\n        //记录c的位置\n        List<int> targetArray = new List<int>();\n\n        var charArray = s.ToCharArray();\n        for (int i = 0; i < charArray.Length; i++)\n        {\n            if (charArray[i].Equals(c))\n            {\n                targetArray.Add(i);\n            }\n        }\n\n        var res = new int[charArray.Length];\n        int targetArrayIndex = 0;\n        for (int i = 0; i < charArray.Length; i++)\n        {\n            if (targetArrayIndex < targetArray.Count() && i.Equals(targetArray[targetArrayIndex]))\n            {\n                res[i] = 0;\n                targetArrayIndex++;\n            }\n            else\n            {\n                if (i < targetArray[0])\n                {\n                    res[i] = Math.Abs(i - targetArray[targetArrayIndex]);\n                }\n                else if (i > targetArray[targetArray.Count() - 1])\n                {\n                    res[i] = Math.Abs(i - targetArray[targetArrayIndex - 1]);\n                }\n                else\n                {\n                    res[i] = Math.Min(Math.Abs(i - targetArray[targetArrayIndex]), Math.Abs(targetArray[targetArrayIndex - 1] - i));\n                }\n            }\n        }\n        return res;\n    }\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432943455","body":"### 思路\n\nc#中使用 int[]或者List<int>来模拟应该结果是差不多的。\n不能使用Stack 因为stack用index进行索引赋值\n\n### 代码\n\n```c#\n\npublic class CustomStack\n{\n    int[] array;\n    int index = -1;\n    public CustomStack(int maxSize)\n    {\n        array = new int[maxSize];\n    }\n\n    public void Push(int x)\n    {\n        if (index < array.Length - 1)\n        {\n            array[++index] = x;\n        }\n    }\n\n    public int Pop()\n    {\n        return index < 0 ? -1 : array[index--];\n    }\n\n    public void Increment(int k, int val)\n    {\n        for (int i = 0; i < (k > array.Length ? array.Length : k); i++)\n        {\n            array[i] += val;\n        }\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：Increment是O(n)，其他O(1)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434771304","body":"### 思路\n\n没想出来 看了别人的题解\n\n### 代码\n\n```c#\n    public string DecodeString(string s) {\n        Stack<int> countStack = new Stack<int>();\n        Stack<StringBuilder> charStack = new Stack<StringBuilder>();\n        StringBuilder result = new StringBuilder();\n        int count = 0;\n        foreach(char c in s)\n        {\n            if(char.IsDigit(c))\n            {\n                count = count * 10 + c - '0';\n            }\n            else if(char.IsLetter(c))\n            {\n                result.Append(c);\n            }\n            else if(c == '[')\n            {\n                countStack.Push(count);\n                charStack.Push(result);\n                result = new StringBuilder();\n                count = 0;\n            }\n            else if(c == ']')\n            {\n                var chars = charStack.Pop();\n                var repeat = countStack.Pop();\n                for(int i=0;i<repeat;i++)\n                {\n                    chars.Append(result);\n                }\n                result = chars;\n            }\n        }\n        return result.ToString();\n    }   \n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\u0000","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435672258","body":"### 思路\r\n\r\n    in and out stack\r\n\r\n### 代码\r\n\r\n```c#\r\n  public class MyQueue {\r\n    private Stack inStack = new Stack();\r\n    private Stack outStack = new Stack();\r\n    public MyQueue()\r\n    {\r\n\r\n    }\r\n\r\n    public void Push(int x)\r\n    {\r\n        this.inStack.Push(x);\r\n    }\r\n\r\n    public int Pop()\r\n    {\r\n        this.outStack.Clear();\r\n        while (this.inStack.Count>0&&this.inStack.Peek()!=null)\r\n        {\r\n            this.outStack.Push(this.inStack.Pop());\r\n        }\r\n\r\n        int res = Convert.ToInt32(this.outStack.Pop());\r\n\r\n        while (this.outStack.Count>0&&this.outStack.Peek()!=null)\r\n        {\r\n            this.inStack.Push(this.outStack.Pop());\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    public int Peek()\r\n    {\r\n        this.outStack.Clear();\r\n        while (this.inStack.Count > 0 && this.inStack.Peek() != null)\r\n        {\r\n            this.outStack.Push(this.inStack.Pop());\r\n        }\r\n\r\n        int res = Convert.ToInt32(this.outStack.Peek());\r\n\r\n        while (this.outStack.Count > 0 && this.outStack.Peek() != null)\r\n        {\r\n            this.inStack.Push(this.outStack.Pop());\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    public bool Empty()\r\n    {\r\n        return this.inStack.Count==0;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436004786","body":"### 思路\n\n开始没看懂这个题  看懂之后没太做出来。。看了优秀的题解 mark hard 需要再看\n\n### 代码\n\n```c#\n  \n        Stack<int> stack = new Stack<int>();\n        foreach (int num in arr)\n        {\n            if (stack.Count>0 && num < stack.Peek())\n            {\n                int head = stack.Pop();\n                while (stack.Count > 0 && num < stack.Peek()) stack.Pop();\n                stack.Push(head);\n            }\n            else stack.Push(num);\n        }\n        return stack.Count();\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\u0000","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437155843","body":"### 思路\n1、判空直接返回\n2、算总数 算实际需要移动低次数\n3、如果没移动 直接返回\n4、如果移动 将链表转为环 循环赋值 index从1开始少循环一次 多操作一次再循环外给返回赋值\n5、断开环 返回结果\n\n\n### 代码\n\n```c#\n\n     public ListNode RotateRight(ListNode head, int k)\n        {\n            if (head == null)\n            {\n                return head;\n            }\n\n            int n = 1;\n            ListNode end = head;\n            while (end.next != null)\n            {\n                end = end.next;\n                n++;\n            }\n            k %= n;\n            if (k == 0)\n            {\n                return head;\n            }\n\n            end.next = head;//链表变成环\n\n            int newTailIndex = n - k;\n            ListNode ans = head;\n            //少循环一次后面多走一次赋值\n            for (int i = 1; i < newTailIndex; i++)\n            {\n                ans = ans.next;\n            }\n            ListNode newHead = ans.next;\n            ans.next = null;//还原回链表\n            return newHead;\n        }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438706411","body":"### 思路\n\n不能开辟辅助空间 会超时。艹了 递归没写出来。\n\n### 代码\n\n```c#\n  \n   public ListNode SwapPairs(ListNode head)\n    {\n        ListNode pre = new ListNode(0);\n        pre.next = head;\n        ListNode temp = pre;\n        while (temp.next != null && temp.next.next != null)\n        {\n            ListNode start = temp.next;\n            ListNode end = temp.next.next;\n            temp.next = end;\n            start.next = end.next;\n            end.next = start;\n            temp = start;\n        }\n        return pre.next;\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440281976","body":"### 思路\n\n先看110 平衡二叉树 然后看108数组平衡二叉树  最后来看这个题 链表平衡二叉树 【redo】\n\n### 代码\n\n```c#\n\n    public TreeNode SortedListToBST(ListNode head) {\n        return CreateBST(head, null);\n    }\n\n    public TreeNode CreateBST(ListNode start, ListNode end) {\n        if (start == end) {\n            return null;\n        }\n        ListNode slow = start, fast = start.next;\n        while (fast != end && fast.next != end) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return new TreeNode(slow.val, CreateBST(start, slow), CreateBST(slow.next, end));\n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(logn)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"northseacoder":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429682330","body":"## 思路\n- 利用 number 自动进位\n- 每次取数组未运算的最小位置直接加上 k 并取结果最末位 unshift 到结果数组内\n- nums 取完时需要考虑有多余进位\n- 计算时间复杂度时,当 k>num 时,循环次数为 log k(k 每次循环除 10)\n## 代码\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    let index = num.length - 1;\n    let sum = k;\n    while (index >= 0 || sum > 0) {\n        if (index >= 0) {\n            sum += num[index];\n            index--;\n        }\n        res.unshift(sum % 10);\n        sum = Math.floor(sum / 10);\n    }\n    return res;\n};\n```\n### 复杂度\n- 时间复杂度: O(max(n,log k));\n- 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430666807","body":"## 思路\n- 两次遍历\n- j 用来保留上次字符出现的位置\n- 从左往右获取左侧距离\n- 从右往左获取右侧距离\n\n## 代码\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    const n = s.length;\n    const res = new Array(n).fill(Infinity);\n    for (let i = 0, j = -1; i < n; i++) {\n        if (s.at(i) === c) j = i;\n        if (j !== -1) res[i] = i - j;\n    }\n    for (let i = n - 1, j = -1; i >= 0; i--) {\n        if (s.at(i) === c) j = i;\n        if (j !== -1) res[i] = Math.min(res[i], j - i);\n    }\n    return res;\n};\n```\n## 复杂度\n- TC:O(n)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432315252","body":"## 思路\n- 利用js 原生数组模拟栈\n\n## 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = [];\n    this.size = maxSize;\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length < this.size) this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.stack.pop() ?? -1;\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for (let i = 0; i < Math.min(this.stack.length, k); i++) {\n        this.stack[i] += val;\n    }\n};\n```\n## 复杂度\n- SC: O(n)\n- TC: push:O(1),pop:O(1),increment:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434022191","body":"## 思路\n- 双栈分别记录字符串和数字\n- 注意数字的判断\n\n## 代码\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    const repeatStack = [];\n    const resStack = [];\n    let repeat = 0;\n    let res = '';\n    for (let char of s) {\n        if (!Number.isNaN(Number(char))) {\n            //数字\n            repeat = repeat * 10 + Number(char);\n        } else if (char === '[') {\n            //获取新的 repeat 和 res\n            resStack.push(res);\n            res = '';\n            repeatStack.push(repeat);\n            repeat = 0;\n        } else if (char === ']') {\n            //计算当前值\n            const repeatTimes = repeatStack.pop();\n            res = resStack.pop() + res.repeat(repeatTimes);\n        } else {\n            //字符串\n            res += char;\n        }\n    }\n    return res\n};\n\n## 复杂度\n- TC:O(n)\n- SC:O(n)\n```\n\n## 思路(dfs)\n- 核心逻辑一样,只是用递归替换栈\n## 代码\n```js\nvar decodeString = function(s) {\n    const queue = s.split('');\n    const dfs = (q) => {\n        let res = '';\n        let repeat = 0;\n        while (q.length) {\n            const char = q.shift();\n            if (!Number.isNaN(Number(char))) {\n                repeat = repeat * 10 + Number(char);\n            } else if (char === '[') {\n                const tmp = dfs(q);\n                res += tmp.repeat(repeat);\n                repeat = 0;\n            } else if (char === ']') {\n                return res;\n            } else {\n                res += char;\n            }\n        }\n        return res\n    };\n    return dfs(queue);\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435693857","body":"## 思路\n- 将一个栈里面的元素全部弹出，然后压入另一个栈在弹出来就变成了反转后的顺序\n\n## 代码\n```js\nvar MyQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n    return this.outStack.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n    return this.outStack.at(-1);\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.inStack.length && !this.outStack.length;\n};\n\n```\n\n## 复杂度\n- TC:push/empty O(1);peek/pop:O(n);\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435814610","body":"## 思路\n- 将块分别进行排序并使得连接的结果和按升序排序后的原数组相同。需要保证当前块的最大值要小于后面块的任意值;\n- 每一块的最大值必然大于前一块的最大值,有多少个最大值就有多少个块\n- 单调栈\n\n## 代码\n\n```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    const stack = [];\n    arr.forEach((val) => {\n        if (stack.length && val < stack.at(-1)) {\n            const top = stack.pop();\n            while (stack.length && val < stack.at(-1)) stack.pop();\n            stack.push(top);\n        } else {\n            stack.push(val);\n        }\n    });\n    return stack.length;\n};\n\n```\n\n## 复杂度\n- TC:O(n)\n- SC:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436207578","body":"## 代码 (环)\n```js\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (!head || !head.next || k === 0) return head;\n    let point = head;\n    let length = 1;\n    while (point.next) {\n        length++;\n        point = point.next;\n    }\n    if (k % length === 0) return head;\n\n    let n = length - (k % length);\n    //构建环\n    point.next = head;\n    //找到新链表头结点的前驱节点:n+k = length\n    while (n > 0) {\n        point = point.next;\n        n--;\n    }\n    let newHead = point.next;\n    point.next = null;\n    return newHead;\n};\n```\n## 复杂度\n- TC: O(n)\n- SC:O(1)\n\n## 代码(双指针)\n```js\nvar rotateRight = function(head, k) {\n    if (!head || !head.next || k === 0) return head;\n    let point = head;\n    let length = 1;\n    while (point.next) {\n        length++;\n        point = point.next;\n    }\n    if (k % length === 0) return head;\n\n    let n = k % length;\n\n    let fast = head;\n    let slow = head;\n    //先移动 fast\n    while (n > 0) {\n        fast = fast.next;\n        n--;\n    }\n    //同步移动,最终 slow 为新链表头结点前驱节点\n    while (fast.next) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    fast.next = head;\n    head = slow.next;\n    slow.next = null;\n    return head;\n};\n```\n## 复杂度\n- TC: O(n)\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437764849","body":"## 代码(递归)\n```js\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    if (!head || !head.next) return head;\n    const next = head.next;\n    //获取交换后的链表\n    head.next = swapPairs(next.next);\n    //交换当前节点\n    next.next = head;\n    return next\n};\n```\n## 复杂度\n- TC:O(n);\n- SC:O(n)\n\n## 代码(迭代)\n```js\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    if (!head || !head.next) return head;\n    //虚拟头结点\n    const newHead = new ListNode(0, head);\n    let point = newHead;\n    while (point.next && point.next.next) {\n        const pre = point.next;\n        const post = point.next.next;\n        //指针指向 post,post 为首位;\n        point.next = post;\n        //pre 指向后续节点,pre 此时为第二位;\n        pre.next = post.next;\n        //post 指向 pre,交换完成\n        post.next = pre;\n        //指针移至 pre 进入下一步迭代\n        point = pre;\n    }\n    return newHead.next;\n};\n```\n## 复杂度\n- TC:O(n);\n- SC:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439429591","body":"## 双指针\n\n```js\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    //递归结束\n    if (!head) return head;\n    let fast = head;\n    let slow = head;\n    let pre;\n    //找到中间节点做为根节点\n    while (fast && fast.next) {\n        pre = slow;\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    const root = new TreeNode(slow.val);\n    if (pre) {\n        //没有左子树的情况\n        pre.next = null;\n        root.left = sortedListToBST(head);\n    }\n    //右子树为 slow.next\n    root.right = sortedListToBST(slow.next);\n    return root;\n};\n```\n- TC:O(nlogn):递归 logn,每层递归循环一次找中点 n\n-  SC:O(logn)\n\n## 转成有序数组\n```js\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    let point = head;\n    const arr = [];\n    //转成有序数组\n    while (point) {\n        arr.push(point.val);\n        point = point.next;\n    }\n\n    const build = (start, end) => {\n        //递归中止条件\n        if (start > end) return null;\n        //取中间值\n        const midIndex = start + Math.floor((end - start) / 2);\n        const mid = arr[midIndex];\n        const root = new TreeNode(mid);\n        root.left = build(start, midIndex - 1);\n        root.right = build(midIndex + 1, end);\n        return root\n    };\n    return build(0, arr.length - 1);\n};\n```\n- TC:O(n)\n- SC:O(n)\n\n## 优化\n```js\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    let point = head;\n    let len = 0;\n    //计算链表长度\n    while (point) {\n        len++;\n        point = point.next;\n    }\n    let node = head;\n    const build = (start, end) => {\n        //递归中止条件\n        if (start > end) return null;\n        //取中间值\n        const midIndex = start + Math.floor((end - start) / 2);\n        //中序遍历优化\n        const left = build(start, midIndex - 1);\n        \n        const root = new TreeNode(node.val);\n        node = node.next;\n        root.left = left;\n\n        root.right = build(midIndex + 1, end);\n        return root;\n    };\n    return build(0, len - 1);\n};\n\n```\n- TC:O(n) \n- SC:O(logn) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441133283","body":"## 双指针\n``` js\nvar getIntersectionNode = function(headA, headB) {\n    if (headA === null || headB === null) {\n        return null;\n    }\n    let pointA = headA;\n    let pointB = headB;\n    while (pointA !== pointB) {\n        pointA = pointA ? pointA.next : headB;\n        pointB = pointB ? pointB.next : headA;\n    }\n    //如果相交,则此时为相交节点,\n    //如果不相交,则此时为 null\n    return pointA;\n};\n```\n- TC:O(m+n);\n- SC:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dominique9898":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429688396","body":"### 思路\n\n首先计算 k 按十进制下的每一位的值, 然后模拟竖式加法,对每一位进行相加(不存在的位为0),\n并且用carry这个变量存储进位标志符. 因为我们是从前往后遍历,所以最后需要reverse一下结果.\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        if (k == 0) return num;\n\n        reverse(num.begin(), num.end());\n        vector<int> digit_k;\n        while (k) {\n            digit_k.push_back(k % 10);\n            k /= 10;\n        }\n\n        vector<int> ans;\n        int carry = 0, ptr = 0;\n        const int n = num.size(), m = digit_k.size();\n        while (carry || ptr < max(n, m)) {\n            const int d1 = ptr < n ? num[ptr] : 0;\n            const int d2 = ptr < m ? digit_k[ptr] : 0;\n            const int cur = d1 + d2 + carry;\n            carry = cur / 10;\n            ans.push_back(cur % 10);\n            ptr++;\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组 arr 长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431436378","body":"# 思路\n\n首先从左到右遍历一次s，如果s[i] == c就设置为0，否则设置为s[i - 1] + 1\n然后从右到左遍历一次s，如果s[i] == c就设置为0，否则设置为min(s[i], s[i - 1] + 1)\n\n# 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        if (s.empty()) return vector<int>{};\n\n        const int n = s.size();\n        const int MAX = n + 1000;\n        vector<int> ans(n, MAX);\n        ans[0] = (s[0] == c) ? 0 : MAX;\n        for (int i = 1; i < n; i++) {\n            ans[i] = (s[i] == c) ? 0 : ans[i - 1] + 1;\n        }\n\n        ans[n - 1] = (s[n - 1] == c) ? 0 : ans[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            ans[i] = (s[i] == c) ? 0 : min(ans[i], ans[i + 1] + 1);\n        }\n        return ans;\n    }\n};\n```\n\n# 分析\n\n时间复杂度 O(N)\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433254448","body":"# 思路\n\n用 stack 维护栈的原始元素。用stack维护前缀和\n\n# 代码\n\n```cpp\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        mxSize = maxSize;\n        cur = 0;\n    }\n    \n    void push(int x) {\n        if (stk.size() + 1 > mxSize) return;\n        stk.push_back(x);\n        if (!diff.empty()) diff.back() += cur;\n        diff.push_back(0);\n        cur = 0;\n    }\n    \n    int pop() {\n        if (stk.empty()) return -1;\n        const int x = stk.back();\n        stk.pop_back();\n        cur += diff.back();\n        diff.pop_back();\n        return x + cur;\n    }\n    \n    void increment(int k, int val) {\n        if (stk.empty()) return;\n        const int n = stk.size();\n        diff[min(n - 1, k - 1)] += val;\n    }\nprivate:\n    vector<int> stk, diff;\n    int mxSize, cur;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n# 复杂度分析\n\n每一个操作都是 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434909623","body":"class Solution {\npublic:\n\n    bool isDigital(char c) {\n        return (c - '0') >= 0 && (c - '9') <= 9;\n    }\n    string help(string s) {\n        int num = 0;\n        string res = \"\";\n        stack<int> s1;\n        stack<string> s2;\n        for (int i = 0; i < s.length(); i++) {\n            if (isDigital(s[i])) num = num * 10 + (s[i] - '0');\n            else if (s[i] == '[') {\n                s1.push(num);\n                num = 0;\n                s2.push(res); \n                res = \"\";\n            } else if (s[i] == ']') {\n                int times = s1.top();\n                s1.pop();\n                while(times--) s2.top() += res;\n                res = s2.top();\n                s2.pop();\n            } else {\n                res = res + s[i];\n            }\n        }\n        return res;\n    }\n\n    string decodeString(string s) {\n        return help(s);\n    }\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435703586","body":"```c++\r\nclass MyQueue {\r\npublic:\r\n    stack<int> s1;\r\n    stack<int> s2;\r\npublic:\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        int front;\r\n        if (!s2.empty()) {\r\n            front = s2.top();\r\n            s2.pop();\r\n        } else {\r\n            while(!s1.empty()) {\r\n                int top = s1.top();\r\n                s2.push(top);\r\n                s1.pop();\r\n            }\r\n            front = s2.top();\r\n            s2.pop();\r\n        }\r\n        return front;\r\n    }\r\n    \r\n    int peek() {\r\n        int front;\r\n        if (!s2.empty()) {\r\n            front = s2.top();\r\n        } else {\r\n            while(!s1.empty()) {\r\n                int top = s1.top();\r\n                s2.push(top);\r\n                s1.pop();\r\n            }\r\n            front = s2.top();\r\n        }\r\n        return front;\r\n    }\r\n    \r\n    bool empty() {\r\n        return s1.empty() && s2.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```c++```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437213073","body":"第一直觉先写的,感觉方法不唯一. 后续看看题解和优化\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (head == NULL) return NULL;\r\n        if (head->next == NULL) return head;\r\n        ListNode* cur = head;\r\n        int len = 0;\r\n        while(cur != NULL) {\r\n            len++;\r\n            cur = cur->next;\r\n        }\r\n        cout << len << endl;\r\n        k = k % len;\r\n        for (int i = 0; i < k; i++) {\r\n            cur = head;\r\n            ListNode* last = cur->next;\r\n            ListNode* pre_last = cur;\r\n            \r\n            while(last->next != NULL) {\r\n                last = last->next;\r\n                pre_last = pre_last->next;\r\n            }\r\n            pre_last->next = NULL;\r\n            last->next = head;\r\n            head = last;\r\n        }\r\n        return head;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wl678":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429692569","body":"2.14\n\n思路：\n\n​\t拿到题目最初的想法是将num数组转换为十进制的整数，然后直接与k相加，但是看到题目中条件数组的长度最大可以是$10^4$，排除这种做法，因为无论是int还是long long int 都够呛存下来。\n\n​\t因此，因该考虑逐位相加，但是这种方法我感觉又有些麻烦，所以参考了官方题解的另一种思路，并尝试实现。\n\n​\t将整数k与num数组最后一位相加，用temp暂时存下相加的结果，对temp取余得到最终结果的最后一位，然后再对temp整除10，将得到的结果与num数组倒数第二位相加，重复前面的步骤，整体的算法思路就是这样。\n\n​\t但是，要注意一些小问题，比如最终结果需要往前进位怎么办，整数k的长度 > 数组长度怎么办。\n\n​\t可以发现如果出现上面的两种情况，在跳出第一个for之后，temp肯定不为0，所以这时只需要将temp逐位插入到最终的数组中即可。\n\n​\t此外，对于整数k的长度远小于数组长度的测试用例，可以通过检查temp是否为0来提前终止循环，减少运行时间，算是一点小优化。\n\n代码：**C++**\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int nsize = num.size();\n        int temp = k;\n        for (int i = nsize - 1; i >= 0; i--) {\n            //小改进\n            if(temp == 0)\n                break;\n            temp = num[i] + temp;\n            num[i] = temp % 10;\n            temp = temp / 10;\n            //如果最高位出现进位\n            \n        }\n        while( temp != 0) {\n            num.insert(num.begin(), temp % 10);\n            temp = temp / 10;\n        }\n        return num;\n\n    }\n};\n```\n\n复杂度分析：\n\n​\t时间复杂度： 取决于整数k和数组的长度，所以应该是O(max(num.size(),logk));\n\n​\t空间复杂度：由于没有创建新的数组，应该为O(1);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431341658","body":"思路：\n\n​\t既然需要查找距离当前位置最近的目标字符，一共有两种可能，左边最近或者右边最近，那么直观的想法是，每当遍历到一个字符，分别从左到字符串开头和从右到字符串末尾进行查找，最后将两边得到的最近的目标字符的距离进行比较，取最小值即可。当然会出现一些特殊情况，左边或者右边没有字符没有，或者目标字符只出现了一次，并且当前刚好遍历到该字符，此时两边都查找不到。\n\n\n\n代码：**C++**\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        \n        int len = s.size();\n        vector<int> dis(len);\n        for(int i = 0; i < len;i++) {\n            int left = 0;\n            int right = 0;\n            if(s[i] != c){\n                //查找左边\n                for(int j = i; j >= 0; j--){\n                    if(s[j] == c){\n                        left = i - j;\n                        break;\n                    }\n                }\n                if(!left){\n                    left = -1;\n                }\n                //查找右边\n                for(int j = i; j < len; j++){\n                    if(s[j] == c){\n                        right = j - i;\n                        break;\n                    }\n                }\n                 if(!right){\n                    right = -1;\n                }\n                if(left == -1 || right == -1){\n                   dis[i] = max(left,right);\n                } else {\n                    dis[i] = min(left,right);\n                }\n                cout <<\"letf:\"<< left << endl;\n                cout <<\"rigth:\"<< right << endl;\n            } else {\n                dis[i] = 0;\n            }\n            \n        }\n        return dis;\n    }\n};\n```\n\n复杂度分析：\n\n时间复杂度：for循环里面嵌套了两个循环，时间复杂度为O(n\\*(i)+n\\*(n-i))=O($n^2$)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432701934","body":"\n\n思路：\n\n​\t栈作为一种底层容器，可以使用vector、deque、list来实现，遵循“先进后出”原则，可以发现题目要求实现的 push、pop 和 inc 三个功能中，前两个功能就是普通的栈所具有的功能，而最后一个inc功能需要让栈中的元素是可见的。\n\n代码：**C++**\n\n```c++\nclass CustomStack {\npublic:\n    //使用vector来构造栈\n    vector<int> stk;\n    //栈顶元素\n    int top;\n\t//构造函数\n    CustomStack(int maxSize) {\n        stk.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if (top != stk.size() - 1) {\n            ++top;\n            stk[top] = x;\n        }\n    }\n    \n    int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stk[top + 1];\n    }\n    \n    void increment(int k, int val) {\n        int lim = min(k, top + 1);\n        for (int i = 0; i < lim; ++i) {\n            stk[i] += val;\n        }\n    }\n};\n\n```\n\n复杂度分析：\n\n时间复杂度：\n\n​\tpush: O(1)\n\n​\tpop:   O(1)\n\n​\tinc:     O(k)\n\n空间复杂度： O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434347420","body":"思路：\n\n从题目中可以把\"[ \" \"]\"看作是操作符，而前面的数字以及中间的字符则看作是操作数，那么需要给每一个\"[\"匹配到对应的\"]\"才能执行操作。因此，采用栈来解决较为合适。题目中数字和字母代表的含义不相同，需要进行区分。\n\n首先，来说数字，题中给出s中的数字的范围是[1,300]，也就是说可能存在2位或者3位数字组成的数，此时需要将多位数字合并成一个数。\n\n对于字母，需要设计实现读取\"]\"与离它最近的\"[\"之间的所有字符，由于栈是LFIO原则，所以反转字符串是必要的。\n\n获得正确顺序的字串之后，就需要按照指定的次数去重复生成。\n\n\n\n代码：**C++**\n\n```c++\n class Solution {\n public:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n             ret.push_back(s[ptr++]);\n         }\n        return ret;\n     }\n\n     string getString(vector <string> &v) {\n         string ret;\n         //为什么要定义为const auto &？\n         for (const auto &s: v) {\n             ret += s;\n         }\n         return ret;\n     }\n     string decodeString(string s) {\n         //定义一个栈\n         vector <string> stk;\n         //size_t 是一些C/C++标准在stddef.h中定义的，size_t 类型表示C中任何对象所能达到的最大长度，它是无符号整数。\n         size_t ptr = 0;\n\n         while (ptr < s.size()) {\n             char cur = s[ptr];\n             //isdigit(),C 库函数 int isdigit(int c) 检查所传的字符是否是十进制数字字符。\n             if (isdigit(cur)) {\n                 // 获取一个数字并进栈,如有多位数字，例如200，会将\"2\"\"0\"\"0\"合并成一个字符串\n                 string digits = getDigits(s, ptr);\n                cout << digits << endl;\n                 stk.push_back(digits);\n             } else if (isalpha(cur) || cur == '[') {\n                 //isalpha(),C 库函数 void isalpha(int c) 检查所传的字符是否是字母。\n                 // 获取一个字母并进栈\n                 stk.push_back(string(1, s[ptr++])); \n             } else {\n                 //遇到\"]\"的时候，开始执行编码\n                 ++ptr;\n                 //获取子串\n                 vector <string> sub;\n                 while (stk.back() != \"[\") {\n                     //函数back(),vector、string中,返回当前vector容器中末尾元素的引用。\n                     //如果定义int c = a.back()，c并不是一个引用，操作c不会对a中的最后一个元素造成影响。\n                     sub.push_back(stk.back());\n                     //pop_back(),删除最后一个元素\n                     //pop_back()函数并没有真的把原来数组内存里面的数值给删掉，而是仅仅取消了数组最后一个元素的地址映射。\n                     stk.pop_back();\n                 }\n                 reverse(sub.begin(), sub.end());\n                 // 左括号出栈\n                 stk.pop_back();\n                 // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                 //stoi(),作用是将 n 进制的字符串转化为十进制，使用时包含头文件string。\n                 int repTime = stoi(stk.back()); \n                 stk.pop_back();\n                 string t = \"\", o = getString(sub);\n                 // 构造字符串\n                 while (repTime--) t += o; \n                 // 将构造好的字符串入栈\n                 stk.push_back(t);\n             }\n\n         }\n\n         return getString(stk);\n\n\n\n     }\n };\n\n```\n\n复杂度分析：\n\n时间复杂度：\n\n记原来字符串的长度为|s|，解码之后的字符串长度为S，每一小段子字符串在经过解码后，解码之后的字符串又会再入栈，一共有S个字符入栈，而经过遍历，原来的字符串的每个字符都出栈过，所以时间复杂度会是O(S+|s|)。\n\n空间复杂度：记解码后得出的字符串长度为 S，栈的总大小最终与 S*S* 相同，故渐进空间复杂度为 O(S)。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435669195","body":"思路：\n\n栈的特点是\"先进后出\"，而队列的特点是\"先进先出\"；形象点，可以把栈看作只有一个开口的盒子，而队列则是双向开口的盒子，因此，直观的想法是用两个只有一个开口但是开口方向相反的盒子（栈）来模拟双向开口的盒子（队列）。\n\n入栈和入列的操作基本上相同，区别主要在出栈操作上，队列是先进去的元素先出来，所以需要将stkIn已经入栈元素全部出栈，然后依次在另一个栈stkOut中入栈，此时，stkOut中元素的顺序已经反过来（原来在stkIn栈底的元素在stkOut栈顶），然后执行出栈，就完成了先进的元素先出。\n\n\n\n代码：**C++**\n\n```c++\nclass MyQueue {\npublic:\n    stack<int> stkIn;\n    stack<int> stkOut;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        stkIn.push(x);\n    }\n    \n    int pop() {\n        if(stkOut.empty()){\n            while(!stkIn.empty()) {\n            stkOut.push(stkIn.top());\n            stkIn.pop();\n            }\n        }\n        int temp = stkOut.top();\n        stkOut.pop();\n        return temp;\n\n    }\n    \n    int peek() {\n        if(stkOut.empty()){\n                    while(!stkIn.empty()) {\n                    stkOut.push(stkIn.top());\n                    stkIn.pop();\n                    }\n                }\n                int temp = stkOut.top();\n                return temp;\n        //int res = this->pop(); // 直接使用已有的pop函数\n        //stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去\n        //return res;\n    }\n    \n    bool empty() {\n        if(stkOut.empty() && stkIn.empty())\n            return true;\n        else\n            return false;\n        //(stkOut.empty() && stkIn.empty()) ? return true : return false;\n        //return stkOut.empty() && stkIn.empty();\n    }\n};\n```\n\n复杂度分析：\n\n​\t时间复杂度：\n\n​\t\tpush（）：O(1)\n\n​\t\tpop（）：O (4k) ,k为已经进入队列的元素数。\n\n​\t\tpeek（）：O (4k) ,k为已经进入队列的元素数。\n\n​\t\tempty（）：O(1)\n\n​\t空间复杂度：\n\n​\t\t记队列的元素总数为k，O（2k）= O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435995991","body":"思路：单调栈\n\n起初根本没看懂题目意思，参考了题解之后，了解了单调栈这种数据结构，再来回顾题目，有种豁然开朗的感觉，将原有的数组分块，分块之后排序，再合并，要与直接对原数组升序排列相同，问最多可以分成多少块？\n\n要分块，分完块还要排序，排序之后还要在跟原数组比较，听起来就让人觉得头大，感觉十分复杂。\n\n不过，考虑一组已经满足题意分好块并排序的，添加一个新元素，如何求新数组的分块方式，如果新元素比最后一个块的最大值还大或者等于，那么新元素可以自己分为一组，以求块数最多，如果小于最后一个块的最大值，但是比倒数第二格块的最大值大或者等于，那么新元素应该融入最后一个块中，一次类推，直到第一个块，整体得到思路类似演绎的思想，以“栈中存储块的最大值”为核心。\n\n\n\n代码：**C++**\n\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> stk;\n        for(auto &num : arr) {\n            if(stk.empty() || num >= stk.top()){\n                stk.push(num);\n            } else {\n                int mx = stk.top();\n                stk.pop();\n                while(!stk.empty() && stk.top() > num) {\n                    stk.pop();\n                }\n                stk.push(mx);//最后一个块的最大值还是mx，所以这里入栈的是mx而不是num！\n\n            }\n           \n        }\n        return stk.size(); \n    }\n};\n```\n\n复杂度分析：\n\n​\t时间复杂度：num和mx一共入栈n次,最多出栈n-1次，为O(n)。n为数组元数个数。\n\n​\t空间复杂度：O(1)?   O(n)*O*(*n*)。栈的长度最多为 n。 （不太懂，考虑最坏情况？)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437053125","body":"思路：\n\n如果给的是循环链表，那么只需要考虑移动head指针就可以了，但题目中给出的是单链表，所以需要先遍历整个链表，得到链表的长度，同时将链表首尾相连，然后根据输入的k移动head，之后再断掉head前面的连接即可。\n\n整体的思路是这样，但是有两种特殊情况，需要考虑，\n\n​\tk是count的倍数，此时，head不需要挪动，之间返回即可。\n\n​\tk大于count，此时需要对count - k取模，但此时得到的结果是负数，因此还需要加上一个count。\n\n代码：**C++**\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head == nullptr || head->next == nullptr || k == 0)\n            return head;\n        int count = 1;\n        ListNode* temp = head;\n        //得到链表的总长度\n        while(head->next != nullptr) {\n            count++;\n            head = head->next;\n        }\n        if( k % count !=0){\n        //首尾相连\n        head -> next = temp;\n        head = temp;\n        int rotTimes = 0;\n        if(count < k)\n            rotTimes = (count - k) % count + count; //k mod count,取正数\n        else \n            rotTimes = count - k;\n        for(int i = 1; i < rotTimes ; i++){\n            head = head -> next;\n        }\n        ListNode* temp2 = head -> next;\n        head -> next = nullptr;\n        head = temp2;\n        }\n        else{\n            //k为count整数倍，不需要移动\n            head = temp;\n        }\n        return head;\n    }\n};\n```\n\n复杂度分析：\n\n​\t时间复杂度：O(max(n,k))\n\n​\t空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438656886","body":"##### 思路：\n\n递归思路，将两两结点进行交换，输入要交换的两个结点的第一个结点的地址，返回新链表的头结点。\n\n##### 代码：C++\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        ListNode* newHead = head->next;\n        head->next = swapPairs(newHead->next);\n        newHead->next = head;\n        return newHead;\n    }\n};\n```\n\n\n\n##### 复杂度分析：\n\n​\t时间复杂度：O(n)，n为链表结点的数量，对于每个结点的指针都更新了。\n\n​\t空间复杂度：O(n)，创建了新链表，n为链表结点的数量。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440269167","body":"##### 思路：分治\n\n##### 代码：C++\n\n```c++\nclass Solution {\npublic:\n    ListNode* getMedian(ListNode* left, ListNode* right) {\n        ListNode* fast = left;\n        ListNode* slow = left;\n        while (fast != right && fast->next != right) {\n            fast = fast->next;\n            fast = fast->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n\n    TreeNode* buildTree(ListNode* left, ListNode* right) {\n        if (left == right) {\n            return nullptr;\n        }\n        ListNode* mid = getMedian(left, right);\n        TreeNode* root = new TreeNode(mid->val);\n        root->left = buildTree(left, mid);\n        root->right = buildTree(mid->next, right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        return buildTree(head, nullptr);\n    }\n};\n\n```\n\n\n\n##### 复杂度分析：\n\n时间复杂度：O(nlogn)，其中 nn 是链表的长度。\n\n空间复杂度：O(logn)，","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"meisgithub":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429694199","body":"思路：\n加法模拟\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> ans;\n        int carry = 0;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i)\n        {\n            int digit = k % 10;\n            k /= 10;\n            int sum = num[i] + digit + carry;\n            ans.push_back(sum % 10);\n            carry = sum / 10;\n        }\n        while (k)\n        {\n            int digit = k % 10;\n            k /= 10;\n            int sum = digit + carry;\n            ans.push_back(sum % 10);\n            carry = sum / 10;\n        }\n        if (carry > 0)\n        {\n            ans.push_back(1);\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430809021","body":"思路：遍历一次得到左边和右边最接近字符c的下标，最后计算最近距离\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> left(n);\n        vector<int> right(n);\n        left[0] = s[0] == c ? 0 : -10000;\n        right[n - 1] = s[n - 1] == c ? n - 1 : 20000;\n        for (int i = 1; i < n; ++i)\n        {\n            if (s[i] == c)\n            {\n                left[i] = i;\n            }\n            else\n            {\n                left[i] = left[i - 1];\n            }\n            // cout << n - i - 1 << endl;\n            if (s[n - i - 1] == c)\n            {\n                right[n - i - 1] = n - i - 1;\n            }\n            else\n            {\n                right[n - i - 1] = right[n - i];\n            }\n        }\n        vector<int> ans(n);\n        for (int i = 0; i < n; ++i)\n        {\n            ans[i] = min(abs(i - left[i]), abs(right[i] - i));\n        }\n        return ans;\n    }\n};\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432486024","body":"#### 思路\n* 使用数组模拟\n``` cpp\nclass CustomStack {\nprivate:\n    int m_size;\n    int m_maxSize;\n    vector<int> v;\npublic:\n    CustomStack(int maxSize) {\n        m_size = 0;\n        m_maxSize = maxSize;\n        v.clear();\n    }\n    \n    void push(int x) {\n        if (m_size < m_maxSize)\n        {\n            v.push_back(x);\n            m_size++;\n        }\n    }\n    \n    int pop() {\n        if (m_size == 0)\n        {\n            return -1;\n        }\n        int ans = v[m_size - 1];\n        v.pop_back();\n        m_size--;\n        return ans;\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i < k && i < m_size; ++i)\n        {\n            v[i] += val;\n        }\n    }\n};\n```\n\n#### 复杂度\n* 时间复杂度：O(n)\n* 空间复杂度：O(maxSize())","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1433901307","body":"``` cpp\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<char> encoder;\r\n        stack<int> cnt;\r\n        int n = s.size();\r\n        int i = 0;\r\n        int num = 0;\r\n        while (i < n)\r\n        {\r\n            char c = s[i];\r\n            if (isalpha(c))\r\n            {\r\n                encoder.push(c);\r\n            }\r\n            else if (isdigit(c))\r\n            {\r\n                num = num * 10 + (c - '0');;\r\n            }\r\n            else if (c == '[')\r\n            {\r\n                encoder.push(c);\r\n                cnt.push(num);\r\n                num = 0;\r\n            }\r\n            else\r\n            {\r\n                string tmp;\r\n                while (encoder.top() != '[')\r\n                {\r\n                    tmp.push_back(encoder.top());\r\n                    encoder.pop();\r\n                }\r\n                encoder.pop();\r\n                reverse(tmp.begin(), tmp.end());\r\n                int k = cnt.top();\r\n                cnt.pop();\r\n                string s;\r\n                for (int i = 0; i < k; ++i)\r\n                {\r\n                    s += tmp;\r\n                }\r\n                for (int i = 0; i < s.size(); ++i)\r\n                {\r\n                    encoder.push(s[i]);\r\n                }\r\n            }\r\n            ++i;\r\n        }\r\n        string ans;\r\n        while (!encoder.empty())\r\n        {\r\n            ans += encoder.top();\r\n            encoder.pop();\r\n        }\r\n        reverse(ans.begin(), ans.end());\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435455658","body":"用两个栈来模拟\n``` cpp\nclass MyQueue {\nprivate:\n    stack<int> stk1;\n    stack<int> stk2;\n\n    void move()\n    {\n        while (!stk1.empty())\n        {\n            stk2.push(stk1.top());\n            stk1.pop();\n        }\n    }\n\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        stk1.push(x);\n    }\n    \n    int pop() {\n        if (stk2.empty())\n        {\n            move();\n        }\n        int ans = stk2.top();\n        stk2.pop();\n        return ans;\n    }\n    \n    int peek() {\n        if (stk2.empty())\n        {\n            move();\n        }\n        return stk2.top();\n    }\n    \n    bool empty() {\n        return stk1.empty() && stk2.empty();\n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435978703","body":"排序 + 哈希表\n``` cpp\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        vector<int> tmp = arr;\n        sort(tmp.begin(), tmp.end());\n        int n = arr.size();\n        unordered_map<int, int> cnt;\n        int res = 0;\n        for (int i = 0; i < n; ++i)\n        {\n            cnt[arr[i]]++;\n            if (cnt[arr[i]] == 0)\n            {\n                cnt.erase(arr[i]);\n            }\n            cnt[tmp[i]]--;\n            if (cnt[tmp[i]] == 0)\n            {\n                cnt.erase(tmp[i]);\n            }\n            if (cnt.empty())\n            {\n                res++;\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436026242","body":"``` cpp\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        ListNode* p = head;\n        if (p == nullptr)\n        {\n            return nullptr;\n        }\n        int n = 1;\n        while (p->next)\n        {\n            p = p->next;\n            n++;\n        }\n        p->next = head;\n        k = k % n;\n        p = head;\n        int i = 1;\n        while (i < n - k)\n        {\n            p = p->next;\n            i++;\n        }\n        ListNode* newHead = p->next;\n        p->next = nullptr;\n        return newHead;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437247179","body":"``` cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr)\n        {\n            return head;\n        }\n        ListNode* newHead = head->next;\n        ListNode* nextHead = head->next->next;\n        newHead->next = head;\n        head->next = swapPairs(nextHead);\n        return newHead;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439406802","body":"``` cpp\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        return sortedListToBST(head, nullptr);\n    }\n\n    TreeNode* sortedListToBST(ListNode* start, ListNode* end)\n    {\n        if (start == end)\n        {\n            return nullptr;\n        }\n        ListNode* slow = start;\n        ListNode* fast = start;\n        while (fast != end && fast->next != end)\n        {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        TreeNode* root = new TreeNode(slow->val);\n        root->left = sortedListToBST(start, slow);\n        root->right = sortedListToBST(slow->next, end);\n        return root;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441179208","body":"``` cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* pA = headA;\n        ListNode* pB = headB;\n        while (pA && pB)\n        {\n            pA = pA->next;\n            pB = pB->next;\n        }\n        int i = 0;\n        if (pA)\n        {\n            pB = headB;\n            while (pA)\n            {\n                pA = pA->next;\n                ++i;\n            }\n            pA = headA;\n            while (i > 0)\n            {\n                pA = pA->next;\n                --i;\n            }\n        }\n        else if (pB)\n        {\n            pA = headA;\n            while (pB)\n            {\n                pB = pB->next;\n                ++i;\n            }\n            pB = headB;\n            while (i > 0)\n            {\n                pB = pB->next;\n                --i;\n            }\n        }\n        else\n        {\n            pA = headA;\n            pB = headB;\n        }\n        while (pA != pB)\n        {\n            pA = pA->next;\n            pB = pB->next;\n        }\n        return pA;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sye9286":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429697450","body":"### 思路\n\n把数组转换回数字，直接相加计算，再把结果转换成数组\n不过遇到一个问题是，题目给的数字居然超过了 JS 的安全最大值，被迫把所有数字转换成 BigInt 才能计算\n\n今天时间不多先写下这个方案，后续再思考完善一下其他方案，比如 k 直接往数组最后一位加，超过 10 的进一。但还没想好怎么处理最高位进一的问题。\n\n### 代码\n\n\n```js\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let num_digit = BigInt(0);\n    for (let i=0; i<=num.length-1; i++) {\n        num_digit += BigInt(num[i]) * (BigInt(10) ** BigInt(num.length-1-i) )\n    }\n\n    num_digit += BigInt(k)\n\n    return num_digit.toString().split('').map(Number);\n\n};\n\n```\n\n**复杂度分析**\n\n执行用时：5868 ms, 在所有 JavaScript 提交中击败了6.19%的用户\n内存消耗：50.8 MB, 在所有 JavaScript 提交中击败了5.31%的用户\n\n- 时间复杂度：O(n), n 为数组 num 的长度。\n- 空间复杂度：O(n)\n\n从结果上看 BigInt 的处理应该使用了大量内存空间\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431589153","body":"### 思路\r\n正向遍历，不匹配且从未匹配过时为 num[i] = -1，匹配为0，不匹配但曾经匹配过则为 num[i-1] 的值 +1\r\n反向遍历，和num里的值比较，更新为取较小的值。\r\n\r\n时间关系，代码还在测试中，结果有点问题。。\r\n\r\n### 代码\r\n```js\r\nlet s = [\"q\",\"g\",\"g\",\"c\",\"g\",\"e\",\"h\",\"c\"]\r\nlet c = \"c\"\r\nlet number = []\r\nlet number2 = []\r\n\r\n    let found = false;\r\n    \r\n    for(let i = 0; i < s.length; i++) {\r\n        \r\n\r\n        if (s[i] !== c){\r\n            if (!found) {\r\n                number[i] = -1;\r\n            } \r\n            else number[i] = number[i-1] + 1 ;\r\n        }\r\n\r\n\r\n        if (s[i] === c){\r\n            found = true;\r\n            number[i] = 0;\r\n        }\r\n        \r\n        // console.log(number)\r\n\r\n    }\r\n    \r\n    \r\n    found = false;\r\n    \r\n    for(i = s.length-1; i >= 0; i--) {\r\n    \r\n        if (s[i] === c){\r\n            number2[i] = 0;\r\n        }\r\n\r\n        if (s[i] !== c && i != s.length-1){\r\n            \r\n            number2[i] = number2[i+1] + 1 ;\r\n            \r\n            if (number2[i] < number[i] || number[i] === -1 ) number[i] = number2[i]\r\n        }\r\n    \r\n    \r\n        \r\n        // console.log(number2)\r\n\r\n    }\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432911295","body":"### 思路\n就是个数组。\nrealSize 表示容纳的真实元素数量，同时也可以作为下标用，因为每次都只操作最后一个元素\npush 时只要 realSize 小于 maxSize 就允许添加，否则不需要做特殊处理\npop 时如果 realSize 不为0，就返回那个元素（realSize - 1），并且 realSize 数量减少 1。其实理论上并不需要专门把栈里的数字删除，只要标记数量减少了即可。\ninc 先判断 k 是否大于 realSize，取小的值作为数量，然后从头依次相加\n\n\n### 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = new Array(maxSize)\n    this.realSize = 0;\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.realSize < this.maxSize) {\n        this.stack[this.realSize++] = x;        \n    }\n    //console.log(\"push \"+ x)\n    //console.log(\"RS+ \"+this.realSize)\n    //console.log(this.stack)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    //console.log(\"pop RS \" + this.realSize)\n    //console.log(\"before \"+ this.stack)\n    if(this.realSize !== 0){\n        let val_ret = this.stack[--this.realSize]\n        //console.log(\"RS-- \"+this.realSize)\n        //console.log(\"VR \"+val_ret)\n        this.stack[this.realSize] = undefined\n        //console.log(\"after \"+ this.stack)\n        return val_ret\n    }else return -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\n\n function min(a, b) {\n  return a < b ? a : b;\n}\n\nCustomStack.prototype.increment = function(k, val) {\n    //console.log(\"inc k \"+k+\" val \"+val)\n    //console.log(\"before inc \"+ this.stack)\n\n    for(let i=0; i< min(k,this.realSize); i++) {\n        this.stack[i] += val;\n    }\n    //console.log(\"after inc \"+ this.stack)\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n### 复杂度分析\n时间复杂度，inc是O(n)，其他O(1)\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434439100","body":"### 思路\r\n完全想不到，看了题解写出来也是一知半解，还需要再思考一下\r\n\r\n\r\n### 代码\r\n```js\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let sta = []; \r\n    let num = 0;\r\n    let res = \"\";\r\n\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] >= '0' && s[i] <= '9') {\r\n            num *= 10;\r\n            num += parseInt(s[i]);\r\n        }\r\n\r\n        else if (s[i] === '[') {\r\n            sta.push([num, res]);\r\n            num = 0;\r\n            res = \"\";\r\n        }\r\n\r\n        else if (s[i] === ']') {\r\n            let [n, a] = sta.pop();\r\n            for (let j = 0; j < n; j++) {\r\n                a += res;\r\n            }\r\n            res = a;\r\n        }\r\n        \r\n        else {\r\n            res += s[i];\r\n        }\r\n    }\r\n    return res;\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435675132","body":"额 写完了发现好像不允许用数组，只能用栈，怪不得写起来这么简单。。。\r\n我重新思考一下\r\n\r\n### 思路\r\nJS中没有stack，用数组代替。新建队列时，初始化头指针 head 和尾指针 tail 均为 0\r\n\r\n1. push : 添加到尾指针处，然后尾指针 +1\r\n\r\n2. pop : 返回头指针处的元素，然后头指针后移一位，元素仍在数组中不需要删除。\r\n另外题目中说明所有操作保证有效，不会对空队列执行 pop，所以不用验证是否队列为空（head 不应该大于 tail）\r\n\r\n3. peek : 返回头指针处的元素，但不移动头指针位置\r\n\r\n4. empty : 头指针等于尾指针时，表示队列是空的。\r\n\r\n\r\n### 代码\r\n\r\n\r\n```js\r\n\r\nvar MyQueue = function() {\r\n    this.stack = new Array()\r\n    this.head = 0;\r\n    this.tail = 0;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack[this.tail++] = x;\r\n    // console.log(\"aft push tail = \"+this.tail)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    // no need to check if empty operation always valide\r\n    return this.stack[this.head++];\r\n}; \r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[this.head];\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return (this.head === this.tail);\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)，不需要遍历数组\r\n- 空间复杂度：O(1)，没有使用额外空间","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437224697","body":"### 思路\n1. 遍历一遍找到 tail 和 length\n2. 从 tail 开始找到 前 k-1 个节点\n3. 前 k 个节点的作为新 head 返回 \n\n\n### 代码\n\n\n```js\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    // console.log(head.val)\n    // console.log(head.next.val)\n\n    // if nothing in the linked list \n    //  or only one item in the list\n    //  or k = 0\n    // => no need to rotate\n    if (head === null || head.next === null || k === 0 )\n        return head;\n\n    let length = 1;\n    tail = head;\n\n    // to find the tail and the length of the list\n    while (tail.next !== null) {\n        length++;\n        tail = tail.next;\n    }\n\n    // use modulo to count back from the head if k > length\n    k = k % length;\n\n    // if k === 0, means k = length or k is a multiple of length\n    // that means the k-th node from tail is it's head\n    // no need to rotate\n    if (k === 0) return head;\n\n    let newTail = head;\n    for (let i = 0; i< length - k - 1; i++) {\n        newTail = newTail.next;\n    }\n\n    \n    let newHead = newTail.next;\n    newTail.next = null;\n    tail.next = head;\n\n    return newHead;\n\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438183240","body":"### 思路\n如果 head 为空或者只有一个点，则不用交换直接返回，有两个点的，用递归的方式交换两个点。\n\n\n### 代码\n\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    if (head === null || head.next === null)\n        return head;\n\n    let newHead = head.next;\n    head.next = swapPairs(newHead.next)\n    newHead.next = head;\n    \n    return newHead;\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439829021","body":"### 思路\n用双指针遍历有序链表，找到中间点，用递归方式生成左右子树\n\n\n### 代码\n\n\n```js\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n\n    if (head === null) {\n        return head;\n    }\n\n    let fast = head;\n    let slow = head;\n    let preSlow = null;\n\n    while (fast !== null && fast.next !== null) {\n        fast = fast.next.next;\n        preSlow = slow;\n        slow = slow.next;\n    }\n\n    let node = new TreeNode(slow.val);\n\n    if (preSlow !== null) {\n        preSlow.next = null;\n        node.left = sortedListToBST(head);\n    }\n\n    node.right = sortedListToBST(slow.next);\n\n    return node;\n\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N log N)\n- 空间复杂度：O(log N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fuku-l":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429707061","body":"### 思路\n1. 从低位开始，每次取两个数字的相应一位a,b。进行求和sum（a+b+carry），取sum的个位放到结果，取sum的十位放到进位carry。对两个数字的指针进行移动，直到两个数字都遍历结束。\n2. 判断是否存在进位，有就将进位放到结果中。\n**模板**\n```\nwhile( A 没完 || B 没完成){\n    a = A 的当前位\n    b = B 的当前位\n    # 求和\n    sum = a+b+进位carry\n    当前位 = sum % 10\n    进位 = sum / 10\n\n    # 移动 A 和B\n    A=A/10\n    B=B/10 \n}\n\nif(进位carry!=0) {\n    将进位加到结果中\n}\n```\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int sum = 0;\n        int carry = 0;\n        int idx = num.length-1;\n        while(idx >=0 || k !=0){\n            int a = idx >= 0 ? num[idx]:0;\n            int b = k!=0 ? k%10:0;\n            sum = a+b+carry;\n            res.add(0,sum%10);\n            carry = sum/10;\n            idx--;\n            k/=10;\n        }\n        if(carry!=0) res.add(0, carry);\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(max(N, logK))，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430858292","body":"### 思路\r\n数组的正序遍历和倒序遍历。需要遍历两次，使用 indexof(ch, index)需要注意字符串不存在的情况，即返回-1。\r\n\r\n### 代码\r\n\r\n```java\r\npublic class Q0821ShortestDistanceToACharacter {\r\n\r\n    public static void main(String[] args) {\r\n        Solution solution = new Q0821ShortestDistanceToACharacter().new Solution();\r\n        int[] test1= solution.shortestToChar(\"loveleetcode\", 'e');\r\n        System.out.println(Arrays.toString(test1));;\r\n    }\r\n\r\n    class Solution {\r\n        public int[] shortestToChar(String s, char c) {\r\n            int[] res = new int[s.length()];\r\n            int ch = c;\r\n\r\n            for (int i = 0; i < s.length(); i++) {\r\n                int a = s.indexOf(ch, i);\r\n                int b = s.lastIndexOf(ch, i);\r\n                if (a == i) {\r\n                    res[i] = 0;\r\n                } else {\r\n                    res[i] = a>0&&b>0?Math.min(Math.abs(a - i), Math.abs(b-i)):a<0? Math.abs(b-i): Math.abs(a-i);\r\n                    //if(a<0){\r\n                    //    res[i] = Math.abs(b-i);\r\n                    //} else if(b<0){\r\n                    //    res[i] = Math.abs(a-i);\r\n                    //} else {\r\n                    //    res[i] = Math.min(Math.abs(a - i), Math.abs(b-i));\r\n                    //}\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432640510","body":"### 思路\r\n因为题目中要求 nc() 方法需要遍历栈底到k的区间，可以使用数组和指针来完成\r\n\r\n### 代码\r\n\r\n```java\r\nclass CustomStack {\r\n    int[] arr = null;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top < arr.length-1){\r\n            arr[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top >= 0){\r\n            return arr[top--];\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int loop = Math.min(k-1, top);\r\n        for(int i = 0; i <= loop; i++){\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：出栈和入栈为O(1)，increment方法为O(N)， N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434398421","body":"### 思路\r\n将数字、字母、左括号、右括号看作独立的str，用栈来维护这些str\r\n1. 如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\r\n2. 如果为字符或左括号，直接进栈\r\n3. 如果为右括号，开始出栈。一直到左括号出栈，出栈序列反转后拼成字符串a，取出栈顶数字num，将a重复num次后进栈\r\n\r\n### 代码\r\n\r\n```java\r\n\r\npublic class Q0394DecodeString {\r\n\r\n    public static void main(String[] args) {\r\n        Solution solution = new Q0394DecodeString().new Solution();\r\n        String s = solution.decodeString(\"3[z]2[2[y]pq4[2[jk]e1[f]]]ef\");\r\n        System.out.println(s);\r\n    }\r\n    class Solution {\r\n        public String decodeString(String s) {\r\n            Deque<String> stack = new ArrayDeque<String>();\r\n            int idx = 0;\r\n            while (idx < s.length()) {\r\n                char ch = s.charAt(idx);\r\n                if (Character.isDigit(ch)) {\r\n                    // 数字\r\n                    int end = s.indexOf('[',idx);\r\n                    stack.push(s.substring(idx, end));\r\n                    idx = end;\r\n                } else if(']' == ch){\r\n                    // 出栈，直到遇到'['\r\n                    String a = \"\";\r\n                    while (!\"[\".equals(stack.peek())){\r\n                        a = stack.pop() + a;\r\n                    }\r\n                    stack.pop();\r\n                    int num = Integer.parseInt(stack.pop());\r\n                    String val = \"\";\r\n                    for (int i = 0; i < num; i++) {\r\n                        val+=a;\r\n                    }\r\n                    stack.push(val);\r\n                    idx++;\r\n                }else {\r\n                    // 字符 或者 [ 直接进栈\r\n                    stack.push(String.valueOf(ch));\r\n                    idx++;\r\n                }\r\n            }\r\n\r\n            StringBuffer res = new StringBuffer();\r\n            Object[] str = stack.toArray();\r\n            for (int i = str.length-1; i >=0; i--) {\r\n                res.append(str[i]);\r\n            }\r\n            return res.toString();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435465707","body":"### 思路\r\n使用ArrayDeque的栈作为数据结构。\r\n设计两个栈，一个栈用来保存push的数据，一个栈用来保存pop的数据。\r\n\r\n**对应方法思考**：\r\n1. 入队：每次入队时直接入队就可以。\r\n2. 出队：每次出队从pop栈中取值，如果pop栈中没有数据，就将push栈中的数据放到pop栈中，再将队头数据出栈。\r\n3. peek()：和出队思路一样，只是将 pop() 操作改为 peek()。\r\n4. 判断为空：需要判断两个栈是否都为空。\r\n\r\n### 代码\r\n\r\n```java\r\nclass MyQueue {\r\n    Deque<Integer> push_stack;\r\n    Deque<Integer> pop_stack;\r\n    public MyQueue() {\r\n        this.push_stack = new ArrayDeque<Integer>();\r\n        this.pop_stack = new ArrayDeque<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        push_stack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(pop_stack.isEmpty() && push_stack.isEmpty()){\r\n            return -1;\r\n        } else if(pop_stack.isEmpty()){\r\n            while(!push_stack.isEmpty()){\r\n                pop_stack.push(push_stack.pop());\r\n            }\r\n        } \r\n        return pop_stack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(pop_stack.isEmpty() && push_stack.isEmpty()){\r\n            return -1;\r\n        } else if(pop_stack.isEmpty()){\r\n            while(!push_stack.isEmpty()){\r\n                pop_stack.push(push_stack.pop());\r\n            }\r\n        } \r\n        return pop_stack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return pop_stack.isEmpty() && push_stack.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push()和empty()：O(1)，pop()，peek()：平均为O(1)。\r\n- 空间复杂度：O(N)，其中 N 为数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435990309","body":"### 思路\r\n单调栈，从左往右遍历数组，如果当前值比栈顶元素小时，需要栈中比当前值大的所有元素都出栈，将最大的一个元素入栈。\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Deque<Integer> stack = new ArrayDeque<Integer>();\r\n        for(int n: arr){\r\n            if(stack.isEmpty() || n >= stack.peek()){\r\n                stack.push(n);\r\n            } else {\r\n                int max = stack.pop();\r\n                while(!stack.isEmpty() && stack.peek() > n){\r\n                    stack.pop();\r\n                }\r\n                stack.push(max);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436414160","body":"### 思路\r\n1. 分析测试案例可知，将链表的每一位都移动k个位置，相当于将链表的后续k个节点连到head。\r\n2. 使用两个指针 p1 和 p2， p2 先走k步（若p2走到尾节点，说明k>size，可以优化k=(k%size)+size，减少循环走次数。）\r\n3. p1 和 p2 一起走，直到p2到达尾节点。将p2.next连到head，将head指向 p1.next 作为新的头，将p1.next置空。\r\n4. 返回head。\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n\r\n        ListNode p1 = head;\r\n        ListNode p2 = head;\r\n        int size = 1;\r\n        for(int i = 0; i < k; i++){\r\n            if(p2.next!=null){\r\n                p2 = p2.next;\r\n                size++;\r\n            } else {\r\n                p2 = head;\r\n                k = (k % size) + size;\r\n            }\r\n        }\r\n\r\n        while(p2.next!=null){\r\n            p2 = p2.next;\r\n            p1 = p1.next;\r\n        }\r\n\r\n        p2.next = head;\r\n        head = p1.next;\r\n        p1.next = null;\r\n\r\n        return head;\r\n    }\r\n}\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437982711","body":"### 思路\r\n1. 新增一个虚拟头节点，以保持交换操作的一致性。\r\n2. 循环条件为 cur.next != null && cur.next.next != null\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n        ListNode pre = new ListNode(0);\r\n        pre.next = head;\r\n        ListNode cur = pre;\r\n        while (cur.next != null && cur.next.next!=null){\r\n            ListNode tmp = cur.next;\r\n            cur.next = tmp.next;\r\n            tmp.next = cur.next.next;\r\n            cur.next.next = tmp;\r\n            cur = tmp;\r\n        }\r\n        return pre.next;\r\n    }\r\n}\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439552974","body":"### 思路\r\n1. 使用递归构造树和树的左右节点。\r\n2. 使用快慢指针查找链表的中间节点。\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return buildTree(head, null);\r\n    }\r\n\r\n    public TreeNode buildTree(ListNode left, ListNode right){\r\n        if(left == right){\r\n            return null;\r\n        }\r\n        ListNode mid = getMedian(left, right);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = buildTree(left, mid);\r\n        root.right = buildTree(mid.next, right);\r\n        return root;\r\n    }\r\n\r\n    public ListNode getMedian(ListNode left, ListNode right){\r\n        ListNode fast = left;\r\n        ListNode slow = left;\r\n        while(fast != right && fast.next != right){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(NlogN)，其中 N 为数组长度。\r\n- 空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441321239","body":"### 思路\r\n两个思路，一种参考题解（更简单高效）。\r\n思路一：一开始想的，使用Set判断和保存遍历时两个节点。空间复杂度 O(N)，时间复杂度 O(N)\r\n思路二：参考题解。如果两个链表相交，那么两个指针一起走到相交节点的路径应该是一致的。（都是经过自身链表+另一条链表相交节点的前半部分)。空间复杂度O(1)，时间复杂度O(N)。\r\n\r\n### 代码\r\n思路一代码：空间复杂度 O(N)，时间复杂度 O(N)，N为两个链表的长度之和。\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        \r\n        Set<ListNode> save = new HashSet<>();\r\n        if (headA != null) save.add(headA);\r\n        if (headB != null){\r\n            if (save.contains(headB)){\r\n                return headB;\r\n            } else {\r\n                save.add(headB);\r\n            }\r\n        }\r\n\r\n        while (headA.next!=null || headB.next!=null){\r\n            if (headA.next != null){\r\n                headA = headA.next;\r\n                if (save.contains(headA)){\r\n                   return headA;\r\n                } else {\r\n                    save.add(headA);\r\n                }\r\n            }\r\n            if (headB.next!=null){\r\n                headB=headB.next;\r\n                if (save.contains(headB)) {\r\n                   return headB;\r\n                } else {\r\n                    save.add(headB);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n思路二代码：（更简单高效）空间复杂度O(1)，时间复杂度O(N)。\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) return null;\r\n        ListNode p1 = headA;\r\n        ListNode p2 = headB;\r\n        while (p1 != p2) {\r\n            p1 = p1 == null ? headB : p1.next;\r\n            p2 = p2 == null ? headA : p2.next;\r\n        }\r\n        return p1;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kangliqi1":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429723823","body":"public List<Integer> addToArrayForm(int[] num,int k) {\n               //把k拆分成数组\n\t\tString kStr = String.valueOf(k);\n\t\tList<Integer> kArr= new ArrayList<>();\n\t\tString[] kStrs = kStr.split(\"\");\n\t\t//取较大值为遍历总次数，遍历相加，大于10则前一位多加1\n\t\tint a= num.length;\n\t\tint b = kStrs.length;\n\t\tint max = a;\n\t\tif (b>a){\n\t\t\tmax = b;\n\t\t}\n\t\tList <Integer> res = new ArrayList<>();\n\t\tint next = 0;\n\t\tfor (int j = 1;j<=max;j++) {\n\t\t\tint num1 = 0;\n\t\t\tint num2 = 0;\n\t\t\tif (a - j >=0) {\n\t\t\t\tnum1 = num[a-j];\n\t\t\t}\n\t\t\tif (b- j >= 0) {\n\t\t\t\tnum2 = Integer.valueOf(kStrs[b-j]);\n\t\t\t}\n\t\t\tint cur = num1+num2+next;\n\t\t\tif (cur>=10) {\n\t\t\t\tres.add(cur%10);\n\t\t\t\tnext = 1;\n\t\t\t} else {\n\t\t\t\tres.add(cur);\n\t\t\t\tnext = 0;\n\t\t\t}\n\t\t}\n\t\treturn Collections.reverse(res);\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431236149","body":"        public static int[] shortestToChar(String s, char c) {\n\t// 字符串长度\n        int len = s.length();\n        //创建一个和字符串长度一样长的数组存储结果值\n        int[] r = new int[len];\n \t//从左遍历\n        int pos = -10000;\n \tfor (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                pos = i;\n            }\n            r[i] = i - pos;\n        }\n \t//从右遍历\n        pos = 10000;\n        for (int i = len - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                pos = i;\n            }\n            r[i] = Math.min(r[i], pos - i);\n        }\n        return r;\n    }\n\n时间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433044884","body":"class CustomStack {  \r\n\t\r\n\tList<Integer> stack = new ArrayList();\r\n\tint maxSize = 0;\r\n\r\n   public CustomStack(int num) {\r\n      maxSize = num;\r\n    }\r\n\t\r\n\tpublic void push(int i) {\r\n\t\tif (stack.size() < maxSize) {\r\n\t\t\tstack.add(i);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic int pop() {\r\n\t\tif (stack.size == 0) {\r\n\t\t\treturn -1;\r\n\t\t} else {\r\n\t\t\tint res = stack.get(stack.size() - 1);\r\n\t\t\tstack.removeLast();\r\n\t\t\treturn res;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic void inc(int k, int val) {\r\n\t\tint i = k < stack.size() ? k : stack.size();\r\n\t\tfor (int j = 0;j < i;j++) {\r\n\t\t\tstack.get(j) += val;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n时间复杂度 stack.inc(int k, int val)   O(n)\r\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434656386","body":"public String decodeString(String str) {\n\t\tStringBuffer res = new StringBuffer();\n\t\tString [] strs = str.split(\"]\");\n\t\tfor (int i = 0;i < strs.length;i++) {\n\t\t\tString curStr = strs[i];\n\t\t\tint index = 0;\n\t\t\t// 循环判断字符串直接放入结果中\n\t\t\tfor (int j = 0;j<curStr.length();j++) {\n\t\t\t\tif (curStr.charAt(j) < 48 || curStr.charAt(j) > 57) {\n\t\t\t\t\tres.append(curStr.charAt(j));\n\t\t\t\t\tindex ++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//数字部分\n\t\t\tint time = Integer.valueOf(curStr.substring(index,curStr.indexOf(\"[\")));\n\t\t\t//重复字符串部分\n\t\t\tString realStr = curStr.substring(curStr.indexOf(\"[\")+1);\n\t\t\tint k = 0;\n\t\t\twhile (k<time) {\n\t\t\t\tres.append(realStr);\n\t\t\t}\n\t\t}\n\t\treturn res.toString();\n\t}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435688387","body":"class MyQueue {\n    Deque<Integer> s1;\n    Deque<Integer> s2;\n    public MyQueue() {\n        this.s1 = new LinkedList<Integer>();\n        this.s2 = new LinkedList<Integer>();\n    }\n    \n    public void push(int x) {\n        s1.push(x);\n    }\n    \n    public int pop() {\n        if(s2.isEmpty() && s1.isEmpty()){\n            return -1;\n        } else if(s2.isEmpty()){\n            while(!s1.isEmpty()){\n                s2.push(s1.pop());\n            }\n        } \n        return s2.pop();\n    }\n    \n    public int peek() {\n        if(s2.isEmpty() && s1.isEmpty()){\n            return -1;\n        } else if(s2.isEmpty()){\n            while(!s1.isEmpty()){\n                s2.push(s1.pop());\n            }\n        } \n        return s2.peek();\n    }\n    \n    public boolean empty() {\n        return s2.isEmpty() && s1.isEmpty();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436003937","body":"public int maxChunksToSorted(int[] arr) {\nLinkedList<Integer> stack = new LinkedList<Integer>();\n for(int num : arr) {\nif(!stack.isEmpty() && num < stack.getLast()) {\nint head = stack.removeLast();\nwhile(!stack.isEmpty() && num < stack.getLast()) {\nstack.removeLast();\n } \n stack.addLast(head);\n}\nelse stack.addLast(num);\n }\n return stack.size();\n }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436877643","body":"public ListNode rotateRight(ListNode head, int k) {\r\nif (k == 0 || head == null || head.next == null) {\r\nreturn head;\r\n}\r\nint n = 1;\r\nListNode iter = head;\r\nwhile (iter.next != null) {\r\niter = iter.next;\r\nn++;\r\n}\r\nint add = n - k % n;\r\nif (add == n) {\r\nreturn head;\r\n}\r\niter.next = head;\r\nwhile (add-- > 0) {\r\niter = iter.next;\r\n}\r\nListNode ret = iter.next;\r\niter.next = null;\r\nreturn ret;\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438529945","body":"public ListNode swapPairs(ListNode head) {\nListNode temp = new ListNode(0,head);\nListNode ans = temp;\nwhile(head!=null&&head.next!=null){\ntemp.next = temp.next.next;\nhead.next = head.next.next;\ntemp.next.next = head;\nhead = head.next;\ntemp = temp.next.next;\n}\nreturn ans.next;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439950124","body":"class Solution {\n  public TreeNode sortedListToBST(ListNode head) {\n      if(head == null) return null;\n      return dfs(head,null);\n  }\n  private TreeNode dfs(ListNode head, ListNode tail){\n      if(head == tail) return null;\n      ListNode fast = head, slow = head;\n      while(fast != tail && fast.next != tail){\n          fast = fast.next.next;\n          slow = slow.next;\n      }\n      TreeNode root = new TreeNode(slow.val);\n      root.left = dfs(head, slow);\n      root.right = dfs(slow.next, tail);\n      return root;\n  }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richardtaok":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429734899","body":"# 思路\n将k转成数组，从数组最后一个两两相加，在加上上一对相加后的除数\n将余数赋值给较长数组的当前值\n更新当前的除数，直到其中一个走到头了\n长的一个数组继续上面的步骤。直到temp为0.\n返回最长的数组\n# 代码\n```\nvar addToArrayForm = function(num, k) {\n    const data = String(k).split('').map(i=>Number(i))\n    const addList = (num,data)=>{\n        let i = data.length-1;\n        let j = num.length-1;\n        let temp = 0\n        while(i>=0 && j>=0){\n            let sum = data[i] + num[j] + temp;\n            num[j] = sum%10\n            temp = parseInt(sum/10)\n            i--;\n            j--;\n            console.log(num)\n        }\n        while(j>=0){\n            let sum = num[j] + temp;;\n            num[j]=sum%10\n            temp = parseInt(sum/10)\n            j--;\n        }\n        console.log(num)\n        if(temp){\n            num.unshift(1)\n        }\n        return num;\n    }\n    if(num.length>=data.length){\n        return addList(num,data)\n    }else{\n        return addList(data,num)\n    }\n    \n    \n};\n```\n# 复杂度\n时间复杂度： O(n)\n空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431546994","body":"# 代码\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    const res = new Array(s.length).fill(0);\r\n    const n = s.length;\r\n    // idx是记录下最近一次左边c出现的位置\r\n    for(let i=0,idx=-n;i<n;i++){\r\n        if(s[i]===c){\r\n            idx = i\r\n        }\r\n        res[i] = i-idx;\r\n    }\r\n    // 记录下最近一次右边c出现的位置\r\n    for(let i=n-1,idx=2*n;i>=0;i--){\r\n        if(s[i]===c){\r\n            idx = i\r\n        }\r\n        res[i] = Math.min(res[i],idx-i)\r\n    }\r\n    return res\r\n};\r\n```\r\n# 复杂度分析\r\nT(n)=O(n)\r\nS(n)=O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433315696","body":"# 代码\n```\nvar CustomStack = function(maxSize) {\n    this.length = 0\n    this.maxSize = maxSize;\n    this.values = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.length<this.maxSize){\n        this.values.push(x)\n        this.length +=1;\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.length>0){\n        this.length-=1\n        return this.values.pop()\n    }\n    return -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    console.log(this.length,k)\n    const len = this.length<k ? this.length : k\n    for(let i = 0;i<len;i++){\n        this.values[i] += val\n    }\n    \n};\n```\n# increment复杂度\nT(n)= O(k)\nS(n)=O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434825772","body":"# 思路\n1. 因为我们需要重复数字次数的字符串，而字数数字存在于字符串前面，所以适合借助栈来使用。\n2. 一个栈放数字，因为可能会遇到连续好几次的[，所以我们需要一个栈来存放【 之前的字符串。\n3. 开始循环\n    - 如果遇到数字，放到数字栈中，但是由于可能存在好几个数字，所以需要一个repeat来记录多个数字\n    - 如果遇到【  将repeat入数字栈，将攒的str入字符栈 ，str重新记录，repeat置为0，为了防止遇到3[a4[c]]这种\n    - 如果遇到普通字符，那就就攒字符\n   - 如果遇到 】，数字栈出栈，字符str重复数字次数。res = 字符栈出栈一个值，连接上str\n4. 最终的str就是我们想要的str\n# 代码分析\n```\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    const repeatStack = []\n    const resStack = []\n    let res=\"\"\n    let repeat = 0\n    for(let i=0;i<s.length;i++){\n        const str = s[i];\n        if(str>='0' && str<='9'){\n            repeat =repeat*10+ (str - '0')\n        }else if(str === '['){\n            repeatStack.push(repeat);\n            resStack.push(res);\n            res=''\n            repeat = 0\n        }else if(str === ']'){\n            let num = repeatStack.pop()\n            let s = ''\n            while(num>0){\n                s+=res;\n                num-=1\n            }\n            res = resStack.pop()+s;\n        }else{\n            res+=str\n        }\n    }\n    return res;\n};\n```\n# 复杂度分析\nT(n) = O(n)\nS(n) = O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435688248","body":"# 思路\n这个题目上说的是用两个栈实现队列，但是在js中栈也是数组模拟的。所以当我们直接用一个数组也就能模拟出队列\npush：就是入，放到数组最后\npop：返回就是数组第一个值，然后删除数组第一个值。\npeek：就是数组第一个\n# 代码\n```javascript\nvar MyQueue = function() {\n    this.stack = []\n    this.head = 0;\n    this.tail = 0\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stack.push(x);\n    this.tail+=1\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    return this.stack[this.head++]\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.stack[this.head]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.head === this.tail\n};\n```\n# 复杂度分析\nT(n)=O(1)\nS(n)=O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436018787","body":"# 算法思路\n看了大佬的解题思路，才知道这个是非递减的就需要分块。所以使用递增栈来做一个分块临界，导致每次都能将最大的保留下来。直到遇到更大的没法合并的\n# 代码\n```javascript\nvar maxChunksToSorted = function(arr) {\n    let stack = []\n    for(let i=0;i<arr.length;i++){\n\n        if(stack.length &&  stack[stack.length-1]> arr[i]){\n            const topStack = stack[stack.length-1]\n            while(stack && stack[stack.length-1]>arr[i]){\n                stack.pop()\n            }\n            stack.push(topStack)\n        }else{\n            stack.push(arr[i])\n        }\n    }\n    return stack.length\n};\n```\n# 复杂度分析\nO(n)\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437222578","body":"# 代码\n```javascript\nif (!head || !head.next) return head;\n    let count = 0,now = head;\n    while (now) {\n        now = now.next;\n        count++;\n    }\n    let new_k = k % count;\n    let slow = (fast = head);\n    while(fast.next){\n        if(new_k-- <= 0){\n            slow = slow.next\n        }\n        fast = fast.next\n    }\n    const cur = slow.next;\n    slow.next = null;\n    fast.next = head;\n    return cur\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1440277827","body":"# 算法思路\n1. 链表的交换\n2. 递归\n# 代码\n```javascript\nvar swapPairs = function(head) {\n    if(!head || !head.next){\n        return head\n    }\n    const pre = head;\n    const cur = head.next;\n    const next = cur.next;\n    cur.next = pre;\n    pre.next = swapPairs(next);\n    return cur;\n};\n```\n# 复杂度分析\nT(n) = O(n)\nS(n) = O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440293693","body":"# 思路\n以当前节点为根，左边的为左子树，右边的为右子树。\n快慢指针，来选中间节点。快指针走两步，慢指针走一步，直到快指针到达尾部，慢指针真好为中间节点。\n# 代码\n```javascript\nvar sortedListToBST = function(head) {\n    function dfs(head, tail) {\n        if (head == tail) return null;\n        let fast = head;\n        let slow = head;\n        while (fast != tail && fast.next != tail) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        let root = new TreeNode(slow.val);\n        root.left = dfs(head, slow);\n        root.right = dfs(slow.next, tail);\n        return root;\n    }   \n    if (!head) return null;\n    return dfs(head, null);\n};\n```\n# 复杂度分析\nT(n)=O(nlogn)\nS(n) = O(logn)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chocolate-emperor":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429752834","body":"```c++\n// 大数加法，从最低位计算，一直加到两数均取完，最后再把多出的进位数也加上\nclass Solution {\npublic:\n\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(),num.end());\n        vector<int>res;\n        int bit_res = 0,curr=0;\n        while(k!=0 || curr<num.size()){\n            if(curr<num.size()) bit_res+=num[curr];\n            if(k!=0)    bit_res += k%10;\n            res.push_back(bit_res%10);\n\n            bit_res = bit_res/10;\n            k=k/10;\n            curr+=1;\n        }\n        while(bit_res!=0){\n            res.push_back(bit_res%10);\n            bit_res/=10;\n        }\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431312919","body":"```c++\nclass Solution {\npublic:\n//每个字符的结果来自离它右侧和左侧最近的字符c中的较小值\n//扫描两遍，第一遍更新所有c字符右侧字符的距离，第二遍更新所有c字符的左侧字符距离\n    vector<int> shortestToChar(string s, char c) {\n        int l = s.length();\n        int dis = 0, i=0, j=l-1;\n        vector<int>res(l,l);\n        while(s[i]!=c && i<l)  i+=1;\n        while(i <= l-1){\n            if(s[i]==c) dis=i;\n            res[i] = min(res[i],i-dis);\n\n            i+=1;\n        }\n\n        while(s[j]!=c && j>=0)   j-=1;\n        while(j>=0){\n            if(s[j]==c) dis=j;\n            res[j] = min(res[j],dis - j);\n\n            j-=1;\n        }   \n\n        return res;  \n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433167584","body":"```c++\nclass CustomStack {\npublic:\n    int stk[1000+5];\n    int max_sz;\n    int cnt;    //（最后一个元素）栈顶元素序号\n    CustomStack(int maxSize) {\n        max_sz = maxSize;\n        cnt = -1;\n    }\n    \n    void push(int x) {\n        if(cnt+1<max_sz)   stk[++cnt] = x;\n\n    }\n    \n    int pop() {\n        if(cnt>-1)    return stk[cnt--];   \n        else return -1;\n    }\n    \n    void increment(int k, int val) {\n        for(int i=0;i<min(k,cnt+1);i++){\n            stk[i]+=val;\n        }\n    }\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439946214","body":"```c++\nclass Solution {\npublic:\n//递归:结束条件，走一步+之前递归的结果\n//从链表中点断开，分成中点，左，右，三个子链表，左右子链转换成左右子树，形成以链表中点为根的BST\n    TreeNode* sortedListToBST(ListNode* head) {\n         if(head==nullptr){\n            return nullptr;\n        }else if(head->next==nullptr){\n            return new TreeNode(head->val,nullptr,nullptr);\n        }\n        else{\n            ListNode*sentry = new ListNode(0,head);\n            ListNode*l=sentry,*r=sentry,*lend=sentry;\n\n            while(r->next!=nullptr){\n                lend = l;\n                l=l->next;\n                r=r->next;\n                if(r->next)     r=r->next;\n            }\n\n            lend->next =nullptr;\n            TreeNode *res = new TreeNode(l->val,\n            sortedListToBST(sentry->next),sortedListToBST(l->next));\n            return res;\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441664738","body":"```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* a = headA, *b = headB;\n        while(a!=b){\n            a = a->next;\n            b = b->next;\n            if(a==nullptr && b)  a = headB;\n            if(b==nullptr && a)  b = headA;\n        }\n        return a;\n    }\n};\n//时间复杂度：O(m+n)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lydia61":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429759312","body":"# 989. 数组形式的整数加法\n\n## 思路\n\n - 将 num 和 k 逐位进行求和，并将求和结果的个位逐个保存\n- 直到 num 全部遍历， 且 k 为 0 \n\n## 代码\n \n``` c++\nclass Solution\n{\npublic:\n    vector<int> addToArrayForm(vector<int> &num, int k)\n    {\n        // 用来保存结果值\n        vector<int> v_res;\n        \n        // 将 num 和 k 逐位进行求和，并将求和结果的个位逐个保存\n        // 直到 num 全部遍历， 且 k 为 0 \n        while (!num.empty() || k) {\n            if (!num.empty()) { \n                k += num.back();\n                num.pop_back();\n            }\n            v_res.push_back(k % 10);\n            k /= 10;\n        }\n\n        // 反转成从高位到低位\n        reverse(v_res.begin(), v_res.end());\n        \n        // 返回结果\n        return v_res;\n    }\n};\n```\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431497927","body":"# 821. 字符的最短距离\n\n## 思路\n\n正反遍历字符串，分别算出距离目标字符的前后距离。\n\n## 代码\n\n``` c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        // 获取字符串长度\n        int length = s.length();\n        // 初始化结果向量\n        vector<int> v_res(length, 0);\n\n        // 保存 目标位置，初始值为最远处\n        int point_target = -length;\n\n        // 正向遍历\n        for(int index = 0; index < length; index++) {\n            if(s[index] == c) \n                point_target = index;\n            v_res[index] = index - point_target;\n        }\n\n        // 反向遍历\n        point_target = length << 1;\n        for(int index = length - 1; index >= 0; index--) {\n            if(s[index] == c) \n                point_target = index;\n            if (point_target - index < v_res[index])\n                v_res[index] = point_target - index;\n        }\n\n        // 返回结果\n        return v_res;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433244234","body":"# 1381. 设计一个支持增量操作的栈\n\n## 思路\n\n利用定长数组模拟栈\n\n## 代码\n\n``` C++\nclass CustomStack {\nprivate:\n    int * stack;\n    short length;\n    short MAX_SIZE;\n\npublic:\n    CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        length = 0;\n        MAX_SIZE = maxSize;\n    }\n    \n    void push(int x) {\n        if(length < MAX_SIZE)\n            stack[length++] = x;\n    }\n    \n    int pop() {\n        if(length)\n            return stack[--length];\n        else\n            return -1;\n    }\n    \n    void increment(int k, int val) {\n        if (k > length)\n            k = length;\n        while (k)\n            stack[--k] += val;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434840869","body":"# 394. 字符串解码\n\n## 思路\n\n用栈数据结构录入编码的字符串\n\n## 代码\n\n``` C++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res = \"\";\n        string encoded_string;\n        int k, index;\n\n        for(char c : s) {\n            if (c != ']')\n                res += c;\n            else {\n                encoded_string = \"\";\n                k = 0;\n                while(res.back() != '[') {\n                    encoded_string = res.back() + encoded_string;\n                    res.pop_back();\n                }\n                res.pop_back();\n                \n                index = 0;\n                while(!res.empty() && res.back() <= '9' && res.back() >= '0') {\n                    k += (res.back() - '0') * pow(10, index++);\n                    res.pop_back();\n                    cout << k << endl;\n                }\n\n                while(k--)\n                    res += encoded_string;\n            }\n        }\n        return res;\n    }\n};\n``` \n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435693645","body":"# 232. 用栈实现队列\r\n\r\n## 思路\r\n\r\n用输入栈和输出栈两个栈模拟列表。当输出栈有内容时候，输出栈栈顶即为出队数据；若输出栈为空，则从输入栈逐个拿去数据之后再做出栈处理。\r\n\r\n## 代码\r\n\r\n``` C++ \r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n\r\npublic:\r\n    MyQueue() {}\r\n\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    int pop() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n\r\n    int peek() {\r\n        if (outStack.empty()) {\r\n            while (!inStack.empty()) {\r\n                outStack.push(inStack.top());\r\n                inStack.pop();\r\n            }\r\n        }\r\n        return outStack.top();\r\n    }\r\n\r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：O(1)\r\n- 空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436012724","body":"import collections\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        count = collections.defaultdict(int)\n        ans, nonzero = 0, 0\n\n        for x, y in zip(arr, sorted(arr)):\n            count[x] += 1\n            if count[x] == 0:\n                nonzero -= 1\n            if count[x] == 1:\n                nonzero += 1\n\n            count[y] -= 1\n            if count[y] == -1:\n                nonzero += 1\n            if count[y] == 0:\n                nonzero -= 1\n\n            if nonzero == 0:\n                ans += 1\n\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437189745","body":"# 61.旋转链表\n\n## 思路\n\n链表遍历\n\n## 代码 \n\n``` python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        length = 1\n\n        p_node = head\n        while p_node.next:\n            length += 1\n            p_node = p_node.next\n        \n        p_node.next = head\n        k %= length\n        for _ in range(length - k):\n            p_node = p_node.next\n        res = p_node.next\n        p_node.next = None\n        return res\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438610499","body":"# 24. 两两交换链表中的节点\n\n## 思路\n\n使用递归，每次交换两个节点\n\n## 代码\n\n``` C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(!head || !head->next) \n            return head;\n        ListNode * new_head = head->next;\n        head->next = swapPairs(new_head->next);\n        new_head->next = head;\n        return new_head;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440178672","body":"# 109. 有序链表转换二叉搜索树\n\n## 思路\n\n利用快慢指针找出链表中点，然后将左右分别进行递归操作，构成搜索二叉树。\n\n## 代码\n\n``` C++ \nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(!head)\n            return NULL;\n        if(!head->next)\n            return new TreeNode(head->val);\n        \n        ListNode *pre, *slow, *fast;\n        slow = head;\n        fast = head;\n\n        while(fast && fast->next) {\n            pre = slow;\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        TreeNode * root = new TreeNode(slow->val);\n\n        if(pre) {\n            pre->next = NULL;\n            root->left = sortedListToBST(head);\n        }\n        root->right = sortedListToBST(slow->next);\n\n        return root;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangjiahuan17":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429777424","body":"# 思路\r\n将输入list转化为int型后与k相加，再转化为list\r\n\r\n# 代码\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_str = \"\"\r\n        if len(num)>0:\r\n            for i in num:\r\n                num_str += str(i)\r\n            result_int = int(num_str) + k\r\n            result = [int(j) for j in str(result_int)]\r\n        return result\r\n \r\n# 复杂度\r\nO(n)?       \r\n       ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431465290","body":"# 思路\r\n正向遍历，记录s中字符与c的正向距离，反向遍历，记录s中字符与c的反向距离，取二者中最小值\r\n\r\n# 代码\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        sl = len(s)\r\n        result = [0 for i in range(sl)]\r\n\r\n        idx = -sl\r\n        for i, si in enumerate(s):\r\n            if si == c:\r\n                idx = i\r\n            result[i] = i - idx\r\n        \r\n        idx = 2 * sl\r\n        for i in range(sl-1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            result[i] = min(result[i], idx-i)\r\n        \r\n        return result\r\n# 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433203473","body":"# 代码\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.st = []\r\n        self.cnt = 0\r\n        self.size = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.size:\r\n            self.st.append(x)\r\n            self.cnt += 1\r\n\r\n    def pop(self) -> int:\r\n        if len(self.st) == 0:\r\n            return -1\r\n        self.cnt -= 1\r\n        return self.st.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, self.cnt)):\r\n            self.st[i] += val\r\n\r\n# 复杂度\r\n时间复杂度：O(k)\r\n空间复杂度：O(maxsize)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1438500230","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in s:\n            if i == ']':\n                encoded_string = ''\n                k = ''\n                while stack and stack[-1] != '[':\n                    encoded_string = stack.pop() + encoded_string\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    k = stack.pop() + k\n                stack.append(encoded_string * int(k))\n            else:\n                stack.append(i)\n        return \"\".join(stack)\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1438518363","body":"class MyQueue:\r\n\r\n    def __init__(self):\r\n        self.instack = []\r\n        self.outstack = []\r\n    \r\n    def in_to_out(self):\r\n        while self.instack:\r\n            self.outstack.append(self.instack.pop())\r\n\r\n    def push(self, x: int) -> None:\r\n        self.instack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.outstack:\r\n            while self.instack:\r\n                self.outstack.append(self.instack.pop())\r\n        return self.outstack.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.outstack:\r\n            self.in_to_out()\r\n        return self.outstack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        if not self.instack and not self.outstack:\r\n            return True\r\n        else:\r\n            return False\r\n","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438542168","body":"class Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        newhead = head.next\r\n        head.next = self.swapPairs(newhead.next)\r\n        newhead.next = head\r\n        return newhead\r\n        \r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"seanutf":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429780721","body":"```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10) {\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyong-hub":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429806182","body":"```c\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& A, int K) {\n        vector<int> res;\n        int n = A.size();\n        for(int i =n-1;i>=0;i--){\n            int sum = A[i] + K%10;\n            K /=10;\n            if(sum>=10){\n                K++;\n                sum -=10;\n\n            }\n            res.push_back(sum);\n        }\n        for(;K>0;K/=10){\n            res.push_back(K%10);\n        }\n        reverse(res.begin(),res.end());\n        return res;\n\n    }\n};\n```\n# 时间复杂度 O(N)\n# 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431343471","body":"思路：\n1、把c出现的位置记录；\n2、s[i]循环求最小距离\n时间复杂度（O(n*k)）\n空间复杂度O(N)\n```c\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int>num_i;\n        vector<int>res(s.length(),s.size());\n        for(int i=0;i<s.length();i++)\n        {\n            if(s[i]==c)\n                num_i.push_back(i);\n            else\n                continue;\n        }\n\n        for(int i=0;i<s.length();i++)\n        {\n            int dist=s.length();\n            if(s[i]==c)\n            {\n                res[i]=0;\n                continue;\n            } \n            else\n            {\n                for(int j=0;j<num_i.size();j++)\n                {\n                    dist = abs(i-num_i[j]);\n                    if(dist<res[i])\n                        res[i]=dist;\n                }\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433031130","body":"#思路\n使用数组模拟栈\n```c\nclass CustomStack {\nprivate:\n    int size;\n    int top;//栈顶\n    int *stack;//数组模拟栈\npublic:\n    CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        size  = maxSize;\n        top = 0;\n    }  \n    void push(int x) {\n        if(top >=size)\n            return;\n        if(top <size)\n            stack[top++]=x;\n    }\n    \n    int pop() {\n        if(top>0)\n            return stack[--top];\n        else\n            return -1;\n\n    }\n    \n    void increment(int k, int val) {\n            if(top <k){\n                for(int i=0;i<top;i++)\n                        stack[i] +=val;\n            }else{\n                for(int i=0;i<k;i++)\n                        stack[i] +=val;\n\n            }\n    }\n};\n\n\n```\n# 时间复杂度分析\npop push (O(1))\ninc (O(K))\n#空间复杂度\nO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434651099","body":"# 思路\n使用递归\n```c\nclass Solution {\npublic:\n    string helper(string s,int &index){\n        string temp=\"\";\n        string res=\"\";\n        int nums=0;\n        while(index < s.length())\n        {\n          \n            if(s[index]>='0' && s[index]<='9')\n            {\n                nums = nums*10 + (s[index]-'0');\n            }else if(s[index]=='[')\n            {\n                temp = helper(s,++index);\n                while(nums>0){\n                    res+=temp;\n                    nums--;\n                }\n            }else if(s[index]==']'){\n                break;\n            }else{\n                res += s[index];\n            }\n            index++;\n        }\n        return res;\n    }\n    string decodeString(string s) {\n        int index=0;\n        return helper(s,index);\n\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1438495554","body":"# 思路\n用栈有序的最大值，最后返回栈的大小\n```c\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        if(arr.size()==1 || arr[0]==arr.size())\n            return 1;\n        if(arr.size()==0)\n            return 0;\n        stack<int>stk;\n        stk.push(arr[0]);\n        int topmax=stk.top();\n        for(int i=1;i<arr.size();i++){\n            if(stk.top()<=arr[i])\n                stk.push(arr[i]);\n            else{\n                topmax = stk.top();\n                while(stk.size()!=0 &&stk.top()>arr[i]){ \n                    stk.pop();\n                }\n                stk.push(topmax>arr[i]?topmax:arr[i]);  \n            }       \n        }\n        return stk.size();\n\n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436946585","body":"#思路\n采用递归，先把链表形成环，记录头结点\n```c\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || head->next==nullptr || k==0)\n            return head;\n        temphead=head;\n        return helper(head,k);    \n    }\n        ListNode *temphead;//记录头结点 \n        int L = 0;//反转几次\n        int nums =0;//记录长短\n    ListNode* helper(ListNode* head, int k){\n        if(head==nullptr)\n            return head;\n        nums++;\n        if(helper(head->next,k)==nullptr){\n            L= k%nums;\n            head->next = temphead;//形成环\n        }\n        if(L==0){\n            temphead = head->next;\n            head->next = nullptr;\n        }\n        L--;\n        return temphead;\n\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438483714","body":"# 思路\n递归，注意终止条件\n```c\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(!head || !head->next)\n            return head;\n        ListNode *newhead = head->next;\n        head->next = swapPairs(newhead->next);\n        newhead->next = head;\n        return newhead;\n        \n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erquaner":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429815149","body":"```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let arrK = String(k).split('')\r\n    let i = num.length-1, j = arrK.length-1\r\n    let list = [], c = 0\r\n    while(i >=0||j>=0) {\r\n        const add1 = i >= 0 ? num[i] : 0;\r\n        const add2 = j >= 0 ? +arrK[j] : 0;\r\n        const sum = add1 + add2 + c;\r\n        c = Math.floor(sum / 10);\r\n        list.unshift(sum % 10);\r\n        i--;\r\n        j--;\r\n      \r\n    }\r\n     if(c != 0){\r\n        list.unshift(c);\r\n       }\r\n\r\n    return list;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1433066985","body":"```js\r\n//双指针\r\nvar shortestToChar = (S, C) => {\r\n    let res = [] \r\n    for ( let i = 0 ; i < S.length ; i ++){\r\n        let left = i , right = i\r\n        while(1){\r\n            if ( S[left] === C || S[right] === C) {\r\n                res.push(right-i)\r\n                break\r\n            }\r\n            left--;\r\n            right++\r\n        }\r\n    }\r\n    return res\r\n}\r\n// 数组 \r\nvar shortestToChar = (S, C) => {\r\n    let arr = [] , res = [] ,index = 0\r\n    for( let i = 0 ; i < S.length ; i ++){\r\n        if (S[i] === C ) arr.push(i)\r\n    }\r\n    for( let i = 0 ; i < S.length ; i ++){\r\n        for( let j = index ; j < arr.length ; j ++) {\r\n            if ( i <= arr[j] ){\r\n                index = j ; \r\n                res.push(Math.min(arr[j]-i,(i-arr[j-1] || Infinity)))\r\n                break\r\n            }\r\n            j === arr.length -1 && res.push(i-arr[j])\r\n        }\r\n    }\r\n    return res\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433065609","body":"```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.stack = new Array();   // [empty, ...]\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  // 最大长度限制\r\n  if(this.stack.length<this.maxSize){\r\n    this.stack.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  // 栈顶为空的 =》 -1\r\n  if(this.stack.length===0){\r\n    return -1;\r\n  }\r\n  let val = this.stack.pop();\r\n  return val;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let n = Math.min(k,this.stack.length);  //取交集，前n个元素+val\r\n  for(let i=0;i<n;i++){\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiujingxukong":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429824008","body":"# 思路\r\n在leetcode看题解，看到如下思路：\r\n```\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n顺着这个思路写。\r\n# 代码\r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  let res = [];\r\n  let carry = 0;\r\n\r\n  while (num.length !== 0 || k !== 0) {\r\n    let a = num.length !== 0 ? num.pop() : 0;\r\n    let b = k % 10;\r\n\r\n    let sum = a + b + curry;\r\n    let current = sum % 10;\r\n    carry = Math.floor(sum / 10);\r\n\r\n    res.push(current);\r\n\r\n    k = Math.floor(k / 10);\r\n  }\r\n  if (curry === 1) res.push(1);\r\n  return res.reverse();\r\n};\r\n```\r\n# 复杂度分析\r\n1. 时间复杂度\r\nO(max(a,b)) a为给定数组长度，b为给定整数的位数\r\n2. 空间复杂度\r\ncurry是函数范围的变量\r\na,b,sum,current,k都是循环范围的变量\r\n整体空间复杂度为O（1）\r\n\r\n# 个人代码习惯勘误\r\n1. array.push()返回值不是数组，不能res=res.push(current)\r\n2. 返回值需要return值,不然就会看到返回值是undefined\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431476925","body":"# 解题思路\n看Lucifer的官方题解2  \n先将字符c出现在字符串s中的下标位置存入数组cIndices中  \n再遍历字符串s的每个字符，再在cIndices中寻找距离当前字符最近的下标\n# 代码\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let cIndices=[]\n    for(i=0;i<s.length;i++){\n        if(s[i]===c){\n            cIndices.push(i)\n        }\n    }\n\n    let res=Array(s.length).fill(Infinity)\n\n    for(i=0;i<s.length;i++){\n\n        if(s[i]===c){\n            res[i]=0\n            continue\n        }\n\n        for(let cIndex of cIndices){\n            let distance=Math.abs(i-cIndex)\n\n            if(res[i]<distance)break\n\n            res[i]=distance\n        }\n    }\n    return res\n\n};\n```\n# 复杂度分析\n1. 时间复杂度。O（N*K）N为字符串s的长度，K为c字符出现在字符串s中的次数，K<=N。一层循环内套一层小的循环。O（N+N*K）≈O（N*K）\n2. 空间复杂度。O（K）。开辟了新的数组cIndices。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433211649","body":"# 解题思路\r\n第二种解题思路没看懂，第一次看到这种解法，所以按照第一种写代码   \r\n需要一个 cnt 变量记录栈的当前长度，一个 size 变量记录最大容量，并在 pop 和 push 的时候更新 cnt   \r\npush 的时候要判断是否满了   \r\npop 的时候要判断是否空了\r\n从栈底往上的K个元素增加都val，要遍历栈内元素，当增加到K个元素时，便跳出循环。\r\n# 解题代码\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.max=maxSize\r\n    this.stack=[]\r\n\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.stack.length<this.max){\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    const res=this.stack.pop()\r\n   return res==null?-1:res\r\n\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(i=0;i<this.stack.length;i++){\r\n        if(i<k){\r\n            this.stack[i]=this.stack[i]+val\r\n        }\r\n       if(i=k)break\r\n    }\r\n};\r\n```\r\n# 复杂度分析\r\n1. 时间复杂度   \r\npush和pop都是O（1）   \r\nincrement操作是O（min(k,l)）l是stack的长度   \r\n2. 空间复杂度O（1）\r\n# 代码习惯\r\n1. 当js中数组长度为0，此时pop，会返回结果undefined,所以判断原本数组中是否为空的条件，需要是res==null，而不能是res===null\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434672700","body":"# 解题思路\r\n递归方法看了一下应该短时间内看不懂，于是只会用栈的思路解题   \r\n刚开始思路跑偏，输入的字符串的前面和后面的字母无法拼接到最终结果上（JS的数组没有类似Python的append方法），于是看了评论区里的其他人用JS写的解法。   \r\n   \r\n遍历这个字符串 s，判断每一个字符的类型：\r\n如果是字母 --> 添加到 stack 当中\r\n如果是数字 --> 先不着急添加到 stack 中 --> 因为有可能有多位\r\n如果是 [ --> 说明重复字符串开始 --> 将数字和当前的结果字符串入栈 --> 并且将数字零，结果字符串清空\r\n如果是 ] --> 说明重复字符串结束 --> 拼接出重复字符，拼接到结果字符串上   \r\n# JS代码\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n 数据结构用栈\r\n */\r\nvar decodeString = function (s) {\r\n  res = \"\";\r\n  temp = [];\r\n  count = 0;\r\n  for (let i of s) {\r\n    if (i === \"]\") {\r\n      const [str, num] = temp.pop();\r\n      res = str + res.repeat(num);\r\n      continue;\r\n    } else if (Number.isInteger(Number(i))) {\r\n      count = Number(count + i);\r\n      continue;\r\n    } else if (i === \"[\") {\r\n      temp.push([res, count]);\r\n      res = \"\";\r\n      count = 0;\r\n      continue;\r\n    } else {\r\n      res = res + i;\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```\r\n# 复杂度分析\r\n1. 时间复杂度O（n）n为s的长度，遍历了一遍s。\r\n2. 空间复杂度O（k）k为s中右括号或者说左括号的个数\r\n# 代码习惯\r\n1. 第一次知道字符串实例的方法 repeat\r\n2. 使用typeof判断字符串的字符时，好像都会判断为string，所以遍历s时，条件为字符类型是string的要放在最后。\r\n3. Number.isInteger(Number(i))用于判断i的类型\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435665081","body":"# 解题思路\r\n此题结合实际——使用两个栈来替代一个队列的实现是为了在多进程中分开对同一个队列对读写操作——来看确实经典，而且解法上官方题解更趋近于现实情况，即分为读栈和写栈。  \r\n下面这段话还怎么理解。 \r\n>实际上现实中也有使用两个栈来实现队列的情况，那么为什么我们要用两个 stack 来实现 一个 queue？   \r\n其实使用两个栈来替代一个队列的实现是为了在多进程中分开对同一个队列对读写操作。一 个栈是用来读的，另一个是用来写的。当且仅当读栈满时或者写栈为空时，读写操作才会发 生冲突。   \r\n当只有一个线程对栈进行读写操作的时候，总有一个栈是空的。在多线程应用中，如果我们 只有一个队列，为了线程安全，我们在读或者写队列的时候都需要锁住整个队列。而在两个 栈的实现中，只要写入栈不为空，那么push操作的锁就不会影响到pop。\r\n# 解题代码\r\n1. 我自己的实现\r\n```javascript\r\nvar MyQueue = function() {\r\n    this.stack1=[]\r\n    this.stack2=[]\r\n\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack1.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    const length=this.stack1.length\r\n    if(length!==0){\r\n        for(let i=0;i<length;i++){\r\n            this.stack2.push(this.stack1.pop())\r\n        }\r\n        const del=this.stack2.pop()\r\n        for(let i=0;i<length-1;i++){\r\n            this.stack1.push(this.stack2.pop())\r\n        }\r\n        return del\r\n        }\r\n   \r\n    };\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    \r\n        const length=this.stack1.length\r\n        if(length!==0){\r\n        for(let i=0;i<length;i++){\r\n            this.stack2.push(this.stack1.pop())\r\n        }\r\n        top=this.stack2.pop()\r\n        this.stack1.push(top)\r\n        for(let i=0;i<length-1;i++){\r\n            this.stack1.push(this.stack2.pop())\r\n        }\r\n    \r\n    return top\r\n    }\r\n\r\n\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack1.length===0?true:false\r\n\r\n};\r\n```\r\n2. 官方题解（更好更贴近现实情况）\r\n```javascript\r\nvar MyQueue = function () {\r\n  this.inStack = [];\r\n  this.outStack = [];\r\n};\r\n\r\nMyQueue.prototype.push = function (x) {\r\n  this.inStack.push(x);\r\n};\r\n\r\nMyQueue.prototype.pop = function () {\r\n  if (!this.outStack.length) {\r\n    this.in2out();\r\n  }\r\n  return this.outStack.pop();\r\n};\r\n\r\nMyQueue.prototype.peek = function () {\r\n  if (!this.outStack.length) {\r\n    this.in2out();\r\n  }\r\n  return this.outStack[this.outStack.length - 1];\r\n};\r\n\r\nMyQueue.prototype.empty = function () {\r\n  return this.outStack.length === 0 && this.inStack.length === 0;\r\n};\r\n\r\nMyQueue.prototype.in2out = function () {\r\n  while (this.inStack.length) {\r\n    this.outStack.push(this.inStack.pop());\r\n  }\r\n};\r\n```\r\n# 复杂度分析（只分析官方思路代码）\r\n1. 时间复杂度\r\npush和empty操作都是O（1）\r\npeek和pop操作都是O（N），其中 N 为 栈中元素个数。\r\n2. 空间复杂度\r\n空间复杂度：O(N)，其中 N 为 栈中元素个数，多使用了一个辅助栈，这 个辅助栈的大小和原栈的大小一样。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436010591","body":"# 解题思路\r\n这道题本来题目都没看明白，看了Lucifer的题解才明白了。   \r\n由于只有分的块内部可以排序，块与块之间的相对位置是不能变的。因此直观上我们的核心其实找到从左到右开始不减少（增加或者不变）的地方并分块。   \r\n只要后面有较小值，那么前面大于它的都应该在一个块里面，有没有注意到我们一直在找下一个比当前小的元素？这就是一个信号，使用单调递增栈即可以空间换时间的方式解决。   \r\n思路逆转，不是分割区块，而是融合区块。比如 [2,1,3,4,4]，遍历到 1 的时候会发现 1 比 2 小，因此 2， 1 需要在一块，我们可以将 2 和 1 融合，并重新压回栈。那么融合成 1 还是 2 呢？答案是 2，因为 2 是瓶颈，这提示我们可以用一个递增栈来完成。   \r\n# 代码\r\n```javascript\r\nvar maxChunksToSorted = function (arr) {\r\n  const stack = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    a = arr[i];\r\n    if (stack.length > 0 && stack[stack.length - 1] > a) {\r\n      const cur = stack[stack.length - 1];\r\n      while (stack && stack[stack.length - 1] > a) stack.pop();\r\n      stack.push(cur);\r\n    } else {\r\n      stack.push(a);\r\n    }\r\n  }\r\n  return stack.length;\r\n};\r\n```\r\n# 复杂度分析\r\n1. 时间复杂度：O(N)，其中 N 为数组长度。\r\n2. 空间复杂度：O(N)，其中 N 为数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437202390","body":"# 解题思路\r\n第一步：找到链表倒数第 k 个节点。   \r\n算法描述：\r\n\r\n1. 采用快慢指针；\r\n2. 快指针与慢指针都以每步一个节点的速度向后遍历；\r\n3. 快指针比慢指针先走 k 步；\r\n4. 当快指针到达终点时，慢指针正好是倒数第 k+1 个节点\r\n\r\n第二步：旋转链表。   \r\n算法描述：\r\n   \r\n1. 获取单链表的倒数第 k 与倒数第 k + 1 个节点；\r\n2. 将倒数第 k + 1 个节点的 next 指向 null；\r\n3. 将尾节点 next 指向 head（拼起来）；\r\n4. 返回倒数第 k 个节点\r\n\r\n# 解题代码\r\n```javascript\r\nvar rotateRight = function (head, k) {\r\n  if (!head || !head.next) return head;\r\n  let count = 0,\r\n    now = head;\r\n  while (now) {\r\n    now = now.next;\r\n    count++;\r\n  }\r\n  k = k % count;\r\n  let slow = (fast = head);\r\n  while (fast.next) {\r\n    if (k-- <= 0) {\r\n      slow = slow.next;\r\n    }\r\n    fast = fast.next;\r\n  }\r\n  fast.next = head;\r\n  let res = slow.next;\r\n  slow.next = null;\r\n  return res;\r\n};\r\n```\r\n# 复杂度分析\r\n1. 时间复杂度O（n），节点最多只遍历两遍。\r\n2. 空间复杂度O(1)，未使用额外的空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438716824","body":"# 解题思路\r\n考察点：   \r\n\r\n1. 怎么改变链表节点指针转向；\r\n2. 链表的递归性；\r\n3. 创建一个空节点 preHead，让其 next 指针指向 A(充当 preA 的角色)，这样是我们专注于算法逻辑，避免判断边界条件。这涉及到链表指针修改的时候头节点可能发生变化的时候非常常用。\r\n\r\n# 解题代码\r\n```javascript\r\nvar swapPairs = function (head) {\r\n  if (!head || !head.next) return head;\r\n  let res = head.next;\r\n  let now = head;\r\n  let preNode = new ListNode();\r\n  preNode.next = head;\r\n  while (now && now.next) {\r\n    let nextNode = now.next;\r\n    let nnNode = nextNode.next;\r\n    now.next = nnNode;\r\n    nextNode.next = now;\r\n    preNode.next = nextNode;\r\n    preNode = now;\r\n    now = nnNode;\r\n  }\r\n  return res;\r\n};\r\n```\r\n# 复杂度分析\r\n1. 时间复杂度O（N）\r\n2. 空间复杂度O（1）\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440292363","body":"# 解题思路\r\n二叉搜索树：左子树的值比根节点小，右子树的值比根节点大。   \r\n算法：   \r\n\r\n1. 获取链表中点\r\n2. 以链表中点为根\r\n3. 中点左边的值都小于它,可以构造左子树；\r\n4. 同理构造右子树；\r\n5. 循环第一步\r\n# 解题代码\r\n第一种获取链表中点的方法：使用快慢指针，定义一个快指针每步前进两个节点，一个慢指针每步前进一个节点，当快指针到达尾部的时候，正好慢指针所到的点为中点。\r\n```javascript\r\nvar sortedListToBST = function (head) {\r\n  if (!head) return null;\r\n  return dfs(head, null);\r\n};\r\n\r\nfunction dfs(head, tail) {\r\n  if (head == tail) return null;\r\n  let fast = head;\r\n  let slow = head;\r\n  while (fast != tail && fast.next != tail) {\r\n    fast = fast.next.next;\r\n    slow = slow.next;\r\n  }\r\n  let root = new TreeNode(slow.val);\r\n  root.left = dfs(head, slow);\r\n  root.right = dfs(slow.next, tail);\r\n  return root;\r\n}\r\n```\r\n第二种获取链表中点的方法，使用数组将链表的值存储,以空间换时间。\r\n```javascript\r\nvar sortedListToBST = function (head) {\r\n  let res = [];\r\n  while (head) {\r\n    res.push(head.val);\r\n    head = head.next;\r\n  }\r\n  return dfs(res, 0, res.length - 1);\r\n};\r\n\r\nfunction dfs(res, l, r) {\r\n  if (l > r) return null;\r\n  let mid = parseInt((l - r) / 2 + r);\r\n  let root = new TreeNode(res[mid]);\r\n  root.left = dfs(res, l, mid - 1);\r\n  root.right = dfs(res, mid + 1, r);\r\n  return root;\r\n}\r\n```\r\n# 复杂度分析\r\n## 第一种方法\r\n时间复杂度：递归树的深度为 logn，每一层的基本操作数为 n，因此总的时间复杂度为O(nlogn)\r\n空间复杂度：O（logn）,递归树的深度为 logn\r\n## 第二种方法\r\n时间复杂度：递归树每个节点的时间复杂度为 O(1)，每次处理一个节点，因此总的节点数就是 n， 也就是说总的时间复杂度为O(n)。\r\n空间复杂度：使用了数组对链表的值进行缓存，空间复杂度为O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"x1aox1a":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429825256","body":"# **0989. 数组形式的整数加法**\n\n# 题目\n\n```bash\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\n\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\n\n示例 1：\n\n输入：num = [1,2,0,0], k = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n示例 2：\n\n输入：num = [2,7,4], k = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n示例 3：\n\n输入：num = [2,1,5], k = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n```\n\n# 思路\n\n1. 将列表转数字\n2. 数字相加\n3. 数字和转列表\n4. 返回列表\n\n# 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        def list_to_num(num: List[int]) -> int:\n            # O(N)\n            res = 0\n            Len = len(num)\n            for i in range(Len):\n                res += num[i] * 10**(Len-i-1)\n            return res\n\n        def num_to_list(k: int) -> List[int]:\n            # O(N)\n            return list(map(int, str(k)))\n\n        return num_to_list(list_to_num(num) + k)\n```\n\n- 时间复杂度：O(N) + O(N) = O(N)\n- 空间复杂度：O(1)，除了返回结果，只使用了常数空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431475727","body":"# 0**821. 字符的最短距离**\r\n\r\n# 题目\r\n\r\n```python\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n```\r\n\r\n# 思路：双向遍历\r\n\r\n- 第一次：左到右，计算最短距离\r\n- 第二次：右到左，再次计算并且更新最短距离\r\n\r\n# 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n\r\n        L = len(s)\r\n        res = [L] * L\r\n        \r\n        # left to right\r\n        c_idx = None\r\n        for i, char in enumerate(s):\r\n            if char==c:\r\n                c_idx, res[c_idx] = i, 0\r\n            elif c_idx is not None:\r\n                res[i] = i-c_idx\r\n\r\n        # right to left        \r\n        c_idx = None  \r\n        for i, char in enumerate(s[::-1]):\r\n            i = L-i-1\r\n            if char==c: \r\n                c_idx = i\r\n            elif c_idx is not None:\r\n                res[i] = min(res[i], c_idx-i)\r\n        \r\n        return res\r\n```\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433300555","body":"# **1381. 设计一个支持增量操作的栈**\r\n\r\n# 题目\r\n\r\n```python\r\n请你设计一个支持对其元素进行增量操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack stk = new CustomStack(3); // 栈是空的 []\r\nstk.push(1);                          // 栈变为 [1]\r\nstk.push(2);                          // 栈变为 [1, 2]\r\nstk.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\nstk.push(2);                          // 栈变为 [1, 2]\r\nstk.push(3);                          // 栈变为 [1, 2, 3]\r\nstk.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\nstk.increment(5, 100);                // 栈变为 [101, 102, 103]\r\nstk.increment(2, 100);                // 栈变为 [201, 202, 103]\r\nstk.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\nstk.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\nstk.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\nstk.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n```\r\n\r\n# 思路\r\n\r\n# 代码\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max_size = maxSize\r\n        self.size = 0\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size == self.max_size: return None\r\n        self.stack.append(x)\r\n        self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.size == 0: \r\n            return -1\r\n        else:\r\n            self.size -= 1\r\n            return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, self.size)):\r\n            if i==self.max_size:\r\n                return None\r\n            self.stack[i] += val\r\n            \r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n\r\n- 时间复杂度：\r\n    - push: O(1)\r\n    - pop: O(1)\r\n    - increment: O(min(k, size)), size is the current size\r\n- 空间复杂度：都是 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434842539","body":"# **394. 字符串解码**\r\n\r\n# 题目\r\n\r\n```python\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n示例 3：\r\n\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n示例 4：\r\n\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n```\r\n\r\n# 思路：stack\r\n\r\n- 在 “]” 之前，入栈\r\n- 遇到  “]” ，即出栈\r\n- 注意点：\r\n    - 需要 pop 掉 “[”\r\n    - 次数有可能不是个位数\r\n\r\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1332ae90-07bb-4f2f-bcbd-05637c76c434/Untitled.png)\r\n\r\n# 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for char in s:\r\n            if char == \"]\":\r\n                repeat_str = \"\"\r\n                repeat_count = \"\"\r\n                # 1. repeat_str\r\n                while stack[-1] != \"[\":\r\n                    repeat_str = stack.pop() + repeat_str\r\n                # 2. pop out \"[\"\r\n                stack.pop() \r\n                # 3. repeat_count\r\n                while stack and stack[-1].isnumeric():\r\n                    repeat_count = stack.pop() + repeat_count\r\n                # 4. repeat_count * repeat_str\r\n                stack.append(int(repeat_count)*repeat_str)\r\n            else:\r\n                stack.append(char)\r\n\r\n        return \"\".join(stack)\r\n```\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n- 时间 40 ms 击败 36.67%\r\n- 内存 15 MB 击败 32.21%","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435694047","body":"# **0232. 用栈实现队列**\r\n\r\n# 题目\r\n\r\n```python\r\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\r\n\r\n实现 MyQueue 类：\r\n\r\nvoid push(int x) 将元素 x 推到队列的末尾\r\nint pop() 从队列的开头移除并返回元素\r\nint peek() 返回队列开头的元素\r\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\r\n说明：\r\n\r\n你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n \r\n\r\n示例 1：\r\n\r\n输入：\r\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\r\n[[], [1], [2], [], [], []]\r\n输出：\r\n[null, null, null, 1, 1, false]\r\n\r\n解释：\r\nMyQueue myQueue = new MyQueue();\r\nmyQueue.push(1); // queue is: [1]\r\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\nmyQueue.peek(); // return 1\r\nmyQueue.pop(); // return 1, queue is [2]\r\nmyQueue.empty(); // return false\r\n```\r\n\r\n# 思路\r\n\r\n- 两个栈：\r\n    - self.stack 用于数据保存\r\n    - tmp_stack 用于在 pop 和 peek 时拷贝 self.stack 并获取 tmp_stack 底部数据\r\n- 注意点：\r\n    - 进行 pop 操作时，需要将 self.len - 1\r\n\r\n# 代码\r\n\r\n```python\r\nfrom copy import deepcopy as copy\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack = []\r\n        self.len = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        # O(1)\r\n        self.stack.append(x)\r\n        self.len += 1\r\n\r\n    def pop(self) -> int:\r\n        # O(N) 将 stack 清空直至剩下最后一个，即 queue pop\r\n        # 需要将 len-1，代表 pop\r\n        tmp_stack = copy(self.stack)\r\n        tmp_len = self.len\r\n        while tmp_len > 1:\r\n            tmp_stack.pop()\r\n            tmp_len -= 1\r\n        self.len -= 1 # reduse len when pop\r\n        return tmp_stack.pop()\r\n\r\n    def peek(self) -> int:\r\n        # O(N) 将 stack 清空直至剩下最后一个，即 queue peek\r\n        tmp_stack = copy(self.stack)\r\n        tmp_len = self.len\r\n        while tmp_len > 1:\r\n            tmp_stack.pop()\r\n            tmp_len -= 1\r\n        return tmp_stack.pop()\r\n\r\n    def empty(self) -> bool:\r\n        # O(1)\r\n        return self.len == 0\r\n```\r\n\r\n- 时间复杂度：\r\n    - push: O(1)\r\n    - pop: O(N)，while 操作，N 为之前 push 的次数\r\n    - peek: O(N)，while 操作，N 为之前 push 的次数\r\n    - empty: O(1)\r\n- 空间复杂度：\r\n    - push: O(1)\r\n    - pop: O(N)，copy 操作，N 为之前 push 的次数\r\n    - peek: O(N)，copy 操作，N 为之前 push 的次数\r\n    - empty: O(1)\r\n- 时间 32 ms 击败 87.77%\r\n- 内存 15.3 MB 击败 5.26%","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436023145","body":"# **0768. 最多能完成排序的块 II**\r\n\r\n# 题目\r\n\r\n```python\r\n给你一个整数数组 arr 。\r\n\r\n将 arr 分割成若干 块 ，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\r\n\r\n返回能将数组分成的最多块数？\r\n\r\n \r\n示例 1：\r\n\r\n输入：arr = [5,4,3,2,1]\r\n输出：1\r\n解释：\r\n将数组分成2块或者更多块，都无法得到所需的结果。 \r\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \r\n示例 2：\r\n\r\n输入：arr = [2,1,3,4,4]\r\n输出：4\r\n解释：\r\n可以把它分成两块，例如 [2, 1], [3, 4, 4]。 \r\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。\r\n```\r\n\r\n# 思路\r\n\r\n- 对于每一个分隔点，其左边所有元素需小于等于右侧所有元素\r\n- 可以通过在末尾插入一个 inf 来简化代码\r\n\r\n# 代码\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        count = 0\r\n        arr.append(float('inf'))\r\n        for i in range(1, len(arr)):\r\n            if max(arr[:i]) <= min(arr[i:]):\r\n                count += 1\r\n\r\n        return count\r\n```\r\n\r\n- 时间复杂度：O(N^2)\r\n- 空间复杂度：O(1)\r\n- 时间 764 ms 击败 5.26%\r\n- 内存 15.2 MB 击败 63.16%","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437009800","body":"# **0061. 旋转链表**\r\n\r\n# 题目\r\n\r\n```python\r\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\r\n\r\n示例 1：\r\n输入：head = [1,2,3,4,5], k = 2\r\n输出：[4,5,1,2,3]\r\n\r\n示例 2：\r\n输入：head = [0,1,2], k = 4\r\n输出：[2,0,1]\r\n```\r\n\r\n# 思路\r\n\r\n- 通过计算链表长度，可以将缩小 k\r\n1. 将 old tail node 的 next 设置为 old head\r\n2. 读取目标两个节点【只有两个节点，因此不必使用 queue】\r\n    1. 第一个节点的 next 设置为 None，即为 new tail node\r\n    2. 第二个节点为 new head\r\n\r\n![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302202103122.png](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302202103122.png)\r\n\r\n# 代码\r\n\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if k==0 or not head:\r\n            return head\r\n\r\n        # 0. Calculate len and reduce k\r\n        Len, cur = 0, head\r\n        while cur:\r\n            Len += 1\r\n            prev, cur = cur, cur.next            \r\n        k %= Len\r\n            \r\n        # 1. Link old tail node to head\r\n        prev.next = head\r\n                \r\n        # 2. Find target nodes      \r\n        new_tail, new_head = None, None\r\n        cur_idx, cur = 0, head\r\n        while cur_idx <= Len-k:\r\n            new_tail, new_head = new_head, cur            \r\n            cur_idx, cur = cur_idx+1, cur.next\r\n        # 2.1 Link new tail node to None\r\n        new_tail.next = None\r\n        # 3.2 Return new head\r\n        return new_head\r\n```\r\n\r\n- 时间复杂度：O(N)，N 为链表长度\r\n- 空间复杂度：O(1)\r\n- 时间 36 ms 击败 86.77%\r\n- 内存 14.8 MB 击败 95.47%","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438015489","body":"# ****0024. 两两交换链表中的节点****\r\n\r\n# 题目\r\n\r\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\r\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\r\n\r\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8196ab83-ec41-43d3-b270-f2598e1238b9/Untitled.png)\r\n\r\n```python\r\n示例 1：\r\n输入：head = [1,2,3,4]\r\n输出：[2,1,4,3]\r\n\r\n示例 2：\r\n输入：head = []\r\n输出：[]\r\n\r\n示例 3：\r\n输入：head = [1]\r\n输出：[1]\r\n\r\n提示：\r\n链表中节点的数目在范围 [0, 100] 内\r\n0 <= Node.val <= 100\r\n```\r\n\r\n# 思路1\r\n\r\n- 观察规律，如图所示\r\n- 首先排除没有任何 node 或者只有一个 node 的链表\r\n- 对于起码有两个 node 的链表，轮流记录 first node 和 second node，反复进行 step 1～2 操作\r\n- 直到没有 new_first（偶数链表）或者没有 new_first.next（奇数链表），进行 step 3 操作\r\n\r\n![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302211600438.jpeg](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302211600438.jpeg)\r\n\r\n# 代码1\r\n\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        \"\"\"\r\n        用递归实现链表相邻互换：\r\n        第一个节点的 next 是第三、第四个节点交换的结果，第二个节点的 next 是第一个节点；\r\n        第三个节点的 next 是第五、第六个节点交换的结果，第四个节点的 next 是第三个节点；\r\n        以此类推\r\n        :param ListNode head\r\n        :return ListNode\r\n        \"\"\"\r\n        if not head or not head.next:\r\n            return head\r\n                \r\n        first = head\r\n        second = head.next\r\n        new_head = second\r\n        \r\n        while True:\r\n            new_first = second.next\r\n            # step 1. link `sencod` to `first`\r\n            second.next = first\r\n            # step 3, return `new_head` when come to the end\r\n            if not new_first or not new_first.next:\r\n                first.next = new_first\r\n                return new_head\r\n            # step 2. link `first` to `new_second`\r\n            else:                \r\n                first.next = new_first.next                \r\n            # move forward, repeat step 1~2 until step 3\r\n            first = new_first\r\n            second = new_first.next\r\n```\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n\r\n# 思路2：递归\r\n\r\n- 用递归实现链表相邻互换：\r\n    - 第一个节点的 next 是第三、第四个节点交换的结果，\r\n        - 第二个节点的 next 是第一个节点；\r\n    - 第三个节点的 next 是第五、第六个节点交换的结果，\r\n        - 第四个节点的 next 是第三个节点；\r\n- 以此类推\r\n\r\n# 代码2\r\n\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        \"\"\"\r\n        用递归实现链表相邻互换：\r\n        第一个节点的 next 是第三、第四个节点交换的结果，第二个节点的 next 是第一个节点；\r\n        第三个节点的 next 是第五、第六个节点交换的结果，第四个节点的 next 是第三个节点；\r\n        以此类推\r\n        :param ListNode head\r\n        :return ListNode\r\n        \"\"\"\r\n        # 如果为 None 或 next 为 None，则直接返回\r\n        if not head or not head.next:\r\n            return head\r\n\r\n        _next = head.next                      # 第二个节点\r\n        head.next = self.swapPairs(_next.next) # 第一个节点的 next 是：第三、第四个节点交换的结果\r\n        _next.next = head                      # 第二个节点的 next 是：第一个节点\r\n        return _next\r\n```\r\n\r\n- 时间复杂度：O(N)，所有节点只遍历一遍\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440038295","body":"# **0109. 有序链表转换二叉搜索树**\r\n\r\n# 题目\r\n\r\n```python\r\n给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。\r\n\r\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。\r\n\r\n示例 1:\r\n输入: head = [-10,-3,0,5,9]\r\n输出: [0,-3,9,-10,null,5]\r\n解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。\r\n示例 2:\r\n\r\n输入: head = []\r\n输出: []\r\n```\r\n\r\n# 思路1：链表→数组→BST\r\n\r\n- 首先链表转数组，将问题转换为有序数组到BST的问题\r\n- 再根据左右索引，递归建立 BST\r\n\r\n![https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302221730672.jpeg](https://x1a-alioss.oss-cn-shenzhen.aliyuncs.com/SnippetsLab/202302221730672.jpeg)\r\n\r\n# 代码\r\n\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head: return None\r\n\r\n        # linklist to list\r\n        node = head\r\n        n = 0\r\n        nums = []\r\n        while node:\r\n            nums.append(node.val)\r\n            n += 1\r\n            node = node.next\r\n        \r\n        def list_to_BST(L, center_idx, R):\r\n            # L: close, R: close\r\n            left_idx = (L+center_idx-1) // 2  \r\n            right_idx = (R+center_idx+1) // 2\r\n\r\n            center = TreeNode(val=nums[center_idx])\r\n            if left_idx!=center_idx and left_idx>=L:\r\n                center.left = list_to_BST(L, left_idx, center_idx-1)\r\n            if right_idx!=center_idx and right_idx<=R:\r\n                center.right = list_to_BST(center_idx+1, right_idx, R)\r\n            return center\r\n\r\n        return list_to_BST(0, n//2, n-1)\r\n```\r\n\r\n- 时间复杂度：O(n)，每个数字都得经历一次\r\n- 空间复杂度：O(n)，转换为数组所占用的空间，n为节点数量\r\n- 时间 64 ms 击败 81%\r\n- 内存 21.5 MB 击败 5.18%","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1440489330","body":"# ****0160. 相交链表****\r\n\r\n# 题目\r\n\r\n![Screen Shot 2022-06-28 at 21.12.22.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c5797b21-f982-419f-80d4-4b70548ce765/Screen_Shot_2022-06-28_at_21.12.22.png)\r\n\r\n# 思路1：正向遍历 + 逆向遍历\r\n\r\n- 分别遍历 A、B，储存为 list\r\n- 逆向遍历 list，直到相等\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        A, B = [], []\r\n        while headA:\r\n            A.append(headA)\r\n            headA = headA.next\r\n        while headB:\r\n            B.append(headB)\r\n            headB = headB.next\r\n        \r\n        ans = None\r\n        for i in range(-1, -min(len(A)+1, len(B)+1), -1):\r\n            if A[i]==B[i]:\r\n                ans = A[i]        \r\n        return ans\r\n```\r\n\r\n- 时间复杂度：O(m+n)\r\n- 空间复杂度：O(m+n)\r\n\r\n# 思路2：哈希化\r\n\r\n有 A, B 这两条链表, 先遍历其中一个，比如 A 链表, 并将 A 中的所有节点存入哈希表。\r\n遍历 B 链表,检查节点是否在哈希表中, 第一个存在的就是相交节点\r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        A = set()\r\n        while headA:\r\n            A.add(headA)\r\n            headA = headA.next\r\n                \r\n        while headB:\r\n            if headB in A:\r\n                return headB\r\n            headB = headB.next\r\n\r\n        return None\r\n```\r\n\r\n- 时间复杂度：O(m+n)\r\n- 空间复杂度：O(m)\r\n\r\n# 思路3：双指针 （A+C+B = B+C+A）\r\n\r\n例如使用 a, b 两个指针分别指向 A, B 这两条链表, 两个指针相同的速度向后移动,\r\n\r\n- 当 a 到达链表的尾部时,重定位到链表 B 的头结点\r\n- 当 b 到达链表的尾部时,重定位到链表 A 的头结点。\r\n- a, b 指针相遇的点为相交的起始节点，否则没有相交点\r\n\r\n![https://tva1.sinaimg.cn/large/007S8ZIlly1gfig7vsvwhj30bs05z3yl.jpg](https://tva1.sinaimg.cn/large/007S8ZIlly1gfig7vsvwhj30bs05z3yl.jpg)\r\n\r\n为什么 a, b 指针相遇的点一定是相交的起始节点? 我们证明一下：\r\n\r\n> 1. 将两条链表按相交的起始节点继续截断，链表 1 为: A + C，链表 2 为: B + C\r\n2. 当 a 指针将链表 1 遍历完后,重定位到链表 B 的头结点,然后继续遍历直至相交点(a 指针遍历的距离为 A + C + B)\r\n3. 同理 b 指针遍历的距离为 B + C + A\r\n> \r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a, b = headA, headB\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA\r\n        return a\r\n```\r\n\r\n- 时间复杂度：O(m+n)\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"drinkmorekaik":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429842914","body":"## 思路\n##### 遍历数组num然后往数字k累加，省去进位的考虑，使用~~运算符避免undefined相加为NaN的情况，返回数组先使push最终再reserve比每一次unshift性能更好\n```\nconst addToArrayForm = function(num, k) {\n    const res = [];\n    let len = num.length - 1\n    while(len >= 0 || k) {\n        k += ~~num[len]\n        res.push(k % 10)\n        k = parseInt(k / 10)\n        len--\n    }\n    return res.reverse()\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431458364","body":"## 思路\r\n## 双指针记录当前正在遍历字符串的最近的左右字符c的index\r\n## 然后计算距离它的最小值\r\n```javascript\r\nvar shortestToChar = function(s, c) {\r\n  const res = []\r\n  let leftIndex = -1,\r\n      rightIndex = s.indexOf(c)\r\n  for (let i = 0; i < s.length; i++) {\r\n      if (leftIndex === -1 && i < rightIndex) {\r\n          res[i] = rightIndex - i\r\n          continue\r\n      }\r\n      if (i === rightIndex) {\r\n          res[i] = 0\r\n          leftIndex = rightIndex\r\n          rightIndex = s.indexOf(c, leftIndex + 1)\r\n          continue\r\n      }\r\n      // i-leftIndex 一定为正数， rightIndex-i 使用 Math.abs 的原因是 rightIndex 值可能为 -1，-1减去i的绝对值一定大于 i-leftIndex\r\n      res[i] = Math.min(i - leftIndex, Math.abs(rightIndex - i))\r\n  }\r\n  return res\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433180933","body":"##API 搬运工\n```javascript\nclass CustomStack {\n  constructor(maxSize) {\n    this.maxSize = maxSize\n    this.stack = []\n  }\n  push(x) {\n    if (this.stack.length < this.maxSize) this.stack.push(x)\n  }\n  pop() {\n    return this.stack.pop() || -1\n  }\n  increment(k, val) {\n    const count = Math.min(k, this.stack.length)\n    for (let i = 0; i < count; i++) {\n      this.stack[i] += val\n    }\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434820374","body":"var decodeString = function(s) {\n    let numStack = [];              // 倍数 num 的等待栈\n    let strStack = [];              // 待拼接 str 的等待栈\n\n    let num = 0, result = '';\n\n    for(let i = 0; i < s.length; i++) {\n        const item = s[i];\n\n        if(!isNaN(item)) {              // 判断是数字时\n            num = num * 10 + parseInt(item);\n        } else if(item === '[') {\n            strStack.push(result);\n            result = '';\n            numStack.push(num);\n            num = 0;\n        } else if(item === ']') {\n            const repeatTimes = numStack.pop();         // 从栈中获取次数\n            result = strStack.pop() + result.repeat(repeatTimes);\n        } else {\n            result += item;\n        }\n    }\n    return result;\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435674626","body":"```javascript\nclass MyQueue {\n    constructor() {\n        this.stackPush = []\n        this.stackPop = []\n    }\n    push(val) {\n        this.stackPush.push(val)\n    }\n    pop() {\n        if (this.stackPop.length) return this.stackPop.pop()\n        while(this.stackPush.length) {\n            this.stackPop.push(this.stackPush.pop())\n        }\n        return this.stackPop.pop()\n    }\n    peek() {\n        return this.stackPop.length ? this.stackPop.at(-1) : this.stackPush.at(0)\n    }\n    empty() {\n        return !this.stackPop.length && !this.stackPush.length\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435996628","body":"## 没想出来，看了题解思路写的\r\n```javascript\r\nvar maxChunksToSorted = function (arr) {\r\n  let maxStack = [arr[0]]\r\n  for (let i = 1; i < arr.length; i++) {\r\n    if (arr[i] >= maxStack.at(-1)) {\r\n      maxStack.push(arr[i])\r\n    } else {\r\n      let maxValue = -Infinity\r\n      while (maxStack.at(-1) > arr[i]) {\r\n        maxValue = Math.max(maxValue, maxStack.pop())\r\n      }\r\n      maxStack.push(maxValue)\r\n    }\r\n  }\r\n  return maxStack.length\r\n}\r\n```\r\n<img width=\"692\" alt=\"iShot_2023-02-19_21 57 29\" src=\"https://user-images.githubusercontent.com/51078581/219952900-89d7c5a9-7f8e-4ecf-90ce-b420300c95f1.png\">","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437258377","body":"## 快慢指针\r\n```javascript\r\nvar rotateRight = function(head, k) {\r\n    if (!head) return null\r\n    let slow = head, fast = head\r\n    while (k--) {\r\n        fast = fast.next || head\r\n    }\r\n    if (fast === slow) return head\r\n    while (fast.next) {\r\n        slow = slow.next\r\n        fast = fast.next \r\n    }\r\n    const res = slow.next || head\r\n    slow.next = null\r\n    fast.next = head\r\n    return res\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438762349","body":"## 递归\r\n```javascript\r\nfunction ListNode(val) {\r\n    this.val = val;\r\n    this.next = null;\r\n}\r\n\r\nvar swapPairs = function (head) {\r\n    if (!head || !head.next) {\r\n        return head;\r\n    }\r\n    let next = head.next;\r\n    head.next = swapPairs(next.next);\r\n    next.next = head;\r\n    return next;\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440218278","body":"## 链表值入栈，再通过递归构建二叉树\n```javascript\n\nfunction ListNode(val, next) {\n    this.val = (val===undefined ? 0 : val)\n    this.next = (next===undefined ? null : next)\n}\n\nfunction TreeNode(val, left, right) {\n    this.val = (val===undefined ? 0 : val)\n    this.left = (left===undefined ? null : left)\n    this.right = (right===undefined ? null : right)\n}\n\nvar sortedListToBST = function(head) {\n    if (!head) return null\n    const arr = []\n    while(head) {\n        arr.push(head.val)\n        head = head.next\n    }\n    const dfs = (arr) => {\n        if (!arr.length) return null\n        const middle = parseInt(arr.length / 2),\n              leftArr = arr.slice(0, middle),\n              rightArr = arr.slice(middle + 1)\n        const treeNode = new TreeNode(arr[middle])\n        treeNode.left = dfs(leftArr)\n        treeNode.right = dfs(rightArr)\n        return treeNode\n    }\n    return dfs(arr)\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dinjufen":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429850830","body":"思路：令t = k，从num的末位开始累加，边加边将t的末位放入列表，以免t太大超出限制。加完后再依次添加num剩余的数，最后得到结果\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int t = k;\n        int i = 0;\n        vector<int> res;\n        while (t) {\n            if (i < num.size()) {\n                t += num[num.size() - i - 1];\n                i++;\n            }\n            res.push_back(t % 10);\n            t /= 10;\n        }\n        while (i < num.size()) {\n            res.push_back(num[num.size() - i - 1]);\n            i++;\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437706920","body":"思路：先将链表连接成环，再根据需要的距离进行断开，返回新的头节点即可\n\n代码：\n```C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (k == 0 || !head || !head->next) return head;\n        int length = 1;\n        ListNode* tmp = head;\n        while (tmp->next) {\n            length++;\n            tmp = tmp->next;\n        }\n        int add = length - k % length;\n        if (add == length) return head;\n        tmp->next = head;\n        while (add--) {\n            tmp = tmp->next;\n        }\n        ListNode* next = tmp->next;\n        tmp->next = nullptr;\n        return next;\n    }\n};\n```\n时间复杂度： O(n)\n空间复杂度: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437698328","body":"思路：递归，递归首先要知道最小步骤是什么，在这里最小步骤是两两交换节点，然后交换后的第二个节点指向下一次递归的返回值\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (head == nullptr || head->next == nullptr) {\r\n            return head;\r\n        }\r\n        ListNode* next = head->next;\r\n        head->next = swapPairs(next->next);\r\n        next->next = head;\r\n        return next;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441052202","body":"思路：先通过一次遍历找出A和B的长度差，第二次遍历，长的链表先走完差值，再一起走，第一次相遇时即为交叉点\n\n代码：\n```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* moveA = headA, *moveB = headB;\n        \n        while (moveA && moveB) {\n                moveA = moveA->next;\n                moveB = moveB->next;\n        }\n        int minusAB = 0, minusBA = 0;\n        while (moveA) {\n            moveA = moveA->next;\n            minusAB++;\n        }\n        while (moveB) {\n            moveB = moveB->next;\n            minusBA++;\n        }\n        moveA = headA;\n        moveB = headB;\n        while(minusAB--) {\n            moveA = moveA->next;\n        }\n        while (minusBA--) {\n            moveB = moveB->next;\n        }\n        while (moveA && moveB && moveA != moveB) {\n            moveA = moveA->next;\n            moveB = moveB->next;\n        }\n        return moveA;\n    }\n};\n```\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzmt":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429857608","body":"### 思路\n从低位相加，每次将所得之和的个位数push进arr数组, 再将和除以10之后取整，与数组的倒数第二位再相加，以此循环\n### 代码\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const arr = [];\n    let _k = k;\n    let i = num.length - 1;\n    while (i >= 0 || _k > 0) {\n        if (i >= 0) {\n            _k += num[i];\n            i--;\n        }\n        arr.push(_k % 10);\n        _k = parseInt(_k / 10);\n    }\n    return arr.reverse();\n};\n```\n### 复杂度分析\n- 时间复杂度O(n)\n- 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431399034","body":"### 思路\n拿到每一个字符到目标字符的距离，然后再取出最短距离\n### 代码\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    var len = s.length;\n    var res = [];\n    for (var i = 0; i < len; i++) {\n        var distance = [];\n        for (var n = 0; n < len; n++) {\n            if (s[n] === c) {\n                distance.push(Math.abs(i - n));\n            }\n        }\n        res.push(Math.min(...distance))\n    }\n    return res;\n};\n```\n### 复杂度\n- 时间复杂度 O(n^2)\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433164917","body":"### 思路\n- 构造函数主要就是初始化两个值；\n- push在数组最后添加一个元素；\n- pop把数组最后一个元素删除，并返回删除的值即可；\n- increment确定好循环次数\n### 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = [];\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack?.length < this.maxSize) {\n        this.stack = [...this.stack, x]\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    const len = this.stack.length;\n    const lastVal = this.stack[len - 1];\n    this.stack.splice(len - 1, 1)\n    return lastVal || -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const len = this.stack.length > k ? k : this.stack.length;\n    for(let i = 0; i < len; i++) {\n        this.stack[i] += val;\n    }\n};\n```\n### 复杂度\n- 时间复杂度\n  - 初始化, push, pop为O(1)\n  - increment 为O(k)\n- 空间复杂度 O(maxSize)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438467968","body":"### 思路\n使用递归，注意留口子结束递归\n### 代码\n```js\nvar swapPairs = function(head) {\n    if(!head || !head.next){\n        return head\n    }\n\n    const curHead = head.next;\n    head.next = swapPairs(curHead.next);\n    curHead.next = head;\n    return curHead;\n};\n```\n### 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"munmust":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429862730","body":"### 思路\n1,将k也转化为数组\n2，将两个数组从最后开始相加\n3，通过和得出carry（是否进位），和当前位数的值\n4，最后判断是否有carry，在添加到结果数组里\n5，反转数组得到结果\n\n### 代码\n\n``` javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n    const result = [];\n    let i = num.length - 1;\n    const kArr = `${k}`.split('').map(v => Number(v));\n    let j = kArr.length - 1;\n    let carry = 0;\n    while (i >= 0 || j >= 0) {\n        const sumVal = (num?.[i] || 0) + (kArr?.[j] || 0) + carry;\n        const val = Math.floor(sumVal % 10);\n        carry = Math.floor(sumVal / 10);\n        result.push(val);\n        i--;\n        j--;\n    }\n    if (!!carry) {\n        result.push(carry)\n    }\n    return result.reverse();\n};\n```\n\n### 复杂度\n空间复杂度 O(n)\n时间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431439401","body":"### 思路\n1，得到各个指定字符的位置\n2，遍历字符串，遍历得到的位置的数组\n3，进行两个位置的相减，取最小正整数返回\n### 代码\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n    const sArr = s.split('');\n    const cResult = [];\n\n    sArr.forEach((sItem, index) => {\n        if (sItem === c) {\n            cResult.push(index);\n        }\n    })\n    const result = sArr.map((v, index) => {\n        let min = s.length;\n        cResult.forEach(value => {\n            const nowMin = Math.abs(value - index)\n            min = min < nowMin ? min : nowMin\n        })\n        return min\n    })\n    return result\n};\n\n### 时间复杂度 O(n^2)\n### 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433348222","body":"``` javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n    this.stack = [];\r\n    this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n    if (this.stack.length < this.maxSize) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n    if (this.stack.length === 0) {\r\n        return -1;\r\n    }\r\n    return this.stack.pop();\r\n\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n    let len = Math.min(k, this.stack.length);  //取交集，前n个元素+val\r\n    for (let i = 0; i < len; i++) {\r\n        this.stack[i] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434864272","body":"``` javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s) {\r\n    let numStack = [];\r\n    let strStack = [];\r\n    let num = 0;\r\n    let result = '';\r\n    for (const char of s) {\r\n        if (!isNaN(char)) {\r\n            num = num * 10 + Number(char);\r\n        } else if (char == '[') {\r\n            strStack.push(result);\r\n            result = '';\r\n            numStack.push(num);\r\n            num = 0;\r\n        } else if (char == ']') {\r\n            let repeatTimes = numStack.pop();\r\n            result = strStack.pop() + result.repeat(repeatTimes);\r\n        } else {\r\n            result += char;\r\n        }\r\n    }\r\n    return result;\r\n\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435705721","body":"```jabascript\r\n// 使用两个数组的栈方法（push, pop） 实现队列\r\n/**\r\n* Initialize your data structure here.\r\n*/\r\nvar MyQueue = function() {\r\n   this.stackIn = [];\r\n   this.stackOut = [];\r\n};\r\n\r\n/**\r\n* Push element x to the back of queue. \r\n* @param {number} x\r\n* @return {void}\r\n*/\r\nMyQueue.prototype.push = function(x) {\r\n   this.stackIn.push(x);\r\n};\r\n\r\n/**\r\n* Removes the element from in front of queue and returns that element.\r\n* @return {number}\r\n*/\r\nMyQueue.prototype.pop = function() {\r\n   const size = this.stackOut.length;\r\n   if(size) {\r\n       return this.stackOut.pop();\r\n   }\r\n   while(this.stackIn.length) {\r\n       this.stackOut.push(this.stackIn.pop());\r\n   }\r\n   return this.stackOut.pop();\r\n};\r\n\r\n/**\r\n* Get the front element.\r\n* @return {number}\r\n*/\r\nMyQueue.prototype.peek = function() {\r\n   const x = this.pop();\r\n   this.stackOut.push(x);\r\n   return x;\r\n};\r\n\r\n/**\r\n* Returns whether the queue is empty.\r\n* @return {boolean}\r\n*/\r\nMyQueue.prototype.empty = function() {\r\n   return !this.stackIn.length && !this.stackOut.length\r\n};\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436022969","body":"``` javascript\n  const stack = [];\n  for (let i = 0; i < arr.length; i++) {\n    a = arr[i];\n    if (stack.length > 0 && stack[stack.length - 1] > a) {\n      const cVal = stack[stack.length - 1];\n      while (stack && stack[stack.length - 1] > a) {\n          stack.pop();\n     }\n      stack.push(cVal);\n    } else {\n      stack.push(a);\n    }\n  }\n  return stack.length;\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437091313","body":"```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n    if (head == null || k == 0) return head;\n    let n = 0;\n    let tail = null;\n    for (let p = head; p != null; p = p.next) {\n        tail = p;\n        n++;\n    }\n    k %= n;\n    let p = head;\n    for (let i = 0; i < n - k - 1; i++) p = p.next;\n    tail.next = head;\n    head = p.next;\n    p.next = null;\n    return head;\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438681127","body":"```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function (head) {\n    if (head == null || head.next == null) {\n        return head;\n    }\n    let stack = [];\n    let p = new ListNode(-1);\n    let cur = head;\n    head = p;\n    while (cur != null && cur.next != null) {\n        stack.push(cur);\n        stack.push(cur.next);\n        cur = cur.next.next;\n        p.next = stack.pop();\n        p = p.next;\n        p.next = stack.pop();\n        p = p.next;\n    }\n    if (cur != null) {\n        p.next = cur;\n    } else {\n        p.next = null;\n    }\n    return head.next;\n\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440236978","body":"```jaavascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nconst sortedListToBST = (head) => {\n    if (head == null) return null;\n    let slow = head;\n    let fast = head;\n    let preSlow;\n\n    while (fast && fast.next) {\n        preSlow = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    const root = new TreeNode(slow.val);\n\n    if (preSlow != null) {\n        preSlow.next = null;\n        root.left = sortedListToBST(head);\n    }\n    root.right = sortedListToBST(slow.next);\n    return root;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yan-jie":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429866566","body":"```javascript\nvar addToArrayForm = function(num, k) {\n\n    let result = [];\n    const numberLen = num.length;\n    let reducedK = k;\n    let carry = 0;\n\n    for(let i = numberLen - 1; ; i--){\n        if(num[i] === undefined && reducedK === 0 && carry === 0){\n            break;\n        }\n        const lastInNum = num[i] === undefined ? 0 : num[i];\n        const lastInK = reducedK === 0 ? 0 : reducedK % 10;\n        reducedK = Math.floor(reducedK / 10);\n        const sum = lastInNum + lastInK + carry;\n        const validSum = sum >= 10 ? sum - 10 : sum;\n        carry = sum >= 10 ? 1 : 0\n        result.unshift(validSum);\n    }\n\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431456161","body":"```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    const result = [];\n    const len = s.length;\n    let lastPosition = -1;\n    for(let i = 0; i < len; i++){\n        if(s[i] === c){\n            if(lastPosition === -1){\n                lastPosition = i;\n            }\n            for(let j = 0; j <= i; j++){\n                const oldDistance = result[j];\n\n                const d1 = Math.abs(lastPosition - j);\n                const d2 = Math.abs(i - j)\n                const minDistance = Math.min(d1, d2)\n\n                if(oldDistance === undefined){\n                    result[j] = minDistance\n                }else{\n                    result[j] = Math.min(oldDistance, minDistance)\n                }\n            }\n            lastPosition = i;\n        }\n    }\n\n    // 补充\n    if(lastPosition < len - 1){\n        for(let i = lastPosition; i < len; i++){\n            result[i] = Math.abs(lastPosition - i)\n        }\n    }\n\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432866073","body":"```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.data = new Array(maxSize).fill(null);\n    this.index = -1;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.index < this.maxSize - 1){\n        this.data[this.index + 1] = x;\n        this.index++;\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.index === -1){\n        return -1\n    }\n    const res = this.data[this.index];\n    this.data[this.index] = null;\n    this.index = this.index - 1;\n    return res;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(this.index === -1) return;\n    const loopNumber = Math.min(k, this.index + 1)\n    for(let i = 0; i < loopNumber; i++){\n        this.data[i] = this.data[i] + val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434712099","body":"```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    \n    const resultStack = new Array;\n    for(let i = 0; i < s.length; i++){\n        let tmp = s[i];\n        if(tmp !== ']'){\n            resultStack.push(tmp)\n        } else {\n            let chars = ''\n            while(true){\n                const poped = resultStack.pop();\n                if(poped === '['){\n                    break;\n                } else if(/[a-z]/.test(poped)){\n                    chars = poped + chars;\n                }\n            }\n\n            let repeatNumStr = ''\n            while(true){\n                let popedNum = resultStack.pop();\n                if(/\\d/.test(popedNum)){\n                    repeatNumStr = popedNum + repeatNumStr;\n                }else{\n                    resultStack.push(popedNum);\n                    break;\n                }\n            }\n\n            const repeatNum = Number(repeatNumStr);\n            for(let j = 0; j < repeatNum; j++){\n                for(let c of chars){\n                    resultStack.push(c);\n                }\n            }\n        }\n    }\n\n    return resultStack.join('')\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435699161","body":"```javascript\nvar MyQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\n\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x);\n};\n\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack.pop();\n};\n\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack[this.outStack.length - 1];\n};\n\nMyQueue.prototype.empty = function() {\n    return this.outStack.length === 0 && this.inStack.length === 0;\n};\n\nMyQueue.prototype.in2out = function() {\n    while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop());\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437867577","body":"```javascript\nvar swapPairs = function(head) {\n    if(head === null || head.next === null){\n        return head;\n    }\n    const newHead = head.next;\n    head.next = swapPairs(head.next.next);\n    newHead.next = head;\n    return newHead;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hktangshuo":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429871860","body":"有bug\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length - 1;\n        LinkedList<Integer> res = new LinkedList<>();\n\n        int c = k;\n        while (n >= 0) {\n            int tmp = num[n]+c;\n\n            res.addFirst(tmp%10);\n            c=tmp/10;\n\n            n--;\n        };\n        while (c!=0){\n            res.addFirst(c);\n\n            c=c/10;\n\n        }\n\n        return res;\n    }\n\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpbc007":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429891929","body":"# 思路\n- k % 10 得到当前位的数值\n- Math.floor(k / 10 ) 得到向上一位的值\n- 将 k 直接加到数组最后一位，并不断向上进位，直到数组遍历完毕 & k 为0\n\n# 代码\nfunction addToArrayForm(num: number[], k: number): number[] {\n    const result: number[] = []\n    \n    for (let index = num.length - 1; index >= 0 || k > 0;index--, k = Math.floor(k / 10)) {\n        if (index >= 0) {\n            k += num[index]\n        }\n        \n        result.unshift(k%10)\n    }\n    \n    return result\n};\n\n# 复杂度分析\n时间复杂度：O（Max(num.length,k))\n空间复杂度：O（num.length)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431481273","body":"# 思路\n正序遍历数组，得到距离左侧节点的距离，逆序遍历数组，得到距离右侧节点的距离\n\n# 代码\n```ts\nfunction shortestToChar(s: string, c: string): number[] {\n    const result: number[] = []\n\n    let lastIndex = -1\n    for (let index = 0; index < s.length ; index++) {\n        const char = s[index]\n\n        if (char === c) {\n            lastIndex = index\n        }\n\n        result[index] = lastIndex === -1 ? s.length : index - lastIndex\n    }\n\n    lastIndex = -1\n    for (let index = s.length - 1; index >= 0; index--) {\n        const char = s[index]\n\n        if (char === c) {\n            lastIndex = index\n        }\n\n        result[index] = lastIndex === -1 ? result[index] : (result[index] < lastIndex - index ? result[index] : lastIndex - index)\n    }\n    return result\n};\n```\n\n# 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433298451","body":"# 思路\n一个 stack 维护原始数据，一个 stack 维护后续每个元素增加的值。在 pop 的时候再把值加上\n\n# 代码\nclass CustomStack {\n    // 存放数据\n    private dataArr: number[] = []\n\n    // 存放每次增加的值\n    private incrementVal: number[] = []\n\n    // 栈顶指针\n    private topIndex = -1\n\n    constructor(private maxSize: number) {}\n\n    push(x: number): void {\n        if (this.topIndex < this.maxSize - 1) {\n            this.dataArr[++this.topIndex] = x\n        }\n    }\n\n    pop(): number {\n        if (this.topIndex === -1) {\n            return -1\n        }\n\n        const result = this.dataArr[this.topIndex] + (this.incrementVal[this.topIndex] ? this.incrementVal[this.topIndex] : 0)\n        this.dataArr[this.topIndex] = 0\n        this.incrementVal[this.topIndex] = 0\n        this.topIndex--\n\n        return result\n    }\n\n    increment(k: number, val: number): void {\n        const maxIndex = Math.min(k, this.topIndex + 1)\n\n        for (let i = 0; i < maxIndex; i++) {\n            this.incrementVal[i] = this.incrementVal[i] ? this.incrementVal[i] + val : val\n        }\n    }\n}\n\n# 复杂度\n时间复杂度：\n- pop O(1)\n- increment O(1)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434700825","body":"# 思路\r\n遇到非 ']' 都入栈，遇到 ']' 出栈。出栈的时候向前解析数字\r\n\r\n# 代码\r\n```ts\r\nexport function decodeString(s: string): string {\r\n    const stack: string[] = []\r\n\r\n    for (let c of s) {\r\n        if (c !== ']') {\r\n            stack.push(c)\r\n        } else {\r\n            let tmpStr = ''\r\n            while(true) {\r\n                const stackChar = stack.pop()\r\n                \r\n                if (stackChar !== '[') {\r\n                    tmpStr = stackChar + tmpStr\r\n                } else {\r\n                    let stackNumStr = ''\r\n\r\n                    while(true) {\r\n                        const stackNumChar = stack.pop()\r\n                        const stackNum = Number(stackNumChar)\r\n\r\n                        // 取出的是数字，添加到数字字符串中\r\n                        if (!Number.isNaN(stackNum)) {\r\n                            stackNumStr = stackNumChar + stackNumStr\r\n                        } else { // 不是数字，说明数字到头了，把多取出来的再放回去\r\n                            stack.push(stackNumChar!)\r\n                            stack.push(tmpStr.repeat(Number(stackNumStr)))\r\n\r\n                            break\r\n                        }\r\n\r\n                        // stack 已经空了，开始计算\r\n                        if (stack.length === 0) {\r\n                            stack.push(tmpStr.repeat(Number(stackNumStr)))\r\n\r\n                            break\r\n                        }\r\n                    }\r\n\r\n                    break\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    return stack.join('')\r\n};\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(N) 原数组所有字母入栈，再出栈一次\r\n空间复杂度：O(N) 使用栈存储原有字符串","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435520184","body":"## 思路\r\n\r\n队列：先入先出\r\n栈：先入后出\r\n为了能快速的从栈中读取栈底的值，可以使用两个栈：\r\n- 一个栈用于插入数据\r\n- 一个栈用于读取数据\r\n当读取数据栈为空时，从插入数据栈中把所有数据再导入到读取数据栈，这样原始数据经过两次 `先入后出` 就变成了 `先入先出`\r\n\r\n## 代码\r\n\r\n```ts\r\n// push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\nclass MyStack<T> {\r\n    private valueContainer: T[] = []\r\n\r\n    push(val: T) {\r\n        this.valueContainer.push(val)\r\n    }\r\n\r\n    pop(): T | undefined {\r\n        return this.valueContainer.pop()\r\n    }\r\n\r\n    peek(): T | undefined {\r\n        return this.valueContainer[this.valueContainer.length - 1]\r\n    }\r\n\r\n    size(): number {\r\n        return this.valueContainer.length\r\n    }\r\n\r\n    isEmpty(): boolean {\r\n        return this.valueContainer.length === 0\r\n    }\r\n}\r\n\r\nexport class MyQueue {\r\n    // 插入数据\r\n    private insertStack = new MyStack<number>()\r\n    // 读取数据\r\n    private readStack = new MyStack<number>()\r\n\r\n    constructor() {}\r\n\r\n    push(x: number): void {\r\n        this.insertStack.push(x)\r\n    }\r\n\r\n    pop(): number {\r\n        if (!this.readStack.isEmpty()) {\r\n            return this.readStack.pop()!\r\n        }\r\n\r\n        if (!this.insertStack.isEmpty()) {\r\n            this.insert2Read()\r\n\r\n            return this.readStack.pop()!\r\n        }\r\n\r\n        return -1\r\n    }\r\n\r\n    peek(): number {\r\n        if (!this.readStack.isEmpty()) {\r\n            return this.readStack.peek()!\r\n        }\r\n\r\n        if (!this.insertStack.isEmpty()) {\r\n            this.insert2Read()\r\n\r\n            return this.readStack.peek()!\r\n        }\r\n\r\n        return -1\r\n    }\r\n\r\n    empty(): boolean {\r\n        return this.readStack.isEmpty() && this.insertStack.isEmpty()\r\n    }\r\n\r\n    private insert2Read() {\r\n        while(!this.insertStack.isEmpty()) {\r\n            this.readStack.push(this.insertStack.pop()!)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n### 时间复杂度\r\n- push、empty: O(1)\r\n- pop、peek: O(1) （每个元素只会在两个栈中各出现一次）\r\n\r\n### 空间复杂度\r\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436006081","body":"# 解法1\r\n## 思路\r\n观察排序后的数组，和被分隔后的数组。每块被分隔后的数组中各个数字出现的频次，和排序后的数组一定是一致的。\r\n因此再排序数组中，每个数字出现其频次 `+1`，在原始数组中每个数字出现其频次 `-1`，如果出现各个数字的频次都为 0 时，则说明此时可以进行一次分割\r\n\r\n## 代码\r\n```ts \r\nfunction maxChunksToSorted(arr: number[]): number {\r\n    // 排序后的数组\r\n    const sortedArr = [...arr].sort((a, b) => a - b)\r\n    const map = new Map<number, number>()\r\n    let result = 0\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        const sortedNum = sortedArr[i]\r\n        const num = arr[i]\r\n\r\n        // 在排序数组中出现，频次 +1\r\n        map.set(sortedNum, (map.get(sortedNum) || 0) + 1)\r\n        if (map.get(sortedNum) === 0) {\r\n            map.delete(sortedNum)\r\n        } \r\n\r\n        // 在原始数组中出现，频次 -1\r\n        map.set(num, (map.get(num) || 0) - 1)\r\n        if (map.get(num) === 0) {\r\n            map.delete(num)\r\n        }\r\n\r\n        // 频次相等，可以分隔\r\n        if (map.size === 0) {\r\n            result++\r\n        }\r\n    }\r\n\r\n    return result\r\n};\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：数组的排序 O(NlogN)\r\n空间复杂度：多了一个排序数组 O(N)\r\n\r\n# 解法2\r\n## 思路\r\n假设当前已经有了几个块，当加入新的数字后，可能会出现以下情况\r\n- 新增数字大于最后一个块的最大值，则最后加入的数字自己可以成为新的区块\r\n- 新增数字小于最后一个块的最大值，则需要将后面的区块融合，直到加入的数字大于前一个区块的最大值，或者只剩最后一个区块了\r\n\r\n## 代码\r\n```ts\r\nclass MyStack {\r\n    private val: number[] = []\r\n\r\n    isEmpty() {\r\n        return this.val.length === 0\r\n    }\r\n\r\n    peek() {\r\n        return this.isEmpty() ? 0 : this.val[this.val.length - 1]\r\n    }\r\n\r\n    pop() {\r\n        return this.isEmpty() ? 0 : this.val.pop()!\r\n    }\r\n\r\n    push(val: number) {\r\n        this.val.push(val)\r\n    }\r\n\r\n    size() {\r\n        return this.val.length\r\n    }\r\n}\r\n\r\nfunction maxChunksToSorted(arr: number[]): number {\r\n    return arr.reduce((stack, item) => {\r\n        if (!stack.isEmpty() && item < stack.peek()) {\r\n            const max = stack.pop()\r\n            while(!stack.isEmpty() && item < stack.peek()) {\r\n                stack.pop()\r\n            }\r\n\r\n            stack.push(max)\r\n        } else {\r\n            stack.push(item)\r\n        }\r\n\r\n        return stack\r\n    }, new MyStack()).size()\r\n}\r\n```\r\n## 复杂度\r\n时间复杂度：数组遍历一次 O(N)\r\n空间复杂度：多了一个栈存储最大值 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437047730","body":"# 思路\n快慢指针，先让头指针移动 K 次，然后头尾指针同时移动，直到头指针移动到链表尾部。\n此时让头节点指向链表的头，尾结点的下个节点作为新链表的头结点，并将尾结点清空。\n\n# 代码\n```ts\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n    if (!head || head.next == null) {\n        return head\n    }\n\n    let first: ListNode | null = head\n    let last: ListNode | null = head\n    let step = 0\n\n    // 第一个指针先移动 K \n    let index = 0\n    while (index < k) {\n        first = move2Next({cur: first, head})\n\n        index++\n    }\n\n\n    while (first.next !== null) {\n        first = move2Next({cur: first, head})\n        last = move2Next({cur: last, head})\n        \n        step++\n    }\n\n    first.next = head\n    const newHead = last!.next\n    last!.next = null\n\n    return newHead\n};\n\n/**\n * 考虑循环移动的场景\n */\nfunction move2Next({ cur, head }: { cur: ListNode, head: ListNode }) {\n    if (cur.next) {\n        return cur.next\n    }\n\n    return head\n}\n```\n# 复杂度分析\n- 时间复杂度：整个链表遍历一次 O(N)\n- 空间复杂度：无额外开销 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437761954","body":"# 解法 1\n\n递归\n\n## 思路\n\n第一个节点 -> 第二个节点\n\n1. 用临时变量存储第二个节点\n2. 让第一个节点指向交换后的第二个节点的下一个节点（递归）\n3. 第二个节点指向第一个节点\n\n## 代码\n\n```ts\nfunction swapPairs(head: ListNode | null): ListNode | null {\n    // 头结点不存在 | 只有一个节点\n    if (!head || !head.next) {\n        return head\n    }\n\n    let tmp: ListNode | null = null\n\n    tmp = head.next\n    head.next = swapPairs(head.next.next)\n    tmp.next = head\n\n    return tmp\n}\n```\n\n## 复杂度\n\n-   空间复杂度：O(1)\n-   时间复杂度：O(N) 整个链表遍历一遍\n\n# 解法 2\n\n循环\n\n## 思路\n\n1. pre 存储当前头结点的上一个节点\n2. 正常交换节点\n3. 如果有 pre 更新下 pre 的指向\n4. 头节点移动到下个位置\n\n## 代码\n\n```ts\nfunction swapPairs(head: ListNode | null): ListNode | null {\n    if (!head || !head.next) {\n        return head\n    }\n    let tmp: ListNode | null = null\n    let newHead: ListNode | null = null\n    let pre: ListNode | null = null\n\n    while (head && head.next) {\n        // 两两交换\n        tmp = head.next\n        head.next = head.next.next\n        tmp.next = head\n\n        if (pre) {\n            pre.next = tmp\n        }\n        // 移动到下个位置\n        head = tmp.next.next\n        pre = tmp.next\n        if (!newHead) {\n            newHead = tmp\n        }\n    }\n\n    return newHead\n}\n```\n\n## 复杂度\n\n-   空间复杂度：O(1)\n-   时间复杂度：O(N) 整个链表遍历一遍\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440253529","body":"## 思路\n\n链表的顺序，与中序遍历的输出顺序是一致的。基于此按照中序遍历创建一棵树，并不断填值，就能得到想要的结果了\n\n## 代码\n```ts\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    if (!head) {\n        return null\n    }\n\n    const len = getListLen(head)\n\n    function buildBSTFromList(start: number, end: number): TreeNode | null {\n        if (end <= start) {\n            return null\n        }\n\n        const mid = (start + end) >>> 1\n        const leftNode = buildBSTFromList(start, mid)\n        const root = new TreeNode(head!.val)\n        head = head!.next\n        const rightNode = buildBSTFromList(mid + 1, end)\n\n        root.left = leftNode\n        root.right = rightNode\n\n        return root\n    }\n\n    return buildBSTFromList(0, len)\n}\n\n/** 获取链表长度 */\nfunction getListLen(head: ListNode | null) {\n    let len = 0\n\n    while (head) {\n        len++\n        head = head.next\n    }\n\n    return len\n}\n\n```\n\n## 复杂度分析\n- 时间复杂度: O(N)\n- 空间复杂度: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linlizzz":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429896683","body":"### 思路\n1.将K转换成数组形式\n\n2.将数组A和K的元素依次倒叙相加，顺序记入新数组，大于9的结果记1，加入下一次计算\n\n3.将得到的数组进行元素倒序排序，得到最终结果\n\n### 代码\n```python\nimport numpy as np\n\ndef add(A, K):\n    K_list = []\n    while(K//10 != 0):\n        K_list.append(K%10)\n        K = K//10\n    K_list.append(K%10) # 将K倒序存成列表\n    print(K_list)\n    res = []\n    up = 0\n    diff = abs(A.shape[0] - len(K_list))\n    for i in range(min(len(K_list), A.shape[0])):\n        res.append((K_list[i] + A[-1-i])%10 + up)\n        print(res)\n        if (K_list[i] + A[-1-i])//10 == 1:\n            up = 1\n        else:\n            up = 0\n    if A.shape[0] > len(K_list):\n        for j in range(diff):\n            res.append(A[-2-i-j] + up)\n            if (A[-2-i-j] + up)//10 == 1:\n                up = 1\n            else:\n                up = 0\n            print(res)\n    elif A.shape[0] < len(K_list):\n        for j in range(diff):\n            res.append(K_list[i+j+1] + up)\n            if (K_list[i+j+1] + up)//10 == 1:\n                up = 1\n            else:\n                up = 0\n            print(res)\n    res.reverse()\n    res = np.array(res)\n    return res\n```\n### 时间复杂度\nT(n)=O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431529057","body":"### 思路\n1.取出字符c在字符串s中出现的所有下标值，存于列表pos\n\n2.比较每个位置下标值与pos中所有值的差绝对值，取最小数，作为该位置的最短距离值，存于输出结果列表的相应位置\n\n### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pos = []\n        res = []\n        for i in range(len(s)):\n            if c == s[i]:\n                pos.append(i)\n\n        for j in range(len(s)):\n            t = len(s)\n            for i in pos:\n                t = min(abs(j-i), t)\n            res.append(t)\n        \n        return res\n```\n### 复杂度分析\nT(n) = n^2\n\nS(n) = n\n\nn=len(s)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433291470","body":"### 思路\n\n1.利用列表构建栈，列表长度为maxSize，设计指针变量指向栈顶之后一个元素。\n\n2.push时，先判断列表是否已满，未满则加入指针变量指向元素位置，指针变量上移。\n\n3.pop时，先判断列表是否为空，非空则指针变量下移，取出该元素值，并将该元素清空。\n\n4.increment时，取k和指针变量较小者，遍历加入val值。\n\n### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = [None]*maxSize\n        self.size = maxSize\n        self.point = 0\n\n    def push(self, x: int) -> None:\n        if self.point == self.size:\n            pass\n        else:\n            self.stack[self.point] = x\n            self.point += 1\n\n    def pop(self) -> int:\n        if self.point == 0:\n            res = -1\n        else:\n            self.point -= 1\n            res = self.stack[self.point]\n            self.stack[self.point] = None\n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i < self.point:\n                self.stack[i] += val\n            else:\n                break\n```\n### 复杂度分析\nincrement时，T(n)=O(n),n为栈的maxSize\n其余T(n)=O(1)\nS(n)=O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434822171","body":"Day 4 17/02/2023\n\n### 思路\n\n1.构建栈，遇到左括号存入之前的数字n以及之前的字符str\n\n2.遇到右括号，弹出栈顶元素，str=str+n\\*两括号之间的字符\n\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = ''\n        n = 0\n        for i in range(len(s)):\n            if s[i].isdigit():\n                n = n*10 + int(s[i])\n                print(n)\n            elif s[i] == '[':\n                stack.append((n, res))\n                print(stack)\n                res = ''\n                n = 0\n            elif s[i] == ']':\n                print(stack)\n                pre = stack.pop()\n                print(pre)\n                res = pre[1] + pre[0]*res\n            else:\n                res += s[i]\n                print(res)\n        print(res)\n        return res\n```\n### 复杂度分析\nT(n)=O(n) n为输入str长度\n\nS(n)=O(k) k为输出str长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435674473","body":"### 思路\n\n1. 初始化一个列表作为栈\n\n2.push直接append；pop时另新建一个列表，倒序存放原列表元素，.pop()出后再重新倒序放入原列表；peek取第一个元素，empty查看列表是否为空\n\n### 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n\n\n    def pop(self) -> int:\n        self.stack_inv = []\n        for i in self.stack[::-1]:\n            self.stack_inv.append(i)\n        res = self.stack_inv.pop()\n        self.stack = []\n        for j in self.stack_inv[::-1]:\n            self.stack.append(j)\n        return res\n\n\n    def peek(self) -> int:\n        res = self.stack[0]\n        return res\n\n\n    def empty(self) -> bool:\n        if self.stack:\n            return False\n        else:\n            return True\n```\n### 复杂度分析\n\nT(n)=O(n) n为栈的大小\n\nS(n)=O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435983034","body":"### 思路\n\n从前往后遍历数组中元素，若前面元素子集中最大值小于等于后面元素子集中最小值，则分块。\n\n### 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        res = 0\n        j = 0\n        for i in range(1, len(arr)):\n            if max(arr[j:i]) <= min(arr[i:]):\n                res += 1\n                j =i\n        res += 1\n        return res\n```\n### 复杂度分析\nT(n)=O(n) n为输入数组长度\n\nS(n)=O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437279024","body":"### 思路\n\n先把链表首尾相连，再找到位置断开循环\n\n### 代码\n```python\nclass Solution(object):\n    def rotateRight(self, head, k):\n        if head is None or head.next is None: return head\n        start, end, len = head, None, 0\n        while head:\n            end = head\n            head = head.next\n            len += 1\n        end.next = start\n        pos = len - k % len\n        while pos > 1:\n            start = start.next\n            pos -= 1\n        ret = start.next\n        start.next = None\n        return ret\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440268104","body":"###思路\n\n1.当head==None或者head.next==None时直接输出相应的res\n\n2.设置三个指针，point_2每次循环走两步，point_1每次循环走一步，point_pre每次循环指向point_1的前一个\n\n3.当point_2走到底或剩一个时，point_1正好走到链表中间作为当前树的根节点，用point_pre把原链表断开，以point_1为界，分为前后两个子链表作为当前树的根节点的左右子节点，分别返回2递归循环该函数\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        res = TreeNode()\n        if head == None:\n            res = None\n        elif head.next == None:\n            res.val = head.val\n        else:\n            point_pre = head\n            point_1 = head\n            point_2 = head\n            while point_2 and point_2.next:\n                point_pre = point_1\n                point_1 = point_1.next\n                point_2 = point_2.next.next\n            point_pre.next = None # split the link list\n            res.val = point_1.val\n            res.left = self.sortedListToBST(head)\n            res.right = self.sortedListToBST(point_1.next)\n        return res\n```\n\n### 复杂度分析\n\nT(n) = O(n)\n\nS(n) = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441368752","body":"### 思路\n\n1. 取point_a和point_b分别指向headA和headB的头，依次向后移动\n\n2. 若两指针分别走完各自的链表，则重定向到对方链表的头，继续依次向后移动\n\n3. 相等时退出循环返回该节点，存在或两个链表一起走完时等于None，则不存在相同节点\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        point_a = headA\n        point_b = headB\n        while point_a != point_b:\n            point_a = point_a.next if point_a else headB\n            point_b = point_b.next if point_b else headA\n        return point_a\n```\n\n### 复杂度分析\n\nT(n) = O(m+n), m和n分别为headA和headB的长度\n\nS(n) = O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"krabbejing":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429898395","body":"\n    class Solution:\n        def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n            i = len(num)-1\n            while k:\n                num[i] += k\n                k, num[i] = num[i] // 10, num[i] % 10\n                i -= 1\n                if i < 0 and k > 0:\n                    i = 0\n                    num.insert(0,0)\n            return num\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431543980","body":"    class Solution:\n        def shortestToChar(self, s: str, c: str) -> List[int]:\n            length = len(s)\n            res = [0 if s[i] == c else None for i in range(length)]\n            # left to right\n            for i in range(1, length):\n                if res[i] != 0 and res[i-1] is not None:\n                    res[i] = res[i-1] + 1\n            # right to left\n            for i in range(length-2, -1, -1):\n                if res[i] is None or res[i+1] + 1 < res[i]:\n                    res[i] =  res[i+1] + 1\n            return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433234776","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.currentSize = 0\n        self.storage = []\n\n    def push(self, x: int) -> None:\n        if self.currentSize < self.maxSize:\n            self.storage.append(x)\n            self.currentSize+=1\n\n    def pop(self) -> int:\n        if self.currentSize == 0:\n            return -1\n        self.currentSize-=1\n        return self.storage.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        incre_num = min(k, self.currentSize)\n        for i in range(incre_num):\n            self.storage[i] += val\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437174466","body":"```py\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        cur1 = head\n        tail = head\n        if head is None or head.next is None:\n            return head\n        length = 1\n        while tail.next is not None:\n            length += 1\n            tail = tail.next\n        \n        # new k\n        k = k % length\n        if k == 0:\n            return head\n        tail.next = cur1\n        step = 1\n        while step != length-k:\n            cur1 = cur1.next\n            step += 1\n        \n        head = cur1.next\n        cur1.next = None\n        return head\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438416752","body":"```py\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None or head.next is None:\n            return head\n        fake_head = ListNode()\n        fake_head.next = head\n        temp = fake_head\n\n        while temp.next and temp.next.next:\n            p1 = temp.next\n            p2 = temp.next.next\n            temp.next = p2\n            p1.next = p2.next\n            p2.next = p1\n            temp = p1\n\n        return fake_head.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439375918","body":"```py\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def findMedian(left, right):\n            slow, fast = left, left\n            while fast != right and fast.next != right:\n                slow = slow.next\n                fast = fast.next.next\n            return slow\n        \n        def buildBalanceTree(left, right):\n            if left == right:\n                return None\n            median_node = findMedian(left, right)\n            res = TreeNode(median_node.val)\n            res.left = buildBalanceTree(left, median_node)\n            res.right = buildBalanceTree(median_node.next, right)\n            return res\n\n        return buildBalanceTree(head, None)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441178979","body":"### 思路\nhash set\n### 代码\n```py\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        hash_set = set()\n        p1 = headA\n        p2 = headB\n        while p1 is not None:\n            hash_set.add(p1)\n            p1 = p1.next\n        while p2 is not None:\n            if p2 in hash_set:\n                return p2\n            else:\n                p2 = p2.next\n        return None\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"firehaosky":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429903817","body":"# 思路：\n# k取余数与num的最后一位相加，数组长度i-1，用re来记录进位，当k取整或数组num的长度i为0时，将剩余数，插入数组前面。\n\n# 代码：\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        re = 0\n        ans = []\n        i_num = len(num)-1\n        i_k = len(str(k))-1\n\n        while i_num>=0 or i_k>=0:\n            x = num[i_num] if i_num>=0 else 0\n            y = k%10 if i_k>=0 else 0\n            k //= 10\n\n            sums = x+y+re\n            re = sums // 10\n            ans.insert(0, sums%10)\n\n            i_num -= 1\n            i_k -= 1\n        \n        if re>0:\n            ans.insert(0, re)\n        \n        return ans\n\n# 复杂度分析\n# 时间复杂度：O(n)\n# 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431347829","body":"# 思路：\n'''\n遍历数组，从左起以数组最大长度计算，逐个递减，当遇到c的时候更新被减数\n从右再遍历一遍，同之前的结果对比取最小值。\n'''\n# 解题 python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [0] * n\n\n        idx = -n\n        for i in range(0,n):\n            if s[i] == c:\n                idx = i\n            \n            ans[i] = i - idx\n        \n        idx = 2*n\n        for i in range(n-1, -1, -1):\n            if s[i] == c:\n                idx = i\n            \n            ans[i] = min(ans[i], idx-i)\n        \n        return ans\n\n# 复杂度分析：\n'''\n时间复杂度：for循环O（n）\n空间复杂度：O（1）\n'''","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432933019","body":"# 思路：\n'''\n首先根据最大值确定数组长度，以及数组计数\n'''\n\n# 解题 python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = [0] * maxSize\n        self.top_num = -1\n\n\n    def push(self, x: int) -> None:\n        if self.top_num != len(self.stack)-1:\n            self.top_num+=1\n            self.stack[self.top_num] = x\n\n\n\n    def pop(self) -> int:\n        if self.top_num != -1:\n            self.top_num -= 1\n            return self.stack[self.top_num+1]\n        else:\n            return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        lm = min(k, self.top_num+1)\n        for i in range(lm):\n            self.stack[i] += val\n\n\n\n\n# 复杂度分析：\n\"\"\"\n时间复杂度：只有inc中为O（n）\n空间复杂度：O（maxsize）\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434621754","body":"# 思路：\n\"\"\"\n采用递归，遇见数字就记录为数字，遇到[就将当前位置和字符串传入递归，当遇到]就返回保存的字符和位置\n\"\"\"\n\n# 解题：python\n\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        def dfs(s,i):\n            res = \"\"\n            multi = 0\n            while i < len(s):\n                if '0' <= s[i] <= '9':\n                    multi = multi*10 + int(s[i])\n                \n                elif s[i] == '[':\n                    i, tmp = dfs(s, i+1)\n                    res += multi * tmp\n                    multi = 0\n\n                elif s[i] == ']':\n                    return i, res\n\n                else:\n                    res += s[i]\n                \n                i+=1\n\n\n            return res\n        \n\n        return dfs(s,0)\n\n# 复杂度分析：\n\"\"\"\n时间复杂度：循环，O(n)\n空间复杂度：占用空间O(n)\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435660070","body":"class MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.s1 = []\n        self.s2 = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.s1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n        return self.s2.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.s2 == []:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n        return self.s2[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return self.s1 == [] and self.s2 == []\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435973222","body":"# 思路：\n\"\"\"\n要求分块的排序与原本排序一致，即当前块的最大值，要小于后面的所有值\n\n\"\"\"\n# 解题：python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for a in arr:\n            if len(stack) == 0 or a >= stack[-1]:\n                stack.append(a)\n            else:\n                mx = stack.pop()\n                while stack and a<stack[-1]:\n                    stack.pop()\n                stack.append(mx)\n        \n        return len(stack)\n\n\n# 复杂度分析：\n\"\"\"\n时间复杂度：采用了遍历，O(n)\n空间复杂度：使用了列表，O(n)\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437198448","body":"# 思路：\n\"\"\"\n循环，首先要判断其长度和循环后的起点位置，循环后顺序仍然相同，只需要找到断点即可\n\"\"\"\n\n# 解题：python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0 or not head or not head.next:\n            return head\n\n        cur = head\n        n = 1\n\n        while cur.next:\n            cur = cur.next\n            n += 1\n\n        if (add := n - k%n) == n:\n            return head\n\n        cur.next = head\n        while add:\n            cur = cur.next\n            add -= 1\n\n        re = cur.next\n        cur.next = None\n        return re\n\n# 复杂度分析：\n\"\"\"\n时间复杂度：采用了两个while循环，复杂度为O(n)\n空间复杂度：O(1)\n\"\"\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438460180","body":"# 思路：\n\"\"\"\n通过一个中间节点分别指向之后的两个节点，然后将这个中间节点推进至第二个节点的位置，重复上述过程，知道没有节点或只有一个节点的时候。\n\"\"\"\n# 解题：python\n\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        middle = ListNode[0]\n        middle.next = head\n        temp = middle\n        while temp.next and temp.next.next:\n            node1 = temp.next\n            node2 = temp.next.next\n            temp.next = node2\n            node1.next = node2.next\n            node2.next = node1\n            temp = node1\n        return middle.next\n\n# 复杂度分析：\n\"\"\"\n时间复杂度：O(n)\n空间复杂度：O(1)\n\"\"\"\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440300313","body":"`class Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        def getMiddle(left, right):\r\n            fast = slow = left\r\n            while fast!=right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n\r\n        def buildTree(left, right):\r\n            if left == right:\r\n                return None\r\n\r\n            mid = getMiddle(left, right)\r\n            root = TreeNode(mid.val)\r\n            root.left = buildTree(left, mid)\r\n            root.right = buildTree(mid.next, right)\r\n            return root\r\n\r\n        return buildTree(head, None)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441659165","body":"# 思路：\n\"\"\"\n通过两个指针，分别从头开始遍历两个链表，当到达末尾时，从另一个链表开始继续，当相等是为所需节点，或为空\n\"\"\"\n# 解题：python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if headA==None or headB==None:\n            return None\n        \n        pa = headA\n        pb = headB\n        while pa!=pb:\n            pa = pa.next if pa else headB\n            pb = pb.next if pb else headA\n        \n        return pa\n\n# 复杂度分析：\n\"\"\"\n时间复杂度：O(m+n) 最坏的情况需要两个链表都循环一遍\n空间复杂度：O(1)\n\"\"\"","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chao-cc":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429926937","body":"###思路\r\n\r\n最近才接触算法，很懵逼看了leetcode题解，先照着做下学习下思路\r\n\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n   和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n   当前位 = 和 % 10;\r\n   进位 = 和 / 10;\r\n\r\n判断是否有进位\r\n\r\n\r\n\r\n###代码\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int numL = num.length;\r\n        List<Integer> res = new ArrayList<>();\r\n        int i = numL -1, sum = 0 , carry = 0;\r\n        while(i>=0||k!=0){\r\n            int x = i>=0? num[i]:0;\r\n            int y = k!=0? k%10:0;\r\n            sum = x + y + carry;\r\n            carry  = sum/10;\r\n            k = k/10;\r\n            i--;\r\n            res.add(0,sum%10);\r\n        }\r\n        if(carry !=0){\r\n            res.add(0,carry);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n###复杂度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431581701","body":"###思路\n\n看解题思路，左右个遍历一次，分别记录距离，然后对比大小\n\n###代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int count = s.length();\n        int[] ans = new int[n];\n        Arrays.fill(ans, count + 1);\n        for (int i = 0, j = -1; i < count; i++) {\n            if (s.charAt(i) == c) j = i;\n            if (j != -1) ans[i] = i - j;\n        }\n        for (int i = count - 1, j = -1; i >= 0; i--) {\n            if (s.charAt(i) == c) j = i;\n            if (j != -1) ans[i] = Math.min(ans[i], j - i);\n        }\n        return ans;\n    }\n}\n```\n\n###复杂度分析\n\n时间复杂度 ：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433280746","body":"### 思路\n\n看了官方解题， 知道了 push pop的原理，希望能进步一点点，用数组模拟栈 变量top来记录当前栈顶的位置\n\n### 代码\n\n````java\nclass CustomStack{\n  int[] stack;\n  int top;\n  public CustomStack(int maxSize){\n    stack = new int[maxSize];\n    top = -1;\n   \n  }\n  public void push(int x){\n    if(top != stack.length -1){\n      top++;\n      stack[top] =x;\n    }\n\t}\n  public int pop(){\n    if(top == -1){\n      return top;\n    }\n    --top;\n    return stack[top+1];\n  }\n  public void increment(int k, int val){\n\t\tint limit = Math.min(k, top + 1);\n    for(int i=0; i < limit; ++i){\n\t\t\tstack[i] += val;\n    }\n  }\n  \n}\n````\n\n### 复杂度\n\n- 时间复杂度：incremet 方法里面循环操作 O(k)\n- 空间复杂度：O(maxSize)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinjin680":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429932323","body":"## 思路\n\n- 直接把K加到A的每一位中，再做取余处理得到和的数组形式对应位置的数；加了K之后的A[i]除以10得到新的K\n- 若加了该数字加了K之后，位数变多了\n  - 两数位数相同，和多了一位\n  - K位数比该数多\n- 在数组前面插入0，继续循环直至K为0\n\n## 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        i = len(A) - 1\n        while K:\n            A[i] += K\n            K = A[i] // 10\n            A[i] = A[i] % 10\n            #处理加了该数字加了K之后，位数变多了的情况（两数位数相同，和多了一位；K位数比该数多）\n            i -= 1\n            if i < 0 and K:\n                A.insert(0,0)\n                i = 0\n        return A\n```\n\n ## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431556364","body":"## 思路\n\n- 思路1：从左到右遍历一遍，得到离左边C的距离；再从右到左遍历一遍，得到离右边C的距离；取二者之间较小的那一个\n- 思路2：双指针\n  1. 未遇到C时，右指针右移；\n  2. 当右指针遇到C时，左指针的值即为与右指针之间的距离和当前值的最小项\n  3. 当右指针遇到C后，右指针右移，且右指针所在值为前一值加1\n\n## 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        l = r = 0\n        n = len(s)\n        res = [n] * n\n        flag = False  # 判断是否遇到过C\n        while r <= n - 1:\n            if s[r] == c: # 遇到C了\n                res[r] = 0 # 遇到c，距离为0\n                while l <= r: # 若l<=r，更新从左指针到r-1位置\n                    res[l] = min(res[l], r - l) # r - left  # 取两者距离最小值\n                    l += 1\n                r += 1\n                flag = True\n            else:\n                if flag:\n                    res[r] = res[r-1] + 1  # 算的是与左边C的距离\n                r += 1 # 没有遇到过c，右指针往右移\n        return res\n\n\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cruiseyugh":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429943458","body":"## 思路\n方法1.  将整个加数 k 加入从数组的最低位加起来，然后分别取最低位为num的结果，以及sum//10 为下一位的累加值\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num) -1\n        while k:\n            num[n] += k\n            #k,num[n] = num[n]//10, num[n]%10\n            num[n],k = num[n]%10, num[n]//10\n            n -= 1\n            if n<0 and k:\n                num.insert(0,0)\n                n = 0\n        return num\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431455081","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = [ len(s)+1 for _ in range(len(s))]\n        flag_index =-1\n        for index in range(len(s)):\n            \n            if s[index]==c:\n                ans[index] = 0\n                flag_index = index\n            elif flag_index !=-1:\n                ans[index] = index -flag_index\n        #print(ans)\n        flag_index =-1\n        for index in range(len(s)-1,-1,-1):\n            if s[index]==c:\n                ans[index] = 0\n                flag_index = index\n            elif flag_index !=-1:\n                ans[index] = min(flag_index-index ,ans[index] )\n        return ans\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(2n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433229854","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if (self.top+1) ==len(self.stk):\r\n            return \r\n        self.top += 1\r\n        self.stk[self.top] = x\r\n        #print(self.stk)\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -=1 \r\n        #print(self.stk)\r\n        return self.stk[self.top+1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        k = min(self.top+1,k)\r\n        for index in range(k):\r\n            self.stk[index] +=val\r\n        #print(self.stk)\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(k)$\r\n- 空间复杂度：$O(maxsize)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1435994659","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in range(len(s)):\n            if s[i] != \"]\":\n                stack.append(s[i])\n            else:\n                cur = \"\"\n                while stack[-1] != \"[\":\n                    cur = stack.pop() + cur\n                stack.pop()\n\n                k = \"\"\n                while stack and stack[-1].isdigit():\n                    k = stack.pop() + k\n                stack.append(cur * int(k))\n        return \"\".join(stack)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435994448","body":"class MyQueue:\n\n    def __init__(self):\n        self.stack = []\n        self.len = 0\n\n    def push(self, x: int) -> None:\n        # O(1)\n        self.stack.append(x)\n        self.len += 1\n\n    def pop(self) -> int:\n        # O(N) 将 stack 清空直至剩下最后一个，即 queue pop\n        # 需要将 len-1，代表 pop\n        tmp_stack = copy(self.stack)\n        tmp_len = self.len\n        while tmp_len > 1:\n            tmp_stack.pop()\n            tmp_len -= 1\n        self.len -= 1 # reduse len when pop\n        return tmp_stack.pop()\n\n    def peek(self) -> int:\n        # O(N) 将 stack 清空直至剩下最后一个，即 queue peek\n        tmp_stack = copy(self.stack)\n        tmp_len = self.len\n        while tmp_len > 1:\n            tmp_stack.pop()\n            tmp_len -= 1\n        return tmp_stack.pop()\n\n    def empty(self) -> bool:\n        # O(1)\n        return self.len == 0","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435994135","body":"'''\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        count_a = collections.defaultdict(int)\n        count_b = collections.defaultdict(int)\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            count_a[a] += 1\n            count_b[b] += 1\n            if count_a == count_b: ans += 1\n\n        return ans\n'''","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437024878","body":"## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head:\n            slow , fast = head ,head\n            tmp = head\n            leng = 0\n            while tmp:\n                tmp = tmp.next\n                leng +=1\n            k = k%leng\n            while k:\n                fast = fast.next\n                k -=1\n            while fast.next:\n                slow = slow.next\n                fast = fast.next\n            if slow.next:\n                tmp = slow.next\n            else:\n                return head\n            slow.next = None\n            fast.next = head\n            return tmp\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438717630","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        pre = ListNode(0)\n        pre.next =head\n        if not head or head.next ==None:\n            return head\n        pre_cu,cur,cur_next = pre,head,head.next\n        while cur and cur_next:\n            pre_cu.next = cur_next\n            cur.next = cur_next.next\n            cur_next.next =cur\n            print(pre)\n            pre_cu = cur\n            cur =pre_cu.next\n            if cur==None:\n                break\n            cur_next = cur.next\n        return pre.next\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440219381","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  利用快慢指针找出链表中点，然后将左右分别进行递归操作，构成搜索二叉树。\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def mediu_node(left,right):\r\n            slow = left\r\n            fast = left\r\n            while fast!=right and fast.next!=right:\r\n                slow = slow.next\r\n                fast = fast.next.next\r\n            return slow\r\n        def build_tree(left,right):\r\n            if left == right:\r\n                return None\r\n            med = mediu_node(left,right)\r\n            root = TreeNode(med.val)\r\n            root.left = build_tree(left,med)\r\n            root.right = build_tree(med.next,right)\r\n            return root\r\n        return build_tree(head,None)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"quieter2018":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429944216","body":"**思路**\r\n从低位逐个相加，进位加1，加完倒序；\r\n\r\n**代码**\r\n下述代码未考虑到 k 的位数比num多的情况，导致越界\r\n```C++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n\r\n        int len = num.size()-1;\r\n        int rem = 0;\r\n        vector<int> result;\r\n        while(len >= 0 ||k != 0){\r\n            rem = k % 10;\r\n            k = k / 10;\r\n            int sum = num[len]+rem;\r\n            if(sum >= 10){\r\n                k = k+1;\r\n                rem = sum % 10;\r\n                result.push_back(rem);\r\n            }else{\r\n                result.push_back(sum);\r\n            }\r\n            len--;\r\n        }\r\n        return {result.rbegin(), result.rend()};\r\n\r\n    }\r\n};\r\n\r\n```\r\n修改后\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n\r\n        int len = num.size()-1;\r\n        int rem = 0;\r\n        vector<int> result;\r\n        while(len >= 0 ||k != 0){\r\n            rem = k % 10;\r\n            k = k / 10;\r\n            \r\n            if(len>=0){\r\n                int sum = num[len]+rem;\r\n                if(sum >= 10){\r\n                    k = k+1;\r\n                }\r\n                 result.push_back(sum%10);\r\n            }else{\r\n                result.push_back(rem);\r\n            }\r\n            len--;\r\n        }\r\n        return {result.rbegin(), result.rend()};\r\n\r\n    }\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431231443","body":"**思路**\r\n从左往右遍历计算距离，从右往左遍历，取最小值。\r\n\r\n**代码**\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> dis(s.size());\r\n        int c_idx_1=0;\r\n        int c_idx_2=1;\r\n\r\n        for(int i = 0;i<s.size(); i++){\r\n            if(s[i]==c){\r\n                c_idx_2 = i;\r\n                dis[i]=0;\r\n                for(int j=c_idx_1; j<i;j++){\r\n                    dis[j]=abs(c_idx_2-j);\r\n                }\r\n                c_idx_1 =c_idx_2+1;\r\n            }else{\r\n                dis[i]=abs(c_idx_2-i);\r\n            }\r\n        }\r\n\r\n        c_idx_1= s.size()-1;\r\n        c_idx_2= s.size()-1;\r\n        vector<int> dis_back(s.size());\r\n\r\n        for(int i = s.size()-1;i>=0; i--){\r\n            if(s[i]==c){\r\n                c_idx_2 = i;\r\n                dis[i]=0;\r\n                for(int j=c_idx_1; j>i;j--){\r\n\r\n                    dis_back[j]=abs(c_idx_2-j);\r\n                }\r\n                c_idx_1 =c_idx_2-1;\r\n            }else{\r\n                dis_back[i]=abs(c_idx_2-i);\r\n            }\r\n        }\r\n\r\n        for(int i = 0;i<s.size(); i++){\r\n            dis[i]= min(dis_back[i],dis[i]);\r\n        }\r\n\r\n    return dis;    \r\n\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(n)\r\n\r\n- 空间复杂度：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433238056","body":"**思路**\r\n就按照题目所述进行实现即可。\r\n\r\n**代码**\r\n```C++\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stack;\r\n    int maxSize;\r\n    int top_idx = -1;\r\n\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize);\r\n        this->maxSize = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top_idx >= maxSize-1){\r\n            return;\r\n        }\r\n        top_idx++;\r\n        stack[top_idx]=x;\r\n\r\n    }\r\n    \r\n    int pop() {\r\n        if(top_idx<0){\r\n            return -1;\r\n        }\r\n        int res =  stack[top_idx];\r\n        top_idx--;\r\n        return res;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for(int i=0;i<=top_idx && i< k;i++){\r\n            stack[i]+=val;\r\n        }\r\n\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：push()、pop() 为 O(1) ;  increment操作是 O(k);\r\n- 空间复杂度:  O(n);","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435988388","body":"**思路**\r\n使用单调栈，分析可知当前值小于之前块的最大值时，则当前值为下一个分块的起点。\r\n\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> max;\r\n        int top=0;\r\n        int top_tmp =0;\r\n        if(arr.empty()){\r\n            return 0;\r\n        }\r\n        for(int i=0; i<arr.size()-1;i++){\r\n          if(i==0){\r\n              max.push(arr[i]);\r\n          }\r\n\r\n          if(arr[i+1]>=max.top()){\r\n            max.push(arr[i+1]);\r\n          }else{\r\n            top = max.top();\r\n            top_tmp = max.top();\r\n            while(arr[i+1]< top_tmp && (!max.empty() )){\r\n                if(max.size()>1){\r\n                  max.pop();\r\n                  top_tmp = max.top();\r\n                }else{\r\n                    max.pop();\r\n                }\r\n            }\r\n            max.push(top);\r\n          } \r\n        }\r\n        if(max.empty()){\r\n            return 1;\r\n        }\r\n        return max.size();\r\n\r\n    }\r\n};\r\n```\r\n**复杂度:**\r\n时间复杂度：O(n);\r\n空间复杂度：O(n);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436953794","body":"**思路：**\r\n将尾部向前数第K个元素作为头，原来的头接到原来的尾上，其实就是找倒数第k个元素。\r\n\r\n**代码：**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(head == NULL || head->next == NULL|| k == 0){\r\n            return head;\r\n        }\r\n\r\n        //计算链表长度\r\n        int length = 1;\r\n        ListNode *p = head;\r\n        while(p->next!=NULL){\r\n            length++;\r\n            p = p->next;\r\n        }\r\n\r\n        //若右移k == n*length,相当于链表不用动\r\n        k= k % length;\r\n        if(k==0){\r\n            return head;\r\n        }\r\n\r\n        //快慢指针,找到倒数k个值\r\n        ListNode *fast = head;\r\n        ListNode *slow = head;\r\n        int i = k;\r\n        while(i>0){\r\n            fast = fast->next;\r\n            i--;\r\n        }\r\n\r\n        while(fast->next!= NULL){\r\n            slow = slow->next;\r\n            fast = fast->next;\r\n        }\r\n\r\n        ListNode *new_head =  slow->next; \r\n        slow->next = NULL;\r\n        fast->next = head;\r\n\r\n        return new_head;\r\n\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析：**\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438593077","body":"**思路**\r\n利用虚拟节点，并创建 temp 表示当前到达的节点，每次需要交换 temp 后面的两个节点即可。\r\n\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        ListNode* newHead = new ListNode(0);\r\n        newHead->next = head; //指向原始链表\r\n        ListNode* temp = newHead;\r\n        while (temp->next != NULL && temp->next->next != NULL) {\r\n            ListNode* node1 = temp->next;\r\n            ListNode* node2 = temp->next->next;\r\n            temp->next = node2;//交换两个节点\r\n            node1->next = node2->next;\r\n            node2->next = node1;\r\n            temp = node1;\r\n        }\r\n        return newHead->next;\r\n    }\r\n};\r\n```\r\n**复杂度：**\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441241535","body":"**思路**\r\n当链表 headA 和 headB 都不为空时，两个链表才可能相交；两个指针 分别走 A+B 和 B+A，寻找到距尾部个数相同的节点位置，然后找交点。\r\n\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        //为空则不存在\r\n        if (headA == NULL || headB== NULL) { \r\n            return NULL;\r\n        }\r\n        //使用快慢指针，构造相同长度的两个链表\r\n        ListNode *pA = headA, *pB = headB;\r\n        while (pA != pB) { //不相等说明不相交\r\n            pA = (pA == NULL) ? headB:pA->next; \r\n            pB = (pB == NULL)?  headA:pB->next; \r\n        }\r\n\r\n        return pA;\r\n    }\r\n        \r\n};\r\n```\r\n**复杂度**\r\n时间复杂度： O(m+n) 　　m,n分别为两个链表的长度\r\n空间复杂度： O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jadeliu13":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429970650","body":"'''\nK取余作为相加的位数，K取整作为进一位的相加结果\n'''\nclass Solution:\n    def addToArrayForm(self, A: list[int], K: int) -> list[int]:\n        n = len(A)\n        ans = []\n\n        for i in range(n-1, -1, -1):\n            sum = A[i] + K % 10\n            K //= 10\n            # 当前位相加结果大于 10 时，进位 1 加入下一位计算\n            if sum >= 10:                \n                K += 1\n            # 进入数组\n            ans.append(sum % 10)\n            \n        # 若数组 A 的长度小于整数 K 位数个数的情况\n        while K > 0:\n            ans.append(K % 10)\n            K //= 10\n        # 因为添加进来是由低位往高位，输出时进行逆序输出\n        return ans[::-1]\n'''\n待解\n时间复杂度：O(n)\n空间复杂度：O(n)\n'''","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431595411","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n\n        def find_c():\n            yield from (i for i, j in enumerate(s) if j == c)\n            yield n * 2\n\n        f = find_c()\n        x, y = n * 2, next(f)\n        \n        ans = list()\n        for i, j in enumerate(s):\n            if j == c:\n                x, y = i, next(f)\n            ans.append(min(abs(i - x), abs(i - y)))\n        return ans","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434842143","body":"'''\n1. 栈里面每次存储两个信息, (左括号前的字符串, 左括号前的数字), \n比如abc3[def], 当遇到第一个左括号的时候，压入栈中的是(\"abc\", 3), 然后遍历括号里面的字符串def, \n当遇到右括号的时候, 从栈里面弹出一个元素(s1, n1), 得到新的字符串为s1+n1*\"def\", 也就是abcdefdefdef。\n对于括号里面嵌套的情况也是同样处理方式。\n2. 凡是遇到左括号就进行压栈处理，遇到右括号就弹出栈，栈中记录的元素很重要。\n'''\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxSize=maxSize\n        self.stack=[]\n\n\n    def push(self, x):\n        if len(self.stack)<self.maxSize:\n            self.stack.append(x)\n\n\n    def pop(self):\n        if len(self.stack)==0:\n            return -1\n        return self.stack.pop()\n\n\n    def increment(self, k, val):\n        if len(self.stack)<k:\n            for i in range(len(self.stack)):\n                self.stack[i]+=val\n        else:\n            for i in range(k):\n                self.stack[i]+=val\n        return self.stack\n# 有参考评论 https://leetcode.cn/problems/decode-string/comments/","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436017592","body":"# 一个数组可以分成好几个小数组，每个小数组内部都是递增排列的，最后这几个小数组可以按顺序组成的大数组刚好是这个数组的递增序列\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        arr = zip(arr, range(len(arr)))\n        arr = sorted(arr)\n        arrs = [0]*len(arr)\n        for idx,i in enumerate(arr):\n            arrs[i[1]] = idx\n        m = -float('inf')\n        res = 0\n        for i in range(len(arrs)):\n            m = max(m, arrs[i])\n            if m == i:\n                res += 1\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437239492","body":"#首尾相连，再找到位置断开循环.将尾部向前数第K个元素作为头，原来的头接到原来的尾上https://leetcode.cn/problems/rotate-list/\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n    #遍历到none，就从0开始计数（右开空间），如果遍历到最后有效位，就从1开始（右闭空间）\n        if head is None or head.next is None: return head\n        start, end, len = head, None, 0\n        while head:\n            end = head\n            head = head.next\n            len += 1\n        #首尾连接\n        end.next = start\n        #计算有效移动步数\n        pos = len - k % len\n        while pos > 1:\n            start = start.next\n            pos -= 1\n        ret = start.next\n        start.next = None\n        return ret","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437287514","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        res = ListNode(next=head)\n        pre = res\n      # 剩1或0，则遍历结束\n        while pre.next and pre.next.next:\n            cur = pre.next\n            post = pre.next.next            \n            # pre，cur，post对应最左，中间的，最右边的节点\n            cur.next = post.next\n            post.next = cur\n            pre.next = post\n\n            pre = pre.next.next\n        return res.next","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440286189","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n# 需要先找到链表的中间节点，然后将该中间节点作为二叉搜索树的根节点，创建完根节点之后，再递归的处理链表的左半部分和右半部分\n# 递归。用head和tail定义链首和链尾，链表区间为左闭右开，即 [ head , tail ）\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if head == None:\n            return None\n        return self.helper(head, None)\n    \n    def helper(self, start, end):\n        fast = slow = start\n        if start == end:\n            return None\n        while fast != end and fast.next != end:\n            fast = fast.next.next\n            slow = slow.next\n        root = TreeNode(slow.val)\n        root.left = self.helper(start, slow)\n        root.right = self.helper(slow.next, end)\n        return root\n\n    ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaoq777":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429974006","body":"```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> kList = new ArrayList<>();\r\n        while(k != 0) {\r\n            kList.add(k % 10);\r\n            k = k / 10;\r\n        }\r\n        Collections.reverse(kList);\r\n        \r\n        int i = num.length - 1, j = kList.size() - 1;\r\n        List<Integer> result = new ArrayList<>();\r\n        int add = 0;\r\n        while(i >= 0 || j >= 0) {\r\n            int sum = add;\r\n            if(i >= 0) {\r\n                sum += num[i--];\r\n            }\r\n            if(j >= 0) {\r\n                sum += kList.get(j--);\r\n            }\r\n            add = sum >= 10 ? 1 : 0;\r\n            result.add(sum % 10);\r\n        }\r\n        if(add != 0) {\r\n            result.add(1);\r\n        }\r\n        Collections.reverse(result);\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431568984","body":"## 思路\r\n先从左至右遍历，记录最后出现的字符c的索引j，得到每个位置与 向左找最近的字符c 的距离Math.abs(i-j)。\r\n再从右至左遍历，同上方式得到每个位置与 向右找最近的字符c 的距离。\r\n若在某个位置上向左找向右找都有字符c，就求 向左找最小距离 与 向右找最小距离 的较小值作为结果。\r\n\r\n\r\n## 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] result = new int[len];\r\n        Arrays.fill(result, Integer.MAX_VALUE);\r\n        int j = -1;\r\n        for(int i = 0; i < len; i++) {\r\n            if(s.charAt(i) == c) {\r\n                j = i;\r\n            }\r\n            if(j != -1) {\r\n                result[i] = Math.abs(i - j);\r\n            }\r\n        }\r\n        j = -1;\r\n        for(int i = len - 1; i >= 0; i--) {\r\n            if(s.charAt(i) == c) {\r\n                j = i;\r\n            }\r\n            if(j != -1) {\r\n                result[i] = Math.min(result[i], Math.abs(i - j));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n时间复杂度 O(N)\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433266099","body":"### 思路\r\n使用数组实现栈，使用一个tail变量记录当前栈顶的索引。\r\n入栈操作tail+1，出栈操作tail-1。\r\n\r\n### 代码\r\n```java\r\nclass CustomStack {\r\n\r\n    int[] arr;\r\n    int tail = -1;\r\n\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(tail == arr.length - 1) {\r\n            return;\r\n        }\r\n        arr[++tail] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(tail == -1) {\r\n            return -1;\r\n        }\r\n        return arr[tail--];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i = 0; i < Math.min(k, arr.length); i++) {\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度:\r\n* push: O(1)\r\n* pop: O(1)\r\n* increment: O(k)或O(maxSize)\r\n\r\n空间复杂度:\r\nO(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434643795","body":"### 思路\r\n使用栈数据结构，将字符依次入栈，遇到']'时取出栈中需要重复的连续字符放入list，直到遇到'['后再从栈中取出连续的数字n，将这一段内容解码(将list内容重复n次)后,  将这段内容再放入栈中继续处理。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Deque<Character> stack = new LinkedList<>();\r\n        StringBuffer buffer = new StringBuffer();\r\n        for(int i = 0; i < s.length(); i++) {\r\n            char c = s.charAt(i);\r\n            if(c == ']') {\r\n                List<Character> list = new ArrayList<>();\r\n                while(!stack.isEmpty()) {\r\n                    char d = stack.pop();\r\n                    if(d == '[') {\r\n                        break;\r\n                    }\r\n                    list.add(d);\r\n                }\r\n                int num = 0;\r\n                int n = 1;\r\n                while(!stack.isEmpty()) {\r\n                    char d = stack.pop();\r\n                    if(d - '0' <= 9) {\r\n                        num += n * (d - '0');\r\n                        n *= 10;\r\n                    }else {\r\n                        stack.push(d);\r\n                        break;\r\n                    }\r\n                }\r\n                num = num == 0 ? 1 : num;\r\n                for(int j = 0; j < num; j++) {\r\n                    for(int k = list.size() - 1; k >= 0; k--) {\r\n                        stack.push(list.get(k));\r\n                    }\r\n                }\r\n            }else {\r\n                stack.push(c);\r\n            }\r\n        }\r\n        while(!stack.isEmpty()) {\r\n            buffer.append(stack.pollLast());\r\n        }\r\n        return buffer.toString();\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435493598","body":"### 思路\r\n使用两个栈模拟，peek或pop操作时将第一个栈中的元素全部移动到第二个栈中(第一个栈的栈顶元素将被放到第二个栈的栈底)。\r\n这样从第二个栈的栈顶取元素相当于整体顺序先入先出。\r\n\r\n### 代码\r\n```java\r\nclass MyQueue {\r\n\r\n    Stack<Integer> stack1 = new Stack<>();\r\n    Stack<Integer> stack2 = new Stack<>();\r\n\r\n    public MyQueue() {\r\n\r\n    }\r\n    \r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        move();\r\n        if(!stack2.isEmpty()) {\r\n            return stack2.pop();\r\n        }else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public int peek() {\r\n        move();\r\n        return stack2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stack1.isEmpty() && stack2.isEmpty();\r\n    }\r\n\r\n    public void move() {\r\n        if(stack2.isEmpty()) {\r\n            while(!stack1.isEmpty()) {\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436024728","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack();\r\n        int n = 0;\r\n        for(int i = 0; i < arr.length; i++) {\r\n            if(stack.isEmpty() || arr[i] >= stack.peek()) {\r\n                stack.push(arr[i]);\r\n            }else {\r\n                int t = stack.pop();\r\n                while(!stack.isEmpty() && stack.peek() > arr[i]) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(t);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437231281","body":"```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (k == 0 || head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        int len = 1;\r\n        ListNode node = head;\r\n        while (node.next != null) {\r\n            node = node.next;\r\n            len++;\r\n        }\r\n        int n = len - k % len;\r\n        if (n == len) {\r\n            return head;\r\n        }\r\n        node.next = head;\r\n        for(int i = 0; i < n; i++) {\r\n            node = node.next;\r\n        } \r\n        ListNode result = node.next;\r\n        node.next = null;\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438621802","body":"```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        ListNode result = head.next;\r\n        ListNode pre = null;\r\n        while(head != null && head.next != null) {\r\n            ListNode next = head.next.next;\r\n            head.next.next = head;\r\n            if(pre != null) {\r\n                pre.next = head.next;\r\n            }\r\n            head.next = next;\r\n            pre = head;\r\n            head = next;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1439940171","body":"```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        List<Integer> list = new ArrayList<>();\r\n        while(head != null) {\r\n            list.add(head.val);\r\n            head = head.next;\r\n        }\r\n        if(list.isEmpty()) {\r\n            return null;\r\n        }\r\n        return buildTree(list, 0, list.size() - 1);\r\n    }\r\n\r\n    public TreeNode buildTree(List<Integer> list, int start, int end) {\r\n        int mid = start + (end - start) / 2;\r\n        TreeNode node = new TreeNode(list.get(mid));\r\n        if(mid > start) {\r\n            node.left = buildTree(list, start, mid - 1);\r\n        }\r\n        if(end > mid) {\r\n            node.right = buildTree(list, mid + 1, end);\r\n        }\r\n        return node;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangyanlineu":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429976257","body":"### Idea\r\n- use``` k%10``` to get the least important digit (the last one)\r\n- use ```carry_on``` to memorize the number that we carried from last round, the original ```carry_on``` should be 0\r\n- loop from the last element in array num to the start, ```carry_on+num_element + k%10``` should be the current number\r\n- update the ```carry_on``` and ```num_element``` in different way based on if ```carry_on+num_element + k%10 >= 10```\r\n- if we run out of the num element, then we insert the new digit to the index 0 until ```k == 0 and carry_on == 0```\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = len(num)-1\r\n        carry_on = 0\r\n        while i >= 0:\r\n            carry_on += k%10\r\n            k = k//10\r\n            temp = num[i] + carry_on\r\n            if temp >= 10:\r\n                carry_on = temp//10\r\n                num[i] = temp%10\r\n            else:\r\n                num[i] = temp\r\n                carry_on = 0\r\n            i -= 1\r\n\r\n        while carry_on or k:\r\n            carry_on += k%10\r\n            k = k//10\r\n            if carry_on >= 10:\r\n                num.insert(0, carry_on%10)\r\n                carry_on = carry_on//10\r\n            else:\r\n                num.insert(0, carry_on)\r\n                carry_on = 0\r\n        return num\r\n```\r\n- Time Complexity:  O(N)  <b>N = len(max(len(num), len(k_digits))</b>\r\n- Space Complexity: O(1) <b> insert new digits to the original num array</b>","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430346702","body":"### Idea\r\n- use <b>Two Pointers</b> to decide which index is the cloest\r\n- get all c's index in s\r\n- iterate through s and get the smallest distance\r\n```python3\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        # Get all c's index in s\r\n        c_index = []\r\n        for index, value in enumerate(s):\r\n            if value == c:\r\n                c_index.append(index)\r\n                \r\n        ans = []\r\n        cur = c_index.pop(0)\r\n        for i in range(len(s)):\r\n            distance_cur = cur-i if cur-i >= 0 else i-cur\r\n            if not c_index:\r\n                ans.append(distance_cur)\r\n            else:\r\n                distance_next = c_index[0]-i if c_index[0]-i>=0 else i-c_index[0]\r\n                ans.append(min(distance_cur, distance_next))\r\n                if distance_next <= distance_cur:\r\n                    cur = c_index.pop(0)\r\n        return ans\r\n```\r\n- Time Complexity = O(N) <b>N= len(s)</b>\r\n- Space Complexity = O(N) <b>N= len(s)</b>","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433316573","body":"###Idea\r\n- use self.cur_length to memorize the length of the stack\r\n- self.limit represents the maxSize of the stack\r\n- use array's append and pop to do push and pop\r\n\r\n```python3\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.limit = maxSize\r\n        self.cur_length = 0\r\n        self.stack = []\r\n        \r\n    def push(self, x: int) -> None:\r\n        if self.cur_length < self.limit:\r\n            self.stack.append(x)\r\n            self.cur_length += 1\r\n        else:\r\n            return\r\n    \r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            self.cur_length -= 1\r\n            return self.stack.pop()\r\n        return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        k = min(k, self.cur_length)\r\n        while k>0 :\r\n            self.stack[k-1] += val\r\n            k -= 1\r\n        return\r\n```\r\n- Time Complexity = O(1) for push and pop, O(N) for increment N=min(k, self.cur_length)\r\n- Space Complexity = O(N) N=maxSize","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1433978030","body":"### Idea \r\n- Recursively\r\n```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        def findNum(index: int) -> list:\r\n            num = ''\r\n            while index<len(s) and s[index].isnumeric():\r\n                num += s[index]\r\n                index += 1\r\n            return [int(num), index]\r\n        def findPairBracket(first_bracket: int) -> int:\r\n            num_of_first_bracket = 0\r\n            for i in range(first_bracket, len(s)):\r\n                if s[i] == '[':\r\n                    num_of_first_bracket += 1\r\n                elif s[i] == ']':\r\n                    num_of_first_bracket -= 1\r\n                if num_of_first_bracket == 0:\r\n                    return i\r\n        res = ''\r\n        index = 0\r\n        while index<len(s):\r\n            if s[index].isnumeric(): \r\n                [repeat_num, first_bracket] = findNum(index)\r\n                second_bracket = findPairBracket(first_bracket) \r\n                res += self.decodeString(s[first_bracket+1:second_bracket])*repeat_num \r\n                index = second_bracket + 1\r\n            else:\r\n                res += s[index]\r\n                index += 1\r\n        return res\r\n```\r\n- Stack\r\n```python3\r\ndef decodeString(self, s: str) -> str:\r\n        stack = []\r\n        num = ''\r\n        cur_str = ''\r\n        for char in s:\r\n            if char == '[':\r\n                stack.append(cur_str)\r\n                stack.append(int(num))\r\n                num = cur_str = ''\r\n            elif char == ']':\r\n                repeat_num = stack.pop()\r\n                prev = stack.pop()\r\n                cur_str = prev + cur_str*repeat_num\r\n            elif char.isnumeric():\r\n                num += char\r\n            else:\r\n                cur_str += char\r\n        return cur_str\r\n```\r\n- Time Complexity = O(N)\r\n- Space Complexity = O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435465026","body":"```python3\nclass MyQueue:\n\n    def __init__(self):\n        self.queue = []\n        \n    def push(self, x: int) -> None:\n        self.queue.append(x)\n        \n    def pop(self) -> int:\n        if self.queue:\n            return self.queue.pop(0)\n\n    def peek(self) -> int:\n        if self.queue:\n            return self.queue[0]\n\n    def empty(self) -> bool:\n        if not self.queue:\n            return True\n        return False\n```\n- space = O(N)\n- time = O(1) except that pop() is O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436287975","body":"```python3\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack =[]\n        for num in arr:\n            if not stack or stack[-1] <= num:\n                stack.append(num)\n            else:\n                cur = stack[-1]\n                while stack and stack[-1] > num:\n                    cur = max(cur, stack.pop())\n                stack.append(cur)\n        return len(stack)\n```\n- Time Complexity = O(N)\n- Space Complexity = O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436258891","body":"### Idea\n- get the length of the linked list\n- k = k%length\n- break and rebuild the link\n```python3\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n        length = 0\n        cur = head\n        while cur:\n            length += 1\n            cur = cur.next\n\n        k = k%length\n        if k == 0:\n            return head\n        slow = fast = head\n        for _ in range(length-k-1):\n            fast = fast.next\n        end = fast\n        newHead = fast = fast.next\n        end.next = None\n        while fast and fast.next:\n            fast = fast.next\n        fast.next = slow\n        return newHead\n```\n- Time Complexity = O(N)\n- Space Complexity = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437348055","body":"### Idea\n- remove and rebuild the link until there is less than 2 nodes left \n```python3\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        dummy = ListNode(0, head)\n        prev = dummy\n        first = prev.next\n        while first and first.next:\n            second = first.next\n            prev.next = second\n            first.next = second.next\n            second.next = first\n            prev = first\n            first = prev.next\n        return dummy.next\n```\n- Time = O(N) N=length of the listed list\n- Space = O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1438888980","body":"- find the middle node in the linked list\r\n- **divide** it in the middle **and conquer** left segment and right segment\r\n```python3\r\nclass Solution:\r\n    def divideConquer(self, segment: Optional[ListNode], length: int) -> Optional[TreeNode]:\r\n        if not segment: return\r\n        if not segment.next: return TreeNode(segment.val)\r\n        # find the middle node to divide and conquer\r\n        prev, middle = segment, segment.next\r\n        for _ in range(length//2-1):\r\n            prev, middle =  prev.next, middle.next \r\n        # divide and conquer\r\n        prev.next = None\r\n        leftTree = self.divideConquer(segment, length//2)\r\n        rightTree = self.divideConquer(middle.next, length-length//2-1)\r\n        middle.next = None\r\n        return TreeNode(middle.val, leftTree, rightTree) \r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head: return\r\n        if not head.next: return TreeNode(head.val)\r\n        # Get the length of the linked list\r\n        length = 0\r\n        cur = head\r\n        while cur:\r\n            length += 1\r\n            cur = cur.next\r\n        return self.divideConquer(head, length)\r\n```\r\n- Time = O(NlogN)\r\n- Space = O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1440582904","body":"- Find the length of headA and headB\n- move the longer one's pointer few steps away (difference between length)\n- move both pointers forward until find the joint point\n- **Time = O(m+n)**\n- **Space = O(1)**\n```python3\nclass Solution:\n    def getLength(self, head: ListNode) -> int:\n        res = 0\n        cur = head\n        while cur:\n            res += 1\n            cur = cur.next\n        return res\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        a, b = self.getLength(headA), self.getLength(headB)\n        [long, short] = [headA, headB] if a>=b else [headB, headA]\n        for _ in range(abs(a-b)):\n            long = long.next\n        while long:\n            if long == short:\n                return long\n            long, short = long.next, short.next\n        return None\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxiner":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1429985050","body":"## 思路\r\n 1. 将k转为数组\r\n 2. 数组形式逐位相加\r\n\r\n## 代码（JavaScript）\r\n\r\n```javascript\r\nvar addToArrayForm = function (num, k) {\r\n    let i1 = num.length - 1;\r\n    let kArray = k.toString().split('').map(i => Number(i));\r\n    let i2 = kArray.length - 1;\r\n    const carry =0;\r\n    const res = []\r\n    while (i1 >= 0 || i2 >= 0) {\r\n        const sum = num[i1] + kArray[i2] + carry;\r\n        const val = sum % 10;\r\n        carry = Math.floor(sum / 10);\r\n        res.push(val);\r\n        i1--;\r\n        i2--;\r\n    }\r\n    if(!!carry) {\r\n        res.push(carry)\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\n\r\n```\r\n\r\n\r\n## 复杂度分析\r\n时间O(N)\r\n空间O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431571499","body":"# 思路：\n两次遍历\n\nvar shortestToChar = function (s, c) {\n    const arr = s.split('');\n    const n = arr.length;\n    const res = [];\n    for (let i = 0, idx = -n; i < n; i++) {\n        if (arr[i] == c) {\n            idx = i;\n        }\n        res[i] = i - idx;\n    }\n\n    for (let i = n - 1, idx = 2 * n; i >= 0; i--) {\n        if (arr[i] == c) {\n            idx = i;\n        }\n        res[i] = Math.min(res[i], idx - i);\n    }\n    return res\n\n};\n\n时间&空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433193468","body":"思路：模拟数组原生pop和push\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize = maxSize;\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    let stack = this.stack;\r\n    if(stack.length < this.maxSize) {\r\n        stack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    let stack = this.stack;\r\n    if(stack.length > 0) {\r\n        return stack.pop();\r\n    }\r\n    return -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    let stack = this.stack;\r\n    for(let i = 0; i < Math.min(stack.length, k); i++) {\r\n        stack[i] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1435535241","body":"以下是使用 JavaScript 实现给定编码字符串的解码函数：\n\n```javascript\nfunction decodeString(s) {\n  const stack = [];\n  let currentStr = \"\";\n  let currentNum = 0;\n\n  for (let i = 0; i < s.length; i++) {\n    const char = s.charAt(i);\n\n    if (/[0-9]/.test(char)) {\n      currentNum = currentNum * 10 + parseInt(char);\n    } else if (char === \"[\") {\n      stack.push(currentStr);\n      stack.push(currentNum);\n      currentStr = \"\";\n      currentNum = 0;\n    } else if (char === \"]\") {\n      const num = stack.pop();\n      const prevStr = stack.pop();\n      currentStr = prevStr + currentStr.repeat(num);\n    } else {\n      currentStr += char;\n    }\n  }\n\n  return currentStr;\n}\n```\n### 使用了一个栈来辅助解码。我们遍历给定的字符串，对于每个字符，执行以下操作：\n\n如果是数字，更新当前数字；\n如果是左括号，将当前字符串和数字入栈，并清空当前字符串和数字；\n如果是右括号，从栈中弹出之前保存的字符串和数字，重复当前字符串并拼接到弹出的字符串后面；\n如果是字母，将它拼接到当前字符串后面。\n最后返回当前字符串即为解码后的字符串。\n### 复杂度分析：\n时间：O(N)\n空间：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435618399","body":"```javascript\nvar MyQueue = function () {\n    this.stack1 = [];\n    this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n    if (this.stack2.length === 0) {\n        while (this.stack1.length > 0) {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n    if (this.stack2.length === 0) {\n        while (this.stack1.length > 0) {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    const top = this.stack2.pop();\n    this.stack2.push(top);\n    return top;\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n    return this.stack1.length === 0 && this.stack2.length === 0;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n```\n\n### 使用两个栈实现一个先入先出队列，其中一个栈 stack1 用于入队，另一个栈 stack2 用于出队。入队操作时，将元素压入 stack1；出队操作时，如果 stack2 不为空，则直接弹出栈顶元素；如果 stack2 为空，则依次将 stack1 的元素弹出并压入 stack2，再弹出 stack2 的栈顶元素。peek 操作时，先执行和 pop 操作类似的步骤，最后将栈顶元素压回 stack2 中。\n\n### 复杂度\n空间： O(2N)\n时间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436023370","body":"努力看懂大神们的解法ing\n```javascript\n\nvar maxChunksToSorted = function (arr) {\n    var count = 1;\n    let max = 0;\n    for (let i = 0; i < arr.length; i++) {\n        max = Math.max(max, arr[i]);\n        if (max === i) {\n            count++;\n        }\n    }\n    return count;\n};\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437192206","body":"```javascript\nvar rotateRight = function(head, k) {\n    if( !k || !head || !head.next) return head;\n    let n = 1;\n    let cur = head;\n    while(cur.next) {\n        cur = cur.next;\n        n++;\n    }\n    cur.next = head;\n    let end = n - k % n;\n    while(end) {\n        cur = cur.next\n        end--;\n    }\n    const ret = cur.next;\n    cur.next = null;\n    return ret\n};\n```\n\n### 思路：\n\n遍历链表，得到链表长度N和尾巴\n将链表尾巴指向head，得到循环链表\n遍历（N - k % N）次，得到预期结果的上一个节点cur\n\n### 复杂度：\n空间 O(N)\n时间 O(2N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438559813","body":"```javascript\nvar swapPairs = function (head) {\n    const ghost = new ListNode(0, head);\n    let cur = ghost;\n    while (cur.next && cur.next.next) {\n        const next = cur.next;\n        const end = next.next;\n        cur.next = end;\n        next.next = end.next;\n        end.next = next;\n        cur = next;\n        // console.log(ghost.next)\n    }\n    return ghost.next;\n};\n\n```\n### 思路：\n非递归，中间变量用的好，交换无烦恼\n\n## 复杂度：\n时间： O(N)\n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440144499","body":"```javascript\nvar sortedListToBST = function (head) {\n    return buildTree(head, null);\n};\n\nfunction buildTree(left, right) {\n    if (left === right) return null;\n    var mid = getMedian(left, right);\n    var root = new TreeNode(mid.val);\n    root.left = buildTree(left, mid);\n    root.right = buildTree(mid.next, right);\n    return root\n}\n\nfunction getMedian(left, right) {\n    var fast = left;\n    var slow = left;\n    while (fast !== right && fast.next !== right) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    return slow\n}\n\n```\n\n### 思路：\n递归找中值作为root节点，找中值的方法利用快慢针\n\n### 复杂度：\n空间： O(Nlog(N))\n时间： O(log(N))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufanzh":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1430340398","body":"# intuition: convert k to list of num, then add backwards\n# tc: o(n)\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # first convert k to array \n        # then use carrier to add backwards\n        k_list = list(map(int, str(k))) #map(func, iter)\n        # print(k_list)\n        # now we add backwards\n        i = len(num) - 1\n        j = len(k_list) - 1\n        carry = 0\n        ans = []\n        while i >= 0 or j >= 0:\n            a = num[i] if i >= 0 else 0 \n            b = k_list[j] if j >= 0 else 0\n            val = a + b + carry\n            carry = val // 10\n            i -= 1\n            j -= 1\n            ans.append(val%10)\n        # now ans is in reversed order\n        if carry != 0:\n            ans.append(carry)\n        ans.reverse()\n        return ans\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1430315284","body":"#forward and backward array traverse\n# tc: o(n) since we traverse the array without nest\n# sc: o(n) for initialize ans array\n\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = [float('inf')] * len(s)\n        # traverse forward and backward to get two list, first the min value between those two list\n        # correct way to initialize ans\n        ans = [0 if s[i] == c else None for i in range(len(s))] # 0 means distance\n        # forward scan\n        for i in range(1, len(s)):\n            if ans[i] != 0 and ans[i-1] is not None:\n                ans[i] = ans[i-1] + 1\n                # if i index is not c, and previous distance has value\n        \n        # backward scan\n        for i in range(len(s)-2, -1, -1):\n            if ans[i] is None or ans[i] > ans[i+1] + 1:\n                ans[i] = ans[i+1] + 1 # not updated yet or value larger than backward scan\n        return ans\n\n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1431948381","body":"```\r\nclass CustomStack:\r\n# keep a separate increment array to add only on the boundary\r\n    def __init__(self, maxSize: int):\r\n        self.max = maxSize\r\n        self.stack = []\r\n        self.incr = []\r\n        \r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max:\r\n            self.stack.append(x)\r\n            self.incr.append(0)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) == 0:\r\n            return -1 # empty stack\r\n        if len(self.stack) > 1:\r\n            self.incr[-2] += self.incr[-1]\r\n        return self.stack.pop() + self.incr.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.incr:\r\n            idx = min(k, len(self.incr))\r\n            self.incr[idx - 1] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1435771409","body":"```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        # example using stack 32[a]2[bc]\n        # ch in s can be under the following four situations\n        # digit, [, letter, ]\n        ans = \"\"\n        stack = []\n        num = 0\n        for ch in s:\n            if ch.isdigit():\n                num = num * 10 + int(ch)\n            elif ch == \"[\":\n                # we put previous string/num to stack\n                stack.append(ans)\n                stack.append(num)\n                ans = \"\"\n                num = 0\n            elif ch.isalpha():\n                ans += ch\n            elif ch == \"]\":\n                # pop out from stack\n                preNum = stack.pop()\n                preString = stack.pop()\n                ans = preString + preNum * ans\n        return ans\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435773907","body":"```\nclass MyQueue:\n# QUEUE: FIFO\n# STACK: LIFO\n    def __init__(self):\n        #use an out stack for pop function \n        self.instk = []\n        self.out = []\n\n    def push(self, x: int) -> None:\n        self.instk.append(x)\n\n    def pop(self) -> int:\n        if not self.out:\n            while self.instk:\n                val = self.instk.pop()\n                self.out.append(val)\n        return self.out.pop()\n\n    def peek(self) -> int:\n        if not self.out:\n            while self.instk:\n                val = self.instk.pop()\n                self.out.append(val)\n        return self.out[-1]\n\n    def empty(self) -> bool:\n        return not self.out and (not self.instk)\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435769946","body":"* idea: monotonic stack keep max value for each chunk.\\n\n* tc: O(N), only need to traverse the array once.\n\n\n```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        # from the problem we know that, for all the chuncks\n        # max value of left must <= max value of right to make the sorted possible\n        # then we can maintain a monotonic stack, if num[i] >= stack[-1], we put it in. if nums[i] < stack[-1], then it must belong to some previous chunck, we need to pop up top of stack.\n        mono_stack = []\n        for num in arr:\n            if len(mono_stack) == 0 or mono_stack[-1] <= num:\n                mono_stack.append(num)\n            else:\n                ma = mono_stack[-1]\n                while mono_stack and num < mono_stack[-1]:\n                    ma = max(ma, mono_stack.pop())\n                    # !! add max value to stack, not number when we found those small values, stack should keep max value for each chunck\n                mono_stack.append(ma)\n            print(mono_stack)\n        return len(mono_stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436295396","body":"```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        # this has to split the linked list at k places --> consider slow-fast pointers\n        # edge case for linked list\n        if not head or not head.next or k == 0:\n            return head\n        # based on constraint, k is not necessarily smaller than length of node, so there can be multiples, we want to get the mod to be more efficient\n        # step 1, get the length of the linked list first\n        length = 1\n        p0 = head\n        while p0.next:\n            p0 = p0.next\n            length += 1\n        k = k % length\n\n        # now use fast slow pointers to find the k places\n        p_slow = head\n        p_fast = head\n        while k > 0:\n            p_fast = p_fast.next\n            k -= 1\n        while p_fast.next:\n            p_fast = p_fast.next\n            p_slow = p_slow.next\n        # now we reach the flip location\n        p_fast.next = head\n        res = p_slow.next\n        p_slow.next = None\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437503835","body":"two approaches: recursive and iteratively.\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # typical linked list problem: recursive & iterative\n        # method 1. recursive:\n        # p1 --> p2 --> rest\n        # p2 --> p1 --> rest\n        # # edge case\n        # while not head or not head.next:\n        #     return head\n        # p1 = head\n        # p2 = head.next\n        # p1.next = self.swapPairs(p2.next)\n        # p2.next = p1\n        # return p2\n\n        # method 2. iteratively\n        # keep point1, 2 to move and swap p1 --> p2 --> next\n        while not head or not head.next:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head\n        p0 = dummy\n        while p0 and p0.next and p0.next.next:\n            p1 = p0.next\n            p2 = p0.next.next\n            # start to swap\n            p1.next = p2.next\n            p2.next = p1\n            p0.next = p2\n            p0 = p1\n        return dummy.next\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441229309","body":"```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        # two pointers\n        p1 = headA\n        p2 = headB\n      #the critical part is headA and headB doesn't necessarily meet at intersection after same steps\n    #One way to do it is to tranverse headA to headB, and then tranverse headB to headA, then their intersection will both appear in the end (or as nullptr)\n        while p1 != p2:\n            if p1 == None:\n                p1 = headB\n            else:\n                p1 = p1.next\n            if p2 == None:\n                p2 = headA\n            else:\n                p2 = p2.next\n        return p1\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"franciszq":[null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431327395","body":"## 思路\n\n求最短距离，一维数据的话，需要从前往后，从后往前各自遍历一遍，然后每个位置，取较小的一个。\n\n## 代码\n\n~~~c++\nclass Solution\n{\npublic:\n    vector<int> shortestToChar(string s, char c)\n    {\n        vector<int> from_begin_length, from_end_length, res;\n        int length_tmp = 999999;\n        for (int i = 0; i < s.size(); ++i) {    // 从头遍历\n            if (s[i] == c) {\n                length_tmp = 0;\n            } else {\n                length_tmp++;\n            }\n            from_begin_length.emplace_back(length_tmp);\n        }\n        length_tmp = 9999999;\n        for (int i = s.size() - 1; i >= 0; --i) {     // 从尾遍历\n            if (s[i] == c) {\n                length_tmp = 0;\n            } else {\n                length_tmp++;\n            }\n            from_end_length.emplace_back(length_tmp);\n        }\n        for (int i = 0; i < s.size(); ++i) {\n            if (from_begin_length[i] < from_end_length[s.size() - i - 1]) {\n                res.emplace_back(from_begin_length[i]);\n            } else {\n                res.emplace_back(from_end_length[s.size() - i - 1]);\n            }\n        }\n        return res;\n    }\n};\n\n\n\n\n~~~\n\n## 复杂度\n\n* 时间复杂度O(3n)\n* 空间复杂度O(3n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432964991","body":"## 思路\n\n用数组来模拟栈。\n\n## 代码\n\n~~~c++\nclass CustomStack\n{\npublic:\n    CustomStack(int maxSize)\n    {\n        max_size = maxSize;\n        stack.reserve(max_size);\n    }\n\n    void push(int x)\n    {\n        if (stack.size() >= max_size) {\n            return;\n        }\n        stack.emplace_back(x);\n    }\n\n    int pop()\n    {\n        if (stack.size() > 0) {\n            int val = stack.back();\n            stack.pop_back();\n            return val;\n        } else {\n            return -1;\n        }\n\n    }\n\n    void increment(int k, int val)\n    {\n        int add_size = min(k, int(stack.size()));\n        for (int add_id = 0; add_id < add_size; ++add_id) {\n            stack[add_id] = stack[add_id] + val;\n        }\n    }\nprivate:\n    vector<int> stack;\n    int max_size;\n    int cur_size;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n~~~\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434671781","body":"## 思路\n\n自己没有想出来，看题解的。思想如下：\n\n* 遍历字符串，使用栈来存储需要的信息，并且记录当前遍历的位置id\n* 如果遇到数字，则需要找连续的数字，然后放到栈当中\n* 遇到字母和\"[\"，就放到栈当中\n\n重点：\n\n* 遇到 \"]\"，说明之前栈中的肯定全是字母，直到遇到“[”，把字母全部取出来\n* “【”前面肯定是数字，把数字取出来，然后将取出来的字母拼起来，重复数字的数倍，再push进栈中\n* 直到遍历完整个字符串，栈中肯定全是字母，拼起来后return。\n\n#### 注意点\n\n* id的增加\n* 取出的字母要翻转一下。\n\n## 代码\n\n~~~c++\nclass Solution {\npublic:\n    std::string get_digit(string& s, int& id)\n{\n    std::string s_digit;\n    while (isdigit(s[id])) {\n        s_digit += s[id++];\n    }\n    return s_digit;\n}\n\nstd::string get_string(std::vector<std::string>& stk)\n{\n    std::string res;\n    for (auto s : stk) {\n        res += s;\n    }\n    return res;\n}\n\nstring decodeString(string s)\n{\n    std::vector<std::string> stk;\n    int id = 0;\n    while (id < s.size()) {\n        if (isdigit(s[id])) {\n            stk.push_back(get_digit(s, id));\n        } else if (isalpha(s[id]) || s[id] == '[') {\n            stk.push_back(std::string(1, s[id++]));\n        } else {     //\n            id++;\n            std::vector<std::string> v_str;\n            while (stk.back() != \"[\") {\n                v_str.push_back(stk.back());\n                stk.pop_back();\n            }\n            reverse(v_str.begin(), v_str.end());\n            stk.pop_back();   // 左括号出栈\n            int rep_time = stoi(stk.back());\n            stk.pop_back();\n            std::string sub_str = get_string(v_str);\n            std::string t;\n            for (int i = 0; i < rep_time; ++i) {\n                t += sub_str;\n            }\n            stk.push_back(t);\n        }\n    }\n    return get_string(stk);\n}\n};\n~~~\n\n## 复杂度\n\n* 时间复杂度O(n)\n* 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435667304","body":"## 思路\n\n两个栈，一个做入栈，一个做出栈\n\n出栈的数据来自于入栈，当出栈为空时，将入栈的数据全部塞进出栈。\n\n\n\n## 代码\n\n~~~c++\nclass MyQueue\n{\npublic:\n    MyQueue()\n    {\n\n    }\n\n    void push(int x)\n    {\n        stk_in.push(x);\n    }\n\n    int pop()\n    {\n        if (stk_in.empty() && stk_out.empty()) {\n            return -1;\n        }\n        if (stk_out.empty()) {\n            while (!stk_in.empty()) {\n\n                stk_out.push(stk_in.top());\n                stk_in.pop();\n            }\n        }\n        int tmp = stk_out.top();\n        stk_out.pop();\n        return tmp;\n    }\n\n    int peek()\n    {\n        if (stk_out.empty()) {\n            while (!stk_in.empty()) {\n                int nub = stk_in.top();\n                stk_in.pop();\n                stk_out.push(nub);\n            }\n        }\n        return stk_out.top();\n    }\n\n    bool empty()\n    {\n        if (stk_in.empty() && stk_out.empty()) {\n            return true;\n        }\n        return false;\n    }\n\nprivate:\n    std::stack<int> stk_in;\n    std::stack<int> stk_out;\n};\n\n~~~\n\n## 复杂度\n\n* 时间复杂度O(1)\n* 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435995510","body":"## 思路\n\n第一个靠自己过hard难度的题目的，也是挺兴奋的。\n\n这题感觉就是找规律，一开始的思想是如何找出一种分法，则必须前面一块的数字都要比后面一块小，概况就是前面一块的最大值，比后面一块的最小值都要小，则就可以分开。\n\n细想一下，就是遍历整个数组，按遍历到的数字分为前面和后面，只要前面的最大值小于后面的最小值，则就是一种分法。但是直接这么做，复杂度有点高，因此，想到的如下的方式。\n\n* 从前往后遍历，找到每一位之前最大的数字，记录下来到max_size。\n* 从后往前遍历，找到每一位之前最小的数字，记录下来到min_size\n* 遍历比较max_size[i]和min_size[i+1]，如果max_size[i] <=min_size[i+1]，则结果+1。\n\n#### 注意点\n\n* 结果从1开始累加\n\n## 代码\n\n~~~c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int arr_size = arr.size();\n        if(arr_size == 1)\n        {\n            return 1;\n        }\n        int res = 1;\n        vector<int> max_size(arr_size, 0);\n        vector<int> min_size(arr_size, 0);\n        max_size[0] = arr[0];\n        min_size[arr_size-1] = arr[arr_size-1];\n        for(int i = 1; i < arr_size; ++i)\n        {\n            if (arr[i] > max_size[i-1])\n            {\n                max_size[i] = arr[i];\n            }\n            else\n            {\n                max_size[i] = max_size[i-1];\n            }\n            if (arr[arr_size-i-1] < min_size[arr_size-i])\n            {\n                min_size[arr_size-1-i] = arr[arr_size-i-1];\n            }\n            else\n            {\n                min_size[arr_size-1-i] = min_size[arr_size-i];\n            }\n        }\n        for(int i = 0; i < arr_size-1; ++i)\n        {\n            if (max_size[i] <= min_size[i + 1])\n            {\n                res++;\n            } \n        }\n        return res;\n    }\n};\n~~~\n\n## 复杂度\n\n* 时间复杂度O(3n)\n* 空间复杂度O(2n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436863915","body":"## 思路\r\n\r\n就是截断链表，重新换个链表头，并且原来的尾巴指向原来的表头。步骤如下\r\n\r\n* 先计算链表的长度size\r\n* 如果k大于size的话，会有重复，所以用k%size，得到的值，就是移动的距离move_size\r\n* 找到4个节点：原来的表头，原来的表尾，原来的size-move_size-1的节点（cut_node），size-move_size的节点（新的表头）。\r\n* 表尾next指向表头，size-move_size-1；cut_node的next指向null。返回size-move_size的节点\r\n\r\n#### 注意点\r\n\r\n* if (head == nullptr || head->next == nullptr || k == 0)的话，直接返回head\r\n\r\n* k%size == 0的话，不旋转\r\n\r\n## 代码\r\n\r\n~~~c++\r\nclass Solution\r\n{\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k)\r\n    {\r\n        if (head == nullptr || head->next == nullptr || k == 0) {\r\n            return head;\r\n        }\r\n        ListNode* first_node = head;\r\n        int list_size = 1;\r\n        while (head->next != nullptr) {\r\n            head = head->next;\r\n            list_size++;\r\n        }\r\n        ListNode* last_node = head;\r\n        int rotate_size = k % list_size;\r\n        if (rotate_size == 0) {\r\n            return first_node;\r\n        }\r\n        ListNode* cut_node = first_node;\r\n        for (int i = 0; i < list_size - rotate_size - 1; ++i) {\r\n            cut_node = cut_node->next;\r\n        }\r\n        head = cut_node->next;\r\n        last_node->next = first_node;\r\n        cut_node->next = nullptr;\r\n        return head;\r\n\r\n    }\r\n};\r\n~~~\r\n\r\n## 复杂度\r\n\r\n* 时间复杂度O(n)\r\n* 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438594311","body":"## 思路\n\n加虚拟头，就是每两个节点交换。只要记录4个节点：head，first_head，second_head，next_head。\n\n然后head指向second_head，second_head指向first_head，first_head指向next_head。\n\n#### 注意点\n\n无。\n\n## 代码\n\n~~~c++\nListNode* swapPairs(ListNode* head)\n    {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        ListNode* virtual_head = new ListNode;\n        virtual_head->next = head;\n        head = virtual_head;\n        while (head->next && head->next->next) {\n            ListNode* first_node = head->next;\n            ListNode* second_node = head->next->next;\n            ListNode* next_first = head->next->next->next;\n            head->next = second_node;\n            second_node->next = first_node;\n            first_node->next = next_first;\n            head = head->next->next;\n        }\n\n        return virtual_head->next;\n    }\n~~~\n\n## 复杂度\n\n* 时间复杂度O(n)\n* 空间复杂度O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441633538","body":"## 思路\n\n又是想不出来的一道题，看的官方解答。\n\n最基础的就是多对多的遍历，但是时间复杂度为O（m*n），肯定不行。\n\n简答的方法是两个指针，然后同时从A，B开始遍历，各自遍历完后，去遍历另一个指针，因为如果有相交，碰到同一个指针，则就是相交点。\n\n因为如果有相交，则A相交前有3个点，B相交前有5个点，相交后都有2个点，则按上面那种方式，会同时走3+2+5。\n\n#### 注意点\n\n无。\n\n## 代码\n\n~~~c++\nListNode* getIntersectionNode(ListNode* headA, ListNode* headB)\n    {\n        if (headA == nullptr || headB == nullptr) {\n            return nullptr;\n        }\n        ListNode* headA_run = headA;\n        ListNode* headB_run = headB;\n        while (headA_run != headB_run) {\n            headA_run = headA_run == nullptr ? headB : headA_run->next;\n            headB_run = headB_run == nullptr ? headA : headB_run->next;\n        }\n\n        return headA_run;\n    }\n~~~\n\n## 复杂度\n\n* 时间复杂度O(m+n)\n* 空间复杂度O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kangqinsen":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1431529917","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode.cn/problems/add-to-array-form-of-integer/\n\n## 思路\n\n两数相加，从后往前，两数遍历完最后看carry。\n其中一个数遍历完，后续取0。\n最后reverse下。\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new ArrayList<>();\n        int c = 0;\n\n        int i = num.length-1 ; \n\n        int carry = 0;\n        while(i>=0 || k >0){\n          int ki = k % 10;\n          int numi = i >= 0 ? num[i] : 0;\n\n          k /= 10;\n          i--;\n\n          int sum = (ki + numi + carry) ;\n          carry = sum / 10;\n          ans.add(sum%10);\n        }\n        if(carry>0){\n          ans.add(carry);\n        }\n        List<Integer> result = new ArrayList<>();\n        for(int idx = ans.size()-1 ; idx >= 0 ; idx --){\n          result.add(ans.get(idx));\n        }\n        return result;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431448135","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode.cn/problems/shortest-distance-to-a-character/\n\n\n## 思路\n两次循环，第一次从左到右，第二次从左到右，分别找到从左到右最小的距离和从右到校最小的距离，二者取最小\n## 关键点\n两次循环中，第一次从左到右，在找到第一个c之前，result[i] = 无限大，在第一次c之前的结果，在第二次循环从右到左一定能找到最近的c，且是最终答案。\n同理，从右到左，也是无限大。\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n      int size = s.length();\n      int[] result = new int[size];\n      int currentIndexC = -1*size;\n      for(int i = 0 ; i < size ; i++){\n        int ch = s.charAt(i);\n        if(ch == c){\n          currentIndexC = i;\n        }\n      result[i] = Math.abs(currentIndexC - i);\n      }\n\n      currentIndexC = size*2;\n      for(int i = size - 1 ; i >= 0 ; i--){\n        int ch = s.charAt(i);\n        if(ch == c){\n          currentIndexC = i;\n        }\n        result[i] = Math.min(result[i] , Math.abs(currentIndexC - i));\n      }\n      \n      return result;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437746965","body":"\n\n## 思路\n定义一个prev， 一个current（current 是 prev.next) 。保持prev不变，交换current和current.next 。 然后prev指向current(即交换后的next)\n## 关键点\nhead指针会变化的题，定义dummy。 dummy也是最开始的prev\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode prev = dummy;\n        ListNode current= dummy.next; \n        ListNode nextNode= null;\n        while(current != null && current.next != null){\n          nextNode = current.next;\n          prev.next = nextNode; \n          current.next = nextNode.next;\n          nextNode.next = current;\n\n          prev = current;\n          current = prev.next ; \n        }\n      \n        return dummy.next;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"manwzy":[null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431519341","body":"/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\n\nvar shortestToChar = function(s, c) {\n  let i=-1,j=0,cur=0;\n  let res = []\n  while(i<s.length){\n    if(s[j]!==c && j<s.length){\n      j++\n      continue\n    }\n\n    if(i===-1){\n      cur = 0\n      while(cur<j){\n        res.push(j-cur++)\n      }\n    }else if(j===s.length){\n      cur = i\n      while(cur<j){\n        res.push(cur++-i)\n      }\n    }else{\n      cur = i\n      while(cur<j){\n        res.push(Math.min(cur-i,j-cur))\n        cur++\n      }\n    }\n    i=j\n    j++\n  }\n  return res\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436023615","body":"/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n  if(arr.length===1){\r\n    return 1\r\n  }\r\n  let minMaxRes = []\r\n  let currentMax = arr[0]\r\n  let currentMin = arr[0]\r\n  for(let i=1;i<arr.length;++i){\r\n    if(arr[i]>=currentMax){\r\n      minMaxRes.push(currentMin, currentMax)\r\n      currentMax = arr[i]\r\n      currentMin = arr[i]\r\n    }\r\n    currentMin = Math.min(arr[i], currentMin)\r\n  }\r\n  minMaxRes.push(currentMin, currentMax)\r\n\r\n  let length = minMaxRes.length / 2\r\n  for(let i=length-1;i>0;--i){\r\n    if(minMaxRes[i*2] < minMaxRes[i*2-1]){\r\n      //current max ,next min,need merge\r\n      length--\r\n      minMaxRes[i*2-1] = minMaxRes[i*2+1]\r\n      minMaxRes[i*2-2] = Math.min(minMaxRes[i*2],minMaxRes[i*2-2])\r\n    }\r\n  }\r\n\r\n  return length\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1436034355","body":"/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n  if(k===0){\r\n    return head\r\n  }\r\n  let stash = []\r\n  let cur = head\r\n  \r\n  while(cur && k>0){\r\n    stash.push(cur.val)\r\n    cur = cur.next\r\n    k--\r\n  }\r\n  let i = 0\r\n\r\n  if(!cur && !k){\r\n    return head\r\n  }\r\n\r\n  if(!cur){\r\n    k%=stash.length\r\n    cur = head\r\n    while(cur){\r\n      cur.val = stash[(i+stash.length - k)%stash.length] \r\n      cur = cur.next\r\n      i++\r\n    }\r\n  }else{\r\n    while(cur){\r\n      stash.push(cur.val)\r\n      cur.val = stash[i] \r\n      cur = cur.next\r\n      i++\r\n    }\r\n    cur = head\r\n    while(i<stash.length){\r\n      cur.val = stash[i]\r\n      cur = cur.next\r\n      i++\r\n    }\r\n  }\r\n \r\n  return head\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1437278469","body":"var swapPairs = function(cur) {\r\n  if(!cur || !cur.next){\r\n    return cur\r\n  }\r\n  let tmp = cur.next\r\n  cur.next = swapPairs(tmp.next)\r\n  tmp.next = cur\r\n  return tmp\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1438873574","body":"/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\n\r\nconst trans = (arr, start, end) => {\r\n  if(start > end){\r\n    return null\r\n  }\r\n  if(start === end){\r\n    return arr[start]\r\n  }\r\n  let i = start + Math.floor((end-start) / 2)\r\n  arr[i].left = trans(arr,start,i-1)\r\n  arr[i].right = trans(arr,i+1,end)\r\n  return arr[i]\r\n}\r\n\r\nvar sortedListToBST = function(head) {\r\n  if(!head){\r\n    return null\r\n  }\r\n  let arr = []\r\n  while(head){\r\n    arr.push(new TreeNode(head.val))\r\n    head = head.next\r\n  }\r\n\r\n  return trans(arr,0,arr.length-1)\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry9926":[null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431523338","body":"思路：\n1. 计算目标字符的下标数组\n2. 遍历字符串，计算每个字符与目标字符的距离\n3. 对比距离取最小值记录\n4. 输出\n\n```js\nvar shortestToChar = function(s, c) {\n    // i=目标字符的下标,e=结果\n    var i = [], e = []\n    s.split('').forEach(function(item, index) {\n        item == c && i.push(index)\n    })\n    s.split('').forEach(function(num, index) {\n        if (num == c) {\n            e.push(0)\n        } else {\n            // b=当前距离\n            var b = s.length\n            i.forEach(function(item) {\n                if (Math.abs(item-index) < b) {\n                    b = Math.abs(item-index)\n                }\n            })\n            e.push(b)\n        }\n    })\n    return e\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432601446","body":"时间复杂度\npush、pop=O(1)\nincrement=O(n)\n空间复杂度\nO(maxSize)\n\n```js\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.value=[]\n    this.maxSize=maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.value.length < this.maxSize) {\n        this.value.unshift(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.value.length === 0) {\n        return -1\n    }\n    return this.value.shift()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    var n=0\n    for (var i=this.value.length-1; i >= 0; i--) {\n        if (n < k) {\n            n++\n            this.value[i] = this.value[i] + val    \n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"soso1105":[null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431572670","body":"### 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        left = []\n        res = []\n        for i in range(len(s)):\n            if c == s[i]:\n                left.append(i)\n\n        for j in range(len(s)):\n            t = len(s)\n            for i in left:\n                t = min(abs(j-i), t)\n            res.append(t)\n        \n        return res\n```\n\n**复杂度分析**\n\n\\- 时间复杂度：O(N^2)\n\\- 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433263826","body":"### 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.currentSize = 0\n        self.storage = []\n\n    def push(self, x: int) -> None:\n        if self.currentSize < self.maxSize:\n            self.storage.append(x)\n            self.currentSize+=1\n\n    def pop(self) -> int:\n        if self.currentSize == 0:\n            return -1\n        self.currentSize-=1\n        return self.storage.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        incre_num = min(k, self.currentSize)\n        for i in range(incre_num):\n            self.storage[i] += val\n```\n\n**复杂度分析**\n\n\\- 时间复杂度：O(1)\n\\- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435705496","body":"### 代码\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.arr=[]\r\n    \r\n    def push(self, x: int) -> None:\r\n        self.arr.append(x)\r\n\r\n    def pop(self) -> int:\r\n        return self.arr.pop(0)\r\n\r\n    def peek(self) -> int:\r\n        return self.arr[0]\r\n        \r\n\r\n    def empty(self) -> bool:\r\n        return not self.arr\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pkuphy":[null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432292492","body":"```rust\r\nstruct CustomStack {\r\n    elements: Vec<i32>, // 使用 vector 模拟 stack\r\n    maxSize: usize, // 初始化 maxSize，后续比较多用 usize 所以此处使用 usize 类型\r\n}\r\n\r\n\r\nimpl CustomStack {\r\n\r\n    fn new(maxSize: i32) -> Self {\r\n        CustomStack {\r\n            elements: Vec::new(), // new vector\r\n            maxSize: maxSize as usize,\r\n        }\r\n    }\r\n    \r\n    fn push(&mut self, x: i32) { // &mut self\r\n        if self.elements.len() < self.maxSize {\r\n            self.elements.push(x)\r\n        }\r\n    }\r\n    \r\n    fn pop(&mut self) -> i32 {\r\n        self.elements.pop().unwrap_or(-1)\r\n    }\r\n    \r\n    fn increment(&mut self, k: i32, val: i32) {\r\n        let k = std::cmp::min(k as usize, self.elements.len());\r\n\r\n        for i in 0..k {\r\n            *(self.elements.get_mut(i).unwrap()) += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\npush, pop O(1)\r\nincrement O(k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhenya-zhu":[null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/3#issuecomment-1431616262","body":"思路：\n遇到c将count置0。顺序遍历，倒序遍历，填充时取最小值\n```\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\n\nvar shortestToChar = function(s, c) {\n    let arr = s.split('').map(ch => {\n        if (ch == c) {\n            return 0\n        } else{\n            return null\n        }\n    })\n\n    let dis = null\n    for (let i = 0; i < arr.length; i++){\n        cur = arr[i]\n        if (cur === 0){\n            dis = 0\n        }else{\n            if (dis !== null){\n                dis++\n                if (arr[i] == null){\n                    arr[i] = dis\n                }else{\n                    arr[i] = Math.min(arr[i], dis)\n                }\n            }\n        }\n    }\n    dis = null\n    for (let i = arr.length - 1; i > -1; i--){\n        cur = arr[i]\n        if (cur === 0){\n            dis = 0\n        }else{\n            if (dis !== null){\n                dis++\n                if (arr[i] == null){\n                    arr[i] = dis\n                }else{\n                    arr[i] = Math.min(arr[i], dis)\n                }\n            }\n        }\n    }\n    return arr\n\n};\n```\n\n时间复杂度：3次遍历，O(n)\n空间复杂度：O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433025382","body":"/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.stack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length < this.maxSize){\n        this.stack.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.stack.length > 0){\n        return this.stack.pop()\n    }else{\n        return -1\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const len = this.stack.length\n    for(let i = 0; i < k && i < len; i++){\n        this.stack[i] += val\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438627269","body":"#思路\r\n递归求解\r\n\r\n#代码\r\n```js\r\nvar swapPairs = function(head) {\r\n    function swap(first){\r\n        if(!first) return first\r\n        let second = first.next\r\n        if(!second) return first\r\n        let rest = second.next\r\n        first.next = swap(rest)\r\n        second.next = first\r\n        return second\r\n    }\r\n    return swap(head)\r\n};\r\n```\r\n\r\n#复杂度\r\n时间：On\r\n空间：O1","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wty9sky":[null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432367108","body":"``` javascript\nfunction ListNode(val){\n    this.val=val;\n    this.next=null;\n}\nvar CustomStack = function(maxSize) {\n    this.maxSize=maxSize;\n    this.head=null;\n    this.length=0;\n};\n\nCustomStack.prototype.push = function(x) {\n    if(this.length===this.maxSize) return;\n    let node=new ListNode(x);\n    let linkList=this.head;\n    node.next=linkList;\n    this.head=node;\n    this.length++;\n};\n\nCustomStack.prototype.pop = function() {\n    if(this.length===0) return -1;\n    let linkList=this.head.next;\n    let popVal=this.head.val;\n    this.head=linkList;\n    this.length--;\n    return popVal;\n};\n\nCustomStack.prototype.increment = function(k, val) {\n    if(k<0) return;\n    let start=this.length-k;\n    let currentNode=this.head;\n    if(start>0){\n        for(let i=0;i<start;++i){\n            currentNode=currentNode.next;\n        }\n    }\n    while(currentNode){\n        currentNode.val+=val;\n        currentNode=currentNode.next;\n    }\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440172599","body":"``` javascript\nconst sortedListToBST = (head) => {\n  const arr = [];\n  while (head) { // 将链表节点的值逐个推入数组arr\n    arr.push(head.val);\n    head = head.next;\n  }\n  // 根据索引start到end的子数组构建子树\n  const buildBST = (start, end) => {\n    if (start > end) return null;        // 指针交错，形成不了子序列，返回null节点\n    const mid = (start + end) >>> 1;     // 求中间索引 中间元素是根节点的值\n    const root = new TreeNode(arr[mid]); // 创建根节点\n    root.left = buildBST(start, mid - 1); // 递归构建左子树\n    root.right = buildBST(mid + 1, end);  // 递归构建右子树\n    return root;                          // 返回当前子树\n  };\n\n  return buildBST(0, arr.length - 1);  // 根据整个arr数组构建\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skyoct":[null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1432523094","body":"class CustomStack {\r\n\r\n    private int[] stack;\r\n    private int top = 0;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top >= stack.length) {\r\n            return;\r\n        }\r\n        stack[top++] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == 0) {\r\n            return -1;\r\n        }\r\n        return stack[--top];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int end = k > top ? top : k ;\r\n        for(int i=0; i<end; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bingzxy":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1433279109","body":"### 题目：\r\n\r\n[989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\r\n\r\n### 思路\r\n数组逐位相加，模拟\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> kArr = new ArrayList<> ();\r\n        while (k > 0) {\r\n            System.out.println(k % 10);\r\n            kArr.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        List<Integer> nArr = new ArrayList<> ();\r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            nArr.add(num[i]);\r\n        }\r\n\r\n        List<Integer> ans = new ArrayList<> ();\r\n        int extr = 0;\r\n        int size = Math.min(kArr.size(), nArr.size());\r\n        for (int i = 0; i < size; i++) {\r\n            int tmp = kArr.get(i) + nArr.get(i) + extr;\r\n            extr = tmp / 10;\r\n            ans.add(tmp % 10);\r\n        }\r\n\r\n        if (size < kArr.size()) {\r\n            for (int i = size; i < kArr.size(); i++) {\r\n                int tmp = kArr.get(i) + extr;\r\n                extr = tmp / 10;\r\n                ans.add(tmp % 10);\r\n            }\r\n        }\r\n\r\n        if (size < nArr.size()) {\r\n            for (int i = size; i < nArr.size(); i++) {\r\n                int tmp = nArr.get(i) + extr;\r\n                extr = tmp / 10;\r\n                ans.add(tmp % 10);\r\n            }\r\n        }\r\n\r\n        if (extr == 1) {\r\n            ans.add(extr);\r\n        }\r\n\r\n        List<Integer> reverseAns = new ArrayList<> ();\r\n        for (int i = ans.size() - 1; i >= 0; i--) {\r\n            reverseAns.add(ans.get(i));\r\n        }\r\n\r\n        return reverseAns;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433197588","body":"### 思路\r\n使用数组模拟栈操作\r\n\r\n### 代码\r\n```java\r\nclass CustomStack {\r\n\r\n    int[] stack;\r\n    int current;\r\n    int size;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        size = maxSize;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (current == size) {\r\n            return;\r\n        }\r\n        stack[current++] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if (current == 0) {\r\n            return -1;\r\n        }\r\n        return stack[--current];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < Math.min(k, current); i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push、pop O(1)，increment O(k)\r\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435701057","body":"### 思路\r\n使用两个栈进行模拟，一个栈负责接受数据，另一个负责输出数据\r\n\r\n### 代码\r\n```java\r\nclass MyQueue {\r\n    Deque<Integer> stackA = new ArrayDeque<> ();\r\n    Deque<Integer> stackB = new ArrayDeque<> (); \r\n    public MyQueue() {\r\n\r\n    }\r\n    \r\n    public void push(int x) {\r\n        stackA.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (!stackB.isEmpty()) {\r\n            return stackB.pop();\r\n        }\r\n        while (!stackA.isEmpty()) {\r\n            stackB.push(stackA.pop());\r\n        }\r\n        return pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (!stackB.isEmpty()) {\r\n            return stackB.peek();\r\n        }\r\n        while (!stackA.isEmpty()) {\r\n            stackB.push(stackA.pop());\r\n        }\r\n        return peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stackA.isEmpty() && stackB.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1438605120","body":"### 思路\r\n指针操作，注意将操作数 k 进行取模\r\n\r\n### 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        int cnt = 0;\r\n        ListNode cur = head;\r\n        while (cur != null) {\r\n            cnt++;\r\n            cur = cur.next;\r\n        }\r\n\r\n        k = k % cnt;\r\n        if (k == 0) {\r\n            return head;\r\n        }\r\n        ListNode pre = head;\r\n        cur = head;\r\n        while (k-- > 0) {\r\n            cur = cur.next;\r\n        }\r\n\r\n        while (cur.next != null) {\r\n            cur = cur.next;\r\n            pre = pre.next;\r\n        }\r\n\r\n        ListNode nextHead = pre.next;\r\n        pre.next = null;\r\n        cur.next = head;\r\n        return nextHead;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438578863","body":"### 思路\r\n递归，每层交换两个元素，当链表为空或单节点时可以直接返回。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n\r\n        ListNode l1 = head, l2 = head.next;\r\n        ListNode next = l2.next;\r\n        l2.next = l1;\r\n        l1.next = swapPairs(next);\r\n        return l2;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/12#issuecomment-1440174243","body":"### 思路\r\n按平衡树要求，可以将链表转为数组，此时数据递增，可以取中间节点作为根节点，则左子树和右子树的数量一致，递归生成左子树和右子树。\r\n\r\n### 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        int cnt = 0;\r\n        ListNode cur = head;\r\n        List<ListNode> list = new ArrayList<> ();\r\n        while (cur != null) {\r\n            cnt++;\r\n            ListNode next = cur.next;\r\n            cur.next = null;\r\n            list.add(cur);\r\n            cur = next;\r\n        }\r\n        return sortedListToBST(list, 0, cnt - 1);\r\n    }\r\n\r\n    private TreeNode sortedListToBST(List<ListNode> list, int start, int end) {\r\n        if (start > end) {\r\n            return null;\r\n        }\r\n        int mid = start + (end - start) / 2;\r\n        TreeNode head = new TreeNode(list.get(mid).val);\r\n        head.left = sortedListToBST(list, start, mid - 1);\r\n        head.right = sortedListToBST(list, mid + 1, end);\r\n        return head;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaodingc":[{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/2#issuecomment-1433470554","body":"```\r\n        public IList<int> AddToArrayForm(int[] num, int k)\r\n        {\r\n            #region 方法1\r\n\r\n            //从右到左遍历数组，用carry记录每次需要相加的值，\r\n            //这里的carry并不是进位，而是数组A每个元素应该相加的值。\r\n            //A = [1,2,3,4], K = 34，那么tmp =4+34=38 将38%10=8添加进res数组中\r\n            //carry=38/10=3，tmp=3+3=6, A=[1,2,6,8] 1 33337\r\n\r\n            IList<int> res = new List<int>();\r\n            int carry = k;\r\n            for (int i = num.Length - 1; i >= 0; i--)\r\n            {\r\n                var tmp = num[i] + carry;\r\n                res.Add(tmp % 10);\r\n                carry = tmp / 10;\r\n            }\r\n\r\n            while (carry > 0)\r\n            {\r\n                res.Add(carry % 10);\r\n                carry = carry / 10;\r\n            }\r\n\r\n\r\n            return res.Reverse().ToList();\r\n            #endregion\r\n        }\r\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/4#issuecomment-1433349820","body":"C#版本\r\n```\r\npublic class CustomStack {\r\n    int[] num;\r\n    int cur = -1;\r\n\r\n    public CustomStack(int maxSize) {\r\n        num = new int[maxSize];\r\n    }\r\n    \r\n    public void Push(int x) {\r\n        if(cur < num.Length-1){\r\n            ++cur;\r\n            num[cur] = x;\r\n        }\r\n    }\r\n    \r\n    public int Pop() {\r\n        if(cur == -1)\r\n            return -1;\r\n        cur--;\r\n        return num[cur+1];\r\n    }\r\n    \r\n    int t;\r\n    public void Increment(int k, int val) {\r\n        t = Math.Min(k, cur +1);\r\n        for(int i = 0 ; i < t ; i++){\r\n            num[i] += val;\r\n        }\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434863642","body":"```  \r\n  //定义一个字符栈，一个数字栈\r\n  //如果是连续数字就对该数字进行转换操作\r\n  //如果遇到'[' 字符串及数字栈入栈，且数字置0\r\n  //如果遇到']'字符串 数字栈出栈 并根据出栈值循环字符串的长度\r\n  //如果不是上述情况，用StringBuilder追加该字符长度\r\n  public string DecodeString(string s)\r\n        {\r\n            Stack<string> stringStack = new Stack<string>();\r\n            Stack<int> numStack = new Stack<int>();\r\n            StringBuilder sb =new StringBuilder();\r\n            int num = 0;\r\n            foreach (var c in s)\r\n            {\r\n                if (c<='9' && c>='0')\r\n                {\r\n                    num =10*num+ (c - '0');\r\n                }\r\n                else if(c=='[')\r\n                {\r\n                    stringStack.Push(sb.ToString());\r\n                    numStack.Push(num);\r\n                    num = 0;\r\n                    sb=new StringBuilder();\r\n                }else if (c == ']')\r\n                {\r\n                    StringBuilder tem= new StringBuilder();\r\n                    int count = numStack.Pop();\r\n                    for (int i = 0; i < count; i++)\r\n                    {\r\n                        tem.Append(sb.ToString());\r\n                    }\r\n                    sb = new StringBuilder(stringStack.Pop() + tem);\r\n                }\r\n                else\r\n                {\r\n                    sb.Append(c);\r\n                }\r\n            }\r\n            return sb.ToString();\r\n        }\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1434886854","body":"```\r\n       public class MyQueue\r\n        {\r\n            private Stack<int> s1, s2;\r\n            public MyQueue()\r\n            {\r\n                s1=new Stack<int>();\r\n                s2=new Stack<int>();\r\n            }\r\n\r\n            public void Push(int x)\r\n            {\r\n                s1.Push(x);\r\n            }\r\n\r\n            public int Pop()\r\n            {\r\n                Peek();\r\n                return s2.Pop();\r\n            }\r\n\r\n            //1 2 3 // 3 2 1\r\n            public int Peek()\r\n            {\r\n                if (s2.Count==0)\r\n                {\r\n                    while (s1.Count!=0)\r\n                    {\r\n                        s2.Push(s1.Pop());\r\n                    }\r\n                }\r\n                return s2.Peek();\r\n            }\r\n\r\n            public bool Empty()\r\n            {\r\n                if (s1.Count==0 && s2.Count==0)\r\n                {\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1436016116","body":"看了单调递增栈解答，想了好久时间才明白  \r\nC#版本\r\n```\r\n     public static int MaxChunksToSorted(int[] arr)\r\n        {\r\n            Stack<int> stack = new Stack<int>();\r\n            int i = 0;\r\n            while (arr.Length-1>=i)\r\n            {\r\n                var a = arr[i];\r\n                if (stack.Count>0 && stack.Peek()> a)\r\n                {\r\n                    int temp = stack.Peek();\r\n                    //注意 如果条件换了，stack为空时要加条件\r\n                    while (stack.Count > 0 && stack.Peek() > a)\r\n                    {\r\n                        stack.Pop();\r\n                      \r\n                    }\r\n                    stack.Push(temp);\r\n                }\r\n                else\r\n                {\r\n                    stack.Push(a);\r\n                }\r\n                i++;\r\n            }\r\n\r\n            return stack.Count;\r\n        }\r\n```\r\n复杂度分析\r\n1.时间复杂度：O(N)\r\n2.空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437232271","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     public int val;\r\n *     public ListNode next;\r\n *     public ListNode(int val=0, ListNode next=null) {\r\n *         this.val = val;\r\n *         this.next = next;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode RotateRight(ListNode head, int k) {\r\n        if(head == null || k==0)\r\n            return head;\r\n        ListNode cur = head;\r\n        ListNode pre = null;\r\n        int count = 1;\r\n        while(cur.next!=null)\r\n        {\r\n            cur = cur.next;\r\n            count++;\r\n        }\r\n        if(k>=count)\r\n        {\r\n            k%=count;\r\n        }\r\n        cur.next = head;\r\n        while(count-k>0)\r\n        {\r\n            pre = head;\r\n            head = head.next;\r\n            count--;\r\n        }\r\n        pre.next = null;\r\n        return head;\r\n    }\r\n}\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jyjsunny":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434348480","body":"import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.List;\n\n//import java.util.Scanner;\n\npublic class Solution {\n    //static int min = 100000000;\n\n    public static void main(String[] args){\n        //Scanner sc = new Scanner(System.in);\n        System.out.println(\"hello \");\n        String s = \"2[abc]3[cd]ef\";\n        //String s = \"3[a]2[bc]\";\n        decoder(s);\n       \n        //sc.close(); \n    }\n    public static String decoder(String s){\n\n        Deque<Integer> numStack  = new ArrayDeque<>();//??\n        Deque<Character> charStack = new ArrayDeque<>();\n        int len = s.length();\n        for(int i=0;i<len;i++){\n            char c = s.charAt(i);\n            if(isNumber(c)){//k计算\n                int num = c-'0';\n                while((i<(len-1))&&isNumber(s.charAt(i+1))){\n                    c=s.charAt(i+1);\n                    num*=10;\n                    num+=c-'0';\n                    i++;\n                }\n                numStack.push(num);\n            }\n            else{\n                if(c!=']')\n                    charStack.push(c);\n                else{\n                    int k = numStack.pollFirst();\n                    List<Character> tmp = new ArrayList<>();\n                    while(charStack.peek()!='['){\n                        char cc = charStack.pollFirst();\n                       tmp.add(cc); \n                    }\n                    //System.out.println(charStack.peek());\n                    charStack.pop();\n                    for(int j=0;j<k;j++){\n                        \n                        for(int p = tmp.size()-1;p>=0;p--){\n                            //System.out.print(tmp.get(p));\n                            charStack.push(tmp.get(p));\n                        }\n                    }\n                    \n                    \n                }\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        while(!charStack.isEmpty()){\n            sb.append(charStack.pollLast());\n        }\n        System.out.println(sb.toString());\n\n        return sb.toString();\n    }\n    public static boolean isNumber(char c){\n        return ((c-'0')>=0 && (c-'0')<=9)?true:false;\n    }\n\n    \n\n\n\n\n\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438528833","body":"## 思路\n\n-    方法一：设置pre和node，每两个点为一组表示关系、进行交换（看重链表性质以及构造逻辑）\n-    方法二：两点为一组，递归求解（利用递归特性）\n\n## 代码\n```\n//方法一：利用list逻辑\n    public static ListNode SwapList(ListNode node){\n        if(node==null||node.next==null)  return node;\n        ListNode newhead = node.next;\n        ListNode pre = new ListNode();\n        pre.next = node;\n\n        while(node!=null&&node.next!=null){\n            pre.next = node.next;\n            node.next = node.next.next;\n            pre.next.next = node;\n            pre = node;\n            node = pre.next;\n        }\n    \n        return newhead;\n    }\n//方法二：利用递归\n    public static ListNode SwapList(ListNode node){\n        //方法二：递归\n        //递归：1）终止条件，2）返回值，3）单步过程\n        //终止条件\n        if(node==null||node.next==null)\n        {\n            return node;\n        }\n        ListNode next = node.next;\n        //单步过程\n        node.next= SwapList(next.next);\n        next.next=node;\n        //返回值\n        return next;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aoxiangw":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/5#issuecomment-1434802798","body":"```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for i in range(len(s)):\r\n            if s[i] != \"]\":\r\n                stack.append(s[i])\r\n            else:\r\n                cur = \"\"\r\n                while stack[-1] != \"[\":\r\n                    cur = stack.pop() + cur\r\n                stack.pop()\r\n\r\n                k = \"\"\r\n                while stack and stack[-1].isdigit():\r\n                    k = stack.pop() + k\r\n                stack.append(cur * int(k))\r\n        return \"\".join(stack)\r\n```\r\n\r\nTime complexity: O(n)\r\nSpace complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435480497","body":"```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.input = []\r\n        self.output = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.input.append(x)\r\n\r\n    def pop(self) -> int:\r\n        self.peek()\r\n        return self.output.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.output:\r\n            while self.input:\r\n                self.output.append(self.input.pop())\r\n        return self.output[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return not self.input() and not self.output()\r\n```\r\nTime complexity: O(1)\r\nSpace complexity: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438635504","body":"```python\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        dummy = ListNode(0, head)\r\n        prev, cur = dummy, head\r\n        while cur and cur.next:\r\n            second = cur.next\r\n            nxt = cur.next.next\r\n            cur.next = nxt\r\n            second.next = cur\r\n            prev = cur\r\n            cur = nxt\r\n        return dummy.next\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"enrilwang":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435392513","body":"class MyQueue {\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n\r\n    public MyQueue() {\r\n        inStack = new LinkedList<Integer>();\r\n        outStack = new LinkedList<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n\r\n    private void in2out() {\r\n        while (!inStack.isEmpty()) {\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/11#issuecomment-1438574762","body":"{\r\npublic ListNode swapPairs(ListNode head) {\r\n    if(head == null || head.next == null){\r\n        return head;\r\n    }\r\n\r\n    ListNode temp = head.next;\r\n    head.next = swapPairs(temp.next);\r\n    temp.next = head;\r\n    return temp;\r\n}\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aswrise":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435639529","body":"class MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stack1.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack2)==0:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack2)==0:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        if len(self.stack1)==0 and len(self.stack2)==0:\n            return True\n        else:\n            return False","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aneureka":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/7#issuecomment-1435678098","body":"```cpp\r\n#include <stack>\r\n\r\nclass MyQueue {\r\npublic:\r\n    MyQueue() {\r\n    }\r\n    \r\n    void push(int x) {\r\n        in.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if (out.empty()) {\r\n            while (!in.empty()) {\r\n                out.push(in.top());\r\n                in.pop();\r\n            }\r\n        }\r\n        int peek = out.top();\r\n        out.pop();\r\n        return peek;\r\n    }\r\n    \r\n    int peek() {\r\n        if (out.empty()) {\r\n            while (!in.empty()) {\r\n                out.push(in.top());\r\n                in.pop();\r\n            }\r\n        }\r\n        return out.top();\r\n    }\r\n    \r\n    bool empty() {\r\n        return in.empty() && out.empty();\r\n    }\r\nprivate:\r\n    stack<int> in;\r\n    stack<int> out;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ljqchlsw":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/9#issuecomment-1435900397","body":"# 思路\nFor two adjacent chunks, the max value of left chunk must be less or equal to the min value of right chunk, if the the min value of right chunk was less than the max value of left chunk, we should merge those two chunks into one, greedy technique to merge chunks to get max chunks! To achieve this, we have to record the max value of the previous chunks and compare them with the current chunk(aka. a single number) so that we can either merge them or append a new chunk, in this case stack is the best data structure to be applied here. We save max values of all chunks with a stack, the final result is the size of this stack!\n\n# 代码\n~~~\npublic int maxChunksToSorted(int[] arr) {\n    Deque<Integer> stack = new ArrayDeque<>();\n    for (int num : arr) {\n        int curMax = num;\n        while (!stack.isEmpty() && stack.peek() > num) {\n            curMax = Math.max(stack.pop(), curMax);\n        }\n        stack.push(curMax);\n    }\n    return stack.size();\n}\n~~~\n# 复杂度\nTime complexity: O(n), space complexity: O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441359476","body":"# 思路\nlen(A) = a + c, len(B) = b + c, 两指针分别从A， B开始遍历A和B， B和A， a + c + b = b + c + a, 会在交点相遇，若c==0, 即无交点时，两指针同时到达null\n# 复杂度\ntime: O(m + n), space O(1)\n# 代码\n~~~\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA;\n        ListNode b = headB;\n\n        while (a != b) {\n            if (a != null) {\n                a = a.next;\n            } else {\n                a = headB;\n            }\n            if (b != null) {\n                b = b.next;\n            } else {\n                b = headA;\n            }\n        }\n\n        return a;\n    }\n~~~","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jingyuzhou123":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437029993","body":"```javascript\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    let res = cur.next;\n    cur.next = null;\n    return res;\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dianlandu":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437064730","body":"**思路**\r\n倒数第 k 个 = 正数第 length - k % length 个\r\n\r\n**代码**\r\n```\r\n//链表长度计算\r\nint getLen(struct ListNode* head){\r\n    struct ListNode* p = head;\r\n    int len = 1;\r\n    while(p->next){\r\n        p = p->next;\r\n        ++len;\r\n    }\r\n    return len;\r\n}\r\n\r\nstruct ListNode* rotateRight(struct ListNode* head, int k){\r\n    if(!head || !head->next){\r\n        return head;\r\n    }\r\n\r\n    int len = getLen(head);\r\n    int gap = len - k % len;  //gap为倒数第几个，从gap处断开，方便后续拼接\r\n    struct ListNode *dummy = malloc(sizeof(struct ListNode)), *p = head, *q = p;\r\n    dummy->next = head;\r\n\r\n    for(int i = 1; i < gap; i++){\r\n        p = p->next;\t//找到倒数第k个的前一个结点，以便于修改操作\r\n    }\r\n    while(q->next){\r\n        q = q->next;    // 走到表尾\r\n    }\r\n    q->next = dummy->next;\t//表尾接到原表头\r\n    dummy->next = p->next;\t//原表头变为倒数第k个结点\r\n    p->next = NULL;\t\t\t//最后元素指空\r\n\r\n    return dummy->next;\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jameswangxin":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437071099","body":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (!head) return nullptr;\n        int len = 0;\n        auto dummy = new ListNode(-1);\n        dummy->next = head;\n        auto p = head;\n        while (p) {\n            len++;\n            p = p->next;\n        }\n        k %= len;\n        if (k == 0) return head;\n        p = head; auto q = head; //p是慢指针，q是快指针\n        while (k--) q = q->next;\n        while (q->next) {\n            p = p->next;\n            q = q->next;\n        }\n        auto temp = dummy->next;\n        dummy->next = p->next;\n        q->next = temp;\n        p->next = nullptr;\n        return dummy->next;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhenxied":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437092380","body":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) {\n            return null;\n        }\n        // ListNode pre = new ListNode(-1, head);\n        ListNode slow = head;\n        ListNode fast = head;\n        for (int i = 0; i < k; i++) {\n            if (fast.next == null) {\n                fast = head;\n            } else {\n                fast = fast.next;\n            }\n        }\n        if (slow == fast) {\n            return head;\n        }\n        while (fast.next != null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        ListNode res = slow.next;\n        slow.next = null;\n        fast.next = head;\n\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuozhouzhang":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437172999","body":"\nclass Solution:\n    def rotateRight(self, head, k):\n      \n        dummy = ListNode(0)\n        dummy.next = head\n        if head is None:\n            return None\n        \n        #先数链表有几个节点\n        i = head\n        count = 1\n        while i.next is not None:\n            i = i.next\n            count += 1\n        #抛掉重复的转圈,也算一种算法优化吧\n        k = k%count\n        if (k == 0) or count == 1:\n            return head\n        #把链表头尾连起来\n        i.next = head\n \n        #从dummy开始运动\n        i = dummy\n        #运动到新的链表的头的上一个节点\n        for _ in range(count - k):\n            i = i.next\n \n        j = i.next\n        i.next = None\n        return j","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shin-guid":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/10#issuecomment-1437227881","body":"## 代码\n\n```js\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    let res = cur.next;\n    cur.next = null;\n    return res;\n}\n```\n\n## 复杂度\n- 时间复杂度O（n），节点最多只遍历两遍。\n- 空间复杂度O(1)，未使用额外的空间。\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bochengwan":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-10-daily-check/issues/13#issuecomment-1441452347","body":"### 思路\r\n\r\n两个链表若有空链表，则不可能相交。假设A的相交前的长度为a，B的相交前长度为b，公共长度为c。a+c+b  = b+c+a。\r\n\r\n### 代码\r\n```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if(headA == null || headB == null ) return null;\r\n        ListNode pA = headA;\r\n        ListNode pB = headB;\r\n        while(pA!=pB) {\r\n            pA = pA == null? headB:pA.next;\r\n            pB = pB == null? headA:pB.next;\r\n        }\r\n        return pA;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(m+n)，其中 m,n 为链表A和链表B的长度。\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}